s:   Destroy the Log Object
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
Log :: ~Log()
{
    if(fInfoSet != FALSE)
    {
        if(FALSE == fIsUnicode)
        {
            if(WriteVar((PCHAR) NULL, LOG_DONE) != NO_ERROR)
            {
                LogPrintf(stderr, "ERROR: Failed to log \"%s\" status\n",
                          LOG_DONE_TXT);
            }
        }
        else
        {
            if(WriteVar((LPWSTR) NULL, LOG_DONE) != NO_ERROR)
            {
                LogPrintf(stderr, "ERROR: Failed to log \"%ls\" status\n",
                          wLOG_DONE_TXT);
            }
        }
        FreeLogging();          // Make sure memory is freed & file closed
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Info(int, char *[])
//
//  Synopsis:   Parse the command line and set the appropriate member variables
//
//  Arguments:  [argc] - Argument count
//              [argv] - Argument vector
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              30-Oct-92  SarahJ    Updated parms to SetInfo
//
//--------------------------------------------------------------------
ULONG Log :: Info(int argc, char *argv[])
{
    USHORT usNdx;               // Index into cmnd line args
    PCHAR  pszTest    = NULL;   // Name of this test
    PCHAR  pszSubPath = NULL;   // Users log file qualifer
    PCHAR  pszObject  = NULL;   // Name of invoking object
    PCHAR  pch;                 // Temporary pointer into a string


    InitLogging();

    // All the argv processing is still done in CHARs
    if(ulLastError == NO_ERROR)
    {
        //
        // For every command line switch, check its validity and parse its
        // value.  This version allows / or - for switches.  If there are
        // no command line switches, this loop is skipped.  This is for the
        // case when Log() is called with no messages.
        //

        for(usNdx = 1; usNdx < (unsigned short) argc; ++usNdx)
        {
            char *szArg = argv[ usNdx];
            pch = szArg;

            // check for / -

            if(*szArg == '/' || *szArg == '-')
            {
                register int i = 1;
                pch++;

                //
                // Check if next char is m, ie handed down from manager code.
                // If so skip m
                //

                if (*pch == 'm' || *pch == 'M')
                {
                    pch++;
                    i++;
                }

                ++pch;           // Skip next char and check for :

                if(*pch++ == ':')
                {
                    switch(toupper(szArg[i]))
                    {
                      case 'O':       // Object name found

                        pszObject = (PCHAR)pch;
                        break;

                      case 'P':       // Directory Path switch found

                        pszSubPath = (PCHAR)pch;
                        break;

                      case 'L':       // Logging server name found

                        fprintf(stderr, "Logging server not supported with "
                                "this version of log.lib. Continuing.\n");
                        break;

                      case 'T':       // Test name found

                        pszTest = (PCHAR)pch;
                        break;

                      default:        // Skip this unknown argument

                        break;
                    }
                }
            }
        }

        // If no test name was given, set pszTest to the apps base name.

        char szName[_MAX_FNAME];

        if(pszTest == NULL || *pszTest == NULLTERM)
        {
            _splitpath(argv[0], NULL, NULL, szName, NULL);
            pszTest = szName;
        }

        // Here is where the WCHAR additions are
        if(FALSE == fIsUnicode)
        {
            ulLastError = SetInfo(NULL, pszTest, pszSubPath, pszObject);
        }
        else
        {
            // Convert the PCHARs to LPWSTRs
            // This one is guaranteed to be set to something
            LPWSTR  wszTest    = MbNameToWcs(pszTest);
            LPWSTR  wszSubPath = MbNameToWcs(pszSubPath);
            LPWSTR  wszObject  = MbNameToWcs(pszObject);

            if(NO_ERROR == ulLastError)
            {
                ulLastError = SetInfo(NULL, wszTest, wszSubPath, wszObject);
            }

            delete wszTest;
            delete wszSubPath;
            delete wszObject;
        }

    }

    // This was not here before, but it seems the log should be opened by now
    if(NO_ERROR == ulLastError)
    {
        ulLastError = LogOpen() || (FALSE == fIsUnicode) ?
            WriteVar((PCHAR) NULL, LOG_START) :
            WriteVar((LPWSTR) NULL, LOG_START);

    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(PCHAR, USHORT, PCHAR, va_list)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [pszVar]    - Variation
//              [usStat]    - Status
//              [pszFormat] - Format string (like printf)
//              [vaArgs]    - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar method, renamed,
//                                   made to operate on va_lists.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(PCHAR   pszVar,
                          USHORT  usStat,
                          PCHAR   pszFormat,
                          va_list vaArgs)
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // verify that the status is in allowed range

            if(usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr,
                          "ERROR: Illegal status parameter %u for "
                          "Variation  %s\n",
                          usStat,
                          pszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            ulLastError =
                SetStrData(pszFormat, vaArgs) ||
                SetVariation((const char *)pszVar) ||
                SetStatus(aStatus[usStat]) ||
                SetBinData(0, (PVOID)NULL);

            if(ulLastError == NO_ERROR)
            {
                ulLastError = LogData();       // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(LPWSTR, USHORT, LPWSTR, va_list)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [wszVar]    - Variation
//              [usStat]    - Status
//              [wszFormat] - Format string (like printf)
//              [vaArgs]    - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar method, renamed,
//                                   made to operate on va_lists.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(LPWSTR  wszVar,
                          USHORT  usStat,
                          LPWSTR  wszFormat,
                          va_list vaArgs)
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // verify that the status is in allowed range

            if(usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr, L"ERROR: Illegal status parameter %u "
                          L"for Variation  %ls\n",
                          usStat, wszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            ulLastError = SetStrData(wszFormat, vaArgs)
                || SetVariation((LPCWSTR) wszVar)
                || SetStatus(waStatus[usStat])
                || SetBinData(0, (PVOID) NULL);

            if(ulLastError == NO_ERROR)
            {
                ulLastError = LogData();       // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(PCHAR, USHORT, PCHAR, ...)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [pszVar]    - Variation
//              [usStat]    - Status
//              [pszFormat] - Format string (like printf)
//              [...]       - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(PCHAR pszVar, USHORT usStat, PCHAR pszFormat, ...)
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if(pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteVarList(pszVar, usStat, pszFormat, pMarker);

    if(pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(LPWSTR, USHORT, LPWSTR, ...)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [wszVar]    - Variation
//              [usStat]    - Status
//              [wszFormat] - Format string (like printf)
//              [...]       - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(LPWSTR wszVar, USHORT usStat, LPWSTR wszFormat, ...)
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteVarList(wszVar, usStat, wszFormat, pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(PCHAR, USHORT, USHORT, PVOID, PCHAR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [pszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar, renamed, supports
//                                   va_list type now.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(PCHAR   pszVar,
                           USHORT  usStat,
                           USHORT  usBytes,
                           PVOID   pvData,
                           PCHAR   pszFormat,
                           va_list vaArgs )
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if (ulLastError == NO_ERROR)
    {
        if (fInfoSet)
        {
            // verify that the status is in allowed range

            if (usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr,
                          "ERROR: Illegal status parameter %u for "
                          "Variation  %s\n",
                          usStat,
                          pszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            // Note if pszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(pszFormat, vaArgs);

            if (ulLastError == NO_ERROR)
            {
                ulLastError = SetVariation((const char *) pszVar)
                    || SetStatus(aStatus[usStat])
                    || SetBinData(usBytes, pvData);

                if (ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();   // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(LPWSTR, USHORT, USHORT, PVOID,
//                                LPWSTR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [wszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar, renamed, supports
//                                   va_list type now.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(LPWSTR  wszVar,
                          USHORT  usStat,
                          USHORT  usBytes,
                          PVOID   pvData,
                          LPWSTR  wszFormat,
                          va_list vaArgs )
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // verify that the status is in allowed range

            if(usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr, L"ERROR: Illegal status parameter %u "
                          L"for Variation  %ls\n",
                          usStat, wszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            // Note if wszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(wszFormat, vaArgs);

            if(ulLastError == NO_ERROR)
            {
                ulLastError =
                    SetVariation((LPCWSTR) wszVar) ||
                    SetStatus(waStatus[usStat]) ||
                    SetBinData(usBytes, pvData);

                if(ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();   // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(PCHAR, USHORT, USHORT, PVOID, PCHAR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [pszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(PCHAR  pszVar,
                      USHORT usStat,
                      USHORT usBytes,
                      PVOID  pvData,
                      PCHAR  pszFormat,
                      ... )
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if(pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteVarList(pszVar,
                               usStat,
                               usBytes,
                               pvData,
                               pszFormat,
                               pMarker);

    if(pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(LPWSTR, USHORT, USHORT, PVOID, LPWSTR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [wszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(LPWSTR wszVar,
                      USHORT usStat,
                      USHORT usBytes,
                      PVOID  pvData,
                      LPWSTR wszFormat,
                      ... )
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteVarList(wszVar,
                               usStat,
                               usBytes,
                               pvData,
                               wszFormat,
                               pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(PCHAR, va_list)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pszFormat] - a printf-like format string
//              [vaArgs]    - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to work on a va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(PCHAR pszFormat, va_list vaArgs)
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if (ulLastError == NO_ERROR)
    {
        if (fInfoSet)
        {
            // Note if pszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(pszFormat, vaArgs);

            if (ulLastError == NO_ERROR)
            {
                ulLastError = LogData();        // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(LPWSTR, va_list)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [wszFormat] - a printf-like format string
//              [vaArgs]    - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to work on a va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(LPWSTR wszFormat, va_list vaArgs)
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // Note if wszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(wszFormat, vaArgs);

            if(ulLastError == NO_ERROR)
            {
                ulLastError = LogData();        // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(PCHAR, ...)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pszFormat] - a printf-like format string
//              [...]       - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(PCHAR pszFormat, ...)
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if (pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteDataList(pszFormat, pMarker);

    if (pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(LPWSTR, ...)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [wszFormat] - a printf-like format string
//              [...]       - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(LPWSTR wszFormat, ...)
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteDataList(wszFormat, pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(USHORT, PVOID, PCHAR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to support va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(USHORT  usBytes,
                           PVOID   pvData,
                           PCHAR   pszFormat,
                           va_list vaArgs)
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if (ulLastError == NO_ERROR)
    {
        if (fInfoSet)
        {
            // Set up to log the string data
            // Note if pszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(pszFormat, vaArgs);

            if (ulLastError == NO_ERROR)
            {
                // Set up to log the binary data

                ulLastError = SetBinData(usBytes, pvData);

                if (ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();    // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(USHORT, PVOID, LPWSTR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to support va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(USHORT  usBytes,
                           PVOID   pvData,
                           LPWSTR  wszFormat,
                           va_list vaArgs)
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // Set up to log the string data
            // Note if wszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(wszFormat, vaArgs);

            if(ulLastError == NO_ERROR)
            {
                // Set up to log the binary data

                ulLastError = SetBinData(usBytes, pvData);

                if(ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();    // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(USHORT, PVOID, PCHAR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(USHORT usBytes, PVOID  pvData, PCHAR  pszFormat, ...)
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if (pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteDataList(usBytes, pvData, pszFormat, pMarker);

    if (pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(USHORT, PVOID, LPWSTR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(USHORT usBytes, PVOID  pvData, LPWSTR wszFormat, ...)
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteDataList(usBytes, pvData, wszFormat, pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+----------------------------------------------------------------------------
//
//    Member:    Log::GetLogStats(), public
//
//    Synopsis:  returns _stLogStats structure inside log object
//
//    Effects:   Returns actual reference to the real thing.
//
//    Arguments: [out] LogStats& stStats  -  structure to fill in.
//
//    Returns:   nothing, except stStats now is value of structure.
//
//    Modifies:  stStats
//
//    History:   11 Jun 92   DonCl   first version
//
//    Notes:
//
//-----------------------------------------------------------------------------

VOID Log::GetLogStats(LogStats& stStats)
{
    stStats = _stLogStats;
}


//+-------------------------------------------------------------------
//
//  Function:   MbNametoWcs(PCHAR *)
//
//  Synopsis:   Given a pointer to a CHAR string, return a WCHAR copy
//
//  Arguments:  [pszName]  CHAR string to copy
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
LPWSTR Log :: MbNameToWcs(PCHAR pszName)
{
    LPWSTR wszName = NULL;
    if(pszName != NULL)
    {
        size_t sizLen = strlen(pszName);
        if((wszName = new WCHAR[sizLen + 1]) == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if (mbstowcs(wszName, pszName, sizLen) == (size_t)0)
            {
                delete[] wszName;
                ulLastError = ERROR_INVALID_DATA;
            }
            wszName[sizLen] = wNULLTERM;
        }
    }
    return wszName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\h\diswarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      diswarn.h
//
//  Contents:  Pragma's to disable specific warnings at W4
//             This file is included through the use of the 
//             COMPILER_WARNING macro in build make files.
//             EG see the comtools\comday.mk file.
//
//  History:   02-Aug-95        DaveY   Taken from CTOLEUI's killwarn.hxx
//
//
//--------------------------------------------------------------------------
#ifndef __DISWARN_H__
#define __DISWARN_H__

//
// NT groups overall disable warning in sdk\inc\warning.h
//

#ifndef _MAC
#include <warning.h>
#endif


//
//  Removal of these warnings is temporary.  The reason for being here
//  is that build removes these warnings from build.wrn.
//  BUGBUG These are here for now, until they can be investigated more.
//


#pragma warning(disable: 4001)
#pragma warning(disable: 4010)
#pragma warning(disable: 4056)
#pragma warning(disable: 4061)
#pragma warning(disable: 4100)
#pragma warning(disable: 4101)
#pragma warning(disable: 4102)
#pragma warning(disable: 4127)
#pragma warning(disable: 4135)
#pragma warning(disable: 4201)
#pragma warning(disable: 4204)
#pragma warning(disable: 4208)
#pragma warning(disable: 4509)
#pragma warning(disable: 4047)
#pragma warning(disable: 4022)
#pragma warning(disable: 4053)


// these mainly come from midl files
#pragma warning(disable: 4211)
#pragma warning(disable: 4152)

//
// Turn off: access-declarations are deprecated; member using-declarations 
// provide a better alternative
//
#pragma warning(disable: 4516)


// Turn off: non standard extension used: bit field types other than int
//
#pragma warning(disable: 4214)


// Turn off: unreferenced inline function has been removed
//
#pragma warning(disable: 4514)


// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.

#pragma warning(disable: 4201)


// Turn off: Macro not expanded
//
#pragma warning(disable: 4710)


// 'class' : copy constructor could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an copy  operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a copy constructor for the class.

#pragma warning(disable: 4511)


// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.

#pragma warning(disable: 4512)


#ifdef PPC

// Turn off for PPC only since PPC compiler doesn't get it right
// local variable may be used without having been initialized.
//
#pragma warning(disable: 4701)

#endif



#ifdef _MAC

// Turn off for _MAC only because it doesn't handle trigraphs in comments
// correctly
#pragma warning(disable: 4110)

// The Mac OS headers generate this
#pragma warning (disable: 4121)
#endif // _MAC

#endif  // __DISWARN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\h\uisift.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       uisift.h
//
//  Contents:   function declarations and macros for using sift code from C
//
//  History:    7-05-94   t-chripi   Created
//	   3-08-95   ericn       changed linkeage of C functions
//
//----------------------------------------------------------------------------

#ifndef __UISIFT_H__

#define __UISIFT_H__

//Sift success/error values

#define SIFT_NO_ERROR              0
#define SIFT_ERROR_BASE            10000
#define SIFT_ERROR_OUT_OF_MEMORY   (SIFT_ERROR_BASE+3)
#define SIFT_ERROR_INVALID_VALUE   (SIFT_ERROR_BASE+4)

#if defined(NOSIFT) || defined(WIN16) || defined(WIN32S) || (WIN32 == 200)

//  NULL out macros if Win16/Win32s/Chicago or NOSIFT is defined

#define UI_SIFT_INIT(name)
#define UI_SIFT_ON
#define UI_SIFT_OFF
#define UI_SIFT_DECLARE
#define UI_SIFT_DESTROY

#else   //  Win32 only

EXTERN_C VOID UiSiftDeclare(VOID** g_pptsoTestSift);
EXTERN_C VOID UiSiftInit(VOID** g_pptsoTestSift, LPCSTR lpProgName);
EXTERN_C VOID UiSiftOn(VOID** g_pptsoTestSift);
EXTERN_C VOID UiSiftOff(VOID** g_pptsoTestSift);
EXTERN_C VOID UiSiftDestroy(VOID** g_pptsoTestSift);

#define UI_SIFT_INIT(name) \
    UiSiftDeclare(&g_ptsoTestSift);          \
    UiSiftInit(&g_ptsoTestSift, (name))

#define UI_SIFT_ON \
    UiSiftOn(&g_ptsoTestSift)

#define UI_SIFT_OFF \
    UiSiftOff(&g_ptsoTestSift)

#define UI_SIFT_DECLARE             \
    VOID* g_ptsoTestSift

#define UI_SIFT_DESTROY \
    UiSiftDestroy(&g_ptsoTestSift)

#define SVR_SIFT_INIT(name) \
    SvrSiftInit((name))

#endif  // Win32

#endif  // __UISIFT_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\log\common.cxx ===
//+-------------------------------------------------------------------
//
//  File:       common.cxx
//
//  Contents:   The common methods for logsvr and the log sub-projects
//
//  Classes:    LOGCLASS  Actually, this is a macroname that is defined
//                          at compile time
//
//  Functions:  DelString(PCHAR *)
//              LOGCLASS ::InitLogging(VOID)
//              LOGCLASS ::FreeLogging(VOID)
//              LOGCLASS ::SetLogFile(VOID)
//              LOGCLASS ::AddComponent(PCHAR, PCHAR)
//              LOGCLASS ::SetEventCount(VOID)
//              LOGCLASS ::LogOpen(VOID)
//              LOGCLASS ::OpenLogFile(VOID)
//              LOGCLASS ::LogData(VOID)
//              LOGCLASS ::WriteToLogFile(VOID)
//              LOGCLASS ::WriteHeader(VOID)
//              LOGCLASS ::WriteBinItem(CHAR, PVOID, USHORT)
//              LOGCLASS ::CheckDir(PCHAR)
//              LOGCLASS ::NewString(PCHAR *, CPPSZ)
//              LOGCLASS ::SetInfo(CPPSZ, CPPSZ, CPPSZ, CPPSZ)
//              LOGCLASS ::SetStrData(PCHAR, va_list)
//              LOGCLASS ::CloseLogFile(VOID)
//              LOGCLASS ::SetBinData(USHORT, PVOID)
//              LOGCLASS ::LogPrintf(HANDLE, PCHAR, ...)
//              LOGCLASS ::FlushLogFile(USHORT)
//              LOGCLASS ::SetIsComPort(CPPSZ)
//              LOGCLASS ::LogEventCountVOID)
//
//  History:    26-Sep-90  DaveWi    Initial Coding
//              18-Oct-90  DaveWi    Redesigned to be #included in log.cxx
//                                   and logsvr.cxx.
//              25-Sep-91  BryanT    Converted to C 7.0
//              14-Oct-91  SarahJ    DCR 527 - changed WriteBinItem to not
//                                     pad length argument to fixed length
//              30-Oct-91  SarahJ    removed def for CCHMAXPATH
//              30-Oct-91  SarahJ    removed addition of 11 spaces after event
//                                    count for no purpose in LogEventCount
//              14-Nov-91  SarahJ    replaced code to pad the event count
//                                    with spaces as it has a purpose! Also
//                                    explained padding in comment with code.
//              09-Feb-92  BryanT    Win32 work and general cleanup.
//              16-Jul-92  DeanE     Added wchar string support by changing
//                                   vsprintf to w4vsprintf
//                                   BUGBUG - the above addition may still
//                                   not work because the string formed is
//                                   then processed by non wchar functions
//               1-Aug-92  DwightKr  Renamed CPCHAR as CPPSZ.  CPCHAR
//                                   conflicted with the 297 version of
//                                   windows.h
//              17-Sep-92  SarahJ    Bug fixes and memory usage improvements
//              30-Oct-92  Sarahj    Removed the use of pszTester from mn:
//                                   or elsewhere
//
//--------------------------------------------------------------------

#include <pch.cxx>
// BUGBUG Precompiled header does not work on Alpha for some unknown reason and
// so we temporarily remove it.
// #pragma hdrstop

VOID DelString(PCHAR  *psz);
VOID DelString(LPWSTR *wsz);


#define LOGCLASS Log


//
// The SEEK_TO macro takes two different arguments.  Either FILE_BEGIN
// which makes it seek to the beginning of the file or FILE_END where
// it seeks to the end.
//

#define SEEK_TO(n) \
((fIsComPort==FALSE && \
  ~0 == SetFilePointer(hLogFile,0,NULL,(n)) ? -1 : NO_ERROR))

#define COUNT_BUFLEN    12      // Buf len for logged data len buffer

#define SLASH_STRING  "\\"
#define wSLASH_STRING L"\\"

//+-------------------------------------------------------------------
//
//  Function:   DelString(PCHAR *)
//
//  Synopsis:   Given a pointer to a string, delete the memory if necessary
//               and set the pointer to NULL
//
//  Arguments:  [pszOrig]  Original string to delete
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
VOID DelString(PCHAR *pszOrig)
{
    if (*pszOrig != NULL)
    {
        delete *pszOrig;
        *pszOrig = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   DelString(LPWSTR *)
//
//  Synopsis:   Given a pointer to a string, delete the memory if necessary
//               and set the pointer to NULL
//
//  Arguments:  [wszOrig]  Original string to delete
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
VOID DelString(LPWSTR *wszOrig)
{
    if (*wszOrig != NULL)
    {
        delete *wszOrig;
        *wszOrig = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   wcNametoMbs(PCHAR *)
//
//  Synopsis:   Given a pointer to a WCHAR string, return a CHAR copy
//
//  Arguments:  [pwcName] - WCHAR string to copy
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
PCHAR LOGCLASS::wcNametombs(PWCHAR pwcName)
{
    PCHAR pszName = NULL;
    if (pwcName != NULL)
    {
        size_t sizLen = wcslen(pwcName);
        if ((pszName = new char[sizLen+1]) == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memset(pszName, 0, sizLen +1);
            if (wcstombs(pszName, pwcName, sizLen) == (size_t)0)
            {
                delete[] pszName;
                ulLastError = ERROR_INVALID_DATA;
            }
        }
    }
    return pszName;
}


//+-------------------------------------------------------------------
//
//  Class:      LOGCLASS  (Actually, this is a macroname that is defined
//                          at compile time)
//
//  Purpose:
//
//  Interface:
//
//  History:    ??-???-??  ???????? Created
//
//  Notes:      The macro LOGCLASS is set in 'makefile'.  The methods in
//              the file are used in the Log class and in the LogSvr class.
//              In the makefile for building the Log class library log.lib,
//              LOGCLASS is defined as "Log". In building logsvr.exe,
//              LOGCLASS is defined as "LogSvr".  This was done because the
//              original version of this code was developed under
//              Glockenspiel 1.x which does not support multiple inheritance
//              and the inheritance tree for the classes which Log and LogSvr
//              inherit are such that this was the best way to allow for
//              maintaining only one version of these methods.
//
//--------------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::InitLogging(VOID)
//
//  Synopsis:   Initialize the classes data members.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: InitLogging(VOID)
{
    pszLoggingDir = NULL;
    pszMachineName = NULL;
    pszObjectName = NULL;
    pszTestName = NULL;
    pszPath = NULL;
    pszStatus = NULL;
    pszVariation = NULL;
    pvBinData = NULL;
    pszStrData = NULL;
    pszLogFileName = NULL;

    wszLoggingDir = NULL;
    wszMachineName = NULL;
    wszObjectName = NULL;
    wszTestName = NULL;
    wszPath = NULL;
    wszStatus = NULL;
    wszVariation = NULL;
    wszStrData = NULL;
    wszLogFileName = NULL;

    fIsComPort = FALSE;
    fFlushWrites = FALSE;
    fInfoSet = FALSE;
    ulEventCount = 0L;
    ulEventTime = 0L;
    usBinLen = 0;
    hLogFile = INVALID_HANDLE_VALUE;
}

//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::FreeLogging(VOID)
//
//  Synopsis:   Reset existing Logging members back to initial state
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: FreeLogging()
{
    va_list vaDummy = LOG_VA_NULL;
    CloseLogFile();

    fIsComPort   = FALSE;
    fFlushWrites = FALSE;
    fInfoSet     = FALSE;

    if(FALSE == fIsUnicode)
    {
        SetLoggingDir((PCHAR) NULL);
        SetMachineName((PCHAR) NULL);
        SetObjectName((PCHAR) NULL);
        SetTestName((PCHAR) NULL);
        SetPath((PCHAR) NULL);
        SetStatus((PCHAR) NULL);
        SetVariation((PCHAR) NULL);
        SetStrData((PCHAR) NULL, vaDummy);
    }
    else
    {
        SetLoggingDir((LPWSTR) NULL);
        SetMachineName((LPWSTR) NULL);
        SetObjectName((LPWSTR) NULL);
        SetTestName((LPWSTR) NULL);
        SetPath((LPWSTR) NULL);
        SetStatus((LPWSTR) NULL);
        SetVariation((LPWSTR) NULL);
        SetStrData((LPWSTR) NULL, vaDummy);
    }

    ulEventCount   = 0L;
    ulEventTime    = 0L;

    SetBinData(0, NULL);

}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetLogFile(VOID)
//
//  Synopsis:   Combine the logging file name components into a full path
//              file name.  If this new file name is not the same as that
//              referenced by element pszLogFileName, switch to log data
//              into the file in this new name.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_PARAMETER
//              ERROR_NOT_ENOUGH_MEMORY
//               Any error from AddComponent, CheckDir, SetLogFileName,
//               or SetEventCount
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetLogFile()
{
    // if unicode, use the unicode version
    if(TRUE == fIsUnicode)
    {
        return wSetLogFile();
    }

    if (((pszLoggingDir != (PCHAR) NULL) &&
         (strlen(pszLoggingDir) > _MAX_PATH)) ||
        ((pszPath != NULL) && (strlen(pszPath) > _MAX_PATH)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    PCHAR pszNewFileName = new char[_MAX_PATH + 1];
    if(pszNewFileName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Are we going to log to a COM port?
    //

    if(SetIsComPort((const char *)pszLoggingDir) != FALSE)
    {
        fIsComPort = TRUE;             // Yes.
        strcpy(pszNewFileName, pszLoggingDir);
    }
    else
    {
        if(SetIsComPort((const char *)pszPath) != FALSE)
        {
            fIsComPort = TRUE;         // Yes, locally
            strcpy(pszNewFileName, pszPath);
        }
        else
        {
            //
            // No -
            // For each component of the new log file path, append it to the
            // root logging directory.  Make sure only one back-slash exists
            // between each appended path component.
            //

            if(pszLoggingDir != NULL && *pszLoggingDir != NULLTERM)
            {
                strcpy(pszNewFileName, pszLoggingDir);
            }
            else
            {
                *pszNewFileName = NULLTERM;
            }


            ulLastError =
                AddComponent(pszNewFileName, pszPath) ||
                AddComponent(pszNewFileName, pszTestName);

        }
    }

    //
    // The the new file name was successfully built, see if it the same as
    // the name of the currently open log file (if one is open).  If is not
    // the same file name, close the open one (if open) and open the new
    // logging file.  If the open is successful, save the name of the newly
    // opened file for the next time thru here.
    //
    // A later version of this method could be written to create a LRU queue
    // of some max number of open logging files.  This version just keeps one
    // file open at a time, closing it only to switch to a different log file.
    //

    if(ulLastError == NO_ERROR)
    {
        if(fIsComPort == FALSE)
        {
            strcat(pszNewFileName, (const char *)".LOG");
        }

        if((pszLogFileName == NULL) ||
           (hLogFile == INVALID_HANDLE_VALUE) ||
           _stricmp(pszNewFileName, pszLogFileName) != SAME)
        {
            CloseLogFile();     // Make sure it is really closed

            //
            // Make sure the directory part of the logging file name exists.
            // Make each sub-directory that does not exist, then open the
            // logging file.
            //

            ulLastError = CheckDir(pszNewFileName);

            if(ulLastError == NO_ERROR)
            {
                DWORD dwFlags = GENERIC_WRITE;

                if(fIsComPort == FALSE)
                {
                    dwFlags |= GENERIC_READ;
                }
                hLogFile = CreateFileA(pszNewFileName,
                                       dwFlags,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL, OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL, NULL);

                if(hLogFile == INVALID_HANDLE_VALUE)
                {
                    ulLastError = GetLastError();
                }
                else
                {
                    if(SEEK_TO(FILE_END) != NO_ERROR)
                    {
                        ulLastError = GetLastError();
                    }
                    else
                    {
                        ulLastError =
                            SetLogFileName((const char *) pszNewFileName) ||
                            SetEventCount();
                    }
                }
            }
        }
    }

    delete [] pszNewFileName;
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::wSetLogFile(VOID)
//
//  Synopsis:   Combine the logging file name components into a full path
//              file name.  If this new file name is not the same as that
//              referenced by element pszLogFileName, switch to log data
//              into the file in this new name.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_PARAMETER
//              ERROR_NOT_ENOUGH_MEMORY
//               Any error from AddComponent, CheckDir, SetLogFileName,
//               or SetEventCount
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: wSetLogFile()
{
    CHK_UNICODE(TRUE);

    if(((wszLoggingDir != NULL) &&
         (wcslen(wszLoggingDir) > _MAX_PATH)) ||
        ((wszPath != NULL) && (wcslen(wszPath) > _MAX_PATH)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    LPWSTR wszNewFileName = new WCHAR[_MAX_PATH + 1];
    if(wszNewFileName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Are we going to log to a COM port?
    //

    if(SetIsComPort((LPCWSTR) wszLoggingDir) != FALSE)
    {
        fIsComPort = TRUE;             // Yes.
        wcscpy(wszNewFileName, wszLoggingDir);
    }
    else
    {
        if(SetIsComPort((LPCWSTR) wszPath) != FALSE)
        {
            fIsComPort = TRUE;         // Yes, locally
            wcscpy(wszNewFileName, wszPath);
        }
        else
        {
            //
            // No -
            // For each component of the new log file path, append it to the
            // root logging directory.  Make sure only one back-slash exists
            // between each appended path component.
            //

            if(wszLoggingDir != NULL && *wszLoggingDir != wNULLTERM)
            {
                wcscpy(wszNewFileName, wszLoggingDir);
            }
            else
            {
                *wszNewFileName = wNULLTERM;
            }


            ulLastError = AddComponent(wszNewFileName, wszPath) ||
                AddComponent(wszNewFileName, wszTestName);
        }
    }

    //
    // The the new file name was successfully built, see if it the same as
    // the name of the currently open log file (if one is open).  If is not
    // the same file name, close the open one (if open) and open the new
    // logging file.  If the open is successful, save the name of the newly
    // opened file for the next time thru here.
    //
    // A later version of this method could be written to create a LRU queue
    // of some max number of open logging files.  This version just keeps one
    // file open at a time, closing it only to switch to a different log file.
    //

    if (ulLastError == NO_ERROR)
    {
        if(fIsComPort == FALSE)
        {
            wcscat(wszNewFileName, L".LOG");
        }

        if((wszLogFileName == NULL) || (hLogFile == INVALID_HANDLE_VALUE) ||
            _wcsicmp(wszNewFileName, wszLogFileName) != SAME)
        {
            CloseLogFile();     // Make sure it is really closed

            //
            // Make sure the directory part of the logging file name exists.
            // Make each sub-directory that does not exist, then open the
            // logging file.
            //

            ulLastError = CheckDir(wszNewFileName);

            if(ulLastError == NO_ERROR)
            {
                DWORD dwFlags = GENERIC_WRITE;

                if(fIsComPort == FALSE)
                {
                    dwFlags |= GENERIC_READ;
                }
                hLogFile = CreateFileW(wszNewFileName,
                                       dwFlags,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL, OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL, NULL);

                if(hLogFile == INVALID_HANDLE_VALUE)
                {
                    ulLastError = GetLastError();
                }
                else
                {
                    if(SEEK_TO(FILE_END) != NO_ERROR)
                    {
                        ulLastError = GetLastError();
                    }
                    else
                    {
                        ulLastError = SetLogFileName((LPCWSTR) wszNewFileName)
                            || SetEventCount();
                    }
                }
            }
        }
    }

    delete [] wszNewFileName;
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::AddComponent(PCHAR, PCHAR)
//
//  Synopsis:   Append a path component to the given string in szNewName.
//              Make sure there is one and only one '\' between each
//              component and no trailing '\' is present.
//
//  Arguments:  [szNewName]   - Pointer to exist path (must not be NULL)
//              [szComponent] - New component to add
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_NAME
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: AddComponent(PCHAR szNewName, PCHAR szComponent)
{
    CHK_UNICODE(FALSE);

    PCHAR pch = NULL;

    // Path component provided?

    if (szComponent != NULL && *szComponent != NULLTERM)
    {
        int nLen = strlen((const char *)szComponent);

        //
        // Trim trailing and leading '\'s from the component to be appended,
        // then append the component to the file name.
        //

        pch = szComponent + nLen;

        while (pch > szComponent)
        {
            if (*pch == SLASH)
            {
                *pch = NULLTERM;
                pch--;
            }
            else
            {
                break;
            }
        }
        pch = szComponent;

        while (*pch == SLASH)
        {
            pch++;
        }

        //
        // Append one '\' to the file name then append the given component.
        //

        if (strlen((const char *)szNewName) + nLen + 1 < _MAX_PATH)
        {
            nLen = strlen((const char *)szNewName);

            if (nLen > 0)
            {                               // Add component separater
                szNewName[ nLen++] = SLASH;
            }
            strcpy(&szNewName[nLen], (const char *)pch);
        }
        else
        {
            ulLastError = ERROR_INVALID_NAME;
        }
    }

    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::AddComponent(LPWSTR, LPWSTR)
//
//  Synopsis:   Append a path component to the given string in szNewName.
//              Make sure there is one and only one '\' between each
//              component and no trailing '\' is present.
//
//  Arguments:  [wszNewName]   - Pointer to exist path (must not be NULL)
//              [wszComponent] - New component to add
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_NAME
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: AddComponent(LPWSTR wszNewName, LPWSTR wszComponent)
{
    CHK_UNICODE(TRUE);

    LPWSTR wch = NULL;

    // Path component provided?

    if(wszComponent != NULL && *wszComponent != wNULLTERM)
    {
        int nLen = wcslen((LPWSTR) wszComponent);

        //
        // Trim trailing and leading backslash from the component to be
        // appended, then append the component to the file name.
        //

        wch = wszComponent + nLen;

        while(wch > wszComponent)
        {
            if(*wch == wSLASH)
            {
                *wch = wNULLTERM;
                wch--;
            }
            else
            {
                break;
            }
        }
        wch = wszComponent;

        while(*wch == wSLASH)
        {
            wch++;
        }

        //
        // Append one backslash to the file name then append the
        // given component.
        //

        if(wcslen(wszNewName) + nLen + 1 < _MAX_PATH)
        {
            nLen = wcslen(wszNewName);

            if(nLen > 0)
            {                               // Add component separater
                wszNewName[nLen++] = wSLASH;
            }
            wcscpy(&wszNewName[nLen], wch);
        }
        else
        {
            ulLastError = ERROR_INVALID_NAME;
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetEventCount(VOID)
//
//  Synopsis:   This version assumes the current event count is in ASCII
//              format at beginning of the file.  It is also assumed that
//              the value is in the range 0-65535 so it will fit in a small
//              buffer and in a USHORT.
//
//  Returns:    NO_ERROR if successful
//              Values from GetLastError() after CRT function is called
//              CORRUPT_LOG_FILE
//              ERROR_NOT_ENOUGH_MEMORY
//
//  Notes:      This should not need converting to unicode - dda
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetEventCount()
{
    //
    // If we're using a COM port, set the EventCount to 0 since
    // we can't read from it anyway
    //

    if(fIsComPort != FALSE)
    {
        ulEventCount = 0L;
        return NO_ERROR;
    }

    //
    // This version assumes the log file is a binary file, not normally
    // readable by the user without the LOGVIEWER utility.  It seeks to
    // the beginning of the file, reads into zsCount, translates szCount
    // to a ULONG, and seeks to the end.
    //

    if(SEEK_TO(FILE_BEGIN) != NO_ERROR)
    {
        ulLastError = GetLastError();
    }
    else
    {
        LONG lLen = GetFileSize(hLogFile, NULL);

        if(lLen == -1L)
        {
            ulLastError = GetLastError();
        }
        else if(lLen < MIN_LINE_HDR_LEN)
        {
            ulEventCount = 0L;         // The file has been newly created
        }
        else
        {
            PCHAR pszTmp = new CHAR[LINE_HDR_LEN+1];

            // Read the data line header

            if(pszTmp != NULL)
            {
                //
                // SarahJ - Event count is held in a ulong therefore its
                // maximum length as ascii will be 10 digits - and at this
                // point you have a mega file! This means that the maximum
                // length that the data can be is 2, and 99.9% of the time
                // will be 1. The below code depends on at most 2 chars being
                // used for the length.  First read MIN_LINE_HDR_LEN bytes
                // then read 1 more byte to find the :.
                //

                DWORD dwBytesRead;

                if(FALSE == ReadFile(hLogFile, (LPVOID) pszTmp,
                                     MIN_LINE_HDR_LEN, &dwBytesRead, NULL) ||
                   MIN_LINE_HDR_LEN != dwBytesRead)
                {
                    ulLastError = GetLastError();
                }
                else
                {
                    PCHAR pchTmp = &pszTmp[MIN_LINE_HDR_LEN - 1];
                    if(*pchTmp != ':')
                    {
                        if(FALSE == ReadFile(hLogFile, (LPVOID) pszTmp,
                                             1, &dwBytesRead, NULL) ||
                           1 != dwBytesRead)
                        {
                            ulLastError = GetLastError();
                        }
                    }
                    else if(*pchTmp != ':')
                    {
                        ulEventCount = 0L;
                    }
                    else
                    {
                        *pchTmp = NULLTERM;

                        // Get the # bytes in the event count value.  The line
                        // starts with x: where x is the LOG_EVENTS_ID
                        // ID character.

                        if(*pszTmp == LOG_EVENTS)
                        {
                            ULONG ulLen = (ULONG) atoi(&pszTmp[2]);

                            if(ulLen > 0)
                            {
                                PCHAR pszCount = new CHAR[ulLen + 1];

                                if(pszCount != NULL)
                                {
                                    // Read the event count value

                                    if(FALSE == ReadFile(hLogFile,
                                                         (LPVOID) pszTmp,
                                                         ulLen, &dwBytesRead,
                                                         NULL) ||
                                       ulLen != dwBytesRead)
                                    {
                                        ulLastError  = GetLastError();
                                        ulEventCount = 0L;
                                    }
                                    else
                                    {
                                        pszCount[ulLen] = NULLTERM;
                                        ulEventCount     = atol(pszCount);
                                    }
                                    delete pszCount;
                                }
                                else
                                {
                                    ulLastError  = ERROR_NOT_ENOUGH_MEMORY;
                                    ulEventCount = 0L;
                                }
                            }
                            else
                            {
                                ulEventCount = 0L;
                            }
                        }
                        else
                        {
                            ulLastError  = CORRUPT_LOG_FILE;
                            ulEventCount = 0L;
                        }
                    }
                    delete pszTmp;
                }
            }
            else
            {
                ulLastError  = ERROR_NOT_ENOUGH_MEMORY;
                ulEventCount = 0L;
            }
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogOpen(VOID)
//
//  Synopsis:   If we are not in the LogSvr and if logging remotly, try
//              to a START record to the server.  If not, or if the attempt
//              fails, log the data locally. This may require opening the
//              local log file.
//
//  Returns:    NO_ERROR if successful
//              Results from Remote(), SetLogFile(), or OpenLogFile()
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: LogOpen()
{
    if(hLogFile == INVALID_HANDLE_VALUE)
    {
        //
        // Something failed in the remote logging attempt, or this is our
        // first call to open the log file, so set up to log locally.
        //

        ulLastError = SetLogFile();

        if(ulLastError != NO_ERROR)
        {
            return ulLastError;    // Setup failed...  Don't go any further.
        }
    }

    return OpenLogFile();
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::OpenLogFile(VOID)
//
//  Synopsis:   This version assumes that SetLogFile has already been called.
//
//  Returns:    Value of GetLastError() if a CRT function fails otherwise,
//              return code from FlushLogFile()
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: OpenLogFile()
{
    long lLen;

    //
    // If the logging file is empty, write a header to the file and set the
    // event counter to zero.
    //

    if(fIsComPort == FALSE)
    {
        lLen = GetFileSize(hLogFile, NULL);

        if(lLen == -1L)
        {
            ulLastError = GetLastError();
            return ulLastError;
        }
    }
    else
    {
        lLen = 0L;
    }

    if(lLen < LINE_HDR_LEN)
    {
        if(SEEK_TO(FILE_BEGIN) != NO_ERROR)
        {
            ulLastError = GetLastError();
        }
        else
        {
            ulLastError = WriteHeader();
        }
    }
    return FlushLogFile(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogData(VOID)
//
//  Synopsis:   If logging remotely, try to send data to the server.  If
//              not, or if the attempt fails, log the data locally.  This
//              may require opening the local log file.
//
//  Returns:    Result from WriteToLogFile
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: LogData()
{
    if(hLogFile == INVALID_HANDLE_VALUE)
    {
        //
        // This is our first call to open the log file
        //

        ulLastError = SetLogFile();

        if(ulLastError != NO_ERROR)
        {
            return ulLastError; // Setup failed; Don't go any further.
        }
    }

    // Log file opened OK, so write the data
    return WriteToLogFile();
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::WriteToLogFile(VOID)
//
//  Synopsis:   Write data out to the log file.
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: WriteToLogFile()
{
    // use unicode method
    if(TRUE == fIsUnicode)
    {
        return wWriteToLogFile();
    }

    char chBuf[COUNT_BUFLEN];

    int cLen = sprintf(chBuf, "%lu", ulEventCount + 1);

    ulLastError = WriteBinItem(LOG_EVENT_NUM, (PVOID) chBuf, cLen);

    if(ulLastError == NO_ERROR)
    {
        //
        // If the event time has not already been set, set it to the
        // current system time.
        //

        cLen = sprintf(chBuf, "%lu", (ulEventTime==0L) ?
                       time((time_t *) NULL) : ulEventTime);

        ulLastError = WriteBinItem(LOG_EVENT_TIME,
                                   (PVOID) chBuf, strlen((const char *)chBuf))

            || WriteBinItem(LOG_MACHINE,
                            (PVOID) pszMachineName,
                            (pszMachineName == NULL) ?
                            0 : strlen((const char *)pszMachineName))

            || WriteBinItem(LOG_OBJECT,
                            (PVOID) pszObjectName,
                            (pszObjectName == NULL) ?
                            0 : strlen((const char *)pszObjectName))

            || WriteBinItem(LOG_VARIATION,
                            (PVOID) pszVariation,
                            (pszVariation == NULL) ?
                            0 : strlen((const char *)pszVariation))

            || WriteBinItem(LOG_STATUS,
                            (PVOID) pszStatus,
                            (pszStatus == NULL) ?
                            0 : strlen((const char *)pszStatus))

            || WriteBinItem(LOG_STRING,
                            (PVOID) pszStrData,
                            (pszStrData == NULL) ?
                            0 : strlen((const char *)pszStrData))
            || WriteBinItem(LOG_BINARY, pvBinData, usBinLen);

        if(ulLastError == NO_ERROR)
        {
            ++ulEventCount; // Increment the count of logged events

            if(pszStatus != NULL
               && strcmp(pszStatus, LOG_DONE_TXT) == SAME)
            {
                CloseLogFile();        // Make sure the data has been flushed
            }
        }
    }

    // Clean up in preparation for next packet

    va_list vaDummy = LOG_VA_NULL;
    SetStatus((PCHAR) NULL);
    SetVariation((PCHAR) NULL);
    ulEventTime = 0L;
    SetBinData(0, NULL);
    SetStrData((PCHAR) NULL, vaDummy);

    return FlushLogFile(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::wWriteToLogFile(VOID)
//
//  Synopsis:   Write data out to the log file.
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: wWriteToLogFile()
{
    CHK_UNICODE(TRUE);

    WCHAR wchBuf[COUNT_BUFLEN];

    int cLen = swprintf(wchBuf, L"%lu", ulEventCount + 1);

    ulLastError = WriteBinItem(LOG_EVENT_NUM, (PVOID) wchBuf,
                               cLen * sizeof(WCHAR));

    if(ulLastError == NO_ERROR)
    {
        //
        // If the event time has not already been set, set it to the
        // current system time.
        //

        cLen = swprintf(wchBuf, L"%lu", (ulEventTime==0L) ?
                        time((time_t *) NULL) : ulEventTime);

        ulLastError = WriteBinItem(LOG_EVENT_TIME,
                                   (PVOID) wchBuf,
                                   wcslen(wchBuf) * sizeof(WCHAR))

            || WriteBinItem(LOG_MACHINE,
                            (PVOID) wszMachineName,
                            (wszMachineName == NULL) ?
                            0 : wcslen(wszMachineName) * sizeof(WCHAR))

            || WriteBinItem(LOG_OBJECT,
                            (PVOID) wszObjectName,
                            (wszObjectName == NULL) ?
                            0 : wcslen(wszObjectName) * sizeof(WCHAR))

            || WriteBinItem(LOG_VARIATION,
                            (PVOID) wszVariation,
                            (wszVariation == NULL) ?
                            0 : wcslen(wszVariation) * sizeof(WCHAR))

            || WriteBinItem(LOG_STATUS,
                            (PVOID) wszStatus,
                            (wszStatus == NULL) ?
                            0 : wcslen(wszStatus) * sizeof(WCHAR))

            || WriteBinItem(LOG_STRING,
                            (PVOID) wszStrData,
                            (wszStrData == NULL) ?
                            0 : wcslen(wszStrData) * sizeof(WCHAR))

            || WriteBinItem(LOG_BINARY, pvBinData, usBinLen);

        if(ulLastError == NO_ERROR)
        {
            ++ulEventCount; // Increment the count of logged events

            if(wszStatus != NULL &&
               wcscmp(wszStatus, wLOG_DONE_TXT) == SAME)
            {
                CloseLogFile();        // Make sure the data has been flushed
            }
        }
    }

    // Clean up in preparation for next packet

    va_list vaDummy = LOG_VA_NULL;

    SetStatus((LPWSTR) NULL);
    SetVariation((LPWSTR) NULL);
    ulEventTime = 0L;
    SetBinData(0, NULL);
    SetStrData((LPWSTR) NULL, vaDummy);

    return FlushLogFile(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::WriteHeader(VOID)
//
//  Synopsis:   Write data about this logging file.  This only happens
//              when the file is first created.
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: WriteHeader()
{
    LogEventCount();

    if (ulLastError == NO_ERROR)
    {
        if(FALSE == fIsUnicode)
        {
            ulLastError = WriteBinItem(LOG_TEST_NAME, (PVOID) pszTestName,
                                       (pszTestName == NULL) ?
                                       0 : strlen(pszTestName));

            if (ulLastError == NO_ERROR)
            {
                char chBuf[COUNT_BUFLEN];

                // Show when log file was started

                int cLen = sprintf(chBuf, "%lu", time((time_t *)NULL));

                ulLastError =
                    WriteBinItem(LOG_TEST_TIME, (PVOID) chBuf, cLen) ||
                    WriteBinItem(LOG_SERVER, (PVOID) NULL, 0);
            }
        }
        else
        {
            ulLastError = WriteBinItem(LOG_TEST_NAME, (PVOID) wszTestName,
                                       (wszTestName == NULL) ? 0 :
                                       wcslen(wszTestName) * sizeof(WCHAR));

            if (ulLastError == NO_ERROR)
            {
                WCHAR wchBuf[COUNT_BUFLEN];

                // Show when log file was started

                int cLen = swprintf(wchBuf, L"%lu", time((time_t *)NULL));

                ulLastError =
                    WriteBinItem(LOG_TEST_TIME, (PVOID) wchBuf,
                                 cLen * sizeof(WCHAR)) ||
                    WriteBinItem(LOG_SERVER, (PVOID) NULL, 0);
            }
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::WriteBinItem(CHAR, PVOID, ULONG)
//
//  Synopsis:   Attempt to write Binary data to the log file
//
//  Arguments:  [chMark]     The Item ID for the data
//              [pvItem]     Pointer to the data data
//              [ulItemLen]  Length of data to write
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              19-Sep_92  SarahJ    Changed length to be ULONG so
//                                   Data 32K can be written (note
//                                   with header stuff it is > 32K)
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: WriteBinItem(CHAR chMark,
                               PVOID  pvItem,
                               ULONG ulItemLen)
{
    if(fIsComPort != FALSE && chMark == LOG_BINARY)
    {
        return NO_ERROR;       // Do not send binary data to a COM port
    }

    //
    // Write everything at the end of the file except for the # events in
    // the file.
    //

    if(SEEK_TO((chMark == LOG_EVENTS)? FILE_BEGIN : FILE_END) != NO_ERROR)
    {
        ulLastError = GetLastError();
        return ulLastError;
    }

    CHAR szLen[LINE_HDR_LEN+1];

    //
    // Every field of data starts with a header of the form 'x:nnnnn:' where
    // 'x'   is the given ID char and nnnnn is the # of bytes of data.
    //

    int nLen = sprintf(szLen, "%c:%u:", chMark, ulItemLen);


    //
    // SarahJ - changed to not pad the number out to LINE_HDR_LEN -3, but to
    // use minimum # of digits as per DCR 527
    //

    // We do not have to check dwBytesWritten because WriteFile will
    // fail on a file if all bytes not written.
    DWORD dwBytesWritten;

    if(FALSE == WriteFile(hLogFile, (CONST LPVOID) szLen, nLen,
                          &dwBytesWritten, NULL))
    {
        ulLastError = GetLastError();
        return ulLastError;
    }

    if(ulItemLen > 0 && ulLastError == NO_ERROR)
    {
        if(FALSE == WriteFile(hLogFile, (CONST LPVOID) pvItem, ulItemLen,
                              &dwBytesWritten, NULL))
        {
            ulLastError = GetLastError();
            return ulLastError;
        }
    }

    // Every field of data ends with a '\n'

    if(FALSE == WriteFile(hLogFile, (CONST LPVOID) "\n", sizeof(CHAR),
                          &dwBytesWritten, NULL))
    {
        ulLastError = GetLastError();
    }

    // carriage return for com port
    if(fIsComPort == TRUE &&
       FALSE == WriteFile(hLogFile, (CONST LPVOID) "\r", sizeof(CHAR),
                          &dwBytesWritten, NULL))
    {
        ulLastError = GetLastError();
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::CheckDir(PCHAR)
//
//  Synopsis:   Make sure each subdirectory in the given path exists.
//
//  Arguments:  [pszRelPath]  - Pathname to check, relative to
//                              current directory
//
//  Returns:    NO_ERROR if the the directory does exist or was
//              successfully made. A GetLastError() value otherwise.
//
//
//
//  Modifies:
//
//  History:     ??-???-??  ????????  Created
//       92-Apr-17  DwightKr  Added EINVAL to _mkdir() check.  We'll
//                            get this back on the N386 compiler if
//                            the directory already exists
//       01-Jul-92  Lizch     Gutted routine to use much simpler ctcopy code
//                            courtesy of DwightKr
//
//       16-Sep-92  SarahJ    Added check that _fullpath does not return NULL
//                            to fix bug 300
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: CheckDir(PCHAR pszRelPath)
{
    CHK_UNICODE(FALSE);

    char *pszToken;
    char *pszFileName;
    char pszPath[_MAX_PATH];
    char szDirToMake[_MAX_PATH] = "\0";

    if(fIsComPort != FALSE)
    {
        return NO_ERROR;       // COM port directories are an oxymoran.
    }

    if(0 != GetFullPathNameA(pszRelPath, _MAX_PATH - 1, pszPath, &pszFileName))
    {

#ifdef TRACE
        printf("Making directory %s\n", pszPath);
#endif

        // First, we need to remove the filename off the
        // end of the path so we do not create a dir with it! Look for
        // the last backslash. It is either at the end (no file - error),
        // the beginning (file at root - error), somewhere in between, or
        // not at all.
        if(NULL == (pszFileName = strrchr(pszPath, '\\')) ||
           pszFileName == pszPath ||
           '\0' == *(pszFileName + 1))
        {
            *pszPath = '\0';
        }
        else
        {
            *pszFileName = '\0';
        }

        // Just blindly create directories based on the backslashes parsed
        // by strtok. We will look at the return from GetLastError to
        // if we were successful at the end.

        pszToken = strtok(pszPath, SLASH_STRING);
        while(pszToken != NULL)
        {
            strcat(szDirToMake, pszToken);

            if(CreateDirectoryA(szDirToMake, NULL) == TRUE)
            {
#ifdef TRACE
                printf ("Made directory %s\n", szDirToMake);
#endif
                ulLastError = NO_ERROR;
            }
            else
            {
#ifdef TRACE
                printf("Didn't make directory %s\n", szDirToMake);
#endif
                ulLastError = GetLastError();
            }

            pszToken = strtok(NULL, SLASH_STRING);
            if(pszToken != NULL)
            {
                strcat(szDirToMake, SLASH_STRING);
            }
        }

        // Leave error checking until we have tryed to add all directories -
        // we might as well simply check whether the final addition worked.
        // At this point, if the error return indicates the path already
        // exists as a directory or file, we need to error out if it is
        // actually a file.

        if(ulLastError == ERROR_FILE_EXISTS ||
           ulLastError == ERROR_ACCESS_DENIED ||
           ulLastError == ERROR_ALREADY_EXISTS)
        {
            DWORD dwAttr;

            // Now check if it is a directory, in which case we are OK, else if
            // it is a file we need to error out.

            if(~0 == (dwAttr = GetFileAttributesA(szDirToMake)))
            {
                ulLastError = GetLastError();
            }
            else
            {
                if(FILE_ATTRIBUTE_DIRECTORY == dwAttr)
                {
#ifdef TRACE
                    printf ("Path already existed - success!\n");
#endif
                    ulLastError = NO_ERROR;
                }
            }
        }
    }
    else  // GetFullPathName failed
    {
         ulLastError = GetLastError();
         fprintf(stderr, "Bad relative path %s\n", pszRelPath);
#ifdef DBG
         *szDirToMake = '\0';    // just done for below error message
#endif
    }

#ifdef DBG
    if(ulLastError != NO_ERROR)
    {
        fprintf(stderr, "Fatal error making logging directory:\n\t\t %s.\n"
                "Error %u.\n", szDirToMake, ulLastError);
    }
#endif
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::CheckDir(LPWSTR)
//
//  Synopsis:   Make sure each subdirectory in the given path exists.
//
//  Arguments:  [wszRelPath]  - Pathname to check, relative to
//                              current directory
//
//  Returns:    NO_ERROR if the the directory does exist or was
//              successfully made. An GetLastError() value otherwise.
//
//
//
//  Modifies:
//
//  History:     ??-???-??  ????????  Created
//       92-Apr-17  DwightKr  Added EINVAL to _mkdir() check.  We'll
//                            get this back on the N386 compiler if
//                            the directory already exists
//       01-Jul-92  Lizch     Gutted routine to use much simpler ctcopy code
//                            courtesy of DwightKr
//
//       16-Sep-92  SarahJ    Added check that _fullpath does not return NULL
//                            to fix bug 300
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: CheckDir(LPWSTR wszRelPath)
{
    CHK_UNICODE(TRUE);

    LPWSTR wszFileName;
    LPWSTR wszToken;
    WCHAR  wszPath[_MAX_PATH];
    WCHAR  wszDirToMake[_MAX_PATH] = L"\0";

    if(fIsComPort != FALSE)
    {
        return NO_ERROR;       // COM port directories are an oxymoran.
    }

    // check good directory name - is the NULL valid??
    if(0 != GetFullPathNameW(wszRelPath, _MAX_PATH - 1, wszPath, NULL))
    {

#ifdef TRACE
        printf("Making directory %ls\n", wszPath);
#endif

        // First, we need to remove the filename off the
        // end of the path so we do not create a dir with it! Look for
        // the last backslash. It is either at the end (no file - error),
        // the beginning (file at root - error), somewhere in between, or
        // not at all.
        if(NULL == (wszFileName = wcsrchr(wszPath, '\\')) ||
           wszFileName == wszPath ||
           '\0' == *(wszFileName + 1))
        {
            *wszPath = '\0';
        }
        else
        {
            *wszFileName = '\0';
        }

        // Just blindly create directories based on the backslashes parsed
        // by wcstok. We will look at the return from GetLastError to
        // if we were successful at the end.

        wszToken = wcstok(wszPath, wSLASH_STRING);
        while(wszToken != NULL)
        {
            wcscat(wszDirToMake, wszToken);

            if(CreateDirectoryW(wszDirToMake, NULL) == TRUE)
            {
#ifdef TRACE
                fprintf(stderr, "Made directory %ls\n", wszDirToMake);
#endif
                ulLastError = NO_ERROR;
            }
            else
            {
#ifdef TRACE
                fprintf(stderr, "Didn't make directory %ls\n", wszDirToMake);
#endif
                ulLastError = GetLastError();
            }

            wszToken = wcstok(NULL, wSLASH_STRING);
            if(wszToken != NULL)
            {
                wcscat(wszDirToMake, wSLASH_STRING);
            }
        }

        // Leave error checking until we have tryed to add all directories -
        // we might as well simply check whether the final addition worked.
        // At this point, if the error return indicates the path already
        // exists as a directory or file, we need to error out if it is
        // actually a file.

        if(ulLastError == ERROR_FILE_EXISTS ||
           ulLastError == ERROR_ALREADY_EXISTS)
        {
            DWORD dwAttr;

            // Now check if it is a directory, in which case we are OK, else if
            // it is a file we need to error out.

            if(~0 == (dwAttr = GetFileAttributesW(wszDirToMake)))
            {
                ulLastError = GetLastError();
            }
            else
            {
                if(FILE_ATTRIBUTE_DIRECTORY == dwAttr)
                {
#ifdef TRACE
                    fprintf(stderr, "Path already existed - success!\n");
#endif
                    ulLastError = NO_ERROR;
                }
            }
        }
    }
    else  // GetFullPathName failed
    {
         ulLastError = GetLastError();
         fprintf(stderr, "Bad relative path %ls\n", wszRelPath);
#ifdef DBG
         *wszDirToMake = L'\0';    // just done for below error message
#endif
    }

#ifdef DBG
    if(ulLastError != NO_ERROR)
    {
        fprintf(stderr, "Fatal error making logging directory:\n\t\t %ls.\n"
                "Error %u.\n", wszDirToMake, ulLastError);
    }
#endif
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::NewString(PCHAR *, const char *)
//
//  Synopsis:   This method will delete the existing string if it exists,
//              and (if a new string is given) will create and return a
//              duplicate string.
//              The assumption, here, is that the original pointer was
//              properly initialized to NULL prior to calling this method
//              the firsttime for that original string.
//
//  Arguments:  [pszOrig]   - The original string
//              [pszNewStr] - The new and improved string
//
//  Returns:    Returns NULL if 'new' fails or if pszNew is NULL.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: NewString(PCHAR *pszOrig, const char * pszNewStr)
{
    CHK_UNICODE(FALSE);

    DelString(pszOrig);

    // If a new string was given, duplicate it.

    if(pszNewStr != NULL)
    {
        *pszOrig = new char[strlen(pszNewStr) + 1];
        if(*pszOrig == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            strcpy(*pszOrig, pszNewStr);
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::NewString(LPWSTR *, LPCWSTR)
//
//  Synopsis:   This method will delete the existing string if it exists,
//              and (if a new string is given) will create and return a
//              duplicate string.
//              The assumption, here, is that the original pointer was
//              properly initialized to NULL prior to calling this method
//              the firsttime for that original string.
//
//  Arguments:  [wszOrig]   - The original string
//              [wszNewStr] - The new and improved string
//
//  Returns:    Returns NULL if 'new' fails or if pszNew is NULL.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: NewString(LPWSTR *wszOrig, LPCWSTR wszNewStr)
{
    CHK_UNICODE(TRUE);

    DelString(wszOrig);

    // If a new string was given, duplicate it.

    if(wszNewStr != NULL)
    {
        *wszOrig = new WCHAR[wcslen(wszNewStr) + 1];
        if(*wszOrig == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(*wszOrig, wszNewStr);
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetInfo(const char *, const char *,
//                             const char *, const char *)
//
//  Synopsis:   Set the logging information about the test being run.
//              User is set to pszTest OR logged on username OR MY_NAME in
//              that order of preference.
//              Machinename is set to computername OR MY_NAME in
//              that order of preference.
//
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of the test being run
//              [pszSubPath] - Log file path qualifier
//              [pszObject]  - Name of object logging the data
//
//  Returns:    USHORT - NO_ERROR (NO_ERROR) if successful.  Otherwise,
//                       the return value from SetTestName,
//                       SetTester, SetPath, or SerObjectName.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              09-Feb-92  BryanT    Added Win32 support
//              01-Jul-92  Lizch     Fixed bug where testername was getting
//                                   overwritten if machinename not set.
//              30-Jul-92  SarahJ    Fixed memory trashing bug - SetTester
//                                   & SetmachineName were trashing environment
//                                   variables
//              30-Oct-92  SarahJ    Removed all signs of pszTester - it
//                                   was only mis-used
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetInfo(const char * pszSrvr,
                          const char * pszTest,
                          const char * pszSubPath,
                          const char * pszObject)
{
    CHK_UNICODE(FALSE);

//BUGBUG Temp code
LPSTR pszTempMachineName = "MyMachineName";
    ulLastError =
        SetTestName(pszTest)   ||
        SetPath(pszSubPath)    ||
        SetObjectName(pszObject);

    if(ulLastError != NO_ERROR)
    {
        return ulLastError;
    }

    if(pszMachineName == NULL)
    {
        //
        // Get network computername.  The computername field
        // is used for pszMachineName
        //

#if defined (__WIN32__) || defined (WIN32)

        LPBYTE lpbBuffer = NULL;
/* BUGBUG
        PCHAR pszName;
*/
        //
        // Then, get the machine name, if not already set.
        //

        if(pszMachineName == NULL)
        {
// BUGBUG  Temporary code
            SetMachineName(pszTempMachineName);
// BUGBUG  End of temporary code

/* BUGBUG
            if(NERR_Success == NetWkstaGetInfo(NULL, 101, &lpbBuffer))
            {
                pszName =
                    wcNametombs((PWCHAR) ((PWKSTA_INFO_101)lpbBuffer)->
                                wki101_computername);
                SetMachineName(pszName);
                NetApiBufferFree(lpbBuffer);
                delete pszName;
            }
*/
        }

#else

/* BUGBUG
        USHORT usAvail = 0;

        USHORT usRC = NetWkstaGetInfo(NULL, 10, NULL, 0, &usAvail);

        if(usRC == NERR_BufTooSmall && usAvail > 0)
        {
            PCHAR pchBuf = (PCHAR)new CHAR[usAvail];

            if(pchBuf != NULL)
            {
                usRC = NetWkstaGetInfo(NULL, 10, pchBuf, usAvail, &usAvail);

                if(usRC == NO_ERROR)
                {
                    if(pszMachineName == NULL)
                    {
                        SetMachineName(((struct wksta_info_10 *)
                                        pchBuf)->wki10_computername);
                    }
                }
                delete pchBuf;
            }
        }
*/
// BUGBUG  Temporary code
            SetMachineName(pszTempMachineName);
// BUGBUG  End of temporary code
#endif          // defined (__WIN32__) || (WIN32)

        if(pszMachineName == NULL)
        {
            fprintf(stderr, "ERROR! machine name not set\n");
        }
    }

    if(ulLastError == NO_ERROR)
    {
        fInfoSet = TRUE;        // Note that info has been set
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetInfo(LPCWSTR, LPCWSTR,
//                             LPCWSTR, LPCWSTR)
//
//  Synopsis:   Set the logging information about the test being run.
//              User is set to pszTest OR logged on username OR MY_NAME in
//              that order of preference.
//              Machinename is set to computername OR MY_NAME in
//              that order of preference.
//
//
//  Arguments:  [wszSrvr]    - Name of logging server
//              [wszTest]    - Name of the test being run
//              [wszSubPath] - Log file path qualifier
//              [wszObject]  - Name of object logging the data
//
//  Returns:    USHORT - NO_ERROR (NO_ERROR) if successful.  Otherwise,
//                       the return value from SetTestName,
//                       SetTester, SetPath, or SerObjectName.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              09-Feb-92  BryanT    Added Win32 support
//              01-Jul-92  Lizch     Fixed bug where testername was getting
//                                   overwritten if machinename not set.
//              30-Jul-92  SarahJ    Fixed memory trashing bug - SetTester
//                                   & SetmachineName were trashing environment
//                                   variables
//              30-Oct-92  SarahJ    Removed all signs of pszTester - it
//                                   was only mis-used
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetInfo(LPCWSTR wszSrvr,
                          LPCWSTR wszTest,
                          LPCWSTR wszSubPath,
                          LPCWSTR wszObject)
{
    CHK_UNICODE(TRUE);

    ulLastError =
        SetTestName(wszTest)   ||
        SetPath(wszSubPath)    ||
        SetObjectName(wszObject);

    if(ulLastError != NO_ERROR)
    {
        return ulLastError;
    }

    if(wszMachineName == NULL)
    {
        //
        // Get network computername.  The computername field
        // is used for pszMachineName
        //

#if defined (__WIN32__) || defined (WIN32)

/* BUGBUG
        LPBYTE lpbBuffer;

        //
        // Then, get the machine name, if not already set.
        //

        if(wszMachineName == NULL)
        {
            if(NERR_Success == NetWkstaGetInfo(NULL, 101, &lpbBuffer))
            {
                SetMachineName((LPWSTR) (((PWKSTA_INFO_101)lpbBuffer)->
                                         wki101_computername));
                NetApiBufferFree(lpbBuffer);
            }
        }
*/

#else

        USHORT usAvail = 0;

// BUGBUG
//        USHORT usRC = NetWkstaGetInfo(NULL, 10, NULL, 0, &usAvail);

        if(usRC == NERR_BufTooSmall && usAvail > 0)
        {
            LPWSTR wchBuf = new WCHAR[usAvail];

            if(wchBuf != NULL)
            {
// BUGBUG
//                usRC = NetWkstaGetInfo(NULL, 10, pchBuf, usAvail, &usAvail);

                if(usRC == NO_ERROR)
                {
                    if(wszMachineName == NULL)
                    {
                        SetMachineName(((struct wksta_info_10 *)
                                        pchBuf)->wki10_computername);
                    }

                }
                delete wchBuf;
            }
        }
#endif          // defined (__WIN32__) || (WIN32)


        if(wszMachineName == NULL)
        {
            fprintf(stderr, "ERROR! machine name not set\n");
        }

    }

    if(ulLastError == NO_ERROR)
    {
        fInfoSet = TRUE;        // Note that info has been set
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetStrData(PCHAR, va_list)
//
//  Synopsis:   Set the string information that is to be logged.
//
//  Effects:    Create a temporary buffer for the formatted string, format
//              the string and copy the new formated string to pszStrData.
//              This version limits the formatted string to STRBUFSIZ chars.
//              See LOG.H for STRBUFSIZ value.  The only check I know how
//              to make is to strlen the format string.  It not a fool-proof
//              check but it's better than nothing...
//
//  Arguments:  [pszFmt]  - Format to use for writing the string (printf-like)
//              [pArgs]   - Arguments to print
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ     changed code to use _vsnprintf
//                                   so that we allocate 1K first
//                                   if that is too small then 32K
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetStrData(PCHAR pszFmt, va_list pArgs)
{
    CHK_UNICODE(FALSE);

    if (pszFmt == NULL || *pszFmt == NULLTERM)
    {
        NewString(&pszStrData, NULL);
    }
    else
    {
        //
        //   Start off by allocating 1K
        //
        PCHAR szTmpBuf = new CHAR[STDSTRBUFSIZ];
        if (szTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //  note _vsnprintf returns -1 if szTmpBuf gets more than 1K

            int iLen;
            if ((iLen = _vsnprintf(szTmpBuf,
                                   STDSTRBUFSIZ - 1,
                                   pszFmt,
                                   pArgs)) >= 0)
            {
                ulLastError = NewString(&pszStrData, (const char *)szTmpBuf);
            }
            else if (iLen == -1)
            {
            //
            // So we have more than 1K data, so lets leap to allocating 32K
            //
                delete [] szTmpBuf;
                szTmpBuf = new CHAR[HUGESTRBUFSIZ];
                if (szTmpBuf == NULL)
                {
                    ulLastError = ERROR_NOT_ENOUGH_MEMORY;
                }

                else if ((iLen =_vsnprintf(szTmpBuf,
                                    HUGESTRBUFSIZ - 1,
                                    pszFmt,
                                    pArgs)) >= 0)
                {
                    ulLastError = NewString(&pszStrData,
                                            (const char *) szTmpBuf);
                }
                else if (iLen == -1) //we have a ton of date - so truncate
                {
                    strcpy(&szTmpBuf[HUGESTRBUFSIZ - STR_TRUNC_LEN - 2],
                           STR_TRUNCATION);
                    ulLastError = NewString(&pszStrData,
                                            (const char *) szTmpBuf);
                }
            }

            if (iLen < -1)   // from either _vsnprintf
            {
                ulLastError = TOM_CORRUPT_LOG_DATA;
	    }
            delete [] szTmpBuf;
        }

    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetStrData(LPWSTR, va_list)
//
//  Synopsis:   Set the string information that is to be logged.
//
//  Effects:    Create a temporary buffer for the formatted string, format
//              the string and copy the new formated string to pszStrData.
//              This version limits the formatted string to STRBUFSIZ chars.
//              See LOG.H for STRBUFSIZ value.  The only check I know how
//              to make is to strlen the format string.  It not a fool-proof
//              check but it's better than nothing...
//
//  Arguments:  [wszFmt]  - Format to use for writing the string (printf-like)
//              [pArgs]   - Arguments to print
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ     changed code to use _vsnprintf
//                                   so that we allocate 1K first
//                                   if that is too small then 32K
//
//--------------------------------------------------------------------
ULONG  LOGCLASS :: SetStrData(LPWSTR wszFmt, va_list pArgs)
{
    CHK_UNICODE(TRUE);

    if(wszFmt == NULL || *wszFmt == wNULLTERM)
    {
        NewString(&wszStrData, NULL);
    }
    else
    {
        //
        //   Start off by allocating 1K
        //
        LPWSTR wszTmpBuf = new WCHAR[STDSTRBUFSIZ];
        if(wszTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //  note _vsnprintf returns -1 if szTmpBuf gets more than 1K

            int iLen;
            if((iLen = _vsnwprintf(wszTmpBuf, STDSTRBUFSIZ - 1,
                                   wszFmt, pArgs))
               >= 0)
            {
                ulLastError = NewString(&wszStrData, (LPCWSTR) wszTmpBuf);
            }
            else if(iLen == -1)
            {
            //
            // So we have more than 1K data, so lets leap to allocating 32K
            //
                delete [] wszTmpBuf;
                wszTmpBuf = new WCHAR[HUGESTRBUFSIZ];
                if(wszTmpBuf == NULL)
                {
                    ulLastError = ERROR_NOT_ENOUGH_MEMORY;
                }

                else if((iLen = _vsnwprintf(wszTmpBuf, HUGESTRBUFSIZ-1,
                                            wszFmt, pArgs))
                        >= 0)
                {
                    ulLastError = NewString(&wszStrData,
                                            (LPCWSTR) wszTmpBuf);
                }
                else if(iLen == -1) //we have a ton of date - so truncate
                {
                    wcscpy(&wszTmpBuf[HUGESTRBUFSIZ - STR_TRUNC_LEN - 2],
                           wSTR_TRUNCATION);
                    ulLastError = NewString(&wszStrData, (LPCWSTR) wszTmpBuf);
                }
            }

            if(iLen < -1)   // from either _vsnwprintf
            {
                ulLastError = TOM_CORRUPT_LOG_DATA;
	    }
            delete [] wszTmpBuf;
        }

    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::CloseLogFile(VOID)
//
//  Synopsis:   If a logging file is open, write event count to the
//              beginning of the file and close the file
//
//  Returns:    <nothing> - sets ulLastError if there is an error
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void  LOGCLASS :: CloseLogFile(VOID)
{
    if(hLogFile != INVALID_HANDLE_VALUE)
    {
        LogEventCount();

        if (ulLastError == NO_ERROR && SEEK_TO(FILE_END) != NO_ERROR)
        {
            ulLastError = GetLastError();
        }

        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;
    }

    if(FALSE == fIsUnicode)
    {
        SetLogFileName((PCHAR) NULL);
    }
    else
    {
        SetLogFileName((LPWSTR) NULL);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetBinData(USHORT, PVOID)
//
//  Synopsis:   Given a buffer of binary data, copy it into the internal
//              temp buffer.
//
//  Arguments:  [usBytes] - Number of bytes to transfer
//              [pvData]  - Pointer to data buffer
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetBinData(USHORT usBytes, PVOID pvData)
{
    if(pvBinData != NULL)
    {
        delete pvBinData;
        pvBinData = NULL;
        usBinLen  = 0;
    }

    if(usBytes > 0 && pvData != NULL)
    {
        // Change to BYTE support WCHAR and CHAR transparently
        // PUCHAR puchData = (PUCHAR)new CHAR[usBytes];
        PBYTE pbData = new BYTE[usBytes];

        if(pbData == NULL)
        {
            usBinLen    = 0;
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(pbData, pvData, (size_t)usBytes);
            usBinLen    = usBytes;
            pvBinData   = (PVOID)pbData;
            ulLastError = NO_ERROR;
        }
    }
    else if((usBytes > 0 && pvData == NULL)
            || (usBytes == 0 && pvData != NULL))
    {
        ulLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        ulLastError = NO_ERROR;
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogPrintf(HANDLE, PCHAR, ...)
//
//  Synopsis:   This version has a max formared output of STRBUFSIZ
//              (see log.h).  The only check I know how to make is to
//              strlen the format string.  It is not fool-proof but it's
//              better than nothing. The method allows a printf-like format
//              and args to be written to a file opened with 'open()'.
//
//  Arguments:  [nHandle] - Output File handle
//              [pszFmt]  - Format string for output
//              [...]     - Data to pass printf()
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ    Changed this function to at most write
//                                   STDSTRBUFSIZ bytes.
//
//  Note:       I have assumed that LogPrintf does not print > 1K
//              and can find no use with more data.
//              If I am wrong then the code from SetStrData should be
//              copied here.
//
//--------------------------------------------------------------------
int LOGCLASS :: LogPrintf(HANDLE hHandle, PCHAR pszFmt, ...)
{
    CHK_UNICODE(FALSE);

    if(pszFmt == NULL || strlen(pszFmt) >= STDSTRBUFSIZ)
    {
        ulLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PCHAR szTmpBuf = new CHAR[STDSTRBUFSIZ];
        if(szTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            va_list pMarker;

            va_start(pMarker, pszFmt);

            // On other error, return will be negative and not -1...
            int nLen = _vsnprintf(szTmpBuf, STDSTRBUFSIZ - 1, pszFmt, pMarker);

            // ...if -1 then buffer has more than STDSTRBUFSIZ chars in it,
            // but we will not support more in this method - truncate.
            if(nLen == -1)
            {
                nLen = (STDSTRBUFSIZ - 1) * sizeof(CHAR);
            }

            DWORD dwBytesWritten;

            if(nLen >= 0)
            {
                if(FALSE == WriteFile(hHandle, (CONST LPVOID) szTmpBuf, nLen,
                                      &dwBytesWritten, NULL))
                {
                    ulLastError = NO_ERROR;
                }
                else
                {
                    ulLastError = GetLastError();
                }
            }
            else
            {
                ulLastError = ERROR_INVALID_PARAMETER;
            }
            delete szTmpBuf;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogPrintf(HANDLE, LPWSTR, ...)
//
//  Synopsis:   This version has a max formared output of STRBUFSIZ
//              (see log.h).  The only check I know how to make is to
//              strlen the format string.  It is not fool-proof but it's
//              better than nothing. The method allows a printf-like format
//              and args to be written to a file opened with 'open()'.
//
//  Arguments:  [hHandle] - Output File handle
//              [wszFmt]  - Format string for output
//              [...]     - Data to pass printf()
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ    Changed this function to at most write
//                                   STDSTRBUFSIZ bytes.
//
//  Note:       I have assumed that LogPrintf does not print > 1K
//              and can find no use with more data.
//              If I am wrong then the code from SetStrData should be
//              copied here.
//
//--------------------------------------------------------------------
int LOGCLASS :: LogPrintf(HANDLE hHandle, LPWSTR wszFmt, ...)
{
    CHK_UNICODE(TRUE);

    if(wszFmt == NULL || wcslen(wszFmt) >= STDSTRBUFSIZ)
    {
        ulLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        LPWSTR wszTmpBuf = new WCHAR[STDSTRBUFSIZ];
        if(wszTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            va_list pMarker;

            va_start(pMarker, wszFmt);

            int nLen = _vsnwprintf(wszTmpBuf, STDSTRBUFSIZ - 1, wszFmt,
                                   pMarker);

            if(nLen == -1)   // if -1 then buffer has STDSTRBUFSIZ char in it
            {
                nLen = (STDSTRBUFSIZ - 1) * sizeof(WCHAR);
            }

            DWORD dwBytesWritten;

            if(nLen >= 0)
            {
                if(FALSE == WriteFile(hHandle, (CONST LPVOID) wszTmpBuf, nLen,
                                      &dwBytesWritten, NULL))
                {
                    ulLastError = NO_ERROR;
                }
                else
                {
                    ulLastError = GetLastError();
                }
            }
            else
            {
                ulLastError = ERROR_INVALID_PARAMETER;
            }
            delete wszTmpBuf;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::FlushLogFile(USHORT)
//
//  Synopsis:   This version checks if flushing was requested.  If yes,
//              the logging file is closed.  The method simply retirns
//              it's parameter which, in the calling code is the value
//              of ulLastError.
//
//  Arguments:  [usErr]  - Return value
//
//  Returns:    Whatever is passed as the first argument
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//------------------------------------------------------------------
ULONG LOGCLASS :: FlushLogFile(ULONG ulErr)
{
    if(fFlushWrites != FALSE && hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;

        if(FALSE == fIsUnicode)
        {
            SetLogFileName((PCHAR) NULL);
        }
        else
        {
            SetLogFileName((LPWSTR) NULL);
        }

        fIsComPort = FALSE;
    }
    return ulErr;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetIsComPort(const char *)
//
//  Synopsis:   This version sets the element fIsComPort to TRUE if the
//              given name is that of a COM port, else FALSE.  This
//              version checks if the given file name is "COMn*" where
//              'n' is a numerical value > 0.
//
//  Arguments:  [pszFileName] - The file name to test
//
//  Returns:    TRUE if it is a comm port, FALSE otherwise
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
BOOL LOGCLASS :: SetIsComPort(const char * pszFileName)
{
    CHK_UNICODE(FALSE);

    BOOL  fRC = TRUE;

    if ((pszFileName  != NULL) &&
         (*pszFileName != NULLTERM) &&
     (_strnicmp(pszFileName, (const char *)"COM", 3) == SAME) &&
         (strlen(pszFileName) > 3))
    {
        PCHAR cp = (PCHAR)&pszFileName[3];

        // Make sure everything after COM is a digit
        do
        {
            if (!isdigit(*cp))
            {
                fRC = FALSE;
            }
        } while (fRC && ++cp);
    }
    else
    {
        fRC = FALSE;
    }
    return(fRC);
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetIsComPort(LPCWSTR)
//
//  Synopsis:   This version sets the element fIsComPort to TRUE if the
//              given name is that of a COM port, else FALSE.  This
//              version checks if the given file name is "COMn*" where
//              'n' is a numerical value > 0.
//
//  Arguments:  [wszFileName] - The file name to test
//
//  Returns:    TRUE if it is a comm port, FALSE otherwise
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
BOOL LOGCLASS :: SetIsComPort(LPCWSTR wszFileName)
{
    CHK_UNICODE(TRUE);

    BOOL  fRC = TRUE;

    if((wszFileName != NULL) && (*wszFileName != NULLTERM) &&
       (_wcsnicmp(wszFileName, L"COM", 3) == SAME) &&
       (wcslen(wszFileName) > 3))
    {
        LPWSTR cp = (LPWSTR) &wszFileName[3];

        // Make sure everything after COM is a digit
        do
        {
            if(!isdigit(*cp))
            {
                fRC = FALSE;
            }
        }
        while(fRC && ++cp);
    }
    else
    {
        fRC = FALSE;
    }

    return fRC;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogEventCount(VOID)
//
//  Synopsis:   This method causes the number of logged events that are
//              in this file is written into this log file.
//
//  Returns:    <nothing>
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: LogEventCount()
{
    if(TRUE == fIsUnicode)
    {
        wLogEventCount();
        return;
    }

    CHAR chBuf[COUNT_BUFLEN];

    int cLen = sprintf(chBuf, "%lu", ulEventCount);

    //
    // The event count needs to be padded so that as the count gets larger
    // we can insert in the file without overwriting the next line
    //

    while(cLen < COUNT_BUFLEN - 1)
    {
        chBuf[cLen++] = ' ';
    }
    chBuf[COUNT_BUFLEN - 1] = NULLTERM;

    WriteBinItem(LOG_EVENTS, (PVOID) chBuf, COUNT_BUFLEN - 1);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS :: wLogEventCount(VOID)
//
//  Synopsis:   This method causes the number of logged events that are
//              in this file is written into this log file.
//
//  Returns:    <nothing>
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: wLogEventCount()
{
    CHK_UNICODE(TRUE);

    WCHAR wchBuf[COUNT_BUFLEN];

    int cLen = swprintf(wchBuf, L"%lu", ulEventCount);

    //
    // The event count needs to be padded so that as the count gets larger
    // we can insert in the file without overwriting the next line
    //

    while(cLen < COUNT_BUFLEN - 1)
    {
        wchBuf[cLen++] = L' ';
    }
    wchBuf[COUNT_BUFLEN - 1] = wNULLTERM;

    WriteBinItem(LOG_EVENTS, (PVOID) wchBuf,
                 (COUNT_BUFLEN - 1) * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\h\nchar.h ===
//+-------------------------------------------------------------------
//
//  Copyright (c) 1991-1993, Microsoft Corporation. All rights reserved
//
//  File:       nchar.h
//
//  Contents:   Definitions for generic international functions, mostly
//              defines which map string/formatted-io/ctype functions
//              to char, wchar_t versions.  To be used for compatibility
//              between single-byte, multi-byte and Unicode text models.
//
//  Note:       If CTUNICODE is defined then Unicode version is used
//              else Char version is used.
//
//  History:    16-Feb-94   NaveenB		Created
//              04-Oct-96   EricHans	New header from sdk
//				25-Feb-97	MariusB		tchar.h referral support
//
//	Note:
//		Many functionalities contained by this file are covered by the 
//		newer file tchar.h. If you want to replace all your nchar.h 
//		includes with tchar.h includes, just define __TCHAR_ONLY__
//		in your project and you'll receive a compilation error for 
//		each nchar.h inclusion. Email MariusB for any question.
//---------------------------------------------------------------------


#ifndef __NCHAR_HXX__
#define __NCHAR_HXX__

#if _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_NCHAR
#define _INC_NCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef __TCHAR_ONLY__
#error NCHAR.H is obsolete. Use TCHAR.H instead
#endif

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


#define _fncscat    _ncscat
#define _fncschr    _ncschr
#define _fncscpy    _ncscpy
#define _fncscspn   _ncscspn
#define _fncslen    _ncslen
#define _fncsncat   _ncsncat
#define _fncsncpy   _ncsncpy
#define _fncspbrk   _ncspbrk
#define _fncsrchr   _ncsrchr
#define _fncsspn    _ncsspn
#define _fncsstr    _ncsstr
#define _fncstok    _ncstok

#define _fncsdup    _ncsdup
#define _fncsnset   _ncsnset
#define _fncsrev    _ncsrev
#define _fncsset    _ncsset

#define _fncscmp      _ncscmp
#define _fncsicmp     _ncsicmp
#define _fncsnccmp    _ncsnccmp
#define _fncsncmp     _ncsncmp
#define _fncsncicmp   _ncsncicmp
#define _fncsnicmp    _ncsnicmp

#define _fncscoll     _ncscoll
#define _fncsicoll    _ncsicoll
#define _fncsnccoll   _ncsnccoll
#define _fncsncoll    _ncsncoll
#define _fncsncicoll  _ncsncicoll
#define _fncsnicoll   _ncsnicoll

/* Redundant "logical-character" mappings */

#define _fncsclen   _ncsclen
#define _fncsnccat  _ncsnccat
#define _fncsnccpy  _ncsnccpy
#define _fncsncset  _ncsncset

#define _fncsdec    _ncsdec
#define _fncsinc    _ncsinc
#define _fncsnbcnt  _ncsnbcnt
#define _fncsnccnt  _ncsnccnt
#define _fncsnextc  _ncsnextc
#define _fncsninc   _ncsninc
#define _fncsspnp   _ncsspnp

#define _fncslwr    _ncslwr
#define _fncsupr    _ncsupr

#define _fnclen     _nclen
#define _fnccpy     _nccpy
#define _fnccmp     _nccmp


#ifdef  _CTUNICODE

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */



#ifndef _WCTYPE_N_DEFINED
typedef wchar_t wint_n;
typedef wchar_t wctype_n;
#define _WCTYPE_N_DEFINED
#endif

#ifndef __NCHAR_DEFINED
typedef wchar_t     _NCHAR;
typedef wchar_t     _NSCHAR;
typedef wchar_t     _NUCHAR;
typedef wchar_t     _NXCHAR;
typedef wint_t      _NINT;
#define __NCHAR_DEFINED
#endif

#ifndef _NCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     NCHAR;
#endif
#define _NCHAR_DEFINED
#endif

#define _NEOF       WEOF

#define __TN(x)      L ## x


/* Program */

#define _nmain      wmain
#define _nWinMain   wWinMain
#define _nenviron   _wenviron
#define __nargv     __wargv

/* Formatted i/o */

#define _nprintf    wprintf
#define _fnprintf   fwprintf
#define _sNprintf   swprintf
#define _snNprintf  _snwprintf
#define _vnprintf   vwprintf
#define _vfnprintf  vfwprintf
#define _vsNprintf  vswprintf
#define _vsnNprintf _vsnwprintf
#define _nscanf     wscanf
#define _fnscanf    fwscanf
#define _snscanf    swscanf


/* Unformatted i/o */

#define _fgetnc     fgetwc
#define _fgetnchar  _fgetwchar
#define _fgetns     fgetws
#define _fputnc     fputwc
#define _fputnchar  _fputwchar
#define _fputns     fputws
#define _getnc      getwc
#define _getnchar   getwchar
#define _getns      _getws
#define _putnc      putwc
#define _putnchar   putwchar
#define _putns      _putws
#define _ungetnc    ungetwc


/* String conversion functions */

#define _ncstod     wcstod
#define _ncstol     wcstol
#define _ncstoul    wcstoul

#define _iton       _itow
#define _lton       _ltow
#define _ulton      _ultow
#define _ntoi       _wtoi
#define _ntol       _wtol


/* String functions */

#define _ncscat     wcscat
#define _ncschr     wcschr
#define _ncscpy     wcscpy
#define _ncscspn    wcscspn
#define _ncslen     wcslen
#define _ncsncat    wcsncat
#define _ncsncpy    wcsncpy
#define _ncspbrk    wcspbrk
#define _ncsrchr    wcsrchr
#define _ncsspn     wcsspn
#define _ncsstr     wcsstr
#define _ncstok     wcstok

#define _ncsdup     _wcsdup
#define _ncsnset    _wcsnset
#define _ncsrev     _wcsrev
#define _ncsset     _wcsset

#define _ncscmp     wcscmp
#define _ncsicmp    _wcsicmp
#define _ncsnccmp   wcsncmp
#define _ncsncmp    wcsncmp
#define _ncsncicmp  _wcsnicmp
#define _ncsnicmp   _wcsnicmp

#define _ncscoll    wcscoll
#define _ncsicoll   _wcsicoll
#define _ncsnccoll  _wcsncoll
#define _ncsncoll   _wcsncoll
#define _ncsncicoll _wcsnicoll
#define _ncsnicoll  _wcsnicoll


/* Execute functions */

#define _nexecl     _wexecl
#define _nexecle    _wexecle
#define _nexeclp    _wexeclp
#define _nexeclpe   _wexeclpe
#define _nexecv     _wexecv
#define _nexecve    _wexecve
#define _nexecvp    _wexecvp
#define _nexecvpe   _wexecvpe

#define _nspawnl    _wspawnl
#define _nspawnle   _wspawnle
#define _nspawnlp   _wspawnlp
#define _nspawnlpe  _wspawnlpe
#define _nspawnv    _wspawnv
#define _nspawnve   _wspawnve
#define _nspawnvp   _wspawnvp
#define _nspawnvp   _wspawnvp
#define _nspawnvpe  _wspawnvpe

#define _nsystem    _wsystem


/* Time functions */

#define _nasctime   _wasctime
#define _nctime     _wctime
#define _nstrdate   _wstrdate
#define _nstrtime   _wstrtime
#define _nutime     _wutime
#define _ncsftime   wcsftime


/* Directory functions */

#define _nchdir     _wchdir
#define _ngetcwd    _wgetcwd
#define _ngetdcwd   _wgetdcwd
#define _nmkdir     _wmkdir
#define _nrmdir     _wrmdir


/* Environment/Path functions */

#define _nfullpath  _wfullpath
#define _ngetenv    _wgetenv
#define _nmakepath  _wmakepath
#define _nputenv    _wputenv
#define _nsearchenv _wsearchenv
#define _nsplitpath _wsplitpath


/* Stdio functions */

#define _nfdopen    _wfdopen
#define _nfsopen    _wfsopen
#define _nfopen     _wfopen
#define _nfreopen   _wfreopen
#define _nperror    _wperror
#define _npopen     _wpopen
#define _ntempnam   _wtempnam
#define _ntmpnam    _wtmpnam


/* Io functions */

#define _naccess    _waccess
#define _nchmod     _wchmod
#define _ncreat     _wcreat
#define _nfindfirst _wfindfirst
#define _nfindfirsti64  _wfindfirsti64
#define _nfindnext  _wfindnext
#define _nfindnexti64   _wfindnexti64
#define _nmktemp    _wmktemp
#define _nopen      _wopen
#define _nremove    _wremove
#define _nrename    _wrename
#define _nsopen     _wsopen
#define _nunlink    _wunlink

#define _nfinddata_t    _wfinddata_t
#define _nfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _nstat      _wstat
#define _nstati64   _wstati64


/* Setlocale functions */

#define _nsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _ncsclen    wcslen
#define _ncsnccat   wcsncat
#define _ncsnccpy   wcsncpy
#define _ncsncset   _wcsnset

#define _ncsdec     _wcsdec
#define _ncsinc     _wcsinc
#define _ncsnbcnt   _wcsncnt
#define _ncsnccnt   _wcsncnt
#define _ncsnextc   _wcsnextc
#define _ncsninc    _wcsninc
#define _ncsspnp    _wcsspnp

#define _ncslwr     _wcslwr
#define _ncsupr     _wcsupr
#define _ncsxfrm    wcsxfrm


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _nclen(_pc) (1)
#define _nccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _nccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */

#if 0
__inline size_t __cdecl _nclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _nccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _nccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif
#endif  /* __STDC__ */


/* ctype functions */

#define _isnalnum   iswalnum
#define _isnalpha   iswalpha
#define _isnascii   iswascii
#define _isncntrl   iswcntrl
#define _isndigit   iswdigit
#define _isngraph   iswgraph
#define _isnlower   iswlower
#define _isnprint   iswprint
#define _isnpunct   iswpunct
#define _isnspace   iswspace
#define _isnupper   iswupper
#define _isnxdigit  iswxdigit

#define _tonupper   towupper
#define _tonlower   towlower

#define _isnlegal(_c)   (1)
#define _isnlead(_c)    (0)
#define _isnleadbyte(_c)    (0)


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _wcsdec(_cpc1, _cpc2) ((_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */

// BUGBUG [erichans] for some bizarre reason this body conflicts with tchar.h
#if 0 
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)(_cpc1,(_cpc2-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif

#endif  /* __STDC__ */


#else   /* ndef _CTUNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#include <string.h>


#define _NEOF       EOF

#define __TN(x)      x


/* Program */

#define _nmain      main
#define _nWinMain   WinMain
#ifdef  _POSIX_
#define _nenviron   environ
#else
#define _nenviron  _environ
#endif
#define __nargv     __argv


/* Formatted i/o */

#define _nprintf    printf
#define _fnprintf   fprintf
#define _sNprintf   sprintf
#define _snNprintf  _snprintf
#define _vnprintf   vprintf
#define _vfnprintf  vfprintf
#define _vsNprintf  vsprintf
#define _vsnNprintf _vsnprintf
#define _nscanf     scanf
#define _fnscanf    fscanf
#define _snscanf    sscanf


/* Unformatted i/o */

#define _fgetnc     fgetc
#define _fgetnchar  _fgetchar
#define _fgetns     fgets
#define _fputnc     fputc
#define _fputnchar  _fputchar
#define _fputns     fputs
#define _getnc      getc
#define _getnchar   getchar
#define _getns      gets
#define _putnc      putc
#define _putnchar   putchar
#define _putns      puts
#define _ungetnc    ungetc


/* String conversion functions */

#define _ncstod     strtod
#define _ncstol     strtol
#define _ncstoul    strtoul

#define _iton       _itoa
#define _lton       _ltoa
#define _ulton      _ultoa
#define _ntoi       atoi
#define _ntol       atol


/* String functions */

#define _ncscat     strcat
#define _ncscpy     strcpy
#define _ncslen     strlen
#define _ncsxfrm    strxfrm
#define _ncsdup     _strdup


/* Execute functions */

#define _nexecl     _execl
#define _nexecle    _execle
#define _nexeclp    _execlp
#define _nexeclpe   _execlpe
#define _nexecv     _execv
#define _nexecve    _execve
#define _nexecvp    _execvp
#define _nexecvpe   _execvpe

#define _nspawnl    _spawnl
#define _nspawnle   _spawnle
#define _nspawnlp   _spawnlp
#define _nspawnlpe  _spawnlpe
#define _nspawnv    _spawnv
#define _nspawnve   _spawnve
#define _nspawnvp   _spawnvp
#define _nspawnvpe  _spawnvpe

#define _nsystem    system


/* Time functions */

#define _nasctime   asctime
#define _nctime     ctime
#define _nstrdate   _strdate
#define _nstrtime   _strtime
#define _nutime     _utime
#define _ncsftime   strftime


/* Directory functions */

#define _nchdir     _chdir
#define _ngetcwd    _getcwd
#define _ngetdcwd   _getdcwd
#define _nmkdir     _mkdir
#define _nrmdir     _rmdir


/* Environment/Path functions */

#define _nfullpath  _fullpath
#define _ngetenv    getenv
#define _nmakepath  _makepath
#define _nputenv    _putenv
#define _nsearchenv _searchenv
#define _nsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _nfdopen    fdopen
#else
#define _nfdopen    _fdopen
#endif
#define _nfsopen    _fsopen
#define _nfopen     fopen
#define _nfreopen   freopen
#define _nperror    perror
#define _npopen     _popen
#define _ntempnam   _tempnam
#define _ntmpnam    tmpnam


/* Io functions */

#define _nchmod     _chmod
#define _ncreat     _creat
#define _nfindfirst _findfirst
#define _nfindfirsti64  _findfirsti64
#define _nfindnext  _findnext
#define _nfindnexti64   _findnexti64
#define _nmktemp    _mktemp

#ifdef _POSIX_
#define _nopen      open
#define _naccess    access
#else
#define _nopen      _open
#define _naccess    _access
#endif

#define _nremove    remove
#define _nrename    rename
#define _nsopen     _sopen
#define _nunlink    _unlink

#define _nfinddata_t    _finddata_t
#define _nfinddatai64_t _finddatai64_t


/* ctype functions */

#define _isnascii   isascii
#define _isncntrl   iscntrl
#define _isnxdigit  isxdigit


/* Stat functions */

#define _nstat      _stat
#define _nstati64   _stati64


/* Setlocale functions */

#define _nsetlocale setlocale


#ifdef _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */




#ifndef __NCHAR_DEFINED
typedef char            _NCHAR;
typedef signed char     _NSCHAR;
typedef unsigned char   _NUCHAR;
typedef unsigned char   _NXCHAR;
typedef unsigned int    _NINT;
#define __NCHAR_DEFINED
#endif

#ifndef _NCHAR_DEFINED
#if     !__STDC__
typedef char            NCHAR;
#endif
#define _NCHAR_DEFINED
#endif


#ifdef _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _ncschr     _mbschr
#define _ncscspn    _mbscspn
#define _ncsncat    _mbsnbcat
#define _ncsncpy    _mbsnbcpy
#define _ncspbrk    _mbspbrk
#define _ncsrchr    _mbsrchr
#define _ncsspn     _mbsspn
#define _ncsstr     _mbsstr
#define _ncstok     _mbstok

#define _ncsnset    _mbsnbset
#define _ncsrev     _mbsrev
#define _ncsset     _mbsset

#define _ncscmp     _mbscmp
#define _ncsicmp    _mbsicmp
#define _ncsnccmp   _mbsncmp
#define _ncsncmp    _mbsnbcmp
#define _ncsncicmp  _mbsnicmp
#define _ncsnicmp   _mbsnbicmp

#define _ncscoll    _mbscoll
#define _ncsicoll   _mbsicoll
#define _ncsnccoll  _mbsncoll
#define _ncsncoll   _mbsnbcoll
#define _ncsncicoll _mbsnicoll
#define _ncsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _ncsclen    _mbslen
#define _ncsnccat   _mbsncat
#define _ncsnccpy   _mbsncpy
#define _ncsncset   _mbsnset


/* MBCS-specific mappings */

#define _ncsdec     _mbsdec
#define _ncsinc     _mbsinc
#define _ncsnbcnt   _mbsnbcnt
#define _ncsnccnt   _mbsnccnt
#define _ncsnextc   _mbsnextc
#define _ncsninc    _mbsninc
#define _ncsspnp    _mbsspnp

#define _ncslwr     _mbslwr
#define _ncsupr     _mbsupr

#define _nclen      _mbclen
#define _nccpy      _mbccpy

#define _nccmp(_cpuc1,_cpuc2)   _ncsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _ncschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _ncscspn(const char *, const char *);
_CRTIMP char * __cdecl _ncsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncspbrk(const char *, const char *);
_CRTIMP char * __cdecl _ncsrchr(const char *, int);
_CRTIMP size_t __cdecl _ncsspn(const char *, const char *);
_CRTIMP char * __cdecl _ncsstr(const char *, const char *);
_CRTIMP char * __cdecl _ncstok(char *, const char *);

_CRTIMP char * __cdecl _ncsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _ncsrev(char *);
_CRTIMP char * __cdecl _ncsset(char *, unsigned int);

_CRTIMP int __cdecl _ncscmp(const char *, const char *);
_CRTIMP int __cdecl _ncsicmp(const char *, const char *);
_CRTIMP int __cdecl _ncsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _ncscoll(const char *, const char *);
_CRTIMP int __cdecl _ncsicoll(const char *, const char *);
_CRTIMP int __cdecl _ncsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _ncsclen(const char *);
_CRTIMP char * __cdecl _ncsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _ncsdec(const char *, const char *);
_CRTIMP char * __cdecl _ncsinc(const char *);
_CRTIMP size_t __cdecl _ncsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _ncsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _ncsnextc (const char *);
_CRTIMP char * __cdecl _ncsninc(const char *, size_t);
_CRTIMP char * __cdecl _ncsspnp(const char *, const char *);

_CRTIMP char * __cdecl _ncslwr(char *);
_CRTIMP char * __cdecl _ncsupr(char *);

_CRTIMP size_t __cdecl _nclen(const char *);
_CRTIMP void __cdecl _nccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _ncschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _ncscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _ncsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _ncsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _ncsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _ncsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _ncscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _ncscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _ncsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _ncsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _ncsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _ncsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _ncsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _ncsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _nclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _nccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _ncsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) _n=((_UI)*_s1++)<<8; _n+=(_UI)*_s1; return(_n);}


#endif /* __STDC__ */

#endif /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _nccmp(_cp1,_cp2)   _ncsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _isnalnum   _ismbcalnum
#define _isnalpha   _ismbcalpha
#define _isndigit   _ismbcdigit
#define _isngraph   _ismbcgraph
#define _isnlegal   _ismbclegal
#define _isnlower   _ismbclower
#define _isnprint   _ismbcprint
#define _isnpunct   _ismbcpunct
#define _isnspace   _ismbcspace
#define _isnupper   _ismbcupper

#define _tonupper   _mbctoupper
#define _tonlower   _mbctolower

#define _isnlead    _ismbblead
#define _isnleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __NCHAR_DEFINED
typedef char            _NCHAR;
typedef signed char     _NSCHAR;
typedef unsigned char   _NUCHAR;
typedef char            _NXCHAR;
typedef int             _NINT;
#define __NCHAR_DEFINED
#endif

#ifndef _NCHAR_DEFINED
#if     !__STDC__
typedef char            NCHAR;
#endif
#define _NCHAR_DEFINED
#endif


/* String functions */

#define _ncschr     strchr
#define _ncscspn    strcspn
#define _ncsncat    strncat
#define _ncsncpy    strncpy
#define _ncspbrk    strpbrk
#define _ncsrchr    strrchr
#define _ncsspn     strspn
#define _ncsstr     strstr
#define _ncstok     strtok

#define _ncsnset    _strnset
#define _ncsrev     _strrev
#define _ncsset     _strset

#define _ncscmp     strcmp
#define _ncsicmp    _stricmp
#define _ncsnccmp   strncmp
#define _ncsncmp    strncmp
#define _ncsncicmp  _strnicmp
#define _ncsnicmp   _strnicmp

#define _ncscoll    strcoll
#define _ncsicoll   _stricoll
#define _ncsnccoll  _strncoll
#define _ncsncoll   _strncoll
#define _ncsncicoll _strnicoll
#define _ncsnicoll  _strnicoll


/* "logical-character" mappings */

#define _ncsclen    strlen
#define _ncsnccat   strncat
#define _ncsnccpy   strncpy
#define _ncsncset   _strnset


/* MBCS-specific functions */

#define _ncsdec     _strdec
#define _ncsinc     _strinc
#define _ncsnbcnt   _strncnt
#define _ncsnccnt   _strncnt
#define _ncsnextc   _strnextc
#define _ncsninc    _strninc
#define _ncsspnp    _strspnp

#define _ncslwr     _strlwr
#define _ncsupr     _strupr
#define _ncsxfrm    strxfrm

#define _isnlead(_c)    (0)
#define _isnleadbyte(_c)    (0)

#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _nclen(_pc) (1)
#define _nccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _nccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _nclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _nccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _nccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _isnalnum   isalnum
#define _isnalpha   isalpha
#define _isndigit   isdigit
#define _isngraph   isgraph
#define _isnlower   islower
#define _isnprint   isprint
#define _isnpunct   ispunct
#define _isnspace   isspace
#define _isnupper   isupper

#define _tonupper   toupper
#define _tonlower   tolower

#define _isnlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
// BUGBUG [erichans] for some bizarre reason this conflicts with tchar.h
#if 0
#define _strdec(_cpc1, _cpc2) ((_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)(_cpc1,(_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif

#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _TN(x)       __TN(x)
#define _TEXTN(x)    __TN(x)


#ifdef __cplusplus
}
#endif

#endif  /* _INC_NCHAR */

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  CTUNICODE

typedef WCHAR *PNCHAR;
typedef NCHAR *LPNCHAR;

typedef LPWSTR LPNCH, PNCH;
typedef LPWSTR PNSTR, LPNSTR;
typedef LPCWSTR LPCNSTR;
typedef LPWSTR LP;
#define __TEXTN(quote) L##quote

#else   /* CTUNICODE */

typedef char NCHAR, *PNCHAR;
typedef unsigned char NBYTE , *PNBYTE ;
typedef NCHAR   *LPNCHAR;

typedef LPSTR LPNCH, PNCH;
typedef LPSTR PNSTR, LPNSTR;
typedef LPCSTR LPCNSTR;
#define __TEXTN(quote) quote

#endif /* CTUNICODE */

typedef const NCHAR CNCHAR;

#ifdef CTUNICODE
#define NSF    __TEXTN("%ls")
#else  // ANSI
#define NSF    __TEXTN("%hs")
#endif

#endif  // __NCHAR_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\log\log.h ===
//+-------------------------------------------------------------------
//
//  File:       log.h
//
//  Contents:   Common definitions used by logsvr.cxx and log.cxx
//
//  History:    18-Sep-90  DaveWi    Initial Coding
//              14-Oct-91  SarahJ    added LOG_PASS_TXT etc
//              31-Oct-91  SarahJ    added MIN_LINE_HDR_LEN
//              10-Feb-92  BryanT    Merged logid.h with this file.
//              16-Sep-92  SarahJ    added STD and HUGESTRBUFSIZEe.
//
//--------------------------------------------------------------------

#ifndef _LOGSVR_LOG_H_INCLUDED_
#define _LOGSVR_LOG_H_INCLUDED_

extern BOOL  fDebugOn;

#define SAME                0

#define LOG_OPEN_PARMS      6          // # parms in LogOpen packet
#define LOG_WRITE_PARMS    11          // # parms in LogWrote packet

#define LINE_HDR_LEN        8          // # bytes at beginning of log file data
                                       // line; must be greater than 3

#define MIN_LINE_HDR_LEN    4          // Minimum length that the hdr
                                       // can be. ie n:<len>:

#define STDSTRBUFSIZ       1024        // Default length of a formatted
                                       // string to be sent to the log file
#define HUGESTRBUFSIZ      32767       // Max len (incl null) of a formated
                                       // string to be sent to the log file

                                       // String logged if output > 32K
#define STR_TRUNCATION  \
    "\n     ****     OUTPUT TRUNCATED    **** \n\n"
#define wSTR_TRUNCATION  \
    L"\n     ****     OUTPUT TRUNCATED    **** \n\n"
#define STR_TRUNC_LEN      50

#define SLASH            '\\'          // File name component sep
#define NULLTERM         '\0'          // String terminating null

#define wSLASH           L'\\'          // File name component sep
#define wNULLTERM        L'\0'          // String terminating null

#define INVALID_PARAM_COUNT (unsigned short)65000 // Invalid # params in packet
#define INVALID_API         (unsigned short)65001 // Invalid API name in packet
#define CORRUPT_LOG_FILE    (unsigned short)65002 // Log file is corrupted

//
// These next 3 defines are used internally by the logging code.
//

#define API_TERMINATE     "TRPCLogServerStop"
#define API_OPENLOGFILE   "TRPCOpenLogFile"
#define API_WRITETOFILE   "TRPCWriteToLogFile"

#define wAPI_TERMINATE    L"TRPCLogServerStop"
#define wAPI_OPENLOGFILE  L"TRPCOpenLogFile"
#define wAPI_WRITETOFILE  L"TRPCWriteToLogFile"

//
// Registered name of logsrvr.  This is the name used, in the logging server,
// to register the logging server with Mailtrck
//

#define LOGSRVR_OBJECT_NAME   "LOGSVR"
#define wLOGSRVR_OBJECT_NAME  L"LOGSVR"

//
// Text strings for status fields
//

#define LOG_PASS_TXT    "VAR_PASS"
#define LOG_FAIL_TXT    "VAR_FAIL"
#define LOG_ABORT_TXT   "VAR_ABORT"
#define LOG_WARN_TXT    "WARNING"
#define LOG_INFO_TXT    "INFO"
#define LOG_START_TXT   "START"
#define LOG_DONE_TXT    "DONE"

#define wLOG_PASS_TXT   L"VAR_PASS"
#define wLOG_FAIL_TXT   L"VAR_FAIL"
#define wLOG_ABORT_TXT  L"VAR_ABORT"
#define wLOG_WARN_TXT   L"WARN"
#define wLOG_INFO_TXT   L"INFO"
#define wLOG_START_TXT  L"START"
#define wLOG_DONE_TXT   L"DONE"

//
// LOG FILE LINE IDENTIFIERS:
//    One of these is the first char in every line in the raw log file.
//    These are for parsing command line parameters, so no WCHAR required.
//

#define LOG_EVENTS        'e'          // # events in log file
#define LOG_TEST_NAME     'n'          // Name of the test
#define LOG_TEST_TIME     't'          // Time test logging started
#define LOG_TESTER        'u'          // User running the test
#define LOG_SERVER        's'          // Logging server's name
#define LOG_EVENT_NUM     'E'          // Event's sequential # in log
#define LOG_EVENT_TIME    'T'          // Time the event happened
#define LOG_MACHINE       'M'          // Machine sending log data
#define LOG_OBJECT        'O'          // Name of logging object
#define LOG_VARIATION     'V'          // Variation number
#define LOG_STATUS        'S'          // Logged status
#define LOG_STRING        'Z'          // String data
#define LOG_BINARY        'B'          // Binary data

// Needed to initialize va_list types to NULL - MIPS and ALPHA are
// not ANSI-compatible wrt va_end
//
#ifdef _M_ALPHA
#define LOG_VA_NULL {NULL, 0}
#else
#define LOG_VA_NULL NULL
#endif

#endif          // _LOGSVR_LOG_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\dummy.cxx ===
#include "ctolerpc.h"
#pragma hdrstop

void pch_dummy_function()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\log\newlog.cxx ===
//+-------------------------------------------------------------------
//
//  File:       log.cxx
//
//  Contents:   The code for the logging servers client logging methods
//
//  Functions:  Log::Log()
//              Log::~Log()
//              Log::Info(inc, char *[])
//              Log::WriteData(PCHAR)
//
//  History:    24-Sep-90  DaveWi    Initial Coding
//              11-Mar-94  DaveY     Miniature Log.
//              10-Aug-95  ChrisAB   Changed fopen()s to _fsopens() for
//                                   proper chicago operation
//
//--------------------------------------------------------------------

#include <comtpch.hxx>
#pragma hdrstop


extern "C"
{
#include <stdarg.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <direct.h>
#include <share.h>
}


#include "log.hxx"
#include "log.h"



#define CCH_MAX_CHARS 1024

// Set up a table of the status text values

const char * aStatus[] = { LOG_PASS_TXT,
                           LOG_FAIL_TXT,
                           LOG_WARN_TXT,
                           LOG_ABORT_TXT,
                           LOG_INFO_TXT,
                           LOG_START_TXT,
                           LOG_DONE_TXT };

#ifdef WIN16
#define OutputDebugStringA OutputDebugString
#endif


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(int, char *[], DWORD)
//
//  Synopsis:   Log constructor with command line data given
//
//  Arguments:  [argc]  - Argument count
//              [argv]  - Argument array
//              [fUseUnicode] - whether we should use WCHARs
//
//  Returns:    Results from Info()
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
//--------------------------------------------------------------------
Log :: Log(int argc, char *argv[], DWORD dwCharType) :
  fInfoSet(FALSE),
  ulLastError(ERROR_SUCCESS)
{

#if defined (_WIN32)

    //
    // Check the result of the CMutex Contructor and continue if 
    // it succeeded
    //
    ulLastError = hMtxSerialize.QueryError();
    if (ulLastError == ERROR_SUCCESS)
    {
        ulLastError = Info(argc, argv);
    }

#else 

    ulLastError = Info(argc, argv);

#endif
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR)
//
//  Synopsis:   Log constructor with internal data given
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of this test
//              [pszName]    - Name of test runner
//              [pszSubPath] - Users log file qualifer
//              [pszObject]  - Name of invoking object
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
// BUGBUG wszName unused - left until all components can co-ordinate
//                         with this. SarahJ
//--------------------------------------------------------------------
Log :: Log(PCHAR pszSrvr,
           PCHAR pszTest,
           PCHAR pszName,
           PCHAR pszSubPath,
           PCHAR pszObject) : ulLastError(ERROR_SUCCESS)
{

#if defined (_WIN32)

    //
    // Check the result of the CMutex Contructor and continue if
    // it succeeded
    //
    ulLastError = hMtxSerialize.QueryError();
    if (ulLastError != ERROR_SUCCESS)
    {
        return;
    }

#endif
    InitLogging();

    // Print warning if server name given
/* BUGBUG Need to restore this once remote server is supported.
    if(NULL != pszSrvr)
    {
        fprintf(stderr, "Remote server not supported with this version of "
                "log.lib. Continuing.\n");
    }
*/

    ulLastError = SetInfo(NULL, pszTest,  pszSubPath, pszObject);
    if(ulLastError == ERROR_SUCCESS)
    {
        ulLastError = LogOpen();

        if(ulLastError == ERROR_SUCCESS)
        {
            WriteData("\n*LOG_START*-%s", pszShortLogFileName);
        }
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::~Log()
//
//  Synopsis:   Destroy the Log Object
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
Log :: ~Log()
{
    if(fInfoSet != FALSE)
    {
        if(WriteData("\n*LOG_DONE*") != ERROR_SUCCESS)
        {    
            LogPrintf(stderr, "ERROR: Failed to log \"%s\" status\n",
                  LOG_DONE_TXT);
        }
    }
    SetLoggingDir((PCHAR) NULL);
    SetMachineName((PCHAR) NULL);
    SetObjectName((PCHAR) NULL);
    SetTestName((PCHAR) NULL);
    SetPath((PCHAR) NULL);
    SetStatus((PCHAR) NULL);
    SetLogFileName((PCHAR) NULL);
    SetShortLogFileName((PCHAR) NULL);
    CloseLogFile();
}

//+-------------------------------------------------------------------
//
//  Member:     Log::Info(int, char *[])
//
//  Synopsis:   Parse the command line and set the appropriate member variables
//
//  Arguments:  [argc] - Argument count
//              [argv] - Argument vector
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              30-Oct-92  SarahJ    Updated parms to SetInfo
//
//--------------------------------------------------------------------
ULONG Log :: Info(int argc, char *argv[])
{
    USHORT usNdx;               // Index into cmnd line args
    PCHAR  pszTest    = NULL;   // Name of this test
    PCHAR  pszSubPath = NULL;   // Users log file qualifer
    PCHAR  pszObject  = NULL;   // Name of invoking object
    PCHAR  pch;                 // Temporary pointer into a string


    InitLogging();

    // All the argv processing is still done in CHARs
    if(ulLastError == ERROR_SUCCESS)
    {
        //
        // For every command line switch, check its validity and parse its
        // value.  This version allows / or - for switches.  If there are
        // no command line switches, this loop is skipped.  This is for the
        // case when Log() is called with no messages.
        //

        for(usNdx = 1; usNdx < (unsigned short) argc; ++usNdx)
        {
            char *szArg = argv[ usNdx];
            pch = szArg;

            // check for / -

            if(*szArg == '/' || *szArg == '-')
            {
                register int i = 1;
                pch++;

                //
                // Check if next char is m, ie handed down from manager code.
                // If so skip m
                //

                if (*pch == 'm' || *pch == 'M')
                {
                    pch++;
                    i++;
                }

                ++pch;           // Skip next char and check for :

                if(*pch++ == ':')
                {
                    switch(toupper(szArg[i]))
                    {
                      case 'O':       // Object name found

                        pszObject = (PCHAR)pch;
                        break;

                      case 'P':       // Directory Path switch found

                        pszSubPath = (PCHAR)pch;
                        break;

                      case 'L':       // Logging server name found

                        // BUGBUG We don't want this message spit to debugger
                        // all the time.
                        // BUGBUG OutputDebugStringA("Logging server not supported with "
                        // BUGBUG         "this version of log.lib. Continuing.\n");
                        break;

                      case 'T':       // Test name found

                        pszTest = (PCHAR)pch;
                        break;

                      default:        // Skip this unknown argument

                        break;
                    }
                }
            }
        }

        // If no test name was given, set pszTest to the apps base name.

        char szName[_MAX_FNAME];

        if(pszTest == NULL || *pszTest == NULLTERM)
        {
            GetBaseFilename(argv[0], szName);
            pszTest = szName;
        }

    }

    ulLastError = SetInfo(NULL, pszTest, pszSubPath, pszObject);

    // This was not here before, but it seems the log should be opened by now
    if(ERROR_SUCCESS == ulLastError)
    {
        ulLastError = LogOpen() || WriteData("\n*LOG_START*-%s", pszShortLogFileName);

    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(PCHAR, ...)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pszFormat] - a printf-like format string
//              [...]       - The data to print out.
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(PCHAR psz, ...)
{

    CHAR szBuffer[CCH_MAX_CHARS];
    va_list varArgs;

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    szBuffer[0] = '\0';
    szBuffer[CCH_MAX_CHARS-1] = '\0';

    if ((psz != NULL) && (pfLog != NULL))
    {

        // Print the caller's string to a buffer
        va_start(varArgs, psz);
        _vsnprintf(szBuffer, CCH_MAX_CHARS-1, psz, varArgs);
        va_end(varArgs);

        int iRet = fprintf(pfLog, "%s\n", szBuffer);
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log data string : ");
            OutputDebugStringA(szBuffer);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
    }
    return(ERROR_SUCCESS);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData2(PCHAR)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [psz] - string to print out
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData2(PCHAR psz)
{

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    if ((psz != NULL) && (pfLog != NULL))
    {

        int iRet = fprintf(pfLog, "%s", psz);
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log data string : ");
            OutputDebugStringA(psz);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
    }
    return(ERROR_SUCCESS);
}

#ifndef WIN16
//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData2(PWCHAR)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pwsz] - string to print out
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData2(PWCHAR pwsz)
{

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    if ((pwsz != NULL) && (pfLog != NULL))
    {

        int iRet = fprintf(pfLog, "%ls", pwsz);
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log data string : ");
            // Note on Chicago this call will be stubbed out.
            OutputDebugStringW(pwsz);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
    }
    return(ERROR_SUCCESS);
}

#endif

//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar
//
//  Synopsis:   Write a variation status to the Log file.
//
//  Arguments:  
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG  Log :: WriteVar(PCHAR pszVariation,
                    USHORT usStatus,
                    PCHAR pszStrFmt, ... )
{

    CHAR szBuffer[CCH_MAX_CHARS];
    va_list varArgs;

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    szBuffer[0] = '\0';
    szBuffer[CCH_MAX_CHARS-1] = '\0';
    if (pfLog != NULL)
    {
        int iRet;

        if (pszStrFmt != NULL)
        {
            // Print the caller's string to a buffer
            va_start(varArgs, pszStrFmt);
            _vsnprintf(szBuffer, CCH_MAX_CHARS-1, pszStrFmt, varArgs);
            va_end(varArgs);

            iRet = fprintf(pfLog, "%s: %s: %s\n", aStatus[usStatus], 
                    pszVariation, szBuffer);
        }
        else
        {
            iRet = fprintf(pfLog, "%s: %s\n", aStatus[usStatus], pszVariation);    
        }
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log variation string : ");
            OutputDebugStringA(pszVariation);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
        fflush(pfLog);
    }

    return(ERROR_SUCCESS);

}


//+-------------------------------------------------------------------
//
//  Member:     Log ::InitLogging(VOID)
//
//  Synopsis:   Initialize the classes data members.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void Log :: InitLogging(VOID)
{
    pszLoggingDir = NULL;
    pszMachineName = NULL;
    pszObjectName = NULL;
    pszTestName = NULL;
    pszPath = NULL;
    pszStatus = NULL;
    pszVariation = NULL;
    pszLogFileName = NULL;
    pszShortLogFileName = NULL;
    fInfoSet = FALSE;
    pfLog = NULL;
}


//+-------------------------------------------------------------------
//
//  Member:     Log ::SetLogFile(VOID)
//
//  Synopsis:   Combine the logging file name components into a full path
//              file name.  If this new file name is not the same as that
//              referenced by element pszLogFileName, switch to log data
//              into the file in this new name.
//
//  Returns:    ERROR_SUCCESS if successful, else
//              ERROR_INVALID_PARAMETER
//              ERROR_OUTOFMEMORY
//              ERROR_CANTOPEN
//               Any error from AddComponent, CheckDir, SetLogFileName,
//               or SetEventCount
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: SetLogFile()
{
    if (((pszLoggingDir != (PCHAR) NULL) &&
         (strlen(pszLoggingDir) > _MAX_PATH)) ||
        ((pszPath != NULL) && (strlen(pszPath) > _MAX_PATH)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    PCHAR pszNewFileName = new char[_MAX_PATH + 1];
    if(pszNewFileName == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    //
    // No -
    // For each component of the new log file path, append it to the
    // root logging directory.  Make sure only one back-slash exists
    // between each appended path component.
    //

    if(pszLoggingDir != NULL && *pszLoggingDir != NULLTERM)
    {
        strcpy(pszNewFileName, pszLoggingDir);
    }
    else
    {
        *pszNewFileName = NULLTERM;
    }


    ulLastError =
        AddComponent(pszNewFileName, pszPath) ||
        AddComponent(pszNewFileName, pszTestName);

    //
    // The the new file name was successfully built, see if it the same as
    // the name of the currently open log file (if one is open).  If is not
    // the same file name, close the open one (if open) and open the new
    // logging file.  If the open is successful, save the name of the newly
    // opened file for the next time thru here.
    //
    // A later version of this method could be written to create a LRU queue
    // of some max number of open logging files.  This version just keeps one
    // file open at a time, closing it only to switch to a different log file.
    //

    if(ulLastError == ERROR_SUCCESS)
    {
        strcat(pszNewFileName, (const char *)".Log");


        ulLastError = SetLogFileName((const char *) pszNewFileName);
       
        if  (ulLastError == ERROR_SUCCESS)
        {
            char szName[_MAX_FNAME];
            GetBaseFilename(pszNewFileName, szName);
            ulLastError = SetShortLogFileName((const char *) szName);
        }

        if  (ulLastError == ERROR_SUCCESS)
        {
            // Changed this from fopen() to work on chicago 16 bit
            pfLog = _fsopen(pszNewFileName, "a", _SH_DENYNO);

            if(pfLog == NULL)
            {
                ulLastError = ERROR_CANTOPEN;
                OutputDebugStringA("CTLOG::Failed to create log file");
                OutputDebugStringA(pszNewFileName);
                OutputDebugStringA("\n");
            }
        }
    }

    delete [] pszNewFileName;
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log ::AddComponent(PCHAR, PCHAR)
//
//  Synopsis:   Append a path component to the given string in szNewName.
//              Make sure there is one and only one '\' between each
//              component and no trailing '\' is present.
//
//  Arguments:  [szNewName]   - Pointer to exist path (must not be NULL)
//              [szComponent] - New component to add
//
//  Returns:    ERROR_SUCCESS if successful
//              ERROR_INVALID_PARAMETER
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: AddComponent(PCHAR szNewName, PCHAR szComponent)
{

    PCHAR pch = NULL;

    // Path component provided?

    if (szComponent != NULL && *szComponent != NULLTERM)
    {
        int nLen = strlen((const char *)szComponent);

        //
        // Trim trailing and leading '\'s from the component to be appended,
        // then append the component to the file name.
        //

        pch = szComponent + nLen;

        while (pch > szComponent)
        {
            if (*pch == SLASH)
            {
                *pch = NULLTERM;
                pch--;
            }
            else
            {
                break;
            }
        }
        pch = szComponent;

        while (*pch == SLASH)
        {
            pch++;
        }

        //
        // Append one '\' to the file name then append the given component.
        //

        if (strlen((const char *)szNewName) + nLen + 1 < _MAX_PATH)
        {
            nLen = strlen((const char *)szNewName);

            if (nLen > 0)
            {                               // Add component separater
                szNewName[ nLen++] = SLASH;
            }
            strcpy(&szNewName[nLen], (const char *)pch);
        }
        else
        {
            ulLastError = ERROR_INVALID_PARAMETER;
        }
    }

    return(ulLastError);
}




//+-------------------------------------------------------------------
//
//  Member:     Log ::LogOpen(VOID)
//
//  Synopsis:   If we are not in the LogSvr and if logging remotly, try
//              to a START record to the server.  If not, or if the attempt
//              fails, log the data locally. This may require opening the
//              local log file.
//
//  Returns:    ERROR_SUCCESS if successful
//              Results from Remote(), SetLogFile(), or OpenLogFile()
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: LogOpen()
{
    if(pfLog == NULL)
    {
        //
        // Something failed in the remote logging attempt, or this is our
        // first call to open the log file, so set up to log locally.
        //

        ulLastError = SetLogFile();

        if(ulLastError != ERROR_SUCCESS)
        {
            return ulLastError;    // Setup failed...  Don't go any further.
        }
    }

    return ERROR_SUCCESS;
}


//+-------------------------------------------------------------------
//
//  Member: Log ::SetInfo(const char *, const char *,
//                             const char *, const char *)
//
//  Synopsis:   Set the logging information about the test being run.
//              User is set to pszTest OR logged on username OR MY_NAME in
//              that order of preference.
//              Machinename is set to computername OR MY_NAME in
//              that order of preference.
//
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of the test being run
//              [pszSubPath] - Log file path qualifier
//              [pszObject]  - Name of object logging the data
//
//  Returns:    USHORT - ERROR_SUCCESS (ERROR_SUCCESS) if successful.  Otherwise,
//                       the return value from SetTestName,
//                       SetTester, SetPath, or SerObjectName.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              09-Feb-92  BryanT    Added Win32 support
//              01-Jul-92  Lizch     Fixed bug where testername was getting
//                                   overwritten if machinename not set.
//              30-Jul-92  SarahJ    Fixed memory trashing bug - SetTester
//                                   & SetmachineName were trashing environment
//                                   variables
//              30-Oct-92  SarahJ    Removed all signs of pszTester - it
//                                   was only mis-used
//--------------------------------------------------------------------
ULONG Log :: SetInfo(const char * pszSrvr,
                          const char * pszTest,
                          const char * pszSubPath,
                          const char * pszObject)
{

    ulLastError =
        SetTestName(pszTest) ||
        SetPath(pszSubPath) ||
        SetObjectName(pszObject);

    if(ulLastError == ERROR_SUCCESS && pszMachineName == NULL)
    {
        SetMachineName("MyMachineName");

        if(pszMachineName == NULL)
        {
            // ulLastError has been set to error by SetMachineName.
            fprintf(stderr, "ERROR! machine name not set\n");
        }
    }

    if(ulLastError == ERROR_SUCCESS)
    {
        fInfoSet = TRUE;        // Note that info has been set
    }
    return ulLastError;
}

//+-------------------------------------------------------------------
//
//  Member:     Log ::OpenLogFile(VOID)
//
//  Synopsis:   Opens log file if not already open.
//
//  Returns:    ERROR_SUCCESS if successful, else ERROR_CANTOPEN
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG  Log :: OpenLogFile(VOID)
{
    ULONG ulErr = ERROR_SUCCESS;

    if(pfLog == NULL)
    {
        // changed this from fopen() to work on chicago 16 bit
        pfLog = _fsopen(pszLogFileName, "a", _SH_DENYNO);
        if(pfLog == NULL)
        {
            ulErr = ERROR_CANTOPEN;
        }
    }
    return(ulErr);
}

//+-------------------------------------------------------------------
//
//  Member:     Log ::CloseLogFile(VOID)
//
//  Synopsis:   If a logging file is open, write event count to the
//              beginning of the file and close the file
//
//  Returns:    <nothing> - sets ulLastError if there is an error
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void  Log :: CloseLogFile(VOID)
{
    if(pfLog != NULL)
    {
        fclose(pfLog);
        pfLog = NULL;
    }

//    SetLogFileName((PCHAR) NULL);
}


//+-------------------------------------------------------------------
//
//
//  Member:     Log ::LogPrintf(HANDLE, PCHAR, ...)
//
//  Synopsis:   This version has a max formared output of STRBUFSIZ
//              (see log.h).  The only check I know how to make is to
//              strlen the format string.  It is not fool-proof but it's
//              better than nothing. The method allows a printf-like format
//              and args to be written to a file opened with 'open()'.
//
//  Arguments:  [nHandle] - Output File handle
//              [pszFmt]  - Format string for output
//              [...]     - Data to pass printf()
//
//  Returns:    ERROR_SUCCESS if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ    Changed this function to at most write
//                                   STDSTRBUFSIZ bytes.
//
//  Note:       I have assumed that LogPrintf does not print > 1K
//              and can find no use with more data.
//              If I am wrong then the code from SetStrData should be
//              copied here.
//
//--------------------------------------------------------------------
int Log :: LogPrintf(FILE *pf, PCHAR pszFmt, ...)
{
    return ERROR_SUCCESS;
}



//+-------------------------------------------------------------------
//
//  Member: Log ::NewString(PCHAR *, const char *)
//
//  Synopsis:   This method will delete the existing string if it exists,
//              and (if a new string is given) will create and return a
//              duplicate string.
//              The assumption, here, is that the original pointer was
//              properly initialized to NULL prior to calling this method
//              the firsttime for that original string.
//
//  Arguments:  [pszOrig]   - The original string
//              [pszNewStr] - The new and improved string
//
//  Returns:    ERROR_SUCCESS if successful, else ERROR_OUTOFMEMORY.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: NewString(PCHAR *pszOrig, const char * pszNewStr)
{

    DelString(pszOrig);

    // If a new string was given, duplicate it.

    if(pszNewStr != NULL)
    {
        *pszOrig = new char[strlen(pszNewStr) + 1];
        if(*pszOrig == NULL)
        {
            ulLastError = ERROR_OUTOFMEMORY;
        }
        else
        {
            strcpy(*pszOrig, pszNewStr);
        }
    }

    return ulLastError;
}



//+-------------------------------------------------------------------
//
//  Function:   DelString(PCHAR *)
//
//  Synopsis:   Given a pointer to a string, delete the memory if necessary
//               and set the pointer to NULL
//
//  Arguments:  [pszOrig]  Original string to delete
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
VOID Log :: DelString(PCHAR *pszOrig)
{
    if (*pszOrig != NULL)
    {
        delete *pszOrig;
        *pszOrig = NULL;
    }
}



//+-------------------------------------------------------------------
//
//  Function:   GetBaseFilename
//
//  Synopsis:   Return a filename with it's extension and path 
//              stripped off
//
//  Arguments:  [pszFileWithExtension]  -- The full filename
//              [pszBaseName]           -- Where to put the base name
//
//  Returns:    <nothing>
//
//  History:    15-Apr-96   MikeW   Created
//              17-Oct-96   EricHans Fixed to return with path stripped
//
//--------------------------------------------------------------------

void Log :: GetBaseFilename(LPSTR pszFileWithExtension, LPSTR pszBaseName)
{
    LPSTR   pszStartOfExtension;
    LPSTR   pszLastBackslash;
    UINT    nCharsInBase;

    pszStartOfExtension = strrchr(pszFileWithExtension, '.');

    // assume this is a fully qualified path or
    // just the filename itself
    pszLastBackslash = strrchr(pszFileWithExtension, '\\');

    if (NULL == pszStartOfExtension)
    {
        // find the end of the string
        pszStartOfExtension = strchr(pszFileWithExtension, '\0');
    }

    if (NULL == pszLastBackslash)
    {
        nCharsInBase = pszStartOfExtension - pszFileWithExtension;

        strncpy(pszBaseName, pszFileWithExtension,  nCharsInBase);
    }
    else
    {
        if (pszLastBackslash > pszStartOfExtension)
        {
            // boundary condition: there's actually a dot in the path
            // find the end of the string instead
            pszStartOfExtension = strchr(pszFileWithExtension, '\0');
        }

        nCharsInBase = (pszStartOfExtension - pszLastBackslash) - 1;    
    
        strncpy(pszBaseName, pszLastBackslash + 1, nCharsInBase);
    }

    pszBaseName[nCharsInBase] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\ctolerpc.cxx ===
//+------------------------------------------------------------------
//
// File:        comtpch.cxx
//
// Contents:    headers to precompile when building all directories
//              in common.
//
// History:     19-Nov-94   DaveY   Created
//
//-------------------------------------------------------------------

#include <ctolerpc.h>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\ctolerpc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       ctolerpc.h
//
//  Synopsis:   Global include file for the ctolerpc project
//
//  History:    31-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#ifndef _CTOLERPC_H_
#define _CTOLERPC_H_



#include "KillWarn.h"

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdarg.h>
#ifdef WIN16
#include <types16.h>
#endif
#include <tchar.h>
#include <direct.h>

#include "macport.h"        // Macintosh-specific stuff

#include "oletypes.h"       // Platform independent ole types
#include "olestr.h"         // ctprintf and olestr functions



#endif // _CTOLERPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\memory\ctmem.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       $(COMTOOLS)\memory\ctmem.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    27-Oct-93   DarrylA     Created.
//              1-May-94    DeanE       Added Heap validation macros.
//              26-May-94   NaveenB     ported to build for 16-bit
//              06-Oct-94   NaveenB     added sifting of the test code
//                  capability
//              10-Oct-94   NaveenB     added IMallocAllocCtm and 
//                  IMallocFreeCtm
//
//----------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <ctmem.hxx>

#ifdef WIN16
#include <types16.h>
#include <stdio.h>
#define NON_TASK_ALLOCATOR 
#define _TEXT(quote) quote
#else
#include <tchar.h>
#endif

#ifdef SIFTING_TEST_CODE

#include <sift.hxx>

ISift *g_psftSiftObject = NULL;

#define SIMULATE_FAILURE( dwRes )                               \
            ((NULL != g_psftSiftObject) &&                      \
                    (g_psftSiftObject->SimFail( ( dwRes ) )))   
#endif

DWORD dwCtValidateHeap = 1;

#if defined(WIN32) && !defined(_CHICAGO_) && !defined(_MAC)
   DWORD dwCtExceptionCode = (DWORD) CT_EXCEPTION_HEAP;
#endif

//+---------------------------------------------------------------------
//
//  Function:   new, new(FAIL_BEHAVIOR), delete
//
//  Synopsis:   Overrides to support the default behavior of the
//              commnot new and delete. Simply uses malloc and free.
//
//  History:    06-Oct-93   DarrylA    Created.
//
//  Notes:
//
//----------------------------------------------------------------------
PVOID __cdecl operator new(unsigned int nSize, FAIL_BEHAVIOR enfb)
{

    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        if(ExceptOnFail == enfb)
        {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call new (ExceptOnFail) in Win16 or Mac\n");
#else
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    else
    {
            return(NULL);
        }
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    PVOID pvTmp;

    pvTmp = (PVOID) malloc(nSize);
    if(ExceptOnFail == enfb)
    {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call new (ExceptOnFail) in Win16 or Mac\n");
#endif
        if(NULL == pvTmp)
        {
#if !defined(WIN16) && !defined(_MAC)
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return pvTmp;

#else      // TASK_ALLOCATOR

    PVOID pvTmp = NULL;

    pvTmp = CoTaskMemAlloc(nSize);
    if (NULL == pvTmp)
    {
        if (ExceptOnFail==enfb)
        {
#if !defined(WIN16) && !defined(_MAC)
            RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return(pvTmp);

#endif 

}

PVOID __cdecl operator new(unsigned int nSize)
{
    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    return (PVOID) malloc(nSize);

#else      // TASK_ALLOCATOR

    PVOID pvTmp = CoTaskMemAlloc(nSize);
    return(pvTmp);

#endif
}


VOID __cdecl operator delete(void *pbData)
{
    VDATEHEAP();

#ifdef NON_TASK_ALLOCATOR

    if(NULL != pbData)
    {
        free(pbData);
    }

#else      // TASK_ALLOCATOR

    CoTaskMemFree(pbData);

#endif
}

//+---------------------------------------------------------------------
//
//  Function:   CtRealloc
//
//  Synopsis:   Adds support for realloc
//
//  History:    31-Dec-97   VaraT    Created.
//
//  Notes:
//
//----------------------------------------------------------------------
PVOID __cdecl CtRealloc(PVOID memBlock,
                         size_t nSize, FAIL_BEHAVIOR enfb)
{

    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        if(ExceptOnFail == enfb)
        {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call Realloc (ExceptOnFail) in Win16 or Mac\n");
#else
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    else
    {
            return(NULL);
        }
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    PVOID pvTmp;

    pvTmp = (PVOID) realloc(memBlock, nSize);
    if(ExceptOnFail == enfb)
    {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call new (ExceptOnFail) in Win16 or Mac\n");
#endif
        if(NULL == pvTmp && nSize != 0)
        {
#if !defined(WIN16) && !defined(_MAC)
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return pvTmp;

#else      // TASK_ALLOCATOR

    PVOID pvTmp = NULL;

    pvTmp = CoTaskMemRealloc(memBlock, nSize);
    if (NULL == pvTmp && nSize != 0)
    {
        if (ExceptOnFail==enfb)
        {
#if !defined(WIN16) && !defined(_MAC)
            RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return(pvTmp);

#endif 

}

PVOID __cdecl CtRealloc(PVOID memBlock, size_t nSize)
{
    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    return (PVOID) realloc(memBlock, nSize);

#else      // TASK_ALLOCATOR

    PVOID pvTmp = CoTaskMemRealloc(memBlock, nSize);
    return(pvTmp);

#endif
}

//+--------------------------------------------------------------
//  Function:   IMallocAllocCtm 
//
//  Synopsis:   Calls the Ole memory allocator and returns the pointer
//              of the new allocated block.  Sifting capability is present
//
//  Arguments:  dwMemctx        specifies whether the memory block is
//                              private to a task or shared between
//                              processes
//              ulCb            size of the memory block
//
//  Returns:    pointer to the allocated block if succeeded else NULL.
//
//  History:    10-Oct-94   NaveenB   Created
//---------------------------------------------------------------

VOID FAR* IMallocAllocCtm(DWORD dwMemctx, ULONG ulCb)
{
    void FAR*   pMemory = NULL;
    LPMALLOC    lpIMalloc = NULL;

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

    if (SUCCEEDED(CoGetMalloc(dwMemctx, &lpIMalloc)))
    {
    if (lpIMalloc != NULL)
    {
            pMemory = lpIMalloc->Alloc(ulCb);
            lpIMalloc->Release();
    }
    }
    else
    {
    OutputDebugString(_TEXT("CoGetMalloc Failed \n"));
    }
    return pMemory;
}

//+--------------------------------------------------------------
//  Function:   IMallocFreeCtm 
//
//  Synopsis:   Calls the Ole memory allocator and returns the pointer
//              of the new allocated block
//
//  Arguments:  dwMemctx        specifies whether the memory block is
//                              private to a task or shared between
//                              processes
//              pv              pointer to the memory block to free
//
//  Returns:    None
//
//  History:    10-Oct-94   NaveenB   Created
//---------------------------------------------------------------

VOID IMallocFreeCtm(DWORD dwMemctx, void FAR* pv)
{
    LPMALLOC    lpIMalloc = NULL;

    if (pv != NULL)
    {
        if (SUCCEEDED(CoGetMalloc(dwMemctx, &lpIMalloc)))
        {
        if (lpIMalloc != NULL)
        {
                lpIMalloc->Free(pv);
                lpIMalloc->Release();
        }
        }
        else
        {
        OutputDebugString(_TEXT("CoGetMalloc Failed \n"));
        }
    }
}

//+--------------------------------------------------------------
//  Function:   IMallocReallocCtm 
//
//  Synopsis:   Calls the Ole memory allocator and returns the pointer
//              of the new allocated block
//
//  Arguments:  dwMemctx        specifies whether the memory block is
//                              private to a task or shared between
//                              processes
//              pv              pointer to the memory block to free
//              cb              New count of allocated memory
//
//  Returns:    None
//
//  History:    5-Nov-97   VaraT   Created
//---------------------------------------------------------------

VOID FAR * IMallocReallocCtm(DWORD dwMemctx, void FAR* pv, DWORD ulCb)
{
    LPMALLOC    lpIMalloc = NULL;
    void FAR*   pMemory = NULL;

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

    if (SUCCEEDED(CoGetMalloc(dwMemctx, &lpIMalloc)))
    {
        if (lpIMalloc != NULL)
        {
                pMemory = lpIMalloc->Realloc(pv, ulCb);
                lpIMalloc->Release();
        }
    }
    else
    {
        OutputDebugString(_TEXT("CoGetMalloc Failed \n"));
    }
    return pMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\oletypes.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       oletypes.h
//
//  Synopsis:   There are several datatypes that Ole uses that are not the
//              same on all platforms.  This file defines several logical 
//              types to use in their place and associated conversion functions
//              to convert between the platform-independent logical types and
//              the "standard" representation of Windows-compatible types
//
//  History:    31-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#ifndef _OLETYPES_H_
#define _OLETYPES_H_



#if defined(WIN16) || (defined(WIN32) && !defined(_MAC))

//
// Windows (16 or 32 bit) types
//

typedef HDC             OleDC;
typedef HGLOBAL         OleHandle;
typedef HMENU           OleMenuHandle;
typedef MSG             OleMessage;
typedef HMETAFILEPICT   OleMetafile;
typedef LOGPALETTE      OlePalette;
typedef RECT            OleRect;
typedef HWND            OleWindow;

#elif defined(_MAC)

//
// Macintosh types
//

typedef GrafPtr         OleDC;
typedef Handle          OleHandle;
typedef MenuHandle      OleMenuHandle;
typedef EventRecord     OleMessage;
typedef PicHandle       OleMetafile;
typedef OLECOLORSCHEME  OlePalette;
typedef Rect            OleRect;
typedef WindowPtr       OleWindow;

#endif



//
// Conversion Functions
//

HRESULT ConvertOleMessageToMSG(const OleMessage *, MSG **);
HRESULT ConvertOleWindowToHWND(OleWindow, HWND *);
HRESULT ConvertOleRectToRECT(const OleRect *, RECT **);
HRESULT ConvertOlePaletteToLOGPALETTE(const OlePalette *, LOGPALETTE **);
HRESULT ConvertOleHandleToHGLOBAL(OleHandle, HGLOBAL *);
HRESULT ConvertOleDCToHDC(OleDC, HDC *);
HRESULT ConvertOleMetafileToMETAFILEPICT(OleMetafile, HMETAFILEPICT *);

HRESULT ConvertMSGToOleMessage(const MSG *, OleMessage **);
HRESULT ConvertHWNDToOleWindow(HWND, OleWindow *);
HRESULT ConvertRECTToOleRect(const RECT *, OleRect **);
HRESULT ConvertLOGPALETTEToOlePalette(const LOGPALETTE *, OlePalette **);
HRESULT ConvertHGLOBALToOleHandle(HGLOBAL, OleHandle *);
HRESULT ConvertHDCToOleDC(HDC, OleDC *);
HRESULT ConvertMETAFILEPICTToOleMetafile(HMETAFILEPICT, OleMetafile *);

#endif // _OLETYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\macport.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       macport.h
//
//  Synopsis:   Defintions for unimplemented stubs & functions & structures
//              for the Macintosh.
//
//-----------------------------------------------------------------------------

#ifndef _MACPORT_H_
#define _MACPORT_H_


//
// WLM is REALLY bad about calling SetLastError when an error occurs.  This
// screws up the upper layer tests pretty badly.  Use this macro when you
// know an error exists and that error 0 (S_OK or ERROR_SUCCESS) is defitely
// wrong.
//

#define HRESULT_FROM_ERROR(x)  (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : E_FAIL)
 

#ifndef _MAC

//
// Stub out some Mac calls if were not building for the mac
//

#define MacInitializeCommandLine()
#define FixHr(x) x
#define MacGetFocus()

//
// Process ID's are completely different on the Mac then on Win32.
//

typedef DWORD ProcessId;


#else // _MAC

//
// Ole types
//

#include <variant.h>
#include <dispatch.h>


typedef DWORD  CLIPFORMAT;
typedef void * HMETAFILEPICT;

#define PHKEY unsigned long *

typedef DWORD REGSAM;

#define TYMED_ENHMF 64

//
// From wchar.h
//

#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif


//
// Wide-char string functions
//

int swprintf( wchar_t *buffer, const wchar_t *format, ... );
int _snwprintf( wchar_t *buffer, size_t count, const wchar_t *format, ... );
wchar_t towupper( wint_t c );
size_t wcslen( const wchar_t *string );
wchar_t *wcscpy( wchar_t *string1, const wchar_t *string2 );
wchar_t *wcsncpy( wchar_t *string1, const wchar_t *string2, size_t count );
int wcscmp( const wchar_t *string1, const wchar_t *string2 );
int _wcsicmp( const wchar_t *string1, const wchar_t *string2 );
wchar_t *wcscat( wchar_t *string1, const wchar_t *string2 );
wchar_t * __cdecl wcschr(const wchar_t *string, wchar_t ch);
wchar_t * __cdecl wcsrchr(const wchar_t *string, wchar_t ch);
wchar_t *wcstok( wchar_t *string1, const wchar_t *string2 );
int iswctype( wint_t c, wctype_t desc );
wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
long   __cdecl wcstol(const wchar_t *, wchar_t **, int);


//
// String conversion functions
//

WINBASEAPI
int
WINAPI
MultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

WINBASEAPI
int
WINAPI
WideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);

#define CP_ACP               0
#define CP_OEMCP             1
#define CP_MACCP             2


//
// More miscellaneous string things
//

LANGID GetSystemDefaultLangID();

#ifndef UNICODE_ONLY
WINBASEAPI
DWORD
WINAPI
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINBASEAPI
DWORD
WINAPI
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define FormatMessage  FormatMessageW
#else
#define FormatMessage  FormatMessageA
#endif // !UNICODE



//
// Network functions
//

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
#ifdef UNICODE
typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;
#else
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#endif // UNICODE

#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#define RESOURCETYPE_RESERVED   0x00000008
#define RESOURCETYPE_UNKNOWN    0xFFFFFFFF

DWORD APIENTRY
WNetAddConnection2A(
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection2W(
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection2  WNetAddConnection2W
#else
#define WNetAddConnection2  WNetAddConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection  WNetCancelConnectionW
#else
#define WNetCancelConnection  WNetCancelConnectionA
#endif // !UNICODE


//
// Command line functions
//

LPSTR GetCommandLineA();
#define GetCommandLine GetCommandLineA

HRESULT MacInitializeCommandLine();

DWORD GetCurrentDirectoryA(
      DWORD  nBufferLength,     // size, in characters, of directory buffer
      LPTSTR  lpBuffer  // address of buffer for current directory 
      );


// 
// Registry functions
//
// Turn off WLM's registry wrappers so we can talk directory to the API's
//

#undef RegCloseKey
#undef RegCreateKey
#undef RegOpenKey
#undef RegSetValue
#undef RegSetValueEx
#undef RegDeleteValue
#undef RegQueryValue
#undef RegQueryValueEx
#undef RegEnumKeyEx

#define RegSetValueEx   CtRegSetValueEx
#define RegQueryValueEx CtRegQueryValueEx

LONG RegCreateKeyEx(
    HKEY hKey,  // handle of an open key 
    LPCTSTR lpSubKey,   // address of subkey name 
    DWORD Reserved, // reserved 
    LPTSTR lpClass, // address of class string 
    DWORD dwOptions,    // special options flag 
    REGSAM samDesired,  // desired security access 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // address of key security structure 
    PHKEY phkResult,    // address of buffer for opened handle  
    LPDWORD lpdwDisposition     // address of disposition value buffer 
   );
LONG RegOpenKeyEx(
    HKEY hKey,  // handle of open key 
    LPCTSTR lpSubKey,   // address of name of subkey to open 
    DWORD ulOptions,    // reserved 
    REGSAM samDesired,  // security access mask 
    PHKEY phkResult     // address of handle of open key 
   );
LONG CtRegSetValueEx(
    HKEY hKey,  // handle of key to set value for  
    LPCTSTR lpValueName,    // address of value to set 
    DWORD Reserved, // reserved 
    DWORD dwType,   // flag for value type 
    CONST BYTE *lpData, // address of value data 
    DWORD cbData    // size of value data 
   );
LONG RegQueryValueEx(
    HKEY hKey,  // handle of key to query 
    LPTSTR lpValueName, // address of name of value to query 
    LPDWORD lpReserved, // reserved 
    LPDWORD lpType, // address of buffer for value type 
    LPBYTE lpData,  // address of data buffer 
    LPDWORD lpcbData    // address of data buffer size 
   );
LONG RegEnumKeyEx(
    HKEY hKey,  // handle of key to enumerate 
    DWORD dwIndex,  // index of subkey to enumerate 
    LPTSTR lpName,  // address of buffer for subkey name 
    LPDWORD lpcbName,   // address for size of subkey buffer 
    LPDWORD lpReserved, // reserved 
    LPTSTR lpClass, // address of buffer for class string 
    LPDWORD lpcbClass,  // address for size of class buffer 
    PFILETIME lpftLastWriteTime     // address for time key last written to 
   );


//
// Process ID's are completely different on the Mac then on Win32.
//

typedef ProcessSerialNumber ProcessId;

#define GetCurrentProcessId MacGetCurrentProcessId
#define OpenProcess         MacOpenProcess

#undef CreateProcess
#define CreateProcess MacCreateProcess

struct MAC_PROCESS_INFORMATION
{
    HANDLE      hProcess;
    HANDLE      hThread;
    ProcessId   dwProcessId;
    ProcessId   dwThreadId;
};

typedef MAC_PROCESS_INFORMATION * LPMAC_PROCESS_INFORMATION;

ProcessId MacGetCurrentProcessId();
HANDLE    MacOpenProcess(DWORD, BOOL, ProcessId);
BOOL      MacCreateProcess(
	     LPCTSTR,
	     LPTSTR,
	     LPSECURITY_ATTRIBUTES,
	     LPSECURITY_ATTRIBUTES,
	     BOOL,
	     DWORD,
	     LPVOID,
	     LPCTSTR,
	     LPSTARTUPINFO,
	     LPMAC_PROCESS_INFORMATION);

		


#define PROCESS_INFORMATION MAC_PROCESS_INFORMATION
#define LPPROCESS_INFORMATION LPMAC_PROCESS_INFORMATION


//
// The WLM IsBadXXX functions just check for NULL, but NULL is ok if the 
// byte count is 0.
//
// Use the weird trinary stuff to prevent warnings about constant boolean
// expressions if c is a constant.
//

#define IsBadReadPtr(p, c)  ((c) ? IsBadReadPtr((p), (c)) : FALSE)
#define IsBadWritePtr(p, c) ((c) ? IsBadWritePtr((p), (c)) : FALSE)

//
// MacOle uses some old values for HRESULTs
// (like 0x80000008 instead of 0x80004005 for E_FAIL)
// This function just converts such old values to
// new ones
//

HRESULT FixHr (HRESULT hrOld);

//
// On the mac, only the foreground app
// can use the clipboard
//
void MacGetFocus ();

BOOL MacIsFullPath (LPCSTR lpszFileName);

#endif // _MAC

#endif // _MACPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\oletypes\mac\oletypes.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       oletypes.cxx
//
//  Synopsis:   Macintosh version of OleTypes
//
//  History:    31-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#include <ctolerpc.h>

//
// Define these here so we don't have to globably include macos\windows.h
//

extern "C" 
{
WINUSERAPI HWND WINAPI          GetWindowWrapper(WindowRef rwnd);
WINUSERAPI WindowRef WINAPI     GetWrapperWindow(HWND hwnd);
}


//+----------------------------------------------------------------------------
//                                                                             
//  Functions:  ConvertOleMessageToMSG                                         
//                                                                             
//  Synopsis:   Covert OleMessage to MSG                                       
//                                                                             
//  Parameters: [event]     -- Pointer to a Mac EventRecord structure          
//              [pp_msg]    -- Where to put a Win32 MSG structure              
//                                                                             
//  Returns:    S_OK if all went well                                          
//                                                                             
//  History:    30-Jul-96   MikeW   Created                                    
//                                                                             
//  Notes:      OleMessage is an EventRecord
//
//              We currently only handle NULL event pointers                   
//                                                                             
//-----------------------------------------------------------------------------
                                                                               
HRESULT ConvertOleMessageToMSG(const OleMessage *event, MSG **pp_msg)               
{                                                                              
    *pp_msg = NULL;                                                            
                                                                               
    if (NULL != event)                                                         
    {                                                                          
        OutputDebugString("ConvertOleMessage only handles NULL events\r\n");   
        return E_NOTIMPL;                                                      
    }                                                                          
                                                                               
    return S_OK;                                                               
}                                                                              



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleWindowToHWND
//
//  Synopsis:   Convert a Mac WindowPtr to a Win32 HWND
//
//  Parameters: [olewindow]         -- The OleWindow
//              [pp_hwnd]           -- Where to put the HWND
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleWindow is a WindowPtr
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleWindowToHWND(OleWindow olewindow, HWND *hwnd)
{
    *hwnd = GetWindowWrapper(olewindow);

    if (NULL == *hwnd)
    {
        OutputDebugString("GetWindowWrapper failed \r\n");
        return E_FAIL;
    }
    else
    {
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleRectToRECT
//
//  Synopsis:   Convert a Mac Rect to a Win32 RECT
//
//  Parameters: [olerect]       -- The Rect
//              [pp_rect]       -- Where to put the RECT
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleRectToRECT(const OleRect *olerect, RECT **pp_rect)
{
    *pp_rect = NULL;

    if (NULL == olerect)
    {
        return S_OK;
    }

    *pp_rect = new RECT;

    if (NULL == *pp_rect)
    {
        return E_OUTOFMEMORY;
    }

    (*pp_rect)->top    = olerect->top;
    (*pp_rect)->bottom = olerect->bottom;
    (*pp_rect)->left   = olerect->left;
    (*pp_rect)->right  = olerect->right;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOlePaletteToLOGPALETTE
//
//  Synopsis:   Convert an OlePalette to a Win32 LOGPALETTE structure
//
//  Parameters: [olepalette]        -- The OlePalette
//              [pp_logpalette]     -- Where to put the LOGPALETTE
//
//  Returns:    S_OK if all went well
//
//  History:    02-Aug-96   MikeW   Created
//
//  Notes:      OlePalette is an OLECOLORSCHEME.
//
//              The layout of an OLECOLOSCHEME is identical to a LOGPALETTE,
//              but some of the names of the structure member names are
//              different.
//
//-----------------------------------------------------------------------------

HRESULT ConvertOlePaletteToLOGPALETTE(
                const OlePalette *olepalette,
                LOGPALETTE      **pp_logpalette)
{
    *pp_logpalette = NULL;

    if (NULL == olepalette)
        return S_OK;

    UINT palette_size = sizeof(LOGPALETTE)
                        + (olepalette->numEntries - 1)
                          * sizeof(PALETTEENTRY);

    *pp_logpalette = (LOGPALETTE *) new BYTE[palette_size];

    if (NULL == *pp_logpalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_logpalette, olepalette, palette_size);
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleHandleToHGLOBAL
//
//  Synopsis:   Convert an OleHandle to an HGLOBAL
//
//  Parameters: [olehandle]         -- The OleHandle
//              [hglobal]           -- Pointer to the HGLOBAL
//
//  Returns:    S_OK if all went well
//  
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleHandle is a Handle
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleHandleToHGLOBAL(OleHandle olehandle, HGLOBAL *hglobal)
{
    long    size;
    void   *data = NULL;
    HRESULT hr = S_OK;

    size = GetHandleSize(olehandle);

    if (0 == size)
    {
        OutputDebugString("WARNING: ConvertOleHandleToHGLOBAL: "
                                   "GetHandleSize returned 0\r\n");
    }

    *hglobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, size);

    if (NULL == *hglobal)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        data = GlobalLock(*hglobal);

        if (NULL == data)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        memcpy(data, *olehandle, size);
    }

    if (NULL != data)
    {
        GlobalUnlock(*hglobal);
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Functions:  ConvertMSGToOleMessage
//
//  Synopsis:   Covert MGS to OleMessage
//
//  Parameters: [msg]       -- Pointer to a Win32 MSG structure
//              [pp_event]  -- Where to put a Mac EventRecord structure
//
//  Returns:    S_OK if all went well
//
//  History:    01-Aug-96   MikeW   Created
//
//  Notes:      OleMessage is an EventRecord
//
//              We currently only handle NULL MSG pointers
//
//-----------------------------------------------------------------------------

HRESULT ConvertMSGToOleMessage(const MSG *msg, OleMessage **pp_event)
{
    *pp_event = NULL;

    if (NULL != msg)
    {
        OutputDebugString("ConvertOleMessage only handles NULL messages\r\n");
        return E_NOTIMPL;
    }

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHWNDToOleWindow
//
//  Synopsis:   Convert a Win32HWND to a Mac WindowPtr
//
//  Parameters: [hwnd]          -- The HWND
//              [olewindow]     -- Where to put the OleWindow
//
//  Returns:    S_OK if all went well
//
//  History:    01-Aug-96   MikeW   Created
//
//  Notes:      OleWindow is a WindowPtr
//
//-----------------------------------------------------------------------------

HRESULT ConvertHWNDToOleWindow(HWND hwnd, OleWindow *olewindow)
{
    *olewindow = GetWrapperWindow(hwnd);

    if (NULL == *olewindow)
    {
        OutputDebugString("GetWindowWrapper failed \r\n");
        return E_FAIL;
    }
    else
    {
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertRECTToOleRect
//
//  Synopsis:   Convert a WIN32 RECT to a OleRect
//
//  Parameters: [rect]          -- The RECT
//              [pp_rect]       -- Where to put the OleRect
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertRECTToOleRect(const RECT *rect, OleRect **pp_olerect)
{
    *pp_olerect = NULL;

    if (NULL == rect)
    {
        return S_OK;
    }

    *pp_olerect = new OleRect;

    if (NULL == *pp_olerect)
    {
        return E_OUTOFMEMORY;
    }

    (*pp_olerect)->top    = (short) rect->top;
    (*pp_olerect)->bottom = (short) rect->bottom;
    (*pp_olerect)->left   = (short) rect->left;
    (*pp_olerect)->right  = (short) rect->right;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHGLOBALToOleHandle
//
//  Synopsis:   Convert an HGLOBAL to an OleHandle
//
//  Parameters: [hglobal]           -- The HGLOBAL
//              [olehandle]         -- Pointer to the OleHandle
//
//  Returns:    S_OK if all went well
//
//  History:    01-Aug-96   MikeW   Created
//
//  Notes:      OleHandle is a Handle
//
//-----------------------------------------------------------------------------

HRESULT ConvertHGLOBALToOleHandle(HGLOBAL hglobal, OleHandle *olehandle)
{
    HRESULT hr = S_OK;
    void   *data = NULL;

    SetLastError(0);

    long size = GlobalSize(hglobal);

    if (0 == size)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (S_OK == hr)
    {
        *olehandle = NewHandle(size);

        if (NULL == *olehandle)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        data = GlobalLock(hglobal);
        
        if (NULL == data)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        memcpy(**olehandle, data, size);
    }

    if (NULL != data)
    {
        GlobalUnlock(data);
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertLOGPALETTEToOlePalette
//
//  Synopsis:   Convert a Win32 LOGPALETTE structure to a OlePalette
//
//  Parameters: [logpalette]        -- The LOGPALETTE
//              [pp_olepalette]     -- Where to put the OlePalette
//
//  Returns:    S_OK if all went well
//
//  History:    02-Aug-96   MikeW   Created
//
//  Notes:      OlePalette is an OLECOLORSCHEME.
//
//              The layout of an OLECOLOSCHEME is identical to a LOGPALETTE,
//              but some of the names of the structure member names are 
//              different.
//
//-----------------------------------------------------------------------------

HRESULT ConvertLOGPALETTEToOlePalette(
                const LOGPALETTE *logpalette, 
                OlePalette     **pp_olepalette)
{
    *pp_olepalette = NULL;

    if (NULL == logpalette)
        return S_OK;

    UINT palette_size = sizeof(LOGPALETTE)
                        + (logpalette->palNumEntries - 1) 
                          * sizeof(PALETTEENTRY);

    *pp_olepalette = (OLECOLORSCHEME *) new BYTE[palette_size];

    if (NULL == *pp_olepalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_olepalette, logpalette, palette_size);
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHDCToOleDC
//
//  Synopsis:   Convert a Win32 HDC to an OleDC
//
//  Parameters: [hdc]           -- The HDC
//              [oledc]         -- The OleDC
//
//  Returns:    S_OK if all went well
//
//  History:    02-Aug-96   MikeW   Created
//
//  Notes:      OleDC is a GrafPtr
//
//-----------------------------------------------------------------------------

HRESULT ConvertHDCToOleDC(HDC hdc, OleDC *oledc)
{
    *oledc = CheckoutPort(hdc, CA_NONE);
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertMETAFILEPICTToOleMetafile
//
//  Synopsis:   Convert a Win32 METAFILEPICT to an OleMetafile
//
//  Parameters: [metafilepict]      -- The METAFILEPICT
//              [olemetafile]       -- The ole metafile
//
//  Returns:    S_OK if all went well
//
//  History:    28-Aug-96   MikeW   Created
//
//  Notes:      OleMetafile is a PICT
//
//-----------------------------------------------------------------------------

HRESULT ConvertMETAFILEPICTToOleMetafile(
                        HMETAFILEPICT metafilepict,
                        OleMetafile  *olemetafile)
{
    PicHandle       pict = NULL;
    METAFILEPICT   *metadata = NULL;
    HRESULT         hr = S_OK;

    *olemetafile = NULL;

    metadata = (METAFILEPICT *) GlobalLock(metafilepict);

    if (NULL == metadata)
    {
        hr = E_FAIL;
    }

    if (S_OK == hr)
    {
        pict = CheckoutPict(metadata->hMF);

        if (NULL == pict)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        *olemetafile = (PicHandle) OleDuplicateData(
                                            (Handle) pict, 
                                            cfPict, 
                                            NULL);
   
        if (NULL == *olemetafile)
        {
            hr = E_FAIL;
        }
    }

    if (NULL != metadata)
    {
        GlobalUnlock(metafilepict);
    }
    if (NULL != pict)
    {
        CheckinPict(metadata->hMF);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\olestr.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  File:       olestr.h
//
//  Synopsis:   ct versions of the printf family and olestr functions
//
//  History:    30-May-96   MikeW      Created.
//              12-Nov-97   a-sverrt   Added a couple more olestrxxx macros.
//
//  Notes:      The ct version of the printf family adds two new format
//              specifiers: %os and %oc.  These specifiers mean ole-string
//              and ole-character respectively.
//
//              In the ANSI-version of this family these specifiers mean
//              "an octal digit followed by the letter s (or c)".  Code that
//              uses octal should be careful when using these functions.
//
//-----------------------------------------------------------------------------

#ifndef _OLESTR_H_
#define _OLESTR_H_



//
// Determine if Ole is Unicode based or not
//

#if !defined(WIN16) && !defined(_MAC)
#define OLE_IS_UNICODE
#endif



//
// Use : as path separator on Mac
//

#ifdef _MAC

#define CH_SEP ':'
#define SZ_SEP TEXT(":")

#else

#define CH_SEP '\\'
#define SZ_SEP TEXT("\\")

#endif // _MAC



//
// Format specifiers for Unicode and Ansi strings and characters
//

#define UNICODE_STRING_SPECIFIER    "ls"
#define UNICODE_CHAR_SPECIFIER      "lc"
#define ANSI_STRING_SPECIFIER       "hs"
#define ANSI_CHAR_SPECIFIER         "hc"



//
// Format specifiers for Ole strings and characters
//

#ifdef OLE_IS_UNICODE

#define OLE_STRING_SPECIFIER    UNICODE_STRING_SPECIFIER
#define OLE_CHAR_SPECIFIER      UNICODE_CHAR_SPECIFIER 

#else // !OLE_IS_UNICODE

#define OLE_STRING_SPECIFIER    ANSI_STRING_SPECIFIER
#define OLE_CHAR_SPECIFIER      ANSI_CHAR_SPECIFIER 

#endif // !OLE_IS_UNICODE



//
// Unicode/Ansi indepedent ctprintf-family
//

#ifndef UNICODE_ONLY

int ctprintfA(const char *format, ...);
int ctsprintfA(char *buffer, const char *format, ...);
int ctsnprintfA(char *buffer, size_t count, const char *format, ...);
int ctfprintfA(FILE *stream, const char *format, ...);
int ctvprintfA(const char *format, va_list varargs);
int ctvsprintfA(char *buffer, const char *format, va_list varargs);
int ctvsnprintfA(
            char *buffer, 
            size_t count, 
            const char *format, 
            va_list varargs);
int ctvfprintfA(FILE *stream, const char *format, va_list varargs);

#endif // !UNICODE_ONLY



#ifndef ANSI_ONLY

int ctprintfW(const wchar_t *format, ...);
int ctsprintfW(wchar_t *buffer, const wchar_t *format, ...);
int ctsnprintfW(wchar_t *buffer, size_t count, const wchar_t *format, ...);
int ctfprintfW(FILE *stream, const wchar_t *format, ...);
int ctvprintfW(const wchar_t *format, va_list varargs);
int ctvsprintfW(wchar_t *buffer, const wchar_t *format, va_list varargs);
int ctvsnprintfW(
            wchar_t *buffer, 
            size_t count, 
            const wchar_t *format, 
            va_list varargs);
int ctvfprintfW(FILE *stream, const wchar_t *format, va_list varargs);

#endif //!ANSI_ONLY



#ifdef UNICODE

#define ctprintf        ctprintfW
#define ctsprintf       ctsprintfW
#define ctsnprintf      ctsnprintfW
#define ctfprintf       ctfprintfW
#define ctvprintf       ctvprintfW
#define ctvsprintf      ctvsprintfW
#define ctvsnprintf     ctvsnprintfW
#define ctvfprintf      ctvfprintfW

#else // !UNICODE

#define ctprintf        ctprintfA
#define ctsprintf       ctsprintfA
#define ctsnprintf      ctsnprintfA
#define ctfprintf       ctfprintfA
#define ctvprintf       ctvprintfA
#define ctvsprintf      ctvsprintfA
#define ctvsnprintf     ctvsnprintfA
#define ctvfprintf      ctvfprintfA

#endif // !UNICODE



//
// Unicode/Ansi independent ole string functions
//

#ifdef OLE_IS_UNICODE


#define  olembstowcs(x,y,z) mbstowcs(x,y,z)
#define  olestrcat          wcscat
#define  olestrchr          wcschr
#define  olestrcmp          wcscmp
#define  olestrcpy          wcscpy
#define _olestricmp        _wcsicmp
#define  olestrlen          wcslen
#define  olestrncmp         wcsncmp
#define  olestrncpy         wcsncpy
#define _olestrnicmp       _wcsnicmp
#define  olestrrchr         wcsrchr
#define  olestrstr          wcsstr
#define  olestrtok          wcstok
#define  olestrtol          wcstol
#define  olestrtoul         wcstoul
#define  olestrtombs(x,y,z) wcstombs(x,y,z)
#define  olewcstombs(x,y,z) wcstombs(x,y,z)
#define  tooleupper         towupper

#define _ltoole            _ltow

#define  olectsnprintf      ctsnprintfW
#define  olectsprintf       ctsprintfW
#define  olesscanf          swscanf
#define  olesprintf         swprintf

#else // !OLE_IS_UNICODE

#define  olembstowcs(x,y,z) strcpy(x,y)
#define  olestrcat          strcat
#define  olestrchr          strchr
#define  olestrcmp          strcmp
#define  olestrcpy          strcpy
#define _olestricmp        _stricmp
#define  olestrlen          strlen
#define  olestrncmp         strncmp
#define  olestrncpy         strncpy
#define _olestrnicmp       _strnicmp
#define  olestrrchr         strrchr
#define  olestrstr          strstr
#define  olestrtok          strtok
#define  olestrtol          strtol
#define  olestrtoul         strtoul
#define  olestrtombs(x,y,z) strncpy(x,y,z)
#define  olewcstombs(x,y,z) strcpy(x,y)      // srt: equivalent to converting in this case
#define  tooleupper         toupper

#define _ltoole            _ltoa

#define  olectsnprintf      ctsnprintfA
#define  olectsprintf       ctsprintfA
#define  olesscanf          sscanf
#define  olesprintf         sprintf

#endif // !OLE_IS_UNICODE



//
// String copy & conversion functions
//

#ifdef __cplusplus

HRESULT CopyString(LPCWSTR, LPSTR *);
HRESULT CopyString(LPCSTR,  LPWSTR *);
HRESULT CopyString(LPCSTR,  LPSTR *);
HRESULT CopyString(LPCWSTR, LPWSTR *);
HRESULT CopyString(LPCWSTR, LPSTR, int, int);
HRESULT CopyString(LPCSTR,  LPWSTR, int, int);


//+--------------------------------------------------------------------------
//
//  unsigned char thunks
//
//  DBCS chars are unsigned so the signed functions above won't match.
//  However, the signed functions are written to be DBCS aware so it's ok
//  to just cast & thunk.
//
//---------------------------------------------------------------------------

inline HRESULT CopyString(LPCWSTR pszSource, unsigned char **ppszDest)
{
    return CopyString(pszSource, (char **) ppszDest);
}

inline HRESULT CopyString(unsigned char *pszSource, LPWSTR *ppszDest)
{
    return CopyString((char *) pszSource, ppszDest);
}

inline HRESULT CopyString(unsigned char *pszSource, unsigned char ** ppszDest)
{
    return CopyString((char *) pszSource, (char **) ppszDest);
}

#endif // __cplusplus



HRESULT TStringToOleString(LPCTSTR pszSource, LPOLESTR *ppszDest);
HRESULT WStringToOleString(LPCWSTR pszSource, LPOLESTR *ppszDest);
HRESULT AStringToOleString(LPCSTR pszSource, LPOLESTR *ppszDest);

HRESULT OleStringToTString(LPCOLESTR pszSource, LPTSTR *ppszDest);
HRESULT OleStringToWString(LPCOLESTR pszSource, LPWSTR *ppszDest);
HRESULT OleStringToAString(LPCOLESTR pszSource, LPSTR *ppszDest);

HRESULT TStringToAString (LPCTSTR pszSource, LPSTR *ppszDest);
HRESULT AStringToTString (LPCSTR pszSource, LPTSTR *ppszDest);


#endif // _OLESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\include\killwarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      killwarn.hxx
//
//  Contents:  Pragma's to kill specific warnings at W4
//
//  History:   28-Nov-94        DeanE   Created
//--------------------------------------------------------------------------
#ifndef __KILLWARN_HXX__
#define __KILLWARN_HXX__

//
//  Quotes taken from vc user's manual
//


// Turn off: unreferenced inline function has been removed
#pragma warning(disable: 4514)

// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.
#pragma warning(disable: 4201)

// 'identifier' : inconsistent DLL linkage. dllexport assumed
//
// The specified member function was declared in a class with dllexport
// linkage, and then was imported. This warning can also be caused by
// declaring a member function in a class with dllimport linkage as neither
// imported nor static nor inline.
//
// The function was compiled as dllexport.
#pragma warning(disable: 4273)

// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.
#pragma warning(disable: 4512)

// 'function': function not expanded
//
// The given function was selected for inline expansion but the compiler did 
// not perform the inlining.
#pragma warning(disable:4710)

// trigraph not being substituted
#pragma warning (disable: 4110)

#ifdef _MAC
// alignment of a memeber was sensitive to packing
#pragma warning (disable: 4121)
#endif // _MAC

#endif  // __KILLWARN_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\olestr\ctprintf.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  File:       ctprintf.cxx
//
//  Synopsis:   ct versions of the printf family
//
//  History:    30-May-96   MikeW   Created
//
//  Notes:      The ct version of the printf family adds two new format
//              specifiers: %os and %oc.  These specifiers mean ole-string
//              and ole-character respectively.
//
//              In the ANSI-version of this family these specifiers mean
//              "an octal digit followed by the letter s (or c)".  Code that
//              uses octal should be careful when using these functions.
//
//-----------------------------------------------------------------------------

#include <ctolerpc.h>
#pragma hdrstop



//
// MAX_FORMAT_SPECIFIER_BUFFER is the maximum length of a (munged) format
// specifier
//

const MAX_FORMAT_SPECIFIER_BUFFER = 1024;

//
// MAKE_UNICODE unconditionally makes a string or char constant Unicode
//

#define _MAKE_UNICODE(x)    L##x
#define MAKE_UNICODE(x)     _MAKE_UNICODE(x)



#ifndef UNICODE_ONLY

//+----------------------------------------------------------------------------
//
//  Function:   MungeFormatSpecifiersA
//
//  Synopsis:   Convert the 'os' and 'oc' printf-format specifier to the right 
//              thing to handle Ole strings and Ole chars.
//
//  Parameters: [format]            -- The format string to convert
//              [munged_format]     -- Where to put the munged format
//
//  Returns:    void
//
//  History:    30-May-96   MikeW   Created
//
//  Notes:      In the regular printf family "%os" and "%oc" evaluate to 
//              an octal number followed by a 's' or a 'c'.  To get these
//              cases to work always put some character (such as a space)
//              after a %o specifier.
//
//-----------------------------------------------------------------------------

void MungeFormatSpecifiersA(const char *format, char *munged_format)
{
    const char *start_of_uncopied_data;
    
    *munged_format = '\0';

    start_of_uncopied_data = format;
    format = strchr(format, '%');

    while (NULL != format)
    {
        //
        // Find the type of the format specifier.
        // Watch out for "%%" and "%<null terminator>".
        //

        do
        {
            ++format;
        }
        while ('%' != *format && '\0' != *format && !isalpha(*format));

        strncat(
                munged_format, 
                start_of_uncopied_data, 
                format - start_of_uncopied_data);

        start_of_uncopied_data = format;
        
        //
        // Munge it to the right thing for %os or %oc
        //

        if ('o' == *format && 's' == *(format + 1))
        {
            strcat(munged_format, OLE_STRING_SPECIFIER);
            format += 1;       
            start_of_uncopied_data += 2;
        }
        else if ('o' == *format && 'c' == *(format + 1))
        {
            strcat(munged_format, OLE_CHAR_SPECIFIER);
            format += 1;
            start_of_uncopied_data += 2;
        }

        format = strchr(format + 1, '%');
    }

    strcat(munged_format, start_of_uncopied_data);
}



//+----------------------------------------------------------------------------
//
//  Functions:  ctprintfA, ctsprintfA, ctsnprintfA, ctfprintfA
//              ctvprintfA, ctvsprintfA, ctvsnprintfA, ctvfprintfA
//      
//  Synopsis:   ct versions of standard ANSI printf family
//
//  History:    30-May-96   MikeW   Created
//
//-----------------------------------------------------------------------------

int ctprintfA(const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvprintfA(format, varargs);
}

int ctsprintfA(char *buffer, const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsprintfA(buffer, format, varargs);
}

int ctsnprintfA(char *buffer, size_t count, const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsnprintfA(buffer, count, format, varargs);
}

int ctfprintfA(FILE *stream, const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvfprintfA(stream, format, varargs);
}

int ctvprintfA(const char *format, va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return vprintf(munged_format, varargs);
}

int ctvsprintfA(char *buffer, const char *format, va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return vsprintf(buffer, munged_format, varargs);
}

int ctvsnprintfA(
            char *buffer, 
            size_t count, 
            const char *format, 
            va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return _vsnprintf(buffer, count, munged_format, varargs);
}

int ctvfprintfA(FILE *stream, const char *format, va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return vfprintf(stream, munged_format, varargs);
}

#endif // !UNICODE_ONLY



#ifndef ANSI_ONLY

//+----------------------------------------------------------------------------
//
//  Function:   MungeFormatSpecifiersW
//
//  Synopsis:   Convert the 'os' and 'oc' printf-format specifier to the right 
//              thing to handle Ole strings and Ole chars.
//
//  Parameters: [format]            -- The format string to convert
//              [munged_format]     -- Where to put the munged format
//
//  Returns:    void
//
//  History:    30-May-96   MikeW   Created
//
//  Notes:      In the regular printf family "%os" and "%oc" evaluate to 
//              an octal number followed by a 's' or a 'c'.  To get these
//              cases to work always put some character (such as a space)
//              after a %o specifier.
//
//-----------------------------------------------------------------------------

void MungeFormatSpecifiersW(const wchar_t *format, wchar_t *munged_format)
{
    const wchar_t *start_of_uncopied_data;
    
    *munged_format = L'\0';

    start_of_uncopied_data = format;
    format = wcschr(format, L'%');

    while (NULL != format)
    {
        //
        // Find the type of the format specifier.
        // Watch out for "%%" and "%<null terminator>".
        //

        do
        {
            ++format;
        }
        while (L'%' != *format && L'\0' != *format && !iswalpha(*format));

        wcsncat(
                munged_format, 
                start_of_uncopied_data, 
                format - start_of_uncopied_data);

        start_of_uncopied_data = format;
        
        //
        // Munge it to the right thing for %os or %oc
        //

        if (L'o' == *format && L's' == *(format + 1))
        {
            wcscat(munged_format, MAKE_UNICODE(OLE_STRING_SPECIFIER));
            format += 1;       
            start_of_uncopied_data += 2;
        }
        else if (L'o' == *format && L'c' == *(format + 1))
        {
            wcscat(munged_format, MAKE_UNICODE(OLE_CHAR_SPECIFIER));
            format += 1;
            start_of_uncopied_data += 2;
        }

        format = wcschr(format + 1, '%');
    }

    wcscat(munged_format, start_of_uncopied_data);
}



//+----------------------------------------------------------------------------
//
//  Functions:  ctprintfW, ctsprintfW, ctsnprintfW, ctfprintfW
//              ctvprintfW, ctvsprintfW, ctvsnprintfW, ctvfprintfW
//      
//  Synopsis:   ct versions of standard Unicode printf family
//
//  History:    30-May-96   MikeW   Created
//
//-----------------------------------------------------------------------------

int ctprintfW(const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvprintfW(format, varargs);
}

int ctsprintfW(wchar_t *buffer, const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsprintfW(buffer, format, varargs);
}

int ctsnprintfW(wchar_t *buffer, size_t count, const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsnprintfW(buffer, count, format, varargs);
}

int ctfprintfW(FILE *stream, const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvfprintfW(stream, format, varargs);
}

int ctvprintfW(const wchar_t *format, va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return vwprintf(munged_format, varargs);
}

int ctvsprintfW(wchar_t *buffer, const wchar_t *format, va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return vswprintf(buffer, munged_format, varargs);
}

int ctvsnprintfW(
            wchar_t *buffer, 
            size_t count, 
            const wchar_t *format, 
            va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return _vsnwprintf(buffer, count, munged_format, varargs);
}

int ctvfprintfW(FILE *stream, const wchar_t *format, va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return vfwprintf(stream, munged_format, varargs);
}

#endif // !ANSI_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\olestr\convert.cxx ===
//+--------------------------------------------------------------------------
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  File:       convert.cxx
//
//  Synopsis:   Functions for converting between LPSTR, LPWSTR, LPTSTR, and
//              LPOLESTR
//
//  Functions:  CopyString (all versions)
//
//              TStringToOleString
//              WStringToOleString
//              AStringToOleString
//              OleStringToTString
//              OleStringToWString
//              OleStringToAString
//
//  History:    01-Aug-96   MikeW   Created
//              31-Oct-96   MikeW   Re-wrote to be DBCS aware
//                                  and less code duplication
//
//---------------------------------------------------------------------------

#include <ctolerpc.h>
#pragma hdrstop


//
// NOTE!  There are seven functions called CopyString.  Collectively
//        they handle copying and converting strings composed of signed,
//        unsigned, and wide chars.  C++ polymorphism serves to distinguish
//        them from one another.
//
//        Three of the CopyString functions are implemented as inline
//        thunks defined in olestr.h
//

#ifndef WIN16

//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a wide (Unicode) string to a multibyte string
//
//  Parameters: [pszSource]     -- The wide string
//              [ppszDest]      -- Where to put the multibyte string
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = WideCharToMultiByte(                        
                        CP_ACP,
                        0,
                        pszSource,
                        -1,
                        *ppszDest,
                        0,
                        NULL,
                        NULL);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Allocate the buffer
    //

    if(S_OK == hr)
    {
        *ppszDest = new char[bufferSize];

        if (NULL == *ppszDest)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pszSource,
                                -1,
                                *ppszDest,
                                bufferSize,
                                NULL,
                                NULL);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Clean up if there's an error
    //

    if (S_OK != hr && NULL != *ppszDest)
    {
        delete [] *ppszDest;
        *ppszDest = NULL;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a multibyte string to a wide (Unicode) string
//
//  Parameters: [pszSource]     -- The multibyte string
//              [ppszDest]      -- Where to put the wide string
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPWSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pszSource,
                        -1,
                        *ppszDest,
                        0);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Allocate the buffer
    //

    if(S_OK == hr)
    {
        *ppszDest = new WCHAR[bufferSize];

        if (NULL == *ppszDest)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszSource,
                            -1,
                            *ppszDest,
                            bufferSize);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Clean up if there's an error
    //

    if (S_OK != hr && NULL != *ppszDest)
    {
        delete [] *ppszDest;
        *ppszDest = NULL;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Copy a wide (Unicode) string
//
//  Parameters: [pszSource]             -- The original string
//              [ppszDest]              -- The copy
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPWSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    // 
    // Find the length of the original string
    //

    bufferSize = wcslen(pszSource) + 1;

    //
    // Allocate the buffer
    //

    *ppszDest = new WCHAR[bufferSize];

    if (NULL == *ppszDest)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Copy the string
    //

    if (S_OK == hr)
    {
        wcscpy(*ppszDest, pszSource);
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a wide (Unicode) string to a multibyte string
//              cchSource can be -1 which means source is null terminated.
//
//  Parameters: [pszSource]     -- The wide string
//              [pszDest]       -- Where to put the multibyte string
//              [cchSource]     -- count of characters of source
//              [cchDest]       -- count of characters of destination
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPSTR pszDest,
    int cchSource, int cchDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = WideCharToMultiByte(                        
                        CP_ACP,
                        0,
                        pszSource,
                        cchSource,
                        pszDest,
                        0,
                        NULL,
                        NULL);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (bufferSize > cchDest)
    {
        hr = E_INVALIDARG;
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pszSource,
                                cchSource,
                                pszDest,
                                cchDest,
                                NULL,
                                NULL);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a multibyte string to a wide (Unicode) string
//              cchSource can be -1 which means source is null terminated.
//
//  Parameters: [pszSource]     -- The multibyte string
//              [pwszDest]      -- Where to put the wide string
//              [cchSource]     -- count of characters of source
//              [cchDest]       -- count of characters of destination
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPWSTR pwszDest,
        int cchSource, int cchDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pszSource,
                        cchSource,
                        pwszDest,
                        0);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (bufferSize > cchDest)
    {
        hr = E_INVALIDARG;
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszSource,
                            cchSource,
                            pwszDest,
                            cchDest);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


#endif


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Copy a multibyte string
//
//  Parameters: [pszSource]             -- The original string
//              [ppszDest]              -- The copy
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    // 
    // Find the length of the original string (in bytes for DBCS)
    //

    bufferSize = strlen(pszSource) + 1;

    //
    // Allocate the buffer
    //

    *ppszDest = new char[bufferSize];

    if (NULL == *ppszDest)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Copy the string
    //

    if (S_OK == hr)
    {
        strcpy(*ppszDest, pszSource);
    }

    return hr;
}




//+----------------------------------------------------------------------------
//
//  -X-StringTo-Y-String functions
//
//  Synopsis:   Convert from a 'T' string to an Ole string
//
//  Parameters: [pszSource]     -- The T string
//              [ppszDest]      -- Where to put the Ole string
//
//  Returns:    S_OK if all went well
//
//  Notes:      The implementation of these functions are all identical.
//              C++ polymorphism serves to make sure the right version
//              of CopyString gets called.
//
//              If *ppszDest is non NULL when this function returns, the
//              caller is responsible for freeing the memory allocated at
//              [*ppszDest]
//
//              For the XStringToYString functions involving Ole types:
//              
//              If system and OLE use the same string type (e.g UNICODE on
//              NT; CHAR on MAC & Win16) , then this function allocates memory
//              for the new string and does a simple string copy.
//
//              If UNICODE is NOT defined, but OLE is unicode (as in Win95),
//              a CHAR to WCHAR conversion is performed.
//
//              If UNICODE is defined, but OLE is NOT unicode (not in any
//              system at present), a WCHAR to CHAR conversion is performed.
//
//-----------------------------------------------------------------------------

HRESULT TStringToOleString(LPCTSTR pszSource, LPOLESTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}


HRESULT OleStringToTString(LPCOLESTR pszSource, LPTSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}


HRESULT AStringToOleString(LPCSTR pszSource, LPOLESTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}
HRESULT OleStringToAString(LPCOLESTR pszSource, LPSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}

HRESULT AStringToTString(LPCSTR pszSource, LPTSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}
HRESULT TStringToAString(LPCTSTR pszSource, LPSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}

#ifndef WIN16

HRESULT WStringToOleString(LPCWSTR pszSource, LPOLESTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}
HRESULT OleStringToWString(LPCOLESTR pszSource, LPWSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolerpc\oletypes\windows\oletypes.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       oletypes.cxx
//
//  Synopsis:   Windows versions of Ole types conversion routines
//
//  History:    30-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#include <ctolerpc.h>



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleMessageToMSG
//
//  Synopsis:   Convert an OleMessage to a MSG
//
//  Parameters: [olemessage]        -- Pointer to the OleMessage
//              [pp_msg]            -- Where to put the MSG pointer
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleMessage is a MSG
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleMessageToMSG(const OleMessage * olemessage, MSG ** pp_msg)
{
    *pp_msg = NULL;

    if (NULL != olemessage)
    {
        *pp_msg = new MSG;

        if (NULL == *pp_msg)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(*pp_msg, olemessage, sizeof(MSG));
    }

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleWindowToHWND
//
//  Synopsis:   Convert an OleWindow to a HWND
//
//  Parameters: [olewindow]         -- The OleWindow
//              [hwnd]              -- Where to put the HWND
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleWindow is a HWND
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleWindowToHWND(OleWindow olewindow, HWND *hwnd)
{
    *hwnd = olewindow;
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleRectToRECT
//
//  Synopsis:   Convert an OleRect to a RECT
//
//  Parameters: [olerect]       -- The OleRect
//              [pp_rect]       -- Where to put the RECT
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleRectToRECT(const OleRect *olerect, RECT **pp_rect)
{
    *pp_rect = NULL;

    if (NULL == olerect)
    {
        return S_OK;
    }

    *pp_rect = new RECT;

    if (NULL == *pp_rect)
    {
        return E_OUTOFMEMORY;
    }
    
    memcpy(*pp_rect, olerect, sizeof(RECT));
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOlePaletteToLOGPALETTE
//
//  Synopsis:   Convert an OlePalette to a Win32 LOGPALETTE structure
//
//  Parameters: [olepalette]        -- The OlePalette
//              [pp_logpalette]     -- Where to put the LOGPALETTE
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov  MikeW   Created
//
//  Notes:      OlePalette is a LOGPALETTE. 
//
//-----------------------------------------------------------------------------

HRESULT ConvertOlePaletteToLOGPALETTE(
                const OlePalette *olepalette,
                LOGPALETTE      **pp_logpalette)
{
    *pp_logpalette = NULL;

    if (NULL == olepalette)
        return S_OK;

    //
    // Calculate the number of bytes we need for the entire LOGPALETTE
    // structure.  We subtract one because LOGPALETTE already has room
    // for one palette entry.
    //

    UINT palette_size = sizeof(LOGPALETTE)
                        + (olepalette->palNumEntries - 1)
                          * sizeof(PALETTEENTRY);

    *pp_logpalette = (LOGPALETTE *) new BYTE[palette_size];

    if (NULL == *pp_logpalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_logpalette, olepalette, palette_size);
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleHandleToHGLOBAL
//
//  Synopsis:   Convert an OleHandle to an HGLOBAL
//
//  Parameters: [olehandle]     -- The OleHandle
//              [hglobal]       -- Pointer to the HGLOBAL
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleHandle is an HGLOBAL
//
//              The HGLOBAL is always allocated with GMEM_MOVEABLE and 
//              GMEM_SHARE.
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleHandleToHGLOBAL(OleHandle olehandle, HGLOBAL *hglobal)
{
    void   *olebytes = NULL;
    void   *bytes = NULL;
    HRESULT hr = S_OK;

    *hglobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, GlobalSize(olehandle));

    if (NULL == hglobal)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        olebytes = GlobalLock(olehandle);

        if (NULL == olebytes)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        bytes = GlobalLock(*hglobal);

        if (NULL == olebytes)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    } 

    if (S_OK == hr)
    {
        memcpy(bytes, olebytes, GlobalSize(olehandle));
    }

    if (NULL != bytes)
    {
        GlobalUnlock(*hglobal);
    }
    if (NULL != olebytes)
    {
        GlobalUnlock(olehandle);
    }

    return hr;
}  



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHWNDToOleWindow
//
//  Synopsis:   Convert a Win32 HWND to an OleWindow
//
//  Parameters: [hwnd]          -- The HWND
//              [olewindow]     -- Where to put the OleWindow
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleWindow is a HWND
//
//-----------------------------------------------------------------------------

HRESULT ConvertHWNDToOleWindow(HWND hwnd, OleWindow *olewindow)
{
    *olewindow = hwnd;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertRECTToOleRect
//
//  Synopsis:   Convert a WIN32 RECT to an OleRect
//
//  Parameters: [rect]          -- The RECT
//              [pp_olerect]    -- Where to put the OleRect
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertRECTToOleRect(const RECT *rect, OleRect **pp_olerect)
{   
    *pp_olerect = NULL;

    if (NULL == rect)
    {
        return S_OK;
    }

    *pp_olerect = new OleRect;

    if (NULL == *pp_olerect)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*pp_olerect, rect, sizeof(RECT));
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHGLOBALToOleHandle
//
//  Synopsis:   Convert an HGLOBAL to an OleHandle
//
//  Parameters: [hglobal]           -- The HGLOBAL
//              [olehandle]         -- Pointer to the OleHandle
//
//  Returns:    S_OK if all went well
//
//  History:    05-Nov-96   BogdanT   Created
//
//  Notes:      OleHandle is a HGLOBAL
//
//-----------------------------------------------------------------------------

HRESULT ConvertHGLOBALToOleHandle(HGLOBAL hglobal, OleHandle *pOlehandle)
{
    HRESULT hr = S_OK;
    UINT    flags = 0;
    LPVOID  lpSrc = NULL, lpDest = NULL;

    *pOlehandle = NULL;
    
    SetLastError(0);

    long size = GlobalSize(hglobal);

    if (0 == size)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (S_OK == hr)
    {
        flags = GlobalFlags(hglobal);

        if (GMEM_INVALID_HANDLE == flags)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        *pOlehandle = GlobalAlloc(flags, size);

        if (NULL == *pOlehandle)
        {
            hr =  HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        lpSrc = GlobalLock(hglobal);

        if (NULL == lpSrc)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        lpDest = GlobalLock(*pOlehandle);

        if (NULL == lpDest)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        CopyMemory(lpDest, lpSrc, size);
        
        if(FALSE == GlobalUnlock(hglobal))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if(FALSE == GlobalUnlock(*pOlehandle))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHDCToOleDC
//
//  Synopsis:   Convert a Win32 HDC to an OleDC
//
//  Parameters: [hdc]           -- The HDC
//              [oledc]         -- The OleDC
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleDC is a hDC
//
//-----------------------------------------------------------------------------

HRESULT ConvertHDCToOleDC(HDC hdc, OleDC *oledc)
{
    *oledc = hdc;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertMETAFILEPICTToOleMetafile
//
//  Synopsis:   Convert a Win32 METAFILEPICT to an OleMetafile
//
//  Parameters: [metafilepict]      -- The METAFILEPICT
//              [olemetafile]       -- The ole metafile
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleMetafile is a HMETAFILEPICT
//
//-----------------------------------------------------------------------------

HRESULT ConvertMETAFILEPICTToOleMetafile(
                        HMETAFILEPICT metafilepict,
                        OleMetafile  *olemetafile)
{
    HRESULT         hr = S_OK;
    
    *olemetafile = (HMETAFILEPICT) OleDuplicateData(
                                            metafilepict,
                                            CF_METAFILEPICT,
                                            NULL);

    if (NULL == *olemetafile)
    {
        hr = HRESULT_FROM_ERROR(GetLastError());
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertLOGPALETTEToOlePalette
//
//  Synopsis:   Convert a Win32 LOGPALETTE structure to a OlePalette
//
//  Parameters: [logpalette]        -- The LOGPALETTE
//              [pp_olepalette]     -- Where to put the OlePalette
//
//  Returns:    S_OK if all went well
//
//  History:    17-Jan-97   EmanP   Created
//
//  Notes:      OlePalette is an LOGPALETTE.
//
//-----------------------------------------------------------------------------

HRESULT ConvertLOGPALETTEToOlePalette(
                const LOGPALETTE *logpalette,
                OlePalette     **pp_olepalette)
{
    *pp_olepalette = NULL;

    if (NULL == logpalette)
        return S_OK;

    UINT palette_size = sizeof(LOGPALETTE)
                        + (logpalette->palNumEntries - 1)
                          * sizeof(PALETTEENTRY);

    *pp_olepalette = (LOGPALETTE *) new BYTE[palette_size];

    if (NULL == *pp_olepalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_olepalette, logpalette, palette_size);
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\chancend.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       chancend.cxx
//
//  Contents:   Implementation for ChanceNode objects.
//
//  Classes:    ChanceNode
//
//  Functions:  ChanceNode
//              ~ChanceNode
//              AppendChildStorage
//              AppendSisterStorage
//
//  History:    DeanE   12-Mar-96   Created
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
//
DH_DECLARE;


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::ChanceNode, public
//
//  Synopsis:   Constructor.  Initializes object with the values passed.
//
//  Arguments:  [cStg]     - Number of direct child storages of this node
//              [cStm]     - Number of streams to create in this node
//              [cbStmMin] - Minimum number of bytes/stream.
//              [cbStmMax] - Maximum number of bytes/stream.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
ChanceNode::ChanceNode(
        ULONG cStg,
        ULONG cStm,
        ULONG cbStmMin,
        ULONG cbStmMax) : _pcnChild(NULL),
                          _pcnSister(NULL),
                          _pcnParent(NULL),
                          _cStorages(cStg),
                          _cStreams(cStm),
                          _cbMinStream(cbStmMin),
                          _cbMaxStream(cbStmMax)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode ctor"));

    DH_ASSERT(cbStmMin <= cbStmMax);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::~ChanceNode, public
//
//  Synopsis:   Destructor.  Deletes any children and sisters.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
ChanceNode::~ChanceNode()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode dtor"));

    delete _pcnChild;
    delete _pcnSister;
}


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::AppendChildStorage, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' child
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
HRESULT ChanceNode::AppendChildStorage(ChanceNode *pcnNew)
{
    ChanceNode *pcnTrav = this;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode::AppendChildStorage"));

    // Find the last child in the structure
    //
    while (NULL != pcnTrav->_pcnChild)
    {
        pcnTrav = pcnTrav->_pcnChild;
    }

    // Append the new node as a child of the last node,
    // increase the number of storages of the last node,
    // and make the new node point to the last node as it's parent
    //
    pcnTrav->_pcnChild = pcnNew;
    pcnTrav->_cStorages++;
    pcnNew->_pcnParent = pcnTrav;

    return(S_OK);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::AppendSisterStorage, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' sister
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
HRESULT ChanceNode::AppendSisterStorage(ChanceNode *pcnNew)
{
    ChanceNode *pcnTrav = this;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode::AppendSisterStorage"));

    // Find the last sister of this node
    //
    while (NULL != pcnTrav->_pcnSister)
    {
        pcnTrav = pcnTrav->_pcnSister;
    }

    // Append the new node as a sister of the last node,
    // increase the number of storages of this nodes' parent,
    // and make the new node point to this nodes parent as it's parent
    //
    pcnTrav->_pcnSister = pcnNew;
    pcnTrav->_pcnParent->_cStorages++;
    pcnNew->_pcnParent = pcnTrav->_pcnParent;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dbcs\test\main.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       main.cxx
//
//  Contents:   DBCS enabled OLE storage
//
//  History:	11/05/97    BogdanT    created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <dbcs.hxx>
#include <locale.h>

DH_DEFINE;

int __cdecl main(int argc, char *argv[])
{
    HRESULT hr          = S_OK;
    UINT nCount         = 0;
    LPTSTR ptszName    = NULL;
    LPWSTR pwszName    = NULL;
    LPSTORAGE  pIStg    = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_TRACE1, _TEXT("main"));

    CDBCSStringGen dbcsgen;

    if(argc < 2)
    {
        printf("Usage: dbcstest <number of string>");
        exit(1);
    }

    dbcsgen.Init(0);

    for(nCount = atoi(argv[1]); nCount>0; nCount--)
    {
        hr = dbcsgen.GenerateRandomFileName(&ptszName);

        hr = TStrToWStr(ptszName, &pwszName);
        DH_HRCHECK(hr, TEXT("TStrToWStr")) ;        
        
        if(S_OK != hr)
            break;

        hr = StgCreateDocfile(pwszName, 
                              STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                              0,
                              &pIStg);

        DH_HRCHECK(hr, TEXT("StgCreateDocfile"));

        if(S_OK != hr)
            break;

        pIStg->Release();

        _tprintf(TEXT("%s\n"), ptszName);

        delete[] ptszName;
        delete[] pwszName;
    }

    return (int)hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dbcs\dbcs.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1995 - 1997.
//
//  File:       dbcs.cxx
//
//  Contents:   Contains DBCS string generator
//
//  History:    03-Nov-97       BogdanT     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#include <dbcs.hxx>

DH_DECLARE;

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::CDBCSStringGen
//
//  Synopsis:   Constructor
//
//  Parameters: none
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
CDBCSStringGen::CDBCSStringGen()
{
#ifdef _MAC
    m_uCodePage     = 1252;
#else
    m_uCodePage     = GetACP();
#endif
    m_fSystemIsDBCS = TRUE;
    m_hDataFile     = NULL;
    m_ptszDataFile  = NULL;
    m_cFileNames    = 0;
    m_pdgi          = NULL;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::~CDBCSStringGen
//
//  Synopsis:   Destructor
//
//  Parameters: 
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
CDBCSStringGen::~CDBCSStringGen()
{
    delete[] m_ptszDataFile;
    delete m_pdgi;
    if(NULL != m_hDataFile)
    {
        fclose(m_hDataFile);
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::Init
//
//  Synopsis:   Initialize the object
//
//  Parameters: [dwSeed]    -- used to seed the internal DG object
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
HRESULT CDBCSStringGen::Init(DWORD dwSeed)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("CDBCSStringGen::Init"));

    _tsetlocale(LC_ALL, TEXT("")); // set locale for RTL routine;
                                   // if we don't, console output won't work
                                   // with DBCS strings

    if(S_OK == hr)
    {
        m_pdgi = new DG_INTEGER(dwSeed);

        if(NULL == m_pdgi)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new DG_INTEGER"));
        }
    }

    if(S_OK == hr)
    {
        m_ptszDataFile = new TCHAR[_MAX_FNAME];

        if(NULL == m_ptszDataFile)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new TCHAR"));
        }
    }

    // check if system is DBCS and set the data file accordingly
    
    m_fSystemIsDBCS = TRUE;

    switch(m_uCodePage)
    {
        case CP_JPN:  _tcscpy(m_ptszDataFile, NAMEFILE_JPN);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS Japan - ACP %d"), m_uCodePage));
                      break;

        case CP_CHS:  _tcscpy(m_ptszDataFile, NAMEFILE_CHS);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS China - ACP %d"), m_uCodePage));
                      break;

        case CP_KOR:  _tcscpy(m_ptszDataFile, NAMEFILE_KOR);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS Korea - ACP %d"), m_uCodePage));
                      break;

        case CP_CHT:  _tcscpy(m_ptszDataFile, NAMEFILE_CHT);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS Taiwan/Hong Kong - ACP %d"), m_uCodePage));
                      break;

        default:      _tcscpy(m_ptszDataFile, TEXT(""));
                      DH_TRACE((DH_LVL_DFLIB, TEXT("SBCS - ACP %d"), m_uCodePage));
                      m_fSystemIsDBCS = FALSE;
                      break;
    }

    if(S_OK == hr)
    {
        if(m_fSystemIsDBCS)
        {
            DH_ASSERT(NULL!=m_ptszDataFile);
            m_hDataFile = _tfopen(m_ptszDataFile, TEXT("r"));

            if(NULL == m_hDataFile)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DH_HRCHECK(hr, TEXT("_tfopen"));
            }

            if(S_OK == hr)
            {
                m_cFileNames = CountNamesInFile();
            }
        }
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::CountNamesInFile
//
//  Synopsis:   Count number of filenames in data file
//
//  Parameters: none
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
UINT CDBCSStringGen::CountNamesInFile()
{
    UINT cNames = 0;
    
    TCHAR lptszCrtLine[MAX_LINE_SIZE]; 

    if(FALSE == m_fSystemIsDBCS) // there is no data file if system is not DBCS
    {
        return 0;
    }

    DH_ASSERT(NULL != m_hDataFile);
    fseek(m_hDataFile, SEEK_SET, 0);

    // count all valid lines in the file

    while(_fgetts(lptszCrtLine, MAX_LINE_SIZE-1, m_hDataFile))
    {
        // we assume every line containing a filename starts with
        // a hex character
        // e.g. fc4b,8140,fc4b,2e,54,78,54
    
        if(_istxdigit(lptszCrtLine[0]))
        {
            cNames++;
        }
    }

    fseek(m_hDataFile, SEEK_SET, 0);

    return cNames;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::GenerateRandomFileName
//
//  Synopsis:   Generate a random filename from the current data file
//
//  Parameters: [pptszName] -- pointer to receive the generated name
//
//  History:    03-Nov-97       BogdanT     Created
//
//  Comments:   This function allocates space for the filename; the caller
//              is responsible for freeing the memory
//
//---------------------------------------------------------------------------
HRESULT CDBCSStringGen::GenerateRandomFileName(LPTSTR *pptszName)
{
    HRESULT hr          = S_OK;
    UINT uNameIndex     = 0xffff;
    LPSTR lpHex         = NULL;
    LPSTR lpName        = NULL;
    INT nStringLen      = 0;
    LPTSTR ptszDest     = NULL;

    CHAR szNameInHex[MAX_LINE_SIZE];
    CHAR szDBCSName[_MAX_FNAME];

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("CDBCSStringGen::GenerateRandomFileName"));

    DH_VDATEPTROUT(pptszName, LPTSTR*);

    if(0 == m_cFileNames)
    {
        return S_FALSE;
    }

    DH_ASSERT(NULL != m_pdgi);
    m_pdgi->Generate(&uNameIndex, 0, m_cFileNames-1);

    hr = GetFileNameFromFile(uNameIndex, szNameInHex);

    DH_HRCHECK(hr, TEXT("GetFileNameFromFile"));

    if(S_OK == hr)
    {
        // now convert ascii hex string
        // the strings look like this: fc4b,8140,fc4b,2e,54,78,54

        for(lpHex=szNameInHex, lpName = szDBCSName; *lpHex!='\0'; lpName++)
        {
            while(!isxdigit(*lpHex) && *lpHex!='\0')
            {
                lpHex++;
            }

            // bail if we reach the end
            if(*lpHex == '\0')
                break;
 
            *lpName = (CHAR)(16*Hex(*lpHex++));
            
            //
            // the only assumption we make is that the two hex digits that
            // represent each byte are not separated;
            //
            // you will get an assert in the next line if the file contains 
            // something like "1f,4 b"
            //                     ^-non hex digit here
            //
            DH_ASSERT(isxdigit(*lpHex));

            *lpName = (CHAR)(*lpName + (Hex(*lpHex++)));
        }

        *lpName = '\0';
    }

#ifdef UNICODE

    if(S_OK == hr)
    {
        // get the needed buffer size

        nStringLen = MultiByteToWideChar(
                   CP_ACP,
                   0,
                   szDBCSName,
                   -1,
                   NULL,
                   0) ;

        if(0 == nStringLen)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("MultiByteToWideChar"));
        }

    }

    if(S_OK == hr)
    {
        ptszDest = new WCHAR[nStringLen];

        if(NULL == ptszDest)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new WCHAR"));
        }
    }
    
    if(S_OK == hr)
    {
        if (nStringLen != MultiByteToWideChar(
                       CP_ACP,
                       0,
                       szDBCSName,
                       -1,
                       ptszDest,
                       nStringLen))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("MultiByteToWideChar"));
        }
    }

    if(S_OK == hr)
    {
        *pptszName = ptszDest;
    }
#else
    
    if(S_OK == hr)
    {
        nStringLen = strlen(szDBCSName);

        ptszDest = new CHAR[nStringLen+1];

        if(NULL == ptszDest)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new WCHAR"));
        }
    }

    if(S_OK == hr)
    {
        strcpy(ptszDest, szDBCSName);
    }

#endif //UNICODE

    if(S_OK == hr)
    {
        *pptszName = ptszDest;
    }
    
    DH_TRACE((DH_LVL_TRACE2, TEXT("GenerateRandomFileName: %s"), 
    (S_OK == hr)?*pptszName:TEXT("none")));

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::GetFileNameFromFile
//
//  Synopsis:   Get a specific name from data file
//
//  Parameters: [nIndex] -- name to be retrieved
//              [lpDest] -- buffer to receive the string; must be big large
//                          enough
//
//  History:    03-Nov-97       BogdanT     Created
//
//
//---------------------------------------------------------------------------
HRESULT CDBCSStringGen::GetFileNameFromFile(UINT nIndex, LPSTR lpDest)
{
    HRESULT hr      = S_OK;
    UINT nCount     = 0;
    CHAR szBuf[MAX_LINE_SIZE];

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("CDBCSStringGen::GetFileNameFromFile"));

    DH_ASSERT(NULL != m_hDataFile);
    fseek(m_hDataFile, SEEK_SET, 0);

    DH_ASSERT(nIndex<m_cFileNames);

    do
    {
        if(!fgets(szBuf, MAX_LINE_SIZE-1, m_hDataFile))
        {
            hr = E_FAIL;
            DH_HRCHECK(hr, TEXT("fgets"));
            break;
        }

        if(isxdigit(szBuf[0]))  // ignore comments and other invalid lines
        {                       // the strings look like this: fc4b,8140,fc4b,2e,54
            nCount++;
        }
    }while(nCount<=nIndex);

    fseek(m_hDataFile, SEEK_SET, 0);

    if(S_OK == hr)
    {
        strcpy(lpDest, szBuf);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\chancedf.cxx ===
//-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       chancedf.cxx
//
//  Contents:   Implementation for ChanceDF object.
//
//  Classes:    ChanceDF
//
//  Functions:  ChanceDF (public)
//              ~ChanceDF (public)
//              CreateFromParams (public)
//              CreateFromSize, multiple (public)
//              CreateFromFile (public)
//              Create (public)
//              GetSeed (public)
//              Generate (protected)
//              GenerateRoot (protected)
//              Init, multiple (public)
//              ParseRange(protected)
//              DeleteChanceDocFileTree (public)
//              GetModes (public)
//              AppendChildNode (protected)
//              AppendSisterNode (protected)
//              DeleteChanceDocFileSubTree (protected)
//              GetDocFileNameFromCmdline (private)
//              GetRandomChanceNode (protected)
//              GetDepthOfNode (private)
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Added more functions, enhanced.
//              BogdanT 30-Oct-96   Mac porting changes
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration

DH_DECLARE;

#define WSZ_DEF_VAL     OLESTR("none")

//--------------------------------------------------------------------------
//  Member:     ChanceDF::ChanceDF, public
//
//  Synopsis:   Constructor.  Initializes variables but real work is
//              done in ::Create*() methods.  This method cannot fail.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

ChanceDF::ChanceDF() : _pdgi(NULL),
                       _pcnRoot(NULL),
                       _pcdfd(NULL),
                       _ptszName(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF ctor"));
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::~ChanceDF, public
//
//  Synopsis:   Destructor.  Frees memory and releases objects.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

ChanceDF::~ChanceDF()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF dtor"));

    if(NULL != _pcdfd)
    {
        delete _pcdfd;
        _pcdfd = NULL;
    }

    if(NULL != _pdgi)
    {
        delete _pdgi;
        _pdgi = NULL;
    }

    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::Init, public
//
//  Synopsis:   Initializes _pcdfd field in the ChanceDF object with default 
//              values
//
//  Arguments:  
//              
//
//  Returns:    HRESULT
//
//  History:    t-leonr   26-Jul-97   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::Init()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF::Init()"));

    if (NULL == _pcdfd)
    {
        _pcdfd = new CDFD;
        if (NULL == _pcdfd)
        {
            return(E_OUTOFMEMORY);
        }
    }
    _pcdfd->cDepthMin    = 0;
    _pcdfd->cDepthMax    = 2;
    _pcdfd->cStgMin      = 0;
    _pcdfd->cStgMax      = 3;
    _pcdfd->cStmMin      = 0;
    _pcdfd->cStmMax      = 5;
    _pcdfd->cbStmMin     = 0;
    _pcdfd->cbStmMax     = 5000;
    _pcdfd->ulSeed       = 0;
    _pcdfd->dwRootMode   = _pcdfd->dwStgMode = _pcdfd->dwStmMode =
                            STGM_READWRITE  |
                            STGM_DIRECT     |
                            STGM_SHARE_EXCLUSIVE; 
    return(S_OK);
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::Init, public
//
//  Synopsis:   Initializes the _pcdfd field in the ChanceDF object with the
//              values passed in the pcdfd.
//
//  Arguments:  pcdfd
//              
//
//  Returns:    HRESULT
//
//  History:    t-leonr   26-Jul-97   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::Init(CDFD *pcdfd)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF::Init(pcdfd)"));

    if (NULL == _pcdfd)
    {
        _pcdfd = new CDFD;
        if (NULL == _pcdfd)
        {
            return(E_OUTOFMEMORY);
        }
    }
    memcpy(_pcdfd, pcdfd, sizeof(CDFD));
    return (S_OK);
}


//--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromParams, public
//
//  Synopsis:   Creates the DocFile from the command line parameters.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//              t-leonr 27-Jul-97   Add stuff about Init()
//
//  Notes:
//              Precedence of switches in the event of conflicts:
//              1) /dfsize:tiny, huge, etc
//              2) /dftemp:<template file name>
//              3) /dfdepth:min-max /dfstg:min-max /dfstm:min-max
//                 /dfstmlen:min-max
//              4) /dfRootMode:<mode> /dfStgMode:<mode> /dfStmMode:<mode>
//              5) /dfname:name for Root DocFile
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromParams(int argc, char **argv, LPTSTR ptName)
{
    HRESULT hr = E_FAIL;
    int     nErr;
    LPTSTR  ptszCmdSize     =   NULL;
    LPTSTR  ptszCmdDepth    =   NULL;
    LPTSTR  ptszCmdStg      =   NULL;
    LPTSTR  ptszCmdStm      =   NULL;
    LPTSTR  ptszCmdTemp     =   NULL;
    LPTSTR  ptszCmdStmLen   =   NULL;
    LPTSTR  ptszCmdName     =   NULL;
    LPTSTR  ptszCmdRootMode =   NULL;
    LPTSTR  ptszCmdStgMode  =   NULL;
    LPTSTR  ptszCmdStmMode  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::CreateFromParams"));

    if (NULL == _pcdfd)
    {
        hr = Init();
        DH_HRCHECK(hr, TEXT("ChanceDF::Init()"));
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    CBaseCmdlineObj  cmdOpenDF(OLESTR("Distrib"), OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdSize  (OLESTR("dfsize"),  OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdDepth (OLESTR("dfdepth"), OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStg   (OLESTR("dfstg"),   OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStm   (OLESTR("dfstm"),   OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStmLen(OLESTR("dfstmlen"),OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdTemp  (OLESTR("dftemp"),  OLESTR(""), WSZ_DEF_VAL);
    CUlongCmdlineObj cmdSeed  (OLESTR("seed"),    OLESTR(""), _TEXTN("0"));
    CBaseCmdlineObj  cmdName  (OLESTR("dfname"),  OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdRootMode (OLESTR("dfRootMode"), OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStgMode  (OLESTR("dfStgMode"),  OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStmMode  (OLESTR("dfStmMode"),  OLESTR(""), WSZ_DEF_VAL);

    CBaseCmdlineObj  *aAllArgs[] = {
                                       &cmdOpenDF,
                                       &cmdSize,
                                       &cmdDepth,
                                       &cmdStg,
                                       &cmdStm,
                                       &cmdStmLen,
                                       &cmdTemp,
                                       &cmdSeed,
                                       &cmdName,
                                       &cmdRootMode,
                                       &cmdStgMode,
                                       &cmdStmMode
                                   };

    CCmdline cmdline(argc, argv);

    nErr = cmdline.QueryError();
    if (CMDLINE_NO_ERROR != nErr)
    {
        DH_TRACE((DH_LVL_ERROR,_TEXT("CCmdline creation error = %d"),nErr));
        goto CleanUpExit;
    }

    // Parse the actual arguments
    //   ignore any extra parameters; last param==FALSE will
    //   do this
    //
    nErr = cmdline.Parse(aAllArgs,
                         sizeof(aAllArgs)/sizeof(CBaseCmdlineObj *),
                         FALSE);

    if (CMDLINE_NO_ERROR != nErr)
    {
        DH_TRACE((DH_LVL_ERROR,
                  _TEXT("Command line parsing error = %d"),
                  nErr));
        goto CleanUpExit;
    }


    // Initialize the seed value first - we'll always have a value
    // for this
    //
    if (0 != *cmdSeed.GetValue())
    {
        // only set seed from cmdline if it has not been put
        // into the cdfd earlier. (permits repro with new testdriver)
        if (0 == _pcdfd->ulSeed || -1 == _pcdfd->ulSeed)
        {
            _pcdfd->ulSeed = *cmdSeed.GetValue();
        }
    }

    // Next, hunt for arguments we actually got

    // Are we creating our docfile to test?
    _uOpenCreateDF = FL_DISTRIB_NONE;
    if (TRUE == cmdOpenDF.IsFound ())
    {
        LPTSTR ptszCmdOpen;
        //Convert OLECHAR to TCHAR
        hr = OleStringToTString (cmdOpenDF.GetValue (), &ptszCmdOpen);
        DH_HRCHECK (hr, TEXT("OleStringToTString"));
        
        if (S_OK == hr)
        {
            if (NULL == _tcsicmp (ptszCmdOpen, TEXT(SZ_DISTRIB_OPEN)) ||
                    NULL == _tcsicmp (ptszCmdOpen, TEXT(SZ_DISTRIB_OPENNODELETE)))
            {
                _uOpenCreateDF = FL_DISTRIB_OPEN;
            }
            else if (NULL == _tcsicmp (ptszCmdOpen, TEXT(SZ_DISTRIB_CREATE)))
            {
                _uOpenCreateDF = FL_DISTRIB_CREATE;
            }
        }
        delete ptszCmdOpen;
        ptszCmdOpen = 0;
    }

    // Initialize the mode values

    if(0 != olestrcmp(cmdRootMode.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdRootMode.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdRootMode.GetValue(), &ptszCmdRootMode);
        
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
         
            if(S_OK == hr)
            { 
                hr = GetModes(&(_pcdfd->dwRootMode), ptszCmdRootMode);

                DH_HRCHECK(hr, TEXT("GetModes - dwRootMode")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStgMode.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStgMode.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStgMode.GetValue(), &ptszCmdStgMode);
        
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {    
                hr = GetModes(&(_pcdfd->dwStgMode), ptszCmdStgMode);

                DH_HRCHECK(hr, TEXT("GetModes - dwStgMode")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStmMode.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStmMode.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStmMode.GetValue(), &ptszCmdStmMode);
       
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {
                hr = GetModes(&(_pcdfd->dwStmMode), ptszCmdStmMode);

                DH_HRCHECK(hr, TEXT("GetModes - dwStmMode")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    // Initialize the name value

    if(0 != olestrcmp(cmdName.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdName.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdName.GetValue(), &ptszCmdName);
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }
    // if nothing on cmdline, put in what was given to us
    if (NULL != ptName && NULL == ptszCmdName)
    {
        ptszCmdName = new TCHAR[_tcslen (ptName) + 1];
        if (NULL != ptszCmdName)
        {
            _tcscpy (ptszCmdName, ptName);
        }
    }

    // Check if dfsize or dftemp given on command line - the call appropriate
    // functions

    if(0 != olestrcmp(cmdSize.GetValue(), WSZ_DEF_VAL)) 
    {
        if(NULL != *cmdSize.GetValue())
        {
            hr = OleStringToTString(cmdSize.GetValue(), &ptszCmdSize);
       
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            { 
                hr = CreateFromSize(
                            ptszCmdSize, 
                            _pcdfd->ulSeed,
                            _pcdfd->dwRootMode,   // non existing values 
                            _pcdfd->dwStgMode,   // for seed and modes
                            _pcdfd->dwStmMode,
                            ptszCmdName);

                goto CleanUpExit;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }
    else
    if(0 != olestrcmp(cmdTemp.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdTemp.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdTemp.GetValue(), &ptszCmdTemp);

            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {    
                hr = CreateFromFile(ptszCmdTemp, _pcdfd->ulSeed);

                goto CleanUpExit;
            }
        }

        if (FAILED(hr))
        {
           goto CleanUpExit;
        }
    }

    // If a size or template file were not specified, we'll need to
    // hunt for specific values on the command line, using defaults
    // for any we don't get
    //

    if(0 != olestrcmp(cmdDepth.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdDepth.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdDepth.GetValue(), &ptszCmdDepth);
        
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {
                hr = ParseRange(ptszCmdDepth, &(_pcdfd->cDepthMin), &(_pcdfd->cDepthMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdDepth")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStg.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStg.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStg.GetValue(), &ptszCmdStg);
    
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
   
            if(S_OK == hr)
            { 
                hr = ParseRange(ptszCmdStg, &(_pcdfd->cStgMin), &(_pcdfd->cStgMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdStg")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStm.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStm.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStm.GetValue(), &ptszCmdStm);
    
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
   
            if(S_OK == hr)
            { 
                hr = ParseRange(ptszCmdStm, &(_pcdfd->cStmMin), &(_pcdfd->cStmMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdStm")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }
            
    if(0 != olestrcmp(cmdStmLen.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStmLen.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStmLen.GetValue(), &ptszCmdStmLen);
        
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
   
            if(S_OK == hr)
            { 
                hr = ParseRange(ptszCmdStmLen, &(_pcdfd->cbStmMin), &(_pcdfd->cbStmMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdStmLen")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    hr = Create(NULL, ptszCmdName);

    DH_HRCHECK(hr, TEXT("Create")) ;

CleanUpExit:

    // Clean up

    if(NULL != ptszCmdSize)
    {
        delete ptszCmdSize;
        ptszCmdSize =NULL;
    }

    if(NULL != ptszCmdDepth)
    {
        delete ptszCmdDepth;
        ptszCmdDepth =NULL;
    }

    if(NULL != ptszCmdStg)
    {
        delete ptszCmdStg;
        ptszCmdStg =NULL;
    }

    if(NULL != ptszCmdStm)
    {
        delete ptszCmdStm;
        ptszCmdStm =NULL;
    }
   
    if(NULL != ptszCmdStmLen)
    {
        delete ptszCmdStmLen;
        ptszCmdStmLen =NULL;
    }
   
    if(NULL != ptszCmdName)
    {
        delete ptszCmdName;
        ptszCmdName =NULL;
    }
   
    if(NULL != ptszCmdRootMode)
    {
        delete ptszCmdRootMode;
        ptszCmdRootMode =NULL;
    }
   
    if(NULL != ptszCmdStgMode)
    {
        delete ptszCmdStgMode;
        ptszCmdStgMode =NULL;
    }
   
    if(NULL != ptszCmdStmMode)
    {
        delete ptszCmdStmMode;
        ptszCmdStmMode =NULL;
    }
   
    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromSize, public
//
//  Synopsis:   Creates the DocFile from size option
//
//  Arguments:  [tszSize] - Size of DocFile.  Must be given. 
//              [ulSeed] - Seed value.
//              [dwRootMode] - Mode for Root Storage. 
//              [dwStgMode] - Mode for IStorage(s).  
//              [dwStmMode] - Mode for IStream(s).  
//              [ptszDocName] - Name of DocFile.  
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 2-July-96   Enhanced
//
//  Notes:      If the value for dwRootMode/dwStgMode/dwStmMode are not given
//              i.e. zero, then default values for the modes would be used.
//              If ptszDocName is NULL, then a random name is chosen for Doc
//              File in VirtualDF creation.
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromSize(
    LPCTSTR     tszSize, 
    ULONG       ulSeed,
    DWORD       dwRootMode,
    DWORD       dwStgMode,
    DWORD       dwStmMode,
    LPTSTR      ptszDocName)
{
    DFSIZE dfs = DF_ERROR;

    DH_FUNCENTRY(NULL,
                 DH_LVL_DFLIB,
                 _TEXT("ChanceDF::CreateFromSize - string"));

    DH_ASSERT(NULL != tszSize);

    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_TINY))
    {
        dfs = DF_TINY;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_SMALL))
    {
        dfs = DF_SMALL;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_MEDIUM))
    {
        dfs = DF_MEDIUM;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_LARGE))
    {
        dfs = DF_LARGE;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_HUGE))
    {
        dfs = DF_HUGE;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_DIF))
    {
        dfs = DF_DIF;
    }

    if (DF_ERROR == dfs)
    {
        return(E_FAIL);
    }

    return(CreateFromSize(
            dfs, 
            ulSeed, 
            dwRootMode, 
            dwStgMode, 
            dwStmMode, 
            ptszDocName));
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromSize, public
//
//  Synopsis:   Creates DocFile from size option.
//
//  Arguments:  [dfs]  - DocFile size. 
//              [ulSeed] - Seed value.
//              [dwRootMode] - Mode for Root Storage. 
//              [dwStgMode] - Mode for IStorage(s).  
//              [dwStmMode] - Mode for IStream(s).  
//              [ptszDocName] - Name of DocFile.  
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//              t-leonr 27-Jul-97   Add stuff about Init(), use _pcdfd
//
//  Notes:      If the value for dwRootMode/dwStgMode/dwStmMode are not given
//              i.e. zero, then default values for the modes would be used.
//              If ptszDocName is NULL, then a random name is chosen for Doc
//              File in VirtualDF creation.
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromSize(
    DFSIZE      dfs, 
    ULONG       ulSeed,
    DWORD       dwRootMode,
    DWORD       dwStgMode,
    DWORD       dwStmMode,
    LPTSTR      ptszDocName)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr,
                 DH_LVL_DFLIB,
                 _TEXT("ChanceDF::CreateFromSize - dfs"));

    if (NULL == _pcdfd)
    {
        hr = Init();
        DH_HRCHECK(hr, TEXT("ChanceDF::Init()"));
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    _pcdfd->ulSeed = ulSeed;

    if(0 == dwRootMode)
    {
        _pcdfd->dwRootMode = STGM_READWRITE  |
                             STGM_DIRECT     |
                             STGM_SHARE_EXCLUSIVE;
    }
    else
    {
        _pcdfd->dwRootMode = dwRootMode;
    }

    if(0 == dwStgMode)
    {
        _pcdfd->dwStgMode = STGM_READWRITE  |
                            STGM_DIRECT     |
                            STGM_SHARE_EXCLUSIVE;
    }
    else
    {
        _pcdfd->dwStgMode = dwStgMode;
    }

    if(0 == dwStmMode)
    {
        _pcdfd->dwStmMode = STGM_READWRITE  |
                            STGM_DIRECT     |
                            STGM_SHARE_EXCLUSIVE;
    }
    else
    {
        _pcdfd->dwStmMode = dwStmMode;
    }

    switch (dfs)
    {
    case DF_TINY:
        _pcdfd->cDepthMin = 0;
        _pcdfd->cDepthMax = 0;
        _pcdfd->cStgMin   = 0;
        _pcdfd->cStgMax   = 0;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 3;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 100;
        break;

    case DF_SMALL:
        _pcdfd->cDepthMin = 0;
        _pcdfd->cDepthMax = 1;
        _pcdfd->cStgMin   = 0;
        _pcdfd->cStgMax   = 1;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 5;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 4000;
        break;

    case DF_MEDIUM:
        _pcdfd->cDepthMin = 1;
        _pcdfd->cDepthMax = 3;
        _pcdfd->cStgMin   = 1;
        _pcdfd->cStgMax   = 4;
        _pcdfd->cStmMin   = 1;
        _pcdfd->cStmMax   = 6;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 10240;
        break;

    case DF_LARGE:
        _pcdfd->cDepthMin = 2;
        _pcdfd->cDepthMax = 5;
        _pcdfd->cStgMin   = 2;
        _pcdfd->cStgMax   = 10;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 8;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 20480;
        break;

    case DF_HUGE:
        _pcdfd->cDepthMin = 5;
        _pcdfd->cDepthMax = 10;
        _pcdfd->cStgMin   = 5;
        _pcdfd->cStgMax   = 30;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 10;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 40000;
        break;

    case DF_DIF:
        _pcdfd->cDepthMin = 5;
        _pcdfd->cDepthMax = 10;
        _pcdfd->cStgMin   = 7;
        _pcdfd->cStgMax   = 10;
        _pcdfd->cStmMin   = 10;
        _pcdfd->cStmMax   = 15;
        _pcdfd->cbStmMin  = 100000;
        _pcdfd->cbStmMax  = 150000;
        break;

    case DF_ERROR:  // Fall through to error condition
    default:
        hr = E_FAIL;
        break;
    }

    if (SUCCEEDED(hr))
    {
        hr = Create(NULL, ptszDocName);

        DH_HRCHECK(hr, TEXT("Create")) ;
    }

    return(hr);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromFile, public
//
//  Synopsis:   Creates DocFile through a given ini file.
//
//  Arguments:  [tszIni]
//              [ulSeed]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromFile(
    LPCTSTR     /* UNREF tszIni */,
    ULONG       /* UNREF ulSeed */)
{
    DH_FUNCENTRY(NULL,
                 DH_LVL_DFLIB,
                 _TEXT("ChanceDF::CreateFromFile - NYI!"));


    DH_ASSERT(!_TEXT("::CreateFromFile NYI!"));

    return(E_FAIL);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::Create, public
//
//  Synopsis:   Creates the ChanceDocFile tree.
//
//  Arguments:  [pcdfd] - pointer to CDFD structure.
//              [ptszDocName] - Name for DocFile.  May be NULL.
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              t-leonr 27-Jul-97   Add stuff about Init()
//
//  Notes:  Destructor will clean up a partially-created object so we
//          don't have to do a bunch of cleanup as we go
//
//          If ptszDocName is NULL, then a random name is chosen for Doc
//          File in VirtualDF creation.
//---------------------------------------------------------------------------

HRESULT ChanceDF::Create(CDFD *pcdfd, LPTSTR ptszDocName)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::Create"));

    if (NULL != pcdfd)
    {
        hr = Init(pcdfd);
        DH_HRCHECK(hr, TEXT("ChanceDF::Init(pcdfd)"));
    }
    else if (NULL == _pcdfd)
    {
        hr = Init();
        DH_HRCHECK(hr, TEXT("ChanceDF::Init()"));
    }
    if (FAILED(hr))
    {
        return hr;
    }
    
    // Create a DataGen object that will allow us to fill the count
    // parameters of all the ChanceDF components
    //
    _pdgi = new DG_INTEGER(_pcdfd->ulSeed);
    if (NULL == _pdgi)
    {
        return(E_OUTOFMEMORY);
    }


    // Store the actual seed value we used to create this tree - we'll
    // need it to initialize other DG objects later
    //
    _pdgi->GetSeed(&_pcdfd->ulSeed);

    // Report the Seed value so this structure can be recreated
    DH_LOG((LOG_INFO, _TEXT("ChanceDF::Create - Seed=%lu"), _pcdfd->ulSeed));


    // Finally, we must generate the ChanceDF tree
    hr = Generate();

    DH_HRCHECK(hr, TEXT("Generate")) ;

    //Store the name of docfile, if provided by user.
    if((S_OK == hr) && (NULL != ptszDocName))
    {
       hr = GetDocFileNameFromCmdline(ptszDocName);

       DH_HRCHECK(hr, TEXT("GetDocFileNameFromCmdline")) ;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::ParseRange, public
//
//  Synopsis:   Parses the range given from command line for different params.
//
//  Arguments:  [tszSwitch]
//              [pulMin]
//              [pulMax]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//
//  Notes:      tszSwitch is of the format '/switch:min-max
//---------------------------------------------------------------------------

HRESULT ChanceDF::ParseRange(LPCTSTR tszSwitch, ULONG *pulMin, ULONG *pulMax)
{
    HRESULT     hr      = E_FAIL;
    LPCTSTR     ptszMin = tszSwitch;
    LPCTSTR     ptszMax = tszSwitch;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::ParseRange"));
    DH_ASSERT(NULL != tszSwitch);
    DH_ASSERT(NULL != pulMin);
    DH_ASSERT(NULL != pulMax);

    // Advance the maximum pointer past the dash delimeter after
    // the minimum value
    //
    ptszMax = ptszMin;
    while ((*ptszMax != L'\0') && (*ptszMax++ != L'-'))
    {
        ;
    }

    // If neither of our pointers is pointing at the null
    // terminator, we can safely get the values
    //
    if ((L'\0' != *ptszMin) && (L'\0' != *ptszMax))
    {
        *pulMin = _ttol(ptszMin);
        *pulMax = _ttol(ptszMax);

        if (*pulMin <= *pulMax)
        {
            hr = S_OK;
        }
    }

    return (hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::Generate, protected
//
//  Synopsis:   Generates the ChanceDocFile tree consisting of ChanceNodes.
//
//  Arguments:  void
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//  Notes:
//              Check the creation parameters
//              Generate the first child node at each level
//              Choose children nodes randomly to create additional siblings,
//              or children, if necessary. In growing the chance docfile tree, 
//              take care not to make sister of root node and do not increase 
//              depth of the tree by making child of nodes at max depth.
//
//              Called privately by public creation methods
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::Generate()
{
    HRESULT      hr            = E_FAIL;
    ULONG        cDepth        = 0;
    ULONG        cRemStg       = 0;
    USHORT       usErr         = 0;
    ChanceNode **apcnFirstBorn = NULL;
    ChanceNode  *pcnRemStg     = NULL;
    ULONG        ulLoop;
    ChanceNode  *pcnOldNode    = NULL;
    UINT         cTypeNode     = 0;
    ULONG        cNumOfNodes   = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::Generate"));

    // Sanity check parameters
    //   minimums for each category must be <= maximums
    //   must have at least as many storages as the minimum depth
    //   must have at least as many storages as the maximum depth
    //
    if ((_pcdfd->cDepthMin > _pcdfd->cDepthMax) ||
        (_pcdfd->cStgMin   > _pcdfd->cStgMax)   ||
        (_pcdfd->cStmMin   > _pcdfd->cStmMax)   ||
        (_pcdfd->cbStmMin  > _pcdfd->cbStmMax)  ||
        (_pcdfd->cDepthMin > _pcdfd->cStgMin)   ||
        (_pcdfd->cDepthMax > _pcdfd->cStgMax))
    {
        goto ErrExit;
    }

    // Determine the exact depth of the docfile
    //

    usErr = _pdgi->Generate(&cDepth, _pcdfd->cDepthMin, _pcdfd->cDepthMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }

    // Adjust minimum and maximum number of storages to create down
    // by the number that would be created by cDepth.
    //

    _pcdfd->cStgMin = max(0, (LONG)(_pcdfd->cStgMin-cDepth));
    _pcdfd->cStgMax = max(0, (LONG)(_pcdfd->cStgMax-cDepth));

    // Calculate the number of extra storages to create
    //

    usErr = _pdgi->Generate(&cRemStg, _pcdfd->cStgMin, _pcdfd->cStgMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }

    // Check if cDepth is zero, but cRemStg is >0, then make cDepth atleast 1,
    // becoz' we wouldn't have siblings of root.

    cDepth = ((cDepth == 0 && cRemStg > 0) ? 1 : cDepth);

    // Allocate a table of pointers to the first children at each
    // level
    //
    apcnFirstBorn = new ChanceNode*[cDepth+1];
    if (NULL == apcnFirstBorn)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }


    // Create root node - if this succeeds, we point our root
    // to it and if any subsequent errors occur while building the
    // rest of the tree the destructor will clean it up
    //
    hr = GenerateRoot();

    DH_HRCHECK(hr, TEXT("GenerateRoot")) ;

    if (FAILED(hr))
    {
        goto ErrExit;
    }
    apcnFirstBorn[0] = _pcnRoot;


    // Create levels of children nodes
    //
    hr = S_OK;
    ulLoop = 1;
    while ((ulLoop<=cDepth) && SUCCEEDED(hr))
    {
        hr = AppendChildNode(&apcnFirstBorn[ulLoop], apcnFirstBorn[ulLoop-1]);

        DH_HRCHECK(hr, TEXT("AppendChildNode")) ;

        ulLoop++;
    }

    if (FAILED(hr))
    {
        goto ErrExit;
    }

    // Now, fill in any remaining storage nodes that we need to
    //

    cNumOfNodes = ulLoop;
    ulLoop = 0;

    while ((ulLoop<cRemStg) && SUCCEEDED(hr))
    {
        usErr = _pdgi->Generate(&cTypeNode, SISTERNODE, CHILDNODE);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        if(S_OK == hr)
        {
            hr = GetRandomChanceNode(cNumOfNodes, &pcnOldNode);

            DH_HRCHECK(hr, TEXT("FindRandomChanceNode")) ;
        }

        if (SUCCEEDED(hr))
        {
            // In growing the chance docfile tree, take care not to make
            // sister of root node and do not increase max depth of the tree
            // by making child of nodes at max depth.

            if((SISTERNODE == cTypeNode) && (_pcnRoot != pcnOldNode)) 
            {
                hr = AppendSisterNode(&pcnRemStg, pcnOldNode);

                DH_HRCHECK(hr, TEXT("AppendSisterNode")) ;
            }
            else 
            {
                // Both conditons CHILDNODE == cTypeNode and
                // ((SISTERNODE == cTypeNode) && (_pcnRoot == pcnOldNode))
                // handled here
        
                if(NULL == pcnOldNode->_pcnChild) 
                {
                    if(GetDepthOfNode(pcnOldNode) < cDepth)
                    {
                        hr = AppendChildNode(&pcnRemStg, pcnOldNode);
                    
                        DH_HRCHECK(hr, TEXT("AppendChildNode")) ;
                    }
                    else
                    {
                        hr = AppendSisterNode(&pcnRemStg, pcnOldNode);

                        DH_HRCHECK(hr, TEXT("AppendSisterNode")) ;
                    }
                }
                else
                {
                    hr = AppendSisterNode(&pcnRemStg,pcnOldNode->_pcnChild);

                    DH_HRCHECK(hr, TEXT("AppendSisterNode")) ;
                }
            }
        }

        ulLoop++;   
        cNumOfNodes++;
    }


ErrExit:
    // All nodes are saved in the tree itself pointed to by _pcnRoot, and
    // we can safely delete this temporary scaffolding
    //
    delete []apcnFirstBorn;

    return(hr);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::GenerateRoot, protected
//
//  Synopsis:   Generates the root of ChanceDocFile tree.
//
//  Arguments:  void
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//---------------------------------------------------------------------------

HRESULT ChanceDF::GenerateRoot()
{
    USHORT usErr;
    ULONG  cStreams;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GenerateRoot"));

    // Generate the number of streams the root will have
    usErr = _pdgi->Generate(&cStreams, _pcdfd->cStmMin, _pcdfd->cStmMax);
    if (DG_RC_SUCCESS != usErr)
    {
        return(E_FAIL);
    }

    _pcnRoot = new ChanceNode(0, cStreams, _pcdfd->cbStmMin, _pcdfd->cbStmMax);
    if (NULL == _pcnRoot)
    {
        return(E_OUTOFMEMORY);
    }

    return(S_OK);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::AppendChildNode, protected
//
//  Synopsis:   Appends the Child node to parent.
//
//  Arguments:  [ppcnNew]
//              [pcnParent]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//
//  Notes:      Attach new node as a child of the parent node at the end of the
//              end of parents child chain.  If the parent is NULL, do nothing
//              with this node.
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::AppendChildNode(ChanceNode **ppcnNew, ChanceNode *pcnParent)
{
    HRESULT hr      =   E_FAIL;
    ULONG   cStreams=   0;
    USHORT  usErr   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("AppendChildNode"));

    DH_ASSERT(NULL != pcnParent)
    DH_ASSERT(NULL != ppcnNew);

    *ppcnNew = NULL;

    // Determine number of streams to create
    usErr = _pdgi->Generate(&cStreams, _pcdfd->cStmMin, _pcdfd->cStmMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }


    // Allocate and initialize the new node
    *ppcnNew = new ChanceNode(0, cStreams, _pcdfd->cbStmMin, _pcdfd->cbStmMax);
    if (NULL == *ppcnNew)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }


    // Append the new node to the list of sisters in the parent
    //
    hr = pcnParent->AppendChildStorage(*ppcnNew);

    DH_HRCHECK(hr, TEXT("AppendChildStorage")) ;

ErrExit:
    if (FAILED(hr))
    {
        delete *ppcnNew;
        *ppcnNew = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::AppendSisterNode, protected
//
//  Synopsis:   Appends the new node as sister of ChanceNode.
//
//  Arguments:  [ppcnNew]
//              [pcnSister]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//---------------------------------------------------------------------------

HRESULT ChanceDF::AppendSisterNode(
        ChanceNode **ppcnNew,
        ChanceNode  *pcnSister)
{
    HRESULT hr      =   E_FAIL;
    ULONG   cStreams=   0;
    USHORT  usErr   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("AppendSisterNode"));

    DH_ASSERT(NULL != pcnSister)
    DH_ASSERT(NULL != ppcnNew);

    *ppcnNew = NULL;

    // Determine number of streams to create
    usErr = _pdgi->Generate(&cStreams, _pcdfd->cStmMin, _pcdfd->cStmMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }


    // Allocate and initialize the new node
    *ppcnNew = new ChanceNode(0, cStreams, _pcdfd->cbStmMin, _pcdfd->cbStmMax);
    if (NULL == *ppcnNew)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }


    // Append the new node to the list of sisters in the parent
    //
    hr = pcnSister->AppendSisterStorage(*ppcnNew);

    DH_HRCHECK(hr, TEXT("AppendSisterStorage")) ;

ErrExit:
    if (FAILED(hr))
    {
        delete *ppcnNew;
        *ppcnNew = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::GetSeed, public
//
//  Synopsis:   Returns the seed value
//
//  Arguments:  void
//
//  Returns:    ULONG
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

ULONG ChanceDF::GetSeed()
{
    ULONG ulSeed = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GetSeed"));

    if (NULL != _pdgi)
    {
        _pdgi->GetSeed(&ulSeed);
    }

    return(ulSeed);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::DeleteChanceDocFileTree, public
//
//  Synopsis:   Deletes the ChanceDocFile tree
//
//  Arguments:  [pcnTrav] - Pointer to ChanceNode
//
//  Returns:    HRESULT
//
//  History:    Narindk 24-Apr-96   Created
//
//  Notes:      First step is to check if the whole tree needs to be deleted or
//              just a part of it.  In case only a part of tree is to be
//              deleted, isolate the node from the remaining tree by readjusting
//              the pointers in the remaining tree.  Then call the function
//              DeleteChanceDocFileSubTree to delete the subtree.  In case,
//              the complete tree needs to be deleted, we call the function
//              DeleteChanceDocFileSubTree directly to delete the complete
//              tree.
//---------------------------------------------------------------------------

HRESULT ChanceDF::DeleteChanceDocFileTree(ChanceNode *pcnTrav)
{
    HRESULT hr              =   S_OK;
    ChanceNode *pTempNode   =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("DeleteChanceDocFileTree"));

    DH_VDATEPTRIN(pcnTrav, ChanceNode);
    DH_ASSERT(NULL != pcnTrav);

    if(S_OK == hr)
    {
        // This basically readjusts the tree, in case some other node except
        // for root of ChanceDocFile tree is passed, so only a part of tree is
        // getting deleted.

        if(NULL != pcnTrav->_pcnParent)
        {
           // Find its previous node whose pointers would need readjustment.

           pTempNode = pcnTrav->_pcnParent->_pcnChild;

           while ((pcnTrav != pcnTrav->_pcnParent->_pcnChild) &&
                  (pcnTrav != pTempNode->_pcnSister))
           {
                pTempNode = pTempNode->_pcnSister;
                DH_ASSERT(NULL != pTempNode);
           }

           // Readjust the child pointer or sister pointer as the case may be.

           pcnTrav->_pcnParent->_pcnChild = (pcnTrav == pTempNode) ?
                pcnTrav->_pcnSister : pcnTrav->_pcnParent->_pcnChild;
           pTempNode->_pcnSister = pcnTrav->_pcnSister;
        }
    }

    if(S_OK == hr)
    {
        // Call the function to delete the tree now.

        hr = DeleteChanceDocFileSubTree(&pcnTrav);

        DH_HRCHECK(hr, TEXT("DeleteChanceDocFileSubTree")) ;
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::DeleteChanceDocFileSubTree, protected
//
//  Synopsis:   Does the real work of deletion of ChanceNodes in the tree.
//
//  Arguments:  [ppcnTrav] - Pointer to pointer to ChanceNode
//
//  Returns:    HRESULT
//
//  History:    Narindk 24-Apr-96   Created
//
//  Notes:      This function is called only through DeleteChanceDocFileTree.
//
//              Assign the passed in ChanceNode to a variable pTempRoot.
//              NULL the pTempRoot's parent.
//              Loop till the pTempRoot is not NULL to delete tree ieratively.
//                  - Assign pTempRoot to a temp variable pTempNode.
//                  - Traverse the tree to make pTempNode point to last child
//                    (_pcnChild).
//                  - Assign pTempNode's _pcnParent to pTempRoot
//                  - Assign the pTempRoot's _pcnChild pointer to point to the
//                    sister of pTempNode's _pcnSister rather than to itself,
//                    therby isolating itself.
//                  - Decrement the _cStorages of pTempRoot (used to verify).
//                  - Assign pTempNode's _pcnSister to NULL.
//                  - Assert to ensure the pTempNode's _cStorages is zero
//                    before deleting it.
//                  - Delete pTempNode.
//                  - Go back to top of loop and repeat till all nodes are
//                    deleted.
//---------------------------------------------------------------------------

HRESULT ChanceDF::DeleteChanceDocFileSubTree(ChanceNode **ppcnTrav)
{
    HRESULT     hr          =   S_OK;
    ChanceNode *pTempRoot   =   NULL;
    ChanceNode *pTempNode   =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("DeleteChanceDocFileSubTree"));

    DH_VDATEPTRIN(ppcnTrav, PCHANCENODE);
    DH_ASSERT(NULL != *ppcnTrav);

    if(S_OK == hr)
    {
        pTempRoot = *ppcnTrav;

        pTempRoot->_pcnParent = NULL;

        // Code to delete the tree iteratively

        while(NULL != pTempRoot)
        {
            pTempNode = pTempRoot;
            while(NULL != pTempNode->_pcnChild)
            {
                pTempNode = pTempNode->_pcnChild;
            }

            pTempRoot = pTempNode->_pcnParent;
            if(pTempRoot != NULL)
            {
                pTempRoot->_pcnChild = pTempNode->_pcnSister;

                // Decrease the storage count.  This would be used to verify
                // before deleting the ChanceNode.

                pTempRoot->_cStorages--;
            }

            pTempNode->_pcnSister = NULL;

            // Verify that number of children of this node are zero.  Assert if
            // not.

            DH_ASSERT(0 == pTempNode->_cStorages);

            // Delete the node

            delete pTempNode;
            pTempNode = NULL;
        }
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetModes, public
//
//  Synopsis:   Gets the creation modes for Root Storage, child storages,
//              streams if provided on command line parameters.
//
//  Arguments:  [pDFMode]
//              [ptcsModeFlags]
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-May-96   Created
//---------------------------------------------------------------------------

HRESULT ChanceDF::GetModes(
    DWORD                *pDFMode,
    LPCTSTR              ptcsModeFlags)
{
    HRESULT     hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetModes"));

    DH_VDATESTRINGPTR(ptcsModeFlags);
    DH_VDATEPTROUT(pDFMode, DWORD);

    DH_ASSERT(NULL != pDFMode);

    if(S_OK == hr)
    {
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADSHEX))
        {
            *pDFMode = STGM_READ          |
                       STGM_DIRECT        |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRWRITESHEX))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_DIRECT        |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADSHDENYW))
        {
            *pDFMode = STGM_READ          |
                       STGM_DIRECT        |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADWRITESHEX))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_DIRECT        |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADWRITESHDENYN))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_DIRECT        |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHEX))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHDENYW))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHDENYN))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHDENYR))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_READ;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHDENYN))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHDENYR))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_READ;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHDENYW))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHEX))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHDENYN))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHDENYR))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_READ;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHDENYW))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHEX))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        {
            hr = E_INVALIDARG ;

            DH_ASSERT(!TEXT("ChanceDF::GetModes: Invalid Mode")) ;
        }
    }

    return hr;

}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetDocFileNameFromCmdline, private
//
//  Synopsis:   Gets the user provided name for docfile to be created.
//
//  Arguments:  [tszName]
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-May-96   Created
//---------------------------------------------------------------------------

HRESULT ChanceDF::GetDocFileNameFromCmdline(LPCTSTR tszName)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::GetDocFileName"));

    DH_VDATESTRINGPTR(tszName);

    _ptszName = new TCHAR[_tcslen(tszName)+1];

    if (_ptszName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        _tcscpy(_ptszName, tszName);
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetRandomChanceNode, protected
//
//  Synopsis:   Gets a random ChanceNode from the ChanceDocFile tree to which
//              a new ChanceNode would be added as Child or Sister during
//              generation of ChanceDF tree. 
//
//  Arguments:  [cNumOfNodes] :  Total number of ChanceNodes in ChanceDF tree 
//              [ppcn] : Out parameter to return random ChanceNode found.
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-July-96   Created
//
//  Notes:      -Find a random number between 1 and total number of nodes in
//               the tree cNumOfNodes
//              -Initialize counter to 1.
//              -Initialze temp variable pcnTrav to _pcnRoot.
//              -In a infinite for loop-
//                  -while pcnTrav's _pcnChild is not NULL and counter is less 
//                   than cRandomNode, loop and update pcnTrav and counter.
//                  -If cRandomNode is equal to counter, then break out of
//                   for loop.
//                  -while pcnTrav's _pcnSister is NULL, loop and keep assign
//                   ing pcnTrav's _pcnParent to pcnTrav.
//                  -When pcnTrav's _pcnSister is not NULL, assign it to 
//                   pcnTrav, increment counter and go back to top of loop.
//
//              Pl. note that if cNumNodes is incorrectly given as more than
//              actual number of nodes in tree, then this function will throw
//              asserts.
//---------------------------------------------------------------------------

HRESULT ChanceDF::GetRandomChanceNode(ULONG cNumOfNodes, ChanceNode **ppcn)
{
    HRESULT     hr          = S_OK;
    ChanceNode  *pcnTrav    = NULL;
    ULONG       cRandomNode = 0;
    ULONG       counter     = 1;
    USHORT      usErr       = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::GetRandomChanceNode"));

    DH_VDATEPTROUT(ppcn, PCHANCENODE);

    DH_ASSERT(NULL != ppcn);
    DH_ASSERT(NULL != _pcnRoot);
    DH_ASSERT(NULL != _pdgi);
    DH_ASSERT(0 != cNumOfNodes);

    if(S_OK == hr)
    {
        // Initialize out parameter
        *ppcn = NULL;

        usErr = _pdgi->Generate(&cRandomNode, 1, cNumOfNodes);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        pcnTrav = _pcnRoot;

        for(;;)
        {
            DH_ASSERT((NULL != pcnTrav) && (counter <= cRandomNode));
            while((pcnTrav->_pcnChild != NULL) && (counter < cRandomNode))
            {
                pcnTrav = pcnTrav->_pcnChild;
                counter++;
            }

            if(cRandomNode == counter)
            {
                break;
            }

            while(NULL == pcnTrav->_pcnSister)
            {
                pcnTrav = pcnTrav->_pcnParent;
                DH_ASSERT(NULL != pcnTrav);
            }

            DH_ASSERT(NULL != pcnTrav->_pcnSister);
            pcnTrav = pcnTrav->_pcnSister;
            counter++;
        }
    }

    if(S_OK == hr)
    {
        *ppcn = pcnTrav;
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetDepthOfNode, private
//
//  Synopsis:   Gets the depth of a ChanceNode in a ChanceDF tree
//
//  Arguments:  [pcn] - ChanceNode whose depth needs to be determined.
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-July-96   Created
//
//  Notes:      -Assigned passed in ChanceNode to temp variable pcnTrav.
//              -Initialize cNodeDepth to zero.
//              -Loop till pcnTrav's _pcnParent is not NULL and keep on 
//               updating pcnTrav and cNodeDepth. 
//              -Depth returned is 0 to n-1 for 1 to nth level nodes.
//---------------------------------------------------------------------------

ULONG ChanceDF::GetDepthOfNode(ChanceNode *pcn)
{
    ChanceNode  *pcnTrav    = NULL;
    ULONG       cNodeDepth  = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF::GetDepthOfNode"));

    DH_ASSERT(NULL != pcn);

    pcnTrav = pcn; 
    while(NULL != pcnTrav->_pcnParent)
    {
        cNodeDepth++;
        pcnTrav = pcnTrav->_pcnParent;
    }

    return cNodeDepth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\createdf.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       init.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  main 
//
//  History:    26-Feb-1997     SCousens    Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
DH_DECLARE;


// Private function
HRESULT MakeVirtualDF (
    IN  ChanceDF         *pChanceDF,
    OUT VirtualDF       **ppVirtualDF);

//----------------------------------------------------------------------------
//
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   ppVirtualDF     - bucket for pVirtualDF  
//              pcdfd           - CDFD for chancedf
//              pCmdLine        - CommandLine (default)  
//              pFileName       - name of docfile (default)
//
//              ulSeed          - seed (to get name)
//
//    SYNOPSIS: Create a test docfile with semantics defined in 
//              given CDFD. 
//              Look on CmdLine (either given or result of 
//              GetCommandLine() call) to override values.
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    
//
//    HISTORY:  19-Mar-1997     SCousens     Created.
//
//----------------------------------------------------------------------------

HRESULT CreateTestDocfile (
        OUT VirtualDF   **ppvdf, 
        IN  CDFD         *pcdfd, 
        IN  LPTSTR        pCmdLine,
        IN  LPTSTR        pFileName)
{

    HRESULT          hr           = S_OK;
    ChanceDF        *pChanceDF    = NULL;
    LPTSTR           pDocFileName = NULL;
    LPTSTR           ptCommandLine= NULL;
    int              argc         = 0;
    char **          argv         = NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, TEXT("CreateTestDocfile"));
    DH_VDATEPTRIN  (pcdfd, CDFD);
    DH_VDATEPTROUT (ppvdf, VirtualDF *);

    *ppvdf = NULL;

    // Always create this. 
    // Create the new ChanceDocFile tree that would consist of chance nodes.
    pChanceDF = new ChanceDF();
    if(NULL == pChanceDF)
    {
        hr = E_OUTOFMEMORY;
    }
    DH_HRCHECK_ABORT (hr, TEXT("new ChanceDF"));

    // initialize chancedf with our desired cdfd
    hr = pChanceDF->Init (pcdfd);
    DH_HRCHECK_ABORT (hr, TEXT("pChanceDF->Init"));

    // Create argc/argv from either given cmdline, or GetCommandLine
    ptCommandLine = (NULL == pCmdLine) ? GetCommandLine () : pCmdLine;
    if (NULL != ptCommandLine)
    {
        LPSTR paCommandLine = NULL;
        hr = TStringToAString (ptCommandLine, &paCommandLine);
        DH_HRCHECK_ABORT (hr, TEXT("TStringToAString"));

        hr = CmdlineToArgs (paCommandLine, &argc, &argv);
        DH_HRCHECK_ABORT (hr, TEXT("CmdlineToArgs"));
        delete []paCommandLine;
    }

    // Create ChanceDF, using filename and cmdline override
    hr = pChanceDF->CreateFromParams (argc, argv, pFileName);
    DH_HRCHECK_ABORT (hr, TEXT("pChanceDF->CreateFromParams"));

    //cleanup argc/argv
   if (NULL != argv)
   {
       for (int count=0; count<argc; count++)
       {
           delete []argv[count];
       }
       delete []argv;
   }

    // Make VirtualDF
    hr = MakeVirtualDF (pChanceDF, ppvdf);
    DH_HRCHECK_ABORT (hr, TEXT("MakeVirtualDF"));

ErrReturn:
    // cleanup 
    delete []pDocFileName;
    delete pChanceDF;

    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   ppVirtualDF     - bucket for pVirtualDF  
//              uType           - predefinede type for docfile
//              ulSeed          - seed
//              pCmdLine        - CommandLine (default)  
//              pFileName       - name of docfile (default)
//
//    SYNOPSIS: Create a test docfile with predefined semantics.
//              Create a CDFD and call CreateTestDocfile with
//              created CDFD
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    
//
//    HISTORY:  19-Mar-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CreateTestDocfile (
        OUT VirtualDF   **ppvdf, 
        IN  DWORD         uType, 
        IN  ULONG         ulSeed,
        IN  LPTSTR        pCmdLine,
        IN  LPTSTR        pFileName)
{

    HRESULT          hr           = S_OK;
    CDFD             cdfd;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, TEXT("CreateTestDocfile"));
    DH_VDATEPTROUT (ppvdf, VirtualDF *);

    *ppvdf = NULL;

    // default modes
    cdfd.dwRootMode = cdfd.dwStgMode = cdfd.dwStmMode = 
            STGM_READWRITE  |
            STGM_DIRECT     |
            STGM_SHARE_EXCLUSIVE;

    cdfd.ulSeed = ulSeed;

    //FIXIT: BUGBUG: we need to define all the types of docfiles needed
    switch (uType)
    {
        case DF_TINY:
            cdfd.cDepthMin = 0;
            cdfd.cDepthMax = 0;
            cdfd.cStgMin   = 0;
            cdfd.cStgMax   = 0;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 3;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 100;
            break;

        case DF_SMALL:
            cdfd.cDepthMin = 0;
            cdfd.cDepthMax = 1;
            cdfd.cStgMin   = 0;
            cdfd.cStgMax   = 1;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 5;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 4000;
            break;

        case DF_MEDIUM:
            cdfd.cDepthMin = 1;
            cdfd.cDepthMax = 3;
            cdfd.cStgMin   = 1;
            cdfd.cStgMax   = 4;
            cdfd.cStmMin   = 1;
            cdfd.cStmMax   = 6;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 10240;
            break;

        case DF_LARGE:
            cdfd.cDepthMin = 2;
            cdfd.cDepthMax = 5;
            cdfd.cStgMin   = 2;
            cdfd.cStgMax   = 10;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 8;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 20480;
            break;

        case DF_HUGE:
            cdfd.cDepthMin = 5;
            cdfd.cDepthMax = 10;
            cdfd.cStgMin   = 5;
            cdfd.cStgMax   = 30;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 10;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 40000;
            break;

        case DF_DIF:
            cdfd.cDepthMin = 5;
            cdfd.cDepthMax = 10;
            cdfd.cStgMin   = 7;
            cdfd.cStgMax   = 10;
            cdfd.cStmMin   = 10;
            cdfd.cStmMax   = 15;
            cdfd.cbStmMin  = 100000;
            cdfd.cbStmMax  = 150000;
            break;

        default:
            hr = E_FAIL;
            break;
    }
    DH_HRCHECK_ABORT (hr, TEXT("set CDFD"));

    hr = CreateTestDocfile (ppvdf, 
            &cdfd, 
            pCmdLine,
            pFileName);
    DH_HRCHECK (hr, TEXT("CreateTestDocfile"));

ErrReturn:
    return hr;
}

//----------------------------------------------------------------------------
//    FUNCTION: MakeVirtualDF
//
//    PARAMS:   pChanceDF   - ptr to pChanceDF  
//              ppVirtualDF - bucket for pVirtualDF  
//
//    SYNOPSIS: This function should be called by
//              CreateTestDocfile
//              We need to create a storage file
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//----------------------------------------------------------------------------
HRESULT MakeVirtualDF (
    IN  ChanceDF         *pChanceDF,
    OUT VirtualDF       **ppVirtualDF)
{
    HRESULT          hr           = S_OK;
    HRESULT          hr2          = S_OK;
    VirtualCtrNode  *pvcnRoot     = NULL;

    // This is internal func. Shouldnt have to do this.
    DH_ASSERT (NULL != pChanceDF); 
    DH_ASSERT (NULL != ppVirtualDF); 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("MakeVirtualDF"));
    DH_VDATEPTRIN  (pChanceDF, ChanceDF);
    DH_VDATEPTROUT (ppVirtualDF, VirtualDF *);

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
    *ppVirtualDF = new VirtualDF(); 
    if (NULL == *ppVirtualDF)
    {
        hr = E_OUTOFMEMORY;
    }
    DH_HRCHECK_ABORT (hr, TEXT("new VirtualDF"));

    // Generate inmemory tree and docfile on disk
    hr = (*ppVirtualDF)->GenerateVirtualDF (pChanceDF, &pvcnRoot);
    DH_HRCHECK_ABORT (hr, TEXT("pVirtualDF->GenerateVirtualDF"));

    // Commit all stms and stgs in newly created storage file
    hr = ParseVirtualDFAndCommitAllOpenStgs (pvcnRoot, 
            STGC_DEFAULT, 
            NODE_INC_TOPSTG);
    DH_HRCHECK (hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs"));

ErrReturn:
    // close the file
    hr2 = ParseVirtualDFAndCloseOpenStgsStms (pvcnRoot, NODE_INC_TOPSTG);
    DH_HRCHECK (hr2, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    hr = FirstError (hr, hr2);

    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CleanupTestDocfile 
//
//    PARAMS:   pVirtualDF  - pVirtualDF to be deleted
//              fDeleteFile - Delete file?
//
//    SYNOPSIS: Cleanup all items that were setup in CreateTestDocfile
//               - virtualdf
//               - delete docfile on disk (if there were no errors)
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    Caller must NULLIFY their pVirtualDF pointer passed in
//              as this function deletes it.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CleanupTestDocfile (
    IN  VirtualDF       *pVirtualDF,
    IN  HRESULT          hrDeleteFile)
{                       
    LPTSTR          pFileName   =  NULL;
    HRESULT         hr          =  S_OK;
    VirtualCtrNode *pvcnRoot;

    DH_FUNCENTRY (&hr, DH_LVL_DFLIB, TEXT("CleanupTestDocfile"));
    DH_VDATEPTRIN (pVirtualDF, VirtualDF);

    // Make sure everything in the docfile is closed
    pvcnRoot = pVirtualDF->GetVirtualDFRoot ();
    if (NULL != pvcnRoot)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms (pvcnRoot, NODE_INC_TOPSTG);
        DH_HRCHECK (hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Get file name
    if ((S_OK == hrDeleteFile || ALWAYS == hrDeleteFile) && NULL != pvcnRoot)
    {
        pFileName= new TCHAR[_tcslen (pVirtualDF->GetDocFileName ())+1];
        if (pFileName != NULL)
        {
            _tcscpy (pFileName, pVirtualDF->GetDocFileName ());
        }
    }

    // Delete Virtual docfile tree
    if (NULL != pVirtualDF)
    {
        hr = pVirtualDF->DeleteVirtualDocFileTree (pvcnRoot);
        DH_HRCHECK (hr, TEXT("pVirtualDF->DeleteVirtualFileDocTree"));

        delete pVirtualDF;
        pVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if ((S_OK == hr) && (NULL != pFileName))
    { 
        if (FALSE == DeleteFile(pFileName))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DH_HRCHECK (hr, TEXT("DeleteFile"));
        }
    }

    // Delete the docfile name
    if (NULL != pFileName)
    {
        delete []pFileName;
        pFileName = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\stgwrap.cxx ===
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       stgwrap.cxx
//
//  Contents:   Wrap the StgOpen/Create apis
//              This is to permit nssfile and conversion testing 
//              and to test the new Stg*Ex apis
//              using the same codebase as the docfile tests with
//              minimal changes to that codebase.
//
//  Functions:  StgInitStgFormatWrapper
//              mStgCreateDocfile
//              mStgOpenStorage
//
//  Notes:      -Only do this fancy stuff if we are not doing 
//               vanilla docfile testing (ie _OLE_NSS_ is defd)
//              -Hook StgOpen/Create only if _OLE_NSS_ is defd
//               *and* _HOOK_STGAPI_ is defd also.
//
//  NOTE:       To turn on nss/cnv functionality you must add
//              -D_OLE_NSS_ -D_HOOK_STGAPI_ to you C_DEFINES
//              in daytona.mk
//
//  History:    SCousens  24-Feb-97   Created
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
DH_DECLARE;

/* only do this fancy stuff if we are not doing vanilla docfile testing */

#ifdef _OLE_NSS_


// This is a global variable. We can do this because it controls
// the state for this entire process. No process will be mixing
// nssfile tests with conversion tests or any other combination.
// Doing it this way gives instant access at various times in the
// tests without rewriting anything.
// Setting of this variable will be done by passing a parameter
// on the commandline to start the process, and calling the init
// function below.

TSTTYPE g_uCreateType  = TSTTYPE_DEFAULT;  //DEFAULT, DOCFILE, NSSFILE 
TSTTYPE g_uOpenType    = TSTTYPE_DEFAULT;  //DEFAULT, DOCFILE, NSSFILE 
DWORD   g_fRegistryBits= REG_OPEN_AS | REG_CREATE_AS | REG_CNSS_ENABLE;
ULONG   g_ulSectorSize = DEFAULT_SECTOR_SIZE;
                         // DEFAULT_SECTOR_SIZE, LARGE_SECTOR_SIZE 

// internal functions
BOOL  StgCheckRegistry (void);
BOOL  StgCheckVolumeInformation (void);

//********************************************************************
// Function:  StgInitStgFormatWrapper (multiple)
//
// Synopsis:  Set the following global variables: 
//              g_uCreateType - type of storage to create
//              g_uOpenType   - type of storage to open
// 
//            1. Check the cmdline, set open and create modes 
//                (default, nssfile, docfile)
//            2. Check the registry. 
//                If NSS not set and want it, spew
//            3. Check disk sub storage type.
//                If !NTFS and want it, spew
// Return:     TRUE  if no issues
//             FALSE if nss set and not NTFS disk, 
//                      
//********************************************************************

BOOL  StgInitStgFormatWrapper (int argc, char *argv[])
{
    HRESULT hr   = S_OK;
    BOOL    fRet = TRUE;

    // check cmdline for open and create and sector size switches.
    CBaseCmdlineObj CCreateDF (OLESTR("CreateAs"), 
            OLESTR("Create doc/nss/flat file"), 
            OLESTR("default"));
    CBaseCmdlineObj COpenDF (OLESTR("OpenAs"), 
            OLESTR("Open doc/nss/flat file"), 
            OLESTR("default"));
    CBaseCmdlineObj CSectorSize (OLESTR("SectorSize"), 
            OLESTR("Sector size"), 
            OLESTR("default"));

    CBaseCmdlineObj *CArgList[] =
    {
        &CCreateDF,
        &COpenDF,
        &CSectorSize
    } ;

    CCmdline CCmdlineArgs(argc, argv);

    if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError())
    {
        hr = E_FAIL ;
    }

    if (S_OK == hr)
    {
        if (CMDLINE_NO_ERROR !=
                CCmdlineArgs.Parse(
                CArgList,
                ( sizeof(CArgList) / sizeof(CArgList[0]) ),
                FALSE))
        {
            hr = E_FAIL ;
        }
    }

    if (S_OK == hr)
    {
        // look for Create
        // default as docfile
        if (TRUE == CCreateDF.IsFound ())
        {
            if (NULL == _olestricmp (CCreateDF.GetValue (), OLESTR(SZ_NSSFILE)))
            {
                g_uCreateType = TSTTYPE_NSSFILE;
            }
            else if (NULL == _olestricmp (CCreateDF.GetValue (), OLESTR(SZ_DOCFILE)))
            {
                g_uCreateType = TSTTYPE_DOCFILE;
            }
            else if (NULL == _olestricmp (CCreateDF.GetValue (), OLESTR(SZ_FLATFILE)))
            {
                g_uCreateType = TSTTYPE_FLATFILE;
                g_uOpenType   = TSTTYPE_FLATFILE;
            }
        }

        // look for Open
        // default as docfile
        if (TRUE == COpenDF.IsFound ())
        {
            if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_NSSFILE)))
            {
                g_uOpenType = TSTTYPE_NSSFILE;
            }
            else if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_DOCFILE)))
            {
                g_uOpenType = TSTTYPE_DOCFILE;
            }
            else if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_FLATFILE)))
            {
                g_uCreateType = TSTTYPE_FLATFILE;
                g_uOpenType   = TSTTYPE_FLATFILE;
            }
        }

        // look for Sector size 
        // default as SECTORTYPE_DEDAULT 
        if (TRUE == CSectorSize.IsFound ())
        {
            if (NULL == _olestricmp (CSectorSize.GetValue (), OLESTR(SZ_DEFAULT)))
            {
                g_ulSectorSize = DEFAULT_SECTOR_SIZE;
            }
            else if (NULL == _olestricmp (CSectorSize.GetValue (), OLESTR(SZ_LARGE)))
            {
                g_ulSectorSize = LARGE_SECTOR_SIZE;
            }
        }
    }

    // Now check the registry for spewage reasons
    StgCheckRegistry ();

    // finally, is the disk sub-system compatible with NSS
    if (FALSE == StgCheckVolumeInformation ())
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL  StgInitStgFormatWrapper (TCHAR *pCreateType, TCHAR *pOpenType)
{
    BOOL fRet = TRUE;
    if (0 == _tcscmp(pCreateType, TSZ_NSSFILE))
    {
        g_uCreateType = TSTTYPE_NSSFILE;
    }
    else if (0 == _tcscmp(pCreateType, TSZ_DOCFILE))
    {
        g_uCreateType = TSTTYPE_DOCFILE;
    }
    else if (0 == _tcscmp(pCreateType, TSZ_FLATFILE))
    {
        g_uCreateType = TSTTYPE_FLATFILE;
        g_uOpenType   = TSTTYPE_FLATFILE;
    }

    if (0 == _tcscmp(pOpenType, TSZ_NSSFILE))
    {
        g_uOpenType = TSTTYPE_NSSFILE;
    }
    else if (0 == _tcscmp(pOpenType, TSZ_DOCFILE))
    {
        g_uOpenType = TSTTYPE_DOCFILE;
    }
    else if (0 == _tcscmp(pOpenType, TSZ_FLATFILE))
    {
        g_uCreateType = TSTTYPE_FLATFILE;
        g_uOpenType   = TSTTYPE_FLATFILE;
    }

    // Now check the registry, and override where necessary
    StgCheckRegistry ();

    // finally, is the disk sub-system compatible with NSS
    if (FALSE == StgCheckVolumeInformation ())
    {
        fRet = FALSE;
    }

    return fRet;
}

//********************************************************************
// Function:  StgCheckRegistryFor
//
// Synopsis:  Check the registry to see if OLE will create nssfiles.
//            Adjust g_fRegistrySet to whether NSS regvalues are set.
// 
// Return:    TRUE  if ok
//            FALSE if registry not set for NSS files
// 
//********************************************************************
BOOL  StgCheckRegistry (void)
{
    HKEY    hKey;
    LONG    lErr;
    TCHAR   tszData[10];
    DWORD   dwType, dwSize;
    LPCTSTR ptszRegKey = {TEXT("Software\\Microsoft\\OLE")};
    LPCTSTR ptszNssRegValue= {TEXT("EnableNtfsStructuredStorage")};
    LPCTSTR ptszCnssRegValue= {TEXT("EnableCNSS")};

    DH_FUNCENTRY (NULL, DH_LVL_DFLIB, TEXT("StgCheckRegistryForNSS"));

    // get whats in the registry
    lErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE, ptszRegKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == lErr)
    {
        dwSize = sizeof (tszData);
        lErr = RegQueryValueEx (hKey, 
                ptszNssRegValue, 
                0, 
                &dwType, 
                (LPBYTE)tszData, 
                &dwSize);
        if (ERROR_SUCCESS != lErr)
        {
            DH_TRACE ((DH_LVL_DFLIB, TEXT("RegQueryValueEx error; lErr=%#lx"), lErr));
        }
        else
        {
            // bit 2 /createas:
            if (TCHAR('Y') == tszData[0] || TCHAR('y') == tszData[0])
            {
                g_fRegistryBits |= REG_CREATE_AS;
            }
            else if (TCHAR('N') == tszData[0] || TCHAR('n') == tszData[0])
            {
                g_fRegistryBits &= ~REG_CREATE_AS;
            }
            // bit 1 /openas:
            if (TCHAR('Y') == tszData[1] || TCHAR('y') == tszData[1])
            {
                g_fRegistryBits |= REG_OPEN_AS;
            }
            else if (TCHAR('N') == tszData[1] || TCHAR('n') == tszData[1])
            {
                g_fRegistryBits &= ~REG_OPEN_AS;
            }
        }

        dwSize = sizeof (tszData);
        tszData[0] = tszData[1] = 0;
        lErr = RegQueryValueEx (hKey, 
                ptszCnssRegValue, 
                0, 
                &dwType, 
                (LPBYTE)tszData, 
                &dwSize);
        if (ERROR_SUCCESS != lErr)
        {
            DH_TRACE ((DH_LVL_DFLIB, TEXT("RegQueryValueEx error; lErr=%#lx"), lErr));
        }
        else
        {
            // bit 3 enable cnss
            if (TCHAR('Y') == tszData[0] || TCHAR('y') == tszData[0])
            {
                g_fRegistryBits |= REG_CNSS_ENABLE;
            }
            else if (TCHAR('N') == tszData[0] || TCHAR('n') == tszData[0])
            {
                g_fRegistryBits &= ~REG_CNSS_ENABLE;
            }
        }
        RegCloseKey (hKey);
    }
    else
    {
        DH_TRACE ((DH_LVL_DFLIB, TEXT("RegOpenKeyEx error; lErr=%#lx"), lErr));
    }

    return TRUE;
}

//********************************************************************
// Function:  StgCheckVolumeInformation
//
// Synopsis:  If not doing docfiles, check the disk sub-system. 
//            If not NTFS, spew
// 
// Return:    TRUE  if ok
//            FALSE if doing nss, disk not ntfs
// 
//********************************************************************
BOOL  StgCheckVolumeInformation (void)
{
    LPTSTR  pstrType = TSZ_DOCFILE;
    TCHAR   pFileSystemNameBuffer[10];
    DWORD   dwFileSystemFlags;
    BOOL    fVolInfo = FALSE;
    BOOL    fNTFS    = FALSE;

    // if we are forcing an nssfile somewhere, or we 
    // are going for default of nssfile
    if (TSTTYPE_NSSFILE == g_uOpenType || TSTTYPE_NSSFILE == g_uCreateType)
    {
        fVolInfo = GetVolumeInformation (NULL,
                NULL,
                0,
                NULL,
                0,
                &dwFileSystemFlags,
                pFileSystemNameBuffer,
                ARRAYSIZE (pFileSystemNameBuffer));

        // if we can detect the disk subsystem
        if (0 != fVolInfo)
        {
            // if not NTFS, 'fix' two flags
            if (0 == lstrcmp (pFileSystemNameBuffer, TEXT("NTFS")))
            {
                fNTFS = TRUE;
            }
        }

        if (FALSE == fNTFS)
        {
            DH_TRACE ((DH_LVL_ALWAYS, 
                    TEXT("WARNING: Disk subsystem not NTFS! NSS not possible!")));
        }
    }
    else
    {
        fNTFS = TRUE;
    }

    return fNTFS;
}

// hook the stgcreatedocfile stgopenstorage apis for debugging purposes -scousens

#ifdef _HOOK_STGAPI_

#undef StgCreateDocfile
#undef StgOpenStorage

//---------------------------------------------------------------
// @doc
// @func    mStgCreateDocfile |
//          Wraps calls to StgCreateDocfile. This is a mechanism
//          to conditionally get current code to call the 
//          StgCreateStorageEx API without changing the existing 
//          codebase.
//
// @rdesc   returns whatever the called function returned.
//
// @comm    condition set in StgInitStgFormatWrap
//
// @comm    The parameters that differ between the two APIs 
//          are essentially ignored/defaulted. 
//---------------------------------------------------------------
HRESULT mStgCreateDocfile(const OLECHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen)
{
    HRESULT hr;
   
    // With 1795 changes to "dwReserved" Parameter to -> version number,
    // sector size (allowed is 512, 4096 only) and reserved parameter as
    // typedef struct tagSTGOPTIONS
    // {
    //  USHORT usVersion;            // Version 1
    //  USHORT reserved;             // must be 0 for padding
    //  ULONG ulSectorSize;          // docfile header sector size (512)
    // } STGOPTIONS;

    STGOPTIONS  stgOptions;
    stgOptions.usVersion = 1;   
    stgOptions.reserved = (USHORT)reserved; // Take from function arg 
    stgOptions.ulSectorSize = g_ulSectorSize; 

    DH_FUNCENTRY (NULL, DH_LVL_STGAPI, TEXT("mStgCreateDocfile:"));

    // If default, use old api
    if (TSTTYPE_DEFAULT == g_uCreateType)
    {
        hr = StgCreateDocfile (pwcsName,
                grfMode,
                reserved,
                ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateDocfile; mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // force docfile with StgCreateStorageEx (STGFMT_DOCFILE)
    else if (TSTTYPE_DOCFILE == g_uCreateType)
    {
        hr = StgCreateStorageEx (pwcsName,
                grfMode,
                STGFMT_DOCFILE,  //force it to be a docfile
                0,
                &stgOptions,
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateStorageEx (df); mode=%#lx; sectorsize=%#lx; hr=%#lx"), grfMode, g_ulSectorSize,hr));
    }
    // force flatfile with StgCreateStorageEx (STGFMT_FILE)
    else if (TSTTYPE_FLATFILE == g_uCreateType)
    {
        hr = StgCreateStorageEx (pwcsName,
                grfMode,
                STGFMT_FILE,  //force it to be a flatfile
                0,
                &stgOptions,
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateStorageEx (df); mode=%#lx; sectorsize=%#lx; hr=%#lx"), grfMode, g_ulSectorSize,hr));
    }
    // else try force nssfile with StgCreateStorageEx () 
    else 
    {
        hr = StgCreateStorageEx (pwcsName,
                grfMode,
                STGFMT_GENERIC,  //force it to be a nssfile (if possible)
                0,
                &stgOptions,
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateStorageEx (df); mode=%#lx; hr=%#lx, sectorsize=%#lx"), grfMode, hr, g_ulSectorSize));
    }
    return (hr);
}

//---------------------------------------------------------------
// @doc
// @func    mStgOpenStorage |
//          Wraps calls to StgOpenStorage. This is a mechanism
//          to conditionally get current code to call the 
//          StgOpenStorageEx API without changing the existing 
//          codebase.
//
// @rdesc   returns whatever the called function returned.
//
// @comm    condition set in StgInitStgFormatWrap
//
// @comm    The parameters that differ between the two APIs 
//          are essentially ignored/defaulted. 
//---------------------------------------------------------------
HRESULT mStgOpenStorage (const OLECHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen)
{
    HRESULT hr;

    DH_FUNCENTRY (NULL, DH_LVL_STGAPI, TEXT("mStgOpenStorage:"));

    // If default, or we have snbs or priority stgs, use old api
    if (TSTTYPE_DEFAULT == g_uOpenType || 
            NULL != pstgPriority ||
            NULL != snbExclude)
    {
        hr = StgOpenStorage (pwcsName,
                pstgPriority,
                grfMode,
                snbExclude,
                reserved,
                ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorage; mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // Force docfile with StgOpenStorageEx (STGFMT_DOCFILE) 
    else if (TSTTYPE_DOCFILE == g_uOpenType)
    {
        hr = StgOpenStorageEx (pwcsName,
                grfMode,
                STGFMT_DOCFILE,  //force it to be a docfile
                0,
                NULL,           // (void*)reserved -> STGOPTIONS*, BUGBUG
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorageEx (df); mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // Force flatfile with StgOpenStorageEx (STGFMT_FILE) 
    else if (TSTTYPE_FLATFILE == g_uOpenType)
    {
        hr = StgOpenStorageEx (pwcsName,
                grfMode,
                STGFMT_FILE,  //force it to be a flatfile
                0,
                NULL,           // (void*)reserved -> STGOPTIONS*, BUGBUG
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorageEx (df); mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // else try force nssfile with StgOpenStorageEx () 
    else
    {
        hr = StgOpenStorageEx (pwcsName,
                grfMode,
                STGFMT_GENERIC,  //force it to be a nssfile (if possible)
                0,
                NULL,           // (void*)reserved -> STGOPTIONS*, BUGBUG
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorageEx(nss); mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    return (hr);
}
#endif  /* _HOOK_STGAPI_ */

#endif /* _OLE_NSS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\vcnode.cxx ===
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       vcnode.cxx
//
//  Contents:   Implementation for in-memory Virtual Container Node class.
//
//  Classes:    VirtualCtrNode (vcn)
//
//  Functions:  VirtualCtrNode()  
//              ~VirtualCtrNode()
//              Init
//              AppendChildCtr
//              AppendSisterCtr
//              AppendFirstChildStm
//              CreateRoot
//              CreateRootEx
//              Create
//              Open
//              OpenRoot
//              OpenRootEx
//              Close
//              Commit
//              Rename
//              Destroy
//              Stat
//              EnumElements 
//              SetElementTimes 
//              SetClass
//              SetStateBits
//              MoveElementTo
//              Revert
//              CopyTo 
//              AddRefCount
//              QueryInterface
//              CreateRootOnCustomILockBytes
//              OpenRootOnCustomILockBytes
//
//              NOTE: All above functions are public
//
//  History:    DeanE    21-Mar-96   Created
//              Narindk  24-Apr-96   Added more functions 
//              SCousens  2-Feb-97   Added Open/CreateRoot for NSS files
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
//
DH_DECLARE;

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::VirtualCtrNode, public
//
//  Synopsis:   Constructor.  
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualCtrNode::VirtualCtrNode() : 
                          _pvcnChild(NULL),
                          _pvcnSister(NULL),
                          _pvcnParent(NULL),
                          _pvsnStream(NULL),
                          _cStreams(0),
                          _ptszName(NULL),
                          _cChildren(0),
                          _dwCRC(CRC_PRECONDITION),
                          _pstg(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualCtrNode"));
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::~VirtualCtrNode, public
//
//  Synopsis:   Destructor.  Frees resources associated with this object,
//              including closing the storage if open and removing this
//              tree from memory.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualCtrNode::~VirtualCtrNode()
{
    ULONG ulRef =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::~VirtualCtrNode"));
    
    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

    if ( NULL != _pstg )
    {
        ulRef = _pstg->Release();

        // Assert if ulRef is not zero, object is being destructed.
        DH_ASSERT(0 == ulRef);

        _pstg = NULL;
    }
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Init, public
//
//  Synopsis:   Initializes a storage node - does not open or create the
//              actual storage.
//
//  Arguments:  [tszName]    - Name of this storage
//              [cStg]       - Number of storages contained in this storage. 
//              [cStm]       - Number of streams contained in this storage. 
//
//  Returns:    S_OK if node initialized successfully, otherwise an error.
//
//  Notes:      BUGBUG - Not Nashville Safe...
//
//  History:    Narindk   18-Apr-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Init( LPTSTR tszName, ULONG cStg, ULONG cStm) 
{
    HRESULT hr = S_OK;

    DH_VDATESTRINGPTR(tszName);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Init"));

    DH_ASSERT(NULL != tszName);

    if( S_OK == hr)
    {
        _ptszName = new TCHAR[_tcslen(tszName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, tszName);

            _cChildren = cStg;
            _cStreams  = cStm;
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AppendChildCtr, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' child
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AppendChildCtr(VirtualCtrNode *pvcnNew)
{
    HRESULT         hr          = S_OK;
    VirtualCtrNode  *pvcnTrav   = this;

    DH_VDATEPTRIN(pvcnNew, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::AppendChildCtr"));

    DH_ASSERT(NULL != pvcnNew);

    if(S_OK == hr)
    {
        // Find the last child in the structure
    
        while (NULL != pvcnTrav->_pvcnChild)
        {
            pvcnTrav = pvcnTrav->_pvcnChild;
        }

        // Append the new node as a child of the last node,
        // and make the new node point to the last node as it's parent
    
        pvcnTrav->_pvcnChild = pvcnNew;
        pvcnNew->_pvcnParent = pvcnTrav;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AppendSisterCtr, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' sister 
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AppendSisterCtr(VirtualCtrNode *pvcnNew)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   this;

    DH_VDATEPTRIN(pvcnNew, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::AppendSisterCtr"));

    DH_ASSERT(NULL != pvcnNew);

    if(S_OK == hr)
    {
        // Find the last sister in the chain 
    
        while (NULL != pvcnTrav->_pvcnSister)
        {
            pvcnTrav = pvcnTrav->_pvcnSister;
        }

        // Append the new node as a sister of the last node,
        // and make the new node point to this nodes parent as it's parent

        pvcnTrav->_pvcnSister = pvcnNew;
        pvcnNew->_pvcnParent = pvcnTrav->_pvcnParent;
    }

    return  hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AppendFirstChildStm, public
//
//  Synopsis:   Appends the first stream to its parent storage 
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AppendFirstChildStm(VirtualStmNode *pvsnNew)
{
    HRESULT         hr          = S_OK;
    VirtualCtrNode  *pvcnCurrent= this;

    DH_VDATEPTRIN(pvsnNew, VirtualStmNode);

    DH_FUNCENTRY(&hr,DH_LVL_DFLIB,TEXT("VirtualCtrNode::AppendFirstChildStm"));

    DH_ASSERT(NULL != pvsnNew);

    if(S_OK == hr)
    {
        // Append the new stream node (first stream node) to parent storage,
        // and make the new stream node point to storage as it's parent

        pvcnCurrent->_pvsnStream = pvsnNew;
        pvsnNew->_pvcnParent = pvcnCurrent;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CreateRoot, public
//
//  Synopsis:   Wrapper for StgCreateDocFile that will create a new root
//              compound file in the file system.
//
//  Arguments:  [grfmode] - Access mode for opening new compound file.
//              [dwReserved] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    18-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CreateRoot(DWORD grfMode, 
        DWORD   dwReserved, 
        DSKSTG  DiskStgType)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_ASSERT(0 == dwReserved);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::CreateRoot"));

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = StgCreateDocfile(pOleStrTemp, grfMode, dwReserved, &_pstg);

        DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("StgCreateRootStorage:%s"), _ptszName));

        if (S_OK == hr)
        {
            if(!StorageIsFlat())
                DH_LOG ((LOG_INFO, TEXT("Created docfile:%s"), _ptszName));
            else
                DH_LOG ((LOG_INFO, TEXT("Created flatfile:%s"), _ptszName));
        }
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }
 
    return  hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CreateRootEx, public (overload)
//
//  Synopsis:   Wrapper for StgCreateDocFileEx that will create a new root
//              compound file in the file system.
//
//  Arguments:  [grfMode]     - Access mode for opening new compound file.
//              [stgfmt]      - Storage Format - enum.
//              [grfAttrs]    - Attributes (zero for now)
//              [pStgOptions] - STGOPTIONS.
//              [pTransaction]- Reserved by OLE for future use, must be zero.
//              [riid]        - should be IID_IStorage to get an IStorage
//
//  Returns:    S_OK for success or an error code.
//
//  History:    28-Jan-97   SCousens     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CreateRootEx(DWORD grfMode, 
        DWORD  stgfmt,
        DWORD  grfAttrs,
        STGOPTIONS *pStgOptions,
        PVOID  pTransaction, 
        REFIID riid)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::CreateRoot"));

    DH_ASSERT(0 == stgfmt);   // want value of 0
    DH_ASSERT(0 == grfAttrs);        // want 0
    DH_ASSERT(NULL == pStgOptions); // want value of NULL for wrapper
    DH_ASSERT(NULL == pTransaction);
    DH_ASSERT(IsEqualIID (IID_IStorage, riid)); // want IStorages. may change

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR
        hr = TStringToOleString(_ptszName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = StgCreateStorageEx (pOleStrTemp, 
                grfMode, 
                stgfmt, 
                grfAttrs, 
                pStgOptions, 
                pTransaction, 
                riid, 
                (void**)&_pstg);
        DH_HRCHECK(hr, TEXT("StgCreateDocFileEx")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("StgCreateRootStorageEx:%s"), _ptszName));

        if (S_OK == hr)
        {
            DH_LOG ((LOG_INFO, TEXT("Created docfile:%s"), _ptszName));
        }
    }

    // Clean up
    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }
 
    return  hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Create, public
//
//  Synopsis:   Wrapper for IStorage::CreateStorage that will create and 
//              open a new IStorage object within this storage object.
//
//  Arguments:  [grfmode] -     Access mode for creating & opening new storage 
//                              object.
//              [dwReserved1] - Reserved by OLE for future use, must be zero.
//              [dwReserved2] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    18-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Create(
    DWORD       grfMode, 
    DWORD       dwReserved1, 
    DWORD       dwReserved2)
{
    HRESULT     hr          =   S_OK;
    LPSTORAGE   pstg        =   NULL;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Create"));

    DH_ASSERT(0 == dwReserved1);
    DH_ASSERT(0 == dwReserved2);

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->CreateStorage(
                pOleStrTemp, 
                grfMode, 
                dwReserved1, 
                dwReserved2, 
                &_pstg);

        DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("CreateStorage:%s"), _ptszName));
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Open, public
//
//  Synopsis:   Wrapper for IStorage::OpenStorage that will open the named 
//              IStorage object within this storage object.
//
//  Arguments:  [grfmode] -    Access mode for opening the storage object. 
//              [dwReserved] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    24-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Open(
    LPSTORAGE   pstgPriority, 
    DWORD       grfmode, 
    SNB         snbExclude,  
    DWORD       dwReserved)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;
    LPSTORAGE   pstg        =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Open"));

    DH_ASSERT(0 == dwReserved);

    // Check if it is root storage, if it is, then call OpenRoot and 
    // return here else proceed.
 
    if(NULL == this->_pvcnParent)
    {
        DH_LOG ((LOG_INFO, 
                TEXT("Test called Open to open root storage. Calling OpenRoot.")));
        hr = this->OpenRoot (pstgPriority, 
                grfmode, 
                snbExclude, 
                dwReserved);
        
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot"));

        return hr;
    }

    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the storage.

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->OpenStorage(
                          pOleStrTemp,
                          pstgPriority,
                          grfmode,
                          snbExclude,
                          dwReserved,
                          &pstg);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStorage"));
        DH_TRACE ((DH_LVL_DFLIB, TEXT("OpenStorage:%s"), _ptszName));
    }

    // Save it if function succeeds if _pstg is NULL.

    if((S_OK == hr) && (NULL == _pstg))
    { 
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::OpenRoot, public
//
//  Synopsis:   Wrapper for IStorage::OpenStorage that will open the named 
//              IStorage object within this storage object.
//
//  Arguments:  [grfmode] -     Access mode for creating & opening new storage 
//                              object.
//              [dwReserved1] - Reserved by OLE for future use, must be zero.
//              [dwReserved2] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    24-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::OpenRoot(
    LPSTORAGE   pstgPriority, 
    DWORD       grfmode, 
    SNB         snbExclude,  
    DWORD       dwReserved,
    DSKSTG      DiskStgType)
{
    HRESULT         hr          =   S_OK;
    IStorage        *pstg       =   NULL;
    LPOLESTR        pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::OpenRoot"));

    DH_ASSERT(0 == dwReserved);

    // Make sure this is the Root.
    DH_ASSERT(NULL == this->_pvcnParent);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the root storage 

    if(S_OK == hr)
    {
#if (WINVER<0x500)          //NT5 is lockviolation fixed
        DG_INTEGER dgi(0);
        ULONG ulRandNum = 0;
        USHORT usErr = 0;
        int i = 0;
        
        // Try opening the docfile
        // StgOpenStorage returns STG_E_LOCKVIOLATION is concurrent API calls
        // are made, so this is the hack for workaround the problem.
        // BUGBUG : Remove this loop once the feature is implemented in OLE.
        // BUGBUG : ntbug#114779  Affects DCOM95 only. ntbug#41249 fixed
          
        for(i=0; i<NRETRIES; i++)  // NRETRIES has been defined as 20
        {
#endif
            hr = StgOpenStorage(
                    pOleStrTemp,
                    pstgPriority,
                    grfmode,
                    snbExclude,
                    dwReserved,
                    &pstg);

            DH_HRCHECK(hr, TEXT("StgOpenStorage"));
            DH_TRACE ((DH_LVL_DFLIB, TEXT("StgOpenRootStorage:%s"), _ptszName));

#if (WINVER<0x500)          //NT5 is lockviolation fixed
            if ( (S_OK == hr) || (STG_E_LOCKVIOLATION != hr) )
            {
                break;
            }

            // Sleep for a random amount of time
            // Note: No particular reason why the below random numbers have been used
            usErr = dgi.Generate(&ulRandNum, 1, 100 );
            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                Sleep(ulRandNum*50);            
            }
        }
#endif
    }

    if((S_OK == hr) && (NULL == _pstg))
    {
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot"));

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::OpenRootEx, public (overload)
//
//  Synopsis:   Wrapper for StgOpenStorageEx that will open a previously 
//              created root compound file in the file system.
//
//  Arguments:  [grfMode]     - Access mode for opening the compound file.
//              [stgfmt]      - Storage Format - enum.
//              [grfAttrs]    - Attributes
//              [pStgOptions] - STGOPTIONS, must be NULL as on build 1795.
//              [pTransaction]- Reserved by OLE for future use, must be zero.
//              [riid]        - should be IID_IStorage to get an IStorage
//
//  Returns:    S_OK for success or an error code.
//
//  History:    28-Jan-97   SCousens     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::OpenRootEx(
    DWORD       grfMode, 
    DWORD       stgfmt, 
    DWORD       grfAttrs, 
    STGOPTIONS  *pStgOptions,
    PVOID       pTransaction,
    REFIID      riid)
{
    HRESULT         hr          =   S_OK;
    IStorage        *pstg       =   NULL;
    LPOLESTR        pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::OpenRoot"));

    // Make sure this is the Root.
    DH_ASSERT(NULL == this->_pvcnParent);
    DH_ASSERT(0 == stgfmt);   // want value of 0
    DH_ASSERT(0 == grfAttrs);        // want 0
    DH_ASSERT(NULL == pStgOptions);  // want value of NULL 
    DH_ASSERT(NULL == pTransaction);
    DH_ASSERT(IsEqualIID (IID_IStorage, riid)); // want IStorages. may change

    if (S_OK == hr)
    {
        // Convert _ptszName to OLECHAR
        hr = TStringToOleString(_ptszName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the root storage 
    if (S_OK == hr)
    {
        DG_INTEGER dgi(0);
        ULONG ulRandNum = 0;
        USHORT usErr = 0;
        int i = 0;
        
        // Try opening the docfile
        // StgOpenStorage returns STG_E_LOCKVIOLATION is concurrent API calls
        // are made, so this is the hack for workaround the problem.
        // BUGBUG : Remove this loop once the feature is implemented in OLE.
          
        for(i=0; i<NRETRIES; i++)  // NRETRIES has been defined as 20
        {
            hr = StgOpenStorageEx(pOleStrTemp,
                    grfMode, 
                    stgfmt, 
                    grfAttrs,
                    pStgOptions,   
                    pTransaction,
                    riid, 
                    (void**)&pstg);

            DH_HRCHECK(hr, TEXT("StgOpenStorageEx"));
            DH_TRACE ((DH_LVL_DFLIB, TEXT("StgOpenRootStorageEx:%s"), _ptszName));

            if ( (S_OK == hr) || (STG_E_LOCKVIOLATION != hr) )
            {
                break;
            }

            // Sleep for a random amount of time
            // Note: No particular reason why the below random numbers have been used
            usErr = dgi.Generate(&ulRandNum, 1, 100 );
            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                Sleep(ulRandNum*50);
                DH_TRACE ((DH_LVL_TRACE4, 
                        TEXT("VirtualCtrNode::OpenRoot: Sleeping due to LOCKVIOLATION")));
            }
        }
    }

    if((S_OK == hr) && (NULL == _pstg))
    {
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot"));

    // Clean up
    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Close, public
//
//  Synopsis:   Closes an open storage.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//  History:    NarindK   25-Apr-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Close()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulRef   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Close"));

    // When we create the storage, it is open.  We do not call release
    // on _pstg normally till the VirtualCtrNode object is destructed,  or
    // if explicitly this function is used to close the storage

    if ( NULL != _pstg )
    {
        ulRef = _pstg->Release();
    }
    else
    {
        DH_ASSERT(!TEXT("_pStg is already NULL!"));
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
  
    if(0 == ulRef)
    {
        _pstg = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Commit, public
//
//  Synopsis:   Wrapper for IStorage::Commit that will commit any changes
//              made to an IStorage object since it was opened or last
//              committed to persistent storage. 
//
//  Arguments:  [grfCommitFlags] - Controls how object is committed to IStorage.
//
//  Returns:    S_OK                Commit operation was successful.
//              STG_E_NOTCURRENT    Another opening of storage object has commi
//                                  tted changes, possibility of overwriting.
//              STG_E_MEDIUMFULL    No space left on device to commit.
//              STG_E_TOOMANYOPENFILES too many open files.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INVALIDFLAG   Invalid flag.
//              STG_E_INVALIDPARAMETER Inalid parameter  
//
//  History:    29-Apr-96   NarindK     Created
//              12-Mar-97   MikeW       Removed HRCHECK after Commit
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Commit(DWORD grfCommitFlags)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Commit"));

    DH_ASSERT(NULL != _pstg);

    if ( S_OK == hr )
    {
        hr = _pstg->Commit(grfCommitFlags);
    }
    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Rename, public
//
//  Synopsis:   Wrapper for IStorage::RenameElement that renames an element 
//              contained in an Storage object subject to transaction state
//              of IStorage object. 
//
//  Arguments:  [pptcsNewName] - Points to pointer to new name for the element. 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  Named element ptcsNewName alreadys exists. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    29-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Rename(LPCTSTR ptcsNewName)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrOld  =   NULL;
    LPOLESTR    pOleStrNew  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Rename"));

    DH_VDATESTRINGPTR(ptcsNewName);

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrOld);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptcsNewName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptcsNewName, &pOleStrNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->RenameElement(pOleStrOld, pOleStrNew);

        DH_HRCHECK(hr, TEXT("IStorage::Rename")) ;
    }

    if(S_OK == hr)
    {
        // Change the name of VirtualCtrNode i.e. its _ptszName variable also

        // First delete the old name

        if(NULL != _ptszName)
        {
            delete _ptszName;
            _ptszName = NULL;
        }

        // Now copy the new name by allocating enough memory
        _ptszName = new TCHAR[_tcslen(ptcsNewName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, ptcsNewName);
        }
    }

    // Clean up

    if(NULL != pOleStrOld)
    {
        delete pOleStrOld;
        pOleStrOld = NULL;
    }

    if(NULL != pOleStrNew)
    {
        delete pOleStrNew;
        pOleStrNew = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Destroy, public
//
//  Synopsis:   Wrapper for IStorage::DestroyElement that removes an element 
//              storage from this storage, subject to transaction mode in 
//              which it was opened.  The wrapper for IStorage::DestroyElement
//              that destorys a stream element from this storage is in
//              VirtualStmNode::Destroy. 
//
//  Arguments:  None 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    29-Apr-96   NarindK     Created
//
//  Notes:      The existing open instance of this element from this parent
//              instance becomes invalid after this function is called.
//
//              Use DestroyStorage in the util.cxx which is a wrapper to call
//              this function and also readjusts the VirtualDF tree.
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Destroy()
{
    HRESULT     hr          =   S_OK;
    LPSTORAGE   pstg        =   NULL;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Destroy"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);
    
    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->DestroyElement(pOleStrTemp);

        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Stat, public
//
//  Synopsis:   Returns relevant statistics concerning this open storage.
//
//  Arguments:  [pStatStg] - pointer to STATSTG structure.
//              [grfStatFlag] - Controls levels of returned statistics.
//
//  Returns:    S_OK                Statistics were successfully returned. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//
//  History:    NarindK   8-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Stat(
    STATSTG         *pStatStg,
    DWORD           grfStatFlag)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Stat"));

    DH_ASSERT(_pstg != NULL);

    DH_ASSERT(NULL != pStatStg);

    DH_ASSERT((
        (grfStatFlag == STATFLAG_DEFAULT) ||
        (grfStatFlag == STATFLAG_NONAME)));

    if(S_OK == hr)
    { 
        hr = _pstg->Stat(pStatStg, grfStatFlag);

        DH_HRCHECK(hr, TEXT("IStorage::Stat"));
    }

    // BUGBUG:  May remove to need DH_ assert macros to do invalid parameter
    // checking.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::EnumElements, public
//
//  Synopsis:   Enumerates the elements immediately contained within this
//              storage object.
//
//  Arguments:  [dwReserved1] - Reserved by OLE 
//              [dwReserved2] - Reserved by OLE
//              [dwReserved3] - Reserved by OLE
//              [ppenumStatStg] - Points to where to return enumerator, NULL
//                              if an error.
//
//  Returns:    S_OK                     Enumeration successful. 
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter. 
//              E_OUTOFMEMORY            Not enough memory.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//
//  History:    NarindK   10-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::EnumElements(
   DWORD           dwReserved1,
   PVOID           pReserved2,
   DWORD           dwReserved3, 
   LPENUMSTATSTG   *ppenumStatStg)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::EnumElements"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    { 
        hr = _pstg->EnumElements(
                dwReserved1, 
                pReserved2, 
                dwReserved3, 
                ppenumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::SetElementTimes, public
//
//  Synopsis:   Sets the modification, access, and creation times of the 
//              indicated element of this storage object. 
//
//  Arguments:  [lpszName] -  Points to name of element to change 
//              [pctime]   -  Points to new creation time 
//              [patime]   -  Points to new access time 
//              [pmtime]   -  Points to new modification time 
//
//  Returns:    S_OK                     Time values successfully set. 
//              STG_E_ACCESSDENIED       insufficient permissions. 
//              STG_E_FILENOTFOUND       Element not found. 
//              STG_E_FILEALREADYEXITS   Specified file already exists. 
//              STG_E_TOOMANYOPENFILES   too many open files
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter. 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//
//  History:    NarindK   10-May-96   Created
//
//  Notes:      Ole implemntation doesn't support setting time on stream elem
//              so no function corresponding to VirtualStmNode for this.
//
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::SetElementTimes(
   FILETIME const  *pctime,
   FILETIME const  *patime,
   FILETIME const  *pmtime)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::SetElementTimes"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);
    
    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    { 
        hr = _pvcnParent->_pstg->SetElementTimes(
                pOleStrTemp, 
                pctime, 
                patime, 
                pmtime);

        DH_HRCHECK(hr, TEXT("IStorage::SetElementTimes"));
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::SetClass, public
//
//  Synopsis:   Persistently stores the object's CLSID.
//
//  Arguments:  [rclsid] - Specifies CLSID to be associated with this storage.
//
//  Returns:    S_OK                CLSID successfully stored. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_MEDIUMFULL    Not enough space on device.  
//
//  History:    NarindK   9-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::SetClass(REFCLSID rclsid)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::SetClass"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    { 
        hr = _pstg->SetClass(rclsid);

        DH_HRCHECK(hr, TEXT("IStorage::SetClass"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::SetStateBits, public
//
//  Synopsis:   Stores upto 32 bits of state information in this IStorage.
//
//  Arguments:  [grfStateBits] - New values of bits to be set
//              [grfMask]      - Binary mask to indicate significant bits.
//
//  Returns:    S_OK                State successfully set. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_INVALIDFLAG   Invalid flag in grfStateBits or grfMask  
//
//  History:    NarindK   9-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::SetStateBits(
    DWORD       grfStateBits,
    DWORD       grfMask)
{
    HRESULT     hr      =   S_OK;
    LPSTORAGE   pstg    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::SetStateBits"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    { 
        hr = _pstg->SetStateBits(grfStateBits, grfMask);

        DH_HRCHECK(hr, TEXT("IStorage::SetStateBits"));
    }

    return hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::MoveElementTo, public
//
//  Synopsis:   Moves an IStorage/IStream element to indicated new destination 
//              container. 
//
//  Arguments:  [ptszName] - Name of child IStorage/IStream present in this
//                           this _pstg to be moved 
//              [pvcnDest] - Pointer to destination virtual container
//              [lpszNewname] - Points to new name to element in its new 
//                              container
//              [grfFlags] - Specifies if to move as move or copy
//
//  Returns:    S_OK                Storage moved successfully. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_FILENOTFOUND       Element not found. 
//              STG_E_FILEALREADYEXITS   Specified file already exists. 
//              STG_E_TOOMANYOPENFILES   too many open files
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_INVALIDFLAG   Invalid flag in grfFlags 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//
//  History:    NarindK   13-May-96   Created
//
//  Notes:      This moves a child storage/stream with name ptszName in present 
//              storage _pstg to a destination storage.  Make sure that the
//              child storage/stream to be moved is closed and the destination 
//              storage is open. 
//              The VirtualDF tree needs to be readjusted after this call.
//              Different methods of VirtualDF may need to be called as the
//              case may be - AdjustTreeOnStgMoveElement, AdjustTreeOnStmMove
//              Element, AdjustTreeOnStgCopyElement, AdjustTreeOnStmCopyElement
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::MoveElementTo(
    LPCTSTR         ptszName,
    VirtualCtrNode  *pvcnDest,
    LPCTSTR         ptszNewName,
    DWORD           grfFlags)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrOld  =   NULL;
    LPOLESTR    pOleStrNew  =   NULL;

    DH_VDATESTRINGPTR(ptszName);
    DH_VDATESTRINGPTR(ptszNewName);
    DH_VDATEPTRIN(pvcnDest, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::MoveElementTo"));

    DH_ASSERT(_pstg != NULL);
    DH_ASSERT(NULL != pvcnDest);
    DH_ASSERT(pvcnDest->_pstg != NULL);

    DH_ASSERT(NULL != ptszName);
    DH_ASSERT(NULL != ptszNewName);
    DH_ASSERT((grfFlags == STGMOVE_COPY) ||
              (grfFlags == STGMOVE_MOVE));

    if(S_OK == hr)
    {
        // Convert ptszName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptszName, &pOleStrOld);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptszNewName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptszNewName, &pOleStrNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    { 
        hr = _pstg->MoveElementTo(
                pOleStrOld,
                pvcnDest->_pstg,
                pOleStrNew,
                grfFlags);

        DH_HRCHECK(hr, TEXT("IStorage::MoveElementTo"));
    }

    // Clean up

    if(NULL != pOleStrOld)
    {
        delete pOleStrOld;
        pOleStrOld = NULL;
    }

    if(NULL != pOleStrNew)
    {
        delete pOleStrNew;
        pOleStrNew = NULL;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Revert, public
//
//  Synopsis:   Discards all changes made in or made visible to thsi storage
//              object since it was opened or last committed.  
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//              S_OK                        Revert operation successful. 
//              STG_E_INSUFFICIENTMEMORY    Out of memory.
//              STG_E_TOOMANYOPENFILES      Too many open files.
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//
//  History:    NarindK   20-May-96   Created
//
//  Notes:      
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Revert()
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Revert"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    {
        hr = _pstg->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CopyTo, public
//
//  Synopsis:   Copies  an IStorage element to indicated new destination 
//              container. 
//
//  Arguments:  [ciidExclude] - Speciefies number of elements in array pointed
//                              to by rgiidExclude. 
//              [rgiidExclude]- Specifies an array of interface identifiers the
//                              caller takes responsibility of moving from 
//                              source to destination.
//              [snbExclude] -  Points to a bloack of named elements not to
//                              to be copied into destination container.
//              [pvcnDest]-     Points to the open storage object where this
//                              open storage object is copied.
//
//  Returns:    S_OK                     Storage copied successfully. 
//              STG_E_ACCESSDENIED       insufficient permissions. 
//              STG_E_TOOMANYOPENFILES   too many open files
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter 
//              STG_E_MEDIUMFULL         Storage medium is full 
//              STG_E_DESTLACKSINTERFACE Destination lacks an interface of the
//                                       source object to be copied.
//
//  History:    NarindK   20-May-96   Created
//
//  Notes:      This copies contents of storage _pstg to a destination storage.
//              The storage to be copied from and the destination storage to
//              be copied into is open. 
//              VirtualDF tree needs to be readjusted after this call. Virtual
//              DF's AdjustTreeOnCopyTo may be used.
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CopyTo(
    DWORD           ciidExclude,
    IID const*      rgiidExclude,
    SNB             snbExclude,
    VirtualCtrNode  *pvcnDest)
{
    HRESULT     hr          =   S_OK;

    DH_VDATEPTRIN(pvcnDest, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::CopyTo"));

    DH_ASSERT(NULL != _pstg);
    DH_ASSERT(NULL != pvcnDest);
    DH_ASSERT(NULL != pvcnDest->_pstg);

    if(S_OK == hr)
    { 
        hr = _pstg->CopyTo(
                ciidExclude,
                rgiidExclude,
                snbExclude,
                pvcnDest->_pstg);

        DH_HRCHECK(hr, TEXT("IStorage::CopyTo"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AddRefCount, public
//
//  Synopsis:   Increments the reference count on IStorage object. 
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AddRefCount()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulTmp   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::AddRefCount"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    {
        ulTmp = _pstg->AddRef();
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::QueryInterface, public
//
//  Synopsis:   Returns pointers to supported objects. 
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::QueryInterface(
    REFIID      riid, 
    LPVOID      *ppvObj)
{
    HRESULT     hr      =   S_OK;
    LPSTORAGE   pstg    =   NULL;

    DH_VDATEPTROUT(ppvObj, IUnknown *) ;
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::QueryInterface"));

    DH_ASSERT(ppvObj != NULL);

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    {
        // Initilze the out parameter

        *ppvObj = NULL;

        hr = _pstg->QueryInterface(riid, ppvObj);
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface"));

    if(S_OK == hr)
    {
        DH_ASSERT(NULL != *ppvObj);
    }
    else
    {
        DH_ASSERT(NULL == *ppvObj);
    }

    return(hr);
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CreateRootOnCustomILockBytes,public
//
//  Synopsis:   Wrapper for StgCreateDocFileOnILockBytes that will create a new
//              root compound file in the file system based on custom ILockBytes
//
//  Arguments:  [grfmode] - Access mode for creating new compound file.
//              [pILockBytes] - Pointer to ILockBytes
//
//  Returns:    S_OK for success or an error code.
//
//  History:    1-Aug-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CreateRootOnCustomILockBytes(
    DWORD       grfMode, 
    ILockBytes  *pILockBytes)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("VirtualCtrNode::CreateRootOnCustomILockBytes"));

    if(S_OK == hr)
    {
        hr = StgCreateDocfileOnILockBytes(
                pILockBytes,
                grfMode,
                0,
                &_pstg);

        DH_HRCHECK(hr, TEXT("StgCreateDocFileOnLockBytes")) ;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::OpenRootOnCustomILockBytes, public
//
//  Synopsis:   Wrapper for StgOpenStorageOnILockBytes that will open the named 
//              IStorage root object on custom ILOckBytes provided. 
//
//  Arguments:  [pstgPrioirty] - Points to previous opening of root stg 
//              [grfmode] -     Access mode for creating & opening new storage 
//                              object.
//              [snbExclude] -  Points to a block of named elements not to
//                              to be excluded in open call.
//              [dwReserved] -  Reserved by OLE for future use, must be zero.
//              [pILockBytes] - Pointer to ILockBytes
//
//  Returns:    S_OK for success or an error code.
//
//  History:    3-Aug-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::OpenRootOnCustomILockBytes(
    LPSTORAGE   pstgPriority, 
    DWORD       grfmode, 
    SNB         snbExclude,  
    DWORD       dwReserved,
    ILockBytes  *pILockBytes)
{
    HRESULT         hr          =   S_OK;
    IStorage        *pstg       =   NULL;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("VirtualCtrNode::OpenRootOnCustomILockBytes"));

    // Make sure this is the Root.
    
    DH_ASSERT(NULL == this->_pvcnParent);

    // Open the root storage 

    if(S_OK == hr)
    {
        hr = StgOpenStorageOnILockBytes(
                pILockBytes,
                pstgPriority,
                grfmode,
                snbExclude,
                dwReserved,
                &pstg);
    
        DH_HRCHECK(hr, TEXT("StgOpenStorage"));
    }

    if((S_OK == hr) && (NULL == _pstg))
    {
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRootOnCustomILockBytes"));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\util.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       util.cxx
//
//  Contents:   Implementation of utilities for common class library and for
//              tests.
//
// Functions:   - GenerateRandomName
//              - GetVirtualCtrNodeForTest
//              - GetVirtualStmNodeForTest
//              - DestroyStorage
//              - DestroyStream
//              - AddStorage
//              - AddStream
//              - CalculateCRCForName
//              - CalculateCRCForDataBuffer
//              - CalculateInMemoryCRCForStg
//              - CalculateInMemoryCRCForStm
//              - ReadAndCalculateDiskCRCForStm
//              - CalculateDiskCRCForStg
//              - EnumerateInMemoryDocFile
//              - OpenRandomVirtualCtrNodeStg
//              - CloseRandomVirtualCtrNodeStg
//              - ParseVirtualDFAndCloseOpenStgsStms
//              - ParseVirtualDFAndCommitAllOpenStgs
//              - CalculateCRCForDocFile
//              - CalculateCRCForDocFileStmData
//              - TStringToOleString
//              - EnumerateDiskDocFile
//              - GenerateVirtualDFFromDiskDF
//              - GenerateRemVirtualDFTree  [local to this file]
//              - GenVirtualCtrNode [local to this file]
//              - GenVirtualStmNode [local to this file]
//              - PrivAtol
//              - GenerateRandomString
//              - GenerateRandomStreamData
//              - ParseVirtualDFAndOpenAllSubStgsStms 
//              - CommitRandomVirtualCtrNodeStg
//
//  History:    17-Apr-96   Narindk  Created.
//               2-Feb-97   SCousens Added for Cnvrs/NSS 
//              31-Mar-98   SCousens Added GenerateRandomStreamData
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration

DH_DECLARE;


// CRC 32 Bitwise lookup table, logic taken from CRC-32 description in
// 'C Programmer's Guide to Netbios' book.

ULONG aulCrc[256] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

// Functions local to this file

HRESULT GenerateRemVirtualDFTree(
    VirtualCtrNode  *pvcnParent,
    LPSTORAGE       pIStgParent);

HRESULT GenVirtualCtrNode(
    LPTSTR          ptcsName,
    VirtualCtrNode  **ppvcnNew);

HRESULT GenVirtualStmNode(
    LPTSTR          ptcsName,
    DWORD           cbSize,
    VirtualStmNode  **ppvsnNew);

//+-------------------------------------------------------------------------
//  Function:   GenerateRandomName
//
//  Synopsis:   Generates a random name using datagen object.
//
//  Arguments:  [pgds] - Pointer to DG_STRING object.
//              [pptszName] - Pointer to pointer to returned string.
//              [ulMinLen] - Minimum length of string
//              [ulMaxLen] - Maximum length of string
//
//  Returns:    HRESULT.  S_OK if everything goes ok, error code otherwise.
//
//  History:    11-Nov-96  BogdanT    Changed the DG_UNICODE ptr. to DG_STRING
//              17-Apr-96  NarindK    Created.
//
//  Notes:      BUGBUG: This function need to be enhance to handle different
//              character sets.
//              Please note that the name generated may have an extension b/w
//              0 and FILEEXT_MAXLEN besides the length of name b/w ulMinLen and
//              ulMax Len.
//--------------------------------------------------------------------------

HRESULT GenerateRandomName(
    DG_STRING   *pgds,
    ULONG       ulMinLen,
    ULONG       ulMaxLen,
    LPTSTR      *pptszName)
{
    HRESULT     hr          =   S_OK;
    ULONG       cTemp       =   0;
    USHORT      usErr       =   0;
    ULONG       ulActMaxLen =   0;
    ULONG       ulActMinLen =   0;
    ULONG       ulNameLen   =   0;
    ULONG       ulExtLen    =   0;
    LPTSTR      ptszName    =   NULL;
    LPTSTR      ptszExt     =   NULL;
    LPWSTR      pwszName    =   NULL;
    LPWSTR      pwszExt     =   NULL;

    TCHAR       ptszFATCharSet[FAT_CHARSET_SIZE];
    // TCHAR       ptszOFSCharSet[OFS_CHARSET_SIZE];
    LPWSTR      pwszFATCharSet = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GenerateRandomName"));

    DH_VDATEPTRIN(pgds, DG_STRING) ;
    DH_VDATEPTROUT(pptszName, LPTSTR) ;

    DH_ASSERT(NULL != pgds);
    DH_ASSERT(NULL != pptszName);

    if (S_OK == hr)
    {
        // Initialize out parameter.

        *pptszName = NULL;

        // Sanity check.  Min length for name must be <= maximum length, if it
        // isn't then make maximum length equal to minimum length.

        if (ulMaxLen < ulMinLen)
        {
            ulMaxLen =  ulMinLen;
        }

        // If Maximum length provided is 0, then default maximum length would
        // be used.  If Minimum length provided is zero, then 1 would be used
        // for it.

        // BUGBUG:  We are using default maximum length for FAT system.

        ulActMaxLen = (ulMaxLen == 0 ? DEF_FATNAME_MAXLEN : ulMaxLen);
        ulActMinLen = (ulMinLen == 0 ? 1 : ulMinLen);

        // '\0', '\', '/', and ':' are invalid for IStorage/IStream names
        //                         (For doc file)
        // '*', '"' '<' '>' '?' are invalid for IStorage/IStream names on OFS

        // Initialize valid character set for FAT file names

        _tcscpy(ptszFATCharSet, _TEXT("abcdefghijklmnopqrstuvwxyz"));
        _tcscat(ptszFATCharSet, _TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ"));
        _tcscat(ptszFATCharSet, _TEXT("0123456789"));

        //BUGBUG:  Check if these characters are not valid for IStorage/IStream
        //         names.

        // _tcscat(ptszFATCharSet, L"_^$~!#%&-{}()@'`");

        // Initialize valid character set for other file names.  BUGBUG: Not
        // using OFS character set at present.

        // for (TCHAR wch = 0x01; wch <= 0x7f; wch++)
        // {
        //    if (wch != L'\\' && wch != L'/' && wch != L'*' && wch != L'?')
        //    {
        //        ptszOFSCharSet[cTemp++] = wch;
        //    }
        // }
        // ptszOFSCharSet[cTemp] = NULL;

        // Call DataGen to generate a random file name
        // BUGBUG:  We are using FAT character set to generate random names.

#ifdef _MAC

	usErr = pgds->Generate(
		    (UCHAR **)&ptszName,     // force compiler to chose the right
		    (UCHAR *)ptszFATCharSet, // version of Generate
		    ulActMinLen,
		    ulActMaxLen);

#else

        if(S_OK == hr)
        {
            // Convert TCHAR to WCHAR

            hr = TStrToWStr(ptszFATCharSet, &pwszFATCharSet);
            DH_HRCHECK(hr, TEXT("TStrToWStr")) ;
        }

        usErr = pgds->Generate(
                    &pwszName,
                    pwszFATCharSet,
                    ulActMinLen,
                    ulActMaxLen);

#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // DataGen error
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Generate a random extension

#ifdef _MAC

	usErr = pgds->Generate(
		    (UCHAR **)&ptszExt,     // force compiler to chose the right
		    (UCHAR *)ptszFATCharSet, // version of Generate
		    0,
		    FILEEXT_MAXLEN);

#else

        usErr = pgds->Generate(
                  &pwszExt,
                  pwszFATCharSet,
                  0,
                  FILEEXT_MAXLEN);

#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // Failed to generate extension
        {
            hr = E_FAIL;

            delete pwszName;
            pwszName = NULL;
        }
    }

#ifndef _MAC 
	
    // In MAC version we don't use the WSZs so skip the conversions

    if(S_OK == hr)
    {
       //Convert WCHAR to TCHAR

       hr = WStrToTStr(pwszName, &ptszName);

       DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
    }

    if((S_OK == hr) && (NULL != *pwszExt))
    {
       //Convert WCHAR to TCHAR

       hr = WStrToTStr(pwszExt, &ptszExt);

       DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
    }

#endif //_MAC

    if (S_OK == hr)
    {
        ulNameLen = _tcslen(ptszName);

        if(NULL != ptszExt) 
        {
            ulExtLen = _tcslen(ptszExt);

            // If the length of the extension > 0, a '.' will be added.

            if (ulExtLen > 0)
            {
                ulNameLen += ulExtLen + 1;
            }
        }

        // Construct the full name

        *pptszName = new TCHAR[ulNameLen + 1];

        if(NULL == *pptszName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        _tcscpy(*pptszName, ptszName);

        if (ulExtLen > 0)
        {
            _tcscat(*pptszName, _TEXT("."));
            _tcscat(*pptszName, ptszExt);
        }
    }

    // Clean up

    if (NULL != ptszExt)
    {
        delete ptszExt;
        ptszExt = NULL;
    }

    if (NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if (NULL != pwszExt)
    {
        delete pwszExt;
        pwszExt = NULL;
    }

    if (NULL != pwszName)
    {
        delete pwszName;
        pwszName = NULL;
    }

    if (NULL != pwszFATCharSet)
    {
        delete pwszFATCharSet;
        pwszFATCharSet = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualCtrNodeForTest
//
//  Synopsis:   Gets a random VirtualCtrNode for doing tests on it.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to root node of subtree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualCtrNodes in subtree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualCtrNodes in subtree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeForTest] - Returned VirtualCtrNode
//
//  Returns:    HRESULT
//
//  History:    27-Apr-96  NarindK    Created.
//              12-Mar-97  MikeW      Converted to use CtrNodes not VirtDF's
//
//  Notes:      If the number of actual maximum number of storages is known,
//              provide that to cMax parameter or else pass 0 to have
//              EnumerateInMemoryDocfile called for you to know actual number 
//              of storages (thereby VirtualCtrNodes) in the tree in test.  Pl.
//              note that if a test provides improper values for cMin/cMax, 
//              asserts would be thrown by the function.  However it is okay to
//              provide valid cMin and cMax values which are lesser than actual
//              number of VirtualCtrNodes in the tree.
//
//              Call OpenRandomVirtualCtrNodeStg after calling this function to
//              open up the storage of this random VirtualCtrNode.  This might 
//              not be required if the original VirtualDF tree is being used,
//              since during first creation of VirtualDF tree, when all stgs/
//              stms are created, they are open.  However if a InMemory Docfile 
//              is generated from Disk DocFile, then only the root storage is
//              open, all other storages/streams are closed.
//
//              -Pick up a random number cRandom between cMin and cmax by
//               DataGen obj pgdi.
//              -Assign root VirtualCtrNode of tree to pvcnTrav and increment
//               temp variable counter.
//              -if counter is equal to cRandom i.e. 1, then return root Virtual
//               CtrNode for test.
//              -Else start a forever loop till node is found
//                 -While pvcnTrav's _pvcnChild is not NULL and counter is less
//                  than cRandom, loop.
//                 -if counter equals cRandom, then node found, break out of
//                  forever loop.
//                 -Else while pvcnTrav's _pvcnSister is eual to NULL, loop
//                  assinging _pvcnParent to pvcnTrav
//                 -Assign pvcnTrav's _pvcnSister to pvcnTrav and increment
//                  counter and go back to start of forever loop
//              -With node found, return that to calling function.
//--------------------------------------------------------------------------

HRESULT GetVirtualCtrNodeForTest(
    VirtualCtrNode  *pVirtualCtrNode,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeForTest)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   NULL;
    USHORT          usErr       =   0;
    ULONG           counter     =   0;
    ULONG           cRandom     =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetVirtualCtrNodeForTest"));

    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode ) ;
    DH_VDATEPTROUT(ppVirtualCtrNodeForTest, PVCTRNODE) ;

    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppVirtualCtrNodeForTest);

    // Sanity check: The tree must have atleast one virtualCtrNode in it,
    // and cMin must be <= cMax
    DH_ASSERT(cMin > 0);
    DH_ASSERT(cMin <= cMax || 0 == cMax);

    // Initialize out parameter
    *ppVirtualCtrNodeForTest = NULL;

    // If cMax is 0, find the number of CtrNodes under the given root.

    if (S_OK == hr && 0 == cMax)
    {
        hr = EnumerateInMemoryDocFile(pVirtualCtrNode, &cMax, NULL);

        if (S_OK == hr && cMax < cMin)
        {
            hr = E_UNEXPECTED;
        }
    }

    // Pick up a random number

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandom, cMin, cMax);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualCtrNode;
//        pvcnTrav = pVirtualDF->GetVirtualDFRoot();
//        DH_ASSERT(NULL != pvcnTrav);
        counter++;

        if(counter != cRandom)
        {
            for(;;)
            {
                DH_ASSERT((NULL != pvcnTrav) && (cRandom >= counter));
                while((pvcnTrav->GetFirstChildVirtualCtrNode() != NULL) &&
                      (counter < cRandom))
                {
                    pvcnTrav = pvcnTrav->GetFirstChildVirtualCtrNode();
                    counter++;
                }

                if(cRandom == counter)
                {
                    break;
                }

                while(NULL == pvcnTrav->GetFirstSisterVirtualCtrNode())
                {
                    pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
                    DH_ASSERT(NULL != pvcnTrav);
                }

                DH_ASSERT(NULL != pvcnTrav->GetFirstSisterVirtualCtrNode());
                pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                counter++;
            }
        }
    }

    if(S_OK == hr)
    {
        // Return the out parameter

        *ppVirtualCtrNodeForTest = pvcnTrav;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualCtrNodeForTest
//
//  Synopsis:   Gets a random VirtualCtrNode for doing tests on it.
//
//  Arguments:  [pVirtualDF] - Pointer to VirtualDF tree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualCtrNodes in subtree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualCtrNodes in subtree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeForTest] - Returned VirtualCtrNode
//
//  Returns:    HRESULT
//
//  History:    12-Mar-97  MikeW      Created
//
//  Notes:      Just thunk to the version of the routine that takes a
//              VirtualCtrNode instead of a VirtualDF.
//--------------------------------------------------------------------------

HRESULT GetVirtualCtrNodeForTest(
    VirtualDF       *pVirtualDF,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeForTest)
{
    DH_VDATEPTRIN(pVirtualDF, *pVirtualDF);

    //
    // Most of the parameter checking is left to the main version of this 
    // routine
    //

    return GetVirtualCtrNodeForTest(
                    pVirtualDF->GetVirtualDFRoot(),
                    pdgi,
                    cMin,
                    cMax,
                    ppVirtualCtrNodeForTest);
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualStmNodeForTest
//
//  Synopsis:   Gets a VirtualStmNode for doing tests on it.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to root node of subtree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualStmNodes in VirtualDF tree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualStmNodes in VirtualDF tree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeParent] - returned parent VirtualCtrNode
//              [ppVirtualStmNodeForTest] - returned VirtualStmNode
//
//  Returns:    HRESULT
//
//  History:    27-Apr-96  NarindK    Created.
//              12-Mar-97  MikeW      Converted to use CtrNodes not VirtDF's
//
//  Notes:      If the number of actual maximum number of storages is known,
//              provide that to cMax parameter or else pass 0 to have
//              EnumerateInMemoryDocfile called for you to know actual number
//              of storages (thereby VirtualCtrNodes) in the tree in test.  Pl.
//              note that if a test provides improper values for cMin/cMax,
//              asserts would be thrown by the function.  However it is okay to
//              provide valid cMin and cMax values which are lesser than actual
//              number of VirtualStmNodes in the tree.
//
//              Also note that this function returns a randomly picked Virtual
//              StmNode and its parent VirtualCtrNode (which is also randomly
//              picked based on VirtualStmNode).  The difference of this func
//              from GetVirtualCtrNode is that the random VirtualCtrNode picked
//              up is one having streams in it.  If none of VirtualCtrNodes
//              traversed have any streams in it, this returns an error.
//
//              -Pick up a random number cRandomStm between cMin and cMax by
//               DataGen obj pgdi.
//              -Assign root VirtualCtrNode of tree to pvcnTrav and increment
//               temp variable counter.
//              -Check in pvcnTrav's _cStreams > 0, if yes, then increment the
//               counter by that number.
//              -if counter is greater or equal cRandom , check return tha
//               desired VirtualStmNode of the root.
//              -Else start a forever loop till a valid node is found
//                 -While pvcnTrav's _pvcnChild is not NULL and counter is less
//                  than cRandomStg, loop.  In the loop, check if pvcnTrav's
//                  > 0, if yes, update the counter.
//                 -if counter is greater or equal to cRandomStg, then break
//                  out of the forever loop
//                 -Else while pvcnTrav's _pvcnSister is eual to NULL, loop
//                  assinging _pvcnParent to pvcnTrav
//                 -Assign pvcnTrav's _pvcnSister to pvcnTrav .  If pvcnTrav's
//                  _cStreams is > 0, then update the counter and go back to
//                  start of forever loop
//              -With parent VirtualCtrNode found, find the number of which
//               child VirtualStmNode of it to return by doing cRandomStm
//               minus (counter minus pvcnTrav's _cStreams count).  Assign this
//               calculated value to cChildStm.
//              -Assign pvsnTrav the value of pvcnTrav's _pvsnStream and decre
//               ment the cChildStm variable.
//              -While cChildStm != zer0 and NULL is not equal to pvsnTrav,loop
//                  -Assign pvsnTrav's _pvsnSister to pvsnTrav.
//                  -Decrement cChildStm and go back to top of loop.
//               -Return the parent VirtualCtrNode and random VirtualStmNode
//                to the caller.
//--------------------------------------------------------------------------

HRESULT GetVirtualStmNodeForTest(
    VirtualCtrNode  *pVirtualCtrNode,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeParent,
    VirtualStmNode  **ppVirtualStmNodeForTest)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   NULL;
    VirtualStmNode  *pvsnTrav   =   NULL;
    USHORT          usErr       =   0;
    ULONG           counter     =   0;
    ULONG           cRandomStm  =   0;
    ULONG           cChildStm   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetVirtualStmNodeForTest"));

    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode ) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTROUT(ppVirtualStmNodeForTest, PVSTMNODE) ;
    DH_VDATEPTROUT(ppVirtualCtrNodeParent, PVCTRNODE) ;

    // The pointer to parent pVirtualCtrNodeParent shouldn't be NULL.
    // cChildStmToFetch can be zero, in which case first stream is
    // is returned.

    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppVirtualStmNodeForTest);
    DH_ASSERT(NULL != ppVirtualCtrNodeParent);

    // Sanity check: cMin must be <= cMax or cMax must be 0

    DH_ASSERT(cMin <= cMax || 0 == cMax);

    // if cMax is 0, find the number of stm nodes under the root

    if(S_OK == hr && cMax == 0)
    {
        hr = EnumerateInMemoryDocFile(pVirtualCtrNode, NULL, &cMax);

        if (S_OK == hr && cMax < cMin)
        {
            hr = E_UNEXPECTED;
        }
    }

    // Pick up a random number

    if(S_OK == hr)
    {
        // Initialize out parameter
        *ppVirtualCtrNodeParent = NULL;
        *ppVirtualStmNodeForTest = NULL;

        usErr = pdgi->Generate(&cRandomStm, cMin, cMax);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualCtrNode;
//        pvcnTrav = pVirtualDF->GetVirtualDFRoot();
//        DH_ASSERT(NULL != pvcnTrav);

        if(0 != pvcnTrav->GetVirtualCtrNodeStreamCount())
        {
            counter = counter + pvcnTrav->GetVirtualCtrNodeStreamCount();
        }
    }

    if(counter < cRandomStm)
    {
        for(;;)
        {
            DH_ASSERT(NULL != pvcnTrav);
            while((pvcnTrav->GetFirstChildVirtualCtrNode() != NULL) &&
                  (counter < cRandomStm))
            {
                pvcnTrav = pvcnTrav->GetFirstChildVirtualCtrNode();

                if(0 != pvcnTrav->GetVirtualCtrNodeStreamCount())
                {
                   counter = counter + pvcnTrav->GetVirtualCtrNodeStreamCount();
                }
            }

            if(counter >= cRandomStm)
            {
                break;
            }

            while(NULL == pvcnTrav->GetFirstSisterVirtualCtrNode())
            {
                pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
                DH_ASSERT(NULL != pvcnTrav);
            }

            DH_ASSERT(NULL != pvcnTrav->GetFirstSisterVirtualCtrNode());
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();

            if(0 != pvcnTrav->GetVirtualCtrNodeStreamCount())
            {
                counter = counter + pvcnTrav->GetVirtualCtrNodeStreamCount();
            }
        }
    }

    if(S_OK == hr)
    {
        // Calculate which child stream needs to be picked up
        cChildStm = cRandomStm -
                    (counter - pvcnTrav->GetVirtualCtrNodeStreamCount());

        pvsnTrav = pvcnTrav->GetFirstChildVirtualStmNode();
        cChildStm--;

        DH_ASSERT(NULL != pvsnTrav);

        while((0 != cChildStm) && (NULL != pvsnTrav))
        {
           pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
           cChildStm--;
        }

        // Return the out parameter

        *ppVirtualCtrNodeParent = pvcnTrav;
        *ppVirtualStmNodeForTest = pvsnTrav;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualStmNodeForTest
//
//  Synopsis:   Gets a VirtualStmNode for doing tests on it.
//
//  Arguments:  [pVirtualDF] - Pointer to VirtualDF tree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualStmNodes in VirtualDF tree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualStmNodes in VirtualDF tree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeParent] - returned parent VirtualCtrNode
//              [ppVirtualStmNodeForTest] - returned VirtualStmNode
//
//  Returns:    HRESULT
//
//  History:    12-Mar-97  MikeW      Created
//
//  Notes:      Just thunk to the version of the routine that takes a
//              VirtualCtrNode instead of a VirtualDF.
//--------------------------------------------------------------------------

HRESULT GetVirtualStmNodeForTest(
    VirtualDF       *pVirtualDF,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeParent,
    VirtualStmNode  **ppVirtualStmNodeForTest)
{
    DH_VDATEPTRIN(pVirtualDF, *pVirtualDF);

    //
    // Most of the parameter checking is left to the main version of this
    // routine
    //

    return GetVirtualStmNodeForTest(
                    pVirtualDF->GetVirtualDFRoot(),
                    pdgi,
                    cMin,
                    cMax,
                    ppVirtualCtrNodeParent,
                    ppVirtualStmNodeForTest);
}

//+-------------------------------------------------------------------------
//  Function:   DestroyStorage
//
//  Synopsis:   Destorys a VirtualCtrNode and associated IStorage.
//
//  Arguments:  [pVirtualDF] - pointer to VirtualDocFile tree.
//              [pVirtualCtrNode] - Pointer to VirtualCtrNode
//
//  Returns:    HRESULT
//
//  History:    29-Apr-96  NarindK    Created.
//
//  Notes:      Call VirtualCtrNode::Destroy to destroy the node.
//              Call VirtualDF::DeleteVirtualDocFileTree to delete the corres-
//              ponding VirtualCtrNode from the VirtualDF tree.
//--------------------------------------------------------------------------

HRESULT DestroyStorage(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pVirtualCtrNode)
{
    HRESULT     hr  =   S_OK;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DestroyStorage"));

    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode) ;

    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != pVirtualDF);

    if(S_OK == hr)
    {
        hr = pVirtualCtrNode->Destroy();

        DH_HRCHECK(hr, TEXT("pVirtualCtrNode->Destroy()")) ;
    }

    if(S_OK == hr)
    {
        // Now adjust the VirtualDocFile tree.  This will decrease the
        // _cChildren variable value of the parent VrtualCtrNode too.

        hr = pVirtualDF->DeleteVirtualDocFileTree(pVirtualCtrNode);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   DestroyStream
//
//  Synopsis:   Destorys a VirtualStmNode and associated IStream.
//
//  Arguments:  [pVirtualDF] - pointer to VirtualDF tree
//              [pVirtualStmNode] - Pointer to VirtualStmNode to be destoryed
//
//  Returns:    HRESULT
//
//  History:    9-July-96  NarindK    Created.
//
//  Notes:      Call VirtualStmNode::Destroy to destroy the IStream.
//              Call VirtualDF::DeleteVirtualCtrNodeStreamNode to delete corres-
//              ponding VirtualCtrNode from the VirtualDF tree.
//--------------------------------------------------------------------------

HRESULT DestroyStream(
    VirtualDF       *pVirtualDF,
    VirtualStmNode  *pVirtualStmNode)
{
    HRESULT         hr              =   S_OK;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DestroyStream"));

    DH_VDATEPTRIN(pVirtualStmNode, VirtualStmNode) ;
    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;

    DH_ASSERT(NULL != pVirtualDF);
    DH_ASSERT(NULL != pVirtualStmNode);

    if(S_OK == hr)
    {
        hr = pVirtualStmNode->Destroy();

        DH_HRCHECK(hr, TEXT("pVirtualStmNode->Destroy()")) ;
    }

    if(S_OK == hr)
    {
        // Now adjust the VirtualDocFile tree.  This will decrease the
        // _cStreams variable value of the parent VirtualCtrNode too.

        hr = pVirtualDF->DeleteVirtualCtrNodeStreamNode(pVirtualStmNode);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualCtrNodeStreamNode")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   AddStorage
//
//  Synopsis:   Adds a VirtualCtrNode and associated IStorage.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to existing VirtualCtrNode
//              [ppNewVirtualCtrNode] _ Returned new VirtualCtrNode
//              [pName] - Name of new storage
//              [grfMode] - Mode in which new storage is to be opened
//
//  Returns:    HRESULT
//
//  History:    29-Apr-96  NarindK    Created.
//
//  Notes:      - Creates a simple new VirtualCtrNode and initializes it with
//                name passed in.  Its _cChildren and _cStreams are initialized
//                to zero.
//              - Append the newly created node pvcnNew to its parent node
//                pVirtualCtrNode.  This would be appended as _pvcnChild or
//                as _pvcnSister of existing old sister as the case might be.
//              - Increase the parent's pVirtualCtrNode's _cChildren variable
//                indicating the new VirtualCtrNode added.
//              - Create a disk IStorage corresponding to this VirtualCtrNode
//                based on passed in grfmode.
//              - If CreateStorage call returns STG_S_CONVERTED, it indicates
//                that an existing stream with specified name was replaced witho
//                a new storage object containing a single stream called 
//                CONTENTS.  If so, adjust the VirtualDF tree.
//              - If successful, copy pvcnNew into out parameter *ppNewVirtual
//                CtrNode, else delete the VirtualCtrNode allocated earlier.
//              Note: Please note that the CRC for node(s) created is not set.
//--------------------------------------------------------------------------

HRESULT AddStorage(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pVirtualCtrNode,
    LPTSTR          pName,
    DWORD           grfMode,
    VirtualCtrNode  **ppNewVirtualCtrNode)
{
    HRESULT         hr          = S_OK;
    HRESULT         hrTemp      = S_OK;
    VirtualCtrNode  *pvcnNew    = NULL;
    VirtualStmNode  *pvsnOld    = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::AddStorage"));

    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode) ;
    DH_VDATEPTROUT(ppNewVirtualCtrNode, PVCTRNODE) ;
    DH_VDATESTRINGPTR(pName);

    DH_ASSERT(NULL != pVirtualDF);
    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppNewVirtualCtrNode);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppNewVirtualCtrNode = NULL;

        // Allocate and Initialize new VirtualCtrNode

        hr = GenVirtualCtrNode(pName, &pvcnNew);

        DH_HRCHECK(hr, TEXT("GenVirtualCtrNode")) ;
    }

    // Append new VirtualCtr Node

    if(S_OK == hr)
    {
        if(0 == pVirtualCtrNode->GetVirtualCtrNodeChildrenCount())
        {
            hr = pVirtualCtrNode->AppendChildCtr(pvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendChildCtr")) ;
        }
        else
        {
            hr=pVirtualCtrNode->GetFirstChildVirtualCtrNode()->AppendSisterCtr(
                    pvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendSisterCtr")) ;
        }
    }

    if(S_OK == hr)
    {
        // Increment the _cChildren variable of parent VirtualCtrNode

        pVirtualCtrNode->IncreaseChildrenStgCount();

    }

    // Call VirtualCtrNode::Create to create a corresponding Storage on disk.

    if(S_OK == hr)
    {
        hr = pvcnNew->Create(
                grfMode,
                0,
                0);

         DH_HRCHECK(hr, TEXT("VirtualCtrNode::Create")) ;
    }

    // Fill in the output parameter

    if((S_OK == hr) || (STG_S_CONVERTED == hr))
    {
        if(STG_S_CONVERTED == hr)
        {
            VirtualStmNode  *pvsnNew    =   NULL;
            ULONG           cb          =   0;

            // Remember hr

            hrTemp = hr;

            // Delete the VirtualStmNode with stream that is converted to this
            // storage.  First find the corresponding VirtualStmNode with same
            // name.
            
            pvsnOld = 
              pvcnNew->GetParentVirtualCtrNode()->GetFirstChildVirtualStmNode();
            
            DH_ASSERT(NULL != pvsnOld);

            while((NULL != pvsnOld) &&
                  (0 != _tcscmp(pName, pvsnOld->GetVirtualStmNodeName())))
            {
                pvsnOld = pvsnOld->GetFirstSisterVirtualStmNode();
            }

            // Delete the old VirtualStmNode

            if((NULL != pvsnOld) &&
               (0 == _tcscmp(pName, pvsnOld->GetVirtualStmNodeName())))
            {
                // Remember size of VirtualStmNode
                cb = pvsnOld->GetVirtualStmNodeSize();

                hr = pVirtualDF->DeleteVirtualCtrNodeStreamNode(pvsnOld);
            }
            else
            {
                hr = E_FAIL;
            }

            // Generate a new VirtualStmNode for CONTENTS stream generated

            if(S_OK == hr)
            {
                hr = GenVirtualStmNode(TEXT("CONTENTS"), cb, &pvsnNew); 

                if(S_OK == hr)
                {
                    hr = pvcnNew->AppendFirstChildStm(pvsnNew);
                } 

                if(S_OK == hr)
                {
                    pvcnNew->IncreaseChildrenStmCount();
                }
            }
        }

        if(S_OK == hr)
        {
            *ppNewVirtualCtrNode = pvcnNew;

            if(STG_S_CONVERTED == hrTemp)
            {
                hr = hrTemp;
            }
        }
    }
    else
    {
        // Storage wasn't created successfully, delete the VirtualCtrNode   
        // being created. Adjust the VirtualDocFile tree.  This will decrease 
        // _cChildren variable value of the parent VirtualCtrNode too.

        hrTemp = pVirtualDF->DeleteVirtualDocFileTree(pvcnNew);

        DH_HRCHECK(hrTemp, TEXT("pVirtualDF->DeleteVirtualFileDocTree")) ;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   AddStream
//
//  Synopsis:   Adds a VirtualStmNode & associated IStream to a VirtualCtrNode.
//              Set the size of stream if cbSize is nonzero, but doesn't write 
//              into it.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to existing VirtualCtrNode
//              [ppNewVirtualStmNode] - Returned new VirtualStmNode
//              [pName] - Name of new stream
//              [grfMode] - Mode of new stream
//              [cbSize] - Size of new stream
//
//  Returns:    HRESULT
//
//  History:    29-Apr-96  NarindK    Created.
//
//  Notes:      - Creates a simple new VirtualStmNode and initializes it with
//                name & cbSize passed in.
//              - Append the newly created node pvsnNew to its parent node
//                pVirtualCtrNode.  This would be appended as _pvsnStream or
//                as _pvsnSister of existing old sister as the case might be.
//              - Increase the parent's pVirtualCtrNode's _cStreams variable
//                indicating the new VirtualStmNode added.
//              - Create a disk IStream corresponding to this VirtualStmNode.
//                based on passed in grfmode.
//              - If cbSize is non zero, do SetSize on stream.
//              - If successful, copy pvsnNew into out parameter *ppNewVirtual
//                StmNode, else delete the VirtualStmNode allocated earlier.
//              Note: Please note that the CRC for node created is not set.
//--------------------------------------------------------------------------

HRESULT AddStream(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pVirtualCtrNode,
    LPTSTR          pName,
    ULONG           cbSize,
    DWORD           grfMode,
    VirtualStmNode  **ppNewVirtualStmNode)
{
    HRESULT         hr          = S_OK;
    HRESULT         hrTemp      = S_OK;
    VirtualStmNode  *pvsnNew    = NULL;
    ULARGE_INTEGER  uli;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::AddStream"));

    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode) ;
    DH_VDATEPTROUT(ppNewVirtualStmNode, PVSTMNODE) ;
    DH_VDATESTRINGPTR(pName);

    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppNewVirtualStmNode);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppNewVirtualStmNode = NULL;

        // Allocate and Initialize new VirtualStmNode

        hr = GenVirtualStmNode(pName, cbSize, &pvsnNew);

        DH_HRCHECK(hr, TEXT("GenVirtualStmNode")) ;
    }

    // Append new VirtualStm Node

    if(S_OK == hr)
    {
        if(0 == pVirtualCtrNode->GetVirtualCtrNodeStreamCount())
        {
            hr = pVirtualCtrNode->AppendFirstChildStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendFirstChildStm")) ;
        }
        else
        {
            hr=pVirtualCtrNode->GetFirstChildVirtualStmNode()->AppendSisterStm(
                    pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::AppendSisterStm")) ;
        }
    }

    if(S_OK == hr)
    {
        // Increment the _cStreams variable of parent VirtualCtrNode

        pVirtualCtrNode->IncreaseChildrenStmCount();

    }

    // Call VirtualStmNode::Create to create a corresponding Stream on disk.

    if(S_OK == hr)
    {
        hr = pvsnNew->Create(
                grfMode,
                0,
                0);

         DH_HRCHECK(hr, TEXT("VirtualStmNode::Create")) ;
    }

    // Call VirtualStmNode::SetSize to set size of stream.

    if((S_OK == hr) && (0 != cbSize))
    {
        ULISet32(uli, cbSize);

        hr = pvsnNew->SetSize(uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize")) ;
    }

    // Fill in the output parameter

    if(S_OK == hr)
    {
        *ppNewVirtualStmNode = pvsnNew;
    }
    else
    {
        // Stream wasn't created successfully, so delete the VirtualStmNode.
        // Adjust the VirtualDocFile tree.  This will decrease the
        // _cStreams variable value of the parent VirtualCtrNode too.

        hrTemp = pVirtualDF->DeleteVirtualCtrNodeStreamNode(pvsnNew);

        DH_HRCHECK(
            hrTemp, 
            TEXT("pVirtualDF->DeleteVirtualCtrNodeStreamNode")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForName
//
//  Synopsis:   Calulates CRC for a IStorage/IStream's name.
//
//  Arguments:  [ptcsName]  - pointer to name of stream
//              [pdwCRCForName] - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      This is a common function used by other CRC utilities function
//              and also called directly is virtdf.cxx to calculate in memory
//              CRC for VirtualCtrNode. Since for VirtualCtrNodes/IStorages,
//              we CRC only name, we could use this function to calculate CRC.
//              - Assign passed in name to a temp. variable ptszTemp.
//              - Loop while *ptszTemp is not NULL, and call CRC_CALC macro
//                to generate CRC for the name.
//--------------------------------------------------------------------------

HRESULT CalculateCRCForName(
    const LPTSTR    ptcsName,
    DWORD           *pdwCRCForName)
{
    HRESULT hr          =   S_OK;
    LPTSTR  ptszTemp    =   NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateCRCForName"));

    DH_VDATESTRINGPTR(ptcsName) ;
    DH_VDATEPTROUT(pdwCRCForName, DWORD) ;

    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != pdwCRCForName);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *pdwCRCForName = CRC_PRECONDITION;

        ptszTemp = ptcsName;

        while(NULL != *ptszTemp)
        {
            CRC_CALC(*pdwCRCForName, (BYTE)*ptszTemp++);
        }
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDataBuffer
//
//  Synopsis:   Calulates CRC for a given data Buffer.
//
//  Arguments:  [ptszBuffer]  - pointer to data buffer.
//              [culBufferSize]  - size of data buffer
//              [pdwCRCForName] - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      This is a common function used by other CRC utilities function
//              - Assign pointer to passed in buffer to pByteBuffer.
//              - Loop for culBufferSize, and call CRC_CALC macro
//                to generate CRC for the data buffer.
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDataBuffer(
    const LPTSTR    ptszBuffer,
    ULONG           culBufferSize,
    DWORD           *pdwCRCForDataBuffer)
{
    HRESULT     hr          =   S_OK;
    LPBYTE      pByteBuffer =   NULL;
    ULONG       i           =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateCRCForDataBuffer"));

    DH_VDATEPTRIN(ptszBuffer, TCHAR);
    DH_VDATEPTROUT(pdwCRCForDataBuffer, DWORD) ;

    DH_ASSERT(NULL != ptszBuffer);
    DH_ASSERT(NULL != pdwCRCForDataBuffer);

    // calculate the CRC for data of stream.

    if(S_OK == hr)
    {
        // Initialize out parameter

        *pdwCRCForDataBuffer = CRC_PRECONDITION;

        pByteBuffer = (BYTE *)ptszBuffer;

        if ( S_OK == hr )
        {
            for (i=0; i < culBufferSize; i++)
            {
                CRC_CALC(*pdwCRCForDataBuffer, pByteBuffer[i]);
            }
        }
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateInMemoryCRCForStg
//
//  Synopsis:   Calulate in memory CRC for a Stroage name
//
//  Arguments:  [pvsn]  - Pointer to VirtualCtrNode.
//              [pdwCRC] - pointer to computed CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      For IStorages, only name is CRC'd.
//              - Call CalculateCRCForName to calculate CRC
//
//--------------------------------------------------------------------------

HRESULT CalculateInMemoryCRCForStg(
    VirtualCtrNode  *pvcn,
    DWORD           *pdwCRC)
{
    HRESULT     hr          = S_OK;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB,_TEXT("CalculateInMemoryCRCForStg"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdwCRC, DWORD) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdwCRC);

    // Now calulate the CRC for name of storage.

    if ( S_OK == hr )
    {
        // Initialize out parameter

        *pdwCRC = CRC_PRECONDITION;

        hr = CalculateCRCForName(pvcn->GetVirtualCtrNodeName(), pdwCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateInMemoryCRCForStm
//
//  Synopsis:   Calulates CRC for a IStream's data and name.
//
//  Arguments:  [pvsn]  - Pointer to VirtualStmNode.
//              [ptszBuffer] - Pointer to buffer used to write into stream
//              [culBufferSize] - Pointer to buffer size used to calculate CRC
//              [pdwCRC] - pointer to computed CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      For IStreams, both name and data of stream are CRC'd.  Ensure
//              that stream is opened before this function is called.
//
//              This function is presently called directly in virtdf.cxx to
//              calculate in memory CRC for VirtualStmNode. Since for  the
//              VirtualStmNodes/IStreams, we CRC name and data, we could use
//              this function to calculate CRC if we pass it the stream name,
//              buffer, size of buffer as input parameters.
//              - Call CalculateCRCForDataBuffer to calculate dwCRCForData.
//              - Call CalculateCRCForName to calculate dwCRCForName.
//              - Compute the total CRC based on above two CRC's.
//
//--------------------------------------------------------------------------

HRESULT CalculateInMemoryCRCForStm(
    VirtualStmNode  *pvsn,
    const LPTSTR    ptszBuffer,
    ULONG           culBufferSize,
    DWCRCSTM        *pdwCRC)
{
    HRESULT     hr          = S_OK;
    DWORD       dwCRCForData= CRC_PRECONDITION;
    DWORD       dwCRCForName= CRC_PRECONDITION;
    ULONG       i           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB,_TEXT("CalculateInMemoryCRCForStm"));

    DH_VDATEPTRIN(pvsn, VirtualStmNode) ;
    DH_VDATEPTROUT(pdwCRC, DWORD) ;
    DH_VDATEPTRIN(ptszBuffer, TCHAR);

    DH_ASSERT(NULL != pvsn);
    DH_ASSERT(NULL != ptszBuffer);
    DH_ASSERT(NULL != pdwCRC);

    if(S_OK == hr)
    {
        // Initialize CRC values to CRC_PRECONDITION

        pdwCRC->dwCRCName = pdwCRC->dwCRCData = pdwCRC->dwCRCSum = CRC_PRECONDITION;
    }

    // First calculate the CRC for data of stream.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(ptszBuffer, culBufferSize,&dwCRCForData);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer")) ;

    }

    // Now calulate the CRC for name of stream.

    if ( S_OK == hr )
    {
        hr = CalculateCRCForName(pvsn->GetVirtualStmNodeName(), &dwCRCForName);

        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    // Compute the total CRC value based on above two CRC's and record 
    // individual CRC's for name and data

    if ( S_OK == hr )
    {
        pdwCRC->dwCRCData = dwCRCForData;
        pdwCRC->dwCRCName = dwCRCForName;
        MUNGECRC(pdwCRC->dwCRCSum,dwCRCForData);
        MUNGECRC(pdwCRC->dwCRCSum,dwCRCForName);
    }

    return hr;
}



//+-------------------------------------------------------------------------
//  Function:   CalculateStreamDataCRC
//
//  Synopsis:   Calculates the CRC of the stream data, 
//				using the IStream given (independent of virtualdf stuff)
//
//  Arguments:  [pStm]        - the Stream
//              [dwSize]      - the size if known, or zero => call Stat
//              [pdwCRC]      - pointer to data CRC
//              [dwChunkSize] - if >0 the stream will be read at chunks
//                              of this size.
//
//  Returns:    HRESULT
//
//  History:    02-Apr-98  georgis    Created.
//
//--------------------------------------------------------------------------

HRESULT CalculateStreamDataCRC(IStream *pStm,
                               DWORD dwSize,
                               DWORD *pdwCRC,
                               DWORD dwChunkSize)
{
    HRESULT     hr=S_OK;
    STATSTG     statstg;
    DWORD       dwBufferSize=0;
    BYTE        *pBuffer=NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateStreamDataCRC"));

    DH_VDATEPTRIN(pStm, IStream);
    DH_VDATEPTROUT(pdwCRC, DWORD);
	*pdwCRC=0;	// invalid CRC

    // Ask for size if unknown (zero passed)
    if (0==dwSize)
    {
        hr = pStm->Stat(&statstg, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("IStorage::Stat"));
        dwSize=statstg.cbSize.LowPart; //BIGBUG: assume LowPart only
    }

    // Allocate the buffer
    if (S_OK == hr)
    {
        if (dwChunkSize>0)
        {
            dwBufferSize=dwChunkSize;
        }
        else
        {
            dwBufferSize=dwSize;
        }

        pBuffer = new BYTE[dwBufferSize];
        if (NULL==pBuffer)
        {
            hr=E_OUTOFMEMORY;
            DH_HRCHECK(hr,TEXT("new"));
        }
    }


    // Reset the stream
    if (S_OK== hr)
    { 
        LARGE_INTEGER li;

        LISet32(li,0L);
        hr=pStm->Seek(li,STREAM_SEEK_SET,NULL);
        DH_HRCHECK(hr,TEXT("Seek"));
    };

    
    // Do the actual read, calculate the CRC
    if (S_OK == hr)
    {
        DWORD dwTotalRead=0;
        DWORD dwRead=0;
        register DWORD dwCRC=CRC_PRECONDITION;
        
        while ((S_OK==hr)&&(dwTotalRead < dwSize))
        {
            hr=pStm->Read(pBuffer, dwBufferSize, &dwRead);
            DH_HRCHECK(hr,TEXT("Read"));
            dwTotalRead+=dwRead;

            if (S_OK==hr)
            {
                for (register int i=0; i<dwRead; i++)
                {
                    CRC_CALC(dwCRC,pBuffer[i]);
                }
            };
        }
        *pdwCRC=dwCRC;
    }

    if (NULL!=pBuffer)
    {
        delete pBuffer;
    };

    return hr;
}
                

//+-------------------------------------------------------------------------
//  Function:   ReadAndCalculateDiskCRCForStm
//
//  Synopsis:   Calulates CRC for a IStream's name and data.
//
//  Arguments:  [pvsn]  - pointer to VirtualStmNode
//              [pdwCRC] - pointer to CRC 
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//              2-Apr-98  georgis    use VirtualStmNode::UpdateCRC
//
//  Notes:      VirtualStmNode::UpdateCRC() actually obsoletes this function,
//              It remains for compatibility with the old tests                               
//
//              BUGBUG: all the DWCRCSTM structures are called dw* and 
//              all pointers to them pdw* . We should fix this
//
//--------------------------------------------------------------------------

HRESULT ReadAndCalculateDiskCRCForStm(
    VirtualStmNode  *pvsn,
    DWCRCSTM        *pdwCRC,
    DWORD           dwChunkSize)

{
    HRESULT     hr          = S_OK;
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ReadAndCalculateDiskCRCForStm"));

    DH_VDATEPTRIN(pvsn, VirtualStmNode) ;
    DH_VDATEPTROUT(pdwCRC, DWCRCSTM) ;

    hr=pvsn->UpdateCRC(dwChunkSize);
    DH_HRCHECK(hr, TEXT("pvsn->UpdateCRC")) ;

    pdwCRC->dwCRCSum =pvsn->GetVirtualStmNodeCRC();
    pdwCRC->dwCRCName=pvsn->GetVirtualStmNodeCRCName();
    pdwCRC->dwCRCData=pvsn->GetVirtualStmNodeCRCData();
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   CalculateDiskCRCForStg
//
//  Synopsis:   Calulates CRC for a IStrorage's name.
//
//  Arguments:  [pvcn]  - pointer to VirtualCtrNode
//              [pdwCRCForName] - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      For IStorages, only name is CRC'd.
//              -Call VirtualCtrNode::Stat to get information about storage.
//              -Call CalculateCRCForName to calculate CRC for name of the
//               storage obtained from STATSTG structure.
//--------------------------------------------------------------------------

HRESULT CalculateDiskCRCForStg(
    VirtualCtrNode  *pvcn,
    DWORD           *pdwCRCForName)
{
    HRESULT     hr          =   S_OK;
    LPMALLOC    pMalloc     =   NULL;
    LPTSTR      ptszName    =   NULL;
    STATSTG     statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateDiskCRCForStg"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdwCRCForName, DWORD) ;

    // For IStorages, only name are CRC'd.

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdwCRCForName);

    // Initialization
    statStg.pwcsName = NULL;

    // Get the statistics about ths opened stream

    if(S_OK == hr)
    {
        // Initialize out parameter

        *pdwCRCForName = CRC_PRECONDITION;

        hr = pvcn->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
    }

    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if(S_OK == hr)
    {
       //Convert WCHAR to TCHAR

       hr = OleStringToTString(statStg.pwcsName, &ptszName);

       DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
    }

    if((S_OK == hr) && (NULL != ptszName))
    {
        hr = CalculateCRCForName(ptszName, pdwCRCForName);

        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    // Clean up

    if ( NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    if(NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   EnumerateInMemoryDocFile
//
//  Synopsis:   Enumerates a in memory docfile.
//
//  Arguments:  [pvcn]       - pointer to VirtualCtrNode
//              [pdwNumStg]  - pointer to number of Storages in doc hierarchy.
//              [pdwNumStm]  - pointer to number of streams in doc hierarchy
//
//  Returns:    HRESULT
//
//  History:    3-June-96  NarindK    Created.
//
//  Notes:      pdwNumStg, pdwNumStm may be NULL if user is not interested in
//              these values to be returned back. Includes the passed in pvcn
//              in pdwnumStg count.
//              -Count the passed in storage pvcn as 1 in pNumStg count.
//              -Check if pvcn's _pvsnStream is NULL or not by calling the
//               GetFirstChildVirtualStmNode() function, assign to pvsnTrav var
//              -If it is not NULL,loop till pvsnTrav is not NULL.
//                  -Increment pNumStm for stream found for this pvcn.
//                  -Assign pvcnTrav->_pvsnSister (GetFirstSisterVirtualStmNode)
//                   to pvsnTrav.
//                  -Go back to top of loop and repeat.
//              -Check if pvcn's _pvcnChild is NULL or not by calling the func
//               pvcn->GetFirstChildVirtualCtrNode() and assign it to pvcnTrav.
//              -Loop while pvcnTrav is not NULL and hr is S_OK.
//                  -Make a recursive call to self (EnumerateInMemoryDocFile)
//                  -Assign pvcnTrav->_pvcnSister to pvcnTrav. (Got thru'
//                   GetFirstSisterVirtualCtrNode function).
//                  -Update pNumStg and pNumStm based on above call, where out
//                   parameters are cChildStg and cChildStm.
//                  -Reinitialize these variables and go back to top of loop.
//--------------------------------------------------------------------------

HRESULT EnumerateInMemoryDocFile(
    VirtualCtrNode  *pvcn,
    ULONG           *pNumStg,
    ULONG           *pNumStm )
{
    HRESULT         hr              =   S_OK;
    ULONG           cChildStg       =   0;
    ULONG           cChildStm       =   0;
    VirtualCtrNode  *pvcnTrav       =   NULL;
    VirtualStmNode  *pvsnTrav       =   NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("EnumerateInMemoryDocFile"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    if(NULL != pNumStg)
    {
        DH_VDATEPTROUT(pNumStg, ULONG) ;
    }
    if(NULL != pNumStm)
    {
        DH_VDATEPTROUT(pNumStm, ULONG) ;
    }

    DH_ASSERT(NULL != pvcn);

    if(S_OK == hr)
    {
        if(NULL != pNumStg)
        {
            // Count the storage passed in.

            *pNumStg = 1;
        }

        if(NULL != pNumStm)
        {
            *pNumStm = 0;
        }

        pvsnTrav = pvcn->GetFirstChildVirtualStmNode();

        // Count number of VirtualStmNodes that this VirtualCtrNode has.

        while(NULL != pvsnTrav)
        {
            if(NULL != pNumStm)
            {
                (*pNumStm)++;
            }
            pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
        }

        // Next recurse into the child VirtualCtrNodes of this VirtualCtrNode

        pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();
        while((NULL != pvcnTrav) && (S_OK == hr))
        {
            hr = EnumerateInMemoryDocFile(
                    pvcnTrav,
                    &cChildStg,
                    &cChildStm);

            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();

            // Update number of nodes on basis of child nodes as found

            if((NULL != pNumStg) && (0 != cChildStg))
            {
                *pNumStg = *pNumStg + cChildStg;
            }

            if((NULL != pNumStm) && (0 != cChildStm))
            {
                *pNumStm = *pNumStm + cChildStm;
            }

            // Reinitialize variables
            cChildStg = 0;
            cChildStm = 0;
        }
    }

    // flatfile only: if we're at the root, increment stream counter to include 
    //                the default flatfile stream (CONTENTS)
    if(StorageIsFlat() && NULL == pvcn->GetParentVirtualCtrNode())
    {
        (*pNumStm)++;
    }

    return  hr;
}

//-------------------------------------------------------------------------
//  Function:   OpenRandomVirtualCtrNodeStg
//
//  Synopsis:   Opens a VirtualCtrNode's IStorage.  This traverses through all
//              the parents of the VirtualCtrNode and opens them and then
//              opens up the required storage. Please ensure that root IStorage
//              is open before this call.
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode whose IStorage has to
//                         opened.
//              [grfMode] - Mode to open the IStorage. (Note: all the parent
//                          IStorages would be opened in that mode too.)
//
//  Returns:    HRESULT
//
//  History:    6-June-96  NarindK    Created.
//
//  Notes:      This function doesn't reopen the root,  which is already
//              open since we need to have a valid function.  If VirtualCtrNode //              node whose storage has to be opened is same as Root, then
//              functions returns w/o any error.  Call CloseRandomVirtualCtr
//              NodeStg function to close the storages opened by this call.
//
//              -Initilize the counter to 1.
//              -Assign pvcn to pvcnTrav and loop till pvcnTrav->_pvcnParent
//               (obtained thru GetParentVirtualCtrNode() is non NULL)
//                  -Increment counter.
//                  -Assign pvcnTrav->_pvcnParent to pvcnTrav
//                  -Go back to top of loop and repeat.
//              -Check if counter is 1 or not.  If 1, then the node to be opened//               is the root itsef that was opened prior to this call. So just
//               return without any error.
//             -If counter>1, then allocate an array of VirtualCtrNode pointers
//              of size counter and continue.
//             -Assign passed in node ovcn to temp var pvcnTrav. And fill up
//              the above allocated arrays starting from the passed in node
//              way upto root.
//             -Increment the conter since root is already open, then in a
//              do-while loop, open up all the nodes till we reach the passed
//              in node. Pl. note that the nodes are opened as per grfMode that
//              was passed in to us.
//             -Delete the array of pointers.
//--------------------------------------------------------------------------

HRESULT OpenRandomVirtualCtrNodeStg(
    VirtualCtrNode  *pvcn,
    DWORD           grfMode)
{
    HRESULT         hr              =   S_OK;
    ULONG           counter         =   1;
    VirtualCtrNode  *pvcnTrav       =   NULL;
    PVCTRNODE       *pvcnArrayPtr   =   NULL;
    BOOL            fIsRoot         =   FALSE;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("OpenRandomVirtualCtrNodeStg"));

    DH_VDATEPTRIN(pvcn, PVCTRNODE) ;

    DH_ASSERT(NULL != pvcn);

    if(S_OK == hr)
    {
        // Count number of parents till the root.

        pvcnTrav = pvcn;
        while(NULL != pvcnTrav->GetParentVirtualCtrNode())
        {
            counter++;
            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }

        if( 1 == counter)
        {
            fIsRoot = TRUE;
        }
        else
        {
            // Allocate an array of desired size
            pvcnArrayPtr = new PVCTRNODE [counter];
            if(NULL == pvcnArrayPtr)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if((S_OK == hr) && (FALSE == fIsRoot))
    {
        // Fill up the array starting from node itself, with parent chain
        // upto including root.

        pvcnTrav = pvcn;
        pvcnArrayPtr[--counter] = pvcn;

        while(NULL != pvcnTrav->GetParentVirtualCtrNode())
        {
            pvcnArrayPtr[--counter] = pvcnTrav->GetParentVirtualCtrNode();
            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }

        // Root is already open, so open the other parent nodes down to random
        // test node.

        counter++;

        do
        {
            if(NULL != pvcnArrayPtr[counter]->GetIStoragePointer())
            {
                // If the storage is already open, then do an addref on it 
                // rather than trying to open it since all internal storages
                // are always opened with STGM_SHARE_EXCLUSIVE mode (OLE).

                hr = pvcnArrayPtr[counter]->AddRefCount();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount")) ;
            }
            else
            {
                hr = pvcnArrayPtr[counter]->Open(
                        NULL,
                        grfMode,
                        NULL,
                        0);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
            }

        } while(pvcnArrayPtr[counter++] != pvcn);
    }

    // Cleanup

    if(NULL != pvcnArrayPtr)
    {
        delete []pvcnArrayPtr;
        pvcnArrayPtr = NULL;
    }

    return  hr;
}

//-------------------------------------------------------------------------
//  Function:   CloseRandomVirtualCtrNodeStg
//
//  Synopsis:   Close a VirtualCtrNode's IStorage and all other IStorages that
//              were open in prior call to OpenRandomVirtualCtrNodeStg.
//              This traverses through all the parents of the VirtualCtrNode
//              and closes them excluding the root IStorage, which was not 
//              reopened during OpenRandomVirtualCtrNodeStg call.
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode whose IStorage has to
//                         closed.
//
//  Returns:    HRESULT
//
//  History:    18-June-96  NarindK    Created.
//
//  Notes:
//--------------------------------------------------------------------------

HRESULT CloseRandomVirtualCtrNodeStg(VirtualCtrNode  *pvcn)
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnTrav       =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CloseRandomVirtualCtrNodeStg"));

    DH_VDATEPTRIN(pvcn, PVCTRNODE) ;

    DH_ASSERT(NULL != pvcn);
    pvcnTrav = pvcn;

    if(S_OK == hr)
    {
        while((NULL != pvcnTrav->GetParentVirtualCtrNode()) && (S_OK == hr))
        {
            hr = pvcnTrav->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }
    }

    return  hr;
}

//-------------------------------------------------------------------------
//  Function:   ParseVirtualDFAndCloseOpenStgsStms
//
//  Synopsis:   This function parses the VirtualDF tree and calls Close
//              release on all open IStorages/IStreams pointers under and/
//              or including the passed in VirtualCtrNode 
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode 
//              [eNodeOp]- May be NODE_INC_TOPSTG / NODE_EXC_TOPSTG 
//
//  Returns:    HRESULT
//
//  History:    16-July-96  NarindK    Created.
//
//  Notes:      If NODE_INC_TOPSTG is given, it calls a close/release on the
//              passed in VirtualCtrNode, if it is NODE_EXC_TOPSTG, it doesn't
//              call a close/release on the IStorage pointer of passed in
//              VirtualCtrNode.
//
//              Also note that if a Parent's IStorage ptr is Released and is
//              NULL, its child IStorage/IStream pointers will not be valid,
//              for use, but we still need to Release them if they exist.
//
//              - If eNodeOp is NODE_INC_TOPSTG, then see if pvcn's _pstg is not
//                NULL and call VirtualCtrNode::Close on it to release it. if
//                eNodeOp is NODE_EXC_TOPSTG, skip this step
//              - Assign pvcn's _pvcnChild to pvcnTrav and pvcn's _pvsnStream
//                to pvsnTrav 
//              - If pvsnTrav is not NULL (i.e pvcn has child VirtualStmNodes),
//                in a loop -
//                      -Check if pvsnTrav's _pstm is not NULL, if not Call 
//                       VirtualStmNode::Close in it to release, else skip it.
//                      -Advance pvsnTrav to bext VirtualStmNode _pvsnSister &
//                       go back to top of loop.
//              - If pvcnTrav is not NULL (ie pvcn has child VirtualCtrNodes),
//                in a loop -
//                      - Call ParseVirtualDFAndCloseOpenStgsStms recursively
//                        Pl. note it is called with NODE_INC_TOPSTG always.
//                      - Advance pvcnTrav to next sister VirtualCtrNode i.e.
//                        _pvcnSister and go back to top of loop.
//--------------------------------------------------------------------------

HRESULT ParseVirtualDFAndCloseOpenStgsStms(
    VirtualCtrNode  *pvcn,
    NODE_OP         eNodeOp)
{
    HRESULT         hr          =   S_OK;
    VirtualStmNode  *pvsnTrav   =   NULL;
    VirtualCtrNode  *pvcnTrav   =   NULL;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("ParseVirtualDFAndCloseOpenStgsStms"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT((NODE_INC_TOPSTG == eNodeOp) ||
              (NODE_EXC_TOPSTG == eNodeOp));

    if((S_OK == hr) && (NODE_INC_TOPSTG == eNodeOp))
    {
        if(NULL != pvcn->GetIStoragePointer())
        {
            hr = pvcn->Close();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
        }
    }

    if(S_OK == hr)
    {
       pvsnTrav = pvcn->GetFirstChildVirtualStmNode();
       pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

       // Release IStream pointers if any.

       while((NULL != pvsnTrav) && (S_OK == hr))
       {
           if(NULL != pvsnTrav->GetIStreamPointer())
           {
               hr = pvsnTrav->Close();

               DH_HRCHECK(hr, TEXT("VirtualStmNode::Close"));
           }

           pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
       }

       // Next recurse into the child VirtualCtrNodes of this VirtualCtrNode

       while((NULL != pvcnTrav) && (S_OK == hr))
       {
           hr = ParseVirtualDFAndCloseOpenStgsStms(
                    pvcnTrav,
                    NODE_INC_TOPSTG);

           DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));

           pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
       }
    }

    return hr;
}

//-------------------------------------------------------------------------
//  Function:   ParseVirtualDFAndCommitAllOpenStgs
//
//  Synopsis:   This function parses the VirtualDF tree and calls commit 
//              on all open IStorages pointers under passed in VirtualCtrNode 
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode 
//              [grfCommitFlags] - Commit flags.
//              [eNodeOp] - NODE_INC_TOPSTG / NODE_EXC_TOPSTG
//
//  Returns:    HRESULT
//
//  History:    23-July-96  NarindK    Created.
//
//  Notes:      - Assign pvcn's _pvcnChild, if not NULL, to local var pvcnTrav. 
//              - If pvcnTrav is not NULL (ie pvcn has child VirtualCtrNodes),
//                traverse the tree in loop to reach last child.
//                   - while pvcnTrav is not equal to pvcn and hr is S_OK, loop
//                         - If pvcnTrav has IStoragePointer, call Commit.
//                         - If pvcnTrav has sister nodes, call the function
//                           recursively with NODE_INC_TOPSTG always.
//                         - Assgin pvcnTrav's parent to pvcnTrav and go back 
//                           to top of loop.
//              - if eNodeOp is equal to NODE_INC_TOPSTG and hr is S_OK, then
//                commit the top storage pvcn, else skip commiting it.
//--------------------------------------------------------------------------

HRESULT ParseVirtualDFAndCommitAllOpenStgs(
    VirtualCtrNode  *pvcn,
    DWORD           grfCommitMode,
    NODE_OP         eNodeOp)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   NULL;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("ParseVirtualDFAndCommitAllOpenStgs"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT((NODE_INC_TOPSTG == eNodeOp) ||
              (NODE_EXC_TOPSTG == eNodeOp));

    if(S_OK == hr)
    {
        pvcnTrav = pvcn;
        while(NULL != pvcnTrav->GetFirstChildVirtualCtrNode())
        {
            pvcnTrav = pvcnTrav->GetFirstChildVirtualCtrNode();
        }

        DH_ASSERT(NULL != pvcnTrav);
    }

    // Commit this storage, next commit any sister VirtualCtrNodes it might 
    // have  and commit those by recursing into them, then go to parent and 
    // repeat. if parent is equal to pvcnParent, quit the loop 

    while((pvcn != pvcnTrav) && (S_OK == hr))
    {
        if(NULL != pvcnTrav->GetIStoragePointer())
        {
            hr = pvcnTrav->Commit(grfCommitMode);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        }

        while((NULL != pvcnTrav->GetFirstSisterVirtualCtrNode()) && 
              (S_OK == hr))
        {
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();

            hr = ParseVirtualDFAndCommitAllOpenStgs(
                        pvcnTrav,
                        grfCommitMode,
                        NODE_INC_TOPSTG);

            DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs"));
        }

        // Go to Parent VirtualCtrNode and commit them
    
        pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
    }

    if((S_OK == hr)                     && 
       (NODE_INC_TOPSTG == eNodeOp)     &&
       (NULL != pvcn->GetIStoragePointer()))
    {
        hr = pvcn->Commit(grfCommitMode);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
    }
 
    return hr;
}

//-------------------------------------------------------------------------
//
// The following utilitiy functions are to calculate the CRC for a docfile
// These are independent of VirtualDF tree or any other base code implement-
// ation.
//
//-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDocFile
//
//  Synopsis:   Calulates CRC for the disk docfile.
//
//  Arguments:  [pIStorage]  - pointer to IStorage
//              [crcflags]   - what stuff to include in the crc
//              [pdwCRC]     - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    30-May-96  NarindK    Created.
//              24-Jul-97  MikeW      Include state bits
//              02-Apr-98  georgis    read in chunks
//
//  Notes:      For IStorages, only name is CRC'd.  For IStorages/IStreams,
//              both name and data are CRC'd.
//
//              Please not that this function will not indicate a failure if
//              and whenver the IEnumSTATSTG->Next returns fail, that just
//              indicates the completion of enumeration sequence.
//
//              If VERIFY_OP is equal to VERIFY_INC_TOPSTG_NAME, then the func
//              goes ahead and calculates CRC for toplevel storage name also
//              else if it is equal to VERIFY_EXC_TOPSTG_NAME, it doesn't
//              include the CRC for top level storage name.  Pl. note that
//              the recursive call to itself in function includes VERIFY_INC_
//              TOPSTG_NAME, so this parameter is used only for TOP level
//              storage that is passed in (pointed by pIStorage).
//
//              - if VERIFY_OP is VERIFY_INC_TOPSTG_NAME then,              
//                  -Call pIStorage->Stat to get STATSTG structure for passed
//                  IStorage.
//                  -Call CalculateCRCForName to get the CRC for name of this
//                  storage obtained from STATSTG structure.
//                  -Fold the CRC into grand CRC pdwCRC.
//              -Call pIStorage->Enumerate to get LPENUMSTATSTG for storage.
//              -Call lpEnumStatStg->Next to get next element in enumeration
//               sequence. If it returns S_FALSE, means no elements to enum
//               earte, so just return w/o any error.
//              -Else loop till hr is S_OK.
//                  -If node is of type STGSTY_STORAGE, then
//                      -Open the child IStorage.
//                      -Make a recursive call to calculate CRC for this
//                       child Istorage to self CalculateCRCForDocFile.
//                      -Fold the CRC from above call into grand CRC pdwCRC.
//                      -Release the child IStorage
//                  -If node is of type STGSTY_STREAM, then
//                      -Call CalculateCRCForDocFileStmData to calculate CRC
//                       for stream data.
//                      -Call CalculateCRCForName to calculate CRC for its
//                       name.
//                      -Fold the above two into grand CRC pdwCRC.
//                  -Get the next element in enumeration sequence. If it returns
//                   S_FALSE, then simply return w/o any error.
//                  -Else go back to top of loop and repeat.
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDocFile(
    IStorage        *pIStorage,
    DWORD           crcflags, 
    DWORD           *pdwCRC,
    DWORD           dwChunkSize)

{
    HRESULT         hr              =   S_OK;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    ULONG           *pceltFetched   =   NULL;
    LPSTORAGE       pIStorageChild  =   NULL;
    DWORD           dwCurrStgCRC    =   0;
    DWORD           dwCurrStgNameCRC=   0;
    DWORD           dwCurrStmNameCRC=   0;
    DWORD           dwCurrStmDataCRC=   0;
    BOOL            fIEnumNextFail  =   FALSE;
    ULONG           i               =   0;
    LPTSTR          ptszName        =   NULL;
    LPTSTR          ptszNameStm     =   NULL;
    LPTSTR          ptszNameStg     =   NULL;
    LPOLESTR        poszNameStg     =   NULL;
    STATSTG         statStg;
    STATSTG         statStgEnum;
    DWORD           statflag        = STATFLAG_DEFAULT;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateCRCForDocFile"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTROUT(pdwCRC, DWORD) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pdwCRC);

    // Initialization
    statStg.pwcsName = NULL;
    statStgEnum.pwcsName = NULL;
 
    // Initialize out parameter

    *pdwCRC = CRC_PRECONDITION;

    // Call Stat on the passed IStorage to get its name and state bits

    if (! (CRC_INC_TOPSTG_NAME & crcflags))
    {
        statflag = STATFLAG_NONAME;
    }

    if(S_OK == hr)
    {
        hr = pIStorage->Stat(&statStg, statflag);

        DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
    }

    if (CRC_INC_STATEBITS & crcflags)
    {
        // Fold the CRC into grand CRC

        MUNGECRC(*pdwCRC, statStg.grfStateBits);

        DH_TRACE((
                DH_LVL_CRCDUMP, 
                TEXT("statebits=0x%08x, crc=0x%08x"),
                statStg.grfStateBits, 
                *pdwCRC));

    }

    // If crcflags includes CRC_INC_TOPSTG_NAME, then calculate and
    // include the top level storage name in calculating grand CRC.

    if(CRC_INC_TOPSTG_NAME & crcflags)
    {
        DH_ASSERT(NULL != statStg.pwcsName);

        // Find the CRC for the storage name

        if(S_OK == hr)
        {
            //Convert WCHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            hr = CalculateCRCForName(ptszName, &dwCurrStgNameCRC);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFileNames")) ;
        }

        // Fold the CRC into grand CRC

        MUNGECRC(*pdwCRC, dwCurrStgNameCRC);

        DH_TRACE((
                DH_LVL_CRCDUMP,
                TEXT("storage=%s, crc=0x%08x"),
                ptszName, 
                *pdwCRC));

        // Clean up

        if(NULL != statStg.pwcsName)
        {
            CoTaskMemFree(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszName)
        {
            delete ptszName;
            ptszName = NULL;
        }
    }

    // Get the enumerator so that we could enumerate this storage

    if(S_OK == hr)
    {
        hr = pIStorage->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    // if successful to get enumerator, get the first element of the enumeration
    // sequence.

    if ( S_OK == hr )
    {
        hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

        if(S_FALSE == hr)
        {
            fIEnumNextFail = TRUE;
        }
    }

    // Loop through till lpEnumStatStg->Next returns FALSE which is desired
    // sequene or some other error happens

    while(S_OK == hr)
    {
        // If the element is an IStorage, open this and make a recursive call
        // to CalculateCRCForDocFile function.

        if (STGTY_STORAGE == statStgEnum.type)
        {
            //Convert WCHAR to TCHAR

            hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStg);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszNameStg, &poszNameStg);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pIStorage->OpenStorage(
                       poszNameStg,
                       NULL,
                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                       NULL,
                       0,
                       &pIStorageChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
            }

            if (S_OK == hr)
            {
                // Make recursive call including CRC_INC_TOPSTG_NAME

                hr = CalculateCRCForDocFile(
                        pIStorageChild, 
                        crcflags | CRC_INC_TOPSTG_NAME,
                        &dwCurrStgCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
            }

            // Fold the CRC for contained IStorage into grand CRC

            MUNGECRC(*pdwCRC, dwCurrStgCRC);

            // Release the storage pointer

            if(NULL != pIStorageChild)
            {
                pIStorageChild->Release();
                pIStorageChild = NULL;
            }
        }
        else

        // If the element is an IStream, calculate CRC for its name and Data.

        if (STGTY_STREAM == statStgEnum.type)
        {
            // Calulate CRC for IStream Data.
    
            if(S_OK == hr)
            {
                //Convert WCHAR to TCHAR

                hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStm);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
            }

            if(S_OK == hr)
            {
                hr = CalculateCRCForDocFileStmData(
                        pIStorage,
                        ptszNameStm,
                        statStgEnum.cbSize.LowPart,
                        &dwCurrStmDataCRC,
                        dwChunkSize);
    
                DH_HRCHECK(hr, TEXT("CalculateCRCForDocFileStmData"));
            }

            // Calulate CRC for IStream Name.

            if(S_OK == hr)
            {
                hr = CalculateCRCForName(
                        ptszNameStm,
                        &dwCurrStmNameCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForName"));

                DH_TRACE((
                        DH_LVL_CRCDUMP,
                        TEXT("stream %s, name crc=0x%08x, data crc=0x%08x"),
                        ptszNameStm,
                        dwCurrStmNameCRC,
                        dwCurrStmDataCRC));
            }

            // Fold the CRC's  for contained IStream into grand CRC

            MUNGECRC(*pdwCRC, dwCurrStmDataCRC);
            MUNGECRC(*pdwCRC, dwCurrStmNameCRC);
        }
        else

        // The element is neither IStorage nor IStream, report error.
        {
            hr = E_UNEXPECTED;
        }

        // Clean up

        if(NULL != statStgEnum.pwcsName)
        {
            CoTaskMemFree(statStgEnum.pwcsName);
            statStgEnum.pwcsName = NULL;
        }

        if(NULL != ptszNameStm)
        {
            delete ptszNameStm;
            ptszNameStm = NULL;
        }

        if(NULL != ptszNameStg)
        {
            delete ptszNameStg;
            ptszNameStg = NULL;
        }

        if(NULL != poszNameStg)
        {
            delete poszNameStg;
            poszNameStg = NULL;
        }

        // Get the next element in the enumeration sequence

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

            if(S_FALSE == hr)
            {
                fIEnumNextFail = TRUE;
            }
        }
    }

    // IEnumSTATSTG->Next would return S_FALSE if it can't enumerate the
    // next element because there might not be any elements to enumerate
    // hence it doesn't indicate an error for this function, but is just
    // a condition for looping through the total docfile structure, hence
    // don't reprot failure because of it.

    if(TRUE == fIEnumNextFail)
    {
        hr = S_OK;
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        lpEnumStatStg->Release();
        lpEnumStatStg = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDocFileStmData
//
//  Synopsis:   Calulates CRC for the disk docfile's stream data.
//
//  Arguments:  [pIStorage]     - pointer to parent storage
//              [ptcsName]      - pointer to name string
//              [cbSize]        - size of the data to be read.
//              [pdwCurrStmDataCRC]- pointer to returned CRC
//
//  Returns:    HRESULT
//
//  History:    30-May-96  NarindK    Created.
//              02-Apr-98  georgis    Use CalculateStreamDataCRC
//
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDocFileStmData(
    LPSTORAGE       pIStorage,
    LPTSTR          ptcsName,
    DWORD           cbSize,
    DWORD           *pdwCurrStmDataCRC,
    DWORD           dwChunkSize)

{
    HRESULT         hr              =   S_OK;
    LPSTREAM        pIStreamChild   =   NULL;
    LPOLESTR        pOleStrTemp     =   NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, TEXT("CalculateCRCForDocFileStmData"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATESTRINGPTR(ptcsName) ;
    DH_VDATEPTROUT(pdwCurrStmDataCRC, DWORD) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != pdwCurrStmDataCRC);

    // Open the stream
    hr = TStringToOleString(ptcsName, &pOleStrTemp);
    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;

    if ( S_OK == hr )
    {
        hr = pIStorage->OpenStream(
                 pOleStrTemp,
                 NULL,
                 STGM_READ | STGM_SHARE_EXCLUSIVE,
                 0,
                 &pIStreamChild);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
    }


    if ( S_OK == hr )
    {
		// Calculate the CRC for the stream data
		hr=CalculateStreamDataCRC(
			pIStreamChild,
			cbSize,
			pdwCurrStmDataCRC,
			dwChunkSize);
		DH_HRCHECK(hr, TEXT("CalculateStreamDataCRC"));
    }

    if (NULL!= pIStreamChild)
    {
        pIStreamChild->Release();
    }

    if (NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDocFileStmData
//
//  Synopsis:   Calulates CRC for the disk docfile's stream data.
//
//  Arguments:  [ptcsName]  - ? not used
//              [pIChildStream] - pointer to the opened stream
//              [cbSize] - size of the data to be read.
//              [pdwCurrStmDataCRC]- pointer to returned CRC
//
//  Returns:    HRESULT
//
//  History:    15-Nov-96  JiminLi    Created.
//              02-Apr-98  georgis    Use CalculateStreamDataCRC
//
//  Notes:      CalculateStreamDataCRC actually obsoletes this function
//              It remains for compatibility with the old tests                               
//
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDocFileStmData(
    LPTSTR          ptcsName,
    LPSTREAM        pIChildStream,
    DWORD           cbSize,
    DWORD           *pdwCurrStmDataCRC,
    DWORD           dwChunkSize)
{
    HRESULT         hr              =   S_OK;
 
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, TEXT("CalculateCRCForDocFileStmData"));

    DH_VDATEPTRIN(pIChildStream, IStream) ;
    DH_VDATEPTROUT(pdwCurrStmDataCRC, DWORD) ;
    DH_ASSERT(NULL != pdwCurrStmDataCRC);
    DH_ASSERT(0 != cbSize);

    // The stream is kept open before calling this function
    DH_ASSERT(NULL != pIChildStream);

    // Calculate the CRC for the stream data
    hr=CalculateStreamDataCRC(
        pIChildStream,
        cbSize,
        pdwCurrStmDataCRC,
        dwChunkSize);
    DH_HRCHECK(hr, TEXT("CalculateStreamDataCRC"));

    return  hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   EnumerateDiskDocFile
//
//  Synopsis:   Enumerates a disk docfile.
//
//  Arguments:  [pIStorage]  - pointer to IStorage
//              [eVerifyOp]  - VERIFY_SHORT or VERIFY_DETAIL
//              [pdwNumStg]  - pointer to number of Storages in doc hierarchy.
//              [pdwNumStm]  - pointer to number of streams in doc hierarchy
//
//  Returns:    HRESULT
//
//  History:    3-June-96  NarindK    Created.
//
//  Notes:      pdwNumStg, pdwNumStm may be NULL if user is not interested in
//              these values to be returned back.  eVerifyOp should normally
//              be specified as VERIFY_SHORT unless test requires it otherwise
//
//              -Count the passed in pIStorage as 1 in pNumStg count.
//              -Call pIStorage->EnumElements to get LPENUMSTATSTG lpEnumStatStg
//              -Call lpEnumStatStg->Next to get next node. If it returns
//               S_FALSE, that indicates no elements to enumerate, so return
//               without any error.
//              -Else loop till hr is S_OK
//                  -if node is of type STGTY_STORAGE, then
//                      -open that child storage and make a recursive call to
//                       EnumerateDiskDocFile passing it pointer to opened
//                       child storage, and cChildStg and cChildStm local
//                       variables for count.
//                      -close the child storage opened.
//                      -Update the pNumStg, pNumStm based on above recursive
//                       call's out parameters cChildStg and CChildStm.
//                  -if node is of type STGTY_STREAM, then update pNumStm count
//                      - if flag VERIFY_DETAIL is passed in, then open that
//                        stream and read its contents.  This verification
//                        is useful in cases like corruption tests where this
//                        verification ensures proper stability of OLE under
//                        such situations.   
//                  -Get the next element in enumeration sequence.
//                  -Reinitilize the local variables cChildStg, cChildStm.
//                  -Go back to top of loop and repeat.
//--------------------------------------------------------------------------

HRESULT EnumerateDiskDocFile(
    LPSTORAGE   pIStorage,
    VERIFY_OP   eVerifyOp, 
    ULONG       *pNumStg,
    ULONG       *pNumStm )
{
    HRESULT         hr              =   S_OK;
    LPMALLOC        pMalloc         =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    ULONG           *pceltFetched   =   NULL;
    LPSTORAGE       pIStorageChild  =   NULL;
    BOOL            fIEnumNextFail  =   FALSE;
    ULONG           cChildStg       =   0;
    ULONG           cChildStm       =   0;
    LPSTREAM        pIStreamChild   =   NULL;
    LPOLESTR        pocsBuffer      =   NULL;
    LPTSTR          ptszNameStg     =   NULL;
    LPOLESTR        poszNameStg     =   NULL;
    LPTSTR          ptszNameStm     =   NULL;
    LPOLESTR        poszNameStm     =   NULL;
    ULONG           culRead         =   0;
    ULONG           culCurBufferLen =   0;
    STATSTG         statStgEnum;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateDiskDocFile"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    if(NULL != pNumStg)
    {
        DH_VDATEPTROUT(pNumStg, ULONG) ;
    }
    if(NULL != pNumStm)
    {
        DH_VDATEPTROUT(pNumStm, ULONG) ;
    }

    DH_ASSERT(NULL != pIStorage);

    // Initialization
    statStgEnum.pwcsName = NULL;

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Call EnumElements on passed IStorage to enumerate it.

    if(S_OK == hr)
    {
        // Initialize out parameter

        if(NULL != pNumStg)
        {
            // Count the storage passed in.

            *pNumStg = 1;
        }

        if(NULL != pNumStm)
        {
            *pNumStm = 0;
        }

        hr = pIStorage->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    // if successful to get enumerator, get the first element of the enumeration
    // sequence.

    if ( S_OK == hr )
    {
        hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

        if(S_FALSE == hr)
        {
            fIEnumNextFail = TRUE;
        }
    }

    // Loop through till lpEnumStatStg->Next returns FALSE which is desired
    // sequence or some other error happens

    while(S_OK == hr)
    {
        // If the element is an IStorage, open this and make a recursive call
        // to EnumerateDocFile function.

        if (STGTY_STORAGE == statStgEnum.type)
        {
            //Convert WCHAR to TCHAR

            hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStg);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszNameStg, &poszNameStg);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pIStorage->OpenStorage(
                       poszNameStg,
                       NULL,
                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                       NULL,
                       0,
                       &pIStorageChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
            }

            if (S_OK == hr)
            {
                // Recursive call to EnumerateDiskDocFile

                hr = EnumerateDiskDocFile(
                        pIStorageChild,
                        eVerifyOp,
                        &cChildStg,
                        &cChildStm);

                DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
            }

            // Release the storage pointer

            if(NULL != pIStorageChild)
            {
                pIStorageChild->Release();
                pIStorageChild = NULL;
            }

            // Release string pointers.

            if(NULL != ptszNameStg)
            {
                delete ptszNameStg;
                ptszNameStg = NULL;
            }

            if(NULL != poszNameStg)
            {
                delete poszNameStg;
                poszNameStg = NULL;
            }

            // Update number of storage and stream objects, if required.

            if((NULL != pNumStg) && (0 != cChildStg))
            {
                *pNumStg = cChildStg + *pNumStg;
            }

            if((NULL != pNumStm) && (0 != cChildStm))
            {
                *pNumStm = cChildStm + *pNumStm;
            }
        }
        else
        if (STGTY_STREAM == statStgEnum.type)
        {
            if(NULL != pNumStm)
            {
                (*pNumStm)++;
            }
            if(VERIFY_DETAIL == eVerifyOp)
            {
                //Attempt to open and read the stream.  Useful for corruption
                // tests to see that OLE doesn't GPF under those conditions.

                //Convert WCHAR to TCHAR

                hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStm);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

                if(S_OK == hr)
                {
                    // Convert TCHAR to OLECHAR

                    hr = TStringToOleString(ptszNameStm, &poszNameStm);

                    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
                }

                // Open the stream.

                if(S_OK == hr)
                {
                    hr = pIStorage->OpenStream(
                            poszNameStm,
                            NULL,
                            STGM_READ | STGM_SHARE_EXCLUSIVE,
                            0,
                            &pIStreamChild);

                    DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
                }

                // Read the stream in loop
                while(( culCurBufferLen < statStgEnum.cbSize.LowPart) &&
                      (S_OK == hr))
                {
                    if ( S_OK == hr )
                    {
                        pocsBuffer = new OLECHAR [STM_BUFLEN];

                        if (pocsBuffer == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if ( S_OK == hr )
                    {
                        // Initialize the buffer

                        memset(pocsBuffer, '\0', STM_BUFLEN);

                        //  Read the stream.

                        hr = pIStreamChild->Read(
                                pocsBuffer,
                                STM_BUFLEN,
                                &culRead);

                        DH_HRCHECK(hr, TEXT("IStream::Read")) ;
                    }

                    // Release the buffer 
                    if(NULL != pocsBuffer)
                    {
                        delete [] pocsBuffer;
                        pocsBuffer = NULL;
                    }

                    // Increment culCurBufferLen
                    culCurBufferLen = culCurBufferLen + culRead;
                }

                // Release the stream
                if(NULL != pIStreamChild)
                {
                    pIStreamChild->Release();
                    pIStreamChild = NULL;
                }
                    
                // Release string pointers.

                if(NULL != ptszNameStm)
                {
                    delete ptszNameStm;
                    ptszNameStm = NULL;
                }

                if(NULL != poszNameStm)
                {
                    delete poszNameStm;
                    poszNameStm = NULL;
                }
            }
        }
        else
        // The element is neither IStorage nor IStream, report error.
        {
            hr = E_UNEXPECTED;
        }

        // Clean up

        if(NULL != statStgEnum.pwcsName)
        {
            pMalloc->Free(statStgEnum.pwcsName);
            statStgEnum.pwcsName = NULL;
        }

        // Get the next element in the enumeration sequence

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

            if(S_FALSE == hr)
            {
                fIEnumNextFail = TRUE;
            }
        }

        // Reinitialize the variables

        cChildStg = 0;
        cChildStm = 0;
    }

    // IEnumSTATSTG->Next returning S_FALSE indicates end of traversal in
    // docfile hierarchy, not an error.

    if(TRUE == fIEnumNextFail)
    {
        hr = S_OK;
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        lpEnumStatStg->Release();
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}


//+-------------------------------------------------------------------------
//  Function:   GenerateVirtualDFFromDiskDF
//
//  Synopsis:   Enumerates a disk docfile and creates an in memory virtual
//              DocFile tree for the docfile.
//
//  Arguments:  [pNewVirtualDF] - Pointer to new VirtualDF tree being made.
//              [ptszRootDFName]  - Pointer to name of root Disk file.
//              [grfMode]    - Mode to open the root storage 
//              [ppvcnRoot]  - pointer to pointer to root of VirtualDF.
//              [pIRootStg]  - Default value is NULL, when fDFOpened is TRUE,
//                             then pIRootStg must not be NULL, it is RootStg
//                             pointer
//              [fDFOpened] -  Default value is FALSE, i.e. the docfile is not
//                             opened, StgOpenStorage is called to open it.
//                             When it's TRUE, the pIRootStg is the stg pointer.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//              3-Feb-97   JiminLi    Adapted
//
//  Notes:      -Call TStringToOleString to convert given DocFile name to
//               OLECHAR.
//              - Call StgOpenStorage to open Root storage.
//              -Call GenVirtualCtrNode to generate the root *ppvcnRoot of new
//               VirtualDocFile tree being made passing it name from above Stat
//               call.  If successful, assocaite disk root IStorage with the
//               root VirtualCtrNode's _pstg parameter.
//              -Call GenerateRemVirtualDFTree to generate rest of tree, passing//               it the new rootgenerated above and pIStorage.
//              -If successful, call VirtualDF::Associate to associate this
//               new root with the VirtualDF tree, else reassign *ppvcnRoot
//               to NULL in case of failure.
//
//              Please note that the Root storage opened during this call will
//              be released during VirtualDF tree deletion that deletes all 
//              the VirtualCtrNodes in the tree & Destructor of VirtualCtrNodes
//              does a final release on the storage pointers, if they are valid
//              Also note that as result of this function, all other storage/
//              streams are closed, except the Root storage. 
//--------------------------------------------------------------------------

HRESULT GenerateVirtualDFFromDiskDF(
    VirtualDF       *pNewVirtualDF,
    LPTSTR          ptszRootDFName,
    DWORD           grfMode,
    VirtualCtrNode  **ppvcnRoot,
    LPSTORAGE       pIRootStg,
    BOOL            fDFOpened,
    ULONG           ulSeed)
{
    HRESULT         hr              =   S_OK;
    LPSTORAGE       pIStorage       =   NULL;
    LPOLESTR        pOleStrTemp     =   NULL;
    ULONG           i               =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenerateVirtualDFFromDiskDF"));

    DH_VDATESTRINGPTR(ptszRootDFName) ;
    DH_VDATEPTROUT(ppvcnRoot, PVCTRNODE) ;
    DH_VDATEPTROUT(pNewVirtualDF, VirtualDF) ;

    DH_ASSERT(NULL != ptszRootDFName);
    DH_ASSERT(NULL != ppvcnRoot);
    DH_ASSERT(NULL != pNewVirtualDF);

    if (fDFOpened)
    {
        DH_ASSERT(NULL != pIRootStg);
        pIStorage = pIRootStg;
    }
    else
    {
        DH_ASSERT(0 != grfMode);
    }

    if ( S_OK == hr )
    {
        // Initialize out parameter

        *ppvcnRoot = NULL;
    }

    if (!fDFOpened && (S_OK == hr))
    {
        // Convert TCHAR to OLECHAR

        hr = TStringToOleString(ptszRootDFName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (!fDFOpened && (S_OK == hr))
    {
        // Try opening the docfile
        // StgOpenStorage returns STG_E_LOCKVIOLATION is concurrent API calls
        // are made, so this is the hack for workaround the problem.
        // BUGBUG : Remove this loop once the feature is implemented in OLE.
        // BUGBUG : ntbug#114779  Affects DCOM95 only. ntbug#41249 fixed

#if (WINVER<0x500)          //NT5 is lockviolation fixed
        for(i=0; i<NRETRIES; i++)  // NRETRIES has been defined as 5
        {
#endif
            hr = StgOpenStorage(
                    pOleStrTemp,  
                    NULL,
                    grfMode, 
                    NULL,
                    0,
                    &pIStorage);

#if (WINVER<0x500)          //NT5 is lockviolation fixed
            if ( (S_OK == hr) || (STG_E_LOCKVIOLATION != hr) )
            {
                break;
            }

            Sleep(NWAIT_TIME);            
        }
#endif
    }

    if ( S_OK == hr )
    {
        // Call to create the VirtualDF tree root.

        hr = GenVirtualCtrNode(ptszRootDFName, ppvcnRoot);

        DH_HRCHECK(hr, TEXT("GenerateVirtualDFRootFromDiskStg")) ;

    }

    if ( S_OK == hr )
    {
        // Create the remaining VirtualDF tree.

        hr = GenerateRemVirtualDFTree(*ppvcnRoot, pIStorage);

        DH_HRCHECK(hr, TEXT("CreateRemVirtualDFTree")) ;
    }

    if (S_OK != hr)
    {
        // The tree couldn't be successfully created, return NULL in out
        // parameter.

        *ppvcnRoot = NULL;
    }
    else
    {
        // Associate the root VirtualCtrNode with the VirtualDF tree.

        hr = pNewVirtualDF->Associate(*ppvcnRoot, pIStorage, ulSeed);

        DH_HRCHECK(hr, TEXT("VirtualDF::Associate")) ;
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp; 
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenerateVirtualDFFromDiskDF
//
//  Synopsis:   Enumerates a disk docfile and creates an in memory virtual
//              DocFile tree for the docfile.
//
//  Arguments:  [pNewVirtualDF]  - Pointer to new VirtualDF tree being made.
//              [ptszRootDFName] - Pointer to name of root Disk file.
//              [grfMode]        - Mode to open the root storage 
//              [ppvcnRoot]      - pointer to pointer to root of VirtualDF.
//              [ulSeed]         - pointer to pointer to root of VirtualDF.
//
//  Notes:      Call the above function with filled in params that are
//              normally defaulted with the defaults. Seed is at the
//              end, so we need them.
//              This is a convenience function.
//
//--------------------------------------------------------------------------

HRESULT GenerateVirtualDFFromDiskDF(
    VirtualDF       *pNewVirtualDF,
    LPTSTR          ptszRootDFName,
    DWORD           grfMode,
    VirtualCtrNode  **ppvcnRoot,
    ULONG           ulSeed)
{                                
    return GenerateVirtualDFFromDiskDF(
            pNewVirtualDF,
            ptszRootDFName,
            grfMode,
            ppvcnRoot,
            NULL,
            FALSE,
            ulSeed);
}

//+-------------------------------------------------------------------------
//  Function:   GenerateRemVirtualDFTree
//
//  Synopsis:   Creates rest of in memory virtual DocFile tree for a given
//              Disk Docfile. Internal function local to this file.
//
//  Arguments:  [pvcnParent]   - pointer to root VirtualCtrNode
//              [pIStgParent]  - pointer to Disk IStorage assoc. with above.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//
//  Notes:      -Call pIStgParent->Enumerate to get LPENUMSTATSTG for storage.
//              -Call lpEnumStatStg->Next to get next element of enumeration.
//               if it returns S_FALSE, that means there is nothing to enum-
//               erate, so just return without nay error.
//              -Else loop till hr is S_OK
//                  -If node is of type STGTY_STORAGE then
//                      -open this child storage.
//                      -Call GenVirtualCtrNode to create a corresponding
//                       VirtualCtrNode for this storage.
//                      -Call AppendChildCtr or AppendSisterCtr as case is.
//                      -Call parent's IncreaseChildrenStgCount to indicate
//                       a new VirtualCtrNode is added.
//                      -Make a recursive call to GenVirtualCtrNode.
//                      -Release the child storage pointer and remember the old
//                       sibling.
//                  -If node is of type STGSTY_STREAM then
//                      -Call GenVirtualStmNode to create a corresponding
//                       VirtualStmNode for this stream.
//                      -Call AppendChildStm or AppendSisterStm as case is.
//                      -Call parent's IncreaseChildrenStmCount to indicate
//                       a new VirtualStmNode is added.
//                      -Remember the old sibling.
//                  -Reinitialize local variables and call Next on the enumera-
//                   or.  If it returns S_FALSE, then exist out of loop w/o
//                   any error.
//                  -Else go back to top of loop and repeat.
//--------------------------------------------------------------------------

HRESULT GenerateRemVirtualDFTree(
    VirtualCtrNode  *pvcnParent,
    LPSTORAGE       pIStgParent)
{
    HRESULT         hr              =   S_OK;
    LPMALLOC        pMalloc         =   NULL;
    ULONG           *pceltFetched   =   NULL;
    LPSTORAGE       pIStorageChild  =   NULL;
    VirtualCtrNode  *pvcnChild      =   NULL;
    VirtualStmNode  *pvsnChild      =   NULL;
    VirtualCtrNode  *pvcnOldSister  =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    BOOL            fFirstChild     =   TRUE;
    BOOL            fFirstStream    =   TRUE;
    BOOL            fIEnumNextFail  =   FALSE;
    LPTSTR          ptszNameStg     =   NULL;
    LPTSTR          ptszNameStm     =   NULL;
    LPOLESTR        pOleStrTemp     =   NULL;
    STATSTG         statStgEnum;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenerateRemVirtualDFTree"));

    // Initialization
    statStgEnum.pwcsName = NULL;

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if ( S_OK == hr )
    {
        // Get an Enumerator for given IStorage

        hr = pIStgParent->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    // if successful to get enumerator, get the first element of the enumeration
    // sequence.

    if ( S_OK == hr )
    {
        hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

        if(S_FALSE == hr)
        {
            fIEnumNextFail = TRUE;
        }
    }

    while(S_OK == hr)
    {
        // If the element is an IStorage, open this and make a recursive call
        // to self.

        if (STGTY_STORAGE == statStgEnum.type)
        {
            if(S_OK == hr)
            {
                //Convert WCHAR to TCHAR

                hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStg);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
            }

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszNameStg, &pOleStrTemp);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            hr = pIStgParent->OpenStorage(
                       pOleStrTemp,
                       NULL,
                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                       NULL,
                       0,
                       &pIStorageChild);

            DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;

            // Add to tree

            if (S_OK == hr)
            {
                hr = GenVirtualCtrNode(
                        ptszNameStg,
                        &pvcnChild);
            }

            if (S_OK == hr)
            {
                if(fFirstChild == TRUE)
                {
                    hr = pvcnParent->AppendChildCtr(pvcnChild);
                    pvcnParent->IncreaseChildrenStgCount();

                    fFirstChild = FALSE;
                }
                else
                {
                    hr = pvcnOldSister->AppendSisterCtr(pvcnChild);
                    pvcnParent->IncreaseChildrenStgCount();
                }
            }

            if (S_OK == hr)
            {
                // Recursive call to self

                hr = GenerateRemVirtualDFTree(pvcnChild, pIStorageChild);

                DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
            }

            // Release the storage pointer

            if(NULL != pIStorageChild)
            {
                pIStorageChild->Release();
                pIStorageChild = NULL;
            }

            // Remember the old sibling

            pvcnOldSister = pvcnChild;
        }
        else

        // The element is an IStream.

        if (STGTY_STREAM == statStgEnum.type)
        {
            // Add to tree

            if (S_OK == hr)
            {
                if(S_OK == hr)
                {
                    // Convert WCHAR to TCHAR

                    hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStm);

                    DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
                }

                // BUGBUG:The cbSize used during creation is a DWORD. Assumption
                // cbSize.LowPart contains the size information hence.

                hr = GenVirtualStmNode(
                        ptszNameStm,
                        statStgEnum.cbSize.LowPart,
                        &pvsnChild);
            }

            if (S_OK == hr)
            {
                if(fFirstStream == TRUE)
                {
                    hr = pvcnParent->AppendFirstChildStm(pvsnChild);
                    pvcnParent->IncreaseChildrenStmCount();

                    fFirstStream = FALSE;
                }
                else
                {
                    hr = pvsnOldSister->AppendSisterStm(pvsnChild);
                    pvcnParent->IncreaseChildrenStmCount();
                }
            }

            // Remember the old sibling

            pvsnOldSister = pvsnChild;
        }
        else
        // The element is neither IStorage nor IStream, report error.
        {
            hr = E_UNEXPECTED;
        }

        // Cleanup

        if(NULL != statStgEnum.pwcsName)
        {
            pMalloc->Free(statStgEnum.pwcsName);
            statStgEnum.pwcsName = NULL;
        }

        if(NULL != pOleStrTemp)
        {
            delete pOleStrTemp; 
            pOleStrTemp = NULL;
        }

        if(NULL != ptszNameStg)
        {
            delete ptszNameStg; 
            ptszNameStg = NULL;
        }

        if(NULL != ptszNameStm)
        {
            delete ptszNameStm; 
            ptszNameStm = NULL;
        }

        // Reinitialize the variables

        pIStorageChild = NULL;
        pvcnChild = NULL;
        pvsnChild = NULL;

        // Get the next element in the enumeration sequence

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

            if(S_FALSE == hr)
            {
                fIEnumNextFail = TRUE;
            }
        }
    }

    // IEnumSTATSTG->Next returning S_FALSE indicates end of traversal in
    // docfile hierarchy, not an error.

    if(TRUE == fIEnumNextFail)
    {
        hr = S_OK;
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        lpEnumStatStg->Release();
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenVirtualCtrNode
//
//  Synopsis:   Creates a VirtualCtrNode and initializes it
//
//  Arguments:  [ptcsName]   - pointer to name for VirtualCtrNode
//              [*ppvcnNew]  - Returned VirtualCtrNode.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//
//  Notes:      Creates a VirtualCtrNode and initializes it will pName that
//              is passed in. _cChildren and _cStreams are initialized to
//              zero.
//--------------------------------------------------------------------------

HRESULT GenVirtualCtrNode(
    LPTSTR          ptcsName,
    VirtualCtrNode  **ppvcnNew)
{
    HRESULT         hr              =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenVirtualCtrNodeFromDiskStg"));

    DH_VDATEPTRIN(ptcsName, TCHAR) ;
    DH_VDATEPTROUT(ppvcnNew, PVCTRNODE) ;

    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != ppvcnNew);

    // Generate VirtualCtrNode for the stg.

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppvcnNew = NULL;

        // Create new VirtualCtrNode

        *ppvcnNew = new VirtualCtrNode();

        if (NULL == *ppvcnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Initialize VirtualCtrNode

        hr = (*ppvcnNew)->Init(ptcsName, 0, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenVirtualStmNode
//
//  Synopsis:   Creates a VirtualStmNode and initializes it
//
//  Arguments:  [ptcsName]   - pointer to name for VirtualStmNode
//              [*ppvcnNew]  - Returned VirtualStmNode.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//
//  Notes:      -Creates a new VirtualStmNode and initializes it with name
//               and size passed in.
//--------------------------------------------------------------------------

HRESULT GenVirtualStmNode(
    LPTSTR          ptcsName,
    DWORD           cbSize,
    VirtualStmNode  **ppvsnNew)
{
    HRESULT         hr              =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenVirtualStmNode"));

    DH_VDATEPTRIN(ptcsName, TCHAR) ;
    DH_VDATEPTROUT(ppvsnNew, PVSTMNODE) ;

    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != ppvsnNew);

    // Generate VirtualStmNode for the stream.

    if(S_OK == hr)
    {
        *ppvsnNew = new VirtualStmNode();

        if (NULL == *ppvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvsnNew)->Init(ptcsName, cbSize);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    return  hr;
}

//+-------------------------------------------------------------------
//
//  Function:  PrivAtol
//
//  Synopsis:  Private "atol" function for better error control
//
//  Arguments: [pszNum] - The number string
//
//             [plResult] - A place to put the result
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   28-Jul-1995   AlexE   Created
//             20-May-1996   Narindk Adapted for stgbase tests.
//
//--------------------------------------------------------------------

HRESULT PrivAtol(char *pszNum, LONG *plResult)
{
    LONG l = 0 ;

    *plResult = 0 ;

    while (0 != *pszNum)
    {
       if (*pszNum > '9' || *pszNum < '0')
       {
           return E_INVALIDARG ;
       }

       l = 10 * l + (LONG) ((*pszNum - '0')) ;

       pszNum++ ;

    }

    *plResult = l ;

    return S_OK ;
}

//+-------------------------------------------------------------------------
//
//  Function:   GenerateRandomString
//
//  Synopsis:   Generates a random string using datagen object.  This function
//              differs from the orginal GenerateRandomFunction in the fact
//              that it doesn't generate a random extenstion.
//
//  Arguments:  [pgdu] - Pointer to DG_UNICODE object.
//              [pptszName] - Pointer to pointer to returned string.
//              [ulMinLen] - Minimum length of string
//              [ulMaxLen] - Maximum length of string
//
//  Returns:    HRESULT.  S_OK if everything goes ok, error code otherwise.
//
//  History:    17-Apr-96  NarindK    Created.
//              31-July-96 Narindk    Adapted to stgbase tests.
//
//  Notes:      BUGBUG: This function need to be enhance to handle different
//              character sets.
//              Please note that in GenerateRandomName, name gen may have an
//              extension b/w 0 and FILEEXT_MAXLEN besides the length of name
//              b/w ulMinLen and ulMax Len.  But  with this function, it will
//              not have any extension, so the length would be b/w ulMinLen &
//              ulMaxLen.
//
//--------------------------------------------------------------------------

HRESULT GenerateRandomString(
    DG_STRING   *pgds,
    ULONG       ulMinLen,
    ULONG       ulMaxLen,
    LPTSTR      *pptszName)
{
    HRESULT     hr          =   S_OK;
    ULONG       cTemp       =   0;
    USHORT      usErr       =   0;
    ULONG       ulActMaxLen =   0;
    ULONG       ulActMinLen =   0;
    ULONG       ulNameLen   =   0;
    LPTSTR      ptszName    =   NULL;
    LPWSTR      pwszName    =   NULL;

    TCHAR       ptszFATCharSet[FAT_CHARSET_SIZE];
    LPWSTR      pwszFATCharSet = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GenerateRandomString"));

    DH_VDATEPTRIN(pgds, DG_STRING) ;
    DH_VDATEPTROUT(pptszName, LPTSTR) ;

    DH_ASSERT(NULL != pgds);
    DH_ASSERT(NULL != pptszName);
    if (S_OK == hr)
    {
        // Initialize out parameter.

        *pptszName = NULL;

        // Sanity check.  Min length for name must be <= maximum length, if it
        // isn't then make maximum length equal to minimum length.

        if (ulMaxLen < ulMinLen)
        {
            ulMaxLen =  ulMinLen;
        }

        // If Maximum length provided is 0, then default maximum length would
        // be used.  If Minimum length provided is zero, then 1 would be used
        // for it.

        // BUGBUG:  We are using default maximum length for FAT system.

        ulActMaxLen = (ulMaxLen == 0 ? DEF_FATNAME_MAXLEN : ulMaxLen);
        ulActMinLen = (ulMinLen == 0 ? 1 : ulMinLen);

        // '\0', '\', '/', and ':' are invalid for IStorage/IStream names
        //                         (For doc file)
        // '*', '"' '<' '>' '?' are invalid for IStorage/IStream names on OFS

        // Initialize valid character set for FAT file names

        _tcscpy(ptszFATCharSet, _TEXT("abcdefghijklmnopqrstuvwxyz"));
        _tcscat(ptszFATCharSet, _TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ"));
        _tcscat(ptszFATCharSet, _TEXT("0123456789"));

        // Call DataGen to generate a random file name
        // BUGBUG:  We are using FAT character set to generate random names.

#ifdef _MAC

	usErr = pgds->Generate(
		    (UCHAR **)&ptszName,     // force compiler to chose the right
		    (UCHAR *)ptszFATCharSet, // version of Generate
		    ulActMinLen,
		    ulActMaxLen);

#else

        if(S_OK == hr)
        {
            // Convert TCHAR to WCHAR

            hr = TStrToWStr(ptszFATCharSet, &pwszFATCharSet);
            DH_HRCHECK(hr, TEXT("TStrToWStr")) ;
        }

        usErr = pgds->Generate(
                    &pwszName,
                    pwszFATCharSet,
                    ulActMinLen,
                    ulActMaxLen);

#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // DataGen error
        {
            hr = E_FAIL;
        }
    }


#ifndef _MAC

    if(S_OK == hr)
    {
       // Convert WCHAR to TCHAR

       hr = WStrToTStr(pwszName, &ptszName);

       DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
    }

#endif //_MAC

    if (S_OK == hr)
    {
        ulNameLen = _tcslen(ptszName);

        // Construct the full name

        *pptszName = new TCHAR[ulNameLen + 1];

        if(NULL == *pptszName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        _tcscpy(*pptszName, ptszName);
    }

    // Clean up

    if (NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if (NULL != pwszName)
    {
        delete pwszName;
        pwszName = NULL;
    }

    if (NULL != pwszFATCharSet)
    {
        delete pwszFATCharSet;
        pwszFATCharSet = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenerateRandomStreamData
//
//  Synopsis:   Generates a random data using datagen object.
//
//  Arguments:  [pgds] - Pointer to DG_STRING object.
//              [pptszName] - Pointer to pointer to returned string.
//              [ulMinLen] - Minimum length of string
//              [ulMaxLen] - Maximum length of string
//
//  Returns:    HRESULT.  S_OK if everything goes ok, error code otherwise.
//
//  History:    30-Mar-98  SCousens   Created from GenerateRandomName
//
//  Notes:      
//              -ulMaxLen is defaulted, so you dont need to specify 
//               both ulMinLen and ulMaxLen if you want a random buffer 
//               of a given length.
//              -If ulMaxLen is less than ulMinLen, buffer will be
//               ulMinLen bytes in length.
//              -Generate a buffer upto CB_STMDATA_DATABUFFER bytes in 
//               length. Copy this buffer multiple times into actual 
//               returned buffer.
//              -Alphabet currently ASCII 1-255
//--------------------------------------------------------------------------
HRESULT GenerateRandomStreamData(
    DG_STRING   *pgds,
    LPTSTR      *pptszData,
    ULONG       ulMinLen,
    ULONG       ulMaxLen)
{
    HRESULT     hr          =   S_OK;
    UINT        x;
    USHORT      usErr       =   0;
    ULONG       cbBuffer    =   0;
    ULONG       ulBufferLen =   0;
    ULONG       ulRndStart  =   0;
    ULONG       ulBufStart  =   0;
    LPBYTE      pbDataBuf   =   0;
    LPBYTE      pbRndBuffer =   0;
    DG_INTEGER  *dgi;  //we need to generate random numbers
#ifdef _MAC
    CHAR        szCharSet[CB_STMDATA_CHARSET];
#else
    WCHAR       szCharSet[CB_STMDATA_CHARSET];
#endif //_MAC

    DH_FUNCENTRY (NULL, DH_LVL_DFLIB, TEXT("GenerateRandomStreamData"));

    DH_VDATEPTRIN (pgds, DG_STRING) ;
    DH_VDATEPTROUT (pptszData, LPTSTR) ;

    DH_ASSERT (NULL != pgds);
    DH_ASSERT (NULL != pptszData);

    // use seed from given dgs, its the best we can do...
    dgi = new DG_INTEGER (pgds->GetSeed ());
    if (NULL == dgi)
    {
        hr = E_OUTOFMEMORY;
    }
    DH_HRCHECK (hr, TEXT("new DG_INTEGER"));

    if (S_OK == hr)
    {
        // Initialize out parameter.
        *pptszData = NULL;

        // Sanity check.  Min length for name must be <= maximum length.
        // if used default params, make max same as min (it will be 0)
        if (ulMaxLen < ulMinLen)
        {
            ulMaxLen =  ulMinLen;
        }

        // If Maximum length provided is 0, then default to 512 (BUGBUG: hardcoded) 
        // If Minimum length provided is 0, then use 1 
        ulMaxLen = (ulMaxLen == 0 ? 512 : ulMaxLen);
        ulMinLen = (ulMinLen == 0 ? 1 : ulMinLen);

        // Initialize character set (BUGBUG currenly only ASCII 01-255)
        for (x=0; x<CB_STMDATA_CHARSET-1; x++)
        {
            szCharSet[x] = x+1; //omit NULL to start
        }

        // this is how many chars we will be putting into the stream.
        // since dg_string::Generate chooses, and we are bypassin that,
        // we need to choose a number between ulminlen, ulmaxlen.
        dgi->Generate (&ulBufferLen, ulMinLen, ulMaxLen);

        // If needed buffer is smaller than our buffer, 
        // just generate that many bytes.
        cbBuffer = min (CB_STMDATA_DATABUFFER, ulBufferLen);

        // make our buffer
#ifdef _MAC
        usErr = pgds->Generate(
                (UCHAR **)&pbRndBuffer, // force compiler to chose the right
                (UCHAR *)szCharSet,     // version of Generate
                cbBuffer / sizeof (TCHAR),   // need chars
                cbBuffer / sizeof (TCHAR));  // cbBuffer is bytes
#else
        usErr = pgds->Generate(
                (LPWSTR*)&pbRndBuffer,
                szCharSet,
                cbBuffer+1 / sizeof (TCHAR),    // need chars
                cbBuffer+1 / sizeof (TCHAR));   // cbBuffer is bytes
#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // DataGen error
        {
            hr = E_FAIL;
        }
        DH_HRCHECK (hr, TEXT("pgds::Generate"));
    }

    // now allocate the data buffer
    if (S_OK == hr)
    {
        pbDataBuf = new BYTE[ulBufferLen];
        if (NULL == pbDataBuf)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new BYTE"));
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("Data buffer (%#x) - allocated %x bytes, (%d bytes)"),
                pbDataBuf,
                ulBufferLen,
                ulBufferLen));
    }


    if (S_OK == hr)
    {
        for (ulBufStart=0; ulBufStart<ulBufferLen; ulBufStart+=cbBuffer)
        {
            //generate a random starting point
            dgi->Generate (&ulRndStart, 
                    0, 
                    min (CB_STMDATA_DATABUFFER, ulBufferLen));

            //  Copy from rnd spot to end of buffer (provided we need it all)
            cbBuffer = min (CB_STMDATA_DATABUFFER-ulRndStart, ulBufferLen-ulBufStart);
            MoveMemory (&pbDataBuf[ulBufStart], 
                    &pbRndBuffer[ulRndStart], 
                    cbBuffer);
            ulBufStart+=cbBuffer;

            //  Copy from begin of buffer to rnd spot (provided we need it)
            cbBuffer = min (ulRndStart, ulBufferLen-ulBufStart);
            if (0 != cbBuffer)
            {
                MoveMemory (&pbDataBuf[ulBufStart], 
                        pbRndBuffer, 
                        cbBuffer);
            }
        }
    }

    if (S_OK == hr)
    {
        *pptszData = (LPTSTR)pbDataBuf;
    }

    // Clean up
    delete []pbRndBuffer;

    return hr;
}

//-------------------------------------------------------------------------
//  Function:   ParseVirtualDFAndOpenAllSubStgsStms 
//
//  Synopsis:   Given a storage, this function will recurse down the
//              tree, opening all substorages and streams.
//
//  Arguments:  [pvcn]      - Pointer to VirtualCtrNode 
//              [dwStgMode] - Mode to open sub-storages
//              [dwStmMode] - Mode to open streams
//
//  Returns:    HRESULT
//
//  History:    27-January-97  SCousens    Created.
//
//  Notes:      - provided VirtualCtrNode must already be open.
//              - ALL substgs and stms must be closed before
//                calling this, else access violations may occur

HRESULT ParseVirtualDFAndOpenAllSubStgsStms (VirtualCtrNode * pvcn,
        DWORD dwStgMode, 
        DWORD dwStmMode)
{
    HRESULT          hr = S_OK;
    VirtualCtrNode * pvcnTrav = NULL;
    VirtualStmNode * pvsnTrav = NULL;

    DH_VDATEPTRIN (pvcn, VirtualCtrNode);
    DH_ASSERT (NULL != pvcn->GetIStoragePointer ()); //if not open _pstg will be null

    // enumerate and open all stms in current stg.
    pvsnTrav = pvcn->GetFirstChildVirtualStmNode ();
    while(NULL != pvsnTrav && S_OK == hr)
    {
        if (NULL == pvsnTrav->GetIStreamPointer ())
        {
            hr = pvsnTrav->Open(NULL, dwStmMode, NULL);
        }
        pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode ();
    }

    // enumerate and open all stgs in current stg.
    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();
    while(NULL != pvcnTrav && S_OK == hr)
    {
        if (NULL == pvcnTrav->GetIStoragePointer ())
        {
            hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
        }
        //  then recursively open all elements in just opened stg.
        if (S_OK == hr)
        {
            hr = ParseVirtualDFAndOpenAllSubStgsStms (pvcnTrav, 
                    dwStgMode, 
                    dwStmMode);
        }
        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode ();
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetDocFileName
//
//  Synopsis:   Figures out name of docfile given the seed
//
//  Arguments:   [in] ulSeed        - the seed value
//              [out] ptszDocName   - docfile name (needs to be deleted [])
//
//  Returns:    S_OK if all goes well, another HRESULT if not.
//
//  History:    19-Mar-97   SCousens   Created
//
//  Notes:      We can take advantage of the way VirtualDF gets the
//              docfile name. Its the first string generated.
//
//--------------------------------------------------------------------------

HRESULT GetDocFileName (ULONG ulSeed, LPTSTR *pptszDocName)
{
    HRESULT    hr       = E_FAIL;
    DG_STRING *pdgs     = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_TRACE1, TEXT("GetDocFileName"));
    DH_VDATEPTROUT (pptszDocName, LPTSTR);
    DH_ASSERT (NULL != ulSeed);

    // init out stuff
    *pptszDocName = NULL;

    //get our datagen
    pdgs = new DG_STRING (ulSeed);

    if (NULL != pdgs)
    {
        // Generate random name for root 
        hr = GenerateRandomName(
                pdgs,
                MINLENGTH,
                MAXLENGTH,
                pptszDocName);
        DH_HRCHECK (hr, TEXT("GenerateRandomName")) ;
    }

    // cleanup
    delete pdgs;

    return hr;
}

//-------------------------------------------------------------------------
//  Function:   CommitRandomVirtualCtrNodeStg
//
//  Synopsis:   Commits a VirtualCtrNode's IStorage and all ascedant
//              IStorages. This traverses through all the parents
//              and commit them excluding the root IStorage
//
//  Arguments:  [pvcn]          - Pointer to VirtualCtrNode whose IStorage
//                                is to be commited
//              [grfCommitMode] - Commit mode
//
//  Returns:    HRESULT
//
//  History:    16-Apr-97  BogdanT    Created.
//
//  Notes:
//--------------------------------------------------------------------------

HRESULT CommitRandomVirtualCtrNodeStg(VirtualCtrNode  *pvcn, 
                                      DWORD           grfCommitMode)
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnTrav       =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CommitRandomVirtualCtrNodeStg"));

    DH_VDATEPTRIN(pvcn, PVCTRNODE) ;

    DH_ASSERT(NULL != pvcn);
    pvcnTrav = pvcn;

    if(S_OK == hr)
    {
        while((NULL != pvcnTrav->GetParentVirtualCtrNode()) && (S_OK == hr))
        {
            hr = pvcnTrav->Commit(grfCommitMode);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }
    }

    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\filebyts\ilkbdf.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       ilkbdf.cxx
//
//  Contents:   Implementation for docfile based on ILockBytes class.
//
//  Classes:    ilkbdf.cxx 
//
//  Functions:  GenerateVirtualDF 
//              GenerateVirtualDFRoot 
//
//  History:    3-Aug-96    Narindk     Created 
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "ilkbhdr.hxx"

//----------------------------------------------------------------------------
//  Member:     GenerateVirtualDF
//
//  Synopsis:   Creates a DocFile based on ILockBytes, size of which is
//              based on the ChanceDocFile created prior to this.
//
//  Arguments:  [pChanceDF] - Pointer to ChanceDocFile tree 
//              [ppDocRoot] - Returned root of DocFile tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   31-July-96   Created
//
//  Notes:      This function differs fro base class GenerateVirtualDF in
//              the way that it creates a ILockBytes instance and then call
//              GenerateVirtualDFRoot on that custom ILockBytes instance.
// 
//              This function calls GenerateVirtualDFRoot to generate docfile 
//              tree's root and GrowDFTree to generate rest of the
//              tree. If the function succeeds, it returns pointer to root
//              of DocFile generated in ppDocRoot parameter.
//              - Get seed from ChanceDocFile tree and construct DG_INTEGER &
//                DG_UNICODE objects.
//              - Get the modes for creating various storages/streams from thw
//                ChanceDocFile tree.
//              - Get name of rootdocfile, if given, from chancedocfile tree, 
//                else generate a random docfile name.
//              - Create an instance of custom ILockBytes and initialize the
//                same.
//              - Call GenerateDFRoot passing it also the custom ILOckBytes
//                generated above 
//              - Call GrowDFTree
//              - If successful, assign root of new DF in *ppDocRoot. 
//---------------------------------------------------------------------------

HRESULT ILockBytesDF::GenerateVirtualDF(
    ChanceDF        *pChanceDF, 
    VirtualCtrNode  **ppvcnRoot)
{
    HRESULT             hr                  =   S_OK;
    LPTSTR              ptszName            =   NULL;
    CFileBytes          *pCFileBytes        =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenerateILockBytesDF"));

    DH_VDATEPTRIN(pChanceDF, ChanceDF) ;

    DH_ASSERT(NULL != pChanceDF);
    DH_ASSERT(NULL != ppvcnRoot);

    if(S_OK == hr)
    {
        *ppvcnRoot = NULL;

        // Create a DataGen obj of type DG_INTEGER that will allow us to fill 
        // count parameters of DocFile tree components, excepting those 
        // which we got from already created ChanceDocFile tree.  Use the
        // same seed value as was used in creation of ChanceDocFile tree.
  
        // Get the value of seed used to create ChanceDocFile tree and store it.

        _ulSeed = pChanceDF->GetSeed();
 
        _pdgi = new(NullOnFail) DG_INTEGER(_ulSeed);

        if (NULL == _pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        _pgdu = new(NullOnFail) DG_STRING(_ulSeed);

        if (NULL == _pgdu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Get the value of different creation modes.

        _dwRootMode = pChanceDF->GetRootMode();
        _dwStgMode  = pChanceDF->GetStgMode();
        _dwStmMode  = pChanceDF->GetStmMode();

        // Get user provided name for DocFile, if any

        ptszName = pChanceDF->GetDocFileName();

        if(NULL != ptszName)
        {
            _ptszName = new TCHAR[_tcslen(ptszName)+1];

            if (_ptszName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(_ptszName, ptszName);
            }
        }
        else
        {
            // Create a random file name for this root. 

            hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &_ptszName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }
    }
 
    // Make new custom ILockBytes

    if (S_OK == hr)
    {
        pCFileBytes = new CFileBytes();

        if(NULL == pCFileBytes)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Initialize new custom ILockBytes
    
    if (S_OK == hr)
    {
        hr = pCFileBytes->Init(_ptszName, OF_CREATE|OF_READWRITE);

        DH_HRCHECK(hr, TEXT("CFileBytes::Init")) ;
    }

    if (S_OK == hr)
    {
        // Generates the root DocFile tree.

        hr = GenerateVirtualDFRoot(pChanceDF->GetChanceDFRoot(), pCFileBytes);

        DH_HRCHECK(hr, TEXT("GenerateDFRoot")) ;
    }

    if (S_OK == hr)
    {
        // Generate DF tree based on the ChanceDF tree.

        hr = GrowVirtualDFTree(pChanceDF->GetChanceDFRoot(), _pvcnRoot);

        DH_HRCHECK(hr, TEXT("GrowDFTree")) ;
    }

    // Fill the out parameter

    if(S_OK == hr)
    {
        _pCFileBytes = pCFileBytes;

        *ppvcnRoot = _pvcnRoot;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     ILockBytesDF::GenerateRoot, protected
//
//  Synopsis:   Creates the root stg for the DocFile
//
//  Arguments:  [pcnRoot] - Pointer to root of ChanceDocFile tree 
//              [pCFileBytes] - Pointer to custom ILockBytes
//
//  Returns:    HRESULT 
//
//  History:    Narindk   31-July-96   Created
//
//  Notes:      This function differs from base class's GenerateVirtualDF in
//              the way that it calls VirtualCtrNode's CreateRootOnCustomILock
//              Bytes method to generate the docfile, rather than CreateRoot.
//              Thereby the root docfile is created upon custom ILockBytes
//              rather than default OLE provided ILockBytes.
//
//              - Create VirtualCtrNode and Initialize it based on ChanceNode
//                data. 
//              - Create real IStorage corresponding to this node 
//              - Creates VirtualStmNodes/IStreams corresponding to this stg 
//                node, if required.
//---------------------------------------------------------------------------

HRESULT ILockBytesDF::GenerateVirtualDFRoot(
    ChanceNode  *pcnRoot, 
    CFileBytes  *pCFileBytes)
{
    HRESULT hr      =   S_OK;

    DH_VDATEPTRIN(pcnRoot, ChanceNode) ; 
    DH_VDATEPTRIN(pCFileBytes, CFileBytes) ;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GenerateDFRoot"));

    DH_ASSERT(NULL != pcnRoot);
    DH_ASSERT(NULL != pCFileBytes);
   
    // Generate VirtualCtrNode for the root node.

    if(S_OK == hr)
    {
        _pvcnRoot = new VirtualCtrNode();

        if (NULL == _pvcnRoot)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = _pvcnRoot->Init(
                _ptszName,
                pcnRoot->GetChanceNodeStgCount(),
                pcnRoot->GetChanceNodeStmCount());

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }
 
    // Call StgCreateDocfileOnILockBytes to create a corresponding Root Storage
    // on disk.

    if(S_OK == hr)
    {
        hr = _pvcnRoot->CreateRootOnCustomILockBytes(
                _dwRootMode | STGM_CREATE,
                pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgCreateDocfileOnILockBytes")) ;
    }

 
    if ((S_OK == hr) && (0 != pcnRoot->GetChanceNodeStmCount()))
    {
       hr = AppendVirtualStmNodesToVirtualCtrNode(
                pcnRoot->GetChanceNodeStmCount(),
                _pvcnRoot,
                pcnRoot->GetChanceNodeStmMinSize(),
                pcnRoot->GetChanceNodeStmMaxSize());

       DH_HRCHECK(hr, TEXT("AppendStmToStg")) ;

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\utest\utest.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//  All rights reserved.
//
//--------------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop

#include <debdlg.h>

// global defines

#define LOG_FILE_NAME "/t:utest"

// Debug Object

DH_DEFINE;

// Usage:  If you would like to use CreateFromParams to create ChanceDocFile
//         tree, give arguments e.g
//         test /seed:2 /dfdepth:0-9 /dfstg:1-11 /dfstm:10-30 /dfstmlen:0-222 
//         /dfRootCrMode:dirReadWriteShEx
//
//         if want to use CreateFromSize but through CreateFromParams e.g.
//         test /seed:2 /dfsize:tiny
//          
//         If the seed value given is zero, the datagen objects computes the
//         seed value to be used based on current time and some other compu-
//         tations, so the resulting docfiles wouldn't be same in different
//         instants of time if seed is 0 even if all the other parameters are
//         same.  With seed value other than zero, the docfiles produced at 
//         different instances of time would be identical with other parameters //         remaining same.
// 

//
//-------------------------------------------------------------------
//
//  Function:   main 
//
//  Synopsis:   entry point for unit test program 
//
//  Parameters: [argc]          - Argument count
//              [argv]          - Arguments
//
//  Returns:    void 
//
//  History:    20-Apr-1996     Narindk     Created 
//
//--------------------------------------------------------------------

VOID __cdecl main(int argc, char *argv[])
{
    HRESULT     hr              = S_OK;
    ChanceDF    *pTestChanceDF  = NULL;
    VirtualDF   *pTestVirtualDF = NULL;
    VirtualCtrNode *pVirtualDFRoot = NULL;

    // Initialize our log object

    DH_CREATELOGCMDLINE( LOG_FILE_NAME ) ;
    DH_SETLOGLOC(DH_LOC_LOG) ;
   
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::main"));
 
    //  Initialize the OLE server.
 
    hr = CoInitialize(NULL);

    if (S_OK != hr)
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("test: CoInitialize failed, hr=0x%08x\n"), hr));

        return;
    }

    // I:   Using CreateFromSize within program to generate DocFile

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
   
    if (S_OK == hr)
    {
        // To check from CreateFromSize

        hr = pTestChanceDF->CreateFromSize(DF_HUGE, 2);
        
        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromSize")) ;
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
 
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        
        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("DocFile - CreateFromSize - successfully created.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("DocFile - CreateFromSize - failed.\n")));

    }

    // Cleanup

    if(NULL != pTestChanceDF)
    {
        hr = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());   
 
        DH_HRCHECK(hr, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    if(NULL != pTestVirtualDF)
    {    
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);    

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // II:   Using CreateFromParams to generate DocFile
    //       a.  Using CreateFromParams to call Create. e.g.
    //           test /seed:3 /dfdepth:0-9 /dfstg:1-11 /dfstm:10-30 
    //           /dfstmlen:0-222  /dfRootCrMode:4114 /dfStgCrMode:4114
    //           /dfStmCrMode:4114
    //       b.  Using CreateFromParams to call CreateFromSize. e.g.
    //           test /seed:2 /dfsize:tiny
    //       c.  Using CreateFromParams to call CreateFromFile (NYI). e.g.
    //           test /seed:4 /dftemp:myfile
    //      
    //       if you do not provide the parameters, but still call the function
    //       CreateFromParam, all default values would be used.

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
   
    // Can pass the arguments after simulating command line arguments in
    // the test itself.
        
    if (S_OK == hr)
    {
        // To create it from Params.

         hr = pTestChanceDF->CreateFromParams(argc, argv);

         DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
 
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("DocFile - CreateFromParams - successfully created.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("DocFile - CreateFromParams - failed.\n")));
    }

    // Cleanup

    if(NULL != pTestChanceDF)
    {
        hr = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());    

        DH_HRCHECK(hr, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    if(NULL != pTestVirtualDF)
    {    
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);    

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // III:   Using CreateFromSize within program to generate DocFile. 
    //        Do the following operations:
 
    //   a.      Close the root node and open root node again. Check it succeeds

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        // To check from CreateFromSize

        hr = pTestChanceDF->CreateFromSize(DF_MEDIUM, 3);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromSize")) ;
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("DocFile - CreateFromSize - successfully created.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("DocFile - CreateFromSize - failed.\n")));
    }

    //   a.  Close the root node and open root node again. Check it succeeds

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("Root Storage closed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("Root Storage couldn't be closed successfully.\n")));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  , 
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("Root Storage opened successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("Root Storage couldn't be opened successfully.\n")));
    }

    //   b.  Close the root node's stream and open it again. Check it succeeds

    VirtualStmNode  *pvsnTest = NULL;
    VirtualCtrNode  *pvcnTest = NULL;

    if (S_OK == hr)
    {
        // This call will return us the root of VirtualDocFileTree becoz'
        // we are passing NULL for second parameter.
 
        hr = GetVirtualStgNodeForTest(pTestVirtualDF, NULL, &pvcnTest, 0); 
        DH_HRCHECK(hr, TEXT("GetVirtualStgNodeForTest")) ;
    }

    if (S_OK == hr)
    {
        // This call will return us the first stream of pvcnTest VirtualCtrNode 
        // as we are passing zero for fourth parameter.

        hr = GetVirtualStmNodeForTest(pvcnTest, &pvsnTest, 0); 
        DH_HRCHECK(hr, TEXT("GetVirtualStgNodeForTest")) ;
    }

    if (S_OK == hr)
    {
        hr = pvsnTest->Close();
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualStmNode::Close completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualStmNode::Close couldn't complete successfully.\n")));
    }

    if (S_OK == hr)
    {
        hr = pvsnTest->Open(
                NULL, 
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  , 
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualStmNode::Open completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualStmNode::Open couldn't complete successfully.\n")));
    }

    // c.1  Set the size of the stream

    DWORD       dwStreamSize   = 512;
    ULARGE_INTEGER   uli;

    ULISet32(uli, dwStreamSize);

    if (S_OK == hr)
    {
        hr =  pvsnTest->SetSize(uli);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::SetSize function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::SetSize function wasn't successful.\n")));
    }


    // c.2  Write into opened test stream. Check it succeeds

    DWORD       dwSize      = 0;
    DWORD       dwBufSize   = 512;
    DWORD       dwWritten   = 0;
    ULONG       *lpBuf      = NULL;
    const ULONG kulPattern  = 0xABCDABCD; // Arbitrary fill pattern for stream

    lpBuf = new ULONG [dwBufSize];

    if (lpBuf == NULL)
    {
       hr = E_OUTOFMEMORY;
    }

    for (dwSize = 0; dwSize < dwBufSize; dwSize++)
    {
       lpBuf[dwSize] = kulPattern;
    }

    if (S_OK == hr)
    {
        hr =  pvsnTest->Write(lpBuf, dwBufSize, &dwWritten);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::Write function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::Write function wasn't successful.\n")));
    }

    // Cleanup

    delete []lpBuf;

    //   d.  Seek test stream. Check it succeeds

    LARGE_INTEGER   lint;

    memset(&lint, 0, sizeof(LARGE_INTEGER));

    //  Position the stream header to the begining

    if (S_OK == hr)
    {
        hr = pvsnTest->Seek(lint, STREAM_SEEK_SET, NULL);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::Seek function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::Seek function wasn't successful.\n")));
    }
    
    //   e.  Read test stream. Check it succeeds

    DWORD   dwRead = 0;
    ULONG   *lpStr  = NULL;

    lpStr = new ULONG [dwBufSize];

    if (lpBuf == NULL)
    {
       hr = E_OUTOFMEMORY;
    }

    if ( S_OK == hr )
    {
        //  Read the stream.

        hr = pvsnTest->Read(lpStr, dwBufSize, &dwRead);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::Read function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::Read function wasn't successful.\n")));
    }

    // Cleanup

    delete []lpStr;

    //   f.  Close the root node's substorage and open it again. Check it 
    //        succeeds

    VirtualCtrNode  *pvcnTest1 = NULL;
    ULONG           cChildCnt = 0;

    if (S_OK == hr)
    {
        // This call will return us the first substorage root of 
        // VirtualDocFileTree if its exists.  We may use pvcnTest
        // which points to the root of virtual docfile tree. 

        cChildCnt = 
           pVirtualDFRoot->GetVirtualCtrNodeChildrenCount();
       
        /* 
        _ftprintf(stdout, 
                  TEXT("No of substorages in RootStorage are %lu"),
                  cChildCnt);
        */

        if(cChildCnt <= 0)
        {
            hr = S_FALSE;
        
            DH_LOG((
                LOG_INFO,
                TEXT("No substorages of this storage")));
        }
    }
 
    if (S_OK == hr)
    {
        // Get the first substorage of the root.

        hr = GetVirtualStgNodeForTest(
               pTestVirtualDF,pVirtualDFRoot,&pvcnTest1,1); 

        DH_HRCHECK(hr, TEXT("GetVirtualStgNodeForTest")) ;
    }

    if (S_OK == hr)
    {
        hr = pvcnTest1->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::Close completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::Close couldn't complete successfully.\n")));
    }

    if (S_OK == hr)
    {
        hr = pvcnTest1->Open(
                NULL, 
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::Open completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::Open couldn't complete successfully.\n")));
    }
  
    // f: Adds a new storage to an existing storage.  We would add another
    //    substorage to our root storage for the test.

    VirtualCtrNode *pvcnNewStorage = NULL;
    LPWSTR         pNewStgName     = L"NewTestStg";
    if(S_OK == hr)
    {
        hr = AddStorage(
                pVirtualDFRoot,
                &pvcnNewStorage, 
                pNewStgName,  
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_CREATE |
                STGM_DIRECT); 
 
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    } 
    
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::AddStorage completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::AddStorage couldn't complete successfully.\n")));
    }
  
    // g: Deletes a storage in an existing storage.  We would delete first 
    //    child substorage of our root storage for the test.

    if(S_OK == hr)
    {
        hr = DestroyStorage(
                pTestVirtualDF, 
                pVirtualDFRoot->GetFirstChildVirtualCtrNode());
 
        DH_HRCHECK(hr, TEXT("DeleteStorage")) ;
    } 
    
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::DestroyStorage completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::DestroyStorage couldn't complete successfully.\n")));
    }

    // h: Adds a new stream to an existing storage.  We would add a stream to
    //    newly created substorage "NewTestStg" of our root storage for test.

    VirtualStmNode *pvsnNewStream = NULL;
    LPWSTR         pNewStmName     = L"NewTestStm";
    ULONG          cbNewSize       = 20;

    if(S_OK == hr)
    {
        hr = AddStream(
                pvcnNewStorage,
                &pvsnNewStream, 
                pNewStmName, 
                cbNewSize, 
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_CREATE |
                STGM_DIRECT); 
 
        DH_HRCHECK(hr, TEXT("AddStream")) ;
    } 
    
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualStmNode::AddStream completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualStmNode::AddStream couldn't complete successfully.\n")));
    }
 
    // i:  Renames the newly created storage from NewTestStg to NewRenStg

    LPCWSTR         pRenStgName     = L"RenStg";

    // First close the opened storage that we want to rename

    if (S_OK == hr)
    {
        hr = pvcnNewStorage->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        hr = pvcnNewStorage->Rename(pRenStgName); 
    }
 
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStorage::RenameElement completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStorage::RenameElement couldn't complete successfully.\n")));
    }
 
    // Final Cleanup

    if(NULL != pTestChanceDF)
    {
        hr = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());    

        DH_HRCHECK(hr, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    if(NULL != pTestVirtualDF)
    {    
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);    

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Uninitialize OLE
        
    CoUninitialize();

    // Log test results and quit

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("Test program executed successfully.\n")));
        exit(0);
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("Test program execution failed.\n")));
        exit(1);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\vsnode.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       vsnode.cxx
//
//  Contents:   Implementation for in-memory Virtual Stream Node class.
//
//  Classes:    VirtualStmNode (vsn)
//
//  Functions:  VirtualStmNode()
//              ~VirtualStmNode
//              Init
//              AppendSisterStm
//              Create
//              Read
//              Write
//              Open
//              Close
//              Seek
//              SetSize
//              Commit
//              Revert
//              Stat
//              CopyTo
//              AddRefCount
//              QueryInterface
//              LockRegion
//              UnlockRegion
//              Clone
//              Rename
//              Destroy
//
//              NOTE: All above functions are public
//
//  History:    DeanE   21-Mar-96   Created
//              Narindk 24-Apr-96   Added more functions. 
//              georgis 02-Apr-98   UpdateCRC
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration

DH_DECLARE;

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::VirtualStmNode, public
//
//  Synopsis:   Constructor.  No work done here and this method cannot
//              fail.  See ::Init method for real initialization work.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualStmNode::VirtualStmNode() : _ptszName(NULL),
                                   _cb(0),
                                   _pvsnSister(NULL),
                                   _pvcnParent(NULL),
                                   _pstm(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualStmNode"));
    _dwCRC.dwCRCName = CRC_PRECONDITION;
    _dwCRC.dwCRCData = CRC_PRECONDITION;
    _dwCRC.dwCRCSum = CRC_PRECONDITION;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::~VirtualStmNode, public
//
//  Synopsis:   Destructor.  Frees resources associated with this object,
//              including closing the storage if open and removing this
//              tree from memory.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualStmNode::~VirtualStmNode()
{
    ULONG   ulRef   =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::~VirtualStmNode"));

    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

    if ( NULL != _pstm )
    {
        ulRef = _pstm->Release();

        // Object is being destructed, assert if reference count is non zero.
        DH_ASSERT(0 == ulRef);

        _pstm = NULL;
    }
}


//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Init, public
//
//  Synopsis:   Initializes a stream node - does not open or create the
//              actual stream.
//
//  Arguments:  [tszName]    - Name of this stream
//              [cb]         - Size of this stream
//
//  Returns:    S_OK if node initialized successfully, otherwise an error.
//
//  History:    DeanE   21-Mar-96   Created
//              Narindk 24-Apr-96   Enhanced
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Init( LPTSTR tszName, ULONG cb)
{
    HRESULT hr = S_OK;

    DH_VDATESTRINGPTR(tszName);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Init"));

    DH_ASSERT(NULL != tszName);

    if(S_OK == hr)
    {
        _ptszName = new TCHAR[_tcslen(tszName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, tszName);
            _cb = cb;
        }
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::AppendSisterStm, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' sister
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   Narindk     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::AppendSisterStm(VirtualStmNode *pvsnNew)
{
    HRESULT         hr          = S_OK;
    VirtualStmNode  *pvsnTrav   = this;

    DH_VDATEPTRIN(pvsnNew, VirtualStmNode);
 
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::AppendSisterStm"));

    DH_ASSERT(NULL != pvsnNew);

    if(S_OK == hr)
    {
        // Find the last sister in the chain 
    
        while (NULL != pvsnTrav->_pvsnSister)
        {
            pvsnTrav = pvsnTrav->_pvsnSister;
        }

        // Append the new node as a sister of the last node,
        // and make the new node point to this nodes parent as it's parent

        pvsnTrav->_pvsnSister = pvsnNew;
        pvsnNew->_pvcnParent = pvsnTrav->_pvcnParent;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Create, public
//
//  Synopsis:   Wrapper for IStorage::CreateStream that will create and
//              open a new IStream object within this storage object.
//
//  Arguments:  [grfmode] -     Access mode for creating & opening new storage
//                              object.
//              [dwReserved1] - Reserved by OLE for future use, must be zero.
//              [dwReserved2] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK                    Stream created successfully. 
//              STG_E_ACCESSDENIED      Insufficient permissions to create.
//              STG_E_INVALIDPOINTER    Bad pointer was passed in.
//              STG_E_FILEALREADYEXISTS File with specified name exists and
//                                      mode is set to STGM_FAILIFTHERE.
//              STG_TOOMANYOPENFILES    too many open files 
//              STG_E_INSUFFICIENTMEMORY Out of memory.
//              STG_E_INVALIDFLAG       Unsuppoeted value in grfmode.
//              STG_E_INVALIDPARAMETER  Invalid parameter.
//              STG_E_INVALIDNAME       Invalid value for ptcsName.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//
//  History:    18-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Create(
    DWORD       grfMode,
    DWORD       dwReserved1,
    DWORD       dwReserved2)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_ASSERT(0 == dwReserved1);
    DH_ASSERT(0 == dwReserved2);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Create"));

    DH_ASSERT(NULL != _pvcnParent);
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->CreateStream(
                pOleStrTemp, 
                grfMode, 
                dwReserved1, 
                dwReserved2, 
                &_pstm);

        DH_HRCHECK(hr, TEXT("IStorage::CreateStream")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("CreateStream:%s"), _ptszName));

    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Read, public
//
//  Synopsis:   Reads data from the stream starting at current seek pointer.
//
//  Arguments:  [pv] - Points to buffer in which stream data should be stored.
//              [cb] - Specifies number of bytes to read from the stream.
//              [pcbRead] - Points to the number if bytes actually read from
//                     from the stream.  Caller can specify it as NULL if not
//                     interested in this value.
//
//  Returns:    S_OK                    Data successfully read from stream. 
//              S_FALSE                 Data couldn't be read from the stream.
//              STG_E_ACCESSDENIED      Insufficient access.
//              STG_E_INVALIDPOINTER    Bad pointer passed in pv.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//              STG_E_WRITEFAULT        Disk error during a write operaion.
//              Other errors            Any ILockBytes or system errors.
//
//  History:    18-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Read(
    PVOID       pv, 
    ULONG       cb, 
    ULONG       *pcbRead)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Read"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Read(pv, cb, pcbRead);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Read"));
    }

    // BUBUG: To check invalid parameter checking, may have to remove DH_
    // validate macros.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Write, public
//
//  Synopsis:   Writes data cb bytes from buffer pointed to by pv into stream 
//              starting at current seek pointer.
//
//  Arguments:  [pv] - Points to buffer containing data to be written to stream 
//              [cb] - Specifies number of bytes to write into the stream.
//              [pcbWritten] - Points to the number if bytes actually written  
//                     to the stream.  Caller can specify it as NULL if not
//                     interested in this value.
//
//  Returns:    S_OK                    Data successfully read from stream. 
//              S_E_MEDIUMFULL          No space left on device. 
//              STG_E_ACCESSDENIED      Insufficient access.
//              STG_E_CANTSAVE          Data cannot be written for reasons other
//                                      than no access or space.
//              STG_E_INVALIDPOINTER    Bad pointer passed in pv.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//              STG_E_WRITEFAULT        Disk error during a write operaion.
//              Other errors            Any ILockBytes or system errors.
//
//  History:    18-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Write(
    PVOID       pv, 
    ULONG       cb, 
    ULONG       *pcbWritten)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Write"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Write(pv, cb, pcbWritten);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Write"));
    }

    if (( S_OK == hr) && (NULL != pcbWritten))
    {
        if (cb != *pcbWritten)
        {
            hr = E_FAIL;

            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::Write - bytes: Expected=%lu, Actual=%lu"),
                cb,
                *pcbWritten));

            DH_ASSERT(
                !TEXT("Expected and actual bytes written mismatch!"));
        }
    }

    // BUBUG: To check invalid parameter checking, may have to remove DH_
    // validate macros.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Open, public
//
//  Synopsis:   Opens an existing named stream according to grfMode.
//                                   OLE doesn't support opening streams in
//              transacted mode, also doesn't allow opening the same stream 
//              from same open IStorage instance.
//
//  Arguments:  [pvReserved1] - Reserved for future use.  Must be NULL.
//              [grfmode]     - Mode in which stream should be opened.
//              [dwReserved2] - Reserved for future use.  Must be NULL. 
//
//  Returns:    HRESULT 
//              S_OK                    Stream was opened successfully.
//              STG_E_ACCESSDENIED      Insufficient access to open stream.
//              STG_E_FILENOTFOUND      Stream of specified name doesn't exist.
//              STG_E_INVALIDFLAG       Unsupported value in grfMode.
//              STG_E_INVALIDNAME       Invalid name.
//              STG_E_INVALIDPOINTER    Bad pointer passed in pv.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//              STG_E_INVALIDPARAMETER  Invalid parameter.
//
//  History:    NarindK   24-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Open(
    PVOID       pvReserved1, 
    DWORD       grfmode, 
    DWORD       dwReserved2)
{
    HRESULT     hr          = S_OK;
    LPSTREAM    pstm        = NULL;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Open"));

    DH_ASSERT(NULL == pvReserved1);
    DH_ASSERT(0 == dwReserved2);

    DH_ASSERT(NULL != _pvcnParent);
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->OpenStream(pOleStrTemp,
                              pvReserved1,
                              grfmode,
                              dwReserved2,
                              &pstm);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStream"));
        DH_TRACE ((DH_LVL_DFLIB, TEXT("OpenStream:%s"), _ptszName));
    }
   
    if((S_OK == hr) && (NULL == _pstm))
    {
        _pstm = pstm;
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::Open"));

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Close, public
//
//  Synopsis:   Closes an open stream.  
//
//  Arguments:  none 
//
//  Returns:    HRESULT 
//
//  History:    NarindK   25-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Close()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulRef   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Close"));

    DH_ASSERT(NULL != _pstm);

    // When we create the stream, it is open.  We do not call release
    // on _pstm normally till the VirtualStmNode object is destructed, or
    // if explicitly this function is used to close the stream.

    if ( NULL != _pstm )
    {
        ulRef = _pstm->Release();
    }
    else
    {
        DH_ASSERT(!TEXT("_pstm is already NULL!"));
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::Close"));

    if(0 == ulRef)
    {
        _pstm = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Seek, public
//
//  Synopsis:   Adjusts the location of seek pointer on the stream.  
//
//  Arguments:  [dlibMove]
//              [dwOrigin]
//              [plibNewPosition] 
//
//  Returns:    HRESULT 
//
//  History:    NarindK   25-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Seek( 
    LARGE_INTEGER   dlibMove,
    DWORD           dwOrigin,
    ULARGE_INTEGER  *plibNewPosition)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Seek"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Seek(dlibMove, dwOrigin, plibNewPosition);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::SetSize, public
//
//  Synopsis:   Changes the size of the stream. 
//
//  Arguments:  [libNewSize]    Specifies new size of stream 
//
//  Returns:    HRESULT
//              S_OK                   Stream size was successfully changed.
//              STG_E_MEDIUMFULL       Lack of space prohibited change of size
//              STG_E_INVALIDFUNCTIONS High DWORD of libNewSize != 0
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   29-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::SetSize(ULARGE_INTEGER  libNewSize)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::SetSize"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->SetSize(libNewSize);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Commit, public
//
//  Synopsis:   Commits any changes made to IStorage object containing the 
//              stream. 
//
//  Arguments:  [grfCommitFlags]    Controls how obect is committed to IStorage 
//
//  Returns:    HRESULT
//              S_OK                   Stream successfully committed.
//              STG_E_MEDIUMFULL       Commit failde due to lack of space 
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   29-Apr-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Commit(DWORD  grfCommitFlags)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Commit"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Commit(grfCommitFlags);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Commit"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Revert, public
//
//  Synopsis:   Discards any changes made to stream object since it was opened
//              or last committed in transacted mode.  This function is a noop
//              in direct mode. 
//
//  Arguments:  none
//
//  Returns:    HRESULT
//              S_OK                   Stream successfully committed.
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   29-Apr-96   Created
//
//  Notes:      OLE doesn't support IStream objects being opened in transacted
//              mode, os most applications don't need to call this function.
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Revert()
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Revert"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Revert();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Revert"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Stat, public
//
//  Synopsis:   Returns relevant statistics concerning this open stream. 
//
//  Arguments:  [pStatStg] - pointer to STATSTG structure.
//              [grfStatFlag] - Controls levels of returned statistics.
//
//  Returns:    S_OK                Stastics were successfully returned.
//              STG_E_ACCESSDENIED  Stm cannot be accessed.
//              STG_E_REVERTED      Object invalidated by a revert operation
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.
////
//  History:    NarindK   8-May-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Stat( 
    STATSTG         *pStatStg,
    DWORD           grfStatFlag)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Stat"));

    DH_ASSERT(_pstm != NULL);
    DH_ASSERT(NULL != pStatStg);
    DH_ASSERT((
        (grfStatFlag == STATFLAG_DEFAULT) || 
        (grfStatFlag == STATFLAG_NONAME)));


    if(S_OK == hr)
    {
        hr = _pstm->Stat(pStatStg, grfStatFlag);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat"));
    }

    // BUGBUG:  May remove to need DH_ assert macros to do invalid parameter
    // checking.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::CopyTo, public
//
//  Synopsis:   Copies data from one stream to another strea, starting at the
//              current seek pointer in each stream. 
//
//  Arguments:  [pvsn] - pointer to VirtualStmNode into whose stream the data
//                       should be copied into. 
//              [cb] -   Specifies number of bytes to be read from source stream
//              [pcbRead] - Contains the number of bytes actually read from the
//                       source stream.
//              [pcbWritten] - Contains number of bytes actually written to the
//                       destination stream.
//
//  Returns:    S_OK                Stream successfully copied.
//              STG_E_MEDIUMFULL    Lack of space prohibited copy.
//              STG_E_READFAULT     Disk error during read.
//              STG_E_WRITEFAULT    Disk error during write opearion.
//              STG_E_INVALIDPOINTER     Invalid pointer.
//              STG_E_REVERTED      Object invalidated by a revert operation
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              Other errors
//
//  History:    NarindK   9-May-96   Created
//
//  Notes:      BUGBUG: Currently not updating the _cb datasize member
//              of virtualstmnode objects involved. required?
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::CopyTo( 
    VirtualStmNode  *pvsnDest,
    ULARGE_INTEGER  cb,
    ULARGE_INTEGER  *pcbRead,
    ULARGE_INTEGER  *pcbWritten)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::CopyTo"));

    DH_VDATEPTROUT(pvsnDest, VirtualStmNode);
    DH_ASSERT(NULL != _pstm);
    DH_ASSERT(NULL != pvsnDest);
    DH_ASSERT(NULL != pvsnDest->_pstm);

    if(S_OK == hr)
    {
        hr = _pstm->CopyTo(pvsnDest->_pstm, cb, pcbRead, pcbWritten);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::CopyTo"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::AddRefCount, public
//
//  Synopsis:   Increments the reference count on IStream object. 
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::AddRefCount()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulTmp   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::AddRefCount"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        ulTmp = _pstm->AddRef();
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::AddRefCount"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::QueryInterface, public
//
//  Synopsis:   Returns pointers to supported objects. 
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::QueryInterface(
    REFIID      riid, 
    LPVOID      *ppvObj)
{
    HRESULT     hr      =   S_OK;

    DH_VDATEPTROUT(ppvObj, IUnknown *) ;
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::QueryInterface"));

    DH_ASSERT(NULL != ppvObj);
    DH_ASSERT(NULL != _pstm);

    if(S_OK == hr)
    {
        // Initilze the out parameter

        *ppvObj = NULL;

        hr = _pstm->QueryInterface(riid, ppvObj);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::QueryInterface"));

    if(S_OK == hr)
    {
        DH_ASSERT(NULL != *ppvObj);
    }
    else
    {
        DH_ASSERT(NULL == *ppvObj);
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::LockRegion, public
//
//  Synopsis:   Locks a range of bytes in the stream. 
//
//  Arguments:  [libOffset] - Specifies beginning of region to lock.
//              [cb]        - Specifies length of region to be locked in bytes.
//              [dwLockType]- Specifies kind of lock beng requested. 
//
//  Returns:    HRESULT
//              S_OK                    Range of bytes was successfully locked.
//              STG_E_INVALIDFUNCTION   Function not supported in this release
//              STG_E_LOCKVIOLATION     Requested lock supported, but can't be
//                                      granted presently becoz of existing
//                                      lock.
//
//  History:    NarindK   22-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::LockRegion(
    ULARGE_INTEGER      libOffset,
    ULARGE_INTEGER      cb,
    DWORD               dwLockType)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::LockRegion"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->LockRegion(libOffset, cb, dwLockType);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::LockRegion"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::UnlockRegion, public
//
//  Synopsis:   Unlocks a region of stream previously locked by IStream::
//              LockRegion
//
//  Arguments:  [libOffset] - Specifies beginning of region to lock.
//              [cb]        - Specifies length of region to be locked in bytes.
//              [dwLockType]- Specifies kind of lock beng requested. 
//
//  Returns:    HRESULT
//              S_OK                    Requested unlock granted.
//              STG_E_INVALIDFUNCTION   Function not supported in this release
//              STG_E_LOCKVIOLATION     Requested unlock can't be granted.
//
//  History:    NarindK   22-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::UnlockRegion(
    ULARGE_INTEGER      libOffset,
    ULARGE_INTEGER      cb,
    DWORD               dwLockType)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::UnlockRegion"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->UnlockRegion(libOffset, cb, dwLockType);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::UnlockRegion"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Clone, public
//
//  Synopsis:   Returns a new IStream object that is clone of this stream. 
//
//  Arguments:  [ppstm] -   Points to where new stream to be returned.
//
//  Returns:    HRESULT
//              S_OK                   Stream successfully copied. 
//              E_OUTOFMEMORY          Out of memory 
//              STG_E_INVALIDPOINTER    Bad pointer was passed in.
//              STG_E_INSUFFICIENTMEMORY Not enough memory 
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   22-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Clone(LPSTREAM  *ppstm)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Clone"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppstm = NULL;

        hr = _pstm->Clone(ppstm);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::Clone"));

    if(S_OK == hr)
    {
        DH_ASSERT(NULL != *ppstm);
    }
    else
    {
        DH_ASSERT(NULL == *ppstm);
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Rename, public
//
//  Synopsis:   Wrapper for IStorage::RenameElement that renames a stream  
//              contained in an Storage object subject to transaction state
//              of IStorage object. 
//
//  Arguments:  [pptcsNewName] - Points to pointer to new name for the element. 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  Named element ptcsNewName alreadys exists. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    8-July-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Rename(LPCTSTR ptcsNewName)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrOld  =   NULL;
    LPOLESTR    pOleStrNew  =   NULL;

    DH_VDATESTRINGPTR(ptcsNewName);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Rename"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrOld);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptcsNewName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptcsNewName, &pOleStrNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->RenameElement(pOleStrOld, pOleStrNew);

        DH_HRCHECK(hr, TEXT("IStorage::Rename")) ;
    }

    if(S_OK == hr)
    {
        // Change the name of VirtualStmNode i.e. its _ptszName variable also

        // First delete the old name

        if(NULL != _ptszName)
        {
            delete _ptszName;
            _ptszName = NULL;
        }

        // Now copy the new name by allocating enough memory
        _ptszName = new TCHAR[_tcslen(ptcsNewName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, ptcsNewName);
        }
    }

    // Clean up

    if(NULL != pOleStrOld)
    {
        delete pOleStrOld;
        pOleStrOld = NULL;
    }

    if(NULL != pOleStrNew)
    {
        delete pOleStrNew;
        pOleStrNew = NULL;
    }

    // BUGBUG: to do valid parameter checking, may need to change prototype
    // of function to take old name too.  Also remove DH_ validation checking

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Destroy, public
//
//  Synopsis:   Wrapper for IStorage::DestroyElement that removes a stream
//              from this storage, subject to transaction mode in which it
//              was opened.  The wrapper for IStorage::DestoryElement that
//              destroys a storage from this storage is in VirtualCtrNode::
//              Destroy.
//
//  Arguments:  None 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    8-July-96   NarindK     Created
//
//  Notes:      The existing open instance of this element from this parent
//              instance becomes invalid after this function is called.
//
//              Use utility function DestroyStream from util.cxx that is a
//              wrapper for this function and also readjusts the VirtualDF
//              tree.
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Destroy()
{
    HRESULT         hr              =   S_OK;
    LPOLESTR        pOleStrTemp     =   NULL;
    VirtualStmNode  *pvsnTemp       =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Destroy"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);
    
    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->DestroyElement(pOleStrTemp);

        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::CalculateCRCs
//
//  Synopsis:   Updates the name and data crc
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  History:    02-Apr-98 georgis   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::UpdateCRC(DWORD dwChunkSize)
{
    HRESULT hr=S_OK;
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::UpdateCRC"));

    // Calculate the CRC for the stream data
    hr=CalculateStreamDataCRC(_pstm,0,&_dwCRC.dwCRCData,dwChunkSize);
    DH_HRCHECK(hr, TEXT("CalculateStreamDataCRC"));

    // Calculate the CRC for the stream name
    if ( S_OK == hr )
    {
        hr = CalculateCRCForName(_ptszName, &_dwCRC.dwCRCName);
        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    // Munge in dwCRCSum
    _dwCRC.dwCRCSum=CRC_PRECONDITION;
    MUNGECRC(_dwCRC.dwCRCSum,_dwCRC.dwCRCData);
    MUNGECRC(_dwCRC.dwCRCSum,_dwCRC.dwCRCName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\virtdf.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       virtdf.cxx
//
//  Contents:   Implementation for in-memory Virtual Docfile class.
//
//  Classes:    VirtualDF
//
//  Functions:  VirtualDF (public)
//              ~VirtualDF (public)
//              GenerateVirtualDF (public)
//              DeleteVirtualDocFileTree (public)
//              GenerateVirtualDFRoot (protected)
//              GrowVirtualDFTree (protected)
//              DeleteVirtualDocFileSubTree (protected)
//              DeleteVirtualCtrNodeStreamTree (protected)
//              AppendVirtualStmNodesToVirtualCtrNode (protected)
//              AppendVirtualCtrNode (protected)
//              AppendVirtualStmNode (protected)
//              AdjustTreeOnStgMoveElement (public)
//              AdjustTreeOnStmMoveElement (public)
//              AdjustTreeOnStgCopyElement(public)
//              AdjustTreeOnStmCopyElement(public)
//              AdjustTreeOnCopyTo (public)
//              CopyVirtualDocFileTree (public)
//              CopyVirtualDFRooti (protected)
//              CopyGrowVirtualDFTree (protected)
//              CopyAppendVirtualStmNodesToVirtualCtrNode (protected)
//              CopyAppendVirtualCtrNode (protected)
//              CopyAppendVirtualStmNode (protected)
//              Associate (public)
//              DeleteVirtualCtrNodeStreamNode (public)
//              CommitCloseThenOpenDocfile (public)
//
//  History:    DeanE    21-Mar-96   Created
//              Narindk  22-Apr-96   Added more functions. 
//              SCousens  2-Feb-97   Added for Cnvrs/NSS 
//              SCousens  8-Apr-98   Handle stg collisions on createdf
//              georgis   2-Apr-98   Added support for large streams
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration

DH_DECLARE;

//+--------------------------------------------------------------------------
//  Member:     VirtualDF::VirtualDF, public [multiple]
//
//  Synopsis:   Constructor. This method cannot fail.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//              SCousens 2-Feb-97   Added for Cnvrs/NSS 
//---------------------------------------------------------------------------

VirtualDF::VirtualDF() : _ptszName(NULL),
                         _pvcnRoot(NULL),
                         _pdgi(NULL),
                         _pgdu(NULL),
                         _ulSeed(0),
                         _dwRootMode(0),
                         _dwStgMode(0),
                         _dwStmMode(0),
                         _dwStgType(STGTYPE_DOCFILE),
                         _pDBCSStrGen(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualDF"));
}

//+--------------------------------------------------------------------------
//  Member:     VirtualDF::VirtualDF, public [multiple]
//
//  Synopsis:   Constructor. This method cannot fail.
//
//  Arguments:  _fUseStgEx - whether to use the Ex apis
//
//  Returns:    Nothing.
//
//  History:    SCousens  4-Apr-97   Added for Cnvrs/NSS 
//---------------------------------------------------------------------------
VirtualDF::VirtualDF(STGTYPE dwStgFmt) : _ptszName(NULL),
                         _pvcnRoot(NULL),
                         _pdgi(NULL),
                         _pgdu(NULL),
                         _ulSeed(0),
                         _dwRootMode(0),
                         _dwStgMode(0),
                         _dwStmMode(0),
                         _dwStgType(dwStgFmt),
                         _pDBCSStrGen(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualDF"));
}


//+--------------------------------------------------------------------------
//  Member:     VirtualDF::~VirtualDF, public
//
//  Synopsis:   Destructor.  Frees resources associated with this docfile.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualDF::~VirtualDF()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::~VirtualDF"));

    if(NULL != _pdgi)
    {
        delete _pdgi;
        _pdgi = NULL;
    }

    if(NULL != _pgdu)
    {
        delete _pgdu;
        _pgdu = NULL;
    }

    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

    if(NULL != _pDBCSStrGen)
    {
        delete _pDBCSStrGen;
        _pDBCSStrGen = NULL;
    }
}


//----------------------------------------------------------------------------
//  Member:     VirtualDF::GenerateVirtualDF, public
//
//  Synopsis:   Creates a VirtualDocFile tree consisting of VirtualCtrNode
//              node(s) and VirtualStmNodes(s) based on the ChanceDocFile
//              created prior to this.
//
//  Arguments:  [pChanceDF] - Pointer to ChanceDocFile tree 
//              [ppvcnRoot] - Returned root of VirtualDocFile tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   22-Apr-96   Created
//              SCousens   2-Feb-97   Added for Cnvrs/NSS 
//
//  Notes:      This function calls GenerateVirtualDFRoot to generate Virtual
//              DF tree's root and GrowVirtualDFTree to generate rest of the
//              tree. If the function succeeds, it returns pointer to the root
//              of VirtualDocFile generated in ppvcnRoot parameter.
//              - Get seed from ChanceDocFile tree and construct DG_INTEGER &
//                DG_STRING objects.
//              - Get the modes for creating various storages/streams from thw
//                ChanceDocFile tree.
//              - Get name of rootdocfile, if given, from chancedocfile tree.
//              - Call GenerateVirtualDFRoot.
//              - Call GrowVirtualDFTree
//              - If successful, assign root of new VirtualDF in *ppvcnRoot. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::GenerateVirtualDF(
    ChanceDF        *pChanceDF, 
    VirtualCtrNode  **ppvcnRoot)
{
    HRESULT             hr                  =   S_OK;
    LPTSTR              ptszName            =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GenerateVirtualDF"));

    DH_VDATEPTRIN(pChanceDF, ChanceDF) ;
    DH_VDATEPTROUT(ppvcnRoot, PVCTRNODE) ;

    DH_ASSERT(NULL != pChanceDF);
    DH_ASSERT(NULL != ppvcnRoot);


    if(S_OK == hr)
    {
        *ppvcnRoot = NULL;

        // Create a DataGen obj of type DG_INTEGER that will allow us to fill 
        // count parameters of VirtualDocFile tree components, excepting those 
        // which we got from already created ChanceDocFile tree.  Use the
        // same seed value as was used in creation of ChanceDocFile tree.
  
        // Get the value of seed used to create ChanceDocFile tree and store it.

        _ulSeed = pChanceDF->GetSeed();
 
        _pdgi = new(NullOnFail) DG_INTEGER(_ulSeed);

        if (NULL == _pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random strings.

        _pgdu = new(NullOnFail) DG_STRING(_ulSeed);

        if (NULL == _pgdu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Get the value of different creation modes.

        _dwRootMode = pChanceDF->GetRootMode();
        _dwStgMode  = pChanceDF->GetStgMode();
        _dwStmMode  = pChanceDF->GetStmMode();

        // Get user provided name for DocFile, if any

        ptszName = pChanceDF->GetDocFileName();

        if(NULL != ptszName)
        {
            _ptszName = new TCHAR[_tcslen(ptszName)+1];

            if (_ptszName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(_ptszName, ptszName);
            }
        }
    }

    if (S_OK == hr)
    {
        // Generates the root VirtualCtrNode for the VirtualDocFile tree.

        hr = GenerateVirtualDFRoot(pChanceDF->_pcnRoot);

        DH_HRCHECK(hr, TEXT("GenerateVirtualDFRoot")) ;
    }

    if (S_OK == hr)
    {
        // Generate remaining VirtualDF tree based on the ChanceDF tree.

        hr = GrowVirtualDFTree(pChanceDF->_pcnRoot, _pvcnRoot);

        DH_HRCHECK(hr, TEXT("GrowVirtualDFTree")) ;
    }

    // Fill the out parameter

    if(S_OK == hr)
    {
        *ppvcnRoot = _pvcnRoot;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::GenerateVirtualDFRoot, protected
//
//  Synopsis:   Creates the root VirtualCtrNode for the VirtualDocFile tree. 
//
//  Arguments:  [pcnRoot] - Pointer to root of ChanceDocFile tree 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   22-Apr-96   Created
//              SCousens   2-Feb-97   Added for Cnvrs/NSS 
//
//  Notes:      - Generate a random name for RootDocFile if it is not provided
//                in the test.
//              - Creates VirtualCtrNode object and initializes it with info
//                based on corresponding ChanceDocFile root.
//              - Create real IStorage corresponding to this VirtualCtrNode.
//              - Creates IStreams corresponding to this VirtualCtrNode, if
//                required.
//              - Calculates in memory CRC for this IStorage and assigns it 
//                to _dwCRC variable.
//---------------------------------------------------------------------------

HRESULT VirtualDF::GenerateVirtualDFRoot(ChanceNode *pcnRoot)
{
    HRESULT hr      =   S_OK;

    DH_VDATEPTRIN(pcnRoot, ChanceNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GenerateVirtualDFRoot"));

    DH_ASSERT(NULL != pcnRoot);
    
    if(S_OK == hr)
    {
        if(NULL == _ptszName) 
        {
            // Create a random file name for this root. 

            // Hack for FE DBCS systems

            _pDBCSStrGen = new(NullOnFail) CDBCSStringGen;

            if (NULL == _pDBCSStrGen)
            {
                hr = E_OUTOFMEMORY;
            }

            if(S_OK == hr)
            {
                hr = _pDBCSStrGen->Init(_ulSeed);
            }

            if((S_OK == hr) && (_pDBCSStrGen->SystemIsDBCS()))
            {
                hr = _pDBCSStrGen->GenerateRandomFileName(&_ptszName);

                if(S_OK != hr)
                {
                    DH_TRACE((DH_LVL_TRACE1, 
                             TEXT("Unable to generate DBCS name. Fall back to GenerateRandomName")));

                    hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &_ptszName);    
                }
            }
            else
            {
                hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &_ptszName);
            }

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }
    }
 
    // Generate VirtualCtrNode for the root node.

    if(S_OK == hr)
    {
        _pvcnRoot = new VirtualCtrNode();

        if (NULL == _pvcnRoot)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = _pvcnRoot->Init(
                _ptszName, 
                pcnRoot->_cStorages, 
                pcnRoot->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    // Call VirtualCtrNode::CreateRoot to create a corresponding Root Storage
    // on disk.

    if(S_OK == hr)
    {
        if (STGTYPE_DOCFILE == _dwStgType)
        {
            hr = _pvcnRoot->CreateRoot(
                    _dwRootMode | STGM_CREATE,
                    0);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CreateRoot")) ;
        }
        else
        {
            hr = _pvcnRoot->CreateRootEx(
                    _dwRootMode | STGM_CREATE,
                    STGFMT_GENERIC,
                    0,
                    NULL,
                    NULL);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CreateRootEx")) ;
        }

        // Generate VirtualStmNode(s) depending upon if root has streams in it.

        DH_ASSERT((pcnRoot->_cStreams) == (_pvcnRoot->_cStreams));
    }

 
    if ((S_OK == hr) && (0 != _pvcnRoot->_cStreams))
    {
       hr = AppendVirtualStmNodesToVirtualCtrNode(
                _pvcnRoot->_cStreams,
                _pvcnRoot,
                pcnRoot->_cbMinStream,
                pcnRoot->_cbMaxStream);

       DH_HRCHECK(hr, TEXT("AppendVirtualStmNodesToVirtualCtrNode")) ;

    }

    // Calculate the CRC for storage name

    if(S_OK == hr)
    { 
        hr = CalculateInMemoryCRCForStg(_pvcnRoot, &(_pvcnRoot->_dwCRC));

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStg")) ;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::GrowVirtualDFTree, protected
//
//  Synopsis:   Creates the ramaining VirtualDocFile tree. 
//
//  Arguments:  [pcnCurrent] - Pointer to current node of ChanceDocFile tree 
//              [pvcnCurrent] - Pointer to current VirtualCtrNode
//
//  Returns:    HRESULT 
//
//  History:    Narindk   13-Jun-96   Made into a new function 
//  
//  Notes:      The VirtualDocFile tree is created based on the corresponding
//              ChanceDocFile tree.  This function is called either from the
//              GenerateVirtualDF function or may call itself recursively. The
//              ChanceDocFile tree is traversed from the top down, and based
//              on its contents, a VirtualDF tree is generated topdown. 
//
//              First assign the passed in ChanceNode to pcnCurrentChild and
//              passed in VirtualCtrNode to pvcnFisrtBorn variables.
//              Loop till pcnCurrentChild's _pcnChild is non NULL & hr is S_OK
//              - Call AppendVirtualCtrNode to create a new node pvcnNextBorn
//                based on info from corresponding ChanceDocFile node and
//                append it to pvcnFirstBorn in the tree being generated.
//              - Assign pcnCurrentChild's _pcnChild to pcnCurrentSister.
//              -  Loop till pcnCurrentSister's _pcnSister is non NULL & hr=S_OK
//                      - Call AppendVirtualCtrNode to create a new node pvcn
//                        NextBornSister and append it to pvcnFirstBorn. Pl.
//                        note that append function would take care to append
//                        it to its older sister.
//                      - Assign pcnCurrentSister's _pcnSister to  variable
//                        pcnCurrentSister. 
//                      - If pcnCurrentSister's _pcnChild is non NULL, then
//                        make a recursive call to itself GrowVirtualDFTree. 
//                      - Reinitialize pvcnNextBornSister to NULL & go back to
//                        top of this inner loop and repeat.
//              - Assign  pvcnNextBorn to pvcnFirstBorn and reinitailize pvcn
//                NextBorn to NULL.
//              - Assign pcnCurrentChild's _pcnChild to pcnCurrentChild.
//              - Go to top of outer loop and repeat. 
//---------------------------------------------------------------------------
HRESULT VirtualDF::GrowVirtualDFTree(
    ChanceNode      *pcnCurrent,
    VirtualCtrNode  *pvcnCurrent)
{
    HRESULT             hr                  =   S_OK;
    VirtualCtrNode      *pvcnFirstBorn      =   NULL;
    VirtualCtrNode      *pvcnNextBorn       =   NULL;
    VirtualCtrNode      *pvcnNextBornSister =   NULL;
    ChanceNode          *pcnCurrentSister   =   NULL;
    ChanceNode          *pcnCurrentChild    =   NULL;

    DH_VDATEPTRIN(pcnCurrent, ChanceNode) ; 
    DH_VDATEPTRIN(pvcnCurrent, VirtualCtrNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GrowVirtualDFTree"));

    DH_ASSERT(NULL != pcnCurrent);
    DH_ASSERT(NULL != pvcnCurrent);

    if(S_OK == hr)
    {
        pvcnFirstBorn = pvcnCurrent;
        pcnCurrentChild = pcnCurrent;
    }

    while((NULL != pcnCurrentChild->_pcnChild) && (S_OK == hr))
    {
        int x=10;
        do 
        {
            hr = AppendVirtualCtrNode(
                    pvcnFirstBorn,
                    pcnCurrentChild->_pcnChild,
                    &pvcnNextBorn); 
            DH_HRCHECK(hr, TEXT("AppendVirtualCtrNode")) ;
            if (STG_E_FILEALREADYEXISTS == hr)
            {
                // delete the ctr node so we can try again.
                DeleteVirtualDocFileTree (pvcnNextBorn);
                // DeleteVirtualDocFileTree decrements the _cChildren,
                // but since no child was added in the first place,
                // restore it to its original value so we can try again.
                pvcnFirstBorn->_cChildren++;
                DH_TRACE ((DH_LVL_ALWAYS, 
                        TEXT("Above ERROR and ASSERT are OK.")));
            }
        } while (STG_E_FILEALREADYEXISTS == hr && --x);

        if(S_OK == hr) 
        {
            pcnCurrentSister = pcnCurrentChild->_pcnChild;

            while((NULL != pcnCurrentSister->_pcnSister) && (S_OK == hr))
            {
                int x=10;
                do
                {
                    hr = AppendVirtualCtrNode(
                             pvcnFirstBorn,
                             pcnCurrentSister->_pcnSister,
                             &pvcnNextBornSister);
                    DH_HRCHECK(hr, TEXT("AppendVirtualCtrNode")) ;
                    if (STG_E_FILEALREADYEXISTS == hr)
                    {
                        // delete the ctr node so we can try again.
                        DeleteVirtualDocFileTree (pvcnNextBornSister);
                        // DeleteVirtualDocFileTree decrements the _cChildren,
                        // but since no child was added in the first place,
                        // restore it to its original value so we can try again.
                        pvcnFirstBorn->_cChildren++;
                        DH_TRACE ((DH_LVL_ALWAYS, 
                                TEXT("Above ERROR and ASSERT are OK.")));
                    }
                } while (STG_E_FILEALREADYEXISTS == hr && --x);

                pcnCurrentSister = pcnCurrentSister->_pcnSister;

                // Check if there are any children of this sister node, if
                // yes, then make a recursive call to self.  

                if(NULL != pcnCurrentSister->_pcnChild)
                {
                    hr = GrowVirtualDFTree(
                            pcnCurrentSister,
                            pvcnNextBornSister);

                    DH_HRCHECK(hr, TEXT("GrowVirtualDFTree"));
                }

                // Reinitialize the variables

                pvcnNextBornSister = NULL;
            }
                
         }
         pvcnFirstBorn = pvcnNextBorn;
         pvcnNextBorn = NULL;

         pcnCurrentChild = pcnCurrentChild->_pcnChild;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AppendVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualCtrNode to VirtualDocFile tree 
//              being created. 
//
//  Arguments:  [pvcnParent] - Parent VirtualCtrNode for the new VirtualCtrNode
//              [pcnCurrent] - Corresponding ChanceNode in ChanceDocFile tree.  
//              [ppvcnNew] -   Pointer to pointer to new VirtualCtrNode to be 
//                             created.
//  Returns:    HRESULT 
//
//  History:    Narindk   23-Apr-96   Created
//
//  Notes:      - Generate a random name for VirtualCtrNode 
//              - Creates VirtualCtrNode object and initializes it with info
//                based on corresponding ChanceDocFile node.
//              - Appends this node to the VirtualDF tree being generated.
//              - Create real IStorage corresponding to this VirtualCtrNode.
//              - Creates IStreams corresponding to this VirtualCtrNode, if
//                required.
//              - Calculates in memory CRC for this IStorage and assigns it 
//                to _dwCRC variable.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AppendVirtualCtrNode(
    VirtualCtrNode *pvcnParent,
    ChanceNode     *pcnCurrent,
    VirtualCtrNode **ppvcnNew) 
{
    HRESULT         hr              =   S_OK;
    LPTSTR          ptcsName        =   NULL ;
    VirtualCtrNode  *pvcnOldSister  =   NULL;

    DH_VDATEPTROUT(ppvcnNew, PVCTRNODE) ; 
    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pcnCurrent, ChanceNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("AppendVirtualCtrNode"));
 
    DH_ASSERT(NULL != pvcnParent);
    DH_ASSERT(NULL != ppvcnNew);
    DH_ASSERT(NULL != pcnCurrent);

    if(S_OK == hr)
    { 
        *ppvcnNew = NULL;

        hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &ptcsName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    { 
        // Allocate and Initialize new VirtualCtrNode

        *ppvcnNew = new VirtualCtrNode();
       
        if (NULL == *ppvcnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvcnNew)->Init(
                ptcsName, 
                pcnCurrent->_cStorages, 
                pcnCurrent->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    // Append new VirtualCtr Node

    if(S_OK == hr)
    {
        if(NULL == pvcnParent->_pvcnChild)
        {
            hr = pvcnParent->AppendChildCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendChildCtr")) ;
        }
        else
        {
            pvcnOldSister = pvcnParent->_pvcnChild;
            while(NULL != pvcnOldSister->_pvcnSister)
            {
                pvcnOldSister = pvcnOldSister->_pvcnSister;
            }

            hr = pvcnOldSister->AppendSisterCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendSisterCtr")) ;
        }
    }
     
    // Call VirtualCtrNode::Create to create a corresponding Storage on disk.
    if(S_OK == hr)
    {
        hr = (*ppvcnNew)->Create(
                _dwStgMode | STGM_CREATE,
                0,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Create")) ;

        // Generate VirtualStmNode(s) depending upon if it has streams in it.
        DH_ASSERT((pcnCurrent->_cStreams) == ((*ppvcnNew)->_cStreams));
    }

    if ((S_OK == hr) && (0 != (*ppvcnNew)->_cStreams))
    {
       hr = AppendVirtualStmNodesToVirtualCtrNode(
                (*ppvcnNew)->_cStreams, 
                *ppvcnNew,
                pcnCurrent->_cbMinStream,
                pcnCurrent->_cbMaxStream);

       DH_HRCHECK(hr, TEXT("AppendVirtualStmNodesToVirtualCtrNode")) ;
    }

    // Calculate the CRC for storage name

    if(S_OK == hr)
    { 
        hr = CalculateInMemoryCRCForStg(*ppvcnNew, &((*ppvcnNew)->_dwCRC));

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStg")) ;
    }

    // Cleanup  
    
    if(NULL != ptcsName)
    {
        delete ptcsName;
        ptcsName = NULL;
    }
 
    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AppendVirtualStmNodesToVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualStmNode(s) to VirtualCtrNode 
//
//  Arguments:  [cStreams] -     Number of streams to be created 
//              [pvcn]     -     Pointer to VirtualCtrNode for which the streams
//                               need to be created and appended.
//              [cbMinStream] -  Minimum size of created stream. 
//              [cbMaxStream] -  Maximum size of created stream. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   23-Apr-96   Created
//
//  Notes:      if number of streams to be created and appended to parent 
//              VirtualCtrNode pvcn is not zero, then loop till cStreams is
//              not equal to zero.
//                  - Call AppendVirtualStmNode to create a new VirtualStmNode
//                    and append it to parent VirtualCtrNode.  Pl. note that
//                    this function would take care if the newly created node
//                    need to be appended to older VirtualStmNode sister.
//                  - Decrement cStreams and o back to top of loop & repeat.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AppendVirtualStmNodesToVirtualCtrNode(
    ULONG           cStreams,
    VirtualCtrNode  *pvcn,
    ULONG           cbMinStream,
    ULONG           cbMaxStream)
{
    HRESULT         hr              =   S_OK;

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ; 

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AppendVirtualStmNodesToVirtualCtrNode"));
 
    DH_ASSERT(0 != cStreams);
    DH_ASSERT(NULL != pvcn);

    while((S_OK == hr) && (0 != cStreams))
    {
        hr = AppendVirtualStmNode(
                pvcn, 
                cbMinStream, 
                cbMaxStream);

        DH_HRCHECK(hr, TEXT("AppendVirtualStmNode")) ;

        cStreams--;
    }

    return hr;
}
 
//----------------------------------------------------------------------------
//  Member:     VirtualDF::AppendVirtualStmNode, protected
//
//  Synopsis:   Creates and appends first VirtualStmNode to VirtualCtrNode 
//
//  Arguments:  [pvcnParent] - Pointer to VirtualCtrNode for which the streams
//                             need to be created and appended. 
//              [cbMinStream] -  Minimum size of created stream. 
//              [cbMaxStream] -  Maximum size of created stream. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   23-Apr-96   Created
//              georgis   02-Apr-98   Added support for large streams
//
//  Notes:      - Generate a random name for VirtualStmNode 
//              - Generates a random size for stream based on inforamtion
//                from corresponding ChanceDocFile tree node.
//              - Creates VirtualStmNode object and initializes it with above
//                info
//              - Appends this node to the parent VirtualCtrNode.
//              - Create real IStream corresponding to this VirtualStmNode.
//              - Set the size of stream based on size calculated above.
//              - Write into the stream random data of above size
//              - Calculates in memory CRC for this IStream and assigns it 
//                to _dwCRC variable.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AppendVirtualStmNode(
    VirtualCtrNode *pvcnParent,
    ULONG          cbMinStream,
    ULONG          cbMaxStream)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnNew        =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;
    ULONG           cb              =   0;
    USHORT          usErr           =   0;
    LPTSTR          ptcsName        =   NULL ;
    BYTE            *pBuffer        =   NULL ;
    ULONG           culWritten      =   0; 
    ULARGE_INTEGER  uli;
 
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::AppendVirtualStmNode"));

    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
 
    DH_ASSERT(NULL != pvcnParent);

    if (S_OK == hr)
    {
        hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &ptcsName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = _pdgi->Generate(&cb, cbMinStream, cbMaxStream);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Allocate a new VirtualStmNode

    if (S_OK == hr)
    {    
        pvsnNew = new VirtualStmNode();

        if (NULL == pvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if(S_OK == hr)
    {
        hr = pvsnNew->Init(ptcsName, cb);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Init")) ;
    }

    if(S_OK == hr)
    { 

        if(NULL == pvcnParent->_pvsnStream)
        {
            // Append it to parent storage
 
            hr = pvcnParent->AppendFirstChildStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendFirstChildStm")) ;
        }
        else
        {
            pvsnOldSister = pvcnParent->_pvsnStream;

            while(NULL != pvsnOldSister->_pvsnSister)
            {
                pvsnOldSister = pvsnOldSister->_pvsnSister;
            }

            // Append it to preceding sister stream 
 
            hr = pvsnOldSister->AppendSisterStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::AppendSisterStm")) ;
        }
    }

    // Call VirtualStmNode::Create to create a corresponding Stream on disk.

    if(S_OK == hr)
    {
        // Since in OLE code: simpstg.cxx, it makes the following comparison:
        //   if (grfMode != (STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
        //      return STG_E_INVALIDFLAG;
        // We can't pass _dwStmMode | STGM_CREATE like in normal mode, 
        // otherwise we will get STG_E_INVALIDFLAG error.

        if (_dwRootMode & STGM_SIMPLE)
        { 
            hr = pvsnNew->Create(
                    _dwStmMode | STGM_FAILIFTHERE,
                    0,
                    0);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::Create")) ;
        }
        else

        {
            hr = pvsnNew->Create(
                    _dwStmMode | STGM_CREATE | STGM_FAILIFTHERE,
                    0,
                    0);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::Create")) ;
        }


    }

    // Call VirtualStmNode::SetSize to set size of stream.

    if(S_OK == hr)
    { 
        ULISet32(uli, cb);

        hr = pvsnNew->SetSize(uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize")) ;
    }

    if(S_OK == hr)
    { 
        ULONG ulTotalWritten = 0;
        ULONG ulChunkSize =0;
        DWORD dwOffset=0;
        register DWORD dwCRC=CRC_PRECONDITION;

#if 0
        // Use for small chunks  
        hr = GenerateRandomName(_pgdu, STM_CHUNK_SIZE, STM_CHUNK_SIZE, (LPTSTR *) &pBuffer);
        DH_HRCHECK(hr, TEXT("GenerateRandomName"));
#else
		// If the chunk is very large, avoid generating many random numbers
		hr = GenerateRandomStreamData(_pgdu,(LPTSTR *) &pBuffer,STM_CHUNK_SIZE);
        DH_HRCHECK(hr, TEXT("GenerateRandomStreamData"));
#endif

        while ((S_OK == hr) && (ulTotalWritten < cb))
        {
            // Write the data from random offset to the end of the buffer 
            _pdgi->Generate(&dwOffset,0,STM_CHUNK_SIZE-2);
            ulChunkSize=min(cb-ulTotalWritten,STM_CHUNK_SIZE-dwOffset);
            
            hr = pvsnNew->Write(pBuffer+dwOffset, ulChunkSize, &culWritten);
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Write")) ;
            
			if (S_OK == hr) // Skip if we are failing
			{
				ulTotalWritten+=culWritten;

				// Calculate the CRC now, to spare aditional Read
				for (register int i=0; i<culWritten; i++)
				{
					CRC_CALC(dwCRC,(BYTE) pBuffer[dwOffset+i])
				};
			}
        }

        // Update the vsnode created
        pvsnNew->_dwCRC.dwCRCData=dwCRC;

        hr=CalculateCRCForName(pvsnNew->_ptszName,&pvsnNew->_dwCRC.dwCRCName);
        DH_HRCHECK(hr, TEXT("CalculateCRCForName"));

        pvsnNew->_dwCRC.dwCRCSum=CRC_PRECONDITION;
        MUNGECRC(pvsnNew->_dwCRC.dwCRCSum,pvsnNew->_dwCRC.dwCRCData);
        MUNGECRC(pvsnNew->_dwCRC.dwCRCSum,pvsnNew->_dwCRC.dwCRCName);
    }

    // Since for simple mode docfile, access to streams follows a linear
    // pattern, it needs to close the current stream before creating and
    // open another stream. So for simple mode docfile, after the docfile
    // is created, all the elements are closed except the root storage.
    // For the normal mode docfile, after it is created, all the elements
    // are kept open.

    if ((S_OK == hr) && (_dwRootMode & STGM_SIMPLE))
    {
        hr = pvsnNew->Close();
        
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }


    // Cleanup

    if(NULL != ptcsName)
    {    
        delete ptcsName;
        ptcsName = NULL;
    }

    if(NULL != pBuffer)
    {    
        delete pBuffer;
        pBuffer = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualDocFileTree, public
//
//  Synopsis:   Deletes the VirtualDocFileTree from the passed in Virtual
//              CtrNode node down. 
//
//  Arguments:  [pvcnTrav]   - Pointer to VirtualCtrNode from which node
//                             downwards, including itself, the tree would
//                             be deleted. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   24-Apr-96   Created
//
//  Notes:      First step is to check if the whole tree needs to be deleted or
//              just a part of it.  In case only a part of tree is to be
//              deleted, isolate the node from the remaining tree by readjusting
//              the pointers in the remaining tree.  Then call the function
//              DeleteVirtualDocFileSubTree to delete the subtree.  In case,
//              the complete tree needs to be deleted, we call the function
//              DeleteVirtualDocFileSubTree directly to delete the complete
//              tree.
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualDocFileTree(VirtualCtrNode *pvcnTrav)
{
    HRESULT hr                  =   S_OK;
    VirtualCtrNode *pTempNode   =   NULL;

    DH_VDATEPTRIN(pvcnTrav, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::DeleteVirtualDocFileTree"));
 
    DH_ASSERT(NULL != pvcnTrav);

    if(S_OK == hr)
    {
        // This basically readjusts the pointers in the tree if the passed in
        // VirtualCtrNode is not the root of the VirtualDF tree.

        if(NULL != pvcnTrav->_pvcnParent)
        {
            // Decrease the _cChildren variable of the parent VirtualCtrNode.
        
            pvcnTrav->_pvcnParent->_cChildren--;

           // Find its previous node whose pointers need readjustment.
           pTempNode = pvcnTrav->_pvcnParent->_pvcnChild;
           while ((pvcnTrav != pvcnTrav->_pvcnParent->_pvcnChild) &&
                  (pvcnTrav != pTempNode->_pvcnSister))
           {
               pTempNode = pTempNode->_pvcnSister;
               DH_ASSERT(NULL != pTempNode);
           }

           // Readjust the child pointer or sister pointer as the case may be.

           pvcnTrav->_pvcnParent->_pvcnChild = (pvcnTrav == pTempNode) ?
                pvcnTrav->_pvcnSister : pvcnTrav->_pvcnParent->_pvcnChild;
           pTempNode->_pvcnSister = pvcnTrav->_pvcnSister;
        }
    }

    if(S_OK == hr)
    {
        hr = DeleteVirtualDocFileSubTree(&pvcnTrav);

        DH_HRCHECK(hr, TEXT("DeleteVirtualDocFileSubTree")) ;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualDocFileSubTree, protected
//
//  Synopsis:   Deletes iteratively all VirtualCtrNode nodes under and including//              the passed in VirtualCtrNode and calls a function to delete
//              all VirtualStmNodes under the VirtualCtrNodes being deleted. 
//
//  Arguments:  [**ppvcnTrav]- Pointer to pointer to VirtualCtrNode from 
//                             which node under, including itself, the tree 
//                             would be deleted. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   24-Apr-96   Created
//
//  Notes:      This function is called only through DeleteVirtualDocFileTree.
// 
//              Assign the passed in VirtualCtrNode to a variable pTempRoot.
//              NULL the pTempRoot's parent.
//              Loop till the pTempRoot is not NULL to delete tree iteratively.
//                  - Assign pTempRoot to a temp variable pTempNode.
//                  - Traverse the tree to make pTempNode point to last child
//                    (_pvcnChild).
//                  - Assign pTempNode's _pvcnParent to pTempRoot
//                  - Assign the pTempRoot's _pvcnChild pointer to point to the
//                    sister of pTempNode's _pvcnSister rather than to itself,
//                    therby isolating itself.
//                  - Decrement the _cChildren of pTempRoot (used to verify).
//                  - Assign pTempNode's _pvcnSister to NULL.
//                  - if pTempNode's _pvsnStream is not NULL, call function
//                    DeleteVirtualCtrNodeStreamTree to delete all its Virtual
//                    StmNodes.
//                  - Assert to ensure the pTempNode's _cChildren and _cStreams
//                    are zero before deleting it.
//                  - Delete pTempNode.
//                  - Go back to top of loop and repeat till all nodes are
//                    deleted.             
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualDocFileSubTree(VirtualCtrNode **ppvcnTrav)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode *pTempRoot   =   NULL;
    VirtualCtrNode *pTempNode   =   NULL;

    DH_VDATEPTRIN(ppvcnTrav, PVCTRNODE) ; 
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::DeleteVirtualDocFileSubTree"));

    DH_ASSERT(NULL != *ppvcnTrav);

    if(S_OK == hr)
    {
        pTempRoot = *ppvcnTrav;
        pTempRoot->_pvcnParent = NULL;

        // This iteratives deletes the VirtualCtrNode and everything under it.

        while(NULL != pTempRoot)
        {
            pTempNode = pTempRoot;
            while(NULL != pTempNode->_pvcnChild)
            {
                pTempNode = pTempNode->_pvcnChild;
            }

            pTempRoot = pTempNode->_pvcnParent;
            if(pTempRoot != NULL)
            {
                pTempRoot->_pvcnChild = pTempNode->_pvcnSister;
            
                // Decrease the children count, this would be used to verify 
                // before deleting the VirtualCtrNode.

                pTempRoot->_cChildren--;
            }

            pTempNode->_pvcnSister = NULL;

            if(pTempNode->_pvsnStream != NULL) 
            {
                hr = DeleteVirtualCtrNodeStreamTree(pTempNode);

                DH_HRCHECK(hr, TEXT("DeleteVirtualCtrNodeStreamTree")) ;
            }

            // Confirm before deleting that all its sub child storages and
            // streams have been deleted, assert if not.
    
            DH_ASSERT(0 == pTempNode->_cChildren);
            DH_ASSERT(0 == pTempNode->_cStreams);

            delete pTempNode;
            pTempNode = NULL;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualCtrNodeStreamTree, protected
//
//  Synopsis:   Deletes iteratively all VirtualStmNodes under the given 
//              VirtualCtrNode.
//
//  Arguments:  [*pvcnTrav]- Pointer to VirtualCtrNode for which all streams
//                           need to be deleted.
//
//  Returns:    HRESULT 
//
//  History:    Narindk   24-Apr-96   Created
//
//  Notes:      Loop till pvcnTrav's _pvsnStream is not NULL 
//              - Assign a temp variable pvsnTemp to point to _pvsnStream of
//                passed in VirtualCtrNode pvcnTrav.
//              - Assign pvcnTrav's _pvsnStream to point to pvsnTemp's _pvsn
//                Sister, thereby isolating the first VirtualStmNode.
//              - Decrease the _cStreams pf pvcnTrav (used to verify).
//              - Assign pvsnTemp's _pvsnSister to NULL.
//              - Delete pvsnTemp
//              - Go back to top of loop. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualCtrNodeStreamTree(VirtualCtrNode *pvcnTrav)
{
    HRESULT         hr          =   S_OK;
    VirtualStmNode  *pvsnTemp   =   NULL; 

    DH_VDATEPTRIN(pvcnTrav, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB,TEXT("::::DeleteVirtualCtrNodeStreamTree"));

    DH_ASSERT(NULL != pvcnTrav);

    if(S_OK == hr)
    {
        // This iteratively deletes all VirtualStmNodes.

        while(NULL != pvcnTrav->_pvsnStream)
        {
            pvsnTemp = pvcnTrav->_pvsnStream;
            pvcnTrav->_pvsnStream = pvsnTemp->_pvsnSister;

            // Decrease the stream count.  This would be used to verify before
            // deleting the parent VirtualCtrNode.

            pvcnTrav->_cStreams--;

            // Delete the node.

            pvsnTemp->_pvsnSister = NULL;
            delete pvsnTemp;
            pvsnTemp = NULL;
        }
    }

    return hr;
}


//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStgMoveElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as move is operated on a IStorage element 
//
//  Arguments:  [pvcnFrom]   - Pointer to VirtualCtrNode to be moved 
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   13-May-1996   Created
//
//  Notes;      Doesn't initialize the _pstg of moved tree elements 
//              as that would require opening of those moved storages/streams.
//              This readjusts the tree by removing the moved element from
//              its original position in tree & reinserting it in tree at its 
//              new destination.  This function is not used when the root it
//              self is moved, assert if root is being moved.
//
//              1. Decrease the pvcnFrom's _pvcnParent's _cChildren count
//                 indicating that pvcnFrom is being moved.
//              2. In the tree, find its previous node whose pointers would
//                 need readjustment.  Find its older sister if it has one,
//                 adjust its _pvcnSister pointer.  Or if the node being moved
//                 is _pvcnChild of its parent _pvcnParent, then adjust the
//                 _pvcnParent's _pvcnChild to _pvcnSister of node being moved.
//              3. NULL out pvcnFrom's _pvcnParent, _pvcnSister pointers thereby
//                 isolating this VirtualCtrNode.  NULL out _pstg too since 
//                 that would have been already move to by IStorage::MoveElement//                 To call prior to calling this function.
//              4. In destination node pvcnTo, check if it's _pvcnChild is NULL.
//                 if yes, then assign pvcnFrom to _pvcnTo's _pvcnChild. If it
//                 is not NULL, then traverse through its children to reach 
//                 last _pvcnSister and assign pvcnFrom to that.
//              5. Assign pvcnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cChildren count indicating the new VirtualCtrNode
//                 being moved here. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStgMoveElement(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode *pTempNode   =   NULL;
    VirtualCtrNode *pvcnTrav    =   NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustTreeOnStgMoveElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvcnFrom);

    // Assert if this is the root that is being moved.
    DH_ASSERT(NULL != pvcnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        // Decrease the _cChildren variable of the parent VirtualCtrNode.
        
        pvcnFrom->_pvcnParent->_cChildren--;

        // Find its previous node whose pointers need readjustment.

        pTempNode = pvcnFrom->_pvcnParent->_pvcnChild;
        while ((pvcnFrom != pvcnFrom->_pvcnParent->_pvcnChild) &&
               (pvcnFrom != pTempNode->_pvcnSister))
        {
            pTempNode = pTempNode->_pvcnSister;
            DH_ASSERT(NULL != pTempNode);
        }

        // Readjust the child pointer or sister pointer as the case may be.

        pvcnFrom->_pvcnParent->_pvcnChild = (pvcnFrom == pTempNode) ?
             pvcnFrom->_pvcnSister : pvcnFrom->_pvcnParent->_pvcnChild;
        pTempNode->_pvcnSister = pvcnFrom->_pvcnSister;

        // NULL out its pointers
        pvcnFrom->_pvcnParent = NULL;
        pvcnFrom->_pvcnSister = NULL;
        pvcnFrom->_pstg = NULL;
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvcnChild)
        {
            pvcnTrav = pvcnTo->_pvcnChild;
            while(NULL != pvcnTrav->_pvcnSister)
            {
                pvcnTrav = pvcnTrav->_pvcnSister;
            }
            pvcnTrav->_pvcnSister = pvcnFrom;
        }
        else
        {
            pvcnTo->_pvcnChild = pvcnFrom;
        }
        pvcnFrom->_pvcnParent = pvcnTo;
        pvcnTo->_cChildren++;
    }

    // The storage was closed prior to its move.  So do we need to reopen it 
    // from here now from moved destination.

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStmMoveElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as move is operated on a IStream element 
//
//  Arguments:  [pvsnFrom]   - Pointer to VirtualStmNode to be moved 
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   9-July-1996   Created
//
//  Notes;      Doesn't initialize the _pstm of moved tree elements 
//              as that would require opening of the moved stream.
//              This readjusts the tree by removing the moved element from
//              its original position in tree & reinserting it in tree at its 
//              new destination.  
//
//              1. Decrease the pvcnFrom's _pvcnParent's _cStreams count
//                 indicating that pvsnFrom is being moved.
//              2. In the tree, find its previous node whose pointers would
//                 need readjustment.  Find its older sister if it has one,
//                 adjust its _pvsnSister pointer.  Or if the node being moved
//                 is _pvsnStream of its parent _pvcnParent, then adjust the
//                 _pvcnParent's _pvsnStream to _pvsnSister of node being moved.
//              3. NULL out pvsnFrom's _pvcnParent, _pvsnSister pointers thereby
//                 isolating this VirtualStmNode.  NULL out _pstm too since 
//                 that would have been already move to by IStorage::MoveElement//                 To call prior to calling this function.
//              4. In destination node pvcnTo,check if it's _pvsnStream is NULL.
//                 if yes, then assign pvsnFrom to _pvcnTo's _pvcnStream. If it
//                 is not NULL, then traverse through its stream nodes to reach 
//                 last _pvsnSister and assign pvsnFrom to that.
//              5. Assign pvsnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cStreams count indicating the new VirtualStmNode
//                 being moved here. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStmMoveElement(
    VirtualStmNode  *pvsnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT         hr          =   S_OK;
    VirtualStmNode *pTempNode   =   NULL;
    VirtualStmNode *pvsnTrav    =   NULL;

    DH_VDATEPTRIN(pvsnFrom, VirtualStmNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustTreeOnStmMoveElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvsnFrom);
    DH_ASSERT(NULL != pvsnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        // Decrease the _cStreams variable of the parent VirtualCtrNode.
        
        pvsnFrom->_pvcnParent->_cStreams--;

        // Find its previous node whose pointers need readjustment.

        pTempNode = pvsnFrom->_pvcnParent->_pvsnStream;
        while ((pvsnFrom != pvsnFrom->_pvcnParent->_pvsnStream) &&
               (pvsnFrom != pTempNode->_pvsnSister))
        {
            pTempNode = pTempNode->_pvsnSister;
            DH_ASSERT(NULL != pTempNode);
        }

        // Readjust the pointer(s) as the case may be.

        pvsnFrom->_pvcnParent->_pvsnStream = (pvsnFrom == pTempNode) ?
             pvsnFrom->_pvsnSister : pvsnFrom->_pvcnParent->_pvsnStream;
        pTempNode->_pvsnSister = pvsnFrom->_pvsnSister;

        // NULL out its pointers
        pvsnFrom->_pvcnParent = NULL;
        pvsnFrom->_pvsnSister = NULL;
        pvsnFrom->_pstm = NULL;
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvsnStream)
        {
            pvsnTrav = pvcnTo->_pvsnStream;
            while(NULL != pvsnTrav->_pvsnSister)
            {
                pvsnTrav = pvsnTrav->_pvsnSister;
            }
            pvsnTrav->_pvsnSister = pvsnFrom;
        }
        else
        {
            pvcnTo->_pvsnStream = pvsnFrom;
        }
        pvsnFrom->_pvcnParent = pvcnTo;
        pvcnTo->_cStreams++;
    }

    // The stream was closed prior to its move.  So do we need to reopen it 
    // from here now from moved destination.

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStgCopyElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as copy is operated on a IStorage element 
//
//  Arguments:  [pvcnFrom]   - Pointer to VirtualCtrNode to be moved as copy
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-1996   Created
//
//  Notes;      Doesn't initialize the _pstg's/_pstm's of copied tree elements 
//              as that would require opening of those copied storages/streams.
//              This readjusts the tree by inserting the copied element in tree
//              at its new destination.  This function is not used when the 
//              root itself is copied, assert if root is being moved.
//
//              1. Call CopyVirtualDocFileTree function to copy pvcnFrom to
//                 pvcnNew.
//              2. In destination node pvcnTo, check if it's _pvcnChild is NULL.
//                 if yes, then assign pvcnFrom to _pvcnTo's _pvcnChild. If it
//                 is not NULL, then traverse through its children to reach 
//                 last _pvcnSister and assign pvcnFrom to that.
//              3. Assign pvcnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cChildren count indicating the new VirtualCtrNode
//                 being copied here.  Also assign pvcnNew's _pvcnSister to
//                 NULL. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStgCopyElement(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT hr                  =   S_OK;
    VirtualCtrNode *pvcnTrav    =   NULL;
    VirtualCtrNode *pvcnNew     =   NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustVirtualDocFileTreeOnStgCopyElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvcnFrom);

    // Assert if this is the root that is being copied.
    DH_ASSERT(NULL != pvcnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        hr = CopyVirtualDocFileTree(pvcnFrom, NEW_STGSTM, &pvcnNew);
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvcnChild)
        {
            pvcnTrav = pvcnTo->_pvcnChild;
            while(NULL != pvcnTrav->_pvcnSister)
            {
                pvcnTrav = pvcnTrav->_pvcnSister;
            }
            pvcnTrav->_pvcnSister = pvcnNew;
        }
        else
        {
            pvcnTo->_pvcnChild = pvcnNew;
        }
        pvcnNew->_pvcnParent = pvcnTo;
        pvcnTo->_cChildren++;
        pvcnNew->_pvcnSister = NULL;
    }

    // The storage was closed prior to its copy.  So do we need to open it 
    // now from copied destination.  How about other _pstg / _pstm for 
    // copied tree?

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStmCopyElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as copy is operated on a IStream element 
//
//  Arguments:  [pvsnFrom]   - Pointer to VirtualstmNode to be moved as copy
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   9-July-1996   Created
//
//  Notes;      Doesn't initialize the _pstm of copied tree stream element 
//              as that would require opening of the copied stream.
//              This readjusts the tree by inserting the copied element in tree
//              at its new destination.  
//
//              1. Copy the VirtualStmNode to be copied to a new VirtualStmNode.
//              2. In destination node pvcnTo,check if it's _pvsnStream is NULL.
//                 if yes, then assign pvsnFrom to _pvcnTo's _pvsnStream. If it
//                 is not NULL, then traverse through its streams to reach 
//                 last _pvsnSister and assign pvsnFrom to that.
//              3. Assign pvsnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cStreams count indicating the new VirtualStmNode
//                 being copied here. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStmCopyElement(
    VirtualStmNode  *pvsnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT        hr           =   S_OK;
    VirtualStmNode *pvsnTrav    =   NULL;
    VirtualStmNode *pvsnNew     =   NULL;

    DH_VDATEPTRIN(pvsnFrom, VirtualStmNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustVirtualDocFileTreeOnStmCopyElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvsnFrom);

    // Copy the VirtualStmNode to be moved as copy

    if (S_OK == hr)
    {
        pvsnNew = new VirtualStmNode();

        if (NULL == pvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        pvsnNew->_dwCRC.dwCRCName =  pvsnFrom->_dwCRC.dwCRCName;
        pvsnNew->_dwCRC.dwCRCData =  pvsnFrom->_dwCRC.dwCRCData;
        pvsnNew->_dwCRC.dwCRCSum =  pvsnFrom->_dwCRC.dwCRCSum;

        hr = pvsnNew->Init(pvsnFrom->_ptszName, pvsnFrom->_cb);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Init")) ;
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvsnStream)
        {
            pvsnTrav = pvcnTo->_pvsnStream;
            while(NULL != pvsnTrav->_pvsnSister)
            {
                pvsnTrav = pvsnTrav->_pvsnSister;
            }
            pvsnTrav->_pvsnSister = pvsnNew;
        }
        else
        {
            pvcnTo->_pvsnStream = pvsnNew;
        }
        pvsnNew->_pvcnParent = pvcnTo;
        pvcnTo->_cStreams++;
    }

    // The stream was closed prior to its copy.  So do we need to open it 
    // now from copied destination.  

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnCopyTo, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::CopyTo 
//              is operated on a IStorage element 
//
//  Arguments:  [pvcnFrom]   - Pointer to VirtualCtrNode to be moved 
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   21-May-1996   Created
//  
//  Notes:      This function differs from VirtualDF::AdjustTreeOnStgCopyEle
//              ment bcause readjusts the tree in the lght that tree has to
//              readjusted since an IStorage elemnt is moved as copy to desti-
//              nation container by IStorage::MoveElementTo as copy.  But here,
//              we need to readjust the tree in the light thst the entire 
//              contents of an open IStorage object are copied into a dest
//              by IStorage::CopyTo
//
//              -Call CopyVirtualDocFileTree to copy everything under the node
//               pvcnFrom, where IStorage::CopyTo source is to pvcnNew.
//              -if pvcnNew has VirtualStmNode in it (_pvsnStream), then
//                  -Check if pvcnTo (dest) has _pvsnStream as NULL or not.
//                      -If not NULL, then loop to get to end of VirtualStm
//                       Nodes's _pvsnSister in the chain.
//                      -As appropriate, assign pvcnNew->_pvsnStream to the
//                       pvcnTo destination.
//                   -Adjust the _pvcnParent of pvcnNew->_pvsnStream to 
//                    point to pvcnTo and increase _cStream member of
//                    pvcnTo node.
//                   -Assign a temp variable pvsnTemp to point to the pvcnNew
//                    ->_pvsnStream and then loop through to end of all
//                    sister VirtualStmNodes and make their _pvcnParent as
//                    pvcnTo and keep on incrementing _cStreams member of
//                    pvcnTo with each new VirtualStmNode traversed.
//                   -Now all VirtualStmNodes fro pvcnNew have been copied
//                    to pvcnTo, their destination.
//              -Repeat same for any VirtualCtrNodes that pvcnNew may have.
//               if pvcnNew has VirtualCtrNode in it (_pvcnChild), then
//                  -Check if pvcnTo (dest) has _pvcnChild as NULL or not.
//                      -If not NULL, then loop to get to end of VirtualCtr
//                       Nodes's _pvcnSister in the chain.
//                      -As appropriate, assign pvcnNew->_pvcnChild to the
//                       pvcnTo destination.
//                   -Adjust the _pvcnParent of pvcnNew->_pvcnChild to 
//                    point to pvcnTo and increase _cChildren member of
//                    pvcnTo node.
//                   -Assign a temp variable pvcnTemp to point to the pvcnNew
//                    ->_pvcnChild and then loop through to end of all
//                    sister VirtualCtrNodes and make their _pvcnParent as
//                    pvcnTo and keep on incrementing _cChildren member of
//                    pvcnTo with each new VirtualCtrNode traversed.
//                   -Now all VirtualCtrNodes fro pvcnNew have been copied
//                    to pvcnTo, their destination.
//              -Now everhing under pvcnNew has been copied to pvcnTo, so
//               delete pvcnNew.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnCopyTo(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT         hr          = S_OK;
    VirtualCtrNode  *pvcnNew    = NULL;
    VirtualCtrNode  *pvcnTrav   = NULL;
    VirtualCtrNode  *pvcnTemp   = NULL;
    VirtualStmNode  *pvsnTrav   = NULL;
    VirtualStmNode  *pvsnTemp   = NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustTreeOnCopyTo"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvcnFrom);

    // Assert if this is the root that is being copied.
    DH_ASSERT(NULL != pvcnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        hr = CopyVirtualDocFileTree(pvcnFrom, NEW_STGSTM, &pvcnNew);
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnNew->_pvsnStream)
        {
            // Append these VirtualStmNode to pvcnTo VirtualCtrNode.

            // BUGBUG: what if these VirtualStmNodes have same name stream in
            //         in destination too.

            if(NULL != pvcnTo->_pvsnStream)
            {
               pvsnTrav = pvcnTo->_pvsnStream;
               while(NULL != pvsnTrav->_pvsnSister)
               {
                  pvsnTrav = pvsnTrav->_pvsnSister;
               }
               pvsnTrav->_pvsnSister = pvcnNew->_pvsnStream;
            }
            else
            {
               pvcnTo->_pvsnStream = pvcnNew->_pvsnStream;
            }
            pvcnNew->_pvsnStream->_pvcnParent = pvcnTo;
            pvcnTo->_cStreams++;
 
            if(NULL != pvsnTrav)
            { 
                pvsnTemp = pvsnTrav->_pvsnSister;
            }
            else
            {
                pvsnTemp = pvcnTo->_pvsnStream;
            }

            while(NULL != pvsnTemp->_pvsnSister)
            {
                pvsnTemp->_pvsnSister->_pvcnParent = pvcnTo;
                pvcnTo->_cStreams++;
                pvsnTemp = pvsnTemp->_pvsnSister;
            }
        }
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnNew->_pvcnChild)
        {
            // Append these storages to pvcnTo VirtualCtrNode.

            // BUGBUG: what if these VirtualCtrNodes have same name stroage in
            //         in destination too.

            if(NULL != pvcnTo->_pvcnChild)
            {
               pvcnTrav = pvcnTo->_pvcnChild;
               while(NULL != pvcnTrav->_pvcnSister)
               {
                  pvcnTrav = pvcnTrav->_pvcnSister;
               }
               pvcnTrav->_pvcnSister = pvcnNew->_pvcnChild;
            }
            else
            {
               pvcnTo->_pvcnChild = pvcnNew->_pvcnChild;
            }
            pvcnNew->_pvcnChild->_pvcnParent = pvcnTo;
            pvcnTo->_cChildren++;

            if(NULL != pvcnTrav)
            { 
                pvcnTemp = pvcnTrav->_pvcnSister;
            }
            else
            {
                pvcnTemp = pvcnTo->_pvcnChild;
            }

            while(NULL != pvcnTemp->_pvcnSister)
            {
                pvcnTemp->_pvcnSister->_pvcnParent = pvcnTo;
                pvcnTo->_cChildren++;
                pvcnTemp = pvcnTemp->_pvcnSister;
            }
        }
    }

    // All the VirtualCtrNodes and VirtualStmNodes under pvcnNew are now
    // adjusted under the pvcnTo node.  So delete the pvcnNew.

    if(NULL != pvcnNew)
    {
        pvcnNew->_pvcnChild = NULL;
        pvcnNew->_pvsnStream = NULL;

        delete pvcnNew;
        pvcnNew = NULL;
    }

    // BUGBUG: How about filling up of _pstg / _pstm fieds for copied tree 
    // nodes?  May be not required if somebody needs, these could be opened.

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyVirtualDocFileTree, public
//
//  Synopsis:   Copies VirtualDocFileTree from old root to a new root with all
//              its structure.   
//
//  Arguments:  [pvcnOldTreeRoot]  - Pointer to VirtualCtrNode to be moved 
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//              [ppvcnNewTreeRoot] - Pointer to VirtualCtrNode of new tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   19-May-1996   Created
//
//  Notes:      In case of transaction mode, where it is just needed to keep
//              a copy of virtualdocfile tree and no new IStroages/Istreams 
//              are in question, then the second parameter should be OLD_STGSTM 
//              However if say MoveTo/CopyTo where there would be new IStorages
//              /IStreams, it should be given NEW_STGSTM. 
//
//              This function call CopyVirtualDFRoot to copy root VirtualCtr
//              Node and calls CopyVirtualDFTree to copy rest of tree.
//              - Call CopyVirtualDFRoot.
//              - Call CopyGrowVirtualDFTree
//              - If successful, assign root of new VirtualDF in *ppvcnRoot. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyVirtualDocFileTree(
    VirtualCtrNode  *pvcnOldTreeRoot,
    TREEOP          treeOpType,
    VirtualCtrNode  **ppvcnNewTreeRoot)
{
    HRESULT         hr                      =   S_OK;
    VirtualCtrNode  *pvcnTempNewTreeRoot    =   NULL;

    DH_VDATEPTRIN(pvcnOldTreeRoot, VirtualCtrNode) ; 
    DH_VDATEPTROUT(ppvcnNewTreeRoot, PVCTRNODE) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyVirtualDocFileTree"));
    
    DH_ASSERT(NULL != pvcnOldTreeRoot);
    DH_ASSERT(NULL != ppvcnNewTreeRoot);

    if (S_OK == hr)
    {
        // Initialize out parameter

        *ppvcnNewTreeRoot = NULL;

        // Generates the root VirtualCtrNode for the VirtualDocFile tree.

        hr = CopyVirtualDFRoot(
                pvcnOldTreeRoot, 
                treeOpType,
                &pvcnTempNewTreeRoot); 

        DH_HRCHECK(hr, TEXT("CopyVirtualDFRoot")) ;
    }

    if (S_OK == hr)
    {
        // Generate remaining new VirtualDF tree based on old VirtualDF tree.

        hr = CopyGrowVirtualDFTree(
                pvcnOldTreeRoot, 
                pvcnTempNewTreeRoot, 
                treeOpType);

        DH_HRCHECK(hr, TEXT("CopyGrowVirtualDFTree")) ;
    }
    
    // Fill the out parameter

    if(S_OK == hr)
    {
        *ppvcnNewTreeRoot = pvcnTempNewTreeRoot;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyVirtualDFRoot, protected
//
//  Synopsis:   Creates the root VirtualCtrNode for the VirtualDocFile tree. 
//
//  Arguments:  [pvcnRootOld] - Pointer to root of old VirtualDocFile tree 
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//              [ppvcnRootNew] - Pointer to pointer to new VirtualDF tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   19-May-96   Created
//
//  Notes:      - Creates VirtualCtrNode object and initializes it with info
//                based on corresponding old source VirtualDocFile root.
//              - Calls CopyAppendVirtualStmNodesToVirtualCtrNode to append
//                VirtualStmNodes to this VirtualCtrNode, if present in old
//                source tree, so required to be copied.
//              - Copies in memory CRC for this VirtualCtrNode _dwCRC from old
//                source VirtualCtrNode.
//              - if treeOpType is OLD_STGSTM, as would be in transaction tree
//                copy procedure, when no new disk IStorages/IStreams are made,
//                this assign's new VirtualCtrNode's _pstg to be old source
//                VirtualCtrNode's _pstg.
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyVirtualDFRoot(
    VirtualCtrNode  *pvcnRootOld, 
    TREEOP          treeOpType,
    VirtualCtrNode  **ppvcnRootNew) 
{
    HRESULT hr      =   S_OK;

    DH_VDATEPTRIN(pvcnRootOld, VirtualCtrNode) ; 
    DH_VDATEPTROUT(ppvcnRootNew, PVCTRNODE) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyVirtualDFRoot"));

    DH_ASSERT(NULL != pvcnRootOld);
    DH_ASSERT(NULL != ppvcnRootNew);
    
    // Generate VirtualCtrNode for the root node.

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppvcnRootNew = NULL;

        *ppvcnRootNew = new VirtualCtrNode();

        if (NULL == *ppvcnRootNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvcnRootNew)->Init(
                pvcnRootOld->_ptszName, 
                pvcnRootOld->_cChildren, 
                pvcnRootOld->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    if ((S_OK == hr) && (0 != (*ppvcnRootNew)->_cStreams))
    {
       hr = CopyAppendVirtualStmNodesToVirtualCtrNode(
                (*ppvcnRootNew)->_cStreams,
                 *ppvcnRootNew,
                 pvcnRootOld,
                 treeOpType);

       DH_HRCHECK(hr, TEXT("CopyAppendVirtualStmNodesToVirtualCtrNode")) ;
    }

    if(S_OK == hr)
    {   
        (*ppvcnRootNew)->_dwCRC = pvcnRootOld->_dwCRC;
    
        if(OLD_STGSTM == treeOpType)
        {
            (*ppvcnRootNew)->_pstg = pvcnRootOld->_pstg;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyGrowVirtualDFTree, protected
//
//  Synopsis:   Creates the ramaining VirtualDocFile tree. 
//
//  Arguments:  [pvcnFrom] - Pointer to current node of original VirtualDocFile///                           tree 
//              [pvcnTo] -   Pointer to current VirtualCtrNode of copied Virtual
//                           DocFile tree
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   13-June-96   Created
//  
//  Notes:      The copied VirtualDocFile tree is created based on corresponding
//              original VirtualDocFile tree.  This function is called either 
//              from the CopyGenerateVirtualDF function or may call itself 
//              recursively. The original VirtualDocFile tree is traversed from
//              the top down, and based on its contents, a new VirtualDF tree 
//              is generated topdown. 
//
//              First assign the passed in pvcnFrom to pvcnCurrentChild and
//              passed in pvcnTo to pvcnFisrtBorn variables.
//              Loop till pvcnCurrentChild's _pvcnChild is non NULL & hr is S_OK
//              - Call CopyAppendVirtualCtrNode to create a new node called
//                pvcnNextBorn based on info from corresponding old pvcnCurrent-
//                Child's _pvcnChild and append it to pvcnFirstBorn in the tree
//                being generated by copy.
//              - Assign pvcnCurrentChild's _pvcnChild to pvcnCurrentSister.
//              -  Loop till pvcnCurrentSister's _pvcnSister is non NULL  
//                      - Call CopyAppendVirtualCtrNode to create a new node 
//                        pvcnNextBornSister and append it to pvcnFirstBorn. Pl.
//                        note that append function would take care to append
//                        it to its older sister.
//                      - Assign pvcnCurrentSister's _pvcnSister to  variable
//                        pvcnCurrentSister. 
//                      - If pvcnCurrentSister's _pvcnChild is non NULL, then
//                        make a recursive call to self CopyGrowVirtualDFTree. 
//                      - Reinitialize pvcnNextBornSister to NULL & go back to
//                        top of this inner loop and repeat.
//              - Assign  pvcnNextBorn to pvcnFirstBorn and reinitailize pvcn
//                NextBorn to NULL.
//              - Assign pvcnCurrentChild's _pvcnChild to pvcnCurrentChild.
//              - Go to top of outer loop and repeat. 
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyGrowVirtualDFTree(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo,
    TREEOP          treeOpType)
{
    HRESULT             hr                  =   S_OK;
    VirtualCtrNode      *pvcnFirstBorn      =   NULL;
    VirtualCtrNode      *pvcnNextBorn       =   NULL;
    VirtualCtrNode      *pvcnNextBornSister =   NULL;
    VirtualCtrNode      *pvcnCurrentSister  =   NULL;
    VirtualCtrNode      *pvcnCurrentChild   =   NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyGrowVirtualDFTree"));

    DH_ASSERT(NULL != pvcnFrom);
    DH_ASSERT(NULL != pvcnTo);

    if(S_OK == hr)
    {
        pvcnFirstBorn = pvcnTo;
        pvcnCurrentChild = pvcnFrom;
    }

    while((NULL != pvcnCurrentChild->_pvcnChild) && (S_OK == hr))
    {
        hr = CopyAppendVirtualCtrNode(
                pvcnFirstBorn,
                pvcnCurrentChild->_pvcnChild,
                treeOpType,
                &pvcnNextBorn); 
          
        DH_HRCHECK(hr, TEXT("CopyAppendVirtualCtrNode")) ;

        if(S_OK == hr) 
        {
            pvcnCurrentSister = pvcnCurrentChild->_pvcnChild;

            while((NULL != pvcnCurrentSister->_pvcnSister) && (S_OK == hr))
            {
                hr = CopyAppendVirtualCtrNode(
                         pvcnFirstBorn,
                         pvcnCurrentSister->_pvcnSister,
                         treeOpType,
                         &pvcnNextBornSister);

                DH_HRCHECK(hr, TEXT("CopyAppendVirtualCtrNode")) ;

                pvcnCurrentSister = pvcnCurrentSister->_pvcnSister;

                // Check if there are any children of this sister node, if
                // yes, then make a recursive call to self.  

                if(NULL != pvcnCurrentSister->_pvcnChild)
                {
                    hr = CopyGrowVirtualDFTree(
                            pvcnCurrentSister,
                            pvcnNextBornSister,
                            treeOpType);

                    DH_HRCHECK(hr, TEXT("CopyGrowVirtualDFTree"));
                }

                // Reinitialize the variables

                pvcnNextBornSister = NULL;
            }
                
         }
         pvcnFirstBorn = pvcnNextBorn;
         pvcnNextBorn = NULL;

         pvcnCurrentChild = pvcnCurrentChild->_pvcnChild;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyAppendVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualCtrNode to VirtualDocFile tree 
//              being created. 
//
//  Arguments:  [pvcnParent] - Parent VirtualCtrNode for the new VirtualCtrNode
//              [pcnSource] -  Corresponding VirtualCtrNode in old VirtualDF 
//                             tree. 
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//              [ppvcnNew] -   Pointer to pointer to new VirtualCtrNode to be 
//                             created.
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-96   Created
//
//  Notes:      - Creates VirtualCtrNode object ppvcnNew & initializes it with 
//                info based on corresponding old source pvcnSource node.
//              - Appends this node to copy VirtualDF tree being generated.
//              - Calls CopyAppendVirtualStmNodesToVirtualCtrNode to append
//                VirtualStmNodes to this VirtualCtrNode, if present in old
//                source tree, so required to be copied.
//              - Copies in memory CRC for this VirtualCtrNode _dwCRC from old
//                source VirtualCtrNode.
//              - if treeOpType is OLD_STGSTM, as would be in transaction tree
//                copy procedure, when no new disk IStorages/IStreams are made,
//                this assign's new VirtualCtrNode's _pstg to be old source
//                VirtualCtrNode's _pstg.
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyAppendVirtualCtrNode(
    VirtualCtrNode *pvcnParent,
    VirtualCtrNode *pvcnSource,
    TREEOP         treeOpType,
    VirtualCtrNode **ppvcnNew) 
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnOldSister  =   NULL;

    DH_VDATEPTROUT(ppvcnNew, PVCTRNODE) ; 
    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnSource, VirtualCtrNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyAppendChildVirtualCtrNode"));
 
    DH_ASSERT(NULL != pvcnParent);
    DH_ASSERT(NULL != ppvcnNew);
    DH_ASSERT(NULL != pvcnSource);

    if(S_OK == hr)
    { 
        *ppvcnNew = NULL;

        // Allocate and Initialize new VirtualCtrNode

        *ppvcnNew = new VirtualCtrNode();
       
        if (NULL == *ppvcnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvcnNew)->Init(
                pvcnSource->_ptszName, 
                pvcnSource->_cChildren, 
                pvcnSource->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    // Append new VirtualCtr Node

    if(S_OK == hr)
    {
        if(NULL == pvcnParent->_pvcnChild)
        {
            hr = pvcnParent->AppendChildCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendChildCtr")) ;
        }
        else
        {
            pvcnOldSister = pvcnParent->_pvcnChild;
            while(NULL != pvcnOldSister->_pvcnSister)
            {
                pvcnOldSister = pvcnOldSister->_pvcnSister;
            }

            hr = pvcnOldSister->AppendSisterCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendSisterCtr")) ;
        }
    }
     
    if ((S_OK == hr) && (0 != (*ppvcnNew)->_cStreams))
    {
       hr = CopyAppendVirtualStmNodesToVirtualCtrNode(
                (*ppvcnNew)->_cStreams, 
                 *ppvcnNew,
                 pvcnSource,
                 treeOpType);

       DH_HRCHECK(hr, TEXT("CopyAppendVirtualStmNodesToVirtualCtrNode")) ;
    }

    if(S_OK == hr)
    {
       (*ppvcnNew)->_dwCRC = pvcnSource->_dwCRC; 

        if(OLD_STGSTM == treeOpType)
        {
            (*ppvcnNew)->_pstg = pvcnSource->_pstg;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyAppendVirtualStmNodesToVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualStmNode(s) to VirtualCtrNode 
//
//  Arguments:  [cStreams] -     Number of streams to be created 
//              [pvcn]     -     Pointer to VirtualCtrNode for which the streams
//                               need to be created and appended.
//              [pvcnSource] -   Pointer to correspoding VirtualCtrNode in 
//                               old VirtualDF tree. 
//              [treeOpType] -   OLD_STGSTM or NEW_STGSTM
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-96   Created
//
//  Notes:      if number of streams to be created and appended to parent 
//              VirtualCtrNode pvcn is not zero, then loop till cStreams is
//              not equal to zero.
//                  - First time in loop, assign pvsnSource from pvcnSource's
//                    _pvcsnStream, otherwise assign pvsnSource's _pvsnSister
//                    to pvsnSource with each traversal of loop.
//                  - Call CopyAppendVirtualStmNode to create a new VirtualStm
//                    Node and append it to parent VirtualCtrNode. Pl. note that
//                    this function would take care if the newly created node
//                    need to be appended to older VirtualStmNode sister.
//                  - Decrement cStreams and go back to top of loop & repeat.
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyAppendVirtualStmNodesToVirtualCtrNode(
    ULONG           cStreams,
    VirtualCtrNode  *pvcn,
    VirtualCtrNode  *pvcnSource,
    TREEOP          treeOpType)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnSource     =   NULL;

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnSource, VirtualCtrNode) ; 

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::CopyAppendVirtualStmNodesToVirtualCtrNode"));
 
    DH_ASSERT(0 != cStreams);
    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pvcnSource);

    while((S_OK == hr) && (0 != cStreams))
    {
        if(NULL == pvsnSource)
        {
            pvsnSource = pvcnSource->_pvsnStream;
        }
        else
        {
            pvsnSource = pvsnSource->_pvsnSister;
        }

        DH_ASSERT(NULL != pvsnSource);

        hr = CopyAppendVirtualStmNode(
                pvcn,   
                pvsnSource,
                treeOpType);

        DH_HRCHECK(hr, TEXT("CopyAppendFirstVirtualStmNode")) ;

        cStreams--;
 
    }
    return hr;
}
 
//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyAppendVirtualStmNode, protected
//
//  Synopsis:   Creates and appends first VirtualStmNode to VirtualCtrNode 
//
//  Arguments:  [pvcnParent] - Pointer to VirtualCtrNode for which the streams
//                             need to be created and appended. 
//              [pvsnSource] - Pointer to corresponding VirtualStmNode in old
//                             VirtualDF tree.
//              [treeOpType] - OLD_STGSTM or NEW_STGSTM
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-96   Created
//
//  Notes:      - Creates VirtualStmNode pvsnNew and initializes it with above
//                info from pvsnSource
//              - Appends this node to the parent VirtualCtrNode pvcnParent.
//              - Copies in memory CRC for this VirtualStmNode's _dwCRC from old
//                source pvsnSource.
//              - if treeOpType is OLD_STGSTM, as would be in transaction tree
//                copy procedure, when no new disk IStorages/IStreams are made,
//                this assign's new VirtualStmNode's _pstm to be pvsnSource's
//                _pstm 
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyAppendVirtualStmNode(
    VirtualCtrNode *pvcnParent,
    VirtualStmNode *pvsnSource,
    TREEOP         treeOpType)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnNew        =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;
 
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyAppendFirstVirtualStmNode"));

    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvsnSource, VirtualStmNode) ; 
 
    DH_ASSERT(NULL != pvcnParent);
    DH_ASSERT(NULL != pvsnSource);

    if (S_OK == hr)
    {
        pvsnNew = new VirtualStmNode();

        if (NULL == pvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if(S_OK == hr)
    {
        hr = pvsnNew->Init(pvsnSource->_ptszName, pvsnSource->_cb);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Init")) ;
    }

    if(S_OK == hr)
    {
        if(NULL == pvcnParent->_pvsnStream)
        { 
            // Append it to parent storage
 
            hr = pvcnParent->AppendFirstChildStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendFirstChildStm")) ;
        }
        else
        {
            pvsnOldSister = pvcnParent->_pvsnStream;
            
            while(NULL != pvsnOldSister->_pvsnSister)
            {
                pvsnOldSister = pvsnOldSister->_pvsnSister;
            }

            // Append it to preceding sister stream 
 
            hr = pvsnOldSister->AppendSisterStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::AppendSisterStm")) ;
        }
    }

    if(S_OK == hr)
    {
        pvsnNew->_dwCRC.dwCRCName =  pvsnSource->_dwCRC.dwCRCName; 
        pvsnNew->_dwCRC.dwCRCData =  pvsnSource->_dwCRC.dwCRCData; 
        pvsnNew->_dwCRC.dwCRCSum =  pvsnSource->_dwCRC.dwCRCSum; 

        if(OLD_STGSTM == treeOpType)
        {
            pvsnNew->_pstm = pvsnSource->_pstm;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::Associate, public
//
//  Synopsis:   Assocaies a VirtualDF tree with a VirtualCtrNode and its name.
//
//  Arguments:  [pvcn]    - Pointer to VirtualCtrNode to be associated with
//              [pIStorage] - pointer to Disk IStorage to associate with
//
//  Returns:    HRESULT 
//
//  History:    Narindk   6-June-96   Created
//
//  Notes:      This function is currently being used by GenerateVirtualDFFrom
//              DiskDF in util.cxx.  
//---------------------------------------------------------------------------

HRESULT VirtualDF::Associate(
    VirtualCtrNode *pvcn, 
    LPSTORAGE       pIStorage,
    ULONG           ulSeed)
{
    HRESULT     hr  =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::Associate"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode);
    DH_VDATEPTRIN(pIStorage, IStorage);

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pIStorage);

    // Associate name

    if(S_OK == hr)
    {
        _ptszName = new TCHAR[_tcslen(pvcn->_ptszName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, pvcn->_ptszName);
        }
    }

    // Associate given root IStorage with root VirtualCtrNode's _pstg and
    // also Associate root of VirtualDF _pvcnRoot with the passed in root
    // VirtualCtrNode.

    if(S_OK == hr)
    {
        pvcn->_pstg = pIStorage;
        _pvcnRoot = pvcn;
    }

    // Create the DataGens if we need to and if we can
    // If ulSeed is UL_INVALIDSEED, caller is not interested.
    if (UL_INVALIDSEED != ulSeed)
    {
        // We need a totally new set of datagens to prevent
        // duplicate names. So Generate a new seed.
        DG_INTEGER *pdgiNew = new DG_INTEGER (ulSeed);
        if (NULL != pdgiNew)
        {
            ULONG ulTmp = 0;
            if (DG_RC_SUCCESS == pdgiNew->Generate(&ulTmp, 0, 0xFFFFFFFF))
            {
                ulSeed = ulTmp;
            }
            delete pdgiNew;
        } 
        if (NULL == _pdgi)
        {
            _pdgi = new(NullOnFail) DG_INTEGER(ulSeed);
        }
        if (NULL == _pgdu)
        {
            _pgdu = new(NullOnFail) DG_STRING(ulSeed);
        }
        if (NULL == _pdgi || NULL == _pgdu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualCtrNodeStreamNode, public
//
//  Synopsis:   Deletes the VirtualStmNode passed in under the given 
//              VirtualCtrNode.
//
//  Arguments:  [*pvcn]- Pointer to VirtualCtrNode for which VirtualStmNode
//                       need to be deleted.
//              [*pvsn] - Pointer to VirtualStmNode to be deleted
//
//  Returns:    HRESULT 
//
//  History:    Narindk   9-July-96   Created
//
//  Notes:      - Assign a temp variable pvsnTemp to point to _pvsnStream of
//                passed in VirtualStmNode pvsn's _pvcnParent.
//              - Delete the corresponding VirtualStmNode from VirtualCtrNode
//                chain of VirtualStmNode and readjusts parent VirtualCtrNode
//                /child VirtualStmNodes pointers and _cStreams count of the
//                VirtualCtrNode.
//                  - In a loop, befor entering into which pvsnOldSister is
//                    set to NULL, find the passed in VirtualStmNode and
//                    break when found.
//                  - if VirtualStmNode to be deleted is first one in the
//                    VirtualStmNode chain of parent, then parent VirtualCtr
//                    Node's _pvsnStream ptr needs to be adjusted to point to
//                    "to be delted" VirtualStmNode's _pvsnSister.
//                  - If VirtualStmNode to be deleted is not first one in the
//                    VirtualStmNode chain, then its older sister is located
//                    and its _pvsnSister pointer is adjusted to "to be delted"
//                    VirtualStmNode's _pvsnSister.
//                  - Decrease the _cStreams count of the VirtualCtrNode parent
//                  - Delete the VirtualStmNode after setting its pointers to
//                    NULL. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualCtrNodeStreamNode(VirtualStmNode *pvsn)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnTemp       =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::DeleteVirtualCtrNodeStreamNode"));

    DH_VDATEPTRIN(pvsn, VirtualStmNode);

    DH_ASSERT(NULL != pvsn);
    DH_ASSERT(NULL != pvsn->_pvcnParent);

    if(S_OK == hr)
    {
        pvsnTemp = pvsn->_pvcnParent->_pvsnStream;
        pvsnOldSister = NULL;

        // This locates the VirtualStmNode to be deleted  and the
        // nodes whose pointers may need to be readjusted.

        while((pvsnTemp != pvsn) && (NULL != pvsnTemp->_pvsnSister))
        {
            pvsnOldSister = pvsnTemp;
            pvsnTemp = pvsnTemp->_pvsnSister;
        }

        DH_ASSERT(pvsnTemp == pvsn);

        // Adjust the pointers

        if(NULL == pvsnOldSister)
        {
            pvsn->_pvcnParent->_pvsnStream = pvsnTemp->_pvsnSister;
        }
        else
        {
            pvsnOldSister->_pvsnSister = pvsnTemp->_pvsnSister;
        }

        // Decrease the stream count of the parent VirtualCtrNode parent.

        pvsn->_pvcnParent->_cStreams--;

        // Delete the node after NULLing its pointers.

        pvsnTemp->_pvcnParent = NULL;
        pvsnTemp->_pvsnSister= NULL;
        delete pvsnTemp;
        pvsnTemp = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\filebyts\ilkbytes.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      ilbfile.cxx
//
//  Contents:  Implementation of CFileBytes class methods - derived from
//             ILockBytes class. 
//
//  Derivation: ILockBytes
//
//  Functions:
//
//  History:    06-Nov-92       AlexT     Created
//              30-July-1996    NarindK   Modified for stgbase tests.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "ilkbhdr.hxx"


//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::CFileBytes, public
//
//  Synopsis:   constructor
//
//  Arguments:  none
//
//  Returns:    none 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:      Returns a fully initialized CFileBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CFileBytes::CFileBytes(void):
    _hf(HFILE_ERROR),
    _ulRef(1),
    _cFail0(0),
    _cWrite0(0),
    _pszFileName(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::CFileBytes"));
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::~CFileBytes, public
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//  Returns:    none 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:     
//
//--------------------------------------------------------------------------

CFileBytes::~CFileBytes(void)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::~CFileBytes"));

    // Clean up

    if(NULL != _pszFileName)
    {
        delete _pszFileName;
        _pszFileName = NULL;
    }
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Init, public
//
//  Synopsis:   Initialize function 
//
//  Arguments:  [ptcPath] - Pointer to file name
//              [dwMode]  - Mode to access/create file 
//
//  Returns:    HRESULT 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:      
//
//--------------------------------------------------------------------------

HRESULT CFileBytes::Init(TCHAR *ptcPath, DWORD dwMode)
{
    HRESULT     hr              =   S_OK;
    LPSTR       pszFileName     =   NULL;
    int         bufferSize      =   0;
    OFSTRUCT    of;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::Init"));

    if(S_OK == hr)
    {
        _pszFileName = (CHAR *) new TCHAR[_tcslen(ptcPath) + 1 * sizeof(TCHAR)];
        if(NULL == _pszFileName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Copy ptcPath to _pszFileName.  If NT, will need tp convert it to single 
    // byte.

    if(S_OK == hr)
    {
#if defined(_NT1X_) && !defined(_MAC)
        bufferSize = (_tcslen(ptcPath) + 1) * sizeof(TCHAR);

        if (0 == WideCharToMultiByte(
                    CP_ACP,
                    0,
                    ptcPath,
                    -1,
                    _pszFileName,
                    bufferSize,
                    NULL,
                    NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DH_HRCHECK(hr, TEXT("WideCharToMultiByte")) ;

            delete [] _pszFileName;
            _pszFileName = NULL;
        }
#else
        _tcscpy(_pszFileName, ptcPath);
#endif
    }

    if(S_OK == hr)
    {
         _hf = OpenFile(_pszFileName, &of, dwMode);

        if (HFILE_ERROR == _hf)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::FailWrite0, public
//
//  Synopsis:   Function to simulate Write failure 
//
//  Arguments:  [cFail0] - failure value 
//
//  Returns:    HRESULT 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:    
//
//-------------------------------------------------------------------------

void CFileBytes::FailWrite0(int cFail0)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::FailWrite0"));

    _cWrite0 = 0;
    _cFail0 = cFail0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::QueryInterface, public
//
//  Synopsis:   Given a riid, returns associated interface 
//
//  Arguments:	[riid] - interface id
//		        [ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::QueryInterface(
    REFIID      /* UNREF riid */, 
    LPVOID FAR  *ppvObj)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::QueryInterface"));

    *ppvObj = NULL;

    return STG_E_INVALIDFUNCTION;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Arguments:  none
//
//  Returns:    ULONG post reference count
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFileBytes::AddRef(void)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::AddRef"));

    _ulRef++;

    DH_TRACE(
        (DH_LVL_ADDREL,
        TEXT("AddRef  - Object %lx, refs: %ld \n"),
        this, _ulRef));

    return _ulRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Release, public
//
//  Synopsis:	release reference
//              closes file when reference count reaches zero
//
//  Arguments:  void
//
//  Returns:	ULONG post reference count
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFileBytes::Release(void)
{
    ULONG   ulTmp   =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::Release"));

    if ( _ulRef > 0 )
    {
        ulTmp = --_ulRef ;

        DH_TRACE(
            (DH_LVL_ADDREL,
            TEXT("Release - Object %lx, refs: %ld \n"),
            this, _ulRef));

        if (0 == _ulRef)
        {
            if (HFILE_ERROR != _hf)
            {
                _lclose(_hf);
            }

            DH_TRACE(
                (DH_LVL_ADDREL,
                TEXT("Release - Deleting Object %lx"), this));

            delete this;
        }
    }
    else
    {
        DH_ASSERT(!"Release() called on pointer with 0 refs!") ;

        ulTmp = 0 ;
    }

    return ulTmp;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::ReadAt
//
//  Synopsis:   Reads bytes from file
//
//  Arguments:  [ulOffset] - byte offset
//		        [pv]       - input buffer
//		        [cb]       - count of bytes to read
//		        [pcbRead]  - count of bytes read
//
//  Returns:    HRESULT 
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::ReadAt(
    ULARGE_INTEGER  uliOffset,
    VOID HUGEP      *pv,
    ULONG           cb,
    ULONG           *pcbRead)
{
    HRESULT hr      =   S_OK;
    LONG    lOffset =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::ReadAt"));

    DH_ASSERT(0 == ULIGetHigh(uliOffset));
    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        lOffset = (LONG) ULIGetLow(uliOffset);

        _llseek(_hf, lOffset, 0);

        *pcbRead = _hread(_hf, pv, cb);

        if (HFILE_ERROR == *pcbRead)
        {
            *pcbRead = 0;
            hr = STG_E_READFAULT;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to file
//
//  Arguments:	[uliOffset]  - byte offset
//		        [pv]         - output buffer
//		        [cb]         - count of bytes to write
//		        [pcbWritten] - count of bytes written
//
//  Returns:    HRESULT	
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP  CFileBytes::WriteAt(
    ULARGE_INTEGER      uliOffset,
    VOID const HUGEP    *pv,
	ULONG               cb,
	ULONG FAR           *pcbWritten)
{
    HRESULT hr      =   S_OK;
    LONG    lOffset =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::WriteAt"));

    DH_ASSERT(0 == ULIGetHigh(uliOffset));
    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        lOffset = (LONG) ULIGetLow(uliOffset);

        if (0 == lOffset)
        {
            //  Check for simulated write failures
        
            if (_cFail0 > 0)
            {
                _cWrite0++;

                if (_cWrite0 == _cFail0)
                {
                    hr = STG_E_WRITEFAULT;
                }
            }
        }
    }

    if(S_OK == hr)
    {
        _llseek(_hf, lOffset, 0);
    
        *pcbWritten = _hwrite(_hf, (char *) pv, cb);

        if (HFILE_ERROR == *pcbWritten)
        {
            *pcbWritten = 0;
            hr = STG_E_WRITEFAULT;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Flush, public
//
//  Synopsis:	flushes file;  not implemented, always return S_OK
//
//  Effects:	none
//
//  Returns:    S_OK 
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::Flush(void)
{
    HRESULT hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::Flush"));

    DH_ASSERT(HFILE_ERROR != _hf);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size. May change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:    HRESULT	
//
//  Algorithm:  realloc the buffer
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::SetSize(ULARGE_INTEGER ulicb)
{
    HRESULT hr      =   S_OK;
    BYTE    ch      =   0;
    ULONG   cb      =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::SetSize"));

    DH_ASSERT(0 == ULIGetHigh(ulicb));
    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        cb = ULIGetLow(ulicb);

        _llseek(_hf, cb, 0);
    
        _hwrite(_hf, (char *) &ch, 0);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Arguments:	[libOffset]  - lock range offset
//		        [cb]         - lock range size
//		        [dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::LockRegion(
    ULARGE_INTEGER  /* UNREF libOffset */,
    ULARGE_INTEGER  /* UNREF cb */,
    DWORD           /* UNREF dwLockType */)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::LockRegion"));

    DH_ASSERT(0 && !TEXT("Can't lock CFileBytes"));
    DH_ASSERT(HFILE_ERROR != _hf);

    return STG_E_INVALIDFUNCTION;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Arguments:	[libOffset]  - lock range offset
//		        [cb]         - lock range size
//		        [dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::UnlockRegion(
    ULARGE_INTEGER  /* UNREF libOffset */,
    ULARGE_INTEGER  /* cb */,
    DWORD           /* dwLockType */)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::UnlockRegion"));

    DH_ASSERT(0 && !TEXT("Can't Unlock CFileBytes"));
    DH_ASSERT(HFILE_ERROR != _hf);

    return STG_E_INVALIDFUNCTION;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		        [grfStatFlag] - status flags
//
//  Returns:    HRESULT
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:	    No time stamps.  Modifies pstatstg.
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    HRESULT             hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::Stat"));

    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        memset(pstatstg, 0, sizeof(STATSTG));

        if (0 == (grfStatFlag & STATFLAG_NONAME))
        {
            // MakeUnicode String doesn't do any parameter validation, so use
            // it correctly.

#ifdef _MAC
            _tcscpy(pstatstg->pwcsName, _pszFileName);
#else
            hr = MakeUnicodeString(_pszFileName, &(pstatstg->pwcsName));
#endif

            DH_HRCHECK(hr, TEXT("TStrToWstr")) ;

            if (NULL == pstatstg->pwcsName)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if(S_OK == hr)
    {
        pstatstg->type = STGTY_LOCKBYTES;

        ULISet32(pstatstg->cbSize, _llseek(_hf, 0, 2));

        pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;
    }


    return hr;
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::GetSize, public
//
//  Synopsis:   Function to return size 
//
//  Arguments:  none 
//
//  Returns:    ULARGE_INTEGER 
//
//  History:    30-July-96  Narindk    Created 
//
//  Notes:    
//
//-------------------------------------------------------------------------

ULARGE_INTEGER CFileBytes::GetSize()
{
    HRESULT          hr =   S_OK;
    ULARGE_INTEGER   ulSize;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::GetSize"));

    DH_ASSERT(HFILE_ERROR != _hf);

    ulSize.LowPart = GetFileSize((HANDLE) _hf, &(ulSize.HighPart));

    if(0xFFFFFFFF == ulSize.LowPart)
    {
       hr = HRESULT_FROM_WIN32(GetLastError());
        
       DH_HRCHECK(hr, TEXT("GetFileSize")) ;
    }

    DH_ASSERT(0xFFFFFFFF != ulSize.LowPart);

    return ulSize; 
}

//+-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\inc\getcli.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       getcli.h
//
//  Contents:   Get clients for a test
//
//  Functions:  GetClients
//
//  History:    02-Jun-97   MikeW       Created
//
//---------------------------------------------------------------------------

#ifndef _GETCLI_H_
#define _GETCLI_H_

#pragma once



//+--------------------------------------------------------------------------
//
//  Class:      ClientData
//
//  Synopsis:   Encapsulate data about each client (or peer) the host is
//              working with.
//
//  History:    02-Jun-97   MikeW   Created
//
//  Notes:      To allocate, call "p = new(x) ClientData" where x is the 
//              maximum number of clients.  To deallocate call "delete p"
//
//---------------------------------------------------------------------------
              
struct ClientData
{
    int     client_count;           // Number of clients

    struct PerClientData            // Info for each client
    {
        DWORD   context;            //    context (local, remote, etc)
        LPWSTR  machine_name;       //    machine name for remote clients
    }
    client[ANYSIZE_ARRAY];

    //
    // a ClientData is a variable sized structure.  Define some routines
    // to make using them easier.
    //

    HRESULT SetMachineName(UINT client, LPCWSTR machine_name);
    inline void * operator new(size_t /* UNREF bytes */, UINT client_count);
    inline void operator delete(void *_this);
};



//+--------------------------------------------------------------------------
//
//  Method:     ClientData::operator new
//
//  Synopsis:   Allocate the variable sized ClientData structure
//
//  Parameters: [client_count]      -- The number of clients
//
//  Returns:    A pointer to the storage for the new object
//
//  History:    02-Jun-97   MikeW   Created
//
//---------------------------------------------------------------------------

inline void * ClientData::operator new(
                                        size_t /* UNREF bytes */, 
                                        UINT   client_count)
{
    return new BYTE[sizeof(ClientData)
                    + sizeof(PerClientData)
                        * (client_count - ANYSIZE_ARRAY)
                    + (MAX_COMPUTERNAME_LENGTH + 1)
                        * client_count * sizeof(WCHAR)];
}



//+--------------------------------------------------------------------------
//
//  Method:     ClientData::operator delete
//
//  Synopsis:   De-allocate the variable sized ClientData structure
//
//  Parameters: [_this]         -- "this" pointer
//
//  Returns:    void
//
//  History:    02-Jun-97   MikeW   Created
//
//---------------------------------------------------------------------------

inline void ClientData::operator delete(void *_this)
{
    delete [] (BYTE *) _this;
}



//
// Functions to discover clients
//

HRESULT GetClients(
                ClientData    **pp_client_data, 
                DWORD           contexts,
                int             client_count,
                const GUID     &test_id = GUID_NULL,
                LPWSTR          test_description = NULL);

HRESULT GetRemoteClients(
                ClientData     *client_data, 
                const GUID     &test_id,
                LPWSTR          test_description);


#endif // _GETCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\inc\killwarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      killwarn.hxx
//
//  Contents:  Pragma's to kill specific warnings at W4
//
//  History:   28-Nov-94        DeanE   Created
//--------------------------------------------------------------------------
#ifndef __KILLWARN_HXX__
#define __KILLWARN_HXX__

//
//  Quotes taken from vc user's manual
//


// Turn off: unreferenced inline function has been removed
#pragma warning(disable: 4514)

// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.
#pragma warning(disable: 4201)

// 'identifier' : inconsistent DLL linkage. dllexport assumed
//
// The specified member function was declared in a class with dllexport
// linkage, and then was imported. This warning can also be caused by
// declaring a member function in a class with dllimport linkage as neither
// imported nor static nor inline.
//
// The function was compiled as dllexport.
#pragma warning(disable: 4273)

// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.
#pragma warning(disable: 4512)

// 'function': function not expanded
//
// The given function was selected for inline expansion but the compiler did 
// not perform the inlining.
#pragma warning(disable:4710)

// trigraph not being substituted
#pragma warning (disable: 4110)

#ifdef _MAC
// alignment of a memeber was sensitive to packing
#pragma warning (disable: 4121)
#endif // _MAC

// access-declarations are deprecated; member using-declarations provide 
// a better alternative
#pragma warning (disable: 4516)

#endif  // __KILLWARN_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\inc\debdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       debdlg.h
//
//  Contents:   ID definitions for controls in dialog box
//
//  Classes:
//
//  Functions:
//
//  History:    4-10-95   kennethm   Created
//
//--------------------------------------------------------------------------
#ifndef __DEBDLG_H__
#define __DEBDLG_H__

#include <winuser.h>

//
//  Externs
//

#define IDD_DEBUGDIALOG                 5270
#define IDC_ADDREL                      1001
#define IDC_TRACEFILELOC                1002
#define IDC_LOGFILELOC                  1003
#define IDC_POPUP                       1004
#define IDC_DEBUGTERM                   1005
#define IDC_TLDEBUGTERM                 1005
#define IDC_SPYWIN                      1006
#define IDC_TLSPYWIN                    1006
#define IDC_TRACEFILEBROWSE             1007
#define IDC_CONSOLE                     1008
#define IDC_TLCONSOLE                   1008
#define IDC_LOGFILE                     1009
#define IDC_TLLOGFILE                   1009
#define IDC_TRACELEVEL                  1010
#define IDC_INTERF                      1011
#define IDC_QI                          1012
#define IDC_LEVEL1                      1013
#define IDC_LEVEL2                      1014
#define IDC_SAVE                        1015
#define IDC_LOGFILEBROWS                1016
#define IDC_LEVEL3                      1017
#define IDC_LLDEBUGTERM                 1018
#define IDC_LLSPYWIN                    1019
#define IDC_LLCONSOLE                   1020
#define IDC_LLLOGFILE                   1021
#define IDC_FUNCOUT                     1022
#define IDC_FUNCIN                      1023
#define IDC_BREAK                       1024
#define IDC_VERBOSE                     1025
#define IDC_SPYWINDOWLOC                1026
#define IDC_LEVEL4                      1027
#define IDC_WARNING                     1028
#define IDC_STATIC                      -1

#endif // __DEBDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\convert.cxx ===
//+-------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       convert.cxx
//
//  Contents:   Conversion functions for various things.
//
//  Classes:
//
//  Functions:  TStrToWStr
//              WStrToTStr
//              MakeUnicodeString
//              MakeSingleByteString
//
//  History:    20-Feb-95       AlexE   Created
//              29-Jan-98       FarzanaR Ported from ctoleui tree
//---------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;

//+-------------------------------------------------------------------------
//
//  Function:   TStrToWStr
//
//  Synopsis:   Converts a TCHAR string to a WCHAR string
//
//  Arguments:  [pszSource] -- The string to convert, NULL is valid
//              [ppszDest]  -- The location to store the new string
//
//  Returns:    S_OK if the conversion was successful, another HRESULT
//              if it was not.
//
//  History:    4-20-95   kennethm   Created
//
//  Notes:      If unicode is defined this function allocates memory for
//              the new string and does a simple 'strcpy'.
//
//              If unicode is NOT defined, a CHAR to WCHAR conversion is
//              performed.
//
//              If *ppszDest is non NULL when this function returns, the
//              caller is responsible for freeing the memory allocated at
//              [*ppszDest]
//
//--------------------------------------------------------------------------

HRESULT TStrToWStr(LPCTSTR pszSource, LPWSTR *ppszDest)
{
    //
    //  Make sure the destination is a valid address
    //

    if (IsBadWritePtr(ppszDest, sizeof(ppszDest)))
    {
        DH_ASSERT(!"TStrToWStr(): Bad destination pointer");
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pszSource, sizeof(TCHAR)))
    {
        DH_ASSERT(!"TStrToWStr(): Bad source pointer");
        return E_INVALIDARG;
    }

    if ('\0' == *pszSource)
    {
        *ppszDest = NULL;
        DH_ASSERT(!"TStrToWStr(): Source string is empty");
        return E_INVALIDARG ;
    }

#ifdef UNICODE

    //
    //  If we're in a unicode world then this whole thing was in vain
    //  but we allocate memory and copy the string anyhow
    //

    *ppszDest = new WCHAR[lstrlen(pszSource) + 1];

    if (NULL == *ppszDest)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(*ppszDest, pszSource);

    return S_OK;

#else

    //
    //  Otherwise we do the conversion
    //

    return MakeUnicodeString(pszSource, ppszDest);

#endif
}



//+-------------------------------------------------------------------------
//
//  Function:   WStrToTStr
//
//  Synopsis:   Converts a WCHAR string into a TCHAR string
//
//  Arguments:  [pszSource] -- The string to convert, NULL is valid
//              [ppszDest]  -- The location to store the new string
//
//  Returns:    S_OK if the conversion was successful, another HRESULT
//              if not.
//
//  History:    12-May-1995   alexe   Created
//
//  Notes:      If unicode is defined this function allocates memory for
//              the new string and does a simple 'strcpy'.
//
//              If unicode is NOT defined, a WCHAR to CHAR conversion is
//              performed.
//
//              If *ppszDest is non NULL when this function returns, the
//              caller is responsible for freeing the memory allocated at
//              [*ppszDest]
//
//--------------------------------------------------------------------------

HRESULT WStrToTStr(LPCWSTR pszSource, LPTSTR *ppszDest)
{
    //
    //  Make sure the destination is a valid address
    //

    if (IsBadWritePtr(ppszDest, sizeof(ppszDest)))
    {
        DH_ASSERT(!"WStrToTStr(): Bad destination pointer");
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pszSource, sizeof(WCHAR)))
    {
        DH_ASSERT(!"WStrToTStr(): Bad source pointer");
        return E_INVALIDARG;
    }

    if ('\0' == *pszSource)
    {
        *ppszDest = NULL;
        DH_ASSERT(!"WStrToTStr(): Source string is empty");
        return E_INVALIDARG ;
    }


#ifdef UNICODE

    //
    //  If we're in a unicode world then this whole thing was in vain
    //  but we allocate memory and copy the string anyhow
    //

    *ppszDest = new WCHAR[lstrlen(pszSource) + 1];

    if (NULL == *ppszDest)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(*ppszDest, pszSource);

    return S_OK;

#else

    //
    //  Otherwise we do the conversion
    //

    return MakeSingleByteString(pszSource, ppszDest);

#endif
}



//+-------------------------------------------------------------------
//  Member:    MakeUnicodeString
//
//  Synopsis:  Converts an LPCSTR into an LPWSTR.  This function is
//             intended to be a helper function for other functions,
//             TStrToWStr() in particular, so it does NOT do any
//             parameter validation.
//
//  Arguments: [pszSource] - The string to convert.
//
//             [ppszDest] - A place to put pointer to new string.
//
//  Returns:   S_OK if all goes well, another HRESULT if not.
//
//  Remarks:   The user of this function is responsible for freeing
//             the memory allocated by this function using the
//             current 'delete' operator implementation.
//
//  History:   07-Mar-95   AlexE   Created
//             28-Mar-95   AlexE   Moved from strhelp.cxx
//--------------------------------------------------------------------

HRESULT MakeUnicodeString(LPCSTR pszSource, LPWSTR *ppszDest)
{
    HRESULT hr = S_OK ;
    INT nLen = 0 ;
    LPWSTR pszTmp = NULL ;

    //
    // Find the length of the string in UNICODE
    //

    SetLastError(0) ;

    nLen = MultiByteToWideChar(
               CP_ACP,
               0,
               pszSource,
               -1,
               NULL,
               0) ;

    DH_ASSERT(0 != nLen) ;

    pszTmp = new WCHAR [ nLen + 1 ] ;

    if (NULL == pszTmp)
    {
        hr = E_OUTOFMEMORY ;
    }

    if (S_OK == hr)
    {
        SetLastError(0) ;

        if (nLen != MultiByteToWideChar(
                       CP_ACP,
                       0,
                       pszSource,
                       -1,
                       pszTmp,
                       nLen))
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_ASSERT(S_OK == hr) ;
        }
    }

    if (S_OK == hr)
    {
        *ppszDest = pszTmp ;
    }
    else
    {
        if (NULL != pszTmp)
        {
            delete pszTmp ;
        }
    }

    return hr ;
}



//+-------------------------------------------------------------------
//  Member:    MakeSingleByteString
//
//  Synopsis:  Converts an LPCWSTR into an LPSTR.  This function is
//             intended to be a helper function for other functions,
//             WStrToTStr() in particular, so it does NOT do any
//             parameter validation.
//
//  Arguments: [pszSource] - The string to convert.
//
//             [ppszDest] - A place to put pointer to new string.
//
//  Returns:   S_OK if all goes well, another HRESULT if not.
//
//  Remarks:   The user of this function is responsible for freeing
//             the memory allocated by this function using the
//             current 'delete' operator implementation.
//
//  History:   07-Mar-95   AlexE   Created
//             28-Mar-95   AlexE   Moved from strhelp.cxx
//--------------------------------------------------------------------

HRESULT MakeSingleByteString(LPCWSTR pszSource, LPSTR *ppszDest)
{
    HRESULT hr = S_OK ;
    INT nLen ;
    LPSTR pszTmp ;

    SetLastError(0) ;

    nLen = WideCharToMultiByte(
                CP_ACP,
                0,
                pszSource,
                -1,
                NULL,
                0,
                NULL,
                NULL) ;

     hr = HRESULT_FROM_WIN32(GetLastError()) ;

     pszTmp = new CHAR[ nLen + 1 ] ;

     if (NULL == pszTmp)
     {
         hr = E_OUTOFMEMORY ;
     }

     if (S_OK == hr)
     {
         SetLastError(0) ;

         if (nLen != WideCharToMultiByte(
                         CP_ACP,
                         0,
                         pszSource,
                         -1,
                         pszTmp,
                         nLen,
                         NULL,
                         NULL))
         {
             hr = HRESULT_FROM_WIN32(GetLastError()) ;

             DH_ASSERT(S_OK == hr) ;
         }
     }

     if (S_OK == hr)
     {
         *ppszDest = pszTmp ;
     }
     else
     {
         if (NULL != pszTmp)
         {
             delete pszTmp ;
         }
     }

     return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\ntutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       ntutil.cpp
//
//  Contents:   Utility functions for NTFS drives.
//              These functions will probably not be 
//              available for Mac, Win9x, so should be
//              stubbed out in the header file as such.
//
//  Functions:  
//              ConversionVerification
//              VerifyNssfile
//
//  History:    01/19/98  SCousens     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;

// Must be at least NT5 (not mac, not win9x, not nt4 etc) 
#if defined(_WIN32_WINNT) && (_WIN32_WINNT>=0x0500)

/*******************************************************************/
/*                                                                 */
/*    WARNING:                                                     */
/*      ConversionVerification, VerifyNssfile                      */
/*      must be the LAST functions in this file.                   */
/*      We redefine stuff that must not affect the rest            */
/*      of the functions.                                          */
/*      of the functions.                                          */
/*                                                                 */
/*******************************************************************/

#ifdef _HOOK_STGAPI_
#undef StgCreateDocfile
#undef StgOpenStorage
#endif  /* _HOOK_STGAPI_ */

//+-------------------------------------------------------------------------
//  Function:   ConversionVerification
//
//  Synopsis:   Opens a nssfile as docfile and then as nssfile
//              and calculates CRC each time. If CRC is different
//              then there is a problem with the conversion driver
//
//  Arguments:  [pFileName]   - Name of Docfile
//              [dwCRCexp]    - Expected CRC (default=0)
//
//  Returns:    S_OK if all went well and CRCs match
//              or E_FAIL if something else went wrong
//                 (CRCs dont match, ulRef not 0 after Release)
//
//  History:    28-Jan-97  SCousens    Created.
//
//  Notes:      - NSSFile must previously be closed, or access violations
//                may occur calculating CRC.
//--------------------------------------------------------------------------
HRESULT ConversionVerification (LPTSTR pFileName, DWORD dwCRCexp)
{
    DWORD dwCRCdf = 0, dwCRCnss = 0;
    IStorage *pIStorage;
    HRESULT hr = S_OK;
    ULONG ul;
    LPOLESTR        pOleStrTemp     =   NULL;
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ConversionVerification"));
    DH_VDATESTRINGPTR (pFileName);

    // Convert TCHAR to OLECHAR
    hr = TStringToOleString(pFileName, &pOleStrTemp);
    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;

    // Open as docfile, calc CRC for file and close it.
    if(S_OK == hr)
    {
        hr = StgOpenStorageEx (pOleStrTemp, 
                STGM_READ | STGM_SHARE_EXCLUSIVE,
                STGFMT_DOCFILE, 
                0, 
                NULL, 
                NULL,
                IID_IStorage, 
                (void**)&pIStorage);  
        DH_HRCHECK (hr, TEXT("Cnv:StgOpenStorageEx"));
        if (S_OK == hr)
        {
            hr = CalculateCRCForDocFile(pIStorage, 
                    VERIFY_INC_TOPSTG_NAME, 
                    &dwCRCdf);
            DH_HRCHECK (hr, TEXT("CalculateCRCForDocFile"));
        }

        if (S_OK != hr || 0 == dwCRCdf)
        {
            DH_LOG((LOG_INFO, TEXT("Cnv:CalculateCRCForDocFile on docfile failed, hr=0x%lx.\n"), hr));
        }
        if (NULL != pIStorage)
        {
            ul = pIStorage->Release ();
            DH_ASSERT (0 == ul);
            pIStorage = NULL;
        }
    }

    // Open normally (as nssfile), calc CRC for the file close it.
    if (S_OK == hr)
    {
        hr = StgOpenStorage (pOleStrTemp, 
                NULL, 
                STGM_READ | STGM_SHARE_EXCLUSIVE,
                NULL, 
                0, 
                &pIStorage);
        DH_HRCHECK (hr, TEXT("Cnv:StgOpenStorage"));
        if (S_OK == hr)
        {
            hr = CalculateCRCForDocFile(pIStorage, 
                    VERIFY_INC_TOPSTG_NAME, 
                    &dwCRCnss);
            DH_HRCHECK (hr, TEXT("CalculateCRCForDocFile"));
        }

        if (S_OK != hr || 0 == dwCRCnss)
        {
            DH_LOG((LOG_INFO, TEXT("Cnv:CalculateCRCForDocFile on nssfile failed, hr=0x%lx.\n"), hr));
        }

        if (NULL != pIStorage)
        {
            ul = pIStorage->Release ();
            DH_ASSERT (0 == ul);
            pIStorage = NULL;
        }
    }

    // spew
    if (S_OK == hr && 
            dwCRCnss == dwCRCdf && 
            0 != dwCRCdf &&
            (0 == dwCRCexp || dwCRCexp == dwCRCdf))
    {
        DH_LOG((LOG_INFO, TEXT("Conversion verification passed.\n")) );
    }
    else
    {
        hr = (S_OK != hr) ? hr : E_FAIL;  //set it only if not already set.
        DH_LOG((LOG_INFO, 
                TEXT("Conversion verification failed, hr=0x%lx.\n"), 
                hr) );
    }

    if (NULL != pOleStrTemp)
    {
        delete pOleStrTemp; 
        pOleStrTemp = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   VerifyNssfile
//
//  Synopsis:   Verify an nssfile is indeed an nssfile by checking:
//              1. reparse point is set (spew if not)
//              2. header is valid (spew if df or unknown, and set hr)
//              Verify the reparse point is set. 
//              Open the file directly with REPARSE flag (to prevent cnss from
//              converting it). Read the header and make sure it looks like a
//              real nssfile by checking the file signatures.
//
//  Arguments:  [pszPathname] - full path to the file to be checked
//
//  Returns:    S_OK, else some sort of error.
//              We set the following if file is df or unknown
//                  ERROR_INVALID_DATA - if file is a DOCFILE
//                   13L - The data is invalid
//                  ERROR_FILE_INVALID - if file is UNKNOWN (not df or nss)
//                   1006L - The volume for a file has been externally 
//                   altered so that the opened file is no longer valid
//                  ERROR_INVALID_EA_NAME - no reparse point (if others valid)
//                   254L - The specified extended attribute name was invalid.
//
//  History:    24-Jul-97  SCousens    Created.
//
//  Notes:      - NSSFile must previously be closed, or file share 
//                access violations may occur reading the header.
//--------------------------------------------------------------------------

#define  NSSFILE_SIGNATURE    0x444D4F30
#define  DOCFILE_SIGNATURE1   0xE011CFD0   //0xD0CF11E0 little endian
#define  DOCFILE_SIGNATURE2   0xE11AB1A1   //0xA1B11AE1 little endian

HRESULT VerifyNssfile (LPTSTR pszPathname)
{
    HRESULT hr  = S_OK;
    HANDLE  hnd;
    ULONG   culRead;
    ULONG   ulAttr;
    struct  _structFileHeader {
        ULONG ulSig1;
        ULONG ulSig2;
        } sFileHeader;
         
    DH_FUNCENTRY (&hr, DH_LVL_DFLIB, TEXT("VerifyNssfile"));

    /* check the file attributes and look for reparse attribute */
    ulAttr = GetFileAttributes (pszPathname);
    DH_TRACE ((DH_LVL_DFLIB, 
            TEXT("VerifyNssfile; Attributes retrieved:%#lx"), 
            ulAttr));
    if ((ULONG)-1 == ulAttr)
    {
        DH_TRACE ((DH_LVL_ERROR, 
                TEXT("VerifyNssfile; Unable to get attributes for %s"), 
                pszPathname));
        hr = HRESULT_FROM_WIN32(GetLastError());
        DH_HRCHECK (hr, TEXT("GetFileAttributes"));
        return hr;
    }
     
    /* attempt to open the file */
    hnd = CreateFile(pszPathname,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,           // security descriptor 
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OPEN_REPARSE_POINT,
            NULL);          //hTemplateFile
    if (INVALID_HANDLE_VALUE == hnd)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    DH_HRCHECK (hr, TEXT("CreateFile"));
    
    /* if we succeeded, read the header */
    if (S_OK == hr)
    {
        BOOL fErr;
        fErr = ReadFile (hnd, &sFileHeader, sizeof (sFileHeader), &culRead, NULL);
        if (FALSE == fErr)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        DH_HRCHECK (hr, TEXT("ReadFile"));
        DH_TRACE ((DH_LVL_DFLIB, TEXT("Read %ld bytes from file"), culRead));
    }

    /* check the header looks like an nss header */
    if (S_OK == hr)
    {
        if (sFileHeader.ulSig1 != NSSFILE_SIGNATURE)
        {
            if (sFileHeader.ulSig1 == DOCFILE_SIGNATURE1 && 
                    sFileHeader.ulSig2 == DOCFILE_SIGNATURE2)
            {
                hr =  ERROR_INVALID_DATA;
                DH_TRACE ((DH_LVL_TRACE1, TEXT("WARNING!!! VerifyNssfile; File appears to be a DOCFILE")));
            }
            else
            {
                hr = ERROR_FILE_INVALID;
                DH_TRACE ((DH_LVL_TRACE1, TEXT("WARNING!!! VerifyNssfile; File is INVALID nssfile or docfile!")));
            }
        }
        else
        {
            DH_TRACE ((DH_LVL_DFLIB, TEXT("VerifyNssfile; File appears to be valid nssfile")));
        }
    }

    // If nssfile, but no reparse point, its still not valid!
    // It is impossible to have an nssfile with a reparse
    // point on an NTFS4 volume. 
    // It is impossible to have an nssfile on a FAT volume.
    if (0 == (FILE_ATTRIBUTE_REPARSE_POINT & ulAttr))
    {
        DH_TRACE ((DH_LVL_TRACE1, 
                TEXT("WARNING!!! VerifyNssfile; File *NOT* have reparse point set!")));
        if (S_OK == hr)
        {
            hr = ERROR_INVALID_EA_NAME;
        }
    }

    // close the file
    if (INVALID_HANDLE_VALUE != hnd)
    {
        HRESULT hr2 = S_OK;
        if (FALSE == CloseHandle(hnd))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError());
        }
        DH_HRCHECK (hr2, TEXT("CloseHandle"));
    }

    // if there is a problem, say what file caused it.
    if (S_OK != hr)
    {
        DH_TRACE ((DH_LVL_TRACE1, 
                TEXT("WARNING!!! File causing problem: %s"), 
                pszPathname));
    }

    return hr;
}
        
/*******************************************************************/
/*                                                                 */
/*    WARNING:                                                     */
/*      ConversionVerification, VerifyNssfile                      */
/*      must be the LAST function in this file.                    */
/*      We redefine stuff that must not affect the rest            */
/*      of the functions.                                          */
/*                                                                 */
/*******************************************************************/

#endif // WINNT5+
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\miscutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       miscutil.cpp
//
//  Contents:   General utility functions for storage
//              VerifyResult
//		RunningDebugOle
//		WaitForObjectsAndProcessMessages 	 
//              Hex
//              EnumLocalDrives
//
//  Functions:  
//
//  History:    07/29/97  SCousens     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;

//+-------------------------------------------------------------------------
//
//  Function:   VerifyResult
//
//  Synopsis:   Check to see if a HRESULT has the expected value
//
//  Parameters: [hrCheck]       -- the HRESULT to check
//              [hrExpected]    -- the HRESULT expected
//
//  Returns:    S_OK if the HRESULT's match.  If they don't match and the
//              and the actual result was a failure, then that result is 
//              returned (preserving the original failure).  Otherwise 
//              E_FAIL is returned.
//
//  History:    28-Jun-95   MikeW   Created
//
//  Notes:      The main advantages of this routine over DH_HRCHECK is that
//              it puts out more diagnostic messages and that it's easier 
//              to verify values where hr != S_OK.
//
//--------------------------------------------------------------------------

HRESULT VerifyResult(HRESULT hrCheck, HRESULT hrExpected)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_TRACE2, TEXT("VerifyResult"));

    hrCheck = FixHr (hrCheck);

    if (hrCheck != hrExpected)
    {
        DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("HRESULT == 0x%08x, expected 0x%08x"),
                hrCheck,
                hrExpected));

        if (FAILED(hrCheck))
        {
            hr = hrCheck;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     Hex
//
//  Synopsis:   Converts a hex char to integer
//
//  Parameters: [ch] -- character to convert
//
//  History:    03-Nov-97       BogdanT     Created
//
//  Comments:   This function asserts if the character is passing chars
//              outside the hexadecimal range
//
//---------------------------------------------------------------------------
UINT Hex(CHAR ch)
{
    if('0'<=ch && ch<='9')
        return ch-'0';
    if('a'<=ch && ch<='f')
        return 10+ch-'a';
    if('A'<=ch && ch<='F')
        return 10+ch-'A';

    DH_ASSERT(!TEXT("Non hexadecimal char passed to Hex()"));
    return '\0';
}

//////////////////////////////////////////////////////////////
//
// Function: EnumLocalDrives
//
// Synopsis: Enumerates all local drives (except A:, B:)
//           and returns a 32bit drive mask to show 
//           availablity of FIXED, REMOVABLE, RAM disks.
//           
// Return  : ULONG bitmask
// NOTES:
//           return value: bit set drive present.
//           A:=bit 0, B:=bit 1, C:=bit 2 D:=bit 3.
//           bits 0,1 always off (ignore A:, B:)
//
// History:  10-Oct-97   scousens     created.
//
//////////////////////////////////////////////////////////////

ULONG EnumLocalDrives()
{
#ifdef _MAC
    return 0L;
#else  
    ULONG  ulMask, ulMap = 0L;    
    TCHAR  szDrive[3]    = {TEXT("C:")};

    ulMap = 0L;                // We don't have A:, B:
    ulMask = 0x04L ;
    do
    {
        switch (GetDriveType(szDrive))
        {
            case DRIVE_FIXED :      //The disk cannot be removed from the drive. 
            case DRIVE_RAMDISK :    //The drive is a RAM disk. 
            case DRIVE_REMOVABLE :  //The disk can be removed from the drive. 
                ulMap |= ulMask;
                break;
 
            //case DRIVE_UNKNOWN :        //The drive type cannot be determined. 
            //case DRIVE_NO_ROOT_DIR :    //The root directory does not exist. 
            //case DRIVE_REMOTE :         //The drive is a remote (network) drive. 
            //case DRIVE_CDROM :          //The drive is a CD-ROM drive. 
            default:
                break;
        }

        ulMask <<= 1;
        ++*szDrive;
    } while (*szDrive <= TCHAR('Z'));
    return (ulMap);
#endif //_MAC
}

//+-------------------------------------------------------------------
//
//  Function:   WaitForObjectsAndProcessMessages
//
//  Synopsis:   Processes windows messages for all windows on the
//              current thread and waits for provided events to be
//              signalled.
//
//  Arguments:  [pHandles] - A pointer to an array of handles to wait
//                           on.  These handles must be Windows thread
//                           synchronization objects.
//
//              [dwCount] - The count of handles in [pHandles]
//
//              [fWaitAll] - TRUE to wait for all objects in [pHandles];
//                           FALSE to wait for only one.
//
//              [dwMilliSeconds] - Milliseconds to wait;  can be INFINITE
//
//  Returns:    The return value from MsgWaitForMultipleObjects()
//
//  History:    18-Sept-1995   AlexE   Created
//
//--------------------------------------------------------------------

DWORD WaitForObjectsAndProcessMessages(
    LPHANDLE pHandles,
    DWORD dwCount,
    BOOL fWaitAll,
    DWORD dwMilliSeconds)
{
    MSG msg ;
    DWORD dwWaitResult ;
    BOOL  fGotQuitMessage = FALSE ;
    int   nQuitExitCode = 0;


    for (;;)
    {
        //
        // Wait on supplied events; only wake up if we need
        // to process a message - we force QS_ALLINPUT here
        // to make sure that ALL windows on this thread have
        // their messages processed.
        //

        dwWaitResult = MsgWaitForMultipleObjects(
                           dwCount,
                           pHandles,
                           fWaitAll,
                           dwMilliSeconds,
                           QS_ALLINPUT) ;

        //
        // If one or all of our objects has become signalled,
        // return the value to the caller
        //

        if ( (dwWaitResult < (WAIT_OBJECT_0 + dwCount)) &&
             (dwWaitResult >= WAIT_OBJECT_0) )
        {
            break ;
        }

        //
        // If a message is in the queue, wake up, process the
        // message, and call MsgWaitForMultipleObjects() again.
        //

        else if ( (WAIT_OBJECT_0 + dwCount) == dwWaitResult)
        {
            while (FALSE != PeekMessage(
                                &msg,
                                (HWND) 0,
                                0,
                                0,
                                PM_REMOVE))
            {
                if (WM_QUIT == msg.message)
                {
                    DH_ASSERT(FALSE == fGotQuitMessage) ;

                    fGotQuitMessage = TRUE ;
                    nQuitExitCode = (int) msg.wParam ;
                }
                else
                {
                    TranslateMessage(&msg) ;
                    DispatchMessage(&msg) ;
                }
            }
        }

        //
        // Else, some unusual situation has occurred; we
        // can just assert in this case and break out of
        // the loop
        //

        else
        {
            DH_ASSERT(!"MsgWaitForMultipleObjects() error") ;

            break ;
        }
    }

    //
    // If we got a WM_QUIT while waiting for the event re-post it now
    //

    if (fGotQuitMessage)
    {
        PostQuitMessage(nQuitExitCode);
    }

    return dwWaitResult ;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunningDebugOle
//
//  Synopsis:   Determines if were running under debug Ole
//
//  Parameters: None
//
//  Returns:    S_OK                                    -- Debug Ole
//              S_FALSE                                 -- Retail Ole
//              HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) -- Ole is not loaded
//
//  Algorithm:  Since there's no official way to tell if were running debug
//              Ole or not, we have to fall back to checking for debug-only
//              exports - we use "DumpATOM" here.
//
//  History:    13-Nov-95   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT RunningDebugOle()
{
    HMODULE     hModOle;

    hModOle = GetModuleHandle(TEXT("OLE32"));

    if (NULL == hModOle)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (NULL == GetProcAddress(hModOle, "DumpATOM"))
    {
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\dumpcmd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       dumpcmd.cpp
//
//  Contents:   dump commandline intelligently
//              
//  Functions:  
//
//  History:    07/29/97  SCousens     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;


struct _options
{
    LPTSTR name;
    LPTSTR value;
};

#define CHSLASH TEXT('/')
#define CHDASH  TEXT('-')
#define SAFESTRING(a) a ? a : TEXT("")
#define ABORTIF(a,b) if (a) {hr = b; goto EndOfFunction;}

#define FindNextToken(ptr, tok) \
while (TEXT('\0') != *(ptr) && tok != (*(ptr))) ++(ptr);

inline LPTSTR StringToken (LPTSTR ptr, TCHAR tok) 
{
    FindNextToken (ptr, tok);
    if (tok == *ptr) *ptr = NULL;
    else if (TEXT('\0') == *ptr) ptr = NULL;
    return ptr;
}


CONST TCHAR chNull      = TEXT('\0');

CONST TCHAR szCmdLine[] = TEXT("CommandLine:");     // Used DumpCmdLine
CONST TCHAR szCmdLineFail[] = TEXT("CommandLineFail:"); // Used DumpCmdLine


//+-------------------------------------------------------------------
//  Member:     DumpCmdLine, public
//
//  Synopsis:   Gets the commandline via GetCommandLine, appends the    
//              given string to it (additional options to reproduce 
//              particular test), and calls TraceMsg to output it.
//              Depending on fResult, the key word 'CommandLine' or
//              'CommandLineFail' will be prepended.
//
//  Arguments:  [fResult]- Pass or fail (to choose keyword).
//              [pszFmt] - Trace message format string.
//              [...]    - Arguments for format string.
//
//  Returns:    Nothing.
//
//  History:    09-Oct-97  SCousens   Created
//--------------------------------------------------------------------
void DumpCmdLine (DWORD fResult, LPTSTR pszFmt, ...)
{
    va_list varArgs;
    LPCTSTR ptKeyWord, ptCmdLine;
    TCHAR   szBuffer[CCH_MAX_DBG_CHARS];
    LPTSTR  pRepro = NULL;

    // figure out what key word to use
    ptKeyWord = (LOG_FAIL == fResult) ? szCmdLineFail : szCmdLine;

    // set our buffer...if we are given something format it nicely
    if (NULL != pszFmt && TCHAR('\0') != *pszFmt)
    {
        // format what we are given in the way of text.
        va_start(varArgs, pszFmt);
        _vsntprintf(szBuffer, CCH_MAX_DBG_CHARS, pszFmt, varArgs);
        szBuffer[CCH_MAX_DBG_CHARS-1] = chNull;
        va_end(varArgs);
    }
    else
    {
        szBuffer[0] = TCHAR('\0');
    }

    // Get the CommandLine
    ptCmdLine = GetCommandLine();
    if (NULL == ptCmdLine)
    {
        ptCmdLine = TEXT("GetCmdLine Error");
    }

    // now merge the two intelligently. parameters override cmdline
    // and dump the commandline and whatever we were given.
    if (S_OK == MergeParams (ptCmdLine, szBuffer, &pRepro))
    {
        DH_TRACE ((DH_LVL_ALWAYS, TEXT("%s:%s"), ptKeyWord, pRepro)); 
        delete []pRepro;
    }
    else
    {
        DH_TRACE ((DH_LVL_ALWAYS, TEXT("%s:%s %s"), 
                ptKeyWord, ptCmdLine, szBuffer));
    }
    return;
}

//+-------------------------------------------------------------------
//  Member:     MergeParams, private
//
//  Synopsis:   Given two sets of parameters, merge the two into one
//              set, without duplication. Last one wins.
//              given
//                 program /foo /bar /seed:0 /foo:bar
//                 /seed:1234 /ms:rules
//              returns
//                 program /foo:bar /bar /seed:1234 /ms:rules
//
//  Arguments:  [cmdline]    - contents of GetCommandLine call.
//              [additional] - additional options.
//              [repro]      - pointer for resulting string
//
//  Returns:    HRESULT - S_OK or failure
//
//  History:    10-Nov-97  SCousens   Created
//
//  Notes:       Caller must call delete [] on returned buffer
//--------------------------------------------------------------------

HRESULT MergeParams (LPCTSTR ptCmdLine, LPCTSTR ptAdditional, LPTSTR *ptRepro)
{
    struct _options *pOptions;
    int       x, y, n, l;
    int       nParams  = 1;
    HRESULT   hr       = S_OK;
    LPTSTR    pname, pvalue, pnext, ptr;
    LPTSTR    name, value;
    LPTSTR    ptCmd    = NULL;

    //validate our inputs/outputs
    DH_VDATESTRINGPTR (ptCmdLine);
    if (ptAdditional)
        DH_VDATESTRINGPTR (ptAdditional);
    DH_VDATEPTROUT (ptRepro, LPTSTR);
    
    // copy the strings into one buffer, coz we are going to stomp on them
    // how much space do we need?
    l = _tcslen (ptCmdLine);
    if (ptAdditional)
        l += _tcslen (ptAdditional);

    //allocate a buffer
    ptCmd = new TCHAR[l + 2];
    ABORTIF (NULL == ptCmd, E_OUTOFMEMORY);
    memset (ptCmd, 0xFA, l+2); //BUGBUG do this to find why we died in 
                               //FindNextToken at one point. Seem to have
                               //had a non-terminated string for some reason.

    //cat the two strings into the allocd buffer
    l = _stprintf (ptCmd, TEXT("%s"), ptCmdLine);
    if (ptAdditional)
        _stprintf (&ptCmd[l], TEXT(" %s"), ptAdditional);

    // count # parameters (ie spaces) in CmdLine
    ptr = ptCmd;
    while (NULL != *ptr)
    {
        if (TEXT(' ') == *ptr++)
            nParams++;
    }
    DH_TRACE ((DH_LVL_TRACE4, TEXT("Found %d params"), nParams));

    // allocate an _options for each possible parameter
    pOptions = new struct _options[nParams];
    ABORTIF (NULL == pOptions, E_OUTOFMEMORY);

    // go through and setup each of the _options (cmdline and given)
    for (pnext = ptCmd, nParams=0, x=0; NULL != pnext; x++)
    {
        pname = pnext;
        pnext = StringToken (pname, TEXT(' '));  //strtok/strchr equivalent
        if (pnext && NULL == *pnext)  //safety check
            pnext++;

        //ignore emptys caused by extra spaces
        if (NULL == *pname)
            continue;

        //change '-' to '/' so we are uniform in our comparison
        if (CHDASH == *pname)
            *pname = CHSLASH;
        pvalue = StringToken (pname, TEXT(':'));

        //deal with option
        name = new TCHAR[_tcslen (pname)+1];
        ABORTIF (NULL == name, E_OUTOFMEMORY);
        _tcscpy (name, pname);

        // if there is a value, deal with that
        value = 0; 
        if (NULL != pvalue)
        {
            pvalue++;  //move past ':'
            value = new TCHAR[_tcslen (pvalue)+1];
            ABORTIF (NULL == value, E_OUTOFMEMORY);
            _tcscpy (value, pvalue);
        }

        //name is pointing to a string for name
        //value is pointing to a string for val, else null
        DH_TRACE ((DH_LVL_TRACE4, TEXT("Item[%d]: name:'%s': value:'%s'"), 
                nParams, name, value ? value : TEXT("null")));
        pOptions[nParams].name = name;
        pOptions[nParams].value = value;
        nParams++;
    }

    // Now go thru and make a repro line without dups.
    // last one wins.
    for (x=0, l=0; x<nParams; x++)
    {
        // if its been used, skip it
        if  (0 == pOptions[x].name[0])
            continue;

        n = x;
        // look for dups, and if we have a dup, use the second one
        for (y=x+1; y<nParams; y++)
        {
            // if its been canned, skip it
            if  (0 == pOptions[y].name[0])
                continue;
            if (!_tcsicmp (pOptions[n].name, pOptions[y].name))
            {
                pOptions[n].name[0] = 0; //mark 'old' option as used
                n = y; // This is the one we will use
            }
        }

        //now n is the last option
        //add option[n] to end of line
        if (x) //prepend space all except 1st
            l+=_stprintf (&ptCmd[l], TEXT(" ")); 
        l+=_stprintf (&ptCmd[l], TEXT("%s"), pOptions[n].name);
        if (NULL != pOptions[n].value) //add value if there is one
            l+=_stprintf (&ptCmd[l], TEXT(":%s"), pOptions[n].value);
        pOptions[n].name[0] = 0; //mark this option as used
    }
    DH_TRACE ((DH_LVL_TRACE4, TEXT("cmd:%s"), ptCmd));

    //now delete the _options we allocated
    for (x=0; x<nParams; x++)
    {
        delete []pOptions[x].name;
        delete []pOptions[x].value;
    }
    delete []pOptions;

    //give them what they really want
    *ptRepro = ptCmd;

EndOfFunction:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\cdbgdlg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       cdbgdlg.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-10-95   kennethm   Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop
#include <debdlg.h>

// BUGBUG:KILL this ARRAYSIZE DEF when its becomes globally available.
#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof (a)/sizeof (a[0]))
#endif

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceLevels
//
//  Synopsis:
//
//  Arguments:  [hwndDlg]   --
//              [fTraceLvl] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateTraceLevels(HWND hwndDlg, DWORD fTraceLvl)
{
    TCHAR     szTraceLvl[MAX_PATH];

    //
    //  Trace Level flags
    //

    CheckDlgButton(hwndDlg, IDC_ADDREL, (fTraceLvl & DH_LVL_ADDREL) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_QI,     (fTraceLvl & DH_LVL_QI) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_INTERF, (fTraceLvl & DH_LVL_INTERF) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL1, (fTraceLvl & DH_LVL_TRACE1) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL2, (fTraceLvl & DH_LVL_TRACE2) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL3, (fTraceLvl & DH_LVL_TRACE3) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL4, (fTraceLvl & DH_LVL_TRACE4) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_FUNCIN, (fTraceLvl & DH_LVL_ENTRY) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_FUNCOUT,(fTraceLvl & DH_LVL_EXIT) ? 1 : 0);

    //
    //  Set trace level text
    //

    wsprintf(szTraceLvl, TEXT("%#08lx"), fTraceLvl);

    SetDlgItemText(hwndDlg, IDC_TRACELEVEL, szTraceLvl);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateLogLocations
//
//  Synopsis:
//
//  Arguments:  [hwndDlg] --
//              [fLogLoc] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateLogLocations(HWND hwndDlg, DWORD fLogLoc)
{
    CheckDlgButton(hwndDlg, IDC_LLDEBUGTERM, (fLogLoc & DH_LOC_TERM) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LLLOGFILE, (fLogLoc & DH_LOC_LOG) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LLCONSOLE, (fLogLoc & DH_LOC_STDOUT) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LLSPYWIN, (fLogLoc & DH_LOC_SPYWIN) ? 1 : 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceLocations
//
//  Synopsis:
//
//  Arguments:  [hwndDlg]   --
//              [fTraceLoc] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateTraceLocations(HWND hwndDlg, DWORD fTraceLoc)
{
    CheckDlgButton(hwndDlg, IDC_TLDEBUGTERM, (fTraceLoc & DH_LOC_TERM) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_TLLOGFILE, (fTraceLoc & DH_LOC_LOG) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_TLCONSOLE, (fTraceLoc & DH_LOC_STDOUT) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_TLSPYWIN, (fTraceLoc & DH_LOC_SPYWIN) ? 1 : 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceLevelFromText
//
//  Synopsis:
//
//  Arguments:  [hwndDlg]    --
//              [pfTraceLvl] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateTraceLevelFromText(HWND hwndDlg, DWORD *pfTraceLvl)
{
    CHAR            szTraceLvl[MAX_PATH];

    GetDlgItemTextA(hwndDlg, IDC_TRACELEVEL, szTraceLvl, MAX_PATH);
    sscanf(szTraceLvl, "%lx", pfTraceLvl);
    *pfTraceLvl &= DH_LVL_OUTMASK;
    UpdateTraceLevels(hwndDlg, *pfTraceLvl);
}

//+-------------------------------------------------------------------------
//
//  Function:   DebugDialogProc
//
//  Synopsis:
//
//  Arguments:  [hwndDlg] --
//              [uMsg]    --
//              [wParam]  --
//              [lParam]  --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CALLBACK CDebugHelp::OptionsDialogProc(
    HWND    hwndDlg,   // handle of dialog box
    UINT    uMsg,      // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam)    // second message parameter
{
    static DWORD    fLabMode;
    static DWORD    fBreakMode;
    static DWORD    fVerbose;
    static DWORD    fTraceLoc;
    static DWORD    fTraceLvl;
    static DWORD    fLogLoc;
    DWORD           fLevelMask = 0;
    DWORD           fTraceLocMask = 0;
    DWORD           fLogLocMask = 0;
    CDebugHelp     *pdh = 0;

    // get or set the this pointer.
    if (WM_INITDIALOG == uMsg)
    {
        // this pointer comes in as lParam. Save it.
        SetWindowLong (hwndDlg, DWL_USER, lParam);
        pdh = (CDebugHelp*)lParam;
    }
    else
    {
        pdh = (CDebugHelp*)GetWindowLong (hwndDlg, DWL_USER);
    }

    // if we dont have one, bail.
    if (NULL == pdh)
    {
        return FALSE;
    }

    // message processor
    switch (uMsg)
    {
    case WM_INITDIALOG:

        //
        //  Initialize the controls
        //

        fLabMode  = pdh->_fMode&DH_LABMODE ? DH_LABMODE_ON : DH_LABMODE_OFF;
        fBreakMode= pdh->_fMode&DH_BREAKMODE ? DH_BREAKMODE_ON : DH_BREAKMODE_OFF;
        fVerbose  = pdh->_fMode&DH_VERBOSE ? DH_VERBOSE_ON : DH_VERBOSE_OFF;
        fTraceLoc = pdh->_fTraceLoc;
        fTraceLvl = pdh->_fTraceLvl;
        fLogLoc   = pdh->_fLogLoc;

        //
        //  modes
        //
        if (DH_LABMODE_OFF == fLabMode)
        {
            CheckDlgButton(hwndDlg, IDC_POPUP, TRUE);
        }
        if (DH_BREAKMODE_ON == fBreakMode)
        {
            CheckDlgButton(hwndDlg, IDC_BREAK, TRUE);
        }
        if (DH_VERBOSE_ON == fVerbose)
        {
            CheckDlgButton(hwndDlg, IDC_VERBOSE, TRUE);
        }

        //
        //  Trace location flags
        //

        pdh->UpdateTraceLocations(hwndDlg, fTraceLoc);

        //
        //  Log Location flags
        //

        pdh->UpdateLogLocations(hwndDlg, fLogLoc);

        //
        //  Trace level flags
        //

        pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);

        // if no log object show the notification
        if (!pdh->_plog)
        {
            ShowWindow (GetDlgItem(hwndDlg, IDC_WARNING), SW_SHOW);
        }

        // display the spywindow class if there is one
        if (pdh->GetSpyWindowClass ())
        {
            SetDlgItemText (hwndDlg, IDC_SPYWINDOWLOC, pdh->GetSpyWindowClass ());
        }

        return TRUE;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
            // if log to file is set and we have a log file
            // create a log object
            if (fTraceLoc & DH_LOC_LOG || fLogLoc & DH_LOC_LOG)
            {
                CHAR    szLog[MAX_PATH] = {"/t:"};
                if (0 < GetDlgItemTextA (hwndDlg, 
                        IDC_LOGFILELOC, 
                        &szLog[3], 
                        sizeof (szLog) - 3))
                {
                    pdh->CreateLog (szLog);
                }
            }

            // if spywindow is set and we have a spy window class
            // set spy window class in debug object
            if (fTraceLoc & DH_LOC_SPYWIN || fLogLoc & DH_LOC_SPYWIN)
            {
                TCHAR    tszSpyWin[255] = {TEXT("")};
                if (0 < GetDlgItemText (hwndDlg, 
                        IDC_SPYWINDOWLOC, 
                        tszSpyWin, 
                        ARRAYSIZE (tszSpyWin)))
                {
                    pdh->SetSpyWindowClass (tszSpyWin);
                }
            }

            //
            //  The user pressed ok, save the settings
            //
            pdh->UpdateTraceLevelFromText(hwndDlg, &fTraceLvl);
            pdh->SetDebugInfo(
                            fLogLoc,
                            fTraceLoc,
                            fTraceLvl,
                            fLabMode | fBreakMode | fVerbose);

            if (IsDlgButtonChecked(hwndDlg, IDC_SAVE) == 1)
            {
                //
                //  Save the settings to the registry
                //
                pdh->WriteRegDbgInfo (DEFAULT_REG_LOC);
            }

            //
            //  Fall through
            //

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;

        // Popup and break are mutually exclusive. 
        // If one is turned on, turn other off.
        case IDC_POPUP:
            if (IsDlgButtonChecked(hwndDlg, wParam) == 1)
            {
                fLabMode = DH_LABMODE_OFF;
                fBreakMode = DH_BREAKMODE_OFF;
                CheckDlgButton (hwndDlg, IDC_BREAK, FALSE); //turn off Break.
            }
            else
            {
                fLabMode = DH_LABMODE_ON;
            }
            break;

        case IDC_BREAK:
            if (IsDlgButtonChecked(hwndDlg, wParam) == 1)
            {
                fBreakMode = DH_BREAKMODE_ON;
                fLabMode = DH_LABMODE_ON;
                CheckDlgButton (hwndDlg, IDC_POPUP, FALSE); //turn off Popup.
            }
            else
            {
                fBreakMode = DH_BREAKMODE_OFF;
            }
            break;

        case IDC_VERBOSE:
            if (IsDlgButtonChecked(hwndDlg, wParam) == 1)
            {
                fVerbose = DH_VERBOSE_ON;
            }
            else
            {
                fVerbose = DH_VERBOSE_OFF;
            }
            break;

        case IDC_TRACELEVEL:
            if (HIWORD(wParam) == EN_KILLFOCUS)
            {
                pdh->UpdateTraceLevelFromText(hwndDlg, &fTraceLvl);
            }
            break;

        case IDC_TLDEBUGTERM:
            fTraceLocMask = DH_LOC_TERM;
            break;
        case IDC_TLSPYWIN:
            fTraceLocMask = DH_LOC_SPYWIN;
            break;
        case IDC_TLCONSOLE:
            fTraceLocMask = DH_LOC_STDOUT;
            break;
        case IDC_TLLOGFILE:
            fTraceLocMask = DH_LOC_LOG;
            break;
        case IDC_LLDEBUGTERM:
            fLogLocMask = DH_LOC_TERM;
            break;
        case IDC_LLSPYWIN:
            fLogLocMask = DH_LOC_SPYWIN;
            break;
        case IDC_LLCONSOLE:
            fLogLocMask = DH_LOC_STDOUT;
            break;
        case IDC_LLLOGFILE:
            fLogLocMask = DH_LOC_LOG;
            break;
        case IDC_LEVEL1:
            fLevelMask = DH_LVL_TRACE1;
            break;
        case IDC_LEVEL2:
            fLevelMask = DH_LVL_TRACE2;
            break;
        case IDC_LEVEL3:
            fLevelMask = DH_LVL_TRACE3;
            break;
        case IDC_LEVEL4:
            fLevelMask = DH_LVL_TRACE4;
            break;
        case IDC_FUNCOUT:
            fLevelMask = DH_LVL_EXIT;
            break;
        case IDC_FUNCIN:
            fLevelMask = DH_LVL_ENTRY;
            break;
        case IDC_QI:
            fLevelMask = DH_LVL_QI;
            break;
        case IDC_ADDREL:
            fLevelMask = DH_LVL_ADDREL;
            break;
        case IDC_INTERF:
            fLevelMask = DH_LVL_INTERF;
            break;
        }

        //
        //  See if any of the mask have been changed.
        //  If one has been then update our local flag
        //

        if (fLevelMask != 0)
        {
            if (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == 0)
            {
                fTraceLvl &= ~fLevelMask;
            }
            else
            {
                fTraceLvl |= fLevelMask;
            }
            pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);
        }
        if (fLogLocMask != 0)
        {
            if (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == 0)
            {
                fLogLoc &= ~fLogLocMask;
            }
            else
            {
                fLogLoc |= fLogLocMask;
            }
            pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);
        }
        if (fTraceLocMask != 0)
        {
            if (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == 0)
            {
                fTraceLoc &= ~fTraceLocMask;
            }
            else
            {
                fTraceLoc |= fTraceLocMask;
            }
            pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);
        }

        break;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DebugOptionsDialog
//
//  Synopsis:
//
//  Arguments:  [hinstance] --
//              [hWnd]      --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CDebugHelp::OptionsDialog(HINSTANCE hinstance, HWND hWnd)
{
    HRESULT hr = S_OK;
    int     iRet;

    iRet = DialogBoxParam(
                hinstance,
                MAKEINTRESOURCE(IDD_DEBUGDIALOG),
                hWnd,
                OptionsDialogProc,
                (long)this);

    if (iRet == -1)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\cdbghelp.cxx ===
//+-------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       cdbghelp.cxx
//
//  Contents:   OLE Debug Helper Object
//
//  Classes:    CDebugHelper
//
//  History:    19-Nov-94   DeanE   Created
//---------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop


// Global library character constants - note alphabetical order for
// easy reference
//
CONST TCHAR chBackSlash = TEXT('\\');
CONST TCHAR chEqual     = TEXT('=');
CONST TCHAR chNewLine   = TEXT('\n');
CONST TCHAR chNull      = TEXT('\0');
CONST TCHAR chPeriod    = TEXT('.');
CONST TCHAR chSpace     = TEXT(' ');
CONST TCHAR chTrace     = TEXT(' ');
CONST TCHAR chTraceErr  = TEXT('e');

// Global library string contants - note alphabetical order for
// easy reference
//
CONST TCHAR szCRLF[]    = TEXT("\r\n");
CONST TCHAR szError[]   = TEXT("ERROR "); // Used TraceMsg for ERRORs
CONST TCHAR szNewLine[] = TEXT("\n");
CONST TCHAR szNull[]    = TEXT("");
CONST TCHAR szPeriod[]  = TEXT(".");


// Test Result Description strings
//
LPCTSTR szPass    = TEXT("VAR_PASS");
LPCTSTR szFail    = TEXT("VAR_FAIL");
LPCTSTR szAbort   = TEXT("VAR_ABORT");
LPCTSTR szWarn    = TEXT("WARNING");
LPCTSTR szInfo    = TEXT("INFO");
LPCTSTR szInvalid = TEXT("INVALID!!");

// Debug Helper Usage String
//
LPTSTR gptszDebugHelperUsageString = {
TEXT("Debug Object Command line options:\r\n")
TEXT("   /logloc    - where log output goes (bitfield)\r\n")
TEXT("   /traceloc  - where trace output goes (bitfield)\r\n")
TEXT("   /tracelvl  - trace levels (bitfield)\r\n")
TEXT("   /spyclass  - spy window\r\n")
TEXT("   /labmode   - do not use PopUp for errors\r\n")
TEXT("   /breakmode - break on error\r\n")
TEXT("   /verbose   - trace hrchecks that are ok\r\n")
};

int giAlwaysNegativeOne = -1;

// Global variable, the THREAD_VALIDATE_FLAG_ON bit of which at present is 
// used to do or skip thread validation DH_VDATETHREAD macro.  Other bits 
// might be used in future. Initialize the variable to set its bit
// THREAD_VALIDATE_FLAG_ON. 

ULONG g_fThreadValidate = THREAD_VALIDATE_FLAG_ON ;

//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CDebugHelp
//
//  Synopsis:   Initializes CDebugHelp object.  Makes object usable
//              in it's default state.
//
//  Arguments:  None.
//
//  Returns:    Nothing.  Constructor cannot fail.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
CDebugHelp::CDebugHelp() :
        _fLogLoc(DH_LOC_TERM),
        _fTraceLoc(DH_LOC_TERM),
        _fTraceLvl(DH_LVL_ALWAYS|DH_LVL_ERROR),
        _fMode(DH_LABMODE),
        _hrExpectedError(S_OK),
        _fCreatedLog(FALSE),
        _plog(NULL),
        _hwndAssert(NULL),
        _cPass(0),
        _cAbort(0),
        _cFail(0),
        _cIndentLevel(0),
        _fSpyWarning(0),  
        _pszSpyWindowClass((LPTSTR) SZ_DEFAULT_SPY_WINDOW_CLASS)
{
    DWORD cchModule;
    TCHAR szModule[CCH_MAX_MODULE];
    TCHAR szModule1[CCH_MAX_MODULE];
    short ret=0;

    lstrcpy(_szDbgPrefix, TEXT("NoName"));

    // Initialize the debug prefix string - it is the first
    // CCH_MAX_DBGPREFIX characters in the name of this
    // .exe, without the extension
    //
    
    cchModule = GetModuleFileName(NULL, szModule1, CCH_MAX_MODULE);

    if ((0 != cchModule) && (cchModule < CCH_MAX_MODULE))
    {
        ret = GetFileTitle(szModule1, szModule, sizeof(szModule));
    
        if (0 == ret)
        {
            //
            // Strip the .exe extension if it exists
            //

            cchModule = _tcslen(szModule);

            if (cchModule >= 4)     // if the name has at least 4 chars
            {
                if (0 == _tcsicmp(szModule + cchModule - 4, TEXT(".exe")))
                {
                    szModule[cchModule - 4] = TEXT('\0');
                }
            }

            //
            // Save the module name as the debug prefix
            //

            _tcscpy(_szDbgPrefix, szModule);
        }
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::~CDebugHelp
//
//  Synopsis:   Releases resources associated with the CDebugHelp class.
//              Sets member variables so the basic functions can work.
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
CDebugHelp::~CDebugHelp()
{
    // Set all member variables to valid default values
    _fLogLoc   = DH_LOC_TERM;
    _fTraceLoc = DH_LOC_TERM;
    _fTraceLvl = DH_LVL_ALWAYS|DH_LVL_ERROR;
    _fMode     = DH_LABMODE;

    // Close the log by deleting the log object, if we created it
    if (_fCreatedLog)
    {
        delete _plog;
    }

    _plog = NULL;
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::GetRegDbgInfo
//
//  Synopsis:   Initializes CDebugHelp object from the registry.  Even
//              if errors occur, the object is left in the usable
//              default state.
//
//  Arguments:  [pszRegKey] - Registy key holding necessary values.
//
//  Returns:    S_OK if values read and settings are valid, an error
//              code if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::GetRegDbgInfo(LPTSTR pszRegKey)
{
    CRegistryHelp *prhRegKey = NULL;
    HRESULT        hr        = E_FAIL;
    DWORD          fLabMode  = TRUE;
    DWORD          fBreakMode= FALSE;
    DWORD          fVerbose  = FALSE;

    // Open the registry key
    prhRegKey = new(NullOnFail) CRegistryHelp(
#ifndef _MAC
                                         HKEY_CURRENT_USER,
#else // _MAC
                                         HKEY_CLASSES_ROOT,
#endif // _MAC
                                         pszRegKey,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_READ,
                                         &hr);
    if (prhRegKey == NULL)
    {
        hr = MAKE_TH_ERROR_CODE(E_OUTOFMEMORY);
    }

    if (FAILED(hr))
    {
        delete prhRegKey;
        return(hr);
    }


    // Note: From this point, error returns don't mean return an
    // error, but set the default and return
    //

    // Get Trace Location value
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_TRACE_LOC,
                       &_fTraceLoc,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {
        _fTraceLoc = ValidateLoc(_fTraceLoc);
    }

    // Get Log Location value
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_LOG_LOC,
                       &_fLogLoc,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {
        _fLogLoc = ValidateLoc(_fLogLoc);
    }

    // Get Trace Level
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_TRACE_LVL,
                       &_fTraceLvl,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {
        _fTraceLvl = ValidateLvl(_fTraceLvl) | DH_LVL_ALWAYS | DH_LVL_ERROR;
    }

    // Get Mode
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_LABMODE,
                       &fLabMode,
                       REG_DWORD);
    if (SUCCEEDED(hr) && fLabMode)
    {
        _fMode = DH_LABMODE;
    }

    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_BREAKMODE,
                       &fBreakMode,
                       REG_DWORD);
    if (SUCCEEDED(hr) && fBreakMode)
    {
        _fMode |= DH_BREAKMODE;
    }

    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_VERBOSE,
                       &fVerbose,
                       REG_DWORD);
    if (SUCCEEDED(hr) && fVerbose)
    {
        _fMode |= DH_VERBOSE;
    }

    _fMode = ValidateMode(_fMode);

    // Clean up and exit
    delete prhRegKey;

    hr = S_OK;

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::WriteRegDbgInfo
//
//  Synopsis:   Write the current state of the CDebugHelp object to
//              the registry.
//
//  Arguments:  [pszRegKey] - Registy key to write to.
//
//  Returns:    S_OK if values written, an error code if not.
//
//  History:    21-Apr-96   Kennethm   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::WriteRegDbgInfo(LPTSTR pszRegKey)
{
    CRegistryHelp *prhRegKey = NULL;
    HRESULT        hr        = E_FAIL;

    // Open the registry key
    prhRegKey = new(NullOnFail) CRegistryHelp(
#ifndef _MAC
                                         HKEY_CURRENT_USER,
#else // _MAC
                                         HKEY_CLASSES_ROOT,
#endif // _MAC
                                         pszRegKey,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_WRITE,
                                         &hr);
    if (prhRegKey == NULL)
    {
        hr = MAKE_TH_ERROR_CODE(E_OUTOFMEMORY);
    }

    if (FAILED(hr))
    {
        delete prhRegKey;
        return(hr);
    }


    // Write Trace Location value
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_TRACE_LOC,
                       _fTraceLoc,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {

    // Write Log Location value
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_LOG_LOC,
                       _fLogLoc,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Trace Level
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_TRACE_LVL,
                       _fTraceLvl,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Lab Mode
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_LABMODE,
                       _fMode&DH_LABMODE ? TRUE : FALSE,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Break Mode
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_BREAKMODE,
                       _fMode&DH_BREAKMODE ? TRUE : FALSE,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Verbose
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_VERBOSE,
                       _fMode&DH_VERBOSE ? TRUE : FALSE,
                       REG_DWORD);
    }

    // Clean up and exit
    delete prhRegKey;

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CreateLog, public
//
//  Synopsis:   Creates a new log based on the parameters passed.
//
//  Arguments:  [argc] - Number of command line args
//              [argv] - Command line args
//
//  Returns:    S_OK if log created successfully or none is specified,
//              E_FAIL if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::CreateLog(int argc, char **argv)
{
    HRESULT hr = S_OK;

    // Check for existing log
    if ((_plog != NULL)  && (_fCreatedLog == TRUE))
    {
        delete _plog;
    }

    // Create the new log
    _plog = new(NullOnFail) Log(argc, argv, LOG_ANSI);
    if (NULL == _plog)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    if (NO_ERROR != _plog->ConfirmCreation())
    {
        delete _plog;
        hr = E_FAIL;
    }

    // Set _fCreatedLog flag to true so the log will get deleted during
    // cleanup (otherwise the calling process must delete it).
    //
    if (SUCCEEDED(hr))
    {
        _fCreatedLog = TRUE;
    }

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CreateLog, public
//
//  Synopsis:   Creates a new log based on the parameters passed.
//
//  Arguments:  [paszCmdline] - Windows-style ANSI command line.
//
//  Returns:    S_OK if log created successfully or none is specified,
//              E_FAIL if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::CreateLog(LPSTR paszCmdline)
{
    HRESULT   hr   = S_OK;
    int       argc = 0;
    CHAR    **argv = NULL;

    // Convert pszCmdline to argc/argv parameters
    hr = CmdlineToArgs(paszCmdline, &argc, &argv);
    if (FAILED(hr))
    {
        return(hr);
    }

    // Check for existing log
    if ((_plog != NULL)  && (_fCreatedLog == TRUE))
    {
        delete _plog;
    }

    // Create the new log
    _plog = new(NullOnFail) Log(argc, argv, LOG_ANSI);
    if (NULL == _plog)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    if (NO_ERROR != _plog->ConfirmCreation())
    {
        delete _plog;
        hr = E_FAIL;
    }

    // Set _fCreatedLog flag to true so the log will get deleted during
    // cleanup (otherwise the calling process must delete it).
    //
    if (SUCCEEDED(hr))
    {
        _fCreatedLog = TRUE;
    }

    //
    // Delete the argc/argv command line created by CmdlineToArgs
    //


    while (argc > 0)
    {
        --argc;
        delete argv[argc];
    }

    delete argv;

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetLog, public
//
//  Synopsis:   Sets the log pointer to the one passed.  This one should
//              not be deleted.  Deletes existing log is appropriate.  If
//              NULL is passed, the old log is deleted and the new log
//              is set to NULL (none).
//
//  Arguments:  [plog] - Pointer to new log.
//
//  Returns:    S_OK if log set successfully, E_FAIL if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetLog(Log *plog)
{
    HRESULT hr = E_FAIL;

    // Make sure new log pointer is valid
    if ((NULL == plog) || (FALSE == IsBadReadPtr(plog, sizeof(Log *))))
    {
        // Free old log if we have one
        if ((_plog != NULL) && (_fCreatedLog == TRUE))
        {
            delete _plog;
        }

        // Set new log; we should not delete the pointer
        _plog        = plog;
        _fCreatedLog = FALSE;
        hr           = S_OK;
    }
    else
    {
        OutputDebugString(TEXT("Invalid log pointer"));
    }

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetDebugInfo, public
//
//  Synopsis:   Sets debug information.
//
//  Arguments:  [fLogLoc]   - New Log Location setting.
//              [fTraceLoc] - New Trace Location setting.
//              [fTraceLvl] - New Trace Level setting.
//              [fMode]     - New Mode setting.
//
//  Returns:    S_OK 
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens revamp fMode
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetDebugInfo(
        DWORD fLogLoc,
        DWORD fTraceLoc,
        DWORD fTraceLvl,
        DWORD fMode)
{
    // Validate New settings
    fLogLoc   = ValidateLoc(fLogLoc);
    fTraceLoc = ValidateLoc(fTraceLoc);
    fTraceLvl = ValidateLvl(fTraceLvl);
    fMode     = ValidateMode(fMode);
                                                                   
    // Assign new values                                           
    if (fLogLoc != DH_LOC_SAME)                                    
    {
        _fLogLoc = fLogLoc;                                        
    }
                                                                   
    if (fTraceLoc != DH_LOC_SAME)
    {                                                              
        _fTraceLoc = fTraceLoc;                                    
    }
                                                                   
    if (fTraceLvl != DH_LVL_SAME)                                    
    {
        _fTraceLvl = DH_LVL_ALWAYS|DH_LVL_ERROR|fTraceLvl;
    }
    
    // Set mode bits, one by one
    if ((fMode & DH_LABMODE_SET) || 
            (fMode & DH_BREAKMODE_SET) || 
            (fMode & DH_VERBOSE_SET))
    {
        DWORD   fNewMode;
        fNewMode = fMode & DH_LABMODE_SET ? 
                fMode & DH_LABMODE : 
                _fMode & DH_LABMODE;

        fNewMode |= fMode & DH_BREAKMODE_SET ? 
                fMode & DH_BREAKMODE : 
                _fMode & DH_BREAKMODE;

        fNewMode |= fMode & DH_VERBOSE_SET ? 
                fMode & DH_VERBOSE : 
                _fMode & DH_VERBOSE;

        // mask off the SET bits
        _fMode = fNewMode & 
                ~(DH_LABMODE_SET | 
                DH_BREAKMODE_SET | 
                DH_VERBOSE_SET) ;
    }
    
    // Reset the warning flag (in OutputMsg)
    _fSpyWarning = FALSE;  

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetPopupWindow, public
//
//  Synopsis:   Associates the window handle passed with the Assert
//              popups that can occur if Lab Mode is set FALSE.  Simply
//              replaces any existing window handle - does not close
//              it, etc.
//
//  Arguments:  [hwnd] - New window handle
//
//  Returns:    S_OK if set successfully, E_FAIL if not.
//
//  History:    1-Dec-94    DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetPopupWindow(HWND hwnd)
{
    _hwndAssert = hwnd;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Member:     CDebughelp::SetSpyWindowClass, public
//
//
//  Synopsis:   Set the window class that all spy window output will
//              go to.
//
//  Arguments:  [pszSpyWindowClass]     -- pointer to class name
//
//  Returns:    S_OK
//  
//  Algorithm:  If the old spy class is not equal to the default one,
//              free up the buffer we allocated.  Then create a new
//              buffer and copy the new class string into it.
//
//  History:    09-Aug-95   MikeW   Created
//
//  Notes:      If an error is returned the old class is preserved.
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetSpyWindowClass(const LPTSTR pszSpyWindowClass)
{
    HRESULT hr = S_OK;
    LPTSTR  pszTemp;

    if (_pszSpyWindowClass != SZ_DEFAULT_SPY_WINDOW_CLASS)
    {
        delete [] _pszSpyWindowClass;
    }

    pszTemp = new TCHAR[_tcslen(pszSpyWindowClass) + 1];

    if (NULL == pszTemp)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        _pszSpyWindowClass = pszTemp;
        _tcscpy(_pszSpyWindowClass, pszSpyWindowClass);
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::TraceMsg, public
//
//  Synopsis:   Outputs the debug string to the current location setting
//              if any set bit in the level passed match set bits in the
//              global level.
//
//  Arguments:  [fLvl]   - Trace level.
//              [pszFmt] - Trace message format string.
//              [...]    - Arguments for format string.
//
//  Returns:    Nothing.
//
//  History:    20-Oct-93   DeanE    Created
//              10-Apr-97   SCousens Spiff up output string on error
//--------------------------------------------------------------------
void CDebugHelp::TraceMsg(DWORD fLvl, LPTSTR pszFmt, ...)
{
    TCHAR   szBuffer[CCH_MAX_DBG_CHARS];
    TCHAR   szDebug[CCH_MAX_DBG_CHARS +
                    CCH_MAX_DBGPREFIX +
                    CCH_MAX_INDENTPRINT + 6 ];
    TCHAR   szSpaces[CCH_MAX_INDENTPRINT];
    va_list varArgs;

    // If the level has DH_LVL_ENTRY in it indent by one
    //
    if (fLvl & DH_LVL_ENTRY)
    {
        _cIndentLevel++;
    }

    // If all of the bits match, then we will output the string to the
    // current location(s)
    //
    if ((fLvl & _fTraceLvl) == fLvl)
    {
        // Print the caller's string to a buffer
        va_start(varArgs, pszFmt);
        _vsntprintf(szBuffer, CCH_MAX_DBG_CHARS, pszFmt, varArgs);
        szBuffer[CCH_MAX_DBG_CHARS-1] = chNull;
        va_end(varArgs);

        // Add correct number of space for indentation
        lstrcpy(szSpaces, TEXT("              "));
        if (_cIndentLevel < CCH_MAX_INDENTPRINT)
        {
            szSpaces[_cIndentLevel]=TEXT('\0');
        }

        // Now prepend it with the debug prefix
        _sntprintf(szDebug,
                   CCH_MAX_DBG_CHARS,
                   TEXT("%s: %c %s%s%s"),
                   _szDbgPrefix,
                   DH_LVL_ERROR & fLvl ? chTraceErr : chTrace,
                   szSpaces,
                   DH_LVL_ERROR & fLvl ? szError : szNull,
                   szBuffer);
        szDebug[CCH_MAX_DBG_CHARS-1] = chNull;

        // Now, spit the thing out to the proper places
        OutputMsg(_fTraceLoc, szDebug);
    }

    // If the level has DH_LVL_EXIT in it unindent by one
    //
    if (fLvl & DH_LVL_EXIT)
    {
        _cIndentLevel--;
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ReportResult, public
//
//  Synopsis:   Outputs the test variation and result to the location(s)
//              currently specified.
//
//  Arguments:  [usResult] - Result of the test
//              [pszFmt]   - Format of the log message
//              [...]      - Parameters for message
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
void CDebugHelp::ReportResult(USHORT usResult, LPTSTR pszFmt, ...)
{
    HRESULT  hr     = E_FAIL;
    TCHAR    szFmtBuffer[CCH_MAX_LOG_CHARS];
    TCHAR    szLogBuffer[CCH_MAX_LOG_CHARS];
    va_list  varArgs;

    // format variable arg list into a buffer.
    va_start(varArgs, pszFmt);
    _vsntprintf(szFmtBuffer, CCH_MAX_LOG_CHARS, pszFmt, varArgs);
    szFmtBuffer[CCH_MAX_LOG_CHARS-1] = chNull;
    va_end(varArgs);


    // Set up log buffer. Truncate any extra chars.
    _sntprintf(szLogBuffer,
               CCH_MAX_LOG_CHARS,
               TEXT("%s: %s"),
               GetResultText(usResult),
               szFmtBuffer);
    szLogBuffer[CCH_MAX_LOG_CHARS-1] = chNull;

    SetStats(usResult);

    // Send it out
    OutputMsg(_fLogLoc, szLogBuffer);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ReportStats, public
//
//  Synopsis:   Outputs statistics about test variations run so far,
//              such as #tests run, #passed, #failed, etc to the Log
//              Location (_fLogLoc).
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
void CDebugHelp::ReportStats()
{
    TCHAR szBuffer[CCH_MAX_LOG_CHARS];

    _sntprintf(szBuffer, CCH_MAX_LOG_CHARS,
               TEXT("Summary--> Passed: %lu ; Failed: %lu ; Aborted: %lu"),
               _cPass,
               _cFail,
               _cAbort);
    szBuffer[CCH_MAX_LOG_CHARS-1] = chNull;

    OutputMsg(_fLogLoc, szBuffer);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::LabAssertEx, public
//
//  Synopsis:   Produces an assert message to the current debug
//              location(s) or to a dialog box, if running in non-Lab
//              mode.
//
//  Arguments:  [szFile] - File assert occurred in.
//              [nLine]  - Line assert occurred.
//              [nszMsg] - Assert message.
//
//  Returns:    Nothing.
//
//  History:    20-Oct-93   DeanE   Created
//--------------------------------------------------------------------
void CDebugHelp::LabAssertEx(LPCTSTR szFile, int nLine, LPCTSTR szMsg)
{
    TCHAR szBuffer[CCH_MAX_ASSERT_CHARS];
    int   nAnswer;

    _sntprintf(szBuffer,
               CCH_MAX_ASSERT_CHARS,
               TEXT("Assert!!!  File: %s, Line: %d, %s\n"),
               szFile,
               nLine,
               szMsg);
    szBuffer[CCH_MAX_ASSERT_CHARS-1] = chNull;

    // always spew
    OutputMsg(_fTraceLoc, szBuffer);

    // if labmode, popup
    if (FALSE == (_fMode & DH_LABMODE))
    {
        nAnswer = MessageBox(
                         _hwndAssert,
                         szBuffer,
                         TEXT("CT OLE Assert"),
                         MB_ICONEXCLAMATION | MB_OKCANCEL);
        if (IDCANCEL==nAnswer)
        {
            DebugBreak();
        }
    }
    // if break, break
    else if (FALSE != (_fMode & DH_BREAKMODE))
    {
        DebugBreak();
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CheckResult, public
//
//  Synopsis:   Compares the hr passed in with expected hr passed in
//
//  Arguments:  [hrCheck]     - Result to check.
//              [hrExpected]  - Result expected.
//              [pszFuncName] - Name of the current function
//              [pszMsg]      - Debug message if result not in list passed.
//              [nLine]       - __LINE__ macro
//              [pszFile]     - __FILE__ macro
//
//  Returns:    Nothing.
//
//  History:    12-Aug-94   KennethM    Created
//               1-Dec-94   DeanE       Incorporated into CDebugHelp class
//              12-Apr-95   KennethM    Only checks against S_OK
//              10-Apr-97   SCousens    Check against errors also
//--------------------------------------------------------------------
HRESULT CDebugHelp::CheckResult (HRESULT hrCheck, 
        HRESULT hrExpected, 
        LPTSTR pszFuncName, 
        LPTSTR pszMsg, 
        int    nLine, 
        LPTSTR pszFile)
{
    TCHAR   szAssertBuf[CCH_MAX_ASSERT_CHARS];
    TCHAR   szAssertTitle[CCH_MAX_ASSERT_CHARS];
    TCHAR   szMsgBuffer[CCH_MAX_ASSERT_CHARS];
    DWORD   cchMsgBuffer = 0;
    int     nAnswer;
    HRESULT hr = S_OK;

    // If _dwExpectedError is set, then someone up the call chain
    // wants us to ignore that error code, even if our direct caller
    // does not.  If the incoming error code matches _dwExpectedError,
    // then ignore it and return.
    if ( ( _hrExpectedError != S_OK ) && ( hrCheck == _hrExpectedError ) )
    {
        return S_OK;
    }

    // figure out if we have a problem
    if (hrCheck != hrExpected)
    {
        if (FAILED(hrCheck))
        {
            hr = hrCheck;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    // No problem, prepare to bail
    if (S_OK == hr)
    {
        // if we are verbose, call tracemsg 
        if (FALSE != (DH_VERBOSE & _fMode))
        {
            TraceMsg(DH_LVL_ALWAYS,
                    S_OK == hrExpected ?  // different output if HRCHECK
                        TEXT("%s; %s; ok") :
                        TEXT("%s; %s; hr=%#lx; ok"),
                    pszFuncName,
                    pszMsg,
                    hrCheck);
        }
        return hr;
    }

    // Get the text for the HRESULT from the system
    cchMsgBuffer = FormatMessage(
                         FORMAT_MESSAGE_FROM_SYSTEM | 
                         FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         hrCheck,
                         GetSystemDefaultLangID(),
                         szMsgBuffer,
                         CCH_MAX_ASSERT_CHARS,
                         NULL);
    szMsgBuffer[CCH_MAX_ASSERT_CHARS-1] = chNull;

    if (0 == cchMsgBuffer)
    {
        _sntprintf(
                szMsgBuffer,   
                CCH_MAX_ASSERT_CHARS, 
                TEXT("Error 0x%08x"),
                hrCheck);
    }
    else  // zap any \r\n from the FormatMessage
    {
        while ('\r' == szMsgBuffer[cchMsgBuffer-1] || 
                '\n' == szMsgBuffer[cchMsgBuffer-1])
        {
            szMsgBuffer[--cchMsgBuffer] = chNull;
        }
    }

    // Output to Trace Location
    TraceMsg(DH_LVL_ERROR,
            S_OK == hrExpected ?  // different output if HRCHECK
                TEXT("%s; %s; hr=%lx; %s") :
                TEXT("%s; %s; hr=%lx;"),
            pszFuncName,
            pszMsg,
            hr,
            szMsgBuffer);
    // If we are comparing against failure, show what we expected and got.
    if (S_OK != hrExpected)
    {
        TraceMsg(DH_LVL_ALWAYS,
                TEXT("+  hr Expected:%#lx; Got:%#lx; %s"),
                hrExpected,
                hrCheck,
                szMsgBuffer);
    }
    TraceMsg(DH_LVL_ALWAYS,
             TEXT("+  File:%s; Line:%d"),
             pszFile,
             nLine);

    // labmode - display an error popup
    if (FALSE == (_fMode & DH_LABMODE))
    {
        _sntprintf(szAssertBuf,
                   CCH_MAX_ASSERT_CHARS,
                   TEXT("%s : hr=%#lx : Expected %#lx\n%s\n"),
                   pszMsg, 
                   hrCheck, 
                   hrExpected,
                   szMsgBuffer);
        szAssertBuf[CCH_MAX_ASSERT_CHARS-1] = chNull;

        _sntprintf(szAssertTitle,
                   CCH_MAX_ASSERT_CHARS,
                   TEXT("CT OLE - %s Error"),
                   _szDbgPrefix);
        szAssertTitle[CCH_MAX_ASSERT_CHARS-1] = chNull;

        // Do we want to debug this?
        nAnswer = MessageBox(
                         _hwndAssert,
                         szAssertBuf,
                         szAssertTitle,
                         MB_ICONSTOP | MB_OKCANCEL);
        // yes we do?
        if (IDCANCEL==nAnswer)
        {
            DebugBreak();
        }
    }
    // break mode, break into the debugger
    else if (FALSE != (_fMode & DH_BREAKMODE))
    {
        DebugBreak();
    }
    return hr;
}

//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetExpectedError, public
//
//  Synopsis:   Disables error logging for the specified error code.
//
//  Arguments:  [hrExpectedError] - Error code to disable.  Pass S_OK
//                                   for no expected errors.
//
//  Returns:    Nothing.
//
//  History:    16-Sep-97   BWill       Created
//
//  Notes:      -- Use this call to temporarily disable error logging
//                  in client code.
//              -- Call this function with S_OK to enable all checks.
//              -- See also DH_EXPECTEDERROR/DH_NOEXPECTEDERROR in
//                  cdbghelp.hxx.
//--------------------------------------------------------------------
void CDebugHelp::SetExpectedError( HRESULT hrExpectedError )
{
    _hrExpectedError = hrExpectedError;
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ValidateLoc, private
//
//  Synopsis:   Checks the location flag passed to insure it is a legal
//              value.
//
//  Arguments:  [fLoc] - Location flag to check.
//
//  Returns:    Legal version of what we were to check.
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens Return legal value
//--------------------------------------------------------------------
DWORD CDebugHelp::ValidateLoc(DWORD fLoc)
{
    // Get what we can out of supplied location
    return (DH_LOC_VALID & fLoc);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ValidateLvl, private
//
//  Synopsis:   Checks the Trace Level flag passed to insure it is a
//              legal value.
//
//  Arguments:  [fLvl] - Trace Level to check.
//
//  Returns:    Legal version of what we were to check.
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens Return legal value
//--------------------------------------------------------------------
DWORD CDebugHelp::ValidateLvl(DWORD fLvl)
{
    // Make sure a valid setting is passed
    return (~DH_LVL_INVMASK & fLvl);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ValidateMode, private
//
//  Synopsis:   Checks the Lab Mode flag passed to insure it is a
//              legal value.
//
//  Arguments:  [fMode] - Flag to check.
//
//  Returns:    Legal version of what we were to check.
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens Return legal value
//--------------------------------------------------------------------
DWORD CDebugHelp::ValidateMode(DWORD fMode)
{
    return (fMode & (~DH_INVMODE));
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetStats, private
//
//  Synopsis:   Sets stats based on result
//
//  Arguments:  [usResult] - Result to add.
//
//  Returns:    nothing.
//
//  History:    20-Oct-93   DeanE   Created
//--------------------------------------------------------------------
VOID CDebugHelp::SetStats(USHORT usResult)
{

    switch (usResult)
    {
    case LOG_PASS:
        _cPass++;
        break;

    case LOG_FAIL:
        _cFail++;
        break;

    case LOG_ABORT:
        _cAbort++;
        break;

    default:
        // do nothing.
        break;
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::GetResultText, private
//
//  Synopsis:   Determines the correct text to printf for the result code
//              passed.  Result code corresponds to LogServer result codes.
//
//  Arguments:  [usResult] - Result to look up.
//
//  Returns:    Pointer to output string corresponding to the result
//              code passed (ie "PASSED" for LOG_PASS).
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
LPCTSTR CDebugHelp::GetResultText(USHORT usResult)
{
    LPCTSTR szResult = NULL;
    TCHAR   szAssert[CCH_MAX_DBG_CHARS];

    switch (usResult)
    {
    case LOG_PASS:
        szResult = szPass;
        break;

    case LOG_FAIL:
        szResult = szFail;
        break;

    case LOG_ABORT:
        szResult = szAbort;
        break;

    case LOG_WARN:
        szResult = szWarn;
        break;

    case LOG_INFO:
        szResult = szInfo;
        break;

    default:
        szResult = szInvalid;
        _sntprintf(szAssert,
                   CCH_MAX_DBG_CHARS,
                   TEXT("Invalid Test Result=%ld"),
                   usResult);
        szAssert[CCH_MAX_DBG_CHARS-1] = chNull;
        LabAssertEx(TEXT(__FILE__), __LINE__, szAssert);
        break;
    }

    return(szResult);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::OutputMsg, private
//
//  Synopsis:   Outputs the buffer to the locations specified.
//              Location, log, and buffer are all assumed to be valid,
//              so no error checking is done.
//
//  Arguments:  [fLoc]      - Location(s) to output buffer to.
//              [pszBuffer] - Buffer to output.
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//              08-Mar-95   MikeW   Added DH_LOC_SPYWIN stuff
//--------------------------------------------------------------------
void CDebugHelp::OutputMsg(DWORD fLoc, LPTSTR pszBuffer)
{
    CHAR szLogBuf[CCH_MAX_LOG_CHARS];

    if (fLoc & DH_LOC_TERM)
    {
        OutputDebugString(pszBuffer);
        OutputDebugString(szNewLine);
    }

    if (fLoc & DH_LOC_STDOUT)
    {
        _tprintf(TEXT("%s\n"), pszBuffer);
    }

    if (fLoc & DH_LOC_LOG)
    {
        if (FALSE == IsBadReadPtr(_plog, sizeof(Log *)))
        {
            // Buffer must be ANSI regardless of platform
#ifdef UNICODE
            _snprintf(szLogBuf, CCH_MAX_LOG_CHARS, "%ls", pszBuffer);
#else
            _snprintf(szLogBuf, CCH_MAX_LOG_CHARS, "%s", pszBuffer);
#endif
            szLogBuf[CCH_MAX_LOG_CHARS-1] = chNull;
            _plog->WriteData(szLogBuf);
        }
        else
        {
            // Trying to write to log that doesn't exist!
            OutputDebugString(TEXT("CDebugHelp: Unable to write to Log File!\n"));
        }
    }

    if (fLoc & DH_LOC_SPYWIN)
    {
        HWND    hWndSpy;

        hWndSpy = FindWindow(_pszSpyWindowClass, NULL);

        if (NULL != hWndSpy)
        {
            SendMessage(hWndSpy, LB_ADDSTRING, 0, (LPARAM) pszBuffer);
            SendMessage(hWndSpy, LB_ADDSTRING, 0, (LPARAM) szCRLF);
        }
        else if (FALSE == _fSpyWarning)
        {
            //only spew this once, till someone changes the settings.
            _fSpyWarning = TRUE;  
            // Unable to find SpyWindow
            OutputDebugString(TEXT("CDebugHelp: Spy Window not found!\n"));
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeDebugObject
//
//  Synopsis:   Initialize the debug helper (trace levels, etc.)
//
//  Arguments:  (none)
//
//  Returns:    S_OK if all went well
//              S_FALSE if we encountered /? and spewed and bailed.
//
//  History:    29-Apr-05   kennethm    Created
//              09-Aug-95   MikeW       Override defaults w/ command line
//              10-Apr-97   SCousens    move into CDebugHelp
//--------------------------------------------------------------------------

HRESULT CDebugHelp::Initialize()
{
    HRESULT hr = S_OK;
    int     nRet;

    LPTSTR  pszSpyClass = NULL;

    CUlongCmdlineObj cmdTraceLvl (OLESTR("tracelvl"),   OLESTR("Trace levels"));
    CUlongCmdlineObj cmdTraceLoc (OLESTR("traceloc"),   OLESTR("Trace output"));
    CUlongCmdlineObj cmdLogLoc   (OLESTR("logloc"),     OLESTR("Log output"));
    CBoolCmdlineObj  cmdDebugUI  (OLESTR("DebugUI"),    OLESTR("Popup debug dialog"), OLESTR("FALSE"));
    CBoolCmdlineObj  cmdLabMode  (OLESTR("labmode"),    OLESTR("Popup on error"), OLESTR("FALSE"));
    CBoolCmdlineObj  cmdBreak    (OLESTR("breakmode"),  OLESTR("Break on error"), OLESTR("FALSE"));
    CBoolCmdlineObj  cmdVerbose  (OLESTR("verbose"),    OLESTR("Trace HRCHECK for a noisy log"), OLESTR("FALSE"));
    CBaseCmdlineObj  cmdSpyClass (OLESTR("spyclass"),   OLESTR("Classname for Spy Window"));
    CCmdline         cmdlineArgs;

    CBaseCmdlineObj *aPossCmdline[] = {
                              &cmdTraceLvl,
                              &cmdTraceLoc,
                              &cmdLogLoc,
                              &cmdDebugUI,
                              &cmdLabMode,
                              &cmdVerbose,
                              &cmdBreak,
                              &cmdSpyClass };

    //
    //  Read the debug options from the registry
    //
    hr = GetRegDbgInfo (DEFAULT_REG_LOC);

    //
    //  Now that we have the defaults from the registry read the command
    //  line to over-ride them.
    //
    if (hr == S_OK)
    {
        //
        //  Make sure there were no errors starting up the cmd line objects
        //
        nRet = cmdlineArgs.QueryError();
        if (nRet != CMDLINE_NO_ERROR)
        {
            hr = E_FAIL;
            TraceMsg (DH_LVL_ERROR, TEXT("cmdlineArgs.QueryError"));
        }
    }

    if (hr == S_OK)
    {
        //
        //  Now parse the command line
        //

        nRet = cmdlineArgs.Parse(aPossCmdline,
                      sizeof(aPossCmdline)/sizeof(CBaseCmdlineObj *),
                      FALSE);
        if (nRet != CMDLINE_NO_ERROR)
        {
            hr = E_FAIL;
            TraceMsg (DH_LVL_ERROR, TEXT("cmdlineArgs.Parse"));
        }
    }

    if (hr == S_OK)
    {
        DWORD dwLogLoc   = DH_LOC_SAME;
        DWORD dwTraceLoc = DH_LOC_SAME;
        DWORD dwTraceLvl = DH_LVL_SAME;
        DWORD dwMode     = 0;

        if (cmdLabMode.IsFound())
        {
            dwMode = *cmdLabMode.GetValue () ? DH_LABMODE_ON : DH_LABMODE_OFF;
        }
        if (cmdVerbose.IsFound())
        {
            dwMode |= *cmdVerbose.GetValue () ? DH_VERBOSE_ON : DH_VERBOSE_OFF;
        }
        if (cmdBreak.IsFound())
        {
            dwMode |= *cmdBreak.GetValue () ? DH_BREAKMODE_ON : DH_BREAKMODE_OFF;
        }
        if (cmdTraceLvl.IsFound())
        {
            dwTraceLvl = *cmdTraceLvl.GetValue();
        }
        if (cmdTraceLoc.IsFound())
        {
            dwTraceLoc = *cmdTraceLoc.GetValue();
        }
        if (cmdLogLoc.IsFound())
        {
            dwLogLoc = *cmdLogLoc.GetValue();
        }
        SetDebugInfo(         \
                dwLogLoc,     \
                dwTraceLoc,   \
                dwTraceLvl,   \
                dwMode);

        if (cmdSpyClass.IsFound())
        {
            OleStringToTString(cmdSpyClass.GetValue(), &pszSpyClass);

            if (NULL != pszSpyClass)
            {
                SetSpyWindowClass (pszSpyClass);
                delete [] pszSpyClass;
            }
        }
        if (cmdDebugUI.IsFound())
        {
            HRESULT hr2 = OptionsDialog (GetModuleHandle (NULL), GetActiveWindow ());
            if (FAILED(hr2))
            {
                TraceMsg (DH_LVL_ERROR, 
                        TEXT("DialogBoxParam failed; hr=%#x. (Is dlg in res?)"),
                        hr2);
            }
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEntryExitTrace::CEntryExitTrace
//
//  Synopsis:   Displays a debug line saying the current function is being
//              entered.  Saves the information so it can be displayed
//              when the destructor is called.
//
//  Arguments:  [pDebugObject] -- The parent debug log object
//              [plExitOutput] -- The 32 value to display on exit (can be
//                                NULL)
//              [fLvl]         -- The trace level of this function
//              [pszFuncName]  -- The name of this function
//
//  Returns:
//
//  History:    4-10-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CEntryExitTrace::CEntryExitTrace(
            CDebugHelp *pDebugObject,
            PLONG       plExitOutput,
            DWORD       fLvl,
            LPTSTR      pszFuncName)
{
    //  Save the paramters

    _pDebugObject = pDebugObject;
    _plExitOutput = plExitOutput;
    _pszFuncName  = pszFuncName;
    _fLvl         = fLvl;

    //  Display the trace information

    _pDebugObject->TraceMsg(
                (_fLvl | DH_LVL_ENTRY),
                TEXT("%s _IN"),
                _pszFuncName);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEntryExitTrace::~CEntryExitTrace
//
//  Synopsis:   Destructor.  Display a trace output line
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-17-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CEntryExitTrace::~CEntryExitTrace(void)
{
    //  Display the trace information

    if (_plExitOutput != NULL)
    {
        _pDebugObject->TraceMsg(
                    (_fLvl | DH_LVL_EXIT),
                    TEXT("%s _OUT:%#08lx"),
                    _pszFuncName,
                    *_plExitOutput);
    }
    else
    {
        _pDebugObject->TraceMsg(
                    (_fLvl | DH_LVL_EXIT),
                    TEXT("%s _OUT"),
                    _pszFuncName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\arghelp.cxx ===
//+-------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       arghelp.cxx
//
//  Contents:   Helper functions for manipulating & parsing command
//              line arguments (both Windows and Command Line styles).
//
//  Classes:    None
//
//  History:    22-Nov-94   DeanE   Created
//---------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop

#ifdef _MAC
//
// On the mac, default to win95, since
// we're not going to do any tests that
// we don't do on win95
//
DWORD g_dwOperatingSystem = OS_WIN95 ;
#else //!_MAC
DWORD g_dwOperatingSystem = OS_NT ;
#endif //_MAC

#define CCH_MAX_MODULE_NAME     250

//+---------------------------------------------------------------------
//  Macro:      FindNextToken - looks for next non-space char and
//                              writes NILs over spaces it finds
//              FindNextSpace - looks for next space char
//              FindNextNil - looks for next NIl before tail, does a
//                            continue instead of a break at tail to
//                            allow loop to increment
//              FindNextNonNil - looks for next non-NIl before tail
//
//  Synopsis:   Helper macros for walking strings. Walks pointer to
//              desired point in string.
//
//  History:    28-Mar-94   DarrylA    Created.
//----------------------------------------------------------------------

#define FindNextToken(ptr) \
while('\0' != *(ptr)&&' '==(*(ptr))) { *(ptr) = '\0'; ++(ptr); } \
if('\0' == *(ptr)) break

#define FindNextSpace(ptr) \
while('\0' != *(ptr)&&' '!=(*(ptr))) ++(ptr); \
if('\0' == *(ptr)) break

#define FindNextNil(ptr, tail) \
while('\0' != *(ptr)&&(ptr)<(tail)) ++(ptr); \
if((tail) == (ptr)) continue

#define FindNextNonNil(ptr, tail) \
while('\0' == *(ptr)&&(ptr)<(tail)) ++(ptr); \
if((tail) == (ptr)) break


//+-------------------------------------------------------------------
//  Function:   CmdlineToArgs
//
//  Synopsis:   Turns the Windows-style Command Line passed into argc/
//              argv-style arguments.
//
//  Arguments:  [paszCmdline] - Windows-style ANSI command line.
//              [pargc]       - Pointer to resulting argc.
//              [pargv]       - Pointer to resulting argv.
//
//  Returns:    S_OK if no problems, error code otherwise.
//
//  History:    05-Apr-94   DarrylA     Created.
//              22-Nov-94   DeanE       Stolen from Marshal tests
//--------------------------------------------------------------------
HRESULT CmdlineToArgs(
        LPSTR     paszCmdline,
        PINT      pargc,
        CHAR   ***pargv)
{
//    DH_ASSERT(!IsBadWritePtr(pargc, sizeof(PINT)));
//    DH_ASSERT(!IsBadWritePtr(pargv, sizeof(CHAR ***)));

    int     cArgs      = 1;
    int     cchTemp    = 0;
    ULONG   cchCmdline = 0;
    CHAR  **ppArgs     = NULL;
    PCHAR   ptail      = NULL;
    LPSTR   aszCmdline = NULL;
    PCHAR   ptr        = NULL;

    // Copy command line string into an ANSI buffer
    cchCmdline = (ULONG) strlen(paszCmdline);
    aszCmdline = new(NullOnFail) CHAR[cchCmdline+1];
    if (aszCmdline == NULL)
    {
        return(E_OUTOFMEMORY);
    }
    strcpy(aszCmdline, paszCmdline);
    cchTemp = (int) cchCmdline;

    ptr = aszCmdline;

    // The command line is now in the ansi buffer.  Now we need to traverse
    // it and figure out the number of parameters.  While we walk over
    // spaces, we will replace them with '\0' so that afterwards, we just
    // dup each string into the new array.
    //
    while('\0' != *ptr)
    {
        FindNextToken(ptr);
        ++cArgs;
        FindNextSpace(ptr);
    }
    ptail = ptr;        // now points to NIL at end of string
    ptr   = aszCmdline;

    // Now we need to allocate space for the arguments
    ppArgs = new(NullOnFail) LPSTR[cArgs];
    if (NULL == ppArgs)
    {
        delete aszCmdline;
        return(E_OUTOFMEMORY);
    }

    BOOL fNewFail = FALSE;
    int  i = 0; // init to zero in case the strdup fails

    // Initialize ppArgs[0] with the module name
    ppArgs[0] = new(NullOnFail) CHAR[CCH_MAX_MODULE_NAME];
    if (NULL == ppArgs[0])
    {
        delete aszCmdline;
        delete ppArgs;
        return(E_OUTOFMEMORY);
    }
    
    char szTempModule[CCH_MAX_MODULE_NAME];
    short ret;

    cchTemp = (int) GetModuleFileNameA(NULL, szTempModule, CCH_MAX_MODULE_NAME);
    ret = GetFileTitleA(szTempModule, ppArgs[0], CCH_MAX_MODULE_NAME);
    if (ret != 0)
    {
        cchTemp = 0;
    }
    else
    {
        cchTemp = strlen(ppArgs[0]);
    }
    
    if ((cchTemp == 0) || (cchTemp == CCH_MAX_MODULE_NAME))
    {
        delete aszCmdline;
        delete ppArgs[0];
        delete ppArgs;
        return(E_FAIL);
    }

    // Now traverse the command line, plucking arguments and copying them
    // into the ppArgs array
    //
    for(i=1; i<cArgs; i++)
    {
        FindNextNonNil(ptr, ptail);
        ppArgs[i] = new(NullOnFail) CHAR[strlen(ptr)+1];
        if (NULL == ppArgs[i])
        {
            fNewFail = TRUE;
            break;
        }
        else
        {
            strcpy(ppArgs[i], ptr);
        }
        FindNextNil(ptr, ptail);
    }

    // Check for errors - clean up if we got one
    if (i != cArgs || TRUE == fNewFail)
    {
        for (int j=0; j<i; j++)
        {
            delete ppArgs[j];
        }

        delete aszCmdline;
        delete ppArgs;
        return(E_OUTOFMEMORY);
    }

    // Set up return parameters
    *pargc = cArgs;
    *pargv = ppArgs;

    // Clean up and exit
    delete aszCmdline;

    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetOSFromCmdline
//
//  Synopsis:   The operating system can be specified by putting /OS:<os> 
//              on the command line.  Check for it.
//
//  Parameters: [pCmdLine]              -- The command object for /OS
//
//  Returns:    OS_NT                   -- Running on NT
//              OS_WIN95                -- Running on Win95
//              OS_WIN95_DCOM           -- Running on Win95 + DCOM
//
//  History:    06-Jun-96   AlexE   Created
//
//----------------------------------------------------------------------------

DWORD GetOSFromCmdline(CBaseCmdlineObj *pCmdLine)
{
    //
    // If there is an OS specifier on the command line, set
    // the global variable g_dwOperatingSystem to the right
    // thing -- it is set to NT by default during compile time.
    //

    if (pCmdLine->IsFound())
    {
        if (0 == _olestricmp(pCmdLine->GetValue(), OS_STRING_WIN95))
        {
            g_dwOperatingSystem = OS_WIN95 ;
        }
        else if (0 == _olestricmp(pCmdLine->GetValue(), OS_STRING_WIN95DCOM))
        {
            g_dwOperatingSystem = OS_WIN95_DCOM ;
        }
    }

    return g_dwOperatingSystem ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\creghelp.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:       creghelp.cxx
//
//  Contents:   Implementaion of CRegistryHelp class object.
//
//  Classes:    CRegistryHelp
//
//  Functions:  CRegistryHelp::CRegistryHelp
//              CRegistryHelp::~CRegistryHelp
//              CRegistryHelp::GetValue
//              CRegistryHelp::GetValueDword
//              CRegistryHelp::GetValueString
//              CRegistryHelp::SetValue
//              CRegistryHelp::SetValueDword
//              CRegistryHelp::SetValueString
//              CRegistryHelp::DeleteValue
//              CRegistryHelp::DeleteSubKey
//
//  History:    03-Sep-93   XimingZ Created
//              23-Nov-94   DeanE   Modified for general use
//--------------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//  Method:     CRegistryHelp::CRegistryHelp
//
//  Synopsis:   Constructor.
//
//  Arguments:  [hKey]      - Handle to the root key.
//              [pszSubKey] - Name of subkey.
//              [fOptions]  - Special options.
//              [samKey]    - Access desired.
//              [phr]       - Pointer to status code to be returned.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
CRegistryHelp::CRegistryHelp(
    HKEY     hKey,
    LPTSTR   pszSubKey,
    DWORD    fOptions,
    REGSAM   samKey,
    HRESULT *phr) :
        _hKey(NULL),
        _hSubKey(NULL),
        _pszSubKey(NULL),
        _fOptions(fOptions)
{
    DWORD dwDisposition;
    LONG  lRes;

    // Confirm subkey is valid and save it
    if (IsBadReadPtr(pszSubKey, sizeof(LPTSTR)))
    {
        *phr = E_POINTER;
        return;
    }
    _pszSubKey = new(NullOnFail) TCHAR[lstrlen(pszSubKey)+1];
    if (_pszSubKey == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    lstrcpy(_pszSubKey, pszSubKey);

    // Save hKey
    if (hKey == NULL)
    {
        *phr = MAKE_TH_ERROR_CODE(E_HANDLE);
        return;
    }
    _hKey = hKey;

    // Open the subkey and save a handle to it
    lRes = RegCreateKeyEx(
            hKey,
            pszSubKey,
            0,
            NULL,
            fOptions,
            samKey,
            NULL,
            &_hSubKey,
            &dwDisposition);
    if (lRes != ERROR_SUCCESS)
    {
        *phr = MAKE_TH_ERROR_CODE(lRes);

        delete _pszSubKey;
        _hSubKey = NULL;
        _pszSubKey = NULL;
    }
    else
    {
        *phr = S_OK;
    }
}


//+-------------------------------------------------------------------------
//  Function:   CRegistryHelp::~CRegistryHelp
//
//  Synopsis:   Destructor.
//
//  Arguments:  None
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
CRegistryHelp::~CRegistryHelp()
{
    delete _pszSubKey;
    if (_hSubKey != NULL)
    {
        RegCloseKey(_hSubKey);
    }
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::GetValue
//
//  Synopsis:   Retrieves a value for some subkey and value name.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]  - Name of value to query.
//              [pbBuffer]  - Holds retrieved data.
//              [pcbBuffer] - Holds size of buffer on entry and actual size
//                            on exit (in bytes).
//              [pfType]    - Holds type of data retrieved.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::GetValue(
        LPTSTR  pszSubKey,
        LPTSTR  pszValue,
        LPBYTE  pbBuffer,
        LPDWORD pcbBuffer,
        LPDWORD pfType)
{
    HRESULT hr      = E_FAIL;
    HKEY    hSubKey = NULL;
    LONG    lRes;

    // Open the subkey, if necessary
    if (NULL == pszSubKey)
    {
        hSubKey = _hSubKey;
        hr = S_OK;
    }
    else
    {
        lRes = RegOpenKeyEx(_hSubKey, pszSubKey, NULL, KEY_READ, &hSubKey);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Query for the data
    if (SUCCEEDED(hr))
    {
        lRes = RegQueryValueEx(
                  hSubKey,
                  pszValue,
                  NULL,
                  pfType,
                  pbBuffer,
                  pcbBuffer);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Close the subkey handle, if we opened it
    if (hSubKey != _hSubKey)
    {
        RegCloseKey(hSubKey);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::GetValueDword
//
//  Synopsis:   Retrieves a value for some subkey and value name that has
//              REG_DWORD, REG_DWORD_LITTLE_ENDIAN, or REG_DWORD_BIG_ENDIAN
//              data.  Other data types return an error.
//
//  Arguments:  [pszSubKey]      - Subkey the value is on.  NULL means
//                                 _hSubKey.
//              [pszValue]       - Name of value to query.
//              [pdwData]        - Holds retrieved data.
//              [fExpectedType]  - Holds expected type.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::GetValueDword(
        LPTSTR  pszSubKey,
        LPTSTR  pszValue,
        LPDWORD pdwData,
        DWORD   fExpectedType)
{
    HRESULT hr     = E_FAIL;
    DWORD   cbData = sizeof(DWORD);
    DWORD   fType;

    // Check fExpectedType is for a DWORD data type
    if ((fExpectedType != REG_DWORD) &&
        (fExpectedType != REG_DWORD_LITTLE_ENDIAN) &&
        (fExpectedType != REG_DWORD_BIG_ENDIAN))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    // Get the value
    hr = GetValue(pszSubKey, pszValue, (PBYTE)pdwData, &cbData, &fType);
    if (SUCCEEDED(hr))
    {
        if ((fType == fExpectedType) && (cbData == sizeof(DWORD)))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::GetValueString
//
//  Synopsis:   Retrieves a value for some subkey and value name that has
//              REG_SZ, REG_EXPAND_SZ, and REG_MULTI_SZ type data.
//
//  Arguments:  [pszSubKey]      - Subkey the value is on.  NULL means
//                                 _hSubKey.
//              [pszValue]       - Name of value to query.
//              [pszData]        - Holds retrieved data.
//              [pcbData]        - Size of data buffer in bytes.
//              [fExpectedType]  - Holds expected type.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::GetValueString(
        LPTSTR  pszSubKey,
        LPTSTR  pszValue,
        LPTSTR  pszData,
        LPDWORD pcbData,
        DWORD   fExpectedType)
{
    HRESULT hr     = E_FAIL;
    DWORD   fType;

    // Check fExpectedType is for a DWORD data type
    if ((fExpectedType != REG_SZ) &&
        (fExpectedType != REG_EXPAND_SZ) &&
        (fExpectedType != REG_MULTI_SZ))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    hr = GetValue(pszSubKey, pszValue, (PBYTE)pszData, pcbData, &fType);
    if (SUCCEEDED(hr))
    {
        if (fType == fExpectedType)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::SetValue
//
//  Synopsis:   Stores a value for a given subkey and value name.  Subkey
//              is expected to exist.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means
//                            _hSubKey.
//              [pszValue]  - Name of value to set.
//              [pbData]    - Address of value data.
//              [cbData]    - Size of data.
//              [fType]     - Type of data.
//
//  Returns:    S_OK if value is set properly, error code if not.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::SetValue(
        LPTSTR   pszSubKey,
        LPTSTR   pszValue,
        LPBYTE   pbData,
        DWORD    cbData,
        DWORD    fType)
{
    HRESULT hr = E_FAIL;
    LONG    lRes;
    HKEY    hSubKey;

    // Open the subkey, if necessary
    if (pszSubKey == NULL)
    {
        hSubKey = _hSubKey;
        hr = S_OK;
    }
    else
    {
        lRes = RegOpenKeyEx(_hSubKey, pszSubKey, NULL, KEY_WRITE, &hSubKey);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Set the data
    if (SUCCEEDED(hr))
    {
        lRes = RegSetValueEx(hSubKey, pszValue, 0, fType, pbData, cbData);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Close the subkey handle, if we opened it
    if (hSubKey != _hSubKey)
    {
        RegCloseKey(hSubKey);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::SetValueDword
//
//  Synopsis:   Stores a DWORD value for some subkey and value name under
//              this subkey.  Type flag passed must be REG_DWORD,
//              REG_DWORD_LITTLE_ENDIAN, or REG_DWORD_BIG_ENDIAN.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]  - Name of value to set.
//              [dwData]    - Data to set.
//              [fType]     - Type of data.
//
//  Returns:    S_OK if value is set properly, error code if not.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::SetValueDword(
        LPTSTR pszSubKey,
        LPTSTR pszValue,
        DWORD  dwData,
        DWORD  fType)
{
    HRESULT hr = E_FAIL;

    // Check fType is for a DWORD data type
    if ((fType != REG_DWORD) &&
        (fType != REG_DWORD_LITTLE_ENDIAN) &&
        (fType != REG_DWORD_BIG_ENDIAN))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    // Set the value
    hr = SetValue(
            pszSubKey,
            pszValue,
            (LPBYTE)&dwData,
            sizeof(DWORD),
            fType);

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::SetValueString
//
//  Synopsis:   Stores a string value for some subkey and value name under
//              this subkey.  Type flag passed must be REG_SZ,
//              REG_EXPAND_SZ, or REG_MULTI_SZ.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]  - Name of value to set.
//              [pszData]   - Data to set.
//              [cbData]    - Size of data, in bytes.
//              [fType]     - Type of data.
//
//  Returns:    S_OK if value is set properly, error code if not.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::SetValueString(
        LPTSTR pszSubKey,
        LPTSTR pszValue,
        LPTSTR pszData,
        DWORD  cbData,
        DWORD  fType)
{
    HRESULT hr = E_FAIL;

    // Check fType is for a DWORD data type
    if ((fType != REG_SZ) &&
        (fType != REG_EXPAND_SZ) &&
        (fType != REG_MULTI_SZ))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    // Set the value
    hr = SetValue(
            pszSubKey,
            pszValue,
            (LPBYTE)pszData,
            cbData,
            fType);

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::DeleteValue
//
//  Synopsis:   Delete a named value under a given subkey.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]   - Value to delete.
//
//  Returns:    S_OK if value deleted or is not there, error code if not
//              deleted.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::DeleteValue(LPTSTR pszSubKey, LPTSTR pszValue)
{
    HRESULT hr = E_FAIL;
    HKEY    hSubKey;
    LONG    lRes;

    // Open the subkey, if necessary
    if (pszSubKey == NULL)
    {
        hSubKey = _hSubKey;
    }
    else
    {
        lRes = RegOpenKeyEx(_hSubKey, pszSubKey, NULL, KEY_WRITE, &hSubKey);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Delete the value
    if (SUCCEEDED(hr))
    {
        lRes = RegDeleteValue(hSubKey, pszValue);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Close the subkey handle, if we opened it
    if (hSubKey != _hSubKey)
    {
        RegCloseKey(hSubKey);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::DeleteSubKey
//
//  Synopsis:   Delete the subkey passed under this subkey.
//
//  Arguments:  [pszSubKey] - Subkey to delete.  Must have no child
//                            subkeys.
//
//  Returns:    S_OK if value deleted or is not there, error code if not
//              deleted.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::DeleteSubKey(LPTSTR pszSubKey)
{
    LONG    lRes;
    HRESULT hr;

    if (IsBadReadPtr(pszSubKey, sizeof(LPTSTR)))
    {
        hr = MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        lRes = RegDeleteKey(_hSubKey, pszSubKey);
        hr   = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\apitests.cxx ===
/-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       apitests.cxx
//
//  Contents:  storage base tests basically pertaining to API tests in general. 
//
//  Functions:  
//
//  History:    18-June-1996    NarindK     Created.
//              27-Mar-97       SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <sys/stat.h>
#include <share.h>

#include  "init.hxx"

// undo the affects of the wrapper. We need to test the actual APIs here,
// not what we think we should be calling to test docfile/nssfiles.
#undef StgCreateDocfile
#undef StgOpenStorage

// CheckErrorTest macros. 
// These check the return value to an invalid api call. 
// These must remain as #defines as we change local variables.
#define CheckErrorTest(err, msg, pstg)     \
    DH_ASSERT (NULL == pstg);              \
    hr = DH_HRERRORCHECK (hr, err, msg);   \
    if ((S_OK != hr) || (NULL != pstg))    \
    {                                      \
        fPass = FALSE;                     \
        hr = S_OK;                         \
    }                                      \
    // release it if we accidentally got one \
    if (NULL != pstg)                      \
    {                                      \
        pstg->Release ();                  \
        pstg = NULL;                       \
    }

#define CheckErrorTest2(err, msg)          \
    hr = DH_HRERRORCHECK (hr, err, msg);   \
    if (S_OK != hr)                        \
    {                                      \
        fPass = FALSE;                     \
        hr = S_OK;                         \
    }


//----------------------------------------------------------------------------
//
// Test:    APITEST_100 
//
// Synopsis: This test attempts various operations on StgCreateDocFile, Stg
//           OpenStorage API's 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    18-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: IAPISTG.CXX
// 2.  Old name of test : IllegitAPIStg test 
//     New Name of test : APITEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-100
//        /dfRootMode:dirReadWriteShEx /dfname:APITEST.100 /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-100
//        /dfRootMode:xactReadWriteShEx /dfname:APITEST.100 /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfname:APITEST.100 /labmode
//
// BUGNOTE: Conversion: APITEST-100 NO
// 
//-----------------------------------------------------------------------------


HRESULT APITEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageOpen           = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    TCHAR           tszTestName[10]         = TEXT("NonExist");
    LPOLESTR        pOleStrTest             = NULL;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    ULONG           ulRef                   = 0;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt illegitimate ops on StgCreateDocFIle & StgOpenStorage.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name

    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName =
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
            DH_HRCHECK(hr, TEXT("new TCHAR"));
        }
        DH_HRCHECK(hr, TEXT("ChanceDF::GetDocFileName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with mode STGM_CREATE|STGM_CONVERT

    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgCreateDocfile(
                pOleStrTemp,
                STGM_CREATE | STGM_CONVERT,
                0,
                &pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("StgCreateDocfile inv Flags"),
                pIStorage);
    }

    // Try calling StgCreateDocFile with mode equal to -1 
    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgCreateDocfile(
                pOleStrTemp,
                (DWORD) -1, 
                0,
                &pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("StgCreateDocfile inv mode"),
                pIStorage);
    }

    // Try calling StgCreateDocFile with nonzero reserved parameter 
    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgCreateDocfile(
                pOleStrTemp,
                STGM_CREATE | dwRootMode,
                (DWORD)999, 
                &pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("StgCreateDocfile inv reserved"),
                pIStorage);
    }

    // Try calling StgCreateDocFile with NULL ppstgOpen parameter 4th 

    if (S_OK == hr)
    {
        hr = StgCreateDocfile(
                pOleStrTemp,
                dwRootMode, 
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("StgCreateDocfile inv ppstg bucket"));
    }

    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new VirtualDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::GenerateVirtualDF")) ;
    }

    // Now try commiting with grfCommitFlags = -1
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG, 
                TEXT ("VirtualCtrNode::Commit inv flag"));
    }

    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // Instantiate DocFile with grfMode=-1 
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                (DWORD) -1,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("StgOpenStorage inv mode"),
                pIStorageOpen);
    }

    // Instantiate DocFile with name as " " 
    // NOTE: The old test checked the erro value to be STG_E_FILENOTFOUND in 
    // this case.  On NT, we get STG_E_PATHNOTFOUND and on Chicago, we get
    // STG_E_ACCESSDENIED, so let us check against S_OK itself.

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                (OLECHAR *) " ",
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);

        if (RunningOnNT())
        {
            CheckErrorTest(STG_E_PATHNOTFOUND, 
                    TEXT("StgOpenStorage inv name"), 
                    pIStorageOpen);
        }
        else
        {
            CheckErrorTest(STG_E_ACCESSDENIED, 
                    TEXT("StgOpenStorage inv name"),
                    pIStorageOpen);
        }
    }

    // Instantiate DocFile with nonexisting file name
    if(S_OK == hr)
    {
        // Convert tszTestName  to OLECHAR
        hr = TStringToOleString(tszTestName, &pOleStrTest);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTest,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_FILENOTFOUND, 
                TEXT ("StgOpenStorage inv name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with NULL file name
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                NULL,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("StgOpenStorage NULL name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with non zero dwReserved parameter
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                999,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("StgOpenStorage inv reserved"),
                pIStorageOpen);
    }

    // Instantiate DocFile with NULL ppstgOpen parameter (6th)
    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("StgOpenStorage NULL ppstg"));
    }

    // Instantiate DocFile with grfMode as dwRootMode|STGM_DELETEONRELEASE 
    // NOTE: The doc says, erro code in this case to be STG_E_INVALIDFUNCTION,
    // but error STG_E_INVALIDFLAG returned.

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode | STGM_DELETEONRELEASE,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFUNCTION, 
                TEXT ("StgOpenStorage DELETEONRELEASE in mode"),
                pIStorageOpen);
    }

    // Create snbTest with spcae for two names and set name list to NULL i.e.
    // a vaild SNB with no name in the block
    if(S_OK == hr)
    {
        snbTest = (OLECHAR **) new OLECHAR [sizeof(OLECHAR *) * 2];
        if(NULL == snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbTest = NULL;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    // Instantiate DocFile with above empty but valid SNB 
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                snbTest,
                0,
                &pIStorageOpen);
       DH_HRCHECK(hr, TEXT("StgOpenStorage empty SNB")) ;

        // Release the pointer
        if(NULL != pIStorageOpen)
        {
            ulRef = pIStorageOpen->Release();
            DH_ASSERT (0 == ulRef);
            pIStorageOpen = NULL;
        }
    }

    // Allocate space for long name  and fill name with
    // X's, make next SNB elment NULL, and make a call to StgOpenStorage API
    // with too long a name in SNB

    if(S_OK == hr)
    {
        *snbTest = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*12];
        if (NULL == *snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr)
    {
        snbTemp = snbTest;
        ocsSNBChar = *snbTemp;

        for (i=0; i<( MAX_STG_NAME_LEN*12 -1); i++)
        {
            ocsSNBChar[i] = 'X';
        }
        ocsSNBChar[i] = '\0';
 
        // Assign second element as NULL
        snbTemp++; 
        *snbTemp = NULL;
    }
 
    // Instantiate DocFile with above SNB with too long a name in it. 
    // NOTE: In the old test, this was supposed to fail.  Doesn't fail
    // now... Confirmed with Philipla - No length verification of SNB 
    // names done in ValidateSNB in OLE 

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                snbTest,
                0,
                &pIStorageOpen);
        DH_HRCHECK (hr, TEXT("StgOpenStorage long SNB"));

        //Release storage pointer
        if(NULL != pIStorageOpen)
        {
            ulRef = pIStorageOpen->Release();
            DH_ASSERT (0 == ulRef);
            pIStorageOpen = NULL;
        }
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation APITEST_100 failed; hr=%#lx; fPass=%d"),
            hr,
            fPass));
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings
    if(NULL != pOleStrTemp)
    {
        delete []pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if(NULL != pOleStrTest)
    {
        delete []pOleStrTest;
        pOleStrTest = NULL;
    }

    if(NULL != pRootDocFileName)
    {
        delete []pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Free SNB 
    if(NULL != snbTest)
    {
        if(NULL != *snbTest)
        {
            delete [] *snbTest;
            *snbTest = NULL;
        }
        delete [] snbTest;
        snbTest = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_101 
//
// Synopsis: The test attempts various illegitimate operations using names
//       greater than MAX_STG_NAME_LEN, it then attempts to create
//       several random named root docfiles.  If the create is succesful,
//       then a random named child IStorage or IStream is also created.
//       Whether or not the root create was successful, we attempt to
//       open the root docfile (this is expected to fail, the point is
//       to check for asserts/GP faults rather than return codes).  If
//       the instantiation is successful, the test also tries to
//       instantiate the child object.  All objects are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IANAMES.CXX
// 2.  Old name of test : IllegitAPINames test 
//     New Name of test : APITEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: APITEST-101 NO
//
//-----------------------------------------------------------------------------

HRESULT APITEST_101(int argc, char *argv[])
{
#ifdef _MAC  // Simple mode not ported yet; check with the developers    
             // and remove this when ready

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!APITEST-101 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        poszBadName             = NULL;
    LPOLESTR        poszBadNameStg          = NULL;
    LPTSTR          ptszBadNameStg          = NULL;
    DWORD           dwRootMode              = 0;
    ULONG           i                       = 0;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageChild          = NULL;
    LPSTREAM        pIStreamChild           = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    BOOL            fPass                   = TRUE;
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
            TEXT("Call StgCreateDocFile/CreateStorage/CreateStream with too long names")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Call StgCreateDocFile with too long a name for docfile.
    // NOTE: Old test to fail with MAX_STG_NAME_LEN*3, but not in new test,
    // fails with MAX_STG_NAME_LEN*4.
    // NOTE: Crashes in DfFromName in OLE if length is of MAX_STG_NAME_LEN*8
    // CHECK!!!

    if(S_OK == hr)
    {
        poszBadName = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == poszBadName)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new OLECHAR")) ;
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {
            poszBadName[i] = i%20 + OLECHAR('A');
        }
        poszBadName[i] = OLECHAR('\0');
    }

    // Try calling StgCreateDocFile with the above long name pszBadName 
    if (S_OK == hr)
    {
        pIStorage = NULL;
        DH_TRACE ((DH_LVL_TRACE4, TEXT("Filename:%s"), poszBadName)); //BUGBUG - work on chicago?
        hr = StgCreateDocfile(
                poszBadName,
                dwRootMode | STGM_CREATE, 
                0,
                &pIStorage);
        CheckErrorTest(STG_E_PATHNOTFOUND, 
                TEXT ("StgCreateDocfile long name"),
                pIStorage);
    }

    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new VirtualDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualDF::GenerateVirtualDF")) ;
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pIStorage = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pIStorage);
        if (NULL == pIStorage)
        {
            hr = E_FAIL;
        }
    }

    // Call CreateStorage with too long a name for docfile.
    if(S_OK == hr)
    {
        ptszBadNameStg = (TCHAR *) new TCHAR [MAX_STG_NAME_LEN*3];
        if (NULL == ptszBadNameStg)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new TCHAR")) ;
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*3 -1); i++)
        {
            ptszBadNameStg[i] = TEXT('Y');
        }
        ptszBadNameStg[i] = TEXT('\0');
    }

    if(S_OK == hr)
    {
        // Convert Bad storage name to OLECHAR
        hr = TStringToOleString(ptszBadNameStg, &poszBadNameStg);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // now call CreateStorage with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStorage(
                poszBadNameStg,
                pTestChanceDF->GetStgMode(),
                0,
                0,
                &pIStorageChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStorage long name"),
                pIStorageChild);
    }

    // Now call CreateStream with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStream(
                poszBadNameStg,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pIStreamChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStream long name"),
                pIStreamChild);
    }

    // Now add a Valid storage to root.  Call AddStorage that in turns calls
    // CreateStorage
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    // Now try to rename this storage element to a bad name.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDNAME);
        hr = pvcnRootNewChildStorage->Rename(ptszBadNameStg);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDNAME, 
                TEXT ("VirtualCtrNode::Rename long name"));
    }

    // Close the Storage pvcnRootNewChildStorage 
    if (NULL != pvcnRootNewChildStorage)
    {
        hr2 = pvcnRootNewChildStorage->Close();
        DH_HRCHECK(hr2, TEXT("VirtualCtrNode::Close")) ;
        hr = FirstError (hr, hr2);
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK(hr2, TEXT("VirtualCtrNode::Close")) ;
        hr = FirstError (hr, hr2);
    }

    // Delete temp strings
    if(NULL != poszBadNameStg)
    {
        delete [] poszBadNameStg;
        poszBadNameStg = NULL;
    }

    if(NULL != poszBadName)
    {
        delete [] poszBadName;
        poszBadName = NULL;
    }

    if(NULL != ptszBadNameStg)
    {
        delete [] ptszBadNameStg;
        ptszBadNameStg = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // In the following section of test:
    //make a random number of random length, random character root
    //docfiles.  for this variation, we don't care if the operation
    //succeeds, looking for GP faults and asserts only.  if the
    //StgCreateDocfile fails, we'll still attempt the open.  of
    //course, the open in this case will be expected to fail, but
    //again, we won't be checking return codes... If the StgCreateDocfile
    //passes, we'll create a random name IStream or IStorage too.

    ULONG       count               =   0;    
    ULONG       cMinNum             =   16;    
    ULONG       cMaxNum             =   128;
    LPTSTR      ptszRandomRootName  =   NULL;  
    LPTSTR      ptszRandomChildName =   NULL;  
    ULONG       countFlag           =   0;    
    ULONG       cMinFlag            =   0;    
    ULONG       cMaxFlag            =   100;
    ULONG       nChildType          =   0;
    LPSTORAGE   pstgRoot            =   NULL; 
    LPSTORAGE   pstgChild           =   NULL; 
    LPSTREAM    pstmChild           =   NULL; 
    LPOLESTR    poszRandomRootName  =   NULL;
    LPOLESTR    poszRandomChildName =   NULL;
    ULONG       ulRef               =   0;

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&count, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    while(count--)
    {
        if(S_OK == hr)
        {
            hr=GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszRandomRootName);
            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            // Convert name to OLECHAR
            hr = TStringToOleString(ptszRandomRootName, &poszRandomRootName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if (S_OK == hr)
        {
            pstgRoot = NULL;

            hr = StgCreateDocfile(
                    poszRandomRootName,
                    dwRootMode | STGM_CREATE,
                    0,
                    &pstgRoot);
            DH_HRCHECK(hr, TEXT("StgCreateDocfile")) ;
        }

        nChildType = NONE;

        if(S_OK == hr)
        {
            if(S_OK == hr)
            {
                hr=GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH, 
                    &ptszRandomChildName);
                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert name to OLECHAR
                hr = TStringToOleString(
                        ptszRandomChildName, 
                        &poszRandomChildName);
                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pdgi->Generate(&countFlag, cMinFlag, cMaxFlag);
                DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
            }

            if(countFlag > (cMaxFlag/2))
            {
                hr = pstgRoot->CreateStorage(
                        poszRandomChildName,
                        pTestChanceDF->GetStgMode(),
                        0,
                        0,
                        &pstgChild);
                DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;

                if(S_OK == hr)
                {
                    nChildType = STORAGE;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
                    ulRef = pstgChild->Release();
                    DH_ASSERT (0 == ulRef);
                    pstgChild = NULL;
                }
            }
            else
            {
                hr = pstgRoot->CreateStream(
                        poszRandomChildName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        0,
                        0,
                        &pstmChild);   
                DH_HRCHECK(hr, TEXT("IStorage::CreateStream")) ;
 
                if(S_OK == hr)
                {
                    nChildType = STREAM;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
                    ulRef = pstmChild->Release();   
                    DH_ASSERT (0 == ulRef);
                    pstmChild = NULL;
                }
            }

            ulRef = pstgRoot->Release();   
            DH_ASSERT (0 == ulRef);     
            pstgRoot = NULL;
        }
        
        //Try to open Root Storage whetehr the creation was successful or not
        
        hr = StgOpenStorage(
                poszRandomRootName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pstgRoot);
        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;

        if(S_OK == hr)
        {
            switch(nChildType)
            {
                case STORAGE:
                    {
                        hr = pstgRoot->OpenStorage(
                                poszRandomChildName,
                                NULL, 
                                pTestChanceDF->GetStgMode(),
                                NULL,
                                0,
                                &pstgChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
 
                        if(S_OK == hr)
                        {
                            ulRef = pstgChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstgChild = NULL;
                        }
                    
                        break; 
                    }
                case STREAM:
                    {
                        hr = pstgRoot->OpenStream(
                                poszRandomChildName,
                                NULL, 
                                STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
 
                        if(S_OK == hr)
                        {
                            ulRef = pstmChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstmChild = NULL;
                        }
                    
                        break; 
                    }
            }
            ulRef = pstgRoot->Release();
            DH_ASSERT (0 == ulRef);
            pstgRoot = NULL;
        }    

        // Delete temp strings
        if(NULL != ptszRandomChildName)
        {
            delete [] ptszRandomChildName;
            ptszRandomChildName = NULL;
        }

        if(NULL != ptszRandomRootName)
        {
            if(FALSE == DeleteFile(ptszRandomRootName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }

            delete [] ptszRandomRootName;
            ptszRandomRootName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_101 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file
    if(NULL != pTestVirtualDF)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];
        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pFileName)
    {
        delete []pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:    APITEST_102 
//
// Synopsis: Attempts various operations in obtaining enumerators, checking
//       for proper error return.  Then gets a valid enumerator, and
//       attempts various illegitimate method calls on it.  Verify
//       proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IAENUM.CXX
// 2.  Old name of test : IllegitAPIEnum test 
//     New Name of test : APITEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /labmode
//
// BUGNOTE: Conversion: APITEST_102
//-----------------------------------------------------------------------------

HRESULT APITEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    ULONG           cMinNum                 = 1;
    ULONG           cMaxNum                 = 999;
    DWORD           dwReserved1             = 0;
    DWORD           dwReserved3             = 0;
    LPTSTR          pReserved2              = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;
    ULONG           celtFetched             = 0;
    LPMALLOC        pMalloc                 = NULL;
 
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Attempt different illegitimate opeations on IEnumSTATSTG. ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }


    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    //    Adds a new storage to the root storage.

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    // Close the Child storage
    if (NULL != pvcnRootNewChildStorage)
    {
        hr2 = pvcnRootNewChildStorage->Close();
        DH_HRCHECK(hr2, TEXT("VirtualCtrNode::Close")) ;
        hr = FirstError (hr, hr2);
    }

    // Get the random number generator
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved1, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    //Call EnumElements with invalid parameters
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved1"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved3, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved3"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pReserved2);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv pvReserved1"),
                penumWalk);
   }

    // Now call EnumElements with NULL ppenm 4th parameter.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPOINTER);
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, NULL);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("VirtualCtrNode::EnumElements NULL ppEnum"));
    }

    // Make a valid call to EnumElements now
    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, &penumWalk);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        DH_ASSERT (NULL != penumWalk);
    }

    // Now try the following skip calls - Attempt to skip 0 elements and 
    // attempt to skip MAX_ULONG elements.

    // Attempt to Skip 0 elements.
    if(S_OK == hr)
    {
        hr = penumWalk->Skip(0L);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Skip")) ;
    }

    // Attempt to Skip ULONG_MAX elements.

    // NOTE: In the old test, this was supposed to return S_OK, but it returns
    // S_FALSE
    if(S_OK == hr)
    {
        hr = penumWalk->Skip(ULONG_MAX);
        CheckErrorTest2(S_FALSE, 
                TEXT ("IEnumSTATSTG::Skip ULONG_MAX"));
    }

    // Call Clone with NULL ppenum parameter (ist)
    if(S_OK == hr)
    {
        hr = penumWalk->Clone(NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Clone NULL ppEnum"));
    }

    if(S_OK == hr)
    {
        statStg.pwcsName = NULL;

        // first get pmalloc that would be used to free up the name string from
        // STATSTG.

        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Reset the enumerator back to start and then test Next methods

    if(S_OK == hr)
    {
        hr = penumWalk->Reset();
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG:Reset")) ;
    }

    // Call Next with celt equal to zero, but pceltFetched as not NULL
    if(S_OK == hr)
    {
        hr = penumWalk->Next(0, &statStg, &celtFetched);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Next celt 0")) ;
    }

    // Call Next with celt equal to 999 and celtFetched as NULL 
    if(S_OK == hr)
    {
        hr = penumWalk->Next(999, &statStg ,NULL);
        CheckErrorTest2(STG_E_INVALIDPARAMETER, 
                TEXT ("IEnumSTATSTG::Next celt 999 and pceltFetched NULL"));
    }

    // Call Next with rgelt as NULL (2nd parameter). celtFetched may be NULL 
    // when celt asked is 1
 
    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, NULL, NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Next rgelt NULL"));
    }

    // Call Next with celt as 1 and pceltFetched as NULL.  Allowed as per spec 
    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, &statStg, NULL);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Next celt 1 and pceltFetched NULL"));
    }

    // Clean up

    if(NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Free LPENUMSTATSTG pointer
    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT (0 == ulRef);
        penumWalk = NULL;
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_102 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // free strings
    if(NULL != pReserved2)
    {
      delete [] pReserved2;
      pReserved2 = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }
 
   // Stop logging the test
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_103 
//
// Synopsis: Attempts various illegit operations on the IStorage interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTORAG.CXX
// 2.  Old name of test : IllegitAPIStorage test 
//     New Name of test : APITEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: APITEST_103
//-----------------------------------------------------------------------------

HRESULT APITEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStgName        = NULL;
    LPOLESTR        poszChildStgName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTORAGE       pStgChild2              = NULL;
    LPSTREAM        pStmChild               = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           ulRef                   = 0;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
      TEXT("Attempt various illegitimate operations on IStorage interface")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_103, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStgName, &poszChildStgName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call CreateStorage with grfmode=-1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                (DWORD) -1,
                0,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("IStorage::CreateStorage inv mode"),
                pStgChild);
    }

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                cRandom,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStorage inv dwReserved1"),
                pStgChild);
    }

    // Call CreateStorage with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                cRandom,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStorage inv dwReserved2"),
                pStgChild);
    }

    // Call CreateStorage with NULL 5th ppstg parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::CreateStorage NULL ppstg"));
    }

    // Create a stream with poszChildName and later on try to instantiate the
    // child storage with that same name poszChildName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStgName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close stream...
    if (NULL != pStmChild)
    {
         ulRef = pStmChild->Release();
         DH_ASSERT (0 == ulRef);
         pStmChild = NULL;
    }

    // Now try opening storage with name with which above stream was created
    // i.e.  poszChildName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    //Destroy the stream element of this root storage having name poszChildStg
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStgName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Create a valid storage with name poszChildStgName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;
    }

    // Commit with grfCommitFlags = -1
    if (S_OK == hr)
    {
        hr = pStgChild->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG,
                TEXT ("IStorage::Commit inv flag"));
    }

    // Commit the child.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pStgChild->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("IStorage::Commit"));
    }

    // Commit the root storage.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Attempt second instantiation of pStgChild which is already open.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild2);
        CheckErrorTest(STG_E_ACCESSDENIED,
                TEXT ("IStorage::OpenStorage 2nd time"),
                pStgChild2);
    }

    // Release the child
    if (NULL != pStgChild)
    {
        ulRef = pStgChild->Release();
        DH_ASSERT (0 == ulRef);
        pStgChild = NULL;
    }

    // Now try to open child IStorage, but with grfMode = -1
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                (DWORD) -1,
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStorage inv mode"),
                pStgChild);
    }

    // Attempt OpenStorage with name as "" of IStorage to be opened.
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                (OLECHAR *) " ",
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    // Attempt OpenStorage with name as NULL of IStorage to be opened.
#ifdef _MAC
    DH_TRACE((DH_LVL_TRACE1, TEXT("OpenStorage with NULL name skipped.")) );
#else
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                NULL,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStorage NULL name"),
                pStgChild);
    }

#endif //_MAC
    // Attempt OpenStorage with name as NULL ppstg, 6th parameter.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStorage NULL ppstg"));
    }

    // Attempt OpenStorage with random data in dwReserved parameter
    if (S_OK == hr && NULL != pdgi)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                cRandom,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage inv dwReserved"),
                pStgChild);
    }

    // Attempt OpenStorage with uninitialized SNB, should fail, but no GP
    // fault should occur.
    if(S_OK == hr)
    {
        snbTest = (OLECHAR **) new OLECHAR [sizeof(OLECHAR *) * 2];
        if(NULL == snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {   // bad pointer so SNB is not initialized
            *snbTest = (OLECHAR*)0xBAADF00D;  
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage uninitd SNB"),
                pStgChild);
    }

    // Attempt OpenStorage with SNB with no name in block, although it has 
    // space for two names, set name list to NULL
    if(S_OK == hr && NULL != snbTest)
    {
        *snbTest = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage empty SNB"),
                pStgChild);
    }

    // Allocate space for long name and fill name with X's, make next SNB 
    // element NULL, and make a call to IStorage::OpenStorage with too long a 
    // name in SNB
    if(S_OK == hr && NULL != snbTest)
    {
        *snbTest = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == *snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr && NULL != snbTest)
    {
        snbTemp = snbTest;
        ocsSNBChar = *snbTemp;

        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {

            ocsSNBChar[i] = 'X';
        }

        ocsSNBChar[i] = '\0';

        // Assign second element as NULL
        snbTemp++;
        *snbTemp = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage too long SNB"),
                pStgChild);
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_103 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if(NULL != ptszChildStgName)
    {
        delete ptszChildStgName;
        ptszChildStgName = NULL;
    }

    if(NULL != poszChildStgName)
    {
        delete poszChildStgName;
        poszChildStgName = NULL;
    }

    // Free SNB

    if(NULL != snbTest)
    {
        if(NULL != *snbTest)
        {
            delete [] *snbTest;
            *snbTest = NULL;
        }
        delete [] snbTest;
        snbTest = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
//----------------------------------------------------------------------------
//
// Test:    APITEST_104 
//
// Synopsis: Attempts various illegit operations on the IStream interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTREAM.CXX
// 2.  Old name of test : IllegitAPIStream test 
//     New Name of test : APITEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-104
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-104
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-104
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: APITEST_104
//-----------------------------------------------------------------------------

HRESULT APITEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStmName        = NULL;
    LPOLESTR        poszChildStmName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    LPSTREAM        pStmChild2              = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Attempt illegitimate operations on IStream interface. ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_104, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_STRING pointer 
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Generate random name for stream
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &ptszChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStmName, &poszChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Attempt CreateStream with grfmode=-1

    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                (DWORD) -1,
                0,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::CreateStream inv grfMode"),
                pStmChild);
    }

    // Get DG_INTEGER pointer
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved1"),
                pStmChild);
    }

    // Call CreateStream with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved2"),
                pStmChild);
    }

    // Call CreateStorage with NULL 5th ppstm parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::CreateStream NULL ppstm"));
    }

    // Create a storage with poszChildStmName and later on try to instantiate 
    // child stream with that same name poszChildStmName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK (hr, TEXT ("IStorage::CreateStream"));
        DH_ASSERT (NULL != pStgChild);
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT ("VirtualCtrNode::Commit"));
    }

    // Close storage...
    if (NULL != pStgChild)
    {
         ulRef = pStgChild->Release();
         DH_ASSERT (0 == ulRef);
         pStgChild = NULL;
    }

    // Now try opening storage with name with which above stream was created
    // i.e.  poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::CreateStream inv name"),
                pStmChild);
    }

    //Destroy the storage element of this root storage having name poszChildStm
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStmName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Create a valid stream with name poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Attempt second instance of IStream to be instantiated.
    if (S_OK == hr)
    {
        pStmChild2 = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild2);
        CheckErrorTest(STG_E_ACCESSDENIED,
                TEXT ("IStorage::OpenStream 2nd time"),
                pStmChild2);
    }

    // Release the stream
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT (0 == ulRef);
        pStmChild = NULL;
    }

    // Now attempt opening the stream with grfMode = -1
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                (DWORD) -1,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStream inv grfMode"),
                pStmChild);
    }

    // Now attempt opening the stream with name as ""

    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                (OLECHAR *) " ",
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStream inv name"),
                pStmChild);
    }

    // Now attempt opening the stream with name as NULL 
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("OpenStream with NULL name skipped.")) );

#else
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                NULL,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStream NULL name"),
                pStmChild);
    }
#endif // _MAC

    // Now attempt opening the stream with random data in pReserved1 . For test
    // we just put pStgRoot for pReserved1 variable.
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                pStgRoot,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv pReserved1"),
                pStmChild);
    }

    // Now attempt opening the stream with random data in dwReserved2 
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv dwReserved2"),
                pStmChild);
    }

    // Now attempt opening the stream with NULL ppstm (5th parameter) 
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStream NULL ppstm"));
    }

    // Now attempt opening the stream normally 
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::OpenStream"));

        // Release the stream
        if(S_OK == hr)
        {
            ulRef = pStmChild->Release();
            DH_ASSERT (0 == ulRef);
        }
    }

    // Release the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_104 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp string

    if(NULL != ptszChildStmName)
    {
        delete []ptszChildStmName;
        ptszChildStmName = NULL;
    }

    if(NULL != poszChildStmName)
    {
        delete []poszChildStmName;
        poszChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


// for non _OLE_NSS_, funcs are stubbed out below
#ifdef _OLE_NSS_

//----------------------------------------------------------------------------
//
// Test:    APITEST_200 
//
// Synopsis: This test attempts various operations on StgCreateStorageEx, 
//           StgOpenStorageEx API's 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    18-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: IAPISTG.CXX
// 2.  Old name of test : IllegitAPIStg test 
//     New Name of test : APITEST_200 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-200
//        /dfRootMode:dirReadWriteShEx /dfname:APITEST.200 /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-200
//        /dfRootMode:xactReadWriteShEx /dfname:APITEST.200 /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-200
//        /dfRootMode:xactReadWriteShDenyW /dfname:APITEST.200 /labmode
//
// BUGNOTE: Conversion: APITEST-200 NO
// 
//-----------------------------------------------------------------------------


HRESULT APITEST_200(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageOpen           = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    TCHAR           tszTestName[10]         = TEXT("NonExist");
    LPOLESTR        pOleStrTest             = NULL;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    ULONG           ulRef                   = 0;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;
    CLSID           clsidBogus              = {0xBAADF00D,
                                               0xBAAD,
                                               0xF00D,
                                               {0xA0, 0xA0, 0xA0, 0xA0, 
                                                0xA0, 0xA0, 0xA0, 0xA0}};
    DWORD           stgfmt                  = StorageIsFlat()?STGFMT_FILE:0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_200"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_200 started.")) );
    DH_TRACE((DH_LVL_ALWAYS,
            TEXT("Attempt illegitimate ops on StgCreateStorageEx & ")
            TEXT("StgOpenStorageEx.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new ChanceDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Run Mode for APITEST_200, Access mode: %lx"),
                pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name
    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName =
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
            DH_HRCHECK (hr, TEXT("new TCHAR"));
        }
        DH_HRCHECK(hr, TEXT("ChanceDF::GetDocFileName()")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateStorageEx with mode STGM_CREATE|STGM_CONVERT
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT("Try calling StgCreateStorageEx with mode STGM_CREATE|STGM_CONVERT")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                STGM_CREATE | STGM_CONVERT,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgCreateStorageEx inv grfMode"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with grfMode equal to -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with grfMode equal to -1")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                (DWORD) -1, 
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgCreateStorageEx inv grfMode"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with stgfmt equal to -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with stgfmt equal to -1")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                (DWORD)-1, 
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv stgfmt"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with gfrAttr equal to -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with gfrAttr equal to -1")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                (DWORD)-1, 
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgCreateStorageEx inv grfAttr"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with nonzero reserved1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with nonzero reserved1")));

    // With 1795 changes to "dwReserved" Parameter to -> version number,
    // sector size (allowed is 512, 4096 only) and reserved parameter as
    // typedef struct tagSTGOPTIONS
    // {
    //  USHORT usVersion;            // Version 1
    //  USHORT reserved;             // must be 0 for padding
    //  ULONG ulSectorSize;          // docfile header sector size (512)
    // } STGOPTIONS;

    STGOPTIONS  stgOptions;
    stgOptions.usVersion = 1;
    stgOptions.reserved = 999; 
    stgOptions.ulSectorSize = 512;

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0, 
                &stgOptions,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv STGOPTIONS dwreserved"),
                pIStorage);
    }

    if (S_OK == hr)
    {
        stgOptions.reserved = 0; 
        stgOptions.ulSectorSize = 999; // Allowed is 512 and 4096 only

        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                &stgOptions,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv STGOPTIONS ulSectorSize"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with nonzero reserved2
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with nonzero reserved2")));
    if (S_OK == hr)
    {
        stgOptions.ulSectorSize = 512; // Allowed is 512 and 4096 only
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0, 
                &stgOptions,
                (void*)999,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv reserved2"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with invalid IID
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with invalid IID")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0, 
                &stgOptions,
                NULL,
                clsidBogus,
                (void**)&pIStorage);
        CheckErrorTest(E_NOINTERFACE,
                TEXT ("StgCreateStorageEx inv riid"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with NULL ppstgOpen parameter
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with NULL ppstgOpen parameter")));
    if (S_OK == hr)
    {
        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode, 
                stgfmt,
                0,
                &stgOptions,
                NULL,
                IID_IStorage,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("StgCreateStorageEx NULL ppstg"));
    }

    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF(STGTYPE_NSSFILE);
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new VirtualDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualDF::GenerateVirtualDF")) ;
    }

    // Try commiting with grfCommitFlags = -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try commiting with grfCommitFlags = -1")));
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG, 
                TEXT("VirtualCtrNode::Commit inv flags"));
    }

    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // Instantiate DocFile with name as "" 
    // NOTE: The old test checked the erro value to be STG_E_FILENOTFOUND in 
    // this case.  On NT, we get STG_E_PATHNOTFOUND and on Chicago, we get
    // STG_E_ACCESSDENIED, so let us check against S_OK itself.

    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with name as ' '")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                (OLECHAR *) " ",
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        //BUGBUG: what exactly are we expecting failure code?

        if (RunningOnNT())
        {
            // HACKHACK: dont know exactly what the OS will return here.....
            if (STG_E_PATHNOTFOUND == hr ||
                STG_E_FILENOTFOUND == hr ||
                STG_E_INVALIDNAME == hr)
            {
                DH_TRACE ((DH_LVL_TRACE2, TEXT("Actual return value:hr=%#x"), hr));
                hr = STG_E_PATHNOTFOUND;
            }
            CheckErrorTest(STG_E_PATHNOTFOUND,
                    TEXT ("StgOpenStorageEx inv name"),
                    pIStorageOpen);
        }
        else
        {
            CheckErrorTest(STG_E_ACCESSDENIED,
                    TEXT ("StgOpenStorageEx inv name"),
                    pIStorageOpen);
        }
    }
            
    // Instantiate DocFile with nonexisting file name
    if(S_OK == hr)
    {
        // Convert tszTestName  to OLECHAR
        hr = TStringToOleString(tszTestName, &pOleStrTest);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with nonexisting file name")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTest,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("StgOpenStorageEx bad name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with NULL file name
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with NULL file name")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                NULL,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("StgOpenStorageEx NULL name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with grfMode=-1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with grfMode=-1")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                (DWORD) -1,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgOpenStorageEx inv grfMode"),
                pIStorageOpen);
    }

    // Instantiate DocFile with grfMode as dwRootMode|STGM_DELETEONRELEASE 
    // NOTE: The doc says, erro code in this case to be STG_E_INVALIDFUNCTION,
    // but error STG_E_INVALIDFLAG returned.

    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with grfMode as dwRootMode|STGM_DELETEONRELEASE")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode | STGM_DELETEONRELEASE,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFUNCTION,
                TEXT ("StgOpenStorageEx inv grfMode"),
                pIStorageOpen);
    }

    // Instantiate DocFile with stgfmt=-1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with stgfmt=-1")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                (DWORD)-1,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgOpenStorageEx inv stgfmt"),
                pIStorageOpen);
    }

    // Instantiate docfile with grfAttr == -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with grfAttr == -1")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                (DWORD)-1,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgOpenStorageEx inv grfAttr"),
                pIStorageOpen);
    }

    // Instantiate docfile with pTransaction == -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with reserved1 (pTransaction) == -1")));
    if (S_OK == hr)
    {
        stgOptions.reserved = (USHORT)(-1);
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                &stgOptions,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgOpenStorageEx inv reserved1"),
                pIStorageOpen);
    }

    // Instantiate docfile with pSecurity == -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with reserved2 (pSecurity) == -1")));
    if (S_OK == hr)
    {
        stgOptions.reserved = 0;
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                (void*)-1,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgOpenStorageEx inv reserved2"),
                pIStorageOpen);
    }

    // Instantiate docfile with bogus refiid
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with bogus refiid")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                clsidBogus,
                (void**)&pIStorageOpen);
        // ----------- flatfile change ---------------
        if(!StorageIsFlat())
        {
        // ----------- flatfile change ---------------
        CheckErrorTest(E_NOINTERFACE,
                TEXT ("StgOpenStorageEx inv riid"),
                pIStorageOpen);
        }
        else
        {
        CheckErrorTest(STG_E_INVALIDFUNCTION,
                TEXT ("StgOpenStorageEx of a docfile with inv riid"),
                pIStorageOpen);
        }   // ----------- flatfile change ---------------
    }

    // Instantiate DocFile with NULL ppstgOpen parameter (8th)
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with NULL ppstgOpen parameter")));
    if (S_OK == hr)
    {
        hr = StgOpenStorageEx(
                pOleStrTest,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("StgOpenStorageEx NULL ppstg"));
    }

    // Instatiate correctly.
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        // ----------- flatfile change ---------------
        if(StorageIsFlat())
        {
        CheckErrorTest(STG_E_INVALIDFUNCTION,
                TEXT ("StgOpenStorageEx -opening docfile as flatfile"),
                pIStorageOpen);
        }
        // ----------- flatfile change ---------------
        DH_HRCHECK (hr, TEXT("StgOpenStorageEx"));

        // close it.
        if (NULL != pIStorageOpen)
        {
            ulRef = pIStorageOpen->Release();
            DH_ASSERT (0 == ulRef);
            pIStorageOpen = NULL; 
        }
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_200 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_200 failed; hr=%#lx; fPass=%d."),
                hr,
                fPass));
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings
    if(NULL != pOleStrTemp)
    {
        delete []pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if(NULL != pOleStrTest)
    {
        delete []pOleStrTest;
        pOleStrTest = NULL;
    }

    if(NULL != pRootDocFileName)
    {
        delete []pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_200 finished")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_201 
//
// Synopsis: The test attempts various illegitimate operations using names
//       greater than MAX_STG_NAME_LEN, it then attempts to create
//       several random named root docfiles.  If the create is succesful,
//       then a random named child IStorage or IStream is also created.
//       Whether or not the root create was successful, we attempt to
//       open the root docfile (this is expected to fail, the point is
//       to check for asserts/GP faults rather than return codes).  If
//       the instantiation is successful, the test also tries to
//       instantiate the child object.  All objects are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IANAMES.CXX
// 2.  Old name of test : IllegitAPINames test 
//     New Name of test : APITEST_201 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-201
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-201
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-201
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: APITEST-201 NO
//
//-----------------------------------------------------------------------------

HRESULT APITEST_201(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        poszBadName             = NULL;
    LPOLESTR        poszBadNameStg          = NULL;
    LPTSTR          ptszBadNameStg          = NULL;
    DWORD           dwRootMode              = 0;
    ULONG           i                       = 0;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageChild          = NULL;
    LPSTREAM        pIStreamChild           = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    BOOL            fPass                   = TRUE;
    DWORD           stgfmt                  = StorageIsFlat()?STGFMT_FILE:0;
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_201"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_201 started.")) );
    DH_TRACE((DH_LVL_ALWAYS, 
            TEXT("Call StgCreateDocFile/CreateStorage/CreateStream with ")
            TEXT("too long names.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new ChanceDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Run Mode for APITEST_201, Access mode: %lx"),
                pTestChanceDF->GetRootMode()));
    }

    // Call StgCreateDocFile with too long a name for docfile.
    // NOTE: Old test to fail with MAX_STG_NAME_LEN*3, but not in new test,
    // fails with MAX_STG_NAME_LEN*4.
    // NOTE: Crashes in DfFromName in OLE if length is of MAX_STG_NAME_LEN*8
    // CHECK!!!

    if(S_OK == hr)
    {
        poszBadName = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == poszBadName)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {
            poszBadName[i] = 'X';
        }
        poszBadName[i] ='\0';
    }

    // Try calling StgCreateDocFile with the above long name pszBadName 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                poszBadName,
                dwRootMode | STGM_CREATE, 
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);

        // HACKHACK: dont know exactly what the OS will return here.....
        if (STG_E_PATHNOTFOUND == hr ||
            STG_E_FILENOTFOUND == hr ||
            STG_E_INVALIDNAME == hr)
        {
            DH_TRACE ((DH_LVL_TRACE2, TEXT("Actual return value:hr=%#x"), hr));
            hr = STG_E_PATHNOTFOUND;
        }
        CheckErrorTest(STG_E_PATHNOTFOUND,
                TEXT ("StgCreateStorageEx inv name"),
                pIStorage);
    }


    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF(STGTYPE_NSSFILE);
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new VirtualDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualDF::GenerateVirtualDF")) ;
    }


    // Get IStorage pointer
    if (S_OK == hr)
    {
        pIStorage = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pIStorage);
        if (NULL == pIStorage)
        {
            hr = E_FAIL;
        }
    }

    // Call CreateStorage with too long a name for docfile.
    if(S_OK == hr)
    {
        ptszBadNameStg = (TCHAR *) new TCHAR [MAX_STG_NAME_LEN*3];
        if (NULL == ptszBadNameStg)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new TCHAR"));
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*3 -1); i++)
        {
            ptszBadNameStg[i] = 'X';
        }
        ptszBadNameStg[i] ='\0';
    }

    if(S_OK == hr)
    {
        // Convert Bad storage name to OLECHAR
        hr = TStringToOleString(ptszBadNameStg, &poszBadNameStg);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    // now call CreateStorage with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStorage(
                poszBadNameStg,
                pTestChanceDF->GetStgMode(),
                0,
                0,
                &pIStorageChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStorage long name"),
                pIStorageChild);
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------


    // Now call CreateStream with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStream(
                poszBadNameStg,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pIStreamChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStream long name"),
                pIStreamChild);
    }

    // Now add a Valid storage to root.  Call AddStorage that in turns calls
    // CreateStorage
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    // Now try to rename this storage element to a bad name.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDNAME);
        hr = pvcnRootNewChildStorage->Rename(ptszBadNameStg);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDNAME, 
                TEXT ("VirtualCtrNode::Rename inv name"));
    }

    // Close the Storage pvcnRootNewChildStorage 
    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Close"));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Close"));
    }

    // Delete temp strings
    if(NULL != poszBadNameStg)
    {
        delete [] poszBadNameStg;
        poszBadNameStg = NULL;
    }

    if(NULL != poszBadName)
    {
        delete [] poszBadName;
        poszBadName = NULL;
    }

    if(NULL != ptszBadNameStg)
    {
        delete [] ptszBadNameStg;
        ptszBadNameStg = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // In the following section of test:
    //make a random number of random length, random character root
    //docfiles.  for this variation, we don't care if the operation
    //succeeds, looking for GP faults and asserts only.  if the
    //StgCreateDocfile fails, we'll still attempt the open.  of
    //course, the open in this case will be expected to fail, but
    //again, we won't be checking return codes... If the StgCreateDocfile
    //passes, we'll create a random name IStream or IStorage too.

    ULONG       count               =   0;    
    ULONG       cMinNum             =   16;    
    ULONG       cMaxNum             =   128;
    LPTSTR      ptszRandomRootName  =   NULL;  
    LPTSTR      ptszRandomChildName =   NULL;  
    ULONG       countFlag           =   0;    
    ULONG       cMinFlag            =   0;    
    ULONG       cMaxFlag            =   100;
    ULONG       nChildType          =   0;
    LPSTORAGE   pstgRoot            =   NULL; 
    LPSTORAGE   pstgChild           =   NULL; 
    LPSTREAM    pstmChild           =   NULL; 
    LPOLESTR    poszRandomRootName  =   NULL;
    LPOLESTR    poszRandomChildName =   NULL;
    ULONG       ulRef               =   0;

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&count, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("pdgi::Generate")) ;
    }

    while(count--)
    {
        if(S_OK == hr)
        {
            hr=GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszRandomRootName);
            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            // Convert name to OLECHAR
            hr = TStringToOleString(ptszRandomRootName, &poszRandomRootName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if (S_OK == hr)
        {
            pstgRoot = NULL;

            hr = StgCreateStorageEx(
                    poszRandomRootName,
                    dwRootMode | STGM_CREATE,
                    stgfmt,
                    0,
                    NULL,
                    NULL,
                    IID_IStorage,
                    (void**)&pstgRoot);
            DH_HRCHECK (hr, TEXT("StgCreateStorageEx"));
        }

        nChildType = NONE;

        if(S_OK == hr)
        {
            if(S_OK == hr)
            {
                hr=GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH, 
                    &ptszRandomChildName);
                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert name to OLECHAR
                hr = TStringToOleString(
                        ptszRandomChildName, 
                        &poszRandomChildName);
                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pdgi->Generate(&countFlag, cMinFlag, cMaxFlag);
                DH_HRCHECK(hr, TEXT("pdgi::Generate")) ;
            }

            if(!StorageIsFlat() && countFlag > (cMaxFlag/2))
            {
                hr = pstgRoot->CreateStorage(
                        poszRandomChildName,
                        pTestChanceDF->GetStgMode(),
                        0,
                        0,
                        &pstgChild);
                DH_HRCHECK(hr, TEXT("IStorage::CreateStorage"));

                if(S_OK == hr)
                {
                    nChildType = STORAGE;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                    ulRef = pstgChild->Release();
                    DH_ASSERT (0 == ulRef);
                    pstgChild = NULL;
                }
            }
            else
            {
                hr = pstgRoot->CreateStream(
                        poszRandomChildName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        0,
                        0,
                        &pstmChild);   
                DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
 
                if(S_OK == hr)
                {
                    nChildType = STREAM;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                    ulRef = pstmChild->Release();   
                    DH_ASSERT (0 == ulRef);
                    pstmChild = NULL;
                }
            }

            ulRef = pstgRoot->Release();
            DH_ASSERT (0 == ulRef);     
            pstgRoot = NULL;
        }
        
        //Try to open Root Storage whetehr the creation was successful or not
        
        hr = StgOpenStorageEx(
                poszRandomRootName,
                pTestChanceDF->GetStgMode(),
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pstgRoot);
        DH_HRCHECK (hr, TEXT("StgOpenStorageEx"));

        if(S_OK == hr)
        {
            switch(nChildType)
            {
                case STORAGE:
                    {
                        hr = pstgRoot->OpenStorage(
                                poszRandomChildName,
                                NULL, 
                                pTestChanceDF->GetStgMode(),
                                NULL, 
                                0,
                                &pstgChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStorage"));
 
                        if(S_OK == hr)
                        {
                            ulRef = pstgChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstgChild = NULL;
                        }
                    }
                    break; 
                case STREAM:
                    {
                        hr = pstgRoot->OpenStream(
                                poszRandomChildName,
                                NULL, 
                                STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStream"));
 
                        if(S_OK == hr)
                        {
                            ulRef = pstmChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstmChild = NULL;
                        }
                    }
                    break; 
            } /* switch */

            ulRef = pstgRoot->Release();
            DH_ASSERT (0 == ulRef);
            pstgRoot = NULL;
        }    

        // Delete temp strings
        if(NULL != ptszRandomChildName)
        {
            delete [] ptszRandomChildName;
            ptszRandomChildName = NULL;
        }

        if(NULL != ptszRandomRootName)
        {
            if(FALSE == DeleteFile(ptszRandomRootName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
            delete [] ptszRandomRootName;
            ptszRandomRootName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_201 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation APITEST_201 failed; hr=%#lx; fPass=%d."),
            hr,
            fPass));
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file
    if(NULL != pTestVirtualDF)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];
        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;
        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings
    if(NULL != pFileName)
    {
        delete []pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_201 finished")) );

    return hr;

}

//----------------------------------------------------------------------------
//
// Test:    APITEST_202 
//
// Synopsis: Attempts various operations in obtaining enumerators, checking
//       for proper error return.  Then gets a valid enumerator, and
//       attempts various illegitimate method calls on it.  Verify
//       proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IAENUM.CXX
// 2.  Old name of test : IllegitAPIEnum test 
//     New Name of test : APITEST_202 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-202
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-202
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-202
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /labmode
//
// BUGNOTE: Conversion: APITEST_202
//-----------------------------------------------------------------------------

HRESULT APITEST_202(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    ULONG           cMinNum                 = 1;
    ULONG           cMaxNum                 = 999;
    DWORD           dwReserved1             = 0;
    DWORD           dwReserved3             = 0;
    LPTSTR          pReserved2              = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    ULONG           celtFetched             = 0;
    STATSTG         statStg;
    LPMALLOC        pMalloc                 = NULL;
    STATSTG         *pStatStg               = NULL;
    INT             cAskMoreThanPresent     = 2; // Set to 2 since only 1 substg                                                 // added in test
 
 
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_202"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_202 started")) );
    DH_TRACE((DH_LVL_ALWAYS, 
            TEXT("Attempt different illegitimate opeations on IEnumSTATSTG")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }


    if (S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("Run Mode for APITEST_202, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    //    Adds a new storage to the root storage.
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }
// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------


    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Close the Child storage
    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Get the random number generator
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved1, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("pdgi::Generate")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr = pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved1"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved3, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved3"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pReserved2);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv pReserved2"),
                penumWalk);
    }

    // Now call EnumElements with NULL ppenm 4th parameter.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPOINTER);
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, NULL);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("VirtualCtrNode::EnumElements NULL penum"));
    }

    // Make a valid call to EnumElements now
    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, &penumWalk);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Now try the following skip calls - Attempt to skip 0 elements and 
    // attempt to skip MAX_ULONG elements.

    // Attempt to Skip 0 elements.

    if(S_OK == hr)
    {
        hr = penumWalk->Skip(0L);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Skip")) ;
    }

    // Attempt to Skip ULONG_MAX elements.

    // NOTE: In the old test, this was supposed to return S_OK, but it returns
    // S_FALSE
    if(S_OK == hr)
    {
        hr = penumWalk->Skip(ULONG_MAX);
        CheckErrorTest2(S_FALSE, 
                TEXT ("IEnumSTATSTG::Skip ULONG_MAX"));
    }

    // Call Clone with NULL ppenum parameter (ist)
    if(S_OK == hr)
    {
        hr = penumWalk->Clone(NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Clone NULL ppEnum"));
    }

    if(S_OK == hr)
    {
        statStg.pwcsName = NULL;

        // first get pmalloc that would be used to free up the name string from
        // STATSTG.

        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Reset the enumerator back to start and then test Next methods

    if(S_OK == hr)
    {
        hr = penumWalk->Reset();
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG:Reset")) ;
    }

    // Call Next with celt equal to zero, but pceltFetched as not NULL.
    if(S_OK == hr)
    {
        hr = penumWalk->Next(0, &statStg ,&celtFetched);
        DH_TRACE((DH_LVL_TRACE4,
                 TEXT("celt given 0, celtFetched is %lu, hr is %lx\n"), 
                 celtFetched, hr));
        DH_HRCHECK (hr, TEXT("IEnumSTATSTG::Next celt 0"));
    }

    // Call Next with celt equal to 999, but celtFetched set to NULL

    if(S_OK == hr)
    {
        hr = penumWalk->Next(999, &statStg ,NULL);
        CheckErrorTest2(STG_E_INVALIDPARAMETER, 
                TEXT ("IEnumSTATSTG::Next celt 999 and pceltFetched NULL"));
    }

    // Call Next with rgelt as NULL (2nd parameter). celtFetched may be NULL 
    // when celt asked is 1

    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, NULL, NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Next rgelt NULL"));
    }

    // Call Next with celt as 1 and pceltFetched as NULL.  Allowed as per spec
    // For docfile/nssfile, it will pass since it has a substorage added as 
    // above. For flatfile, it will pass since it has CONTENTS stream always

    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, &statStg, NULL);
        DH_TRACE((DH_LVL_TRACE4,
                 TEXT("Name of element fetched is %s\n"), 
                 statStg.pwcsName));
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Next celt 1 and pceltFetched NULL"));
    }   

    // Clean up

    if(NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Call Next with celt more than elements in stg & celtFetched as not NULL
    if(S_OK == hr)
    {
        hr = penumWalk->Reset();
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG:Reset")) ;
    }

    if(S_OK == hr)
    {
        pStatStg = new STATSTG[cAskMoreThanPresent];
        if(NULL == pStatStg)
        {
            hr = E_OUTOFMEMORY;
        }  
    }

    if(S_OK == hr)
    { 
        hr = penumWalk->Next(cAskMoreThanPresent, pStatStg ,&celtFetched);
        DH_TRACE((DH_LVL_TRACE4,
                 TEXT("IEnumSTATSTG celt more, hr %lx, celtFetched %lu\n"), 
                 hr, celtFetched));
        CheckErrorTest2(S_FALSE,
                TEXT ("IEnumSTATSTG::Next celt more number of elements"));
    }

    if(NULL != pStatStg)
    {
        delete [] pStatStg;
        pStatStg= NULL;
    }

    // Free LPENUMSTATSTG pointer
    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT (0 == ulRef);
        penumWalk = NULL;
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_202 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation APITEST_202 failed; hr=%#lx; fPass=%d."),
            hr,
            fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // free strings

    if(NULL != pReserved2)
    {
      delete [] pReserved2;
      pReserved2 = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }
 
   // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_202 finished")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    APITEST_203 
//
// Synopsis: Attempts various illegit operations on the IStorage interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTORAG.CXX
// 2.  Old name of test : IllegitAPIStorage test 
//     New Name of test : APITEST_203 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-203
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-203
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-203
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: APITEST_203
//-----------------------------------------------------------------------------

HRESULT APITEST_203(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hrExpected              = E_NOTIMPL; // Flatfile change
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStgName        = NULL;
    LPOLESTR        poszChildStgName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTORAGE       pStgChild2              = NULL;
    LPSTREAM        pStmChild               = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           ulRef                   = 0;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_203"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_203 started.")) );
    DH_TRACE((DH_LVL_ALWAYS, 
      TEXT("Attempt various illegitimate operations on IStorage interface")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("Run Mode for APITEST_203, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }


    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStgName, &poszChildStgName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call CreateStorage with grfmode=-1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                (DWORD) -1,
                0,
                0,
                &pStgChild);
   
        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDFLAG; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected, 
                TEXT ("IStorage::CreateStorage inv grfMode"),
                pStgChild);
    }

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                cRandom,
                0,
                &pStgChild);

        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDPARAMETER; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected, 
                TEXT ("IStorage::CreateStorage inv dwReserved1"),
                pStgChild);
    }

    // Call CreateStorage with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                cRandom,
                &pStgChild);

        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDPARAMETER; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected, 
                TEXT ("IStorage::CreateStorage inv dwReserved2"),
                pStgChild);
    }

    // Call CreateStorage with NULL 5th ppstg parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                0,
                NULL);
        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDPOINTER; 
        // ----------- flatfile change ---------------

        CheckErrorTest2(hrExpected,
                TEXT ("IStorage::CreateStorage NULL ppstg"));
    }


    // Create a stream with poszChildName and later on try to instantiate the
    // child storage with that same name poszChildName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStgName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close stream...
    if (NULL != pStmChild)
    {
         ulRef = pStmChild->Release();
         DH_ASSERT (0 == ulRef);
    }

    // Now try opening storage with name with which above stream was created
    // i.e.  poszChildName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL, 
                0,
                &pStgChild);
        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_FILENOTFOUND; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    //Destroy the stream element of this root storage having name poszChildStg
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStgName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

// ----------- flatfile change ---------------
if(!StorageIsFlat()) 
// ----------- flatfile change ---------------
{
    // Create a valid storage with name poszChildStgName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStorage"));
    }

    // Commit with grfCommitFlags = -1
     if (S_OK == hr)
    {
        hr = pStgChild->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG, 
                TEXT("IStorage::Commit inv flag"));
    }

    // Commit the child.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pStgChild->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("IStorage::Commit"));
    }

    // Commit the root storage.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Attempt second instantiation of pStgChild which is already open.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild2);
        CheckErrorTest(STG_E_ACCESSDENIED, 
                TEXT ("IStorage::OpenStorage 2nd time"),
                pStgChild2);
    }

    if (S_OK == hr)
    {
        ulRef = pStgChild->Release();
        DH_ASSERT (0 == ulRef);
    }

    // Now try to open child IStorage, but with grfMode = -1
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                (DWORD) -1,
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStorage inv grfMode"),
                pStgChild);
    }

    // Attempt OpenStorage with name as " " of IStorage to be opened.
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                (OLECHAR *) " ",
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    // Attempt OpenStorage with name as NULL of IStorage to be opened.
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                NULL,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStorage NULL name"),
                pStgChild);
    }

    // Attempt OpenStorage with name as NULL ppstg, 6th parameter.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStorage NULL ppstg"));
    }

    // Attempt OpenStorage with random data in dwReserved parameter
    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                cRandom,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage inv dwReserved"),
                pStgChild);
    }

    // Attempt OpenStorage with uninitialized SNB, should fail, but no GP
    // fault should occur.
    if(S_OK == hr)
    {
        snbTest = (OLECHAR **) new OLECHAR [sizeof(OLECHAR *) * 2];
        if(NULL == snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            *snbTest = (OLECHAR*)0xBAADF00D;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage inv snb"),
                pStgChild);
    }

    // Attempt OpenStorage with SNB with no name in block, although it has 
    // space for two names, set name list to NULL

    if(S_OK == hr)
    {
        *snbTest = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage empty snb"),
                pStgChild);
    }

    // Allocate space for long name and fill name with X's, make next SNB 
    // element NULL, and make a call to IStorage::OpenStorage with too long a 
    // name in SNB
    if(S_OK == hr && NULL != snbTest)
    {
        *snbTest = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == *snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr && NULL != snbTest)
    {
        snbTemp = snbTest;
        ocsSNBChar = *snbTemp;

        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {
            ocsSNBChar[i] = 'X';
        }

        ocsSNBChar[i] = '\0';

        // Assign second element as NULL
        snbTemp++;
        *snbTemp = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;

        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage long snb"),
                pStgChild);
    }

// ----------- flatfile change ---------------
}
// ----------- flatfile change ---------------

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_203 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation APITEST_203 failed; hr=%#lx; fPass=%d."),
            hr,
            fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings
    if(NULL != ptszChildStgName)
    {
        delete []ptszChildStgName;
        ptszChildStgName = NULL;
    }

    if(NULL != poszChildStgName)
    {
        delete []poszChildStgName;
        poszChildStgName = NULL;
    }

    // Free SNB

    if(NULL != snbTest)
    {
        if(NULL != *snbTest)
        {
            delete [] *snbTest;
            *snbTest = NULL;
        }
        delete [] snbTest;
        snbTest = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_203 finished")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_204 
//
// Synopsis: Attempts various illegit operations on the IStream interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTREAM.CXX
// 2.  Old name of test : IllegitAPIStream test 
//     New Name of test : APITEST_204 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-204
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-204
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-204
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: APITEST_204
//-----------------------------------------------------------------------------

HRESULT APITEST_204(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStmName        = NULL;
    LPOLESTR        poszChildStmName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    LPSTREAM        pStmChild2              = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_204"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_204 started.")) );
    DH_TRACE((DH_LVL_ALWAYS, 
        TEXT("Attempt illegitimate operations on IStream interface.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("Run Mode for APITEST_204, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_STRING pointer 
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Generate random name for stream
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &ptszChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStmName, &poszChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Attempt CreateStream with grfmode=-1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                (DWORD) -1,
                0,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::CreateStream inv grfMode"),
                pStmChild);
    }

    // Get DG_INTEGER pointer
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1

    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved1"),
                pStmChild);
    }

    // Call CreateStream with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved2"),
                pStmChild);
    }

    // Call CreateStorage with NULL 5th ppstm parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::CreateStream NULL ppstm"));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Create a storage with poszChildStmName and later on try to instantiate 
    // child stream with that same name poszChildStmName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStorage"));
        DH_ASSERT (NULL != pStgChild);
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close storage...
    if (NULL != pStgChild)
    {
         ulRef = pStgChild->Release();
         DH_ASSERT (0 == ulRef);
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------
    // Now try opening storage with name with which above storage was created
    // i.e.  poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::CreateStream inv name"),
                pStmChild);
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    //Destroy the storage element of this root storage having name poszChildStm
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStmName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------
    // Create a valid stream with name poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
        DH_ASSERT (NULL != pStmChild);
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("IStorage::Commit"));
    }

    // Attempt second instance of IStream to be instantiated.
    if (S_OK == hr)
    {
        pStmChild2 = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild2);
        CheckErrorTest(STG_E_ACCESSDENIED,
                TEXT ("IStorage::OpenStream 2nd time"),
                pStmChild2);
    }

    // Release the stream
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT (0 == ulRef);
    }

    // Now attempt opening the stream with grfMode = -1
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                (DWORD) -1,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStream inv grfMode"),
                pStmChild);
    }

    // Now attempt opening the stream with name as ""
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                (OLECHAR *) " ",
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStream inv name"),
                pStmChild);
    }

    // Now attempt opening the stream with name as NULL 
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                NULL,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStream NULL name"),
                pStmChild);
    }

    // Now attempt opening the stream with random data in pReserved1 . For test
    // we just put pStgRoot for pReserved1 variable.
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                pStgRoot,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv dwReserved1"),
                pStmChild);
    }

    // Now attempt opening the stream with random data in dwReserved2 
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv dwReserved2"),
                pStmChild);
    }

    // Now attempt opening the stream with NULL ppstm (5th parameter) 
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStream NULL ppstm"));
    }

    // Now attempt opening the stream normally 
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::OpenStream"));
        DH_ASSERT (NULL != pStmChild);
    }

    // Release the stream
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT (0 == ulRef);
        pStmChild = NULL;
    }

    // Release the root docfile
    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_204 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_204 failed; hr=%#lx; fPass=%d."),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp string
    if(NULL != ptszChildStmName)
    {
        delete []ptszChildStmName;
        ptszChildStmName = NULL;
    }

    if(NULL != poszChildStmName)
    {
        delete []poszChildStmName;
        poszChildStmName = NULL;
    }

    // Stop logging the test
    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_204 finished")) );

    return hr;
}

#else

// Stub out calls to these.
HRESULT APITEST_200(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_201(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_202(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_203(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_204(int argc, char *argv[]) {return E_NOTIMPL;} 

#endif  // _OLE_NSS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\utest\cmdutest\cmdutest.cxx ===
//+-------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       cmdutest.cxx
//
//  Contents:   Unit test for the CDebugHelp class implementation.
//              Utilizes functions in arghelp.cxx and the CRegistryHelp
//              class.
//
//  Classes:    None
//
//  History:    28-Nov-94   DeanE   Created
//---------------------------------------------------------------------
#include <oleworld.hxx>


// Declare the CDebugHelp object
DH_DECLARE;


// Local Functions
HRESULT SettingsTest(VOID);
HRESULT TraceTest(VOID);
HRESULT LogTest(VOID);
HRESULT AssertTest(VOID);


// Test TRACE level flags
#define DH_UTEST_LVL1   0x00001000
#define DH_UTEST_LVL2   0x08000000


// Results macros
#define TESTFAIL(msg)   \
        printf("FAIL: %s, %ul  - %s\n", __FILE__, __LINE__, msg)

#define TESTPASS(msg)    \
        printf("PASS: %s\n", msg)


// Define the CDebugHelp object
DH_DEFINE;


//+---------------------------------------------------------------------
//  Function:   main
//
//  Synopsis:   Command line test utilizing a CDebugHelp object.
//              Excercises Trace Location, Log Location, Trace Level,
//              Trace and Log output, and Assert functionality.  Uses
//              a log created via DH_CREATELOGARGS.
//
//  Arguments:  [argc] - Number of command line arguments.
//              [argv] - Command line arguments.
//
//  Returns:    Zero if no errors, otherwise non-zero
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
    HRESULT hr;

    // First, create a log
    hr = DH_CREATELOGARGS(argc, argv);
    if (FAILED(hr))
    {
        printf("Log creation failed - %lx\n", hr);
        return(1);
    }

    // Set & retrieve settings
    hr = SettingsTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Debug settings");
    }
    else
    {
        TESTFAIL("Debug settings");
        return(1);
    }

    // Trace output macro tests
    hr = TraceTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Trace Output");
    }
    else
    {
        TESTFAIL("Trace Output");
        return(1);
    }

    // Logging output macro tests
    hr = LogTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Log Output");
    }
    else
    {
        TESTFAIL("Log Output");
        return(1);
    }

    // Assert tests
    hr = AssertTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Assert Test");
    }
    else
    {
        TESTFAIL("Assert Test");
        return(1);
    }

    return(0);
}


//+---------------------------------------------------------------------
//  Function:   SettingsTest
//
//  Synopsis:   Sets and checks (by retrieving) values in the
//              global CDebugHelp object.  Assumes a log has been
//              created.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT SettingsTest()
{
    HRESULT hr;
    DWORD   fValues;

    // Set and check Trace Location
    //   Set a valid setting - should succeed
    //
    hr = DH_SETTRACELOC(DH_LOC_STDOUT);
    if (SUCCEEDED(hr))
    {
        fValues = DH_GETTRACELOC;
        hr = (fValues & DH_LOC_STDOUT) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETTRACELOC test - valid setting");
    }


    //   Set an invalid setting - should fail
    if (SUCCEEDED(hr))
    {
        hr = DH_SETTRACELOC(DH_LOC_NONE);
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETTRACELOC test - invalid setting");
        return(hr);
    }

    // Set and check Log Location
    //   Set a valid setting - should succeed
    //
    hr = DH_SETLOGLOC(DH_LOC_STDOUT|DH_LOC_LOG);
    if (SUCCEEDED(hr))
    {
        fValues = DH_GETLOGLOC;
        hr = (fValues & DH_LOC_STDOUT) &&
             (fValues & DH_LOC_LOG) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLOGLOC test - valid setting");
    }

    //   Set an invalid setting - should fail
    if (SUCCEEDED(hr))
    {
        hr = DH_SETLOGLOC(DH_LOC_NONE);
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLOGLOC test - invalid setting");
        return(hr);
    }


    // Set and check Trace Level
    //   Set a valid level - should succeed
    //
    hr = DH_SETLVL(DH_UTEST_LVL1|DH_LVL_TRACE1);
    if (SUCCEEDED(hr))
    {
        fValues = DH_GETTRACELVL;
        hr = (fValues & DH_UTEST_LVL1) &&
             (fValues & DH_LVL_TRACE1) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLVL test - valid setting");
    }

    //   Try to turn one of the reserved settings off - should fail
    if (SUCCEEDED(hr))
    {
        hr = DH_SETLVL(DH_GETTRACELVL&~DH_LVL_ERROR);
        if (SUCCEEDED(hr))
        {
            fValues = DH_GETTRACELVL;
            hr = (fValues & DH_LVL_ERROR) ? S_OK : E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLVL - turn reserved off");
    }

    return(hr);
}


//+---------------------------------------------------------------------
//  Function:   TraceTest
//
//  Synopsis:   Tests TRACE macro outputs of the global CDebugHelp object.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT TraceTest()
{
    HRESULT hr;

    // Set the Trace Location to STDOUT and the debug terminal so we
    // can see messages
    //
    hr = DH_SETTRACELOC(DH_LOC_STDOUT|DH_LOC_TERM);
    if (FAILED(hr))
    {
        TESTFAIL("Cannot set test trace location");
        return(hr);
    }

    printf("Six messages should appear\n");

    // Set a level that should NOT produce a message...
    hr = DH_SETLVL(DH_UTEST_LVL2);
    if (FAILED(hr))
    {
        TESTFAIL("Failure setting test trace level");
        return(hr);
    }

    // Output a message at a level NOT set
    DH_TRACE((DH_UTEST_LVL1, TEXT("ERROR! Message should not appear!")));

    // Output simple messages that should appear
    DH_TRACE((DH_LVL_ALWAYS, TEXT("Sample ALWAYS message")));
    DH_TRACE((DH_LVL_ERROR, TEXT("Sample ERROR message")));
    DH_TRACE((DH_UTEST_LVL2, TEXT("Sample USER-DEFINED message")));

    // Output complex messages
    DH_TRACE((DH_LVL_ALWAYS,
              TEXT("ALWAYS - Expansion File: %s, Line: %lu"),
              TEXT(__FILE__),
              __LINE__));

    // Output messages with multiple levels set
    hr = DH_SETLVL(DH_UTEST_LVL2 | DH_UTEST_LVL1);
    if (FAILED(hr))
    {
        TESTFAIL("Failure setting multiple trace levels");
        return(hr);
    }
    DH_TRACE((DH_UTEST_LVL1,
              TEXT("Sample MULTI-USER-DEFINED message value: %lx"),
              DH_UTEST_LVL1));
    DH_TRACE((DH_UTEST_LVL2,
              TEXT("Sample MULTI-USER-DEFINED message value: %lx"),
              DH_UTEST_LVL2));
    DH_TRACE((DH_LVL_TRACE4,
              TEXT("ERROR! Message TRACE4 should not appear!")));

    return(hr);
}


//+---------------------------------------------------------------------
//  Function:   LogTest
//
//  Synopsis:   Tests LOG macro outputs of the global CDebugHelp object.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT LogTest()
{
    HRESULT hr;

    // Set the Log Location to STDOUT, the log, and the debug
    // terminal so we can see messages
    //
    hr = DH_SETLOGLOC(DH_LOC_STDOUT|DH_LOC_TERM|DH_LOC_LOG);
    if (FAILED(hr))
    {
        TESTFAIL("Cannot set test log location");
        return(hr);
    }

    // Report a simple PASS, complex FAIL, and statistics
    DH_LOG((LOG_PASS, TEXT("Simple sample PASS")));
    DH_LOG((LOG_FAIL,
            TEXT("Complex sample FAIL %s, %lu"),
            TEXT(__FILE__),
            __LINE__));

    printf("Correct totals: 1 PASS, 1 FAIL, 0 ABORT\n");

    DH_LOGSTATS;

    return(hr);
}


//+---------------------------------------------------------------------
//  Function:   AssertTest
//
//  Synopsis:   Tests ASSERT macro outputs of the global CDebugHelp object.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT AssertTest()
{
#pragma warning(disable: 4127)    // Examined and ignored

    // Set Lab Mode to ON - we should NOT get any popups
    DH_SETMODE(DH_LABMODE_ON);

    // Trigger an assert
    DH_ASSERT(!"LABMODE ON - NO POPUP SHOULD APPEAR");


    // Set Lab Mode to ON - we should get popups
    DH_SETMODE(DH_LABMODE_OFF);

    // This assert should NOT trigger
    DH_ASSERT(5 < 6);

    // Set Lab Mode to OFF - we should get a popup
    DH_ASSERT(!"LABMODE OFF - POPUP SHOULD APPEAR");

#pragma warning(default: 4127)    // Examined and ignored

    return(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\createdf.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       init.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  main 
//
//  History:    26-Feb-1997     SCousens    Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <init.hxx>

HRESULT MakeVirtualDF (UINT uOp, ChanceDF *pTestChanceDF, VirtualCtrNode **ppvcnRoot, VirtualDF **ppTestVirtualDF);

// Global:
// For stress debug purposes. So we can get to the seed from 
// within the debugger
// do not use gulSeed for anything else!
ULONG gulSeed=0;


//----------------------------------------------------------------------------
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   argc            - # params on commandline
//              argv            - array of pointers to commandline
//              ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//              ppTestChanceDF  - bucket for pChanceDF  
//
//    SYNOPSIS: Determine whether we are creating a DF, or
//              opening and existing one.
//              Creating
//                Create a ChanceDF of random nodes,
//                Create the VirtualDF from this (GenerateVirtualDF)
//                Commit and close the resulting docfile
//              Opening
//                Figure the name, open it (GenerateVirtualDFFromDiskDF)
//                Also need to set _pgdu, _pgdi
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    All stms and Stgs of the docfile will have been commited
//              and and saved, but all will be open before returning
//              The name of the file will be the first string generated
//              after creating the DataGen for strings. Its the way it 
//              works, we can use this knowledge to our advantage (until
//              someone changes that behaviour and breaks us)
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CreateTestDocfile (
        int               argc, 
        char            **argv, 
        VirtualCtrNode  **ppvcnRoot,
        VirtualDF       **ppTestVirtualDF,
        ChanceDF        **ppTestChanceDF)
{
    HRESULT     hr           = S_OK;
    ChanceDF   *pChanceDF    = NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CreateTestDocfile"));
    DH_VDATEPTROUT (ppvcnRoot, VirtualCtrNode *);
    DH_VDATEPTROUT (ppTestVirtualDF, VirtualDF *);

    *ppvcnRoot = NULL;
    *ppTestVirtualDF = NULL;
    if (NULL != ppTestChanceDF)
    {
        DH_VDATEPTROUT (ppTestChanceDF, ChanceDF *);
        *ppTestChanceDF = NULL;
    }

    // Always create this. There is lots of juicy info that 
    // we will need either way.
    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pChanceDF = new ChanceDF();
        if(NULL == pChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pChanceDF->CreateFromParams (argc, argv);
        DH_HRCHECK(hr, TEXT("pChanceDF->CreateFromParams")) ;
    }

    // Make VirtualDF
    if (S_OK == hr)
    {
        hr = MakeVirtualDF (pChanceDF->GetOpenCreateDF (),
                    pChanceDF,
                    ppvcnRoot,
                    ppTestVirtualDF);
    }

    // If the caller wants ChanceDF give it to them, otherwise delete it
    if (NULL == ppTestChanceDF)
    {
        delete pChanceDF;
    }
    else
    {
        *ppTestChanceDF = pChanceDF;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   pcdfd           - CDFD for chancedf
//              pFileName       - name of docfile
//              ulSeed          - seed (to get name)
//              ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//              ppTestChanceDF  - bucket for pChanceDF  
//
//    SYNOPSIS: See above 
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    See description above 
//
//    HISTORY:  19-Mar-1997     SCousens     Created.
//
//----------------------------------------------------------------------------

HRESULT CreateTestDocfile (
        CDFD             *pcdfd,
        LPTSTR            pFileName,
        VirtualCtrNode  **ppvcnRoot,
        VirtualDF       **ppTestVirtualDF,
        ChanceDF        **ppTestChanceDF)
{

    HRESULT     hr           = S_OK;
    ChanceDF   *pChanceDF    = NULL;
    LPTSTR      pDocFileName = NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CreateTestDocfile"));
    DH_VDATEPTRIN  (pcdfd, CDFD);
    DH_VDATEPTROUT (ppvcnRoot, VirtualCtrNode *);
    DH_VDATEPTROUT (ppTestVirtualDF, VirtualDF *);

    *ppvcnRoot = NULL;
    *ppTestVirtualDF = NULL;
    if (NULL != ppTestChanceDF)
    {
        DH_VDATEPTROUT (ppTestChanceDF, ChanceDF *);
        *ppTestChanceDF = NULL;
    }

    // If dont have a filename, make one
    if (NULL == pFileName)
    {
        DG_STRING *pdgu = NULL;
        if (S_OK == hr)
        {
            // Create a new DataGen object to create random UNICODE strings.
            pdgu = new DG_STRING (pcdfd->ulSeed);
            if (NULL == pdgu)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            // Generate random name for root 
            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pDocFileName);
                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }
        delete pdgu;
    }
    
    // Always create this. 
    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pChanceDF = new ChanceDF();
        if(NULL == pChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pChanceDF->Create (
                pcdfd, 
                NULL == pFileName ? pFileName : pDocFileName);
        DH_HRCHECK(hr, TEXT("pChanceDF->Create")) ;
    }

    // Make VirtualDF
    if (S_OK == hr)
    {
        hr = MakeVirtualDF (g_uOpenCreateDF,  //Global set in ProcessCmdLine()
                    pChanceDF,
                    ppvcnRoot,
                    ppTestVirtualDF);
    }

    // cleanup 
    if (NULL != pDocFileName)
    {
        delete []pDocFileName;
    }

    // If the caller wants ChanceDF give it to them, otherwise delete it
    if (NULL == ppTestChanceDF)
    {
        delete pChanceDF;
    }
    else
    {
        *ppTestChanceDF = pChanceDF;
    }

    return hr;
}

//----------------------------------------------------------------------------
//    FUNCTION: MakeVirtualDF
//
//    PARAMS:   uOp             - Create|Open flag (FL_DISTRIB_xxx)
//              pTestChanceDF   - ptr to pChanceDF  
//              ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//
//    SYNOPSIS: This function should be called by
//              CreateTestDocfile
//              If FL_OPEN is set, and cannot open docfile, 
//              return ERROR.
//              Otherwise we need to create a storage file
//              as we are either as 1st phase, or single phase.
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
// BUGBUG: GenerateVirtualDFFromDiskDF does not fill in the CRC for vsn.
//         we need to write a rtn that will do this for enumtest 100.
//----------------------------------------------------------------------------
HRESULT MakeVirtualDF (
        UINT uOp,
        ChanceDF         *pTestChanceDF,
        VirtualCtrNode  **ppvcnRoot,
        VirtualDF       **ppTestVirtualDF)
{
    HRESULT   hr                = S_OK;

    // This is internal func. Shouldnt have to do this.
    DH_ASSERT (NULL != pTestChanceDF); 
    DH_ASSERT (NULL != ppvcnRoot); 
    DH_ASSERT (NULL != ppTestVirtualDF); 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("MakeVirtualDF"));

    //for stress debug purposes. So we can get to the seed.
    //do not use gulSeed for anything!
    gulSeed = pTestChanceDF->GetSeed ();

    // If its OPEN, try to open existing.
    if (FL_DISTRIB_OPEN == uOp)
    {
        ULONG      ulSeed         = 0;
        DG_STRING *pgdu           = NULL;
        LPTSTR     tszDocfileName = NULL;

        // Get the seed. We need this to generate the filename.
        ulSeed = pTestChanceDF->GetSeed();
 
        // Create a new DataGen object to create the filename
        pgdu = new DG_STRING(ulSeed);
        if (NULL == pgdu)
        {
            hr = E_OUTOFMEMORY;
        }

        // if filename was specified, get it from chanceDF
        if (hr == S_OK)
        {
            tszDocfileName = pTestChanceDF->GetDocFileName();
            if (NULL != tszDocfileName)
            {
                LPTSTR pTmpName = tszDocfileName;
                tszDocfileName = new TCHAR[_tcslen (pTmpName)+1];
                if (NULL == tszDocfileName)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _tcscpy(tszDocfileName, pTmpName);
                }
            }
            else
            {
                // this will generate the name of the file that was created
                hr = GenerateRandomName (pgdu, MINLENGTH, MAXLENGTH, &tszDocfileName);
                DH_HRCHECK (hr, TEXT("GenerateRandomName"));
            }
        }

        if (S_OK == hr)
        {
            *ppTestVirtualDF = new VirtualDF();
            if (NULL == *ppTestVirtualDF)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == S_OK)
        {
            // Remove create bit - open does not like it.
            hr = GenerateVirtualDFFromDiskDF(
                    *ppTestVirtualDF,
                    tszDocfileName,
                    pTestChanceDF->GetRootMode() & ~STGM_CREATE,
                    ppvcnRoot,
                    ulSeed);
            DH_HRCHECK (hr, TEXT("GenerateVirtualDFFromDiskDF"));
        }

        // make sure ALL sub stg/stm are open and have valid _pstg
        if (hr == S_OK)
        {
            hr = ParseVirtualDFAndOpenAllSubStgsStms (
                    *ppvcnRoot,
                    pTestChanceDF->GetStgMode (),
                    pTestChanceDF->GetStmMode ());
            DH_HRCHECK (hr, TEXT("ParseVirtualDFAndOpenAllSubStgsStms"));
        }

        if (NULL != tszDocfileName)
        {
            delete tszDocfileName;
        }

        if (NULL != pgdu)
        {
            delete pgdu;
        }
    }
    // else !open, so create one.
    else
    {
        // Create the VirtualDocFile tree from the ChanceDocFile tree created in
        // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
        // and VirtualStmNodes.
        if (S_OK == hr)
        {
            *ppTestVirtualDF = new VirtualDF(); 
            if (NULL == *ppTestVirtualDF)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            hr = (*ppTestVirtualDF)->GenerateVirtualDF (pTestChanceDF, ppvcnRoot);
            DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
        }

        // Commit all stms and stgs in newly created storage file
        if (S_OK == hr)
        {
            hr = ParseVirtualDFAndCommitAllOpenStgs (*ppvcnRoot, STGC_DEFAULT, NODE_INC_TOPSTG);
            DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
        }

        // If we are testing conversion, close and reopen the file.
        // BUGBUG: If we are distributed and happen to have the 
        //  cmdline for conversion, you will do an extra open and
        //  close. DIF files may get an unacceptible time penalty.
        if (DoingConversion())
        {
            // close the file
            if (S_OK == hr)
            {
                hr = ParseVirtualDFAndCloseOpenStgsStms (*ppvcnRoot, NODE_INC_TOPSTG);
                DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
            }
            // just for fun, verify that we indeed have an nssfile
            // Assume there is a file name, else we failed somewhere
            // creating it and hr should != S_OK
            if (S_OK == hr)
            {
                hr = VerifyNssfile ((*ppTestVirtualDF)->GetDocFileName());
                DH_HRCHECK(hr, TEXT("VerifyNssfile")) ;
            }
            // open root storage
            if (S_OK == hr)
            {
                // if in SIMPLEMODE, get rid of Create.
                ULONG mode = pTestChanceDF->GetRootMode ();
                if (mode & STGM_SIMPLE)
                {
                    mode &= ~STGM_CREATE;
                }

                hr = (*ppvcnRoot)->OpenRoot (NULL,
                        mode,
                        NULL,
                        0);
                DH_HRCHECK(hr, TEXT("StgOpenStorage"));
            }
            // open up the rest of storages and streams
            if (S_OK == hr)
            {
                hr = ParseVirtualDFAndOpenAllSubStgsStms (*ppvcnRoot, 
                        pTestChanceDF->GetStgMode (),
                        pTestChanceDF->GetStmMode ());
                DH_HRCHECK(hr, TEXT("ParseVirtualDFAndOpenAllSubStgsStms")) ;
            }
            DH_TRACE ((DH_LVL_TRACE2, TEXT("Docfile closed and reopened for conversion")));
        }
    }
    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CleanupTestDocfile 
//
//    PARAMS:   ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//              ppTestChanceDF  - bucket for pChanceDF  
//              fDeleteFile     - If was an error, dont delete docfile
//
//    SYNOPSIS: Cleanup all items that were setup in CreateTestDocfile
//               - chancedf
//               - virtualdf
//               - delete docfile on disk (if there were no errors)
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CleanupTestDocfile (
        VirtualCtrNode **ppVirtualDFRoot,
        VirtualDF      **ppTestVirtualDF,
        ChanceDF       **ppTestChanceDF,
        BOOL             fDeleteFile)
{                       
    LPTSTR          pFileName   =  NULL;
    HRESULT         hr          =  S_OK;
    VirtualCtrNode *pvcnRootNode= *ppVirtualDFRoot;
    VirtualDF      *pVirtualDF  = *ppTestVirtualDF;
    ChanceDF       *pChanceDF   = *ppTestChanceDF;

    DH_FUNCENTRY (NULL, DH_LVL_DFLIB, TEXT("CleanupTestDocfile"));

    // Make sure everything in the docfile is closed
    if (NULL != pvcnRootNode)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms (pvcnRootNode, NODE_INC_TOPSTG);
        DH_HRCHECK (hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get file name
    if (TRUE == fDeleteFile && DeleteTestDF ())
    {
        if (NULL != pvcnRootNode)
        {
            pFileName= new TCHAR[_tcslen (pVirtualDF->GetDocFileName ())+1];
            if (pFileName != NULL)
            {
                _tcscpy (pFileName, pVirtualDF->GetDocFileName ());
            }
        }
    }

    // Delete Virtual docfile tree
    if (NULL != pVirtualDF)
    {
        hr = pVirtualDF->DeleteVirtualDocFileTree (pvcnRootNode);
        DH_HRCHECK (hr, TEXT("pVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pVirtualDF;
        pVirtualDF = NULL;
    }

    // Delete Chance docfile tree
    if (NULL != pChanceDF)
    {
        hr = pChanceDF->DeleteChanceDocFileTree (pChanceDF->GetChanceDFRoot());
        DH_HRCHECK (hr, TEXT("pChanceDF->DeleteChanceFileDocTree")) ;

        delete pChanceDF;
        pChanceDF = NULL;
    }

    // Delete the docfile on disk
    if ((S_OK == hr) && (NULL != pFileName))
    { 
        if (FALSE == DeleteFile(pFileName))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError()) ;
            DH_HRCHECK (hr, TEXT("DeleteFile")) ;
        }
    }

    // Delete the docfile name
    if (NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\comtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       comtests.cxx
//
//  Contents:   storage base tests common to IStorage and IStream methoods
//
//  Functions:  
//
//  History:    29-May-1996     NarindK     Created.
//              27-Mar-97       SCousens    Conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    COMTEST_100 
//
// Synopsis:Create a root docfile with a child IStorage and a child IStream.
//          Commit the root docfile.
//
//          Add a random number of refcounts to IStorage via AddRef() method.
//          loop to release the refs, each release is followed by a Stat.  After
//          the last ref (that we added) is released, release the ref created
//          during the Create... call.  This frees the real object.  Repeat for
//          the child IStream.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: ADDREF.CXX
// 2.  Old name of test : MiscAddRef 
//     New Name of test : COMTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-100
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_100
//
//-----------------------------------------------------------------------------


HRESULT COMTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    ULONG           cb                      = 0;
    ULONG           cusIStorageRefs         = 0;
    ULONG           cusIStreamRefs          = 0;
    ULONG           i                       = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    ULONG           cRandomMinVar           = 2;
    ULONG           cRandomMaxVar           = 16;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("AddRef/Release tests on IStorage/IStream")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_UNICODE object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the root storage.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

   
// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // add from 2 to 16 ref counts to child IStorage object and then
    // release each one followed by a Stat() call.  The ref count should
    // be decremented after each release.  There will already be one
    // ref count from the IStorage create call, so all Stat() calls in
    // the loop should be on a valid object.  Finally, release remaining
    // IStorage (this is the ref from the creation)
    
    if (S_OK == hr)
    {
        // Generate random number for ref counts to be done.

        usErr = pdgi->Generate(&cusIStorageRefs, cRandomMinVar, cRandomMaxVar);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    for (i=0; i < cusIStorageRefs; i++)
    {
        // AddRef the storage

        hr = pvcnRootNewChildStorage->AddRefCount();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddRefCount completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::AddRefCount unsuccessful, hr = 0x%lx."),
                hr));

            break;
        }
    }

    while ((cusIStorageRefs--) && (S_OK == hr))
    {
        // Close the storage

        hr = pvcnRootNewChildStorage->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            // Stat the storage

            hr = pvcnRootNewChildStorage->Stat(&statStg, STATFLAG_NONAME);

            if (S_OK == hr)
            {
                DH_TRACE((
                 DH_LVL_TRACE1,
                 TEXT("VirtualCtrNode::Stat completed successfully.")));
            }
            else 
            {
                DH_TRACE((
                 DH_LVL_ERROR,
                 TEXT("VirtualCtrNode::Stat unsuccessful, hr = 0x%lx."),
                 hr));
            }
        }

    }

    // Close the root storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------
    // add from 2 to 16 ref counts to child IStream object and then
    // release each one followed by a Stat() call.  The ref count should
    // be decremented after each release.  There will already be one
    // ref count from the IStream create call, so all Stat() calls in
    // the loop should be on a valid object.  Finally, release remaining
    // IStream (this is the ref from the creation)
    
    if (S_OK == hr)
    {
        // Generate random number for ref counts to be done.

        usErr = pdgi->Generate(&cusIStreamRefs, cRandomMinVar, cRandomMaxVar);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    for (i=0; i < cusIStreamRefs; i++)
    {
        // Addref the stream 

        hr = pvsnRootNewChildStream->AddRefCount();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddRefCount completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::AddRefCount unsuccessful, hr = 0x%lx."),
                hr));

            break;
        }
    }

    while ((cusIStreamRefs--) && (S_OK == hr))
    {
        // Clsoe the stream

        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            // Stat the stream

            hr = pvsnRootNewChildStream->Stat(&statStg, STATFLAG_NONAME);

            if (S_OK == hr)
            {
                DH_TRACE((
                 DH_LVL_TRACE1,
                 TEXT("VirtualStmNode::Stat completed successfully.")));
            }
            else 
            {
                DH_TRACE((
                 DH_LVL_ERROR,
                 TEXT("VirtualStmNode::Stat unsuccessful, hr = 0x%lx."),
                 hr));
            }
        }

    }

    // Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_100 failed, hr = 0x%lx."), 
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST_101 
//
// Synopsis: Regression test for root docfile creation, IStorage creation,
//           embedded stream creation/read/write, and IStorage commit 
//           operations.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: DFTEST.CXX
// 2.  Old name of test :
//     New Name of test : COMTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-101
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_101
//
//-----------------------------------------------------------------------------


HRESULT COMTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;    
    LPTSTR          pwcsBuffer              = NULL;    
    LPTSTR          pReadBuffer              = NULL;    
    ULONG           cb                      = 0;
    ULONG           culWritten              = 0;
    ULONG           culRead                 = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("Regression test for Docfile/IStorage/IStream creation.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("IStream Read/Write, IStorage Commit opertaions.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr ));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Generate a random name for child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    //  Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &pwcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                pwcsBuffer,
                cb,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr = 0x%lx."),
            hr));
    }

    // Close the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Close the IStorage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Commit the DocFile

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Close the Root DocFile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Open the Root DocFile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                STGM_READWRITE  | STGM_SHARE_EXCLUSIVE,
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Open the embedded IStorage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Open the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Read the IStream.

    if (S_OK == hr)
    {
        pReadBuffer = new TCHAR [cb];

        if(NULL == pReadBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        memset(pReadBuffer, '\0', cb);
    
        hr =  pvsnRootNewChildStream->Read(
                pReadBuffer,
                cb,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Read function wasn't successful, hr = 0x%lx."),
            hr));
    }

    // Close the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Close the IStorage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful.")));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Close the Root DocFile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != pwcsBuffer)
    {
        delete []pwcsBuffer;
        pwcsBuffer = NULL;
    }

    if(NULL != pReadBuffer)
    {
        delete []pReadBuffer;
        pReadBuffer = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:     COMTEST_102 
//
// Synopsis: Create a root docfile with random name. Create a child IStorage 
//           and a child IStream in this docfile.  Attempt to do iilegal op
//           erations on this docfile - creating/instantiating storages/streams
//           /root docfiles with existing names with STGM_FAILIFTHERE flag. Also
//           attempts various illegal grfmodes.    
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: IINORM.CXX
// 2.  Old name of test : IllegitInstEnumNormal Test
//     New Name of test : COMTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-102
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_102
//
//  BUGBUG: Use Random Commit modes
//-----------------------------------------------------------------------------


HRESULT COMTEST_102(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    DG_STRING       *pdgu                       = NULL;
    USHORT          usErr                       = 0;
    VirtualStmNode  *pvsnRootNewChildStream     = NULL;
    LPTSTR          pRootNewChildStmName        = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage    = NULL;
    LPTSTR          pRootNewChildStgName        = NULL;    
    ULONG           cb                          = 0;
    VirtualCtrNode  *pvcnRootSecondChildStorage = NULL;
    VirtualCtrNode  *pvcnRootThirdChildStorage  = NULL;
    VirtualStmNode  *pvcnRootSecondChildStream  = NULL;
    VirtualStmNode  *pvcnRootThirdChildStream   = NULL;
    LPSTORAGE       pRootStg                    = NULL;
    LPSTORAGE       pNonExistingStg             = NULL;
    LPSTREAM        pNonExistingStm             = NULL;
    ULONG           cRandomMinSize              = 10;
    ULONG           cRandomMaxSize              = 100;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("Illegal operations on Docfile/IStorage/IStream.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("Instantiating with existing names, invalid grfmodes.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT(NULL != pdgi);
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the Storage 

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Close the IStorage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Generate a random name for child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    //  Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Close the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Commit the Root DocFile 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Attempt to create another Child IStorage with same name as existing
    // IStorage above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStorage);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Attempt to create another Child IStorage with same name as existing
    // IStream above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                pTestChanceDF->GetStgMode()|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStorage);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Attempt to create another Child IStorage with same name as existing
    // IStorage above and STGM_CREATE flag.

    if(S_OK == hr)
    {
        // This call should pass.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE,
                &pvcnRootSecondChildStorage);

        if(S_OK == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));
        }
    }

    // Commit the above Storage 

    if(S_OK == hr)
    {
        hr = pvcnRootSecondChildStorage->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
                hr));
        }
    }

    // Now with the above IStorage created and instantiated, attempt to create 
    // another Child IStorage with same name as above which is both existing
    // and instantiated.  Should give STG_E_ACCESSDENIED error. 

    if(S_OK == hr)
    {
        // This call should give STG_E_ACCESSDENIED error.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_FAILIFTHERE,
                &pvcnRootThirdChildStorage);

        if(STG_E_ACCESSDENIED == hr) 
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Close the pvcnRootSecondChildStorage which is instantiated.

    if (S_OK == hr)
    {
        hr = pvcnRootSecondChildStorage->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Repeat the above with streams

    // Attempt to create another Child IStream with same name as existing
    // IStream above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStream);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Attempt to create another Child IStorage with same name as existing
    // IStream above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStream);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Attempt to create another Child IStorage with same name as existing
    // IStorage above and STGM_CREATE flag.

    if(S_OK == hr)
    {
        // This call should pass.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_CREATE,
                &pvcnRootSecondChildStream);

        if(S_OK == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));
        }
    }

    // Now with the above IStream created and instantiated, attempt to create 
    // another Child IStream with same name as above which is both existing
    // and instantiated.  Should give STG_E_ACCESSDENIED error. 

    if(S_OK == hr)
    {
        // This call should give STG_E_ACCESSDENIED error.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvcnRootThirdChildStream);

        if(STG_E_ACCESSDENIED == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Close the pvcnRootSecondChildStream which is instantiated.

    if (S_OK == hr)
    {
        hr = pvcnRootSecondChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    // Attempt to open a non existing IStorage/IStreams

    // Close the Root DocFile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    // Open the Root DocFile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                pTestChanceDF->GetRootMode(),
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Open unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    if (S_OK == hr)
    {
        pRootStg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pRootStg);
    }

    // Attempt to open a non existing IStorage.  This should give an error
    // STG_E_FILENOTFOUND

    if (S_OK == hr)
    {
        hr = pRootStg->OpenStorage(
                    OLESTR("Non-Existing"),
                    NULL,
                    pTestChanceDF->GetStgMode(),
                    NULL,
                    0,
                    &pNonExistingStg);

// ----------- flatfile change ---------------
        if(!StorageIsFlat())
        {
// ----------- flatfile change ---------------
        if(STG_E_FILENOTFOUND == hr) 
        {
            DH_TRACE(( DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
// ----------- flatfile change ---------------
        }
        else
        {
            if(E_NOTIMPL == hr)
            {
                DH_TRACE(( DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

                hr  = S_OK;
            }
            else
            {
                DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

                if(S_OK == hr)
                {
                    hr = S_FALSE;
                }
            }
        }
// ----------- flatfile change ---------------
    }

    // Attempt to open a non existing IStream.  This should give an error
    // STG_E_FILENOTFOUND

    if (S_OK == hr)
    {
        hr = pRootStg->OpenStream(
                    OLESTR("Non-Existing"),
                    NULL,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    0,
                    &pNonExistingStm);

        if(STG_E_FILENOTFOUND == hr) 
        {
            DH_TRACE(( DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Close the Root DocFile Storage

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_102 failed, hr =0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:     COMTEST_103 
//
// Synopsis: Creates an IStream in the root docfile and writes a random number
//       of bytes then releases the IStream.  Creates an IStorage in the root
//       docfile and an IStream inside of the IStorage.  A random number of
//       bytes are written to the IStream, the IStream is released, and the
//       IStorage and root docfile are committed.  The IStream in the IStorage
//       is instantiated and the data is read and verified.  The IStorage and
//       contained IStream are released.  The IStream in the root docfile is
//       instantiated and the data is read and verified.  The IStream and
//       root docfile are then released.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: LINORM.CXX
// 2.  Old name of test : LegitInstEnumNormal Test
//     New Name of test : COMTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-103
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_103
//
//  BUGBUG: Use Random Commit modes
//-----------------------------------------------------------------------------

HRESULT COMTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pNewRootStmName         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualStmNode  *pvsnNewChildStream     = NULL;
    LPTSTR          pNewChildStmName        = NULL;
    LPTSTR          pwcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           cb                      = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    BOOL            fPass                   = TRUE;
    DWCRCSTM        dwCRC1;
    DWCRCSTM        dwMemCRC1;
    DWCRCSTM        dwCRC2;
    DWCRCSTM        dwMemCRC2;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("LINORM_1"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_103 started.")) );

    // Initialize CRC values to zero

    dwCRC1.dwCRCSum=dwCRC2.dwCRCSum=dwMemCRC1.dwCRCSum=dwMemCRC2.dwCRCSum=0;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_103, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    //    Adds a new stream to a root storage.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Generate a random name for Root's child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pNewRootStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pNewRootStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &pwcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }
    
    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                pwcsBuffer,
                cb, 
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr =0x%lx."),
            hr));
    }


    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                pwcsBuffer,
                cb,
                &dwMemCRC1);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    if(NULL != pwcsBuffer)
    {
        delete pwcsBuffer;
        pwcsBuffer = NULL;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Generate a random name for Root's child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode() |
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr =0x%lx."),
            hr));
    }


    // Adds a new stream to the new storage.  We would add a stream to
    // newly created substorage "NewTestStg" of our root storage for test.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Generate a random name for Root's child IStorage's new child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStorage,
                pNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr =0x%lx."),
            hr));
    }


    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &pwcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    // Write into new stream

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStream->Write(
                pwcsBuffer, 
                cb, 
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr =0x%lx."),
            hr));
    }

    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnNewChildStream,
                pwcsBuffer,
                cb,
                &dwMemCRC2);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }


    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Open(
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Open unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Open unsuccessful, hr =0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnNewChildStream,&dwCRC2);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

        if(dwCRC2.dwCRCSum == dwMemCRC2.dwCRCSum)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's for pvsnNewChildStream match.")));

        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("CRC's for pvsnNewChildStream don't match.")));

            fPass = FALSE;
        }
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadAndCalculateDiskCRCForStm unsuccessful, hr =0x%lx."),
            hr));
    }

    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    //   Close the storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Open unsuccessful, hr =0x%lx."),
            hr));
    }

    // Read and verify
    
    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnRootNewChildStream,&dwCRC1);
    }

    // Compare this CRC with in memory CRC

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

        if(dwCRC1.dwCRCSum == dwMemCRC1.dwCRCSum)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for pvsnRootNewChildStream match.")));

        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("CRC's for pvsnRootNewChildStream do not match.")));
        }
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadAndCalculateDiskCRCForStm unsuccessful, hr =0x%lx."),
            hr));
    }
 
    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    //   Close the storage

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    // if all goes well till here, the test variation has passed successfully,
    // if not, then report failure.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_103 failed, hr =0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    //Free buffer

    if(NULL != pwcsBuffer)
    {
        delete pwcsBuffer;
        pwcsBuffer = NULL;
    }

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pNewRootStmName)
    {
        delete pNewRootStmName;
        pNewRootStmName = NULL;
    }

    if(NULL != pNewChildStmName)
    {
        delete pNewChildStmName;
        pNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST-103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST_104 
//
// Synopsis:Create a root docfile with a child IStorage and a child IStream.
//          Commit the root docfile.
//
//          Call QueryInterface on IID_IStorage created for IStorage and see if
//          succeeded to verify OLE COM Reflexive behaviour.  Then through
//          the interface obtained, query for IID_Imarshal from which query
//          for IUnknown and from that query for IID_IStorage.  This should 
//          pass verifying the Transitive behaiour of IStorage COM interface.  
//          Repeat for the child IStream.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    8-Aug-1996     NarindK     Created.
//
//  Notes:   This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: STORAGE.CXX very briefly 
// 2.  Old name of test : ISTORAGE_TEST very briefly 
//     New Name of test : COMTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_104 NO. BUGBUG:IRootStg not supported by NSS yet. maybe later?
//
//-----------------------------------------------------------------------------


HRESULT COMTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    ULONG           cb                      = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    ULONG           ulRef                   = 0;
    LPSTORAGE       pQueryChildStorage      = NULL;
    LPSTORAGE       pQueryMarshalStorage    = NULL;
    LPSTORAGE       pQueryUnknownStorage    = NULL;
    LPSTORAGE       pQueryRetChildStorage   = NULL;
    LPSTREAM        pQueryChildStream       = NULL;
    LPSTREAM        pQueryRetChildStream    = NULL;
    LPSTREAM        pQueryMarshalStream     = NULL;
    LPSTREAM        pQueryUnknownStream     = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("QueryInterface tests on IStorage/IStream")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_104, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the root storage.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Check Reflexive/Transitive behaviour for IStorage Interface

    // Do QueryInterface on child storage

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->QueryInterface(
                IID_IStorage,
                (LPVOID *) &pQueryChildStorage);     

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;
    }
   
    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryChildStorage);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Query for IRootStorage from the above returned storage pointer, then
    // query through IRootStorage for IID_IUnknown.  From IUnknown, query for
    // IID_IStorage

    if(S_OK == hr) 
    {
        hr = pQueryChildStorage->QueryInterface( 
                IID_IMarshal,
                (LPVOID *) &pQueryMarshalStorage );
    }

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryMarshalStorage);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStorage::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Use the IMarshal interface to QueryInterface an IUnknown
    // interface.

    if(S_OK == hr)
    {
        hr = pQueryMarshalStorage->QueryInterface( 
                IID_IUnknown,
                (LPVOID *) &pQueryUnknownStorage );
    }

    // Use the IUnknown interface to QueryInterface an IStorage interface.

    if(S_OK == hr) 
    {
        DH_ASSERT(NULL != pQueryUnknownStorage);

        hr = pQueryUnknownStorage->QueryInterface(     
                IID_IStorage,
                (LPVOID *) &pQueryRetChildStorage );
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage:Reflexive/Transitive OLE COM behaviour passed.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStorage:Reflexive/Transitive COM behaviour fail,hr=0x%lx"),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Check Reflexive/Transitive behaviour for IStream Interface

    // Do QueryInterface on child stream

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStream->QueryInterface(
                IID_IStream,
                (LPVOID *) &pQueryChildStream);     

        DH_HRCHECK(hr, TEXT("VirtualStmNode::QueryInterface")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Query for IMarshal from the above returned storage pointer, then
    // query through IRootStream for IID_IUnknown.  From IUnknown, query for
    // IID_IStream
// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------

    if(S_OK == hr) 
    {
        hr = pQueryChildStream->QueryInterface( 
                IID_IMarshal,
                (LPVOID *) &pQueryMarshalStream );
    }

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryMarshalStream);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
    else
    if(S_OK == hr) 
    {
        hr = pQueryChildStream->QueryInterface( 
                IID_IStream,
                (LPVOID *) &pQueryMarshalStream );
    }

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryMarshalStream);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }
// --------- flatfile change ---------------

    // Use the IRootStream interface to QueryInterface an IUnknown
    // interface.

    if(S_OK == hr)
    {
        hr = pQueryMarshalStream->QueryInterface( 
                IID_IUnknown,
                (LPVOID *) &pQueryUnknownStream );
    }

    // Use the IUnknown interface to QueryInterface an IStream interface.

    if(S_OK == hr) 
    {
        DH_ASSERT(NULL != pQueryUnknownStream);

        hr = pQueryUnknownStream->QueryInterface(     
                IID_IStream,
                (LPVOID *) &pQueryRetChildStream );
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream:Reflexive/Transitive OLE COM behaviour passed.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream:Reflexive/Transitive COM behaviour fail, hr=0x%lx"),
            hr));
    }

    // Clean up

    if(NULL != pQueryChildStorage)
    {
        ulRef = pQueryChildStorage->Release();
        DH_ASSERT(4 == ulRef);
        pQueryChildStorage = NULL;
    }

    if(NULL != pQueryMarshalStorage)
    {
        ulRef = pQueryMarshalStorage->Release();
        DH_ASSERT(3 == ulRef);
        pQueryMarshalStorage = NULL;
    }

    if(NULL != pQueryUnknownStorage)
    {
        ulRef = pQueryUnknownStorage->Release();
        DH_ASSERT(2 == ulRef);
        pQueryUnknownStorage = NULL;
    }

    if(NULL != pQueryRetChildStorage)
    {
        ulRef = pQueryRetChildStorage->Release();
        DH_ASSERT(1 == ulRef);
        pQueryRetChildStorage = NULL;
    }

    if(NULL != pQueryChildStream)
    {
        ulRef = pQueryChildStream->Release();
        DH_ASSERT(4 == ulRef);
        pQueryChildStream = NULL;
    }

    if(NULL != pQueryMarshalStream)
    {
        ulRef = pQueryMarshalStream->Release();
        DH_ASSERT(3 == ulRef);
        pQueryMarshalStream = NULL;
    }

    if(NULL != pQueryUnknownStream)
    {
        ulRef = pQueryUnknownStream->Release();
        DH_ASSERT(2 == ulRef);
        pQueryUnknownStream = NULL;
    }

    if(NULL != pQueryRetChildStream)
    {
        ulRef = pQueryRetChildStream->Release();
        DH_ASSERT(1 == ulRef);
        pQueryRetChildStream = NULL;
    }

// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    // Close the child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------

    // Close the child stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Close the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_104 failed, hr = 0x%lx."), 
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST-105
//
// Synopsis: A root docfile with a child storage and a child stream is created,
//           then check if Read/WriteClassStg and Read/WriteClassStm APIs work
//           correctly as expected. Also have some illegitmate tests by passing
//           invalid arguments to these APIs.           
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:  15-Aug-1996     JiminLi     Created.
//
// To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-105
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_105
//
//-----------------------------------------------------------------------------

HRESULT COMTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualStmNode  *pvsnRootNewChildStm    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pChildStg               = NULL;
    LPSTREAM        pChildStm               = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszStreamName          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           culWritten              = 0;
    ULONG           ulPosition              = 0;
    STATSTG         statStg;
    STATSTG         statStm;
    LARGE_INTEGER   liZero;
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uli;

    GUID TEST_CLSID = { 0x9c6e9ed0,
                        0xf701,
                        0x11cf,
                        {   0x98,
                            0x44,
                            0x00,
                            0xa0,
                            0xc9,
                            0x08,
                            0xe4,
                            0x6d }};
    CLSID           pclsid;


    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_105 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit and illegit tests on Read/WriteClassStg/Stm ")));

    pclsid = TEST_CLSID;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        pRootStg = pVirtualDFRoot->GetIStoragePointer();

        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        pChildStg = pvcnRootNewChildStg->GetIStoragePointer();

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("AddStorage not successful, hr=0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------

    // Add a child stream under root storage

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                ptszStreamName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStm);
        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr && NULL != pvsnRootNewChildStm)
    {
        pChildStm = pvsnRootNewChildStm->GetIStreamPointer();
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Write a random stream to the stream, in order to test 
    // ReadClassStm later.

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Write(
                ptszStreamName, 
                _tcslen(ptszStreamName), 
                &culWritten);

        DH_HRCHECK(hr, TEXT("IStream::Write")) ;
    }

    // Legit tests of Read/WriteClassStg on the root storage

    // First call Stat on root storage and check the CLSID of it.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Root DocFile has CLSID_NULL as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Root DocFile doesn't have CLSID_NULL unexpectedly.")));
    
        fPass = FALSE;
    }

    // Then call ReadClassStg to see if this API work correctly

    if (S_OK == hr)
    {
        hr = ReadClassStg(pRootStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, CLSID_NULL)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns CLSID_NULL as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return CLSID_NULL as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    // Now write the new CLSID into the root storage object

    if (S_OK == hr)
    {
        hr = WriteClassStg(pRootStg, TEST_CLSID);

        DH_HRCHECK(hr, TEXT("WriteClassStg"));
    }

    // Call Stat again to check if the above WriteClassStg and the next
    // ReadClassStg work correctly

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, TEST_CLSID)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Root DocFile has TEST_CLSID as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Root DocFile doesn't have TEST_CLSID unexpectedly.")));
    
        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStg(pRootStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, TEST_CLSID)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns TEST_CLSID as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return TEST_CLSID as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
 
// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    // Legit tests of Set/GetConvertStg on the child storage

    // First call Stat on root storage and check the CLSID of it.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Storage has CLSID_NULL as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Storage doesn't have CLSID_NULL unexpectedly.")));
    
        fPass = FALSE;
    }

    // Then call ReadClassStg to see if this API work correctly

    if (S_OK == hr)
    {
        hr = ReadClassStg(pChildStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, CLSID_NULL)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns CLSID_NULL as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return CLSID_NULL as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    // Now write the new CLSID into the child storage object

    if (S_OK == hr)
    {
        hr = WriteClassStg(pChildStg, TEST_CLSID);

        DH_HRCHECK(hr, TEXT("WriteClassStg"));
    }

    // Call Stat again to check if the above WriteClassStg and the next
    // ReadClassStg work correctly

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, TEST_CLSID)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Storage has TEST_CLSID as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Storage doesn't have TEST_CLSID unexpectedly.")));
    
        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStg(pChildStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, TEST_CLSID)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns TEST_CLSID as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return TEST_CLSID as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------
 
    // Illegit tests

    // Pass NULL as IStorage pointer, it should fail

#ifdef _MAC

        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("!!!!!!!!!!!!!!!!Invalid param testing skipped"),
            hr));

#else 
    
    if (S_OK == hr)
    {
        hr = WriteClassStg(NULL, TEST_CLSID);
    }

    if (E_INVALIDARG == hr)
    {       
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("WriteClassStg did not return as expected, hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStg(NULL, &pclsid);

    }

    if (E_INVALIDARG == hr)
    {
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadClassStg did not return as expected, hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
 
#endif //_MAC

    // Legit tests of Set/GetConvertStg on the child stream

    // First call Stat on child stream and check the CLSID of it.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Stat(&statStm, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualStmNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStm.clsid, CLSID_NULL)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Stream has CLSID_NULL as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Stream doesn't have CLSID_NULL unexpectedly.")));
    
        fPass = FALSE;
    }

    // Then call ReadClassStm to see if this API work correctly
    // Since ReadClassStm can only read the CLSID written previously by
    // WriteClassStm, it'll return STG_E_READFAULT in this case.

    if (S_OK == hr)
    {
        hr = ReadClassStm(pChildStm, &pclsid);
    }

    if (STG_E_READFAULT == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStm returns STG_E_READFAULT as expected.")));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("Err: ReadClassStm not return STG_E_READFAULT. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    // Get the seek pointer before writing, then retore to this offset
    // when we want to ReadClassStm later.

    if (S_OK == hr)
    {
        LISet32(liZero, 0L);
        hr = pChildStm->Seek(liZero, STREAM_SEEK_CUR, &uli);

        ulPosition = ULIGetLow(uli);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    // Now write a new CLSID into stream

    if (S_OK == hr)
    {
        hr = WriteClassStm(pChildStm, TEST_CLSID);

        DH_HRCHECK(hr, TEXT("WriteClassStm"));
    }

    // Call Stat again to check if the above WriteClassStm and the next
    // ReadClassStm work correctly

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Stat(&statStm, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualStmNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, TEST_CLSID)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Stream has TEST_CLSID as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Stream doesn't have TEST_CLSID unexpectedly.")));
    
        fPass = FALSE;
    }

    // Since ReadClassStm calls pstm->ReadAt(...) but not get CLSID from
    // pstm->Stat, basically it needs correct seek pointer, we need get it.
    
    if (S_OK == hr)
    {
        LISet32(liStreamPos, ulPosition);
        hr = pChildStm->Seek(liStreamPos, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    if (S_OK == hr)
    {
        hr = ReadClassStm(pChildStm, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, TEST_CLSID)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStm returns TEST_CLSID as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStm not return TEST_CLSID as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
 
    // Illegit tests

    // Pass NULL as IStream pointer, it should fail

#ifdef _MAC

        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("!!!!!!!!!!!!!!!!Invalid param testing skipped"),
            hr));

#else 
  
    if (S_OK == hr)
    {
        hr = WriteClassStm(NULL, TEST_CLSID);
    }

    if (E_INVALIDARG == hr)
    {       
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("WriteClassStm did not return as expected, hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStm(NULL, &pclsid);
    }

    if (E_INVALIDARG == hr)
    {
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadClassStm did not return as expected, hr = 0x%lx"),
            hr));

        fPass = FALSE;
    }

#endif //_MAC
    
    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the child stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Close();
        
        DH_HRCHECK(hr, TEXT("VirutalStmNode::Close"));
    }


// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    // Release child and root storages

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_105 passed.")) );
    }
    else if (4 == NTMAJVER()) //No fix bug in NT4.
    {
        DH_LOG((LOG_FAIL, TEXT("COMTEST_105 failed on NT4. Bug#54738")));
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_105 failed, hr = 0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pRootNewChildStgName)
    {
        delete []pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if (NULL != ptszStreamName)
    {
        delete []ptszStreamName;
        ptszStreamName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST-106
//
// Synopsis: Create a root docfile with a child storage and an IStream inside
//           of the child IStorage. Random data is written to the IStream and
//           the CRC is computed for the data. Then commit the child storage, 
//           verify the CRC of data, if it is correct, then commit the root 
//           storage, and again verify the CRC of data. First round passed in
//           STGC_DEFAULT, then change the IStream data, then repeat the above
//           commit process by passed in STGC_OVERWRITE. Finally, change the 
//           IStream data again, repeat the process for commit by passed in 
//           STGC_DANGEROUSLYCIMMITMERELYTODISKCACHE. 
//           
//           Since transacted tests contain more detail tests about Commit,
//           here just keep it simple in base tests. Also, STGC_ONLYIFCURRENT
//           is not test because it should be used in multiple users 
//           environment.
//
//           Only IStorage::Commit is tested, because IStream::Commit has no 
//           effect other than flushing internal memory buffers to the parent
//           storage object. It does not matter if commit changes to streams.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:  15-Aug-1996     JiminLi     Created.
//
// To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-106
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-106
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-106
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_106
//
//-----------------------------------------------------------------------------

HRESULT COMTEST_106(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualCtrNode  *pstgCommitMe           = NULL;
    VirtualStmNode  *pvsnNewChildStm        = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszStreamName          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwOriginalCRC           = 0;
    DWORD           dwCommitCRC             = 0;
    BOOL            fRetry                  = TRUE;
    BOOL            fPass                   = TRUE;
    ULONG           culWritten              = 0;
    ULONG           ulPosition              = 0;
    ULONG           culRandIOBytes          = 0;
    ULONG           culRead                 = 0;
    LARGE_INTEGER   liZero;
    ULARGE_INTEGER  uliSize;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_106 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit and illegit tests on IStorage::Commit.")));


    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {


        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("AddStorage not successful, hr=0x%lx."),
            hr));
    }

    // Add a child stream under the child storage

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStg,
                ptszStreamName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnNewChildStm);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Generate a random number culRandIOBytes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culRandIOBytes,
                culRandIOBytes, 
                &ptcsBuffer);
       
        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStm->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if(S_OK != hr) 
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate the CRC for stream data

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culRandIOBytes,
                &dwOriginalCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Test on STGC_DEFAULT

    pstgCommitMe = pvcnRootNewChildStg;

    while ((S_OK == hr) && (fRetry == TRUE))
    {
        hr = pstgCommitMe->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {   
            // verify IStream data after commit()

            // Allocate a buffer of required size
 
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
            
            if (S_OK == hr)
            {
                LISet32(liZero, 0L);
                hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

                DH_HRCHECK(hr, TEXT("IStream::Seek"));
            }

            if (S_OK == hr)
            {
                memset(ptcsBuffer, '\0', culRandIOBytes * sizeof(TCHAR));

                hr = pvsnNewChildStm->Read(
                       ptcsBuffer,
                       culRandIOBytes,
                       &culRead);
            }

            if ((S_OK != hr) || (culRead != culRandIOBytes))
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("IStream::Read not successful, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }

            // Calculate the CRC for stream data

            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        ptcsBuffer,
                        culRandIOBytes,
                        &dwCommitCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
            }

            // Compare corresponding dwMemCRC and dwActCRC and verify

            if (S_OK == hr)
            {
                if (dwOriginalCRC != dwCommitCRC)
                {
                    DH_TRACE((
                        DH_LVL_ERROR,
                        TEXT("CRC's before/after commit unmatch.")));

                    fPass = FALSE;
                }
            }
            
            // Delete temp buffer

            if (NULL != ptcsBuffer)
            {
                delete []ptcsBuffer;
                ptcsBuffer = NULL;
            }

            // if child storage just commited ok, stay in loop and now 
            // commit root, otherwise set flag to terminate loop

            if ((fPass == TRUE) && (pstgCommitMe == pvcnRootNewChildStg))
            {
                pstgCommitMe = pVirtualDFRoot;
            }
            else
            {
                fRetry = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("VirtualCtrNode::Commit failed. hr = 0x%lx"), 
                hr));

            break;
        }
    }

    // Now make some changes on IStream data, re-set the stream size to 
    // a new random size, then seek from beginning and rewrite the stream
    // data of the new size, and CRC it.

    // Generate a random number culRandIOBytes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culRandIOBytes,
                culRandIOBytes, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        ULISet32(uliSize, culRandIOBytes);
        hr = pvsnNewChildStm->SetSize(uliSize);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize"));
    }

    if (S_OK == hr)
    {
        LISet32(liZero, 0L);
        hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStm->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if(S_OK != hr) 
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate the CRC for stream data

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culRandIOBytes,
                &dwOriginalCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Test on STGC_OVERWRITE

    pstgCommitMe = pvcnRootNewChildStg;

    while ((S_OK == hr) && (fRetry == TRUE))
    {
        hr = pstgCommitMe->Commit(STGC_OVERWRITE);

        if (S_OK == hr)
        {   
            // verify IStream data after commit()

            // Allocate a buffer of required size
 
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
            
            if (S_OK == hr)
            {
                LISet32(liZero, 0L);
                hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

                DH_HRCHECK(hr, TEXT("IStream::Seek"));
            }

            if (S_OK == hr)
            {
                memset(ptcsBuffer, '\0', culRandIOBytes * sizeof(TCHAR));

                hr = pvsnNewChildStm->Read(
                       ptcsBuffer,
                       culRandIOBytes,
                       &culRead);
            }

            if ((S_OK != hr) || (culRead != culRandIOBytes))
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("IStream::Read not successful, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }

            // Calculate the CRC for stream data

            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        ptcsBuffer,
                        culRandIOBytes,
                        &dwCommitCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
            }

            // Compare corresponding dwMemCRC and dwActCRC and verify

            if (S_OK == hr)
            {
                if (dwOriginalCRC != dwCommitCRC)
                {
                    DH_TRACE((
                        DH_LVL_ERROR,
                        TEXT("CRC's before/after commit unmatch.")));

                    fPass = FALSE;
                }
            }
            
            // Delete temp buffer

            if (NULL != ptcsBuffer)
            {
                delete []ptcsBuffer;
                ptcsBuffer = NULL;
            }

            // if child storage just commited ok, stay in loop and now 
            // commit root, otherwise set flag to terminate loop

            if ((fPass == TRUE) && (pstgCommitMe == pvcnRootNewChildStg))
            {
                pstgCommitMe = pVirtualDFRoot;
            }
            else
            {
                fRetry = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("VirtualCtrNode::Commit failed. hr = 0x%lx"), 
                hr));

            break;
        }
    }

    // Now again make some changes on IStream data, re-set the stream size 
    // to a new random size, then seek from beginning and rewrite the stream
    // data of the new size, and CRC it.

    // Generate a random number culRandIOBytes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culRandIOBytes,
                culRandIOBytes, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        ULISet32(uliSize, culRandIOBytes);
        hr = pvsnNewChildStm->SetSize(uliSize);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize"));
    }

    if (S_OK == hr)
    {
        LISet32(liZero, 0L);
        hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStm->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if(S_OK != hr) 
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate the CRC for stream data

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culRandIOBytes,
                &dwOriginalCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Test on STGC_OVERWRITE

    pstgCommitMe = pvcnRootNewChildStg;

    while ((S_OK == hr) && (fRetry == TRUE))
    {
        hr = pstgCommitMe->Commit(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE);

        if (S_OK == hr)
        {   
            // verify IStream data after commit()

            // Allocate a buffer of required size
 
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
            
            if (S_OK == hr)
            {
                LISet32(liZero, 0L);
                hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

                DH_HRCHECK(hr, TEXT("IStream::Seek"));
            }

            if (S_OK == hr)
            {
                memset(ptcsBuffer, '\0', culRandIOBytes * sizeof(TCHAR));

                hr = pvsnNewChildStm->Read(
                       ptcsBuffer,
                       culRandIOBytes,
                       &culRead);
            }

            if ((S_OK != hr) || (culRead != culRandIOBytes))
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("IStream::Read not successful, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }

            // Calculate the CRC for stream data

            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        ptcsBuffer,
                        culRandIOBytes,
                        &dwCommitCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
            }

            // Compare corresponding dwMemCRC and dwActCRC and verify

            if (S_OK == hr)
            {
                if (dwOriginalCRC != dwCommitCRC)
                {
                    DH_TRACE((
                        DH_LVL_ERROR,
                        TEXT("CRC's before/after commit unmatch.")));

                    fPass = FALSE;
                }
            }
            
            // Delete temp buffer

            if (NULL != ptcsBuffer)
            {
                delete []ptcsBuffer;
                ptcsBuffer = NULL;
            }

            // if child storage just commited ok, stay in loop and now 
            // commit root, otherwise set flag to terminate loop

            if ((fPass == TRUE) && (pstgCommitMe == pvcnRootNewChildStg))
            {
                pstgCommitMe = pVirtualDFRoot;
            }
            else
            {
                fRetry = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("VirtualCtrNode::Commit failed. hr = 0x%lx"), 
                hr));

            break;
        }
    }

    // Release the child stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStm->Close();

        DH_HRCHECK(hr, TEXT("VirutalStmNode::Close"));
    }

    // Release child and root storages

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_106 failed, hr = 0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pRootNewChildStgName)
    {
        delete []pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if (NULL != ptszStreamName)
    {
        delete []ptszStreamName;
        ptszStreamName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\dftests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       dftests.cxx
//
//  Contents:   storage base tests basically pertaining to DocFile in general. 
//
//  Functions:  
//
//  History:    3-June-1996     NarindK     Created.
//              27-Mar-97       SCousens    conversionified
//
//--------------------------------------------------------------------------

//BUGBUG: BUGNOTE: All not for conversion need a second look. -scousens

#include <dfheader.hxx>
#pragma hdrstop

#include <sys/stat.h>
#include <share.h>
#include <errno.h> //get errors for our runtime calls

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    DFTEST_100 
//
// Synopsis: Regression test to create a root docfile. Commit the root docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFCOMMIT.CXX
// 2.  Old name of test : LegitRootNormal 
//     New Name of test : DFTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-100
//        /dfRootMode:dirReadWriteShEx /dfname:DFCOMMIT.DFL
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-100
//        /dfRootMode:xactReadWriteShEx /dfname:DFCOMMIT.DFL 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfname:DFCOMMIT.DFL
//
// BUGNOTE: Conversion: DFTEST-100 NO
//
//-----------------------------------------------------------------------------


HRESULT DFTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression test for Root DocFile creation/commit. ")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {                   
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }


    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));

    }

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_101 
//
// Synopsis: Regression test to create a root docfile, commit the root docfile,
//           release the toot docfile and remove the docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFREMOVE.CXX
// 2.  Old name of test :  
//     New Name of test : DFTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-101
//        /dfRootMode:dirReadWriteShEx /dfname:DFREMOVE.DFL 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-101
//        /dfRootMode:xactReadWriteShEx /dfname:DFREMOVE.DFL 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfname:DFREMOVE.DFL 
//
// BUGNOTE: Conversion: DFTEST-101 NO
// 
//-----------------------------------------------------------------------------


HRESULT DFTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression for RootDocFile creation/commit/release/removal.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));

    }

    // Commit the root docfile with STGC_ONLYIFCURRENT mode.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_ONLYIFCURRENT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_102 
//
// Synopsis: Regression test to create a root docfile, commit the root docfile,
//           release the root docfile.  Verify using StgIsStorageFile API.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in transacted mode. 
//
// New Test Notes:
// 1.  Old File: DFROOT.CXX
// 2.  Old name of test : TransactedCommitTest  
//     New Name of test : DFTEST_102 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-102
//        /dfRootMode:xactReadWriteShEx /dfname:DFROOT.DFL 
//
// BUGNOTE: Conversion: DFTEST-102 NO
//
//  StgIsOpenStorage returns S_OK in transacted mode before Commit is done.
//-----------------------------------------------------------------------------


HRESULT DFTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        pOleStrTemp             = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression test for RootDocFile creation/commit/release")));
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("in transacted mode.  Use StgIsStorageFile to verify.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));

    }

    if(S_OK == hr)
    {
        // Convert DocFile name to OLECHAR

        hr = TStringToOleString(pTestVirtualDF->GetDocFileName(), &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Use StgIsStorageFile now.  This should return S_OK since even if 
    // commit is not done till this point, signature is written into it.
    // This is different frol old base tests since this enhancement is
    // checked in by Storage team (confirmed by PhilipLa)

    if (S_OK == hr)
    {
        hr = StgIsStorageFile(pOleStrTemp);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx as expected."), hr));

        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx unexpectedly."), hr));
        }
    } 

    // Commit the root docfile with STGC_ONLYIFCURRENT mode.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_ONLYIFCURRENT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Use StgIsStorageFile now.  This should again return S_OK since commit is
    // done by now.

    if (S_OK == hr)
    {
        hr = StgIsStorageFile(pOleStrTemp);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx as expected."), hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx unexpectedly."), hr));
        }
    } 

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_102 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_103 
//
// Synopsis: Regression test to create and instantiate a root docfile with path 
//           as part of the name.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFTESTN.CXX
// 2.  Old name of test :  
//     New Name of test : DFTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     stgbase /seed:0  /t:DFTEST-103
//
// BUGNOTE: Conversion: DFTEST-103 NO
//
//-----------------------------------------------------------------------------


HRESULT DFTEST_103(ULONG ulSeed)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    LPSTORAGE       pIRootStorage           = NULL;
    DWORD           dwLen                   = 0;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        poszFileName            = NULL;
    TCHAR           tszFileName[MAX_PATH+1]; 
    ULONG           ulRef                   = 0;
    DWORD           dwDirectMode            = STGM_DIRECT |
                                              STGM_READWRITE |
                                              STGM_SHARE_EXCLUSIVE;
    DWORD           dwTransactedMode        = STGM_TRANSACTED |
                                              STGM_READWRITE |
                                              STGM_SHARE_EXCLUSIVE;
    DWORD           dwTransactedDWMode      = STGM_TRANSACTED |
                                              STGM_READWRITE |
                                              STGM_SHARE_DENY_WRITE;
    DWORD           dwRootMode[3]           = {dwDirectMode,    
                                               dwTransactedMode,
                                               dwTransactedDWMode};
    INT             count                   = 0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression for RootDF creation with path as part of name.")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for root 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Determine current directory path (so that a MAX_PATH long
    // filename can be constructed).

    if (S_OK == hr) 
    {
        dwLen = GetCurrentDirectory(MAX_PATH, tszFileName);

        if (0 == dwLen) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GetCurrentDirectory"));
        }
    }

    if (S_OK == hr) 
    {
        _tcscat(tszFileName, SZ_SEP);
        _tcscat(tszFileName, pFileName);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Name of root docfile %ws for DFTEST_103 "),
            tszFileName));
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(tszFileName, &poszFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // First attempt test with Direct mode.

    while((count<3) && (S_OK == hr))
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_103, Access mode: %lx"),
            dwRootMode[count]));

        // Only direct mode is supported for flatfiles, so do accordingly
       
        // ----------- flatfile change ---------------
        if(StorageIsFlat() && ( dwDirectMode != dwRootMode[count]))
        {
            break;
        }
        // ----------- flatfile change ---------------
 
        // Call StgCreateDocFile with path in file name.  

        if (S_OK == hr)
        {
            hr = StgCreateDocfile(
                    poszFileName,
                    STGM_CREATE | dwRootMode[count],
                    0,
                    &pIRootStorage);
        }
    
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile unsuccessful, hr = 0x%lx."),
                hr));
        }

        // Commit

        if (S_OK == hr)
        {
            hr = pIRootStorage->Commit(STGC_DEFAULT);
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr = 0x%lx."),
                hr));
        }

        // Call Release on root docfile

        if (S_OK == hr)
        {
            ulRef = pIRootStorage->Release();
            DH_ASSERT(0 == ulRef);
            pIRootStorage = NULL;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release unsuccessfull, hr = 0x%lx."),
                hr));
        }

        // Instantiate the RootDocFile again

        if (S_OK == hr)
        {
            hr = StgOpenStorage(
                    poszFileName,
                    NULL,
                    dwRootMode[count],
                    NULL,
                    0,
                    &pIRootStorage);

            DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage unsuccessful, hr = 0x%lx."),
                hr));
        }

        // Call Release on root docfile

        if (S_OK == hr)
        {
            ulRef = pIRootStorage->Release();
            DH_ASSERT(0 == ulRef);
            pIRootStorage = NULL;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release unsuccessful, hr = 0x%lx."),
                hr));
        }
        
        count++;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_103 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != poszFileName)
    {
        delete poszFileName;
        poszFileName = NULL;
    }

    // Delete data gen object 

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_104 
//
// Synopsis: Regression test to create, instantiate and enumerate a root 
//           docfile hierarchy and count objects.   
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct mode. 
//
// New Test Notes:
// 1.  Old File: DFVERIFY.CXX
// 2.  Old name of test : MiscDfVerify  
//     New Name of test : DFTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-5 /dfstg:0-5 /dfstm:0-10 /t:DFTEST-104
//        /dfRootMode:dirReadWriteShEx 
//
// BUGNOTE: Conversion: DFTEST_104
// 
//-----------------------------------------------------------------------------


HRESULT DFTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    ULONG           cStg                    = 0;
    ULONG           cStm                    = 0;
    ULONG           cMemStg                 = 0;
    ULONG           cMemStm                 = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression for RootDF creation/instantiation/enumeration.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_104, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Enumerate the DocFile in memory and get the number of VirtualCtrNodes
    // and VirtualStmNodes.  Later on we could compare these statistics with
    // real IStorages / IStreams enumerated from the disk docfile. 

    if (S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cMemStg, &cMemStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile"));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Clsoe all the substorages/streams

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Instantiate the RootDocFile again

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        
        if(NULL == pStgRoot)
        {
          DH_LOG((LOG_INFO, 
            TEXT("pVirtualDFRoot->GetIStoragePointer failed to return IStorage")) );

          hr = E_FAIL;
        }
    }

    // Enumerate the Docfile on the disk

    if (S_OK == hr)
    {
        hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT, &cStg, &cStm);

        DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile"));
    }

    // Check the disk docfile enumeration with in memory docfile enumeration.

    if (S_OK == hr)
    {
        if((cMemStg == cStg) && (cMemStm == cStm))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("DocFile correctly written & enumerated.")) );
        }
        else
        {
            hr = S_FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("DocFile not correctly written or enumerated.")) );
        }
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_104 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_105 
//
// Synopsis: Regression test to create and instantiate a root docfile with a
//           random name, a child IStorage within the root, and an additional
//           child storage within the first child IStorage. The first child is 
//           released before its child is released, verify no error.  The first 
//           child is reinstantiated.  The root IStorage is now released before 
//           the child IStorage, verify no error. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IIREL.CXX
// 2.  Old name of test : IllegitInstEnumRelease Test 
//     New Name of test : DFTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-105
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: DFTEST-105
// 
//-----------------------------------------------------------------------------


HRESULT DFTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootChildStorage   = NULL;
    LPTSTR          pRootChildStgName       = NULL;
    VirtualCtrNode  *pvcnChildChildStorage  = NULL;
    LPTSTR          pChildChildStgName      = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_105 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Create Root DF with Child IStg which has its Child IStg.")));
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Release first child IStg w/o releasing its child IStg.")));
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Reinstantiate 1st child IStg. Release root w/o releasing")));
    DH_TRACE((DH_LVL_TRACE1, TEXT("this IStg.  Verify no errors.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_105, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        if(NULL == pdgu)
        {
          DH_LOG((LOG_INFO, 
            TEXT("pTestVirtualDF->GetDataGenUnicode failed")) );

          hr = E_FAIL;
        }
    }

    // Create a child IStorage in the root.

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE                |
                STGM_FAILIFTHERE,
                &pvcnRootChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Create a child IStorage inside the child IStorage.

    // Generate a random name for the new child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pChildChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pvcnRootChildStorage,
                pChildChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE                |
                STGM_FAILIFTHERE,
                &pvcnChildChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the storages

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pvcnChildChildStorage->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Release child IStorage before its child is released, should
    // cause no error

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Release child's child IStorage 

    if (S_OK == hr)
    {
        hr = pvcnChildChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Reinstantiate the Root's child IStorage again

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Open(
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Call Release on root docfile before calling Release on its child.
    // Verify no error.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Release Root's child IStorage now.

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_105 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootChildStgName)
    {
        delete pRootChildStgName;
        pRootChildStgName = NULL;
    }

    if(NULL != pChildChildStgName)
    {
        delete pChildChildStgName;
        pChildChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_106
 
//
// Synopsis: Attempts several illegitimate operations during creation of
//           root docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IRCREATE.CXX
// 2.  Old name of test : IllegitRootCreate Test 
//     New Name of test : DFTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-106
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//        /dfname:DFTEST.106 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-106
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//        /dfname:DFTEST.106 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-106
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /dfname:DFTEST.106 
//     
// BUGNOTE: Conversion: DFTEST-106 NO
// 
//-----------------------------------------------------------------------------

HRESULT DFTEST_106(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageOpen           = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    FILE            *hFile                  = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    int             iErr                    = 0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("DFTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
       TEXT("Attempt illegitimate operations in creation of root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    // GetRootDocFile mode

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_106, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name

    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName = 
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
        }
        else
        {
            DH_ASSERT(!"No DocFile name passed from cmd line!") ;
        }

        DH_HRCHECK(hr, TEXT("pTestChanceDF->GetDocFileName()")) ;
    }

    // Make a directory with the same name DFTEST.106 that we would use to
    // create the directory.  Check that call to StgCreateDocFile succeeds

    if (S_OK == hr)
    {
        iErr = _tmkdir(pRootDocFileName);
        if (0 != iErr)
        {
            // if file already exists, try deleting it and try mkdir again
            if (ENOENT != errno)
            {
                iErr = DeleteFile (pRootDocFileName);
                if (FALSE == iErr)
                {
                    DH_TRACE ((DH_LVL_ERROR, 
                            TEXT("DeleteFile(%s) Failed. Error:%#lx"), 
                            pRootDocFileName, 
                            GetLastError ()));
                }
                iErr = _tmkdir(pRootDocFileName);
            }
        }
        if (0 != iErr)
        {
            hr = (EACCES == errno) ? ERROR_FILE_EXISTS : ERROR_FILE_NOT_FOUND;
            DH_HRCHECK (hr, TEXT("mkdir"));
        }
    }
    
    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // This call to generate VirtualDF will call StgCreateDocFile API.  This
    // call is expected to fail since dir of same name exists.

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Should fail when dir of same name exists,hr = 0x%lx "),hr));
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Failed as exp when dir of same name exists,hr = 0x%lx"), hr));

            hr = S_OK;
        }
    }

    // Case 2: Try STGM_CONVERT as mode now.  This is also expected to fail, as
    // a dir of same name pre exists.

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try creating with STGM_CONVERT mode.

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CONVERT | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Err:Pass(STGM_CONVERT) with existing same name dir,hr=0x%lx"),
              hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Exp:Fail(STGM_CONVERT)with existing same name dir,hr=0x%lx"),
              hr));

            hr = S_OK;
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Remove the direcory DFTEST.106

    if (S_OK == hr)
    {
        iErr = _trmdir(pRootDocFileName);
        if (0 != iErr)
        {
            hr = (ENOENT == errno) ? ERROR_FILE_NOT_FOUND : ERROR_FILE_EXISTS;
            DH_HRCHECK (hr, TEXT("rmdir"));
        }
    }
    
    // Case 3:  Create DocFile when file exists and is being accessed in deny
    // write mode.

    if (S_OK == hr)
    {
        hFile = _tfsopen(pRootDocFileName, TEXT("w+"), _SH_DENYWR);
        DH_ASSERT(NULL != hFile);
    }

    // Try STGM_CREATE mode to create DocFile.  This call is expected to fail
    // as file exists and is being accessed in deny write mode. 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_SHAREVIOLATION != hr)
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Err:Pass,same name file access in deny write mode, hr=0x%lx"),
              hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Exp;Fail,same name file access in deny write mode, hr=0x%lx"),
              hr));

            hr = S_OK;
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    // Try STGM_CONVERT mode to create DocFile.  This call is expected to fail
    // as file exists and is being accessed in deny write mode. 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CONVERT | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_SHAREVIOLATION != hr)
        {
            DH_TRACE((
             DH_LVL_TRACE1,
             TEXT("Err:Pass(STGM_CONVERT),same name file access in deny write mode")
             TEXT(", hr = 0x%lx "),
              hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Exp:Fail(STGM_CONVERT), same name file access in deny write \
              mode, hr = 0x%lx "), 
              hr));

            hr = S_OK;
        }
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Close handle

    if(NULL != hFile)
    {
        fclose(hFile);
    }

    // Change the mode to READ_ONLY and then try.

    if(S_OK ==  hr)
    {
        iErr = _tchmod(pRootDocFileName, _S_IREAD);
        DH_ASSERT (0 == iErr);
    }

    // Try STGM_CREATE mode to create DocFile.  This call is expected to fail
    // as file exists and is read only. 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Err:Pass,same name file exists and is read only,hr=0x%lx "),
                hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Exp:Fail,same name file exists and is read only,hr = 0x%lx"),
               hr));

            hr = S_OK;
        }
    }

    // Try STGM_CONVERT mode to create DocFile.  This call is expected to fail
    // as file exists and is read only. 

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CONVERT | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Err:Pass(STGM_CONVERT), same name file exists RO,hr=0x%lx"),
                hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Exp:Fail(STGM_CONVERT),same name file exists RO,hr=0x%lx"),
                hr));

            hr = S_OK;
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Change mode to readwrite

    iErr = _tchmod(pRootDocFileName, _S_IREAD|_S_IWRITE);
    DH_ASSERT (0 == iErr);

    // Try to instantiate the pRootDocFileName which isn't a storage object 

    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);

        // ----------- flatfile change ---------------
        if(!StorageIsFlat())
        {
        // ----------- flatfile change ---------------
        if(STG_E_FILEALREADYEXISTS == hr)
        {
           DH_TRACE((
             DH_LVL_TRACE1,
             TEXT("DocFile instantiated failed as exp with non stg obj hr=0x%lx"),
             hr));

           hr = S_OK;
        }
        else
        {
           DH_TRACE((
             DH_LVL_TRACE1,
             TEXT("DocFile instantiation passed unexp with non stg obj,hr=0x%lx"),
             hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorageOpen->Release ();
                pIStorageOpen = NULL;
            }
           fPass = FALSE;
        }
        }  
        else //  ----------- flatfile change ---------------
        {  
        if(S_OK == hr)
        {
           DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Exp:Flatfile instantiation passed with non stg obj,hr=0x%lx"),
           hr));

           if (NULL != pIStorageOpen)
           {
                pIStorageOpen->Release ();
                pIStorageOpen = NULL;
           }
        }
        else
        {
           DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("UnExp:Flatfile instantiation fail with nonstg obj,hr=0x%lx"),
           hr));
           fPass = FALSE;
           hr = S_OK; // Set hr to S_OK for further conditions test
        }
        // ----------- flatfile change ---------------
        }
        // ----------- flatfile change ---------------
    }

    // Remove the file

    iErr = _tremove(pRootDocFileName);
    DH_ASSERT (0 == iErr);

    // Call StgCreateDocFile with non zero data in dwReserved parameter.  This
    // call is expected to fail

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                999,
                &pIStorage);

        if (STG_E_INVALIDPARAMETER != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Err:Pass with nonzero dwReserverd para, hr = 0x%lx "), 
                hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Exp: Fail with nonzero dwReserved parameter, hr=0x%lx "), 
                hr));

            hr = S_OK;
        }
    }

    // Call StgCreateDocFile with NULL 4th parameter.  This call is expected
    // to fail.

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                NULL);

        if (STG_E_INVALIDPOINTER != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Should fail with NULL 4th parameter, hr = 0x%lx "), hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Failed as exp with NULL 4th parameter, hr = 0x%lx "), 
                hr));

            hr = S_OK;
        }
    }

    //  Call StgCreateDocFile with mode STGM_CREATE|STGM_CONVERT.  This call 
    // is expected to fail.

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | STGM_CONVERT,
                0,
                &pIStorage);

        if (STG_E_INVALIDFLAG != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Should fail with invalid mode, hr = 0x%lx "), hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Failed as expected with invalid mode., hr = 0x%lx "), hr));

            hr = S_OK;
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    //  Call StgCreateDocFile with all valid parameters.  This call is 
    //  expected to pass.

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                &pIStorage);
 
       DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DocFile created successfully as expected hr = 0x%lx "),hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DocFile creation failed unexpectedly, hr = 0x%lx "),hr));

            fPass = FALSE;
        }
    }

    // Instantiate DocFile again

    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);

   
        if(STG_E_LOCKVIOLATION == hr)
        {
           DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("DocFile reinstantiated failed as expected hr = 0x%lx "),hr));
           hr = S_OK;
        }
        else
        {
           DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("DocFile reinstantiation didn't fail unexp, hr = 0x%lx "),
               hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorageOpen->Release ();
                pIStorageOpen = 0;
            }
           fPass = FALSE;
        }
    }

    // If everything goes okay, report test as passed, else failure

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_106 failed, hr = 0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Release storage pointer(s) 
 
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release(); 
        DH_ASSERT(0 == ulRef);
    }

    if (NULL != pIStorageOpen)
    {
        ulRef = pIStorageOpen->Release(); 
        DH_ASSERT(0 == ulRef);
    }

    // Delete temp string

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        if(NULL != pVirtualDFRoot)
        {
            hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

            DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;
        }

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_107 
//
// Synopsis: A random root DF is created with STGM_SIMPLE flag and tests done
//          on it.  STGM_SIMPLE mode can only be specified with STGM_CREATE,
//          STGM_READWRITE, STGM_SHARE_EXCLUSIVE flags.  There is no support
//          for substorages.  Each stream is atleast 4096 bytes in length, and
//          access to streams follow a linear pattern, i.e. once a stream is
//          released, it can't be opened or read/written again.  The following
//          IStorage methods: QueryInterface, AddRef, Release, CreateStream,
//          SetClass, Commit are supported.  SetElementTimes is supported with
//          NULL name, allowing applications to set time on root storage in
//          simple mode.  Supported IStream methods are QueryInterface, AddRef,
//          Release, SetSize, Read, Write, Seek. All the other methods return
//          STG_E_INVALIDFUNCTION.  
//                The test verifies the above restrictions on DocFile if STGM_
//          SIMPLE is specified in creation of a docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  9-Aug-1996     NarindK     Created.
//           4-Nov-1996     BogdanT     Mac porting
//
// Notes:    This test runs in direct mode
//
// THIS TEST HAS A MEMORY LEAK IN OLE CODE: BUG 52975
//
// New Test Notes:
// 1.  Old File: STDDOC.CXX
// 2.  Old name of test : TestStdDocFile Test 
//     New Name of test : DFTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:DFTEST-107
//
// BUGNOTE: Conversion: DFTEST-107
//
//-----------------------------------------------------------------------------

HRESULT DFTEST_107(ULONG ulSeed)
{

#ifdef _MAC  // Simple mode not ported yet; check with the developers
             // and remove this when ready

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!Simple mode DFTEST_107 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    VirtualStmNode  *pvsnRootMoreStream     = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          pRootMoreStmName        = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPSTORAGE       pStgRoot                = NULL;
    DWORD           dwChildMode             = STGM_READWRITE |
                                              STGM_SHARE_EXCLUSIVE;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    LPSTREAM        pStmChildTest           = NULL;
    OLECHAR         ocName[]                = {'f', 'o', 'o'}; 
    LPENUMSTATSTG   penumWalk               = NULL;
    ULONG           cb                      = 0;    
    ULONG           culWritten              = 0;
    ULONG           culRead                 = 0;    
    ULONG           cRandomMinSize          = 256;
    ULONG           cRandomMaxSize          = 2048;
    ULONG           cNum                    = 0;
    ULONG           cRandomMinNumStms       = 3;
    ULONG           cRandomMaxNumStms       = 6;
    LPTSTR          ptcsBuffer              = NULL;
    LPTSTR          ptcsSimpReadBuffer      = NULL;
    LPTSTR          ptcsReadBuffer          = NULL;
    BOOL            fRet                    = FALSE;
    FILETIME        cNewFileTime            = {dwDefLowDateTime,
                                              dwDefHighDateTime};
    BOOL            fPass                   = TRUE;
    ULONG           ulSizeOfStream          = 0;
    ULONG           cMemStg                 = 0;
    ULONG           cMemStm                 = 0;
    ULONG           cActStg                 = 0;
    ULONG           cActStm                 = 0;
    DWCRCSTM        dwMemCRC; 
    DWCRCSTM        dwActCRC; 
    SYSTEMTIME      cCurrentSystemTime;
    ULARGE_INTEGER  uliTest;
    STATSTG         statStg;
    FILETIME        cFileTime;
    CDFD            cdfd;
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uli;

    // Not for 2phase. Bail. 
    // Test needs STGM_CREATE bit which invalidates 2 phase test
    if (DoingDistrib () || DoingConversion ())
    {
        return S_OK;
    }

    dwMemCRC.dwCRCSum = dwActCRC.dwCRCSum = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_107"));
   
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_107 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Root created /w STGM_SIMPLE, chk IStorage/IStream restrict")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.
        pdgu = new(NullOnFail) DG_STRING (ulSeed);
        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //want to create only one seed. Once that has been done, 
            //use what we created from now on.
            ulSeed = pdgu->GetSeed(); 
        }
    }

    if (S_OK == hr)
    {
        // Generate random name for root 
        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootDocFileName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = STGM_CREATE             |
                            STGM_DIRECT             |
                            STGM_READWRITE          |
                            STGM_SHARE_EXCLUSIVE    |
                            STGM_SIMPLE;

        hr = CreateTestDocfile (&cdfd, 
                pRootDocFileName,
                &pVirtualDFRoot,
                &pTestVirtualDF,
                &pTestChanceDF);
        DH_HRCHECK (hr, TEXT("CreateTestDocfile"));
    }

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        if(NULL == pStgRoot)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::GetIStoragePointer() failed to return IStorage"),
                hr));
            hr = E_FAIL;
        }
    }        
    
    // These interfaces must fail for IStorage interface if the root docfile
    // is opened with STGM_SIMPLE flag.

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::CreateStorage"), 
           CreateStorage(ocName, dwChildMode|STGM_CREATE, 0, 0, &pStgChild),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::OpenStream"), 
           OpenStream(ocName, NULL, dwChildMode, 0, &pStmChild),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::OpenStorage"), 
           OpenStorage(ocName, NULL, dwChildMode, NULL, 0, &pStgChild),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::MoveElementTo"), 
           MoveElementTo(ocName, pStgChild, ocName, STGMOVE_MOVE),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::EnumElements"), 
           EnumElements(0, NULL, 0, &penumWalk),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::DestroyElement"), 
           DestroyElement(ocName),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::RenameElement"), 
           RenameElement(ocName, ocName),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::SetStateBits"), 
           SetStateBits(0, 0),
           hr);
    }

#ifndef WINNT
    // NT5 spec change. This is now supported on NT5.
    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::Stat"), 
           Stat(&statStg,STATFLAG_NONAME),
           hr);
    }
#endif

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::Revert"), 
           Revert(),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::SetElementTimes with Non-NULL name"), 
           SetElementTimes(ocName, &cFileTime, &cFileTime, &cFileTime),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::CopyTo"), 
           CopyTo(NULL, NULL, NULL, pStgChild),
           hr);
    }

    // Set Element time with NULL name which should pass for STGM_SIMPLE mode.
 
    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewFileTime.dwHighDateTime);
       
        hr = pStgRoot->SetElementTimes(
                NULL,
                &cNewFileTime,
                &cNewFileTime,
                &cNewFileTime); 
        DH_HRCHECK(hr, TEXT("IStorage::SetElementTimes with NULL name")) ;
    }

    // Now create a stream in it with size less than 4096 bytes.  If fewer
    // than 4096 bytes are written into the stream, by the time stream is
    // released, it would have extended to 4096 bytes.  

    if(S_OK == hr)
    {
        // Generate random name for stream
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random integers.
        pdgi = new(NullOnFail) DG_INTEGER(ulSeed);
        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.
        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        DH_HRCHECK(hr, TEXT("pdgi->Generate")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnRootNewChildStream);
        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    // With above stream size is set to less than 4096.  But as per STGM_SIMPLE,
    // the size would extend to 4096 by them time stream is released.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);
        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                cb,
                &culWritten);
        DH_HRCHECK(hr, TEXT("VSN::Write in STGM_SIMPLE")) ;
    }

    // Calculate the CRC for stream data 

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                ptcsBuffer,
                cb,
                &dwMemCRC);
        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    // Check the read in STGM_SIMPLE mode.

    // Allocate a buffer of required size

    if (S_OK == hr)
    {
        ptcsSimpReadBuffer = new TCHAR [cb];
        if (NULL == ptcsSimpReadBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new")) ;
    }

    if(S_OK == hr)
    {
        // First seek to beginning of stream in STGM_SIMPLE mode.
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek in STGM_SIMPLE")) ;
    }

    if (S_OK == hr)
    {
        memset(ptcsSimpReadBuffer, '\0',  cb*sizeof(TCHAR));
        hr =  pvsnRootNewChildStream->Read(
                 ptcsSimpReadBuffer,
                 cb,
                 &culRead);
        DH_ASSERT(culRead == cb);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Read in STGM_SIMPLE")) ;
    }


    // Test unsupported interfaces for IStream interface.  

    if(S_OK == hr)
    {
        pStmChild = pvsnRootNewChildStream->GetIStreamPointer();
        if(NULL == pStmChild)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode->GetIStreamPointer() failed to return IStream"),
                hr));
            hr = E_FAIL;
        }
    }        
    
    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::CopyTo"), 
           CopyTo(pStmChildTest, uliTest, NULL, NULL),
           hr);
    }

    // Don't test IStream::Commit, since that returns STG_E_NOTIMPLEMENTED,
    // rather than STG_E_INVALIDFUNCTION

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::Revert"), 
           Revert(),
           hr);
    }

#ifndef WINNT
    // NT5 spec change. This is now supported on NT5.
    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::Stat"), 
           Stat(&statStg, STATFLAG_NONAME),
           hr);
    }
#endif

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::Clone"), 
           Clone(&pStmChildTest),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::LockRegion"), 
           LockRegion(uliTest, uliTest, 0),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::UnlockRegion"), 
           UnlockRegion(uliTest, uliTest, 0),
           hr);
    }

    // Close child stream.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }


    // Check the linear pattern of stream.  Make sure that the stream can't be
    // opened or be read , written again now.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(NULL, dwChildMode, 0);
        hr = DH_HRERRORCHECK (hr, STG_E_INVALIDFUNCTION, TEXT("VirtualStmNode::Open"));
    }

    // Create a few more streams in root storage.  This being done to test
    // additonal OLE code which occurs for more number of streams

    if (S_OK == hr)
    {
        //calulate random number of streams to be created
        usErr = pdgi->Generate(&cNum, cRandomMinNumStms, cRandomMaxNumStms);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        DH_HRCHECK (hr, TEXT("pdgi::Generate"));
    }

    while((cNum > 0) && (S_OK == hr))
    {
        cNum--;

        if(S_OK == hr)
        {
            // Generate random name for stream
            hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootMoreStmName);
            DH_HRCHECK (hr, TEXT("GenerateRandomName"));
        }

        if(S_OK == hr)
        {
            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootMoreStmName,
                    0,
                    STGM_READWRITE  |
                    STGM_SHARE_EXCLUSIVE, 
                    &pvsnRootMoreStream);
            DH_HRCHECK (hr, TEXT("AddStream"));
        }

        if (S_OK == hr)
        {
            hr = pvsnRootMoreStream->Close();
            DH_HRCHECK (hr, TEXT("IStream::Close"));
        }

        if(NULL != pRootMoreStmName)
        {
            delete pRootMoreStmName;
            pRootMoreStmName = NULL;
        }
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream (s) completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream (s) not successful, hr=0x%lx."),
            hr));
    }

    // Commit Root Docfile.
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }


    // Enumerate In Memory DocFile to count no of stgs/stms for verification
    // later

    if (S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cMemStg, &cMemStm);
        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile"));
    }

    // Close Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    // Open the root docfile without STGM_SIMPLE mode, i.e open in STGM_DIRECT|
    // STGM_READWRITE | STGM_SHARE_EXCLUSIVE mode.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                NULL, 
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    // Open the stream and Verify the CRC of the stream 1 that was calculated 
    // before.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(NULL, dwChildMode, 0);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    // Calculate CRC on stream for the number of bytes that were written during
    // the time the root was opened in STGM_SIMPLE mode.  Since the stream size
    // has got extended, the CRC on total stream would be different, since the
    // fill bytes would be present in extended size.  Garbage tests verify to
    // see that fill bytes are all zero's not checked here.

    // Allocate a buffer of required size

    if (S_OK == hr)
    {
        ptcsReadBuffer = new TCHAR [cb];
        if (NULL == ptcsReadBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new")) ;
    }

    if (S_OK == hr)
    {
        memset(ptcsReadBuffer, '\0',  cb*sizeof(TCHAR));
        culRead = 0;
        hr =  pvsnRootNewChildStream->Read(
                 ptcsReadBuffer,
                 cb,
                 &culRead);
        DH_ASSERT(culRead == cb);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Read")) ;
    }

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                ptcsReadBuffer,
                cb,
                &dwActCRC);
        DH_HRCHECK(hr, TEXT("CalculateInMmeoryCRCForStm")) ;
    }

    // Compare CRC's
 
    if(S_OK == hr)
    {
        if(dwMemCRC.dwCRCSum == dwActCRC.dwCRCSum)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's of stream match as exp.")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("CRC's of stream don't match as exp.")));
            fPass = FALSE;
        }
    }

    // Verify the size of stream is 4096 bytes.

    // Now seek to the current stream to end of stream

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
        ulSizeOfStream = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
       if(4096 == ulSizeOfStream)
       {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Size of stream extended to 4096 bytes as exp")));
       }
       else
       {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("Size of stream not extended to 4096 bytes as exp")));
            fPass = FALSE;
       }
    }

    // Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    // Check times set from SetElementTimes.  BUGBUG: On FAT, the timestamp
    // resolution is not fine enough to make dwLowDateTimeStamp meaningful,
    // so verify with dwHighDataTimeStamp only.

    // Stat on Root Storage

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if(S_OK == hr)
    {
        if(cNewFileTime.dwHighDateTime == statStg.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetElementTime and STATSTG.mtime match as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("SetElementTime and STATSTG.mtime don't match as exp")));
            fPass = FALSE;
        }
    }

    // Enumerate Actual DocFile to count no of stgs/stms for verification
    // with in memory enumerated stgs and stms 

    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT(NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::GetIStoragePointer() failed to return IStorage"),
                hr));
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT, &cActStg, &cActStm);
        DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile"));
    }

    // Verify structure of DocFile

    if(S_OK == hr)
    {
        if((cActStg == cMemStg) && (cActStm == cMemStm))
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("DocFile enumeration passed as exp")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("DocFile enumeration failed unexp")));
            fPass = FALSE;
        }
    }

    // Close the root.    

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_107 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_107 failed, hr=0x%lx, fPass=%d."),
            hr,
            fPass));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    CleanupTestDocfile (&pVirtualDFRoot, &pTestVirtualDF, &pTestChanceDF, S_OK==hr);

    // Delete strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != ptcsBuffer)
    {
        delete [] ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if(NULL != ptcsSimpReadBuffer)
    {
        delete [] ptcsSimpReadBuffer;
        ptcsSimpReadBuffer = NULL;
    }

    if(NULL != ptcsReadBuffer)
    {
        delete [] ptcsReadBuffer;
        ptcsReadBuffer = NULL;
    }

    // Delete data generators

    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_108 
//
// Synopsis: A random root DF is created with STGM_SIMPLE flag.  Illegal
//           operations are done on that DocFile permitted methods.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  12-Aug-1996     NarindK     Created.
//           04-Nov-1996     BogdanT     Mac porting
//
// Notes:    This test runs in direct mode
//
// THIS TEST GPF's IN OLE CODE: BUG 53142, BUG 53615 - fixed 6/97
//
// New Test Notes:
// 1.  Old File: -none- 
// 2.  Old name of test : -none- 
//     New Name of test : DFTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:DFTEST-108
//
// BUGNOTE: Conversion: DFTEST-108 NO
//
//-----------------------------------------------------------------------------

HRESULT DFTEST_108(ULONG ulSeed)
{

#ifdef _MAC  // Simple mode not ported yet; check with the developers
             // and remove this when ready
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!Simple mode DFTEST_108 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#elif defined (_CHICAGO_) || (_WIN32_WINNT < 0x500)
    DH_TRACE ((DH_LVL_ALWAYS, 
            TEXT("DCOM has not picked up the new bits yet. Failure hardcoded in test")));
    DH_LOG ((LOG_FAIL,
            TEXT("DFTEST-108 Failed. DCOM not updated in chicago. Bugs# 53142,53615")));
    return E_FAIL;
#else

    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPOLESTR        poszRootNewChildStmName = NULL;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTREAM        pStmChild               = NULL;
    ULONG           ulRef                   = 0;
    CDFD            cdfd;


    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_108 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt illegal tests on STGM_SIMPLE docfile")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for root 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = STGM_CREATE             |
                            STGM_DIRECT             |
                            STGM_READWRITE          |
                            STGM_SHARE_EXCLUSIVE    |
                            STGM_SIMPLE;

        hr = pTestChanceDF->Create(&cdfd, pRootDocFileName);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(
                pTestChanceDF,
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - failed, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        // Get Root Storage pointer
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        if(NULL == pStgRoot)
        {
          DH_LOG((LOG_INFO, 
            TEXT("pVirtualDFRoot->GetIStoragePointer failed to return IStorage")) );

          hr = E_FAIL;
        }

    }

    if(S_OK == hr)
    {
        // Generate random name for stream
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert stream name to OLECHAR
        hr = TStringToOleString(pRootNewChildStmName, &poszRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call CSimpStorage::CreateStream with valid paramter .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszRootNewChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream passed as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed unexp,hr=0x%lx"),
                hr));
        }
    }

    // Call QueryInterface on IStream with invalid out parameter.
    if(S_OK == hr)
    {
        hr = pStmChild->QueryInterface(IID_IStream, NULL);

        if (STG_E_INVALIDPOINTER == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStream:QueryInterface failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStream::QueryInterface didn't fail exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Release ptr, if reqd
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT(0 == ulRef);
        pStmChild = NULL;
    }

    // delete these strings and create new ones so we get different
    // names when trying to create things in the df (avoid name collisions)
    delete pRootNewChildStmName;
    pRootNewChildStmName = NULL;
    delete poszRootNewChildStmName;
    poszRootNewChildStmName = NULL;

    if(S_OK == hr)
    {
        // Generate random name for stream
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert stream name to OLECHAR
        hr = TStringToOleString(pRootNewChildStmName, &poszRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call QueryInterface on CSimpStorage with invalid out parameter.
    if(S_OK == hr)
    {
        hr = pStgRoot->QueryInterface(IID_IStorage, NULL);

        if (STG_E_INVALIDPOINTER == hr)
        {
            DH_TRACE((DH_LVL_TRACE1,
                TEXT("CSimpStorage:QueryInterface failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1,
                TEXT("CSimpStorage::QueryInterface didn't fail exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Call CSimpStorage::CreateStream with invalid out &pStmChild paramter .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszRootNewChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                NULL);

        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (STG_E_INVALIDPOINTER == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream didn't fail as exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Call CSimpStorage::CreateStream with NULL name .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);

        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream didn't fail as exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }   
    }

    // Release ptr, if reqd
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT(0 == ulRef);
        pStmChild = NULL;
    }

    // Call CSimpStorage::CreateStream with invalid reserved paramter .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszRootNewChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                999,
                999,
                &pStmChild);

        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream didn't fail as exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Release ptr, if reqd
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT(0 == ulRef);
        pStmChild = NULL;
    }

    // if everything goes well, log test as passed else failed.
    if(S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_108 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete  docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree for first DocFile

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree for first docfile

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != poszRootNewChildStmName)
    {
        delete poszRootNewChildStmName;
        poszRootNewChildStmName = NULL;
    }

    // Delete data generators

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_109
//
// Synopsis: A simple mode root docfile is created, then add a random number
//           of streams under the root storage, make sure the last stream's size
//           is less than 4K(ministream), then commit and release the docfile.
//
// Arguments:[ulSeed] 
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct mode only
//
// History:  29-Oct-1996     JiminLi     Created.
//
// Notes:
//   To run the test, do the following at command prompt. 
//   stgbase /seed:0 /t:DFTEST-109
//
// BUGNOTE: Conversion: DFTEST-109 NO
//
//-----------------------------------------------------------------------------

HRESULT DFTEST_109(ULONG ulSeed)
{

#ifdef _MAC  // Simple mode not ported yet; check with the developers
             // and remove this when ready

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!Simple mode DFTEST_109 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                          = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    VirtualStmNode  **pvsnRootNewChildStream    = NULL;
    LPTSTR          *pRootNewChildStmName       = NULL;
    ULONG           culBytesWrite               = 0;
    DG_INTEGER      *pdgi                       = NULL;
    LPTSTR          pRootDocFileName            = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    DG_STRING       *pdgu                       = NULL;
    DWORD           dwRootMode                  = 0;
    ULONG           ulIndex                     = 0;
    ULONG           ulStmNum                    = 0;
    ULONG           ulMinStm                    = 2;
    ULONG           ulMaxStm                    = 5;
    ULONG           culWritten                  = 0;
    USHORT          usErr                       = 0;
    CDFD            cdfd;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_109"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_109 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Test on adding a ministream into the simple root storage")));

    if (S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        // Create a new DataGen object to create random integers.

        pdgi = new(NullOnFail) DG_INTEGER(ulSeed);

        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for root 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = STGM_CREATE             |
                            STGM_DIRECT             |
                            STGM_READWRITE          |
                            STGM_SHARE_EXCLUSIVE    |
                            STGM_SIMPLE;

        hr = pTestChanceDF->Create(&cdfd, pRootDocFileName);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(
                pTestChanceDF,
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - failed, hr=0x%lx."),
            hr));
    }

    // Generate the number of streams to create

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulStmNum, ulMinStm, ulMaxStm);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Initialization

    if (S_OK == hr)
    {
        pvsnRootNewChildStream = new VirtualStmNode*[ulStmNum];
        pRootNewChildStmName = new LPTSTR[ulStmNum];
 
        if ((NULL == pvsnRootNewChildStream) || (NULL == pRootNewChildStmName))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
        {
            pvsnRootNewChildStream[ulIndex] = NULL;
            pRootNewChildStmName[ulIndex] = NULL;
        }
    }

    // Create ulStmNum streams under the root storage

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (S_OK == hr)
        {
            // Generate random name for stream

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStmName[ulIndex]);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if (S_OK == hr)
        {
            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStmName[ulIndex],
                    0,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    &pvsnRootNewChildStream[ulIndex]);

            DH_HRCHECK(hr, TEXT("AddStream")) ;
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx"),
                hr));
        }

        if (S_OK == hr)
        {
            // Generate random size for stream between MIN_STMSIZE and
            // MAX_STMSIZE if it's not the last stream, otherwise generate a 
            // size between 0 and MAXSIZEOFMINISTM(4096L).
 
            if (ulStmNum-1 == ulIndex)
            {
                usErr = pdgi->Generate(&culBytesWrite, 0L, MAXSIZEOFMINISTM);
            }
            else
            {
                usErr = pdgi->Generate(&culBytesWrite,MIN_STMSIZE,MAX_STMSIZE);
            }

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if (S_OK == hr)
        {
            // Generate a random string of size culBytesWrite

            hr = GenerateRandomString(
                    pdgu,
                    culBytesWrite,
                    culBytesWrite,
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream[ulIndex]->Write(
                    ptcsBuffer,
                    culBytesWrite,
                    &culWritten);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Write not successful, hr=0x%lx."),
                hr));
        }

        // Release the stream

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream[ulIndex]->Close();
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }

        // Delete the temp buffer

        if (NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_109 passed.")) );
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_109 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete the docfile on disk

    if ((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp space

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if (NULL != pvsnRootNewChildStream)
    {
        delete []pvsnRootNewChildStream;
        pvsnRootNewChildStream = NULL;
    }

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (NULL != pRootNewChildStmName[ulIndex])
        {
            delete pRootNewChildStmName[ulIndex];
            pRootNewChildStmName[ulIndex] = NULL;
        }
    }

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if (NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    if (NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_109 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\enumtsts.cxx ===
-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      vcpytsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage/IStream copy
//             ops 
//
//  Functions:  
//
//  History:    15-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_100 
//
// synopsis: A random root DF is created with random number of storages/streams
//       committed/close/reopened. An enumerator is obtained.  For each object 
//       found,attempt is made to convert object to an IStorage.  If it already 
//       was an IStorage, the conversion fails and the test continues.  If an 
//       IStream was converted to an IStorage, the new IStorage is committed 
//       and enumerated to ensure that only a single IStream named "CONTENTS" 
//       (STG_CONVERTED_NAME) exists. The CONTENTS IStream is instantiated, 
//       read, verified, and released. When all IStreams in the top level of 
//       the docfile have been converted ,root docfile is committed & released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  22-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LICONV.CXX
// 2.  Old name of test : LegitInstEnumConvert Test 
//     New Name of test : ENUMTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-100
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-100
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTemp               = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPENUMSTATSTG   penumWalkConv           = NULL;
    VirtualStmNode  *pvsnTrav               = NULL;
    VirtualStmNode  *pvsnTempConv           = NULL;
    LPMALLOC        pMalloc                 = NULL;
    ULONG           ulRef                   = 0;
    ULONG           cElementsInConvStg      = 0;
    LPTSTR          ptszStatStgName         = NULL;
    LPTSTR          ptszStatStgConvName     = NULL;
    STATSTG         statStg;
    STATSTG         statStgConv;
    DWCRCSTM        dwMemCRC;
    DWCRCSTM        dwActCRC;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Enumerate RootDF, do CreateStorage STGM_CONVERT on elements")));

// BUGBUG: Bug in testcode. TO BE fixed by scousens soon.
if (DoingDistrib ())
{
    DH_LOG((
            LOG_ABORT, 
            TEXT("Enumtest-100: Test bug. CRC not calcd for streams on open.")));
    return E_FAIL;
}

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    // Initialize CRC values to zero

    dwMemCRC.dwCRCData = dwActCRC.dwCRCData = 0;

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Reopen the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get an enumerator for the root.

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }
 
    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }
 
    // In a loop, enumerate the DocFile at root level and call CreateStorage 
    // with STGM_CONVERT on the found element.  As a result, if the element
    // is a storage, it should return error STG_E_FILEALREADYEXISTS.  If it
    // is a stream, it is replaced with a new storage object containing a
    // single stream called CONTENTS and hr returned is STG_S_CONVERTED.

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        // Convert statStg.pwcsName to TCHAR

        hr = OleStringToTString(statStg.pwcsName, &ptszStatStgName); 

        // Record CRC for this element before conversion if it is a stream

        if((STGTY_STREAM == statStg.type) && (S_OK == hr))
        {
            pvsnTrav = pVirtualDFRoot->GetFirstChildVirtualStmNode(); 
   
            while((NULL != pvsnTrav) &&
                  (0 != _tcscmp(
                            ptszStatStgName,
                            pvsnTrav->GetVirtualStmNodeName()))) 
            {
                pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
            }
            
            DH_ASSERT(NULL != pvsnTrav);
            dwMemCRC.dwCRCData = pvsnTrav->GetVirtualStmNodeCRCData();
        }

        // Call to CreateStorage with STGM_CONVERTED flag

        if(S_OK == hr)
        {
            hr = AddStorage(     
                    pTestVirtualDF,     
                    pVirtualDFRoot,      
                    ptszStatStgName,
                    dwStgMode | STGM_CONVERT,
                    &pvcnTemp);

            if((STGTY_STREAM == statStg.type)           &&
               ((NULL == pvcnTemp)|| (STG_S_CONVERTED != hr)))
            {
                fPass = FALSE;
        
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enumerated stream element not converted")));

                break;
            }
            else
            {
                if(STGTY_STORAGE == statStg.type)
                {
                    if((NULL == pvcnTemp) && (STG_E_FILEALREADYEXISTS == hr))
                    {
                        // Expected result/condition, reset hr to S_OK

                        hr = S_OK;

                        // Delete the temp string

                        if(NULL != ptszStatStgName)
                        {
                            delete ptszStatStgName;
                            ptszStatStgName = NULL;
                        }

                        if ( NULL != statStg.pwcsName)
                        {
                            pMalloc->Free(statStg.pwcsName);
                            statStg.pwcsName = NULL;
                        }

                        continue;
                    }
                    else
                    {
                        fPass = FALSE;
        
                        DH_TRACE((
                            DH_LVL_TRACE1,
                            TEXT("Enum storage didn't return exp error")));

                        break;
                    }
                }
            }
        }
  
        // Delete the temp string

        if(NULL != ptszStatStgName)
        {
            delete ptszStatStgName;
            ptszStatStgName = NULL;
        }

        if(STG_S_CONVERTED == hr)
        {
            // If it comes here and hr is STG_S_CONVERTED, rest hr to S_OK.

            hr = S_OK;
        }
 
        // Commit the newly converted storage

        if(S_OK == hr)
        {
            hr = pvcnTemp->Commit(STGC_DEFAULT);

            if(S_OK != hr)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("IStg::Commit failed, hr=0x%lx"), hr));
                break;
            }
        }

        // Enumerate this converted storage

        if(S_OK == hr)
        {
            hr = pvcnTemp->EnumElements(0, NULL, 0, &penumWalkConv);

            if(S_OK != hr)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("IStg::EnumElem fail, hr=0x%lx"), hr));
                break;
            }
        }
        
        // Check the elements in conv storage.  There should be only one 
        // stream with name CONTENTS in this converted storage. If otherwise,
        // it is an error.

        cElementsInConvStg = 0;
        while(S_OK == hr && S_OK == penumWalkConv->Next(1, &statStgConv, NULL))
        {
            cElementsInConvStg++;

            // Convert statStg.pwcsName to TCHAR

            hr = OleStringToTString(statStgConv.pwcsName, &ptszStatStgConvName); 

            if(S_OK == hr)
            {
                if((STGTY_STREAM != statStgConv.type) ||
                    (0 != _tcscmp(STG_CONVERTED_NAME, ptszStatStgConvName)))
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Conv stg contains other than CONTENTS stm.")));
            
                    fPass = FALSE;
                    break;
                }


                pvsnTempConv = pvcnTemp->GetFirstChildVirtualStmNode();

                while((NULL != pvsnTempConv) &&
                      (0 != _tcscmp(
                                ptszStatStgConvName, 
                                pvsnTempConv->GetVirtualStmNodeName())))
                {
                    pvsnTempConv = pvsnTempConv->GetFirstSisterVirtualStmNode();
                }

                DH_ASSERT(NULL != pvsnTempConv);
            }
 
            // Open the stream and Read its contents

            if(S_OK == hr)
            {
                hr = pvsnTempConv->Open(NULL, STGM_SHARE_EXCLUSIVE|STGM_READ,0);
            }
 
            if(S_OK == hr)
            {
                hr = ReadAndCalculateDiskCRCForStm(pvsnTempConv,&dwActCRC);
            }

            // Delete the temp string

            if(NULL != ptszStatStgConvName)
            {
                delete ptszStatStgConvName;
                ptszStatStgConvName = NULL;
            }

            // Release name

            if ( NULL != statStg.pwcsName)
            {
                pMalloc->Free(statStgConv.pwcsName);
                statStgConv.pwcsName = NULL;
            }
        }

        // Release penumWalkConv

        if(NULL != penumWalkConv)
        {
            ulRef = penumWalkConv->Release();
            DH_ASSERT(0 == ulRef);
            penumWalkConv = NULL;
        }

        // Close child

        if(S_OK == hr)
        {
            hr = pvcnTemp->Close();

            if(S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VCN::Close failed unexp, hr=0x%lx"),
                    hr));
                break;
            }
        }

        // Verify that converted storage has only one CONTENTS stream in it

        if(1 != cElementsInConvStg)
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Convert stg has other elements besides CONTENTS stm")));
            
            fPass = FALSE;
            break;
        }
        
        // Verify that CRC's match of original stream and CONTENTS stream in
        // this converted storage

        if(dwMemCRC.dwCRCData == dwActCRC.dwCRCData)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC of org stm and CONTENTS stm in conv stg match")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC org stm and CONTENTS stm in convstg don't match")));
            fPass = FALSE;
            break;
        }

        // Release name

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }
    }

    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_101 
//
// synopsis: A random root DF is created with random number of storages/streams
//       committed/close/reopened. An enumerator is obtained in random chunks 
//       and the child objects found are counted.  The hierarchy is recursed 
//       into so that all objects in the docfile are counted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  23-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LINEXT.CXX
// 2.  Old name of test : LegitInstEnumNext Test 
//     New Name of test : ENUMTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-101
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cEnumStg                = 0;
    ULONG           cEnumStm                = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Next in Random chunks and verify ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Find the total number of elements in the DocFile

    if(S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cTotalStg, &cTotalStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Reopen the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    //  The named docfile/IStorage is instantiated and an enumerator
    //  is obtained.  The docfile is walked in random chunks and each
    //  contained IStorage/IStream is counted.  If the object returned
    //  by ->Next() is an IStorage, it is recursed into and processed.

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }
 
    // Enumerate the DocFile in Random chunks

    if(S_OK == hr)
    {
        hr = EnumerateDocFileInRandomChunks(
                pVirtualDFRoot,
                pdgi,
                dwStgMode,
                cTotalStg+cTotalStm,
                &cEnumStg,
                &cEnumStm);

        DH_HRCHECK(hr, TEXT("EnumerateDocFileInRandomChunks")) ;
    }

    // Verify results

    if(S_OK == hr)
    {
        if(cEnumStg == cTotalStg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Storages enum by IEnum::Next in rand chunks as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Storages enum by IEnum::Next in rand chunks not exp")));
           
            fPass = FALSE;
        } 

        if(cEnumStm == cTotalStm)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Streams enum by IEnum::Next in rand chunks as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Streams enum by IEnum::Next in rand chunks not exp")));
           
            fPass = FALSE;
        } 
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_102 
//
// synopsis: A random root DF is created with random number of storages/streams
//       committed/close/reopened. An enumerator is obtained and docfile enum-
//       erated.  A clone is made of enumerator. The clone uses Reset/Skip/Next
//       methods of enumerator to verify each of the objects found through the
//       original enumerator to see that it is the same.  All child objects 
//       found are counted and the hierarchy is recursed into so that all 
//       objects in the docfile are counted. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  24-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LISKIP.CXX
// 2.  Old name of test : LegitInstEnumSkip Test 
//     New Name of test : ENUMTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-102
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cEnumStg                = 0;
    ULONG           cEnumStm                = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Clone/Reset/Skip/Next ops verify ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    //BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Find the total number of elements in the DocFile

    if(S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cTotalStg, &cTotalStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Reopen the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    //  The named docfile/IStorage is instantiated and an enumerator
    //  is obtained. The docfile is enumerated all objects at one level.
    //  A clone is made of the enumerator, and it uses reset/skip/next
    //  methods of enumerator to verify each of the child objects found.  
    //  Each contained IStorage/IStream is counted.  If the object returned
    //  by ->Next() is an IStorage, it is recursed into and processed.

    if(S_OK == hr)
    {
        hr = EnumerateDocFileAndVerifyEnumCloneResetSkipNext(
                pVirtualDFRoot,
                dwStgMode,
                cTotalStg+cTotalStm,
                &cEnumStg,
                &cEnumStm);

        DH_HRCHECK(hr, TEXT("EnumerateDocFileInRandomChunks")) ;
    }

    // Verify results

    if(S_OK == hr)
    {
        if(cEnumStg == cTotalStg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stg enum by org and clone/reset/skip/next as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stg enum by org and clone/reset/skip/next notas exp")));
           
            fPass = FALSE;
        } 

        if(cEnumStm == cTotalStm)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stm enum by org and clone/reset/skip/next as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stm enum by org and clone/reset/skip/next notas exp")));
           
            fPass = FALSE;
        } 
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_103 
//
// synopsis: A random root DF is created with random number of storages/streams
//          committed/close/reopened. 
//          From 4 to 8 times, the root IStorage (docfile) is instantiated and
//          an enumerator is obtained.  A Stat call is made on the the IStorage
//          and then the IStorage is enumerated.  About 10% of the time
//          the current object is either destroyed, renamed, or modified.
//          Once every 1 to 64 objects is enumerated, a new IStorage (33%)
//          or IStream (66%) is created in the parent IStorage.  If an object
//          was destroyed, renamed, changed, or added, the parent IStorage is
//          committed 50% of time. If the current object returned by the 
//          enumerator is an IStorage (that wasn't deleted), the test recurses 
//          and repeats the above for that IStorage.  Then 33% of time, the
//          storage is reverted, 66% committed.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  30-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LITERMOD.CXX
// 2.  Old name of test : LegitInstEnumIterMod Test 
//     New Name of test : ENUMTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:ENUMTEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:ENUMTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:ENUMTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-103
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPSTORAGE       pIStorage               = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    UINT            cRandomMinVars          = 4;
    UINT            cRandomMaxVars          = 8;
    UINT            cRandomVars             = 0;
    UINT            cRandomAction           = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Next docfile,Create/Change/Commit/Revert elem")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate random number of variations that would be performed.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cRandomVars, cRandomMinVars, cRandomMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    } 

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    while((0 != cRandomVars--) && (S_OK == hr))
    {
        // Generate Random number to see whether changes would be reverted/
        // committed at end of lop.  If need to be reverted, then make a 
        // copy of VirtualDF which can be used later on

        usErr = pdgi->Generate(&cRandomAction, 0, 3);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        // Reopen the Root Docfile.

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->OpenRoot(
                    NULL,
                    dwRootMode, 
                    NULL,
                    0);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        }

        if (S_OK == hr)
        {
            pIStorage = pVirtualDFRoot->GetIStoragePointer();
        
            DH_ASSERT(NULL != pIStorage);
        }

        //  The named docfile/IStorage is instantiated and an enumerator
        //  is obtained.  The docfile is walked by getting or skipping 
        //  random number of elements.  If the child object got is a storage,
        // it is recursed into

        // Enumerate and walk DocFile by randomly getting/skipping random elem
        // -ents. 

        if(S_OK == hr)
        {
            hr = EnumerateAndProcessIStorage(
                    pIStorage,
                    dwStgMode,
                    pdgi,
                    pdgu);

            DH_HRCHECK(hr, TEXT("EnumerateAndProcessIStorage")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndProcessIStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndProcessIStorage unsuccessful, hr=0x%lx."),
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Close();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_103 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_104 
//
// synopsis: A random root DF is created with random number of storages/streams
//          committed/close/reopened. From 4 - 8 times, the root DocFile is
//          instantiated and an enumerator is obtained. The root docfile is
//          walked by getting or skipping a random number of elements and if
//          child element got is a child storage, recursing into it.  There is
//          33% chance of skipping elements and 67% chance of getting them. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  29-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LIWALK.CXX
// 2.  Old name of test : LegitInstEnumWalk Test 
//     New Name of test : ENUMTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-104
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    UINT            cRandomMinVars          = 4;
    UINT            cRandomMaxVars          = 8;
    UINT            cRandomVars             = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_104 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Next/Skip randomly to walk DocFile ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    //BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Find the total number of elements in the DocFile

    if(S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cTotalStg, &cTotalStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate random number of variations that would be performed.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cRandomVars, cRandomMinVars, cRandomMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    } 

    while(0 != cRandomVars--)
    {
        // Reopen the Root Docfile.

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->OpenRoot(
                    NULL,
                    dwRootMode, 
                    NULL,
                    0);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        }

        //  The named docfile/IStorage is instantiated and an enumerator
        //  is obtained.  The docfile is walked by getting or skipping 
        //  random number of elements.  If the child object got is a storage,
        // it is recursed into

        // Enumerate and walk DocFile by randomly getting/skipping random elem
        // -ents. 

        if(S_OK == hr)
        {
            hr = EnumerateAndWalkDocFile(
                    pVirtualDFRoot,
                    pdgi,
                    dwStgMode,
                    cTotalStg+cTotalStm);

            DH_HRCHECK(hr, TEXT("EnumerateAndWalkDocFile")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndWalkDocFile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndWalkDocFile unsuccessful, hr=0x%lx."),
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Close();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\flattsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:      flattsts.cxx
//
//  Contents:  miscellaneous tests for flatfile storage
//
//  Functions:  
//
//  History:    22-Jan-1998    BogdanT created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

// for non _OLE_NSS_, funcs are stubbed out below
#ifdef _OLE_NSS_

//----------------------------------------------------------------------------
//
// Test:    FLATTEST_100 
//
// Synopsis: Check if STGM_CREATE flag is NOT returned by IStorage::Stat
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
//  History:    22-Jan-1998    BogdanT created
//
// Notes:    To run the test, do the following at command prompt:
//           stgbase /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100
//           /dfRootMode:dirReadWriteShEx /createas:flatfile
//
//-----------------------------------------------------------------------------

HRESULT FLATTEST_100(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DWORD           dwRootMode                  = 0;
    STATSTG         statStg;    

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("FLATTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Check if IStorage::Stat does NOT return STGM_CREATE flag")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for FLATTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if(statStg.grfMode & STGM_CREATE)
    {
        hr = E_FAIL;
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Stat returned STGM_CREATE"),
           hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation FLATTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation FLATTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

#else
HRESULT FLATTEST_100(int argc, char *argv[]) { return E_NOTIMPL; }
#endif //_OLE_NSS_

// for non _OLE_NSS_, funcs are stubbed out below
#ifdef _OLE_NSS_

//----------------------------------------------------------------------------
//
// Test:    FLATTEST_101 
//
// Synopsis: Check that a real docfile (created with STGFMT_DOCFILE can't be 
//           opened as a flatfile with STGFMT_FILE). 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  19/3/98    Narindk     created
//
// Notes:    To run the test, do the following at command prompt:
//           stgbase /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:FLATTEST-101
//           /dfRootMode:dirReadWriteShEx  /dfname:FLATTEST101
//
//          This test tries to open a docfile as a flatfile.  In test DFTEST106
//          vice versa of this is tested already.  It is allowed to open a
//          flatfile as a docfile, but not vice versa.
//
//-----------------------------------------------------------------------------

HRESULT FLATTEST_101(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    HRESULT         hr2                         = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode                  = 0;
    LPSTORAGE       pIStorageOpen               = NULL;
    LPOLESTR        poszFileName                = NULL;
    DWORD           reserved                    = 0; 

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("FLATTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Check a docfile (STGFMT_DOCFILE) cant be opened as flatfile")));

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    // GetRootDocFile mode

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_106, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name

    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName = 
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
        }
        else
        {
            DH_ASSERT(!"No DocFile name passed from cmd line!") ;
        }

        DH_HRCHECK(hr, TEXT("pTestChanceDF->GetDocFileName()")) ;
    }

    if(S_OK == hr)
    {
        // Convert DocFile name to OLECHAR

        hr = TStringToOleString(pRootDocFileName,&poszFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Root docfile name %s."), poszFileName));
    }

    if(S_OK == hr)
    {
        hr = StgCreateStorageEx (
                poszFileName,
                dwRootMode | STGM_CREATE,
                STGFMT_DOCFILE,  //force it to be a docfile
                0,
                NULL, 
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);

        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("StgCreateStorageEx (df); mode=%#lx; hr=%#lx"), dwRootMode,hr));

        if(NULL != pIStorageOpen)
        {
            pIStorageOpen->Release();
            pIStorageOpen = NULL;
        }
    }

    // Open the above doc file as docfile, should succeed

    if(S_OK == hr)
    {
        hr = StgOpenStorageEx (
                poszFileName,
                dwRootMode,
                STGFMT_DOCFILE,  //open as docfile
                0,
                NULL,
                NULL,                
                IID_IStorage,
                (void**)&pIStorageOpen);

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgOpenStorageEx on docfile as docfile;mode=%#lx; hr=%#lx"), 
            dwRootMode, hr)); 

        if(S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx failed unexp, hr=0x%lx ."),
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx passed  as exp, hr=0x%lx ."),
                hr));
        }

        if(NULL != pIStorageOpen)
        {
            pIStorageOpen->Release();
            pIStorageOpen = NULL;
        }
    }

    // Now open above docfile as a flatfile

    if(S_OK == hr)
    {
        hr = StgOpenStorageEx (
                poszFileName,
                dwRootMode,
                STGFMT_FILE,  //force it to be a flatfile
                0,
                NULL,
                NULL,                
                IID_IStorage,
                (void**)&pIStorageOpen);

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgOpenStorageEx as flatfile on docfile;mode=%#lx; hr=%#lx"), 
            dwRootMode, hr)); 

        // BUGBUG: Check what expected error code from this?  We are getting
        // invalid argument as of present.  Have raided bug to come with a
        // uniform error for handling of mismatched format rejection -
        // e.g a docfile being opened as NSS file returns file already exists
        // error and a docfile being opene as flatfile returns invalid arg 
        // Change this with what the outcome of the bug is
 
        if(S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx as NFF on DF failed as exp, hr=0x%lx ."),
                hr));
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx as NFF on DF passed unexp, hr=0x%lx ."),
                hr));
            hr = E_FAIL;
        }

        if(NULL != pIStorageOpen)
        {
            pIStorageOpen->Release();
            pIStorageOpen = NULL;
        }
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation FLATTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation FLATTEST_101 failed, hr = 0x%lx."),
            hr) );
    }


    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    // Delete temp string

    if(NULL != poszFileName)
    {
        delete poszFileName;
        poszFileName = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete temp string

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    return hr;
}

#else
HRESULT FLATTEST_101(int argc, char *argv[]) { return E_NOTIMPL; }
#endif //_OLE_NSS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\hglbtst.cxx ===
/********************************************************************/
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       hglbtest.cxx
//
//  Contents:   HGlobal Test Cases
//
//  Functions:  HGLOBALTEST_100
//              HGLOBALTEST_110
//              HGLOBALTEST_120
//              HGLOBALTEST_130
//              HGLOBALTEST_140
//              HGLOBALTEST_150
//
//  Classes:    None
//
//  History:    31-JULY-1996        T-ScottG        Created
//              27-Mar-97           SCousens        Conversionified
//
/********************************************************************/


#include <dfheader.hxx>
#pragma hdrstop 

#include <debdlg.h>
#include "init.hxx"


/********************************************************************/
//
//  Function:  HGLOBALTEST_100
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an ILockByte Interface on top of the HGlobal (set so 
//             that the ILockBytes will not delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the ILockBytes interface, and then releases it.
//
//             The Test repeats the above sequence (always using the same 
//             HGlobal) a random number of times.  Finally, the HGlobal is 
//             deleted and the test exits.
//
//  Arguments: [ulSeed]     -       Randomizer Seed  
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-100 NO - not supported in nss
//
/********************************************************************/

HRESULT HGLOBALTEST_100 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HANDLE                      hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    ILockBytes *                pILockBytes         =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0; 
    USHORT                      usErr               =           0;
    ULARGE_INTEGER              li;
   
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_100"));
    

    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_100 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of ILockBytes iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {

            // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will not be 
            // deleted when ILockBytes is released)

            // Mac porting: CreateILockBytesOnHGlobal does not accept HGLOBAL,
            //              only OleHandle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }
            
            if (S_OK == hr)
            {
                hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                                FALSE,
                                                &pILockBytes );

                DH_HRCHECK(hr, TEXT("CreateILockBytesOnHGlobal Failed"));
            }


            // Obtain HGlobal pointer from ILockBytes

            if (S_OK == hr)
            {
                hr = GetHGlobalFromILockBytes( pILockBytes, 
                                               &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromILockBytes Failed"));
            }

            // Verify that the memory location that GetHGlobalFromILockBytes
            // returned is the same as the memory location passed to 
            // CreateILockBytesOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }

            
            // Set the size of the ILockBytes Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pILockBytes);
                

                // Assign 1/2 of the ILockBytes final size to Large Integer 
                // Structure.  (Note: this is so that the ILockBytes will still
                // have to automatically increase its size during WriteAt 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pILockBytes->SetSize(li);
                DH_HRCHECK(hr, TEXT("pILockBytes->SetSize Failed"));
            }


            // Call the ILockBytesWriteTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesWriteTest(pILockBytes, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesWriteTest Failed"));
            }


            // Call the ILockBytesReadTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesReadTest(pILockBytes, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesReadTest Failed"));
            }


            // Release ILockBytes

            if (NULL != pILockBytes)
            {
                uRet = pILockBytes->Release();
                DH_ASSERT(0 == uRet);
        
                pILockBytes = NULL;
            }


            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Free HGLOBAL From memory

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != hGlobMem);

        if (NULL != GlobalFree(hGlobMem))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalFree Failed"));
        }
        else
        {
            hGlobMem = NULL;
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_100 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_100 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_110
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an ILockBytes Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the ILockBytes interface, and then releases it.
//
//             The Test repeats the above sequence a random number of 
//             times.  
//
//             Note: This test differs from HGLOBAL_100 in that the
//             HGLOBAL is freed by the ILockBytes Interface when it is 
//             released.  It does not re-use the same HGLOBAL when 
//             multiple ILockBytes are created.
//
//  Arguments: [dwSize]           - Num of Bytes to Write to ILockBytes
//             [dwNumIterations]  - Num of ILockBytes Interfaces to 
//                                  be created on the same HGlobal
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-110 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_110 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    ILockBytes *                pILockBytes         =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0;
    ULARGE_INTEGER              li;
    USHORT                      usErr               =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_110"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_110 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of ILockBytes iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {

            // Allocate HGLOBAL memory

            if (S_OK == hr)
            {
                hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                         GMEM_MOVEABLE, 
                                         dwSize );

                if (NULL == hGlobMem)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
                }
            }


            // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will not be 
            // deleted when ILockBytes is released)

            // Mac porting: CreateILockBytesOnHGlobal does not accept HGLOBAL,
            //              only OleHandle, so first convert the handle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }

            if (S_OK == hr)
            {
                hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                                TRUE,
                                                &pILockBytes );

                DH_HRCHECK(hr, TEXT("CreateILockBytesOnHGlobal Failed"));
            }


            // Obtain HGlobal pointer from ILockBytes

            if (S_OK == hr)
            {
                hr = GetHGlobalFromILockBytes( pILockBytes, 
                                               &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromILockBytes Failed"));
            }

            // Verify that the memory location that GetHGlobalFromILockBytes
            // returned is the same as the memory location passed to 
            // CreateILockBytesOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }


            // Set the size of the ILockBytes Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pILockBytes);
                

                // Assign 1/2 of the ILockBytes final size to Large Integer 
                // Structure.  (Note: this is so that the ILockBytes will still
                // have to automatically increase its size during WriteAt 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pILockBytes->SetSize(li);
                DH_HRCHECK(hr, TEXT("pILockBytes->SetSize Failed"));
            }


            // Call the ILockBytesWriteTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesWriteTest(pILockBytes, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesWriteTest Failed"));
            }


            // Call the ILockBytesReadTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesReadTest(pILockBytes, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesReadTest Failed"));
            }


            // Release ILockBytes

            if (NULL != pILockBytes)
            {
                uRet = pILockBytes->Release();
                DH_ASSERT(0 == uRet);
        
                pILockBytes = NULL;
            }


            // Set hGlobMem to NULL (Note: the memory was freed when ILockBytes
            // was released

            hGlobMem = NULL;

      
            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_110 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_110 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_120
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will not delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the IStream interface, and then releases it.
//
//             The test repeats the above sequence (always using the same 
//             HGlobal) a random number of times.  Finally, the HGlobal 
//             is deleted and the test exits.
//
//  Arguments: [dwSize]           - Num of Bytes to Write to IStream
//             [dwNumIterations]  - Num of IStream Interfaces to 
//                                  be created on the same HGlobal
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-120 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_120 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    IStream *                   pIStream            =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0;
    ULARGE_INTEGER              li;
    USHORT                      usErr               =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_120"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_120 Seed: %d"), ulSeed));


    // Randomly calculate IStream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwSize, 
                               MIN_HGLOBAL_PACKETS, 
                               MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of IStream iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {

            // Create IStream on HGLOBAL. (Note: HGLOBAL will not be 
            // deleted when IStream is released)

            // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
            //              only OleHandle, so first convert the handle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }

            if (S_OK == hr)
            {
                hr = CreateStreamOnHGlobal( hOleGlobMem,
                                            FALSE,
                                            &pIStream );

                DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
            }

            // Obtain HGlobal pointer from IStream

            if (S_OK == hr)
            {
                hr = GetHGlobalFromStream( pIStream, 
                                           &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
            }

            // Verify that the memory location that GetHGlobalFromStream
            // returned is the same as the memory location passed to 
            // CreateStreamOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }


            // Set the size of the IStream Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pIStream);
                

                // Assign 1/2 of the IStream final size to Large Integer 
                // Structure.  (Note: this is so that the IStream will still
                // have to automatically increase its size during Write 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pIStream->SetSize(li);
                DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
            }


            // Call IStreamWriteTest

            if (S_OK == hr)
            {
                hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
            }


            // Call the  Test

            if (S_OK == hr)
            {
                hr = IStreamReadTest(pIStream, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamReadTest Failed"));
            }


            // Release IStream

            if (NULL != pIStream)
            {
                uRet = pIStream->Release();
                DH_ASSERT(0 == uRet);
        
                pIStream = NULL;
            }


            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Free HGLOBAL From memory

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != hGlobMem);

        if (NULL != GlobalFree(hGlobMem))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalFree Failed"));
        }
        else
        {
            hGlobMem = NULL;
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_120 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_120 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_130
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the IStream interface, and then releases it.
//
//             The Test repeats the above sequence a random number of
//             times.  
//
//             Note: This test differs from HGLOBAL_120 in that the
//             HGLOBAL is freed by the IStream Interface when it is 
//             released.  It does not re-use the same HGLOBAL when 
//             multiple IStreams are created.
//
//  Arguments: [dwSize]             - Num of Bytes to Write to IStream
//             [dwNumIterations]    - Num of IStream Interfaces to 
//                                    be created on the same HGlobal
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-130 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_130 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    IStream *                   pIStream            =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0;
    ULARGE_INTEGER              li;
    USHORT                      usErr               =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_130"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_130 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of IStream iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {
            // Allocate HGLOBAL memory

            if (S_OK == hr)
            {
                hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                         GMEM_MOVEABLE, 
                                         dwSize );

                if (NULL == hGlobMem)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
                }
            }


            // Create IStream on HGLOBAL. (Note: HGLOBAL will be 
            // deleted when IStream is released)

            // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
            //              only OleHandle, so first convert the handle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }

            if (S_OK == hr)
            {
                hr = CreateStreamOnHGlobal( hOleGlobMem,
                                            TRUE,
                                            &pIStream );

                DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
            }


            // Obtain HGlobal pointer from IStream

            if (S_OK == hr)
            {
                hr = GetHGlobalFromStream( pIStream, 
                                           &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
            }

            // Verify that the memory location that GetHGlobalFromStream
            // returned is the same as the memory location passed to 
            // CreateStreamOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }


            // Set the size of the IStream Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pIStream);
                

                // Assign 1/2 of the IStream final size to Large Integer 
                // Structure.  (Note: this is so that the IStream will still
                // have to automatically increase its size during Write 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pIStream->SetSize(li);
                DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
            }


            // Call IStreamWriteTest

            if (S_OK == hr)
            {
                hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
            }


            // Call IStreamReadTest

            if (S_OK == hr)
            {
                hr = IStreamReadTest(pIStream, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamReadTest Failed"));
            }


            // Release IStream.  (Note: HGlobal will be deleted with 
            // this call)

            if (NULL != pIStream)
            {
                uRet = pIStream->Release();
                DH_ASSERT(0 == uRet);
        
                pIStream = NULL;
            }


            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, 
            TEXT("HGLOBALTEST_130 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("HGLOBALTEST_130 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_140
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes a specified number of data
//             bytes to the IStream interface, and then clones it --
//             verifying that the new IStream interface contains the
//             same data as the origional.
//
//  Arguments: [dwSize]     -       Num of Bytes to Write to IStream
//
//  Returns:   HRESULT
//
//  History:   Created              T-ScottG                7/30/96
//
// BUGNOTE: Conversion: HGLOBALTEST-140 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_140 (ULONG ulSeed)
{
    HRESULT                     hr              =           S_OK;
    HGLOBAL                     hGlobMem        =           NULL;
    OleHandle                   hOleGlobMem     =           NULL;
    OleHandle                   hOleTempMem     =           NULL;
    IStream *                   pIStream        =           NULL;
    IStream *                   pIClone         =           NULL;
    ULONG                       uRet            =           0;
    DWORD                       dwSize          =           0;
    ULARGE_INTEGER              ulSize;
    LARGE_INTEGER               liSeek;
    USHORT                      usErr           =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_140"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_140 Seed: %d"), ulSeed));


    // Randomly calculate IStream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwSize, 
                               MIN_HGLOBAL_PACKETS, 
                               MAX_HGLOBAL_PACKETS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Create IStream on HGLOBAL. (Note: HGLOBAL will be 
    // deleted when IStream is released)

    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    if (S_OK == hr)
    {
        hr = CreateStreamOnHGlobal( hOleGlobMem,
                                    TRUE,
                                    &pIStream );

        DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
    }


    // Obtain HGlobal pointer from IStream

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pIStream, 
                                   &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromStream
    // returned is the same as the memory location passed to 
    // CreateStreamOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }


    // Set the size of the IStream Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pIStream);
                

        // Assign 1/2 of the IStream final size to Large Integer 
        // Structure.  (Note: this is so that the IStream will still
        // have to automatically increase its size during Write 
        // operations in which its size is overflowed)

        ULISet32(ulSize, (dwSize/2));


        hr = pIStream->SetSize(ulSize);
        DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
    }


    // Call IStreamWriteTest to fill Stream with data

    if (S_OK == hr)
    {
        hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
        DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
    }


    // Set Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        ULISet32(liSeek, 0);

        hr = pIStream->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }


    // Obtain clone of pIStream

    if (S_OK == hr)
    {
        hr = pIStream->Clone(&pIClone);
        DH_HRCHECK(hr, TEXT("IStream::Clone Failed"));
    }


    // Verify that the clone and the origional contain the same data

    if (S_OK == hr)
    {
        hr = IsEqualStream(pIStream, pIClone);
        DH_HRCHECK(hr, TEXT("IsEqualStream Failed"));
    }


    // Release IStream.  (Note: HGlobal will be deleted with 
    // this call)

    if (NULL != pIStream)
    {
        uRet = pIStream->Release();
        DH_ASSERT(0 == uRet);
        
        pIStream = NULL;
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, 
            TEXT("HGLOBALTEST_140 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("HGLOBALTEST_140 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_150
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes a specified number of data
//             bytes to the IStream interface, and then Copies it 
//             to a new IStream (also created using an HGLOBAL),
//             and verified that the new IStream interface contains 
//             the same data as the origional.
//
//  Arguments: [dwSize]     -   Num of Bytes to Write to IStream
//
//  Returns:   HRESULT
//
//  History:   Created          T-ScottG                7/30/96
//
// BUGNOTE: Conversion: HGLOBALTEST-150 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_150 (ULONG ulSeed)
{
    HRESULT                     hr                  =       S_OK;
    HGLOBAL                     hGlobOrigionalMem   =       NULL;
    HGLOBAL                     hGlobCopyMem        =       NULL;
    OleHandle                   hOleGlobOrigionalMem=       NULL;
    OleHandle                   hOleGlobCopyMem     =       NULL;
    OleHandle                   hOleTempMem         =       NULL;
    IStream *                   pIStream            =       NULL;
    IStream *                   pICopy              =       NULL;
    ULONG                       uRet                =       0;
    DWORD                       dwSize              =       0;
    ULARGE_INTEGER              ulSize;
    LARGE_INTEGER               liSeek;
    USHORT                      usErr               =       0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_150"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_150 Seed: %d"), ulSeed));


    // Randomly calculate IStream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory for Origional Stream

    if (S_OK == hr)
    {
        hGlobOrigionalMem = GlobalAlloc ( GMEM_NODISCARD | 
                                          GMEM_MOVEABLE, 
                                          dwSize );

        if (NULL == hGlobOrigionalMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Allocate HGLOBAL memory for the Copy of the Origional Stream

    if (S_OK == hr)
    {
        hGlobCopyMem = GlobalAlloc ( GMEM_NODISCARD | 
                                     GMEM_MOVEABLE, 
                                     dwSize );

        if (NULL == hGlobCopyMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }

    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobOrigionalMem, &hOleGlobOrigionalMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    // Create Origional IStream on HGLOBAL. (Note: HGLOBAL will be 
    // deleted when IStream is released)

    if (S_OK == hr)
    {
        hr = CreateStreamOnHGlobal( hOleGlobOrigionalMem,
                                    TRUE,
                                    &pIStream );

        DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
    }


    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobCopyMem, &hOleGlobCopyMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    // Create Copied IStream on HGLOBAL. (Note: HGLOBAL will be 
    // deleted when IStream is released)

    if (S_OK == hr)
    {
        hr = CreateStreamOnHGlobal( hOleGlobCopyMem,
                                    TRUE,
                                    &pICopy );

        DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
    }


    // Obtain HGlobal pointer from Origional IStream

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pIStream, 
                                   &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromStream
    // returned is the same as the memory location passed to 
    // CreateStreamOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobOrigionalMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }


    // Obtain HGlobal pointer from Copied IStream

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pICopy, 
                                   &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromStream
    // returned is the same as the memory location passed to 
    // CreateStreamOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobCopyMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }


    // Set the size of the Origional IStream Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pIStream);
                
        // Assign 1/2 of the IStream final size to Large Integer 
        // Structure.  (Note: this is so that the IStream will still
        // have to automatically increase its size during Write 
        // operations in which its size is overflowed)

        ULISet32(ulSize, (dwSize/2));


        hr = pIStream->SetSize(ulSize);
        DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
    }


    // Call IStreamWriteTest to fill Stream with data

    if (S_OK == hr)
    {
        hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
        DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
    }


    // Set Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        ULISet32(liSeek, 0);

        hr = pIStream->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }


    // Copy Origional Stream to Copied Stream

    if (S_OK == hr)
    {

        ULISet32(ulSize, dwSize);

        hr = pIStream->CopyTo(pICopy, ulSize, NULL, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Clone Failed"));
    }


    // Verify that the clone and the origional contain the same data

    if (S_OK == hr)
    {
        hr = IsEqualStream(pIStream, pICopy);
        DH_HRCHECK(hr, TEXT("IsEqualStream Failed"));
    }


    // Release IStream.  (Note: HGLOBAL will be deleted with 
    // this call)

    if (NULL != pIStream)
    {
        uRet = pIStream->Release();
        DH_ASSERT(0 == uRet);
        
        pIStream = NULL;
    }


    // Release pICopy.  (Note: HGLOBAL will be deleted with this call)

    if (NULL != pICopy)
    {
        uRet = pICopy->Release();
        DH_ASSERT(0 == uRet);

        pICopy = NULL;
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, 
            TEXT("HGLOBALTEST_150 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("HGLOBALTEST_150 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

/********************************************************************/
//
//  Function:  HGLOBALTEST_101
//
//  Synopsis:  Test which tries illegit tests on API's - CreateILockBytesOn
//             HGlobal and GetHGlobalFromILockBytes. 
// 
//  Arguments: [ulSeed]     -       Randomizer Seed  
//
//  Returns:   HRESULT
//
//  History:   Created     Narindk                8/21/96
//
//  Notes:     OLE BUGS: 54009, 54024.  Not in Automated run yet.
//
// BUGNOTE: Conversion: HGLOBALTEST-101 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_101 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    ILockBytes *                pILockBytes         =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    USHORT                      usErr               =           0;
    ULARGE_INTEGER              li;

    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_101"));
    

    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_101 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS,MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }

    // Mac porting: the next functions do not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    if (S_OK == hr)
    {
        // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will be 
        // deleted when ILockBytes is released)

        // Attempt illehgal out parameter for pILockBytes out param.

        hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                        TRUE,
                                        NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CreateILockBytesOnHGlobal failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1, 
               TEXT("CreateILockBytesOnHGlobal didn't fail as exp,hr=0x%lx"), 
               hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will be 
        // deleted when ILockBytes is released)

        hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                        TRUE,
                                        &pILockBytes );
    }

    // Obtain HGlobal pointer from ILockBytes

    if (S_OK == hr)
    {
        // Attempt illegal value for out Hglobal.

        hr = GetHGlobalFromILockBytes( pILockBytes, 
                                       NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromILockBytes failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromILockBytes didn't fail exp, hr=0x%lx"), 
                hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        hr = GetHGlobalFromILockBytes( pILockBytes, 
                                       &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromILockBytes Failed"));
    }

    // Verify that the memory location that GetHGlobalFromILockBytes
    // returned is the same as the memory location passed to 
    // CreateILockBytesOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }

            
    // Set the size of the ILockBytes Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pILockBytes);
                
        // Assign 1/2 of the ILockBytes final size to Large Integer 
        // Structure.  (Note: this is so that the ILockBytes will still
        // have to automatically increase its size during WriteAt 
        // operations in which its size is overflowed)

        ULISet32(li, (dwSize/2));

        hr = pILockBytes->SetSize(li);
        DH_HRCHECK(hr, TEXT("pILockBytes->SetSize Failed"));
    }


    // Release ILockBytes

    if (NULL != pILockBytes)
    {
        uRet = pILockBytes->Release();
        DH_ASSERT(0 == uRet);

        pILockBytes = NULL;
    }

    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_101 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_101 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

/********************************************************************/
//
//  Function:  HGLOBALTEST_121
//
//  Synopsis:  Test which tries illegit tests on API's - CreateStreamOn
//             HGlobal and GetHGlobalFromStream. 
// 
//  Arguments: [ulSeed]     -       Randomizer Seed  
//
//  Returns:   HRESULT
//
//  History:   Created     Narindk                8/21/96
//
//  Notes:     OLE BUGS: 54053, 54051.  Not in Automated run yet.
//
// BUGNOTE: Conversion: HGLOBALTEST-121 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_121 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    IStream *                   pIStream            =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    USHORT                      usErr               =           0;
    ULARGE_INTEGER              uliSize;

    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_121"));
    

    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_121 Seed: %d"), ulSeed));


    // Randomly calculate Stream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS,MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }
  
    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    if (S_OK == hr)
    {
        // Create Stream on HGLOBAL. 

        // Attempt illegal out parameter for pIStream out param.

        hr = CreateStreamOnHGlobal( hOleGlobMem,
                                    TRUE,
                                    NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CreateStreamOnHGlobal failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CreateStreamOnHGlobal didn't fail exp, hr=0x%lx"), 
                hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will be 
        // deleted when IStream is released)

        hr = CreateStreamOnHGlobal( hOleGlobMem,
                                    TRUE,
                                    &pIStream );
    }

    // Obtain HGlobal pointer from IStream

    if (S_OK == hr)
    {
        // Attempt illegal value for out Hglobal.

        hr = GetHGlobalFromStream(pIStream,  NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromStream failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromStream didn't fail exp, hr=0x%lx"), 
                hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pIStream, &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromILockBytes
    // returned is the same as the memory location passed to 
    // CreateILockBytesOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }

    // Set the size of the IStream Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pIStream);
                
        // Assign 1/2 of the IStream final size to Large Integer 
        // Structure.  (Note: this is so that the IStream will still
        // have to automatically increase its size during Write 
        // operations in which its size is overflowed)

        ULISet32(uliSize, (dwSize/2));

        hr = pIStream->SetSize(uliSize);
        DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
    }

    // Release Stream 

    if (NULL != pIStream)
    {
        uRet = pIStream->Release();
        DH_ASSERT(0 == uRet);

        pIStream = NULL;
    }

    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_121 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_121 Failed, hr = 0x%Lx"), hr));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\ilkbtsts.cxx ===
-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      ilkbtsts.cxx
//
//  Contents:  storage base tests basically pertaining to ILockBytes 
//
//  Functions:  
//
//  History:    31-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    Conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"
#include  "ilkbhdr.hxx"

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_100 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  31-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFLIB.CXX
// 2.  Old name of test : DfSetUpOnILockBytes Test 
//     New Name of test : ILKBTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-100 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-100 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-100 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-100 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgRootOnILockBytes    =   NULL;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Creating DocFile on ILockBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes passed as exp.")));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes failed unexp, hr = 0x%lx."),
            hr));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Get the original CRC of docfile 

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot1);

        hr = CalculateCRCForDocFile(pStgRoot1,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

        pStgRoot1 = NULL;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // ReOpen the root using StgOpenStorageOnILockBytes call.

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        hr = pVirtualDFRoot->OpenRootOnCustomILockBytes(
                NULL,
                dwRootMode,
                NULL,
                0,
                pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgOpenStorageOnILockBytes"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes failed unexp, hr = 0x%lx."),
            hr));
    } 

    // Get the CRC of docfile now after opening on custom ILockBytes

    if(S_OK == hr)
    {
        pStgRootOnILockBytes = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOnILockBytes);

        hr = CalculateCRCForDocFile(
                pStgRootOnILockBytes,
                VERIFY_INC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Release the pointer

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

        pStgRootOnILockBytes = NULL;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's match")));

            DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_100 passed.")) );
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's don't match")));

            DH_LOG((LOG_FAIL, TEXT("Test variation ILKBTEST_100 failed.")) );

            hr = E_FAIL;
        }
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_100 failed, hr=0x%lx."),
            hr) );
    }

    //BUGBUG: This may cause a leak. We may want to be releasing pTestILockBytesDF->_pCFileBytes
    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.
        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }
        
    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_101
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test opens the Asynchronous
//           docfile on ILockBytes
//
//           This test uses ASYNCHRONOUS API's to open the custom ILockBytes
//           by getting the IFillLockBytes based on custom ILockBytes and
//           then using appropraiet API calls.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  5-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: ADFLIB.CXX
// 2.  Old name of test : DfSetUpOnILockBytes Test 
//     New Name of test : ILKBTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-101 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-101 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-101 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-101 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_101(int argc, char *argv[])
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!!!!ILKBTEST_101 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!!!!To be investigateds")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgAsyncDocFile        = NULL;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    IFillLockBytes  *pIFillLockBytes        = NULL;
    CFileBytes      *pCFileBytesEmpty       = NULL;
    LPBYTE          pBuffer                 = NULL;
    ULONG           cbRead                  = 0;
    ULONG           cbWritten               = 0;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliOffset;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Opening Async DocFile on ILockBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Get the original CRC of docfile

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot1);

        hr = CalculateCRCForDocFile(pStgRoot1,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

        pStgRoot1 = NULL;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Now open this docfile on Async docfile API calls.

    // Get an empty ILockBytes

    if(S_OK == hr)
    {
        pCFileBytesEmpty = new CFileBytes;

        if(NULL == pCFileBytesEmpty)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // StgGetIFillLockBytesOnILockBytes expects an empty ILockBytes passed
    // to it.

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnILockBytes(
                pCFileBytesEmpty, 
                &pIFillLockBytes);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgGetIFillLockBytesOnILockBytes passed ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnILockBytes failed unexp, hr=0x%lx "),
            hr));
    }

    // Now copy from original ILockBytes into pIFillBytes

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;
        uli = pCFileBytes->GetSize();

        DH_ASSERT(0xFFFFFFFF != uli.LowPart);

        pBuffer = new BYTE [uli.LowPart];

        if(NULL == pBuffer)
        {
            hr = E_OUTOFMEMORY;
        }

        if(S_OK == hr)
        {
            memset(&uliOffset, 0, sizeof(ULARGE_INTEGER));

            hr = pCFileBytes->ReadAt(
                    uliOffset, 
                    (void *) pBuffer, 
                    uli.LowPart, 
                    &cbRead);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("ILockBytes::ReadAt passed as exp. ")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ILockBytes::ReadAt failed unexp, hr=0x%lx "),
                hr));
        }

        if(S_OK == hr)
        {
            hr = pCFileBytesEmpty->Init(
                    pVirtualDFRoot->GetVirtualCtrNodeName(),
                    OF_READWRITE);

            DH_HRCHECK(hr, TEXT("CFileBytes::Init")) ;
        }

        if(S_OK == hr)
        {
            hr = pIFillLockBytes->FillAppend(
                    (void *)pBuffer, 
                    cbRead, 
                    &cbWritten);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("IFillLockBytes::FillAppend passed as exp. ")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IFillLockBytes::FillAppend failed unexp, hr=0x%lx "),
                hr));
        }

        if(S_OK == hr)
        {
            // notify ILockBytes that all data is copied down

            hr = pIFillLockBytes->Terminate(FALSE);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("IFillLockBytes::Terminate passed as exp. ")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IFillLockBytes::Terminate failed unexp, hr=0x%lx "),
                hr));
        }
    }


    do
    {
        if(S_OK == hr)
        {
            hr = StgOpenAsyncDocfileOnIFillLockBytes(
                    pIFillLockBytes,
                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                    0, 
                    &pStgAsyncDocFile);
        }

        if(E_PENDING == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("E_PENDING")));
            Sleep(1000);
        }

    } while(E_PENDING == hr);

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1,TEXT("StgOpenAsyncDocfileOnIFillLockBytes passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenAsyncDocfileOnIFillLockBytes failed unexp,hr=0x%lx"),
            hr));
    }

    // Get the CRC of docfile now after opening on custom ILockBytes asynch-
    // ronously

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pStgAsyncDocFile,
                VERIFY_INC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Release the pointer

    if(NULL != pStgAsyncDocFile)
    {
        ulRef = pStgAsyncDocFile->Release();
        DH_ASSERT(0 == ulRef);
        pStgAsyncDocFile = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's match")));

            DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_101 passed.")) );
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's don't match")));

            DH_LOG((LOG_FAIL, TEXT("Test variation ILKBTEST_101 failed.")) );

            hr = E_FAIL;
        }
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_101 failed, hr=0x%lx."),
            hr) );
    }

    // Release pIFillLockBytes.  This also releases and deletes the underlying
    // pCFileBytesEmpty.  Check if behaiour expected. 

    if(NULL != pIFillLockBytes)
    {
        pIFillLockBytes->Release();
        DH_ASSERT(0 == ulRef);
        pIFillLockBytes = NULL;
    }

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
        pCFileBytes = NULL;
    }

    // Delete pBuffer

    if(NULL != pBuffer)
    {
        delete []pBuffer;
        pBuffer = NULL;
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_102 
//
// Synopsis: The test first creates a normal docfile  on OLE provided lockbytes
//          and CRC's it.
//          The root docfile is opened upon a special ILockBytes that contains
//          a method allowing the test to simulate write failure during commit.
//          The docfile is modified, simulated write failure is turned on, and
//          the docfile is committed.  The root docfile is then released,
//          reinstantiated, and CRC'd.  The CRCs should match which verifies
//          that no changed were made to the effective docfile contents
//          when the commit failed.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  31-July-1996     NarindK     Created.
//
// Notes:    This test runs in trannsacted and transacted deny write mode
//
// New Test Notes:
// 1.  Old File: LTCMFAIL.CXX
// 2.  Old name of test : LegitTransactedCommitFail Test 
//     New Name of test : ILKBTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-102 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-102 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-102 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCAct                = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - DocFile Commit fail test ")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Calulcate CRC on this DocFile

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pVirtualDFRoot->GetIStoragePointer(),
                VERIFY_INC_TOPSTG_NAME,
                &dwCRCOrg);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Make new ILockBytes

    if (S_OK == hr)
    {
        pCFileBytes = new CFileBytes();

        if(NULL == pCFileBytes)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Initialize new ILockBytes

    if (S_OK == hr)
    {
        hr = pCFileBytes->Init(
                pVirtualDFRoot->GetVirtualCtrNodeName(),
                OF_READWRITE);

        DH_HRCHECK(hr, TEXT("CFileBytes::Init")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("Custom ILockBytes create/init passed ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Custom ILockBytes create/init failed unexp, hr=0x%lx "),
            hr));
    }

    // ReOpen the root using StgOpenStorageOnILockBytes call.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRootOnCustomILockBytes(
                NULL,
                dwRootMode,
                NULL,
                0,
                pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgOpenStorageOnILockBytes"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes failed unexp, hr = 0x%lx."),
            hr));
    } 

    // Modify the DocFile

    if(S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF,
                pVirtualDFRoot,
                pTestVirtualDF->GetDataGenInteger(),
                pTestVirtualDF->GetDataGenUnicode(),
                dwStgMode,
                FALSE);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ModifyDocFile passed ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDocFile failed unexp, hr=0x%lx "),
            hr));
    }

    if(S_OK == hr)
    {
        pCFileBytes->FailWrite0(1);

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("Simulated failure during Commit in ILockBytes")));
    }

    // Commit

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
            
    if(STG_E_WRITEFAULT == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("VirtualCtrNode::Commit failed as exp, hr=0x%lx "),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit return unexp hr, hr=0x%lx "),
            hr));
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }
       
    // Open root agian
 
    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Open passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open failed unexp, hr=0x%lx "),
            hr));
    }

    // Calulcate CRC on this DocFile

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pVirtualDFRoot->GetIStoragePointer(),
                VERIFY_INC_TOPSTG_NAME,
                &dwCRCAct);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        if(dwCRCAct == dwCRCOrg)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's match. ")));

            DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_102 passed.")) );
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's don't match. ")));

            DH_LOG((LOG_FAIL, TEXT("Test variation ILKBTEST_102 failed.")) );

            hr = E_FAIL;
        }
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_102 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_103 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This tests attempts illegal opeartion
//           on custom ILockBytes based docfile.  It creates the custom Ilock
//           Bytes based docfile, then destroys the custom ILOckBytes and 
//           thereafter attempts to commit the DocFile
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  3-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52216
//
// New Test Notes:
// 1.  Old File:i -none- 
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-103 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-103 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-103 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-103 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Creating DocFile on ILockBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes passed as exp.")));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes failed unexp."),
            hr));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    if(NULL != pTestILockBytesDF->_pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);

        DH_TRACE((DH_LVL_TRACE1, TEXT("Destoryed custom ILockBytes")));
    }
        
    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release root and all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_103 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_104 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This tests attempts illegal opeartion
//           while tring to open asynchronously the docfile based on custom
//           ILockBytes 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  3-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52279
//
// New Test Notes:
// 1.  Old File: -none- 
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-104 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-104 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-104 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-104 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_104(int argc, char *argv[])
{

#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!ILKBTEST_104 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgAsyncDocFile        = NULL;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_104 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Creating DocFile on ILockBytes")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes passed as exp.")));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes failed unexp."),
            hr));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release root and all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Pass a invalid pointer in first parameter IFillLockBytes pointer. For
    // test case, we are passing NULL pointer.

    if(S_OK == hr)
    {
        hr = StgOpenAsyncDocfileOnIFillLockBytes(
                NULL,
                STGM_READ | STGM_SHARE_EXCLUSIVE,
                0,
                &pStgAsyncDocFile);
    } 

    if(STG_E_INVALIDPOINTER == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenAsyncDocfileOnIFillLockBytes failed exp, hr=0x%lx"),
            hr));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenAsyncDocfileOnIFillLockBytes returned unexp hr=0x%lx"),
            hr));
    }

    // Release the pointer

    if(NULL != pStgAsyncDocFile)
    {
        ulRef = pStgAsyncDocFile->Release();
        DH_ASSERT(0 == ulRef);
        pStgAsyncDocFile = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    if(NULL != pTestILockBytesDF->_pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        pCFileBytes = pTestILockBytesDF->_pCFileBytes;
        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }
        
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_105 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test opens the Asynchronous
//           docfile on ILockBytes
//
//           This test attempts illegal operation on StgGetIFillBytesOnILock
//           Bytes api call. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  6-Aug-1996     NarindK     Created.
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52513
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: - none -  
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-105 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-105 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-105 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-105 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_105(int argc, char *argv[])
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!ILKBTEST_105 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else

    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;
    IFillLockBytes  *pIFillLockBytes        = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_105 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes-Attempt illegal ops StgGetIFillBytesOnILOckBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Now open this docfile on Async docfile API calls.

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        hr = StgGetIFillLockBytesOnILockBytes(pCFileBytes, NULL);
    }

    if(S_OK != hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnILockBytes failed as exp hr = 0x%lx"),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnILockBytes passed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_105 failed, hr=0x%lx."),
            hr) );
    }

    // Release ILockBytes

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_106 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test opens the Asynchronous
//           docfile on ILockBytes
//
//           This test attempts illegal operation on StgGetIFillBytesOnILock
//           Bytes api call.  Test needs to be integrated with ILKBTEST_105
//           once the bugs are fixed. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  6-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52522
//
// New Test Notes:
// 1.  Old File: - none -  
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-106 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-106 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-106 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-106 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_106(int argc, char *argv[])
{

#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!ILKBTEST_106 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;
    IFillLockBytes  *pIFillLockBytes        = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_106 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes-Attempt illegal ops StgGetIFillBytesOnILOckBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Now get IFillLockBytes.

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        hr = StgGetIFillLockBytesOnILockBytes(NULL, &pIFillLockBytes);
    }

    /* Commented out becuase OLE passes this

    if(S_OK != hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnILockBytes failed as exp hr = 0x%lx"),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnILockBytes passed unexp, hr=0x%lx "),
            hr));
    }

    */

    if(S_OK == hr)
    {
        ulRef =   pIFillLockBytes->AddRef(); 
    }
 
    if(S_OK == hr)
    {
        ulRef =   pIFillLockBytes->Release(); 
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_106 failed, hr=0x%lx."),
            hr) );
    }

    // Release ILockBytes

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_107 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test calls StgIstorageILockBytes
//           API and tests it that ILockBytes array contains a storage object.
//           Also attempts illegal operations with StgIstorageILockBytes API.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  15-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: - none -  
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-107 /dfdepth:0-1 /dfstg:0-1 /dfstm:0-1
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-107 /dfdepth:0-1 /dfstg:0-1 /dfstm:0-1
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-107 /dfdepth:0-1 /dfstg:0-1 /dfstm:0-1
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-107 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_107(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_107"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_107 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes-Attempt StgIsStorageILockBytes ")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_107, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Call StgIsStorageILockBytes API

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        DH_ASSERT(NULL != pCFileBytes);

        hr = StgIsStorageILockBytes(pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgIsStorageILockBytes"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgIsStorageILockBytes passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgIsStorageILockBytes failed unexp, hr=0x%lx "),
            hr));
    }

    // Call StgIsStorageILockBytes API with NULL parameter

    if(S_OK == hr)
    {
        hr = StgIsStorageILockBytes(NULL);
    }

    if(STG_E_INVALIDPOINTER == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgIsStorageILockBytes failed as exp, hr=0x%lx. "),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgIsStorageILockBytes didn't failed as exp, hr=0x%lx "),
            hr));

        hr = E_FAIL;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_107 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_107 failed, hr=0x%lx."),
            hr) );
    }

    // Release ILockBytes

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    ILKBTEST_108 
//
// Synopsis: Legit/illegit Tests for StgGetIFillLockBytesOnFile OLE API.
//
// Arguments:[ulSeed]
//
// Returns:  HRESULT
//
// History:  16-Aug-1996     NarindK     Created.
//
// Notes:   
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// OLE BUG: 53647
//
// New Test Notes:
// 1.  Old File: -none- 
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /t:ILKBTEST-108
//
// BUGNOTE: Conversion: ILKBTEST-108 NO - not supported in nss
//
//-----------------------------------------------------------------------------


HRESULT ILKBTEST_108(ULONG ulSeed)
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!ILKBTEST_108 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else

    HRESULT         hr                      = S_OK;
    IFillLockBytes  *pIFillLockBytes        = NULL;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = NULL;
    LPTSTR          ptszRootDocFileName     = NULL;
    LPOLESTR        poszRootDocFileName     = NULL;
    ULONG           ulRef                   = 0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ILKBTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_108 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Attempt legit/illegit tests StgGetIFillLockBytesOnFile API")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Log the seed value

        usErr = pdgu->GetSeed(&ulSeed);
        DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);

        DH_TRACE((DH_LVL_TRACE1, TEXT("ILKBTEST_108 Seed: %lu"), ulSeed));
    }

    // StgGetIFillLockBytesOnFile called with null file name 

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnFile(NULL, &pIFillLockBytes);
    }

    // OLE creates a temp file name and will pass this call. Shuld return S_OK. 

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnFile passed as exp ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnFile failed as exp hr = 0x%lx"),
            hr));
    }

    if(S_OK == hr)
    {
        ulRef =   pIFillLockBytes->AddRef(); 

        ulRef =   pIFillLockBytes->Release(); 
    }

    // Release the pointer

    if(NULL != pIFillLockBytes)
    {
        ulRef = pIFillLockBytes->Release();
        DH_ASSERT(0 == ulRef);
        pIFillLockBytes = NULL;
    }

    // Generate a new RootDocFile name

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH,&ptszRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootDocFileName, &poszRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // StgGetIFillLockBytesOnFile called with non empty file name parameter
    // and valid out parameter.

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnFile( poszRootDocFileName, &pIFillLockBytes);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnFile passed as exp ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnFile failed unexp, hr=0x%lx"),
            hr));
    }

    // Release the pointer

    if(NULL != pIFillLockBytes)
    {
        ulRef = pIFillLockBytes->Release();
        DH_ASSERT(0 == ulRef);
        pIFillLockBytes = NULL;
    }

    // Delete string

    if(NULL != ptszRootDocFileName)
    {
        delete ptszRootDocFileName;
        ptszRootDocFileName = NULL;
    }

    if(NULL != poszRootDocFileName)
    {
        delete poszRootDocFileName;
        poszRootDocFileName = NULL;
    }

    // StgGetIFillLockBytesOnFile called with NULL second out parameter 
    // This should fail

    // Generate a new RootDocFile name

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH,&ptszRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootDocFileName, &poszRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnFile( poszRootDocFileName, NULL);
    }

    if(STG_E_INVALIDPOINTER == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnFile fail as exp, hr=0x%lx "),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnFile didn't failed as exp,hr=0x%lx"),
            hr));

        hr = E_FAIL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_108 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete string

    if(NULL != ptszRootDocFileName)
    {
        delete ptszRootDocFileName;
        ptszRootDocFileName = NULL;
    }

    if(NULL != poszRootDocFileName)
    {
        delete poszRootDocFileName;
        poszRootDocFileName = NULL;
    }

    // Delete datagen object

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
#endif //_MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\init.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       init.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  main 
//              ProcessCmdLine
//              RunAllTests
//              RunSingleTest
//              RunAllCOMTests
//              RunSingleCOMTest
//              RunAllDFTests
//              RunSingleDFTest
//              RunAllAPITests
//              RunSingleAPITest
//              RunAllROOTTests
//              RunSingleROOTTest
//              RunAllSTMTests
//              RunSingleSTMTest
//              RunAllSTGTests
//              RunSingleSTGTest
//              RunAllVCPYTests
//              RunSingleVCPYTest
//              RunAllIVCPYTests
//              RunSingleIVCPYTest
//              RunAllENUMTests
//              RunSingleENUMTest
//              RunAllIROOTSTGTests
//              RunSingleIROOTSTGTest
//              RunAllHGLOBALTests
//              RunSingleHGLOBALTest
//              RunAllSNBTests
//              RunSingleSNBTest
//              RunAllMISCTests
//              RunSingleMISCTest
//              RunAllILKBTests
//              RunSingleILKBTest
//              RunAllFlatTests
//              RunSingleFlatTest
//
//  History:    20-May-1996     NarindK     Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "init.hxx"

void    CheckCurrentDirectory (int argc, char *argv[]);
HRESULT ProcessCmdLine(int argc, char *argv[]) ;
HRESULT RunSingleTest(char *pszTestName, int argc, char *argv[]) ;
HRESULT RunAllTests(int argc, char *argv[]) ;

HRESULT RunAllCOMTests(int argc, char *argv[]);
HRESULT RunAllDFTests(int argc, char *argv[]);
HRESULT RunAllAPITests(int argc, char *argv[]);
HRESULT RunAllROOTTests(int argc, char *argv[]);
HRESULT RunAllSTMTests(int argc, char *argv[]);
HRESULT RunAllSTGTests(int argc, char *argv[]);
HRESULT RunAllVCPYTests(int argc, char *argv[]);
HRESULT RunAllIVCPYTests(int argc, char *argv[]);
HRESULT RunAllENUMTests(int argc, char *argv[]);
HRESULT RunAllIROOTSTGTests(int argc, char *argv[]);
HRESULT RunAllHGLOBALTests(int argc, char *argv[]);
HRESULT RunAllSNBTests(int argc, char *argv[]);
HRESULT RunAllMISCTests(int argc, char *argv[]);
HRESULT RunAllILKBTests(int argc, char *argv[]);
HRESULT RunAllFlatTests(int argc, char *argv[]);

HRESULT RunSingleCOMTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleDFTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleAPITest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleROOTTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleSTMTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleSTGTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleVCPYTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleIVCPYTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleENUMTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleIROOTSTGTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleHGLOBALTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleSNBTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleMISCTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleILKBTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleFlatTest(LONG lTestNum, int argc, char *argv[]);

// Debug object

DH_DEFINE ;

// Logs:  The log file would be stgbase.log

#define LOG_FILE_NAME "/t:stgbase"

// Misc

BOOL g_fDebugMode = FALSE ;
BOOL g_fFirstFailureExits = FALSE ;
BOOL g_fDebugBreakAtTestStart = FALSE ;
BOOL g_fRunAllMode = FALSE ;
BOOL g_fDoLargeSeekAndWrite = FALSE;
BOOL g_fUseStdBlk = FALSE ;
BOOL g_fRevert = FALSE;
BOOL g_fDeleteTestDF = TRUE;
UINT g_uOpenCreateDF = FL_DISTRIB_NONE;


// Help text
LPCTSTR lptszStgbaseUsage = {
    TEXT("StgBase command line options:\n")
    TEXT("   /t:{testname} - Run {testname} Test\n")
    TEXT("   /FFX          - First Failure Exits\n")
    TEXT("   /BTS          - Break at Test Start\n")
    TEXT("   /DM           - Debug Mode\n")
    TEXT("   /stdblock     - Use std block sizes\n")
    TEXT("   /lgseekwrite  - Do large seek and write\n")
    TEXT("   /revert       - Do revert instead of commit\n")
    TEXT("   /CWD:cwd      - Make cwd Current Directory\n")
};



//+-------------------------------------------------------------------
//  Function:  main 
//
//  Synopsis:  main for stgbase test suite 
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   -1 if main fails 
//
//  History:  20-May-1996   NarindK     Created 
//--------------------------------------------------------------------

#ifdef _MAC

int __stdcall WinMain(HINSTANCE hInstance, 
		      HINSTANCE hPrevInstance, 
		      LPSTR lpCmdLine, 
		      int nCmdShow)
{
    int argc;
    char **argv;
    // the pointer is used for retrieving the command line
    // from the Arguments file on Mac    
    LPSTR       lpszCmdLine = NULL;
    int         count;

#else

int __cdecl main(int argc, char *argv[])
{

#endif // _MAC

    HRESULT     hr          = S_OK;

    // Check if we should change CurrentDirectory, before creating the logfile
    CheckCurrentDirectory (argc, argv);

    // Initialize our log object
    DH_CREATELOGCMDLINE( LOG_FILE_NAME );
    hr = InitializeDebugObject();
    DH_ASSERT( S_OK == hr);

    if (DH_GETLOGLOC == DH_LOC_TERM)
    {
        DH_SETLOGLOC( DH_LOC_TERM | DH_LOC_LOG) ;
    }
    if (DH_GETTRACELOC == DH_LOC_TERM)
    {
        DH_SETTRACELOC( DH_LOC_TERM | DH_LOC_LOG) ;
    }

    // ProcessCmdLine() will run all the tests we
    // need to run...

    if (S_OK == hr)
    {

#ifdef _MAC

        lpszCmdLine = GetCommandLine();

        if(lpszCmdLine == NULL)
        {
            hr = E_FAIL;
            DH_LOG((LOG_INFO, TEXT("Failed to get the command line.\r")) ) ;
        }
         
        if(S_OK == hr)
        {
            hr = CmdlineToArgs(lpszCmdLine, &argc, &argv);
        }

#endif //_MAC

        // init our StgAPI wrapper - to determine whether we want to call
        //  StgAPIs or StgExAPIs for open/create.
        StgInitStgFormatWrapper (argc, argv);

        if(S_OK == hr)
        {
            hr = ProcessCmdLine(argc, argv) ;
        }
    }

    // Log our stats regarding how many tests passed, failed
    // aborted, etc, etc.

    DH_LOGSTATS ;

    // BUGBUG:  The following code that has been commented out reads from a
    // test.ini file and runs different tests as specified there.

    /*
    {
	int         targc       = 0;
	char        **targv     = NULL;
	ULONG       i           = 0;
	    char        buffer[256];
	    char        testName[20];

	for (;;)
	{
	    sprintf (testName, "Test%lu", i);

	    i++;

	    GetPrivateProfileStringA(
				"MyTests", 
								testName,  
								"Fail", 
								buffer, 
								sizeof(buffer), 
								"test.ini" );  

	    if(0 == strcmp(buffer, "EndTest"))
	    {
		break;
	    }
	
	    hr = CmdlineToArgs(buffer, &targc, &targv) ;

	    if(S_OK == hr)
	    {
		hr = RunTest(targc, targv);
	    }

	    // CmdlineToArgs allocates a bunch of strings and a table of
	    // pointers to them, so we need to free them.

	    if (NULL != targv)
	    { 
		for (i=0; i<targc; i++)
		{
		    delete targv[i] ;
		}

		delete [] targv ;
	    }

	    }
    }

    */  
 
    // End of commented code for reading from win.ini file.

#ifdef _MAC

    // cleanup for arguments strings
   if (NULL != argv)
   {
       for (count=0; count<argc; count++)
       {
	   delete argv[count] ;
       }

       delete [] argv ;
   }

#endif //_MAC
    
    return (int)hr;
}

//+-------------------------------------------------------------------
//  Function:  CheckCurrentDirectory 
//
//  Synopsis:  look at cmdline and if requested make CWD as specd
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   void
//
//  History:  27-Jul-1997   SCousens     Created 
//--------------------------------------------------------------------
void CheckCurrentDirectory (int argc, char *argv[])
{
    HRESULT   hr = S_OK;
    CBaseCmdlineObj Ccwd        (OLESTR("cwd"), 
            OLESTR("Make this Current Working Directory"), 
            OLESTR("none"));
    CBaseCmdlineObj *CArgList[] =
    {
        &Ccwd
    };
    CCmdline CCmdlineArgs(argc, argv);

    if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError())
    {
        hr = E_FAIL ;
    }

    if (S_OK == hr)
    {
        if (CMDLINE_NO_ERROR != CCmdlineArgs.Parse(CArgList,
                ARRAYSIZE (CArgList),
                FALSE))
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr && TRUE == Ccwd.IsFound ())
    {
        // Try changing current working directory
        LPTSTR  ptszCWD;
        HRESULT hr = OleStringToTString (Ccwd.GetValue(), &ptszCWD);
        if (S_OK == hr)
        {
            if (FALSE == SetCurrentDirectory (ptszCWD))
            {
                DH_TRACE ((DH_LVL_ERROR,
                        TEXT("SetCurrentDirectory to %s FAILED. hr=%#lx"),
                        ptszCWD,
                        HRESULT_FROM_WIN32 (GetLastError ())));
            }
            else
            {
                DH_TRACE ((DH_LVL_TRACE1,
                        TEXT("CurrentWorkingDirectory now:%s"),
                        ptszCWD));
            }
            delete ptszCWD;
            ptszCWD = NULL;
        }
    }
    return;
}


//+-------------------------------------------------------------------
//  Function:  RunTestAltPath 
//
//  Synopsis: -Look at cmdline for /altpath switch.
//            -If not found, call the specified test with NULL for
//             the alternate path - thus using cwd.
//            -If found with nothing specified, enumerate all local
//             drives and use the root of each drive as alternate.
//            -If found with drive letters specified, use the 
//             specified drive letters.
//            -Currently we only look at the 1st char, and ',;' are
//             the acceptible delimiters
//               eg: /altpath     enumerate and use all drives
//               eg: /altpath:c:;d,e  use C, D and E drives.
//
//  Arguments: [argc]
//             [argv]
//             [pfn]  - pointer to the test function to call
//
//  Returns:   HRESULT whatever the test returned.
//             If multiple tests ran, returns first error.
//
//  Notes:     The test functions must be modified to accept
//             a third parameter, and then optionally use 
//             it when creating a new file.
//
//  History:  14-Oct-1997   SCousens     Created 
//--------------------------------------------------------------------
HRESULT RunTestAltPath(int argc, char *argv[], 
        HRESULT (*pfnTestFunc) (int argc, char*argv[], LPTSTR ptAltPath))
{
    ULONG   ulDriveMap;
    TCHAR   szDrive[]  = {TEXT("C:\\")};
    HRESULT hr         = S_OK;
    HRESULT hrTest     = S_OK;
    LPTSTR  ptAltPath  = NULL;
    BOOL    fAltFound  = FALSE;
    
    DH_FUNCENTRY (&hr, DH_LVL_DFLIB, TEXT("RunTestAltPath"));

    // look for /altpath in commandline
    CBaseCmdlineObj Caltpath (OLESTR("AltPath"), 
            OLESTR("Use a different drive/path"), 
            OLESTR("none"));
    CBaseCmdlineObj *CArgList[] =
    {
        &Caltpath              // just for spewage
    };
    CCmdline CCmdlineArgs(argc, argv);

    ptAltPath = NULL;
    if (CMDLINE_NO_ERROR == CCmdlineArgs.QueryError())
    {
        if (CMDLINE_NO_ERROR ==
                CCmdlineArgs.Parse(CArgList, ARRAYSIZE(CArgList), FALSE))
        {
            if (Caltpath.IsFound ())
            {
                DH_TRACE ((DH_LVL_TRACE4, TEXT("/altpath option found on cmdline")));
                HRESULT hr = OleStringToTString (Caltpath.GetValue (), &ptAltPath);
                DH_HRCHECK (hr, TEXT("OleStringToTString"));
                fAltFound = TRUE;
            }
        }
    }

    // if altpath not on the cmdline, just call the test and bail.
    if (!fAltFound)
    {
        DH_TRACE ((DH_LVL_TRACE4, TEXT("no /altpath option. Using CWD")));
        hr = (*pfnTestFunc)(argc, argv, NULL);
        return hr;
    }

    //if altpath has something, get what we got.
    ulDriveMap = 0;
    if (NULL != ptAltPath)
    {
        // make upper case so math below is easier
        CharUpperBuff(ptAltPath, _tcslen(ptAltPath));
        LPTSTR ptr = _tcstok (ptAltPath, TEXT(";,"));
        // take string and fill DriveMap with specified drives
        while (NULL != ptr)
        {
            if (*ptr >= TCHAR('A') && *ptr <= TCHAR('Z'))
            {
                // c: -> 0x4, d: -> 0x8, e: -> 0x10
                ulDriveMap = ulDriveMap | (0x01 << (*ptr-TCHAR('C')));
                DH_TRACE ((DH_LVL_TRACE4, TEXT("Processed drive %C:"), *ptr));
            }
            ptr = _tcstok (NULL, TEXT(";,"));
        }
    }

    // if /altpath: not found, enum local disks and use them all.
    if (0 == ulDriveMap)
    {
        DH_TRACE ((DH_LVL_TRACE4, TEXT("Enumerating local drives")));
        ulDriveMap = EnumLocalDrives()>>2; //ignore A:, B:
    }
    DH_TRACE ((DH_LVL_TRACE4, TEXT("Drive map : %#x"), ulDriveMap));
    while (ulDriveMap)
    {
        if (ulDriveMap & 0x01)
        {
            DH_TRACE ((DH_LVL_TRACE4, TEXT("Testing to:%s"), szDrive));
            hrTest = (*pfnTestFunc)(argc, argv, szDrive);
            hr = FirstError (hr, hrTest);
        }
        ++*szDrive;
        ulDriveMap = ulDriveMap>>1;
    }

    // cleanup
    delete []ptAltPath;

    // return an error if any of the tests failed.
    return hr;
}

//+-------------------------------------------------------------------
//  Function:  ProcessCmdLine
//
//  Synopsis:  Analyzes the command line and takes appropriate action
//             depending on what is there.
//
//  Arguments: [argc]
//             [argv] -      The command line argument list.  Valid switches
//                            are:
//
//                            1.  /T:{string defining test num}
//
//                                For test num strings, see
//                                %ctolestg%\docs
//
//                                If no /T: switches are on the command
//                                line, all the tests are run.
//
//                                An unlimited number of tests can be
//                                specified on the command line using
//                                the /t: switches
//
//                            2.  /BTS - Break when each test starts
//
//                            3.  /DM  - Debug mode.  In debug mode, the
//                                       test DLL provides more debugging
//                                       information than normal about the
//                                       state of the tests.
//
//                            4.  /FFX - First test failure exits the test
//                                       suite
//
//                            5.  /stdblock - If standard block sizes from
//                                        array ausSIZE_ARRAY needs to be
//                                        used for test.
//
//                            6. /lgseekwrite - if large seek and write needs
//                                        to be done in test.
//
//                            7. /revert - Do revert operation in tests
//                                        instead of commit, if flag set.
//              
//                            NOTE: For OTHER valid switches, please
//                                  see documentation. 
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   20-May-1996   NarindK    Enhanced for stgbase test suite
//
//--------------------------------------------------------------------

HRESULT ProcessCmdLine(int argc, char *argv[])
{
    HRESULT     hr          = S_OK ;
    INT         i           = 0;
    INT         cTestsRun   = 0 ;
    INT         cParseErrors= 0 ;
    int         targc       = 0;
    char        **targv     = NULL;

    //
    // If we are running on DEBUG OLE, set the debug flag to TRUE
    //

    if (S_OK == RunningDebugOle())
    {
        g_fDebugMode = TRUE ;
    }

    //
    // First, check for any switches
    //

    if (S_OK == hr)
    {
        CBoolCmdlineObj Cbts        (OLESTR("BTS"),        OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Cffx        (OLESTR("FFX"),        OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Cdm         (OLESTR("DM"),         OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Chlp        (OLESTR("HELP"),       OLESTR("get help"), OLESTR("FALSE")) ;
        CBoolCmdlineObj Chelp       (OLESTR("?"),          OLESTR("get help"), OLESTR("FALSE")) ;
        CBoolCmdlineObj Cstdblk     (OLESTR("stdblock"),   OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Clgseekwrite(OLESTR("lgseekwrite"),OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Crevert     (OLESTR("revert"),     OLESTR(""), OLESTR("FALSE")) ;
        CBaseCmdlineObj COpenDF (OLESTR("Distrib"), 
                OLESTR("Distributed tests. Create/Open docfile"), 
                OLESTR("none"));
        // these are checked and dealt with in chancedf. look here so we can 
        // put some meaningful useful information into the log
        CBaseCmdlineObj Cmode (OLESTR("dfRootMode"), 
                OLESTR("Direct, Transacted modes"), 
                OLESTR("none"));
        CBaseCmdlineObj Ctest (OLESTR("t"), 
                OLESTR("Test name"), 
                OLESTR("none"));

        CBaseCmdlineObj *CArgList[] =
        {
            &Cmode,             // just for spewage
            &Ctest,             // just for spewage
            &COpenDF,           // 2 phase testing (conversion over redirector)
            &Cbts,              // Break at test start
            &Cffx,              // Break at first failure
            &Cdm,               // Debug mode
            &Chlp,              // Help
            &Chelp,             // display help?
            &Cstdblk,           // Standard block size
            &Clgseekwrite,      // Do large seek and write
            &Crevert            // Revert instead of committing 
        } ;

        CCmdline CCmdlineArgs(argc, argv);

        if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError())
        {
            hr = E_FAIL ;
        }

        if (S_OK == hr)
        {
            if (CMDLINE_NO_ERROR !=
                    CCmdlineArgs.Parse(
                    CArgList,
                    ( sizeof(CArgList) / sizeof(CArgList[0]) ),
                    FALSE))
            {
                hr = E_FAIL ;
            }

            if (S_OK == hr)
            {
                g_fDebugBreakAtTestStart = *(Cbts.GetValue()) ;
                g_fFirstFailureExits = *(Cffx.GetValue()) ;

                g_fDebugMode = FALSE;
                if (FALSE != *(Cdm.GetValue()))
                {
                    g_fDebugMode = TRUE ;
                }

                if (TRUE == Chelp.IsFound() || TRUE == Chlp.IsFound())
                {
                    // Help switch
                    // We are a console app. Dump to stdout.
                    // and debug window for good measure.
                    _tprintf (TEXT("%s\r\n"), lptszStgbaseUsage);
                    OutputDebugString ((LPTSTR)lptszStgbaseUsage);
                    _tprintf (TEXT("%s"), GetDebugHelperUsage());
                    OutputDebugString ((LPTSTR)GetDebugHelperUsage());
                    //
                    // If someone asked for help, don't run any
                    // of the tests
                    //
                    hr = S_FALSE ;
                }

                g_fUseStdBlk = FALSE;
                if (FALSE != *(Cstdblk.GetValue()))
                {
                    g_fUseStdBlk = TRUE ;
                }
                g_fDoLargeSeekAndWrite = FALSE;
                if (FALSE != *(Clgseekwrite.GetValue()))
                {
                    g_fDoLargeSeekAndWrite = TRUE ;
                }
                g_fRevert = FALSE;
                if (FALSE != *(Crevert.GetValue()))
                {
                    g_fRevert = TRUE ;
                }

                g_uOpenCreateDF = FL_DISTRIB_NONE;
                g_fDeleteTestDF = TRUE;
                if (TRUE == COpenDF.IsFound ())
                {
                    if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_DISTRIB_OPEN)))
                    {
                        g_uOpenCreateDF = FL_DISTRIB_OPEN;
                    }
                    else if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_DISTRIB_OPENNODELETE)))
                    {
                        g_uOpenCreateDF = FL_DISTRIB_OPEN;
                        g_fDeleteTestDF = FALSE;
                    }
                    else if (NULL ==_olestricmp (COpenDF.GetValue (), OLESTR(SZ_DISTRIB_CREATE)))
                    {
                        g_uOpenCreateDF = FL_DISTRIB_CREATE;
                    }
                }

#ifdef UNICODE  //dont bother with OleStringToTString if TString is ansi.
                // for spewage only
                if (TRUE == Ctest.IsFound () && TRUE == Cmode.IsFound ())
                {
                    DH_TRACE ((DH_LVL_ALWAYS, 
                            TEXT("Running %s in %s mode"), 
                            Ctest.GetValue(), 
                            Cmode.GetValue()));
                }
#endif
            }
        }
    }

    //
    // Start up the tests 
    //

    targc = argc;
    targv = argv;

    if (S_OK == hr)
    {
        for (i=0; i<argc; i++)
        {
            //
            // Switch must be in the form "{- | /}T:{test name}"
            //

            if ( ('/' != argv[i][0]) && ('-' != argv[i][0]) )
            {
                continue ;
            }

            if ( ('t' != argv[i][1]) && ('T' != argv[i][1]) )
            {
                continue ;
            }

            if (':' != argv[i][2])
            {
                continue ;
            }

            if (0 == argv[i][3])
            {
                cParseErrors++ ;
                continue ;
            }

            hr = RunSingleTest(&argv[i][3], targc, targv) ;

            // test failed. let the world know what tried to do
            if (S_OK != hr)
            {
                LPTSTR      lpszCmdLine = GetCommandLine();
                if(lpszCmdLine != NULL)
                {
                    DH_LOG((LOG_INFO, TEXT("CommandLine:%s"), lpszCmdLine ));
                }
            }

            if ( (S_OK != hr) && (FALSE != g_fFirstFailureExits) )
            {
                break ;
            }

            cTestsRun++ ;
        }
    }

    // If we did not find any tests to run and there were
    // no parse errors, then run all the tests
    //

    if (S_OK == hr)
    {
        g_fRunAllMode = FALSE;
        if ( (0 == cTestsRun) && (0 == cParseErrors) )
        {
            g_fRunAllMode = TRUE ;

            hr = RunAllTests(targc, targv) ;
        }
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllTests
//
//  Synopsis:  Runs all tests
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   28-Jul-1995   AlexE   Created
//             20-May-1996   NarindK Adapted for stgbase test suite
//--------------------------------------------------------------------

HRESULT RunAllTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    // Run "COM" tests

    hr = RunAllCOMTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    
    // Run "DF" tests

    hr = RunAllDFTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    
    // Run "API" tests

    hr = RunAllAPITests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "ROOT" tests

    hr = RunAllROOTTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "STM" tests

    hr = RunAllSTMTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "STG" tests

    hr = RunAllSTGTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "VCPY" tests

    hr = RunAllVCPYTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "IVCPY" tests

    hr = RunAllIVCPYTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "ENUM" tests

    hr = RunAllENUMTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "IROOTSTG" tests

    hr = RunAllIROOTSTGTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }


    // Run "HGLOBAL" tests

    hr = RunAllHGLOBALTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "SNB" tests

    hr = RunAllSNBTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "MISC" tests

    hr = RunAllMISCTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "FLAT" tests

    hr = RunAllFlatTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleTest
//
//  Synopsis:  Runs a single test
//
//  Arguments: [pszTestName] - The test name string.
//             [argc]
//             [argv] 
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   28-Jul-1995   AlexE   Created
//             20-May-1996   NarindK Adapted for stgbase test suite
//--------------------------------------------------------------------

HRESULT RunSingleTest(char *pszTestName, int argc, char *argv[])
{
    char *pszNum = NULL ;
    LONG lNum = -1 ;

    //
    // The test name should be in the form
    //
    //     "{description string}{-}{test number}"
    //

    pszNum = pszTestName ;

    while (0 != *pszNum)
    {
	if ('-' == *pszNum)
	{
	    *pszNum++ = 0 ;

	    break ;
	}

	pszNum++ ;
    }

    if (0 == *pszNum)
    {
        DH_LOG((LOG_INFO, TEXT("No test number in test name string")) ) ;
        return E_INVALIDARG ;
    }

    //
    // Now see if the test name part is one we recognize.
    // If it is, dispatch the test.
    //

    if (S_OK != PrivAtol(pszNum, &lNum))
    {
        DH_LOG((LOG_INFO, TEXT("Invalid number in test name string")) ) ;
        return E_INVALIDARG ;
    }

    if (0 == _strcmpi(pszTestName, "COMTEST"))
    {
        return RunSingleCOMTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "DFTEST"))
    {
        return RunSingleDFTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "APITEST"))
    {
        return RunSingleAPITest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "ROOTTEST"))
    {
        return RunSingleROOTTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "STMTEST"))
    {
        return RunSingleSTMTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "STGTEST"))
    {
        return RunSingleSTGTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "VCPYTEST"))
    {
        return RunSingleVCPYTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "IVCPYTEST"))
    {
        return RunSingleIVCPYTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "ENUMTEST"))
    {
        return RunSingleENUMTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "IROOTSTGTEST"))
    {
        return RunSingleIROOTSTGTest(lNum, argc, argv) ;
    }
    if (0 == _strcmpi(pszTestName, "HGLOBALTEST"))
    {
        return RunSingleHGLOBALTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "SNBTEST"))
    {
        return RunSingleSNBTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "MISCTEST"))
    {
        return RunSingleMISCTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "ILKBTEST"))
    {
        return RunSingleILKBTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "FLATTEST"))
    {
        return RunSingleFlatTest(lNum, argc, argv) ;
    }
    else
    {
        DH_LOG((LOG_INFO, TEXT("Invalid test name string")) ) ;
        return E_INVALIDARG ;
    }
}


//+-------------------------------------------------------------------
//  Function:  RunAllCOMTests
//
//  Synopsis:  Runs all "COM" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-May-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllCOMTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = COMTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllDFTests
//
//  Synopsis:  Runs all "DF" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   3-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllDFTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = DFTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Obtain Seed from CommandLine and call DFTEST_107

    ULONG  ulSeed  =  0;

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    hr = DFTEST_103(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_107(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }


    hr = DFTEST_108(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    
    hr = DFTEST_109(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllAPITests
//
//  Synopsis:  Runs all "API" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   18-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllAPITests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = APITEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllROOTTests
//
//  Synopsis:  Runs all "ROOT" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   24-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllROOTTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = ROOTTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllSTMTests
//
//  Synopsis:  Runs all "STM" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllSTMTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = STMTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_107(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_108(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_109(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllSTGTests
//
//  Synopsis:  Runs all "STG" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   10-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllSTGTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = STGTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_107(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_108(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_109(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_110(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllVCPYTests
//
//  Synopsis:  Runs all "VCPY" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   15-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllVCPYTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = VCPYTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllIVCPYTests
//
//  Synopsis:  Runs all "IVCPY" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   21-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllIVCPYTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = IVCPYTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IVCPYTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllENUMTests
//
//  Synopsis:  Runs all "ENUM" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   22-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllENUMTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = ENUMTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllIROOTSTGTests
//
//  Synopsis:  Runs all "IROOTSTG" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   25-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllIROOTSTGTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = IROOTSTGTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IROOTSTGTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IROOTSTGTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IROOTSTGTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunAllHGLOBALTests
//
//  Synopsis:  Runs all "HGLOBAL" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   25-July-1996   T-ScottG  Created 
//--------------------------------------------------------------------


HRESULT RunAllHGLOBALTests(int argc, char *argv[])
{
    HRESULT             hr              =           S_OK ;
    ULONG               ulSeed           =           0;
    INT                 cFailures       =           0;

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    hr = HGLOBALTEST_100(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    /* OLE bugs

    hr = HGLOBALTEST_101(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    hr = HGLOBALTEST_110(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = HGLOBALTEST_120(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    /* OLE bugs

    hr = HGLOBALTEST_121(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    */

    hr = HGLOBALTEST_130(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = HGLOBALTEST_140(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = HGLOBALTEST_150(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }


    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllSNBTests
//
//  Synopsis:  Runs all "SNB" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   26-July-1996   Jiminli Created
//--------------------------------------------------------------------

HRESULT RunAllSNBTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = SNBTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = SNBTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = SNBTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = SNBTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllMISCTests
//
//  Synopsis:  Runs all "MISC" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   5-Aug-1996   Jiminli Created
//--------------------------------------------------------------------

HRESULT RunAllMISCTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = MISCTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllILKBTests
//
//  Synopsis:  Runs all "ILKB" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   5-Aug-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllILKBTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = ILKBTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ILKBTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ILKBTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }


    /* OLE BUG : 52216

    hr = ILKBTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    /* OLE Bug 52279

    hr = ILKBTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    /* OLE Bug 

    hr = ILKBTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    /* OLE Bug 

    hr = ILKBTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    hr = ILKBTEST_107(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    /* OLE Bug 

    hr = ILKBTEST_108(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunAllFlatTests
//
//  Synopsis:  Runs all "FLAT" tests.  
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:    22-Jan-1998    BogdanT created
//--------------------------------------------------------------------

HRESULT RunAllFlatTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = FLATTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = FLATTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleCOMTest
//
//  Synopsis:  Runs single "COMTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-May-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleCOMTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = COMTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = COMTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = COMTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = COMTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = COMTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = COMTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = COMTEST_106(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid COMTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleDFTest
//
//  Synopsis:  Runs single "DFTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   3-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleDFTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;
    ULONG       ulSeed  =  0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = DFTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = DFTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = DFTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_103(ulSeed) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = DFTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = DFTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = DFTEST_106(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_107(ulSeed) ;

	    break ;
	}

	case ( 108 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_108(ulSeed) ;

	    break ;
	}

	case ( 109 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_109(ulSeed) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid DFTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleAPITest
//
//  Synopsis:  Runs single "APITEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   18-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleAPITest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = APITEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = APITEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = APITEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = APITEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = APITEST_104(argc, argv) ;

	    break ;
	}

    case 200:
    {
        hr = APITEST_200(argc, argv) ;
        break ;
    }

    case 201:
    {
        hr = APITEST_201(argc, argv) ;
        break ;
    }

    case 202:
    {
        hr = APITEST_202(argc, argv) ;
        break ;
    }

    case 203:
    {
        hr = APITEST_203(argc, argv) ;
        break ;
    }

    case 204:
    {
        hr = APITEST_204(argc, argv) ;
        break ;
    }

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid APITEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleROOTTest
//
//  Synopsis:  Runs single "ROOTTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   24-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleROOTTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = ROOTTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = ROOTTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = ROOTTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = ROOTTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = ROOTTEST_104(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid ROOTTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleSTMTest
//
//  Synopsis:  Runs single "STMTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleSTMTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = STMTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = STMTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = STMTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = STMTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = STMTEST_104(argc, argv) ;

	    break ;
	}

		case ( 105 ) :
	{
	    hr = STMTEST_105(argc, argv) ;

	    break ;
	}

		case ( 106 ) :
	{
	    hr = STMTEST_106(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    hr = STMTEST_107(argc, argv) ;

	    break ;
	}

		case ( 108 ) :
	{
	    hr = STMTEST_108(argc, argv) ;

	    break ;
	}

		case ( 109 ) :
	{
	    hr = STMTEST_109(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid STMTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleSTGTest
//
//  Synopsis:  Runs single "STGTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   10-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleSTGTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = STGTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = STGTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = STGTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = STGTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = STGTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = STGTEST_105(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    hr = STGTEST_107(argc, argv) ;

	    break ;
	}

	case ( 108 ) :
	{
	    hr = STGTEST_108(argc, argv) ;

	    break ;
	}

	case ( 109 ) :
	{
	    hr = STGTEST_109(argc, argv) ;

	    break ;
	}

	case ( 110 ) :
	{
	    hr = STGTEST_110(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid STGTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleVCPYTest
//
//  Synopsis:  Runs single "VCPYTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   15-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleVCPYTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = VCPYTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = VCPYTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = VCPYTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = VCPYTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = VCPYTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = VCPYTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = VCPYTEST_106(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid VCPYTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleIVCPYTest
//
//  Synopsis:  Runs single "IVCPYTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   21-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleIVCPYTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = IVCPYTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = IVCPYTEST_101(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid IVCPYTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleENUMTest
//
//  Synopsis:  Runs single "ENUMTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   22-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleENUMTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = ENUMTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = ENUMTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = ENUMTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = ENUMTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = ENUMTEST_104(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid ENUMTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleIROOTSTGTest
//
//  Synopsis:  Runs single "IROOTSTGTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   25-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleIROOTSTGTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = IROOTSTGTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = IROOTSTGTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = IROOTSTGTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = IROOTSTGTEST_103(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid IROOTSTGTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunSingleHGLOBALTest
//
//  Synopsis:  Runs single "HGLOBAL" test.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   31-July-1996   T-ScottG    Modified 
//             25-July-1996   NarindK     Created 
//--------------------------------------------------------------------


HRESULT RunSingleHGLOBALTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT             hr              =           S_OK ;
    ULONG               ulSeed           =           0;

    // Obtain Seed from CommandLine

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    // Case test number

    if (S_OK == hr)
    {

	switch (lTestNum)
	{
	    case ( 100 ) :
	    {
		hr = HGLOBALTEST_100( ulSeed ) ;

		break ;
	    }

	    case ( 101 ) :
	    {
		hr = HGLOBALTEST_101( ulSeed ) ;

		break ;
	    }

	    case ( 110 ) :
	    {
		hr = HGLOBALTEST_110( ulSeed ) ;

		break ;
	    }

	    case ( 120 ) :
	    {
		hr = HGLOBALTEST_120( ulSeed ) ;

		break ;
	    }

	    case ( 121 ) :
	    {
		hr = HGLOBALTEST_121( ulSeed ) ;

		break ;
	    }

	    case ( 130 ) :
	    {
		hr = HGLOBALTEST_130( ulSeed ) ;

		break ;
	    }

	    case ( 140 ) :
	    {
		hr = HGLOBALTEST_140( ulSeed ) ;

		break ;
	    }

	    case ( 150 ) :
	    {
		hr = HGLOBALTEST_150( ulSeed ) ;

		break ;
	    }

	    default:
	    {
		//
		// Invalid test
		//

		DH_LOG((LOG_INFO,
			  TEXT("Invalid HGLOBALTEST test number: %ld"),
			  lTestNum) ) ;
	    }
	}
    }


    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleSNBTest
//
//  Synopsis:  Runs single "SNBTEST" test.  For information on these
//             tests, see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   26-July-1996   Jiminli    Created
//--------------------------------------------------------------------

HRESULT RunSingleSNBTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = SNBTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = SNBTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = SNBTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = SNBTEST_103(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid SNBTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleMISCTest
//
//  Synopsis:  Runs single "MISCTEST" test.  For information on these
//             tests, see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   5-Aug-1996   Jiminli    Created
//--------------------------------------------------------------------

HRESULT RunSingleMISCTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = MISCTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = MISCTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = MISCTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = MISCTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = MISCTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = MISCTEST_105(argc, argv) ;

	    break ;
	}

    default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid MISCTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleILKBTest
//
//  Synopsis:  Runs single "ILKBTEST" test.  For information on these
//             tests, see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   31-July-1996   NarindK    Created
//--------------------------------------------------------------------

HRESULT RunSingleILKBTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;
    ULONG               ulSeed           =           0;


    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = ILKBTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = ILKBTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = ILKBTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = ILKBTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = ILKBTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = ILKBTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = ILKBTEST_106(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    hr = ILKBTEST_107(argc, argv) ;

	    break ;
	}

	case ( 108 ) :
	{
	    // Obtain Seed from CommandLine

	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);
	   
	    hr = ILKBTEST_108(ulSeed) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid ILKBTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunSingleFlatTest
//
//  Synopsis:  Runs single "FLATTEST" test.  
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:    22-Jan-1998    BogdanT created
//--------------------------------------------------------------------

HRESULT RunSingleFlatTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;
    ULONG               ulSeed           =           0;


    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = FLATTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = FLATTEST_101(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid FLATTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\misctsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      misctsts.cxx
//
//  Contents:  miscellaneous tests pertaining to storage base tests
//
//  Functions:  
//
//  History:    5-Aug-1996     Jiminli     Created.
//              27-Mar-97      SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

extern BOOL     g_fUseStdBlk;
extern USHORT   ausSIZE_ARRAY[];

ULONG       ulStreamSize    = 0;
USHORT      usIterations    = 2;

LPTSTR      ptszNames[MAX_DOCFILES];
ULONG       *ulSeekOffset;

TIMEINFO    Time[] = {
                TEXT("FIRST_TIMING           "), FIRST_TIMING, 0, 0,
                TEXT("CREATE_STREAM_NO_EXIST "), CREATE_STREAM_NO_EXIST, 0, 0,
                TEXT("CREATE_STREAM_EXIST    "), CREATE_STREAM_EXIST, 0, 0,
                TEXT("CREATE_DOCFILE_NO_EXIST"), CREATE_DOCFILE_NO_EXIST, 0, 0,
                TEXT("CREATE_DOCFILE_EXIST   "), CREATE_DOCFILE_EXIST, 0, 0,
                TEXT("CREATE_NONAME_DOCFILE  "), CREATE_NONAME_DOCFILE, 0, 0,
                TEXT("OPEN_STORAGE_AND_STREAM"), OPEN_STORAGE_AND_STREAM, 0, 0,
                TEXT("OPEN_STREAM_ONLY       "), OPEN_STREAM_ONLY, 0, 0,
                TEXT("SEQUENTIAL_WRITE       "), SEQUENTIAL_WRITE, 0, 0,
                TEXT("SEQUENTIAL_READ        "), SEQUENTIAL_READ, 0, 0,
                TEXT("RANDOM_WRITE           "), RANDOM_WRITE, 0, 0,
                TEXT("RANDOM_READ            "), RANDOM_READ, 0, 0 };
 
//----------------------------------------------------------------------------
//
// Test:    MISCTEST_100 
//
// Synopsis: A root docfile is created and an IStream created in it. A random
//           number of bytes are written to the IStream and the IStream is
//           released. The root docfile is committed and released. This is
//           a particularly useful way to discover memory leaks as scratch
//           objects are created and (hopefully) released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  5-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: MEMLEAK.CXX
// 2.  Old name of test : MiscMemLeak Test 
//     New Name of test : MISCTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100
//        /dfRootMode:dirReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100 
//        /dfRootMode:xactReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: MISCTEST-100
//
//-----------------------------------------------------------------------------

HRESULT MISCTEST_100(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    VirtualStmNode  *pvsnRootNewChildStream     = NULL;
    LPTSTR          pRootNewChildStmName        = NULL;
    DG_STRING      *pdgu                       = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    USHORT          usErr                       = 0;
    LPTSTR          ptcsBuffer                  = NULL;
    ULONG           culBytesLeftToWrite         = 0;
    ULONG           culWritten                  = 0;
    ULONG           culRandIOBytes              = 0;
    DWORD           dwRootMode                  = 0;
    
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt memory leaks checking as objects are created")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for MISCTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 4L, and MIN_SIZE * 1.5

        usErr = pdgi->Generate(&culBytesLeftToWrite,4L,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Generate random number of bytes to write per chunk b/w  
        // RAND_IO_MIN and RAND_IO_MAX

        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Loop to write new IStream in culRandIOBytes size chunks unless size 
    // remaining to write is less than culRandIOBytes, then write the 
    // remaining bytes. CRC is not important for this test, so no check for it.

    while ((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandIOBytes
        // using GenerateRandomString function.

        if (S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtulaStmNode::Close unsuccessful, hr=0x%lx."), 
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation MISCTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation MISCTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    MISCTEST_101 
//
// Synopsis: Create a docfile over the net using READWRITE|TRANSACTED|
//           DENYWRITE. 50% chance this docfile will be committed. Then 
//           open the same file again over the net using READ|TRANSACTED|
//           DENYNONE. This test doesn't need to be run across the net, but
//           for what we are testing, this is the interesting variation. 
//           (from old test)
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  5-Aug-1996     JiminLi     Created.
//
// Notes:    There are no special parameterized operation modes for this 
//           test.
//
// New Test Notes:
// 1.  Old File: DFWFWOP.CXX
// 2.  Old name of test : MiscWindowForWorkGroupsOpen Test 
//     New Name of test : MISCTEST_101
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-101
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode 
// 
// BUGNOTE: Conversion: MISCTEST-101
//
//-----------------------------------------------------------------------------

HRESULT MISCTEST_101(int argc, char *argv[])
{
    HRESULT         hr                  = S_OK;
    ChanceDF        *pTestChanceDF      = NULL;
    VirtualDF       *pTestVirtualDF     = NULL;
    VirtualCtrNode  *pVirtualDFRoot     = NULL;
    DG_INTEGER      *pdgi               = NULL;
    USHORT          usErr               = 0;
    LPTSTR          pRootDocFileName    = NULL;
    LPOLESTR        pOleStrTemp         = NULL;
    LPSTORAGE       pStgDFRoot1         = NULL;
    LPSTORAGE       pStgDFRoot2         = NULL;
    DWORD           dwRootMode          = 0;
    ULONG           culRandomCommit     = 0;
    ULONG           ulRef               = 0;
    
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("MiscWindowsForWorkGroupOpen test.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for MISCTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }
	
    // 50% chance commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandomCommit, 1, 100);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Get the _pstg of the root storage, for later release

    if (S_OK == hr)
    {
        pStgDFRoot1 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgDFRoot1);
    }

    if ((S_OK == hr) && (culRandomCommit > 50))
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Open same docfile again using READ|TRANSACTED|DENYNONE.

    if (S_OK == hr)
    {
        if (NULL != pVirtualDFRoot)
        {
            pRootDocFileName= new TCHAR[_tcslen (pTestVirtualDF->GetDocFileName ())+1];
            if (pRootDocFileName != NULL)
            {
                _tcscpy (pRootDocFileName, pTestVirtualDF->GetDocFileName());
            }
            else
            {
                hr = E_FAIL;
                DH_TRACE ((DH_LVL_ERROR, TEXT("unable to get/copy DocFilename")));
            }
        }
    }

    if(S_OK == hr)
    {
        // Convert the name of the docfile to OLECHAR

        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                STGM_READ | STGM_TRANSACTED | STGM_SHARE_DENY_NONE,
                NULL,
                0,
                &pStgDFRoot2);
        DH_ASSERT(NULL != pStgDFRoot2);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root, here since we opened the docfile twice, we should
    // release both instances of it so that we can finally delete the 
    // docfile from disk.

    if (S_OK == hr)
    {
        ulRef = pStgDFRoot2->Release();
        DH_ASSERT(0 == ulRef);
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation MISCTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation MISCTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    MISCTEST_102 
//
// Synopsis: This test measures performance for various docfile operations
//           as compared to the equivalent C runtime operations.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  6-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: PERFTIME.CXX
// 2.  Old name of test : PerformanceTiming Test 
//     New Name of test : MISCTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:dirReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102 
//        /dfRootMode:xactReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode
//     d. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:dirReadWriteShEx /stdblock /logloc:2 /traceloc:2 /labmode
//     e. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102 
//        /dfRootMode:xactReadWriteShEx /stdblock /logloc:2 /traceloc:2 /labmode
//     f. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:xactReadWriteShDenyW /stdblock /logloc:2 /traceloc:2 
//        /labmode
//
// BUGNOTE: Conversion: MISCTEST-102
//
//-----------------------------------------------------------------------------

HRESULT MISCTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    ULONG           ulChunkSize             = 0;  
    ULONG           culArrayIndex           = 0;
    ULONG           cStartIndex             = 6;
    ULONG           ulNumofChunks           = 0;
    ULONG           culBytesLeft            = 0;
    USHORT          usIndex1                = 0;
    USHORT          usIndex2                = 0;
    LONG            lAvgDocfileTime         = 0;
    LONG            lAvgRuntimeTime         = 0;
    double          dSDDocfile, dSDRuntime, *pdDocRunDiff;
    double          dAvgDocfileTime, dTotalDocfileTime, dTotalRuntimeTime;
    double          dDocDiffTime;
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_102"));

    pdDocRunDiff = NULL;

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt measure performance for various docfile operations")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for MISCTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Generate stream size b/w MIN_SIZE and MIN_SIZE*1.5
   
    if (S_OK == hr)
    {
        usErr = pdgi->Generate(
                    &ulStreamSize, 
                    (ULONG)MIN_SIZE, 
                    (ULONG) (MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Generate chunk size for each WRITE/READ operation

    if (S_OK == hr)
    {
        if (TRUE == g_fUseStdBlk)
        {
            // Pick up a random array element.  Choosing cStartIndex of the
            // array (with random blocks) as 6 because do not want to write
            // byte by byte or in too small chunks a large docfile. 

            usErr = pdgi->Generate(&culArrayIndex, cStartIndex, MAX_SIZE_ARRAY);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
            else
            {
                ulChunkSize = ausSIZE_ARRAY[culArrayIndex];
            }
        }
        else
        {
            // Generate random number of bytes to write per chunk b/w 
            // RAND_IO_MIN and RAND_IO_MAX.

            usErr = pdgi->Generate(&ulChunkSize, RAND_IO_MIN, RAND_IO_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
    }

    // Calculate how many chunks be written

    if (S_OK == hr)
    {
        culBytesLeft = ulStreamSize;

        if (0 == ulChunkSize) 
        {
            hr = E_FAIL;
        }
        else
        {
            while (0 != culBytesLeft)
            {
                ulNumofChunks++;

                if (culBytesLeft >= ulChunkSize)
                {
                    culBytesLeft -= ulChunkSize;
                }
                else
                {				
                    culBytesLeft = 0;
                }
            }
        }
    }

    if (S_OK == hr)
    {
        ulSeekOffset = new ULONG[ulNumofChunks];

        // Generate the seek offsets for the random READ/WRITE operations

        for (usIndex1=0; usIndex1<ulNumofChunks; usIndex1++)
        {
            usErr = pdgi->Generate(
                        &ulSeekOffset[usIndex1],
                        0L,
                        ulStreamSize - ulChunkSize);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }   

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    if (S_OK == hr)
    {
        // Allocate the array for storing times
        
        for (usIndex1=FIRST_TIMING+1; usIndex1<LAST_TIMING; usIndex1++)
        {
            Time[usIndex1].plDocfileTime = (LONG *) new 
                                            LONG[(usIterations)*sizeof(LONG)];
            Time[usIndex1].plRuntimeTime = (LONG *) new 
                                            LONG[(usIterations)*sizeof(LONG)];

            if ((NULL == Time[usIndex1].plDocfileTime) ||
                (NULL == Time[usIndex1].plRuntimeTime))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            { 
                memset(
                    Time[usIndex1].plDocfileTime, 
                    -1, 
                    usIterations*sizeof(LONG));

                memset(
                    Time[usIndex1].plDocfileTime, 
                    -1, 
                    usIterations*sizeof(LONG)); 
            }

            if (S_OK != hr)
            {
                break;
            }
        }

        if (S_OK == hr)
        {
            pdDocRunDiff = new double[usIterations];

            if (NULL == pdDocRunDiff)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Test for StreamCreate
        
        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_NO_EXIST, 
                    DOCFILE | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_NO_EXIST, 
                    RUNTIME | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_EXIST, 
                    DOCFILE | EXIST | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_EXIST, 
                    RUNTIME | EXIST | COMMIT, 
                    usIterations);          
        }

        if (S_OK != hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Error in StreamCreate")));
        }

        // Test for DocfileCreate
        
        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_DOCFILE_NO_EXIST, 
                    DOCFILE | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_DOCFILE_NO_EXIST, 
                    RUNTIME | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_DOCFILE_EXIST, 
                    DOCFILE | EXIST | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_NONAME_DOCFILE, 
                    DOCFILE | NONAME | COMMIT, 
                    usIterations);          
        }

        if (S_OK != hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Error in DocfileCreate")));
        }

        // Test for StreamOpen
        
        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STORAGE_AND_STREAM, 
                    DOCFILE | COMMIT | OPENBOTH, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STORAGE_AND_STREAM, 
                    RUNTIME | COMMIT | OPENBOTH, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STREAM_ONLY, 
                    DOCFILE | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STREAM_ONLY, 
                    RUNTIME | COMMIT, 
                    usIterations);          
        }

        if (S_OK != hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Error in StreamOpen")));
        }

        // Generate an array of file names to use for the test

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<MAX_DOCFILES; usIndex1++)
            {
                hr = GenerateRandomName(
                        pdgu,
                        MINLENGTH,
                        MAXLENGTH,
                        &ptszNames[usIndex1]);

                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;  

                if (S_OK != hr)
                {
                    break;
                }
            }
        }

        // Sequential operations

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<usIterations; usIndex1++)
            {
                hr = WriteStreamInSameSizeChunks(
                        dwRootMode,
                        pdgu,
                        SEQUENTIAL_WRITE, 
                        DOCFILE,
                        ulChunkSize,
                        usIndex1);

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            SEQUENTIAL_READ,
                            DOCFILE,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = WriteStreamInSameSizeChunks(
                            dwRootMode,
                            pdgu,
                            SEQUENTIAL_WRITE,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            SEQUENTIAL_READ,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK != hr)
                {
                    DH_TRACE((DH_LVL_TRACE1, TEXT("Error in seq. write/read")));
                    break;
                }
            }
        }

        // Random operations

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<usIterations; usIndex1++)
            {
                hr = WriteStreamInSameSizeChunks(
                        dwRootMode,
                        pdgu,
                        RANDOM_WRITE, 
                        DOCFILE,
                        ulChunkSize,
                        usIndex1);

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            RANDOM_READ, 
                            DOCFILE,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = WriteStreamInSameSizeChunks(
                            dwRootMode,
                            pdgu,
                            RANDOM_WRITE,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            RANDOM_READ,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK != hr)
                {
                    DH_TRACE((DH_LVL_TRACE1, TEXT("Error in random write/read")));
                    break;
                }
            }            
        }
        
        // Delete all files on disk

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<MAX_DOCFILES; usIndex1++)
            {
                if (NULL != ptszNames[usIndex1])
                {
                    if(FALSE == DeleteFile(ptszNames[usIndex1]))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError()) ;

                        DH_HRCHECK(hr, TEXT("DeleteFile")) ;
                    }
                }

                if (S_OK != hr)
                {
                    break;
                }
            }
        }

        // Delete temp strings

        for (usIndex1=0; usIndex1<MAX_DOCFILES; usIndex1++)
        {
            if (NULL != ptszNames[usIndex1])
            {
                delete []ptszNames[usIndex1];
                ptszNames[usIndex1] = NULL;
            }
        }

        if (NULL != ulSeekOffset)
        {
            delete []ulSeekOffset;
            ulSeekOffset = NULL;
        }
    }

    // Report statistics result for this run

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("\n\nTest was run %u iterations"), usIterations));
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("Test Type\t\tDocFile\t\tRuntime\t\tDocFile-RunTime\t\tDocFile\tRuntime")));
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("         \t\tavg (SD)\tavg (SD)\taverage (X) (SD)\ttotal\ttotal")));
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("=========\t\t=======\t\t=======\t\t===============\t\t=======\t=======")));

        for (usIndex1=FIRST_TIMING+1; usIndex1<LAST_TIMING; usIndex1++)
        {
            Statistics(
                Time[usIndex1].plDocfileTime,
                usIterations,
                &lAvgDocfileTime,
                &dTotalDocfileTime,
                &dSDDocfile);

            Statistics(
                Time[usIndex1].plRuntimeTime,
                usIterations,
                &lAvgRuntimeTime,
                &dTotalRuntimeTime,
                &dSDRuntime);

            DH_TRACE((DH_LVL_TRACE1, TEXT("%s"), Time[usIndex1].Text));
            DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1ld"), lAvgDocfileTime));
            DH_TRACE((DH_LVL_TRACE1, TEXT(" (%3.1f)"), dSDDocfile));

            if (0 > dTotalRuntimeTime)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));                
            }
            else
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1ld"), lAvgRuntimeTime));
                DH_TRACE((DH_LVL_TRACE1, TEXT(" (%2.1f)"), dSDRuntime));
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("\t%6.1f"), 
                    (dTotalDocfileTime - dTotalRuntimeTime)/usIterations));
            }

            if (0 < dTotalRuntimeTime)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT(" (%2.1fx)"), dTotalDocfileTime / dTotalRuntimeTime));

                for (usIndex2=0; usIndex2<usIterations; usIndex2++)
                {
                    pdDocRunDiff[usIndex2] = 
                        ((float) Time[usIndex1].plDocfileTime[usIndex2]) / 
                                (Time[usIndex1].plRuntimeTime[usIndex2] + 1);
                }

                Statistics(
                    pdDocRunDiff,
                    usIterations,
                    &dAvgDocfileTime,
                    &dDocDiffTime,
                    &dSDDocfile);

                DH_TRACE((DH_LVL_TRACE1, TEXT(" (+- %2.1f)"), dSDDocfile));
            }
            else
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("   \t")));
            }

            DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1f"), dTotalDocfileTime));

            if (0 <= dTotalRuntimeTime)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1f "), dTotalRuntimeTime));
            }
            else
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));
            }

            if (NULL != Time[usIndex1].plDocfileTime)
            {
                delete Time[usIndex1].plDocfileTime;
                Time[usIndex1].plDocfileTime = NULL;
            }

            if (NULL != Time[usIndex1].plRuntimeTime)
            {
                delete Time[usIndex1].plRuntimeTime;
                Time[usIndex1].plRuntimeTime = NULL;
            }
        }

        if (NULL != pdDocRunDiff)
        {
            delete []pdDocRunDiff;
            pdDocRunDiff = NULL;
        }

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("\nNote: All times are measured in milliseconds(accuracy of +- 55)."))); 
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation MISCTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation MISCTEST_102 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    MISCTEST_103
//
// Synopsis: Coverage for NTbug 117010. Test that we can't create a storage
//           if a stream with the same name already exists.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  9-Dec-1997     BogdanT     Created.
//
//-----------------------------------------------------------------------------
HRESULT MISCTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    LPTSTR          ptszFileName            = NULL;
    LPOLESTR        poleFileName            = NULL;
    LPTSTR          ptszStmName             = NULL;
    LPOLESTR        poleStmName             = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           ulSeed                  = 0;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pStg                    = NULL;
    LPSTREAM        pStm                    = NULL;
    BOOL            fTransacted             = FALSE;
    DWORD           dwMode                  = STGM_CREATE          |
                                              STGM_READWRITE       |
                                              STGM_SHARE_EXCLUSIVE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_103"));
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_103 started.")) );

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    pdgu = new(NullOnFail) DG_STRING(ulSeed);

    ulSeed = pdgu->GetSeed();

    if (NULL == pdgu)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_STRING")) ;
    }

    pdgi = new(NullOnFail) DG_INTEGER(ulSeed);

    if (NULL == pdgi)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    pdgi->Generate(&fTransacted, 0, 1);

    if(fTransacted)
    {
        DH_TRACE((DH_LVL_ALWAYS,
                  TEXT("Transacted mode")));
        dwMode |= STGM_TRANSACTED;
    }

    if(S_OK == hr)
    {
        // Generate random filename

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pFileName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszFileName, &poleFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleFileName"));
    }

    if(S_OK == hr)
    {
        hr = StgCreateDocfile(poleFileName,
                              dwMode | STGM_DELETEONRELEASE,
                              0,
                              &pRootStg);

        DH_HRCHECK(hr, TEXT("StgCreateDocfile")) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for stream&storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pStmName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszStmName, &poleStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleStmName"));
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStream(poleStmName,
                                    STGM_CREATE    |
                                    STGM_READWRITE |
                                    STGM_SHARE_EXCLUSIVE,
                                    0,
                                    0,
                                    &pStm);
        DH_HRCHECK(hr, TEXT("CreateStream")) ;
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStorage(poleStmName,
                                     dwMode,
                                     0,
                                     0,
                                     &pStg);
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("Storage over stream succeeded!!!")));
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
    }

    if(S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("MISCTEST_103")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("MISCTEST_103")) );   
        DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u"), ulSeed));
    }
    
    if(NULL != pStg)
    {
        pStg->Release();
    }

    if(NULL != pRootStg)
    {
        pRootStg->Release();
    }

    delete[] ptszFileName;
    delete[] poleFileName;
    delete[] ptszStmName;
    delete[] poleStmName;

    delete pdgu;
    delete pdgi;
 
    return hr;

}
//----------------------------------------------------------------------------
//
// Test:    MISCTEST_104
//
// Synopsis: Coverage for NTbug 117010. Test that we can't create a stream
//           if a storage with the same name already exists.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  9-Dec-1997     BogdanT     Created.
//
//-----------------------------------------------------------------------------
HRESULT MISCTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    LPTSTR          ptszFileName            = NULL;
    LPOLESTR        poleFileName            = NULL;
    LPTSTR          ptszStmName             = NULL;
    LPOLESTR        poleStmName             = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           ulSeed                  = 0;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pStg                    = NULL;
    LPSTREAM        pStm                    = NULL;
    BOOL            fTransacted             = FALSE;
    DWORD           dwMode                  = STGM_CREATE          |
                                              STGM_READWRITE       |
                                              STGM_SHARE_EXCLUSIVE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_104"));
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_104 started.")) );

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    pdgu = new(NullOnFail) DG_STRING(ulSeed);

    ulSeed = pdgu->GetSeed();

    if (NULL == pdgu)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_STRING")) ;
    }

    pdgi = new(NullOnFail) DG_INTEGER(ulSeed);

    if (NULL == pdgi)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    pdgi->Generate(&fTransacted, 0, 1);

    if(fTransacted)
    {
        DH_TRACE((DH_LVL_ALWAYS,
                  TEXT("Transacted mode")));
        dwMode |= STGM_TRANSACTED;
    }

    if(S_OK == hr)
    {
        // Generate random filename

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pFileName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszFileName, &poleFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleFileName"));
    }

    if(S_OK == hr)
    {
        hr = StgCreateDocfile(poleFileName,
                              dwMode | STGM_DELETEONRELEASE,
                              0,
                              &pRootStg);

        DH_HRCHECK(hr, TEXT("StgCreateDocfile")) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for stream&storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pStmName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszStmName, &poleStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleStmName"));
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStorage(poleStmName,
                                     dwMode,
                                     0,
                                     0,
                                     &pStg);
        DH_HRCHECK(hr, TEXT("CreateStorage")) ;
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStream(poleStmName,
                                    STGM_CREATE    |
                                    STGM_READWRITE |
                                    STGM_SHARE_EXCLUSIVE,
                                    0,
                                    0,
                                    &pStm);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("Stream over storage succeeded!!!")));
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
    }

    if(S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("MISCTEST_104")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("MISCTEST_104")) );   
        DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u"), ulSeed));
    }
    
    if(NULL != pStg)
    {
        pStg->Release();
    }

    if(NULL != pRootStg)
    {
        pRootStg->Release();
    }

    delete[] ptszFileName;
    delete[] poleFileName;
    delete[] ptszStmName;
    delete[] poleStmName;

    delete pdgu;
    delete pdgi;
 
    return hr;

}

//----------------------------------------------------------------------------
//
// Test:    MISCTEST_105
//
// Synopsis: Coverage for NTbug 144547. Test that if we open STGM_READ we
//           don't get other privileges; for that, before opening the
//           storage we're opening the underlying file with read&deny write.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  2-Mar-1998     BogdanT     Created.
//
//-----------------------------------------------------------------------------
HRESULT MISCTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
/*    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    UINT            ulSeed                  = 0;
    LPTSTR          pRootDocFileName        = NULL;
    LPOLESTR        poleFileName            = NULL;
    LPSTORAGE       pRootStg                = NULL;
    DWORD           stgfmtOpen              = 0;
    HANDLE          hFile                   = INVALID_HANDLE_VALUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_105"));
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_105 started.")) );

    stgfmtOpen = STGFMT_DOCFILE;
    
    if(StorageIsFlat())
    {
        stgfmtOpen = STGFMT_FILE;
    }

    if(DoingOpenNssfile())
    {
        stgfmtOpen = STGFMT_NATIVE;
    }

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    if (S_OK == hr)
    {
        ulSeed = pTestChanceDF->GetSeed (); // for repro line

        if(NULL != pTestVirtualDF->GetDocFileName())
        {
            pRootDocFileName =
                new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
            }
            DH_HRCHECK(hr, TEXT("new TCHAR"));
        }
        else
        {
            hr = TESTSTG_E_ABORT;
            DH_HRCHECK(hr, TEXT("VirtualDF::GetDocFileName")) ;
        }
        
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &poleFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    if(S_OK == hr)
    {
        hFile = CreateFile(pRootDocFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if(INVALID_HANDLE_VALUE == hFile)
        {
            hr = TESTSTG_E_ABORT;
            DH_HRCHECK (hr, TEXT("CreateFile"));
        }
    }

    if(S_OK == hr)
    {
        hr = StgOpenStorageEx(poleFileName,
                              STGM_READ |
                              STGM_SHARE_DENY_WRITE,
                              stgfmtOpen,
                              0,
                              0,
                              0,
                              IID_IStorage,
                              (void**)&pRootStg);

        DH_HRCHECK(hr, TEXT("StgOpenStorageEx")) ;
    }

    if(S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("MISCTEST_105")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("MISCTEST_105")) );   
    }
    
    if(NULL != pRootStg)
    {
        pRootStg->Release();
    }

    if(INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

     // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    delete[] pRootDocFileName;
    delete[] poleFileName;
*/ 
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\ivcptsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      ivcptsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage/IStream copy
//             ops 
//
//  Functions:  
//
//  History:    21-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    IVCPYTEST_100 
//
// Synopsis:Create a root docfile with a child IStorage and a child IStream
//         within the child IStorage.  Commit the root docfile.  Create a
//         new root docfile with a different name.
//         Revert the child IStorage.  CopyTo() the child IStorage to the
//         second root docfile.  Now revert the original root docfile and
//         attempt the same CopyTo() operation we just tried.  This should
//         fail with STG_E_REVERTED since the child IStorage should be
//         marked invalid from the root revert.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    21-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: ICPARINV.CXX
// 2.  Old name of test : IllegitCopyParentInvalid Test 
//     New Name of test : IVCPYTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: IVCPYTEST-100
//
// Note: In this test, we are not adjusting the VirtualDF tree as 
//       result of copyto opeartions as this test checks only the return
//       error codes as result of copyto operations 
//-----------------------------------------------------------------------------

HRESULT IVCPYTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    VirtualStmNode  *pvsnChildStgNewChildStm= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          pChildStgNewChildStmName= NULL;
    ChanceDF        *pNewTestChanceDF       = NULL;
    VirtualDF       *pNewTestVirtualDF      = NULL;
    VirtualCtrNode  *pNewVirtualDFRoot      = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    CDFD            cdfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IVCPYTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt invalid copyto fm child IStg to root")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IVCPYTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Add a child storage to root.

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode | STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    //    Adds a new stream to this child storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pChildStgNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStorage,
                pChildStgNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnChildStgNewChildStm);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the root storage.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Revert the child storage

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
            hr));
    }

    // Create a new destination docfile with a random name

    if(S_OK == hr)
    {
        // Generate random name for new docfile

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pNewTestChanceDF = new ChanceDF();
        if(NULL == pNewTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = pTestChanceDF->GetSeed();
        cdfd.dwRootMode   = dwRootMode;

        hr = pNewTestChanceDF->Create(&cdfd, pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("pNewTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pNewTestVirtualDF = new VirtualDF();
        if(NULL == pNewTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pNewTestVirtualDF->GenerateVirtualDF(
                pNewTestChanceDF,
                &pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pNewTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Copy source docfile child storage to destination root docfile

    if(S_OK == hr)
    {
       hr = pvcnRootNewChildStorage->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Revert the root source docfile

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
            hr));
    }

    // Attempt Copy source docfile child storage to destination root docfile

    if(S_OK == hr)
    {
       hr = pvcnRootNewChildStorage->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (STG_E_REVERTED == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo failed as exp, hr = 0x%lx"),
            hr));

        hr = S_OK;
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo not as exp, hr=0x%lx."),
            hr));
    }

    // Copy source root docfile to dest root docfile.

    if(S_OK == hr)
    {
       hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close the source Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close the dest Root Docfile.

    if (S_OK == hr)
    {
        hr = pNewVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass)) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation IVCPYTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IVCPYTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete new Chance docfile tree

    if(NULL != pNewTestChanceDF)
    {
        hr2 = pNewTestChanceDF->DeleteChanceDocFileTree(
                pNewTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pNewTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pNewTestChanceDF;
        pNewTestChanceDF = NULL;
    }

    // Delete new Virtual docfile tree

    if(NULL != pNewTestVirtualDF)
    {
        hr2 = pNewTestVirtualDF->DeleteVirtualDocFileTree(pNewVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pNewTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pNewTestVirtualDF;
        pNewTestVirtualDF = NULL;
    }

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete strings

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pChildStgNewChildStmName)
    {
        delete pChildStgNewChildStmName;
        pChildStgNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    IVCPYTEST_101 
//
// Synopsis:Create a root docfile with a child IStorage.  Make an attempt
//          attempt to copy the root docfile into the child.  This should 
//          result in an error.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    21-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: ICPARTOC.CXX
// 2.  Old name of test : IllegitCopyParentToChild Test 
//     New Name of test : IVCPYTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IVCPYTEST-101
//
//-----------------------------------------------------------------------------

HRESULT IVCPYTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode              = 0;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IVCPYTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt invalid copyto fm Parent stg to child")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IVCPYTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Add a child storage to root.

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode | STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Copy source root docfile to child storage.

    if(S_OK == hr)
    {
       hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pvcnRootNewChildStorage);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (STG_E_ACCESSDENIED == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo failed as exp, hr=0x%lx."),
            hr));
    
        hr = S_OK;
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo passed unexp, hr=0x%lx."),
            hr));
    }

    // Close child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close Root Storage

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass)) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation IVCPYTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IVCPYTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp string

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\irootstg.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       irootstg.cxx
//
//  Contents:   storage base tests basically pertaining to IRootStorage 
//              interface. 
//
//  Functions:  
//
//  History:    25-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    Conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//Local Functions - Actual test functions.
HRESULT IROOTSTGTEST_100a(int argc, char *argv[], LPTSTR ptAlt);
HRESULT IROOTSTGTEST_101a(int argc, char *argv[], LPTSTR ptAlt);
HRESULT IROOTSTGTEST_102a(int argc, char *argv[], LPTSTR ptAlt);
HRESULT IROOTSTGTEST_103a(int argc, char *argv[], LPTSTR ptAlt);


// These stubs call a processor function for common processing
// before going on to call the actual tests.
HRESULT IROOTSTGTEST_100(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_100a);
}
HRESULT IROOTSTGTEST_101(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_101a);
}
HRESULT IROOTSTGTEST_102(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_102a);
}
HRESULT IROOTSTGTEST_103(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_103a);
}



//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_100a 
//
// Synopsis: A random docfile with random number of storages/streams is
//           created/committed/closed. The root docfile is instantiated 
//           and CRC'd.  QueryInterface for an IRootStorage is called and then 
//           SwitchToFile with a new file name is called.  The orignal file is 
//           released.  We then modify the switched to file, commit it, and 
//           release.  The original root docfile is then instantiated and CRC'd.
//           The CRCs are compared to verify that original file is unchanged.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  25-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LTSAVEAS.CXX
// 2.  Old name of test : LegitTransactedSaveAs 
//     New Name of test : IROOTSTGTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-100 /dfRootMode:dirReadWriteShEx 
//        /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-100 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-100 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-100 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------


HRESULT IROOTSTGTEST_100a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile, Save as. Modify DF, comp org DF.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_INC_TOPSTG_NAME, 
                &dwCRCOrg);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get the IRootStorage interface pointer by doing QueryInterface.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    if(S_OK == hr)
    {
        // Convert the new name to OLECHAR
        hr = TStringToOleString(pNewRootDocFileName, &poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call IRootStorage::SwitchToFile

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // ModifyDocFile call.  All the changes should be reflected to new docfile
    // (the one switched to) rather than original, since SwitchToFile asso
    // -ciated the ISotrage object with switchedto file rather than original
    // file.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                TRUE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Try to open second time when flags are STGM_DENY_WRITE.  This should
    // fail with STG_E_LOCKVIOLATION error.

    if (S_OK == hr)
    {
        if(dwRootMode & STGM_SHARE_DENY_WRITE)
        {
            if(S_OK == hr)
            { 
                hr = StgOpenStorage(
                        poszNewRootDocFileName, 
                        NULL, 
                        dwRootMode, 
                        NULL, 
                        0, 
                        &pStgRootNew);
            }
        
            if(STG_E_LOCKVIOLATION == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("STGM_SHARE_DENY_WRITE:  StgOpenStg hr = 0x%lx exp"),
                    hr));

                hr = S_OK;
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("STGM_SHARE_DENY_WRITE:StgOpenStg hr = 0x%lx unexp"),
                    hr));
    
                fPass = FALSE;
            }

        }
    }

    // Close the Original DocFile

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the original Root DocFile again

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for entire original DocFile without the RootDocfile name.
    // This CRC should match with CRC calculated for original DocFile since
    // all the changes being made after first CRC calculation should have been
    // to switched to file.

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_INC_TOPSTG_NAME, 
                &dwCRCNew);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's

    if(S_OK == hr)
    {
        if(dwCRCOrg == dwCRCNew)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as expected.")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file got changed unexp.")));
        }
    }

    // Close original file.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test IROOTSTGTEST_100 passed. %s"), 
            szFileSystemInfoBuffer));
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test IROOTSTGTEST_100 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer));
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_101a 
//
// Synopsis: A random docfile with random number of storages/streams is
//          created/committed/closed. The root docfile is instantiated, 
//          modified, and then CRC' is calculated for that.  We then do
//          do QueryInterface for an IRootStorage and SwitchToFile to
//          a new root docfile.  The new docfile is CRC'd and compared to
//          the original, they should match at this point.  This docfile is
//          then modified, CRC'd, and released.  This docfile is then
//          re-instantiated, CRC'd, and the previous two CRCs are compared.
//          The original root docfile is then instantiated and CRC'd and
//          the CRC is compared against the orignal CRC.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  25-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LTSVBOTH.CXX
// 2.  Old name of test : LegitTransactedSaveAsBoth 
//     New Name of test : IROOTSTGTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-101 /dfRootMode:dirReadWriteShEx 
//        /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-101 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-101 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-101 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------

HRESULT IROOTSTGTEST_101a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwCRCTemp               = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile, Save as both. Modify both DF/cmp")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Modify original docfile now and then calculate CRC for it which would 
    // be the original CRC value.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                TRUE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile after making changes, but before calling SwitchToFile.
    // This is the original CRC value.

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCOrg);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC original file %#x"), dwCRCOrg));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get the IRootStorage interface pointer by doing QueryInterface on it.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    if(S_OK == hr)
    {
        // Convert the new name to OLECHAR

        hr = TStringToOleString(pNewRootDocFileName, &poszNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call IRootStorage::SwitchToFile.  Therafter the IStorage would become
    // assocaited with new switched to file rather than original file and all
    // changes, including uncommitted ones, would be reflected to the new
    // switched to file rather than original file.

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Get the new root DocFile CRC after switching to File, should be the 
    // same as original root DocFile CRC at this point.  Calculate CRC and
    // compare to make sure.

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC switched file %#x"), dwCRCTemp));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's at this point, these should match

    if(S_OK == hr)
    {
        if(dwCRCOrg == dwCRCTemp)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match of org & switched to file as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of org & switched to file unexp")));
        }
    }

    // Call ModifyDocFile call.  All the canges are being getting reflected to
    // the new root DocFile since SwitchToFile associated IStorage with switch
    // to file rather than original file.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                TRUE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Get new root DocFile CRC after making changes to new DocFile and commit
    // ing them.  This will be compared to the new docfile CRC after release
    // and reinstantiation.

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCNew);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC switched/modified file %#x"), dwCRCNew));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the new Root DocFile.  The CRC will be computed on it, this
    // is expected to match dwCRCNew that was calculated before.

    if(S_OK == hr)
    { 
        hr = StgOpenStorage(
                poszNewRootDocFileName, 
                NULL, 
                dwRootMode, 
                NULL, 
                0, 
                &pStgRootNew);

        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    // Calculate the CRC on this new root DocFile

    if(S_OK == hr)
    {
        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootNew, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC new (after switch) file %#x"), dwCRCTemp));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Compare CRC's at this point.  The CRC of this new docfile and the
    // DocFile that was switched to and then modified should match.
    
    if(S_OK == hr)
    {
        if(dwCRCNew == dwCRCTemp)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match of new & switched to file as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of new & switched to file unexp")));
        }
    }

    // Close the new root DocFile

    if(S_OK == hr)
    {
        ulRef = pStgRootNew->Release();
        DH_ASSERT(0 == ulRef);
        pStgRootNew = NULL;
    }

    // Open the original Root DocFile again.  The CRC would be calculated on
    // this, it is expected to match dwCRCOrg, thereby verifying that because
    // of SwitchToFile, the original file remained unchanged.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC original file again %#x"), dwCRCTemp));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's of the this orginal docfile after reinstantiation and
    // the original value before SwitchToFile was done. These should match.

    if(S_OK == hr)
    {
        if(dwCRCTemp == dwCRCOrg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file changed unexp")));
        }
    }

    // Close original root docfile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test variation IROOTSTGTEST_101 passed. %s"),
            szFileSystemInfoBuffer) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IROOTSTGTEST_101 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer) );
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_102 
//
// Synopsis: A random docfile with random number of storages/streams is
//          created/committed/closed. The root docfile is instantiated,
//          and CRC is calculated for the docfile.  It is then modified & 
//          CRC'd again.  The test then calls QueryInterface to get an
//          IRootStorage and SwitchesToFile on a new name.  The new docfile
//          is committed, released, reinstantiated, and CRC'd.  This CRC
//          should match the CRC of the modified original root docfile.
//          The original docfile is then instantiated and CRC'd.  This
//          CRC should match the *first* CRC of the original root docfile
//          since we called SwitchToFile() before committing the changes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes.
//
// New Test Notes:
// 1.  Old File: LTSVNEW.CXX
// 2.  Old name of test : LegitTransactedSaveAsNew 
//     New Name of test : IROOTSTGTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-102 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-102 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-102 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------

HRESULT IROOTSTGTEST_102a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwCRCTemp               = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile,  Save as new.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile before making changes.  Then modify DocFile, but
    // don't commit the changes.  Get a new CRC reflecting  these changes 
    // and then switch to a new file *but* don't commit first.

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCOrg);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCOrg));
    }

    // Modify original docfile now, but don't commit the changes to root.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                FALSE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile after making changes, but not commiting these to
    // root. Let this be the new CRC value.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCNew);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCNew));
    }

    // Get the IRootStorage interface pointer by doing QueryInterface on it.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    // Call IRootStorage::SwitchToFile.  Therafter the IStorage would become
    // assocaited with new switched to file rather than original file and all
    // changes, including uncommitted ones, would be reflected to the new
    // switched to file rather than original file.

    if (S_OK == hr)
    {
        //  Convert name to OLECHAR 

        hr =TStringToOleString(pNewRootDocFileName,&poszNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Commit the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),   
            hr));
    }

    // Close the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the new Root DocFile.  The CRC will be computed on it, this
    // is expected to match dwCRCNew that was calculated before.

    if(S_OK == hr)
    { 
        hr = StgOpenStorage(
                poszNewRootDocFileName, 
                NULL, 
                dwRootMode, 
                NULL, 
                0, 
                &pStgRootNew);

        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    // Calculate the CRC on this new root DocFile

    if(S_OK == hr)
    {
        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootNew, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCTemp));
    }
    
    // Compare CRC's at this point.  The CRC of this new docfile and the
    // DocFile that was switched to and then modified should match.
    
    if(S_OK == hr)
    {
        if(dwCRCNew == dwCRCTemp)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match of new & switched to file as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of new & switched to file unexp")));
        }
    }

    // Close the new root DocFile

    if(S_OK == hr)
    {
        ulRef = pStgRootNew->Release();
        DH_ASSERT(0 == ulRef);
        pStgRootNew = NULL;
    }

    // Open the original Root DocFile again.  The CRC would be calculated on
    // this, it is expected to match dwCRCOrg, thereby verifying that because
    // of SwitchToFile, the original file remained unchanged.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for original DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCTemp));
    }

    // Compare CRC's of the this orginal docfile after reinstantiation and
    // the original value before SwitchToFile was done. These should match.

    if(S_OK == hr)
    {
        if(dwCRCTemp == dwCRCOrg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file changed unexp")));
        }
    }

    // Close original root docfile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test variation IROOTSTGTEST_102 passed. %s"),
            szFileSystemInfoBuffer) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IROOTSTGTEST_102 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer) );
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_103 
//
// Synopsis: A random docfile with random number of storages/streams is
//          created/committed/closed. The root docfile is instantiated,
//          and CRC is calculated for the docfile.  It is then modified & 
//          CRC'd again.  The test then calls QueryInterface to get an
//          IRootStorage and SwitchesToFile on a new name.  The new docfile
//          is reverted, released, reinstantiated, and CRC'd.  This CRC
//          should match the *first* CRC of the original root DocfFile, 
//          rather than the CRC of the modified original root docfile.
//          The original docfile is then instantiated and CRC'd.  This
//          CRC should match the *first* CRC of the original root docfile
//          since we called SwitchToFile() before committing the changes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes.
//
// New Test Notes:
// 1.  Old File: LTSVREV.CXX
// 2.  Old name of test : LegitTransactedSaveAsRevert 
//     New Name of test : IROOTSTGTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-103 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-103 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-103 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------

HRESULT IROOTSTGTEST_103a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwCRCTemp               = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile, Save as Revert")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile before making changes.  Then modify DocFile, but
    // don't commit the changes to root.  Get new CRC reflecting these changes 
    // and then switch to a new file *but* don't commit first.

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCOrg);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Modify original docfile now, but dont commit the changes to root.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                FALSE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile after making changes, but not commiting these to
    // root. Let this be the new CRC value.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCNew);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get the IRootStorage interface pointer by doing QueryInterface on it.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    // Call IRootStorage::SwitchToFile.  Therafter the IStorage would become
    // assocaited with new switched to file rather than original file and all
    // changes, including uncommitted ones, would be reflected to the new
    // switched to file rather than original file.

    if (S_OK == hr)
    {
        //  Convert name to OLECHAR 

        hr =TStringToOleString(pNewRootDocFileName,&poszNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Revert the Original DocFile.  This revert will revert all the changes
    // made by the ModifyDocFile call.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),   
            hr));
    }

    // Close the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the new Root DocFile.  The CRC will be computed on it, this
    // is expected to match dwCRCOrg that was calculated on original
    // DocFile before changes were made to it, because all the changes
    // were reverted by doing revert on root.

    if(S_OK == hr)
    { 
        hr = StgOpenStorage(
                poszNewRootDocFileName, 
                NULL, 
                dwRootMode, 
                NULL, 
                0, 
                &pStgRootNew);

        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    // Calculate the CRC on this new root DocFile

    if(S_OK == hr)
    {
        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootNew, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Compare CRC's at this point.  The CRC of this new docfile and the
    // original DocFile before any changes were made to it should match,    
    // since the changes made were reverted.
    
    if(S_OK == hr)
    {
        if((dwCRCNew != dwCRCTemp) && (dwCRCOrg == dwCRCTemp))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("crc's match of new and org before changes as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of new & org before changes unexp")));
        }
    }

    // Close the new root DocFile

    if(S_OK == hr)
    {
        ulRef = pStgRootNew->Release();
        DH_ASSERT(0 == ulRef);
        pStgRootNew = NULL;
    }

    // Open the original Root DocFile again.  The CRC would be calculated on
    // this, it is expected to match dwCRCOrg, thereby verifying that because
    // of SwitchToFile, the original file remained unchanged.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for original DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's of the this orginal docfile after reinstantiation and
    // the original value before SwitchToFile was done. These should match.

    if(S_OK == hr)
    {
        if(dwCRCTemp == dwCRCOrg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file changed unexp")));
        }
    }

    // Close original root docfile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test variation IROOTSTGTEST_103 passed. %s"),
            szFileSystemInfoBuffer) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IROOTSTGTEST_103 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer) );
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\roottsts.cxx ===
-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      roottsts.cxx
//
//  Contents:  storage base tests basically pertaining to root tests in general 
//
//  Functions:  
//
//  History:    24-June-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <sys/stat.h>
#include <share.h>
#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_100 
//
// Synopsis: A randomly named file is created and random data is written 
//           into it.The file is converted to a root docfile, then new IStorage
//           (root docfile) is committed and enumerated to ensure that only
//           a single IStream named "CONTENTS" (STG_CONVERTED_NAME) exists.
//           The CONTENTS IStream is instantiated, read, verified, and released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:   24-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LRCONV.CXX
// 2.  Old name of test : LegitRootConvert test 
//     New Name of test : ROOTTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-100
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-100
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-100
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: ROOTTEST-100 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    ULONG           ulRef                   = 0;
    FILE            *hFile                  = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          ptszRandomDataBuffer    = NULL;
    ULONG           cMin                    = 512;
    ULONG           cMax                    = 4096;
    ULONG           cRandom                 = 0;
    ULONG           culBytesWritten         = 0;
    DWORD           dwMemCRC                = 0;
    DWORD           dwActCRC                = 0;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPTSTR          ptszConvName            = NULL;
    STATSTG         statStg;
    ULONG           cItemsInConvertedDocFile= 0;
    LPMALLOC        pMalloc                 = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt legitimate ops on Root conversion.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.
        pdgu = new(NullOnFail) DG_STRING(pTestChanceDF->GetSeed());
        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new DG_STRING")) ;
    }

    // Generate RootDocFile name
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &pRootDocFileName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with mode as per dwRootFlags | STGM_CONVERT
    // This tests the case of CONVERT specified, but no file exists to convert.
    // This shouldn't fail.

    // Just make sure no DocFile of the name exists.  Delete if it does.
    if(NULL != pRootDocFileName)
    {
        DeleteFile(pRootDocFileName);
    }

    if (S_OK == hr)
    {
        pIStorage = NULL;
        HRESULT hr2 = StgCreateDocfile(
                pOleStrTemp,
                pTestChanceDF->GetRootMode() | STGM_CONVERT,
                0,
                &pIStorage);

        if(S_OK == hr2 && NULL != pIStorage)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, 
                TEXT("StgCreateDocFile failed unexpectedly, hr = 0x%lx ."), hr));
            hr = (S_OK==hr2)?E_FAIL:hr2;
        }
    }
    
    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pIStorage->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, 
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."), hr));
        }
    }


    // Close the root docfile
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    //Now actually prepare the file and then attempt conversion.
    if (S_OK == hr)
    {
        hFile = _tfopen(pRootDocFileName, TEXT("w+"));
        if(NULL == hFile)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("_tfopen")) ;
    } 
  
    if(S_OK == hr)
    {
        // Create a new DataGen object to create random INTEGER.
        pdgi = new(NullOnFail) DG_INTEGER(pTestChanceDF->GetSeed());
        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("Generate")) ;
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu,cRandom, cRandom, &ptszRandomDataBuffer);
        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if(S_OK == hr)
    {
        // Calculate CRC on this buffer ptszRandomDataBuffer
        hr = CalculateCRCForDataBuffer(
                ptszRandomDataBuffer,
                cRandom,
                &dwMemCRC);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer")) ;
    }

    if(S_OK == hr)
    {
        // Write to file using fwrite with above data and close the file.
        culBytesWritten = fwrite((void *) ptszRandomDataBuffer,
                             (size_t) 1,
                             (size_t) cRandom,
                             hFile);
        DH_ASSERT(culBytesWritten == cRandom);
    }

    if (NULL != hFile)
    {
        fclose(hFile);
    }

    // Call StgCreateDocfile with STGM_CONVERT now.
    if (S_OK == hr)
    {
        pIStorage = NULL;

        HRESULT hr2 = StgCreateDocfile(
                pOleStrTemp,
                pTestChanceDF->GetRootMode() | STGM_CONVERT,
                0,
                &pIStorage);

        if(STG_S_CONVERTED == hr2 && pIStorage!=NULL)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile failed unexpectedly, hr = 0x%lx ."), hr));

            hr = (hr2==S_OK)?E_FAIL:hr2;
        }
    }

    // Commit the Root DocFile
    if (S_OK == hr)
    {
        hr = pIStorage->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."), hr));
        }
    }

    // Close the root docfile
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    // Verify the CRC by opening Root DocFile, reading its CONTENTS stream,
    // calculating CRC on that and comparing that against the earlier CRC.
    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                pTestChanceDF->GetRootMode(),
                NULL,
                0,
                &pIStorage);

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgOpenStorage passed as expected.")));

            if(NULL == pIStorage)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgCreateDocfile failed to return IStorage"),
                    hr));

                hr = E_FAIL;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgOpenStorage failed unexpectedly, hr = 0x%lx."), hr));
        }
    }
   
    if(S_OK == hr)
    {
        hr =  pIStorage->EnumElements(0, NULL, 0, &penumWalk);
        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }
 
    // Call Next with celt equal to zero
    while((S_OK == hr) && (S_OK == penumWalk->Next(1, &statStg , NULL)))
    {
        cItemsInConvertedDocFile++;

        //Convert OLECHAR to TCHAR
        hr = OleStringToTString(statStg.pwcsName, &ptszConvName);
        DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

        if(S_OK == hr)
        {
            if((statStg.type != STGTY_STREAM) ||
               (0 != _tcscmp(ptszConvName, STG_CONVERTED_NAME))) 
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Converted DocFile containes other than %s stream"),
                     STG_CONVERTED_NAME));

                hr = E_FAIL;
            }
        }
    
        if(S_OK == hr)
        {
            hr = CalculateCRCForDocFileStmData(
                    pIStorage,
                    STG_CONVERTED_NAME,
                    statStg.cbSize.LowPart,
                    &dwActCRC);
            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFileStmData")) ;
        }

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;        
        }
    }

    // Release LPENUMSTATSTG pointer
    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Release pMalloc
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Close the root docfile
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr)                    &&
        (1 == cItemsInConvertedDocFile) &&
        (dwMemCRC == dwActCRC)) 
    {
        DH_TRACE((DH_LVL_TRACE1,
           TEXT("CRC of ordinary file & converted DocFile equal as exp.")));
        DH_TRACE((DH_LVL_TRACE1,
           TEXT("Ordinary file contents converted to CONTENTS stm as exp.")));
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_100 passed.")) );
    }
    else
    {
        DH_TRACE((DH_LVL_TRACE1,
           TEXT("CRC don't match or docfile not correctly cpnverted unexp")));

        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete temp string
    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if(NULL != ptszRandomDataBuffer)
    {
        delete ptszRandomDataBuffer;
        ptszRandomDataBuffer = NULL;
    }

    if(NULL != ptszConvName)
    {
        delete ptszConvName;
        ptszConvName = NULL;
    }

    // Delete DataGen object
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string
    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_101 
//
// Synposis: From 4 to 16 temporary (NULL name) root docfiles are created,
//       committed, Stat'ed, determined to be a storage object, released,
//       and instantiated with STG_E_FAILIFTHERE to prove that the temporary
//       docfile remained persistent.  The docfile is then deleted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:   24-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LRCONV.CXX
// 2.  Old name of test : LegitRootNull test 
//     New Name of test : ROOTTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-101
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-101
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-101
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: ROOTTEST-101 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    ULONG           ulRef                   = 0;
    DG_INTEGER      *pdgi                   = NULL;
    STATSTG         statStg;
    LPMALLOC        pMalloc                 = NULL;
    LPTSTR          ptszRootTempName        = NULL;
    LPOLESTR        poszRootTempName        = NULL;
    BOOL            fPass                   = TRUE;
    ULONG           cNumVars                = 0;
    ULONG           cRandomMinVar           = 4;
    ULONG           cRandomMaxVar           = 16;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt legitimate ops on temporaray root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random numbers.
        pdgi = new(NullOnFail) DG_INTEGER(pTestChanceDF->GetSeed());
        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cNumVars, cRandomMinVar, cRandomMaxVar);
        DH_HRCHECK(hr, TEXT("Generate")) ;
    }

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((0 != cNumVars) && (S_OK == hr) && (TRUE == fPass))
    {
        cNumVars--;
        DH_TRACE((DH_LVL_TRACE1, TEXT("cNumVars = %ld "), cNumVars));

        // Try calling StgCreateDocFile with NULL name - temporary root DocFile 
        if (S_OK == hr)
        {
            pIStorage = NULL;
            hr = StgCreateDocfile(
                    NULL,
                    pTestChanceDF->GetRootMode() | STGM_CREATE,
                    0,
                    &pIStorage);
            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        // Now do a valid commit.  BUGBUG: Use random modes..
        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        // Do a Stat on root Docfile
        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if(S_OK == hr)
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR
            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage
        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
            DH_HRCHECK(hr, TEXT("StgIsStorageFile"));
        }

        // Close the root docfile
        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
            DH_HRCHECK(hr, TEXT("StgIsStorageFile"));
        }

        // Call StgCreateDocFile with STGM_FAILIFTHERE flag.  This should fail.
        if (S_OK == hr)
        {
            pIStorage = NULL;
            HRESULT hr2 = StgCreateDocfile(
                    poszRootTempName,
                    pTestChanceDF->GetRootMode() | STGM_FAILIFTHERE,
                    0,
                    &pIStorage);

            if((S_OK != hr2) && (NULL == pIStorage))
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgCreateDocFile failed as expected, hr = 0x%lx."),hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_ERROR, 
                    TEXT("StgCreateDocFile passed unexpectedly,hr=0x%lx "), hr2));

                hr = (hr2==S_OK)?E_FAIL:hr2;
                fPass = FALSE;
            }

        }

        // Try calling StgCreateDocFile with STGM_CREATE| STGM_DELETEONRELEASE 
        if (S_OK == hr)
        {
            pIStorage = NULL;
            hr = StgCreateDocfile(
                    poszRootTempName,
                    pTestChanceDF->GetRootMode()|
                    STGM_CREATE                 |
                    STGM_DELETEONRELEASE,
                    0,
                    &pIStorage);
            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        // Now do a valid commit.  BUGBUG: Use random modes..
        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        // Delete temp string
        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        // Free the statStg.pwcsName
        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        // Stat the root IStorage
        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if(S_OK == hr)
        {
           //Convert OLECHAR to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR
            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage
        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
            DH_HRCHECK(hr, TEXT("StgIsStorageFile")) ;
        }

        // Close the root docfile
        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now
        if(S_OK == hr)
        {
            HRESULT hr2 = StgIsStorageFile(poszRootTempName);
            if(STG_E_FILENOTFOUND == hr2)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgIsStorage returned hr = 0x%lx as expected."), hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("StgIsStorage returned hr = 0x%lx unexpectedly."), hr2));

                hr = (hr2==S_OK)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }

        // Delete temp string
        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        // Free the statStg.pwcsName
        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))                  
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_101 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_101 failed, hr=0x%lx; fPass=%d."),
            hr,
            fPass));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Release pMalloc
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete DataGen object
    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_102 
//
// Synposis: From 4 to 16 times, a root docfile with a random name is created,
//       committed, Stat'ed, tested to see if it is a storage object,
//       released, tested to see if we still think it's a storage object,
//       and finally deleted from the file system.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LRNORM.CXX
// 2.  Old name of test : LegitRootNull test 
//     New Name of test : ROOTTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-102
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-102
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-102
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: ROOTTEST-102 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    ULONG           ulRef                   = 0;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING      *pdgu                   = NULL;
    STATSTG         statStg;
    LPMALLOC        pMalloc                 = NULL;
    LPTSTR          ptszRootTempName        = NULL;
    LPOLESTR        poszRootTempName        = NULL;
    LPTSTR          ptszRootName            = NULL;
    LPOLESTR        poszRootName            = NULL;
    BOOL            fPass                   = TRUE;
    ULONG           cNumVars                = 0;
    ULONG           cRandomMinVar           = 4;
    ULONG           cRandomMaxVar           = 16;
    FILE            *hFileRootNonDocFile    = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt legitimate ops on random root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random numbers.

        pdgi = new(NullOnFail) DG_INTEGER(pTestChanceDF->GetSeed());

        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cNumVars, cRandomMinVar, cRandomMaxVar);

        DH_HRCHECK(hr, TEXT("Generate")) ;
    }
    
    // Create DataGen

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(pTestChanceDF->GetSeed());

        if (NULL == pdgu)
        {
           hr = E_OUTOFMEMORY;
        }
    }

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((0 != cNumVars) && (S_OK == hr) && (TRUE == fPass))
    {
        cNumVars--;

        DH_TRACE((DH_LVL_TRACE1, TEXT("cNumVars = %ld "), cNumVars));
        
        // Generate RootDocFile name

        if(S_OK == hr)
        {
            hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszRootName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR

            hr = TStringToOleString(ptszRootName, &poszRootName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Try calling StgCreateDocFile with above random name 

        if (S_OK == hr)
        {
            pIStorage = NULL;

            hr = StgCreateDocfile(
                    poszRootName,
                    dwRootMode | STGM_CREATE,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile failed unexpectedly, hr=0x%lx"), hr));
        }

        // Now do a valid commit.  BUGBUG: Use random modes..

        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }

        // Do a Stat on root Docfile

        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr)
        {
            //Convert OLECHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR

            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx as exp before root release."), 
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx unexp before root release."), 
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx as exp after releasing rootDF"),
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr=0x%lx unexp after releasing root DF."),
                hr));
        }

        // Call StgCreateDocFile with STGM_FAILIFTHERE flag.  This should fail.

        if (S_OK == hr)
        {
            pIStorage = NULL;

            HRESULT hr2 = StgCreateDocfile(
                    poszRootTempName,
                    dwRootMode | STGM_FAILIFTHERE,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr2, TEXT(" StgCreateDocfile")) ;

            if((S_OK != hr2) && (NULL == pIStorage))
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgCreateDocFile failed as expected, hr = 0x%lx."),hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgCreateDocFile passed unexpectedly,hr=0x%lx "), hr2));

                hr = (S_OK==hr2)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }


        // Delete temp string

        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        // Change the mode to READ_ONLY and then try.

        if(S_OK ==  hr)
        {
            _tchmod(ptszRootName, _S_IREAD);
        }
        
        // Now call StgOpenStorage on it.  It should fail.

        if(S_OK ==  hr)
        {
            pIStorage = NULL;

            HRESULT hr2 = StgOpenStorage(
                    poszRootTempName,
                    NULL,
                    dwRootMode,
                    NULL,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr2, TEXT("StgOpenStorage")) ;

            if((S_OK != hr2) && (NULL == pIStorage))
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgOpenStorage fail exp with Read Only mode, hr=0x%lx"),
                    hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgOpenStorage pass unexp with readonly mode,hr=0x%lx"),
                    hr2));

                hr = (S_OK==hr2)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }

        // Change back the mode to read/write. 

        if(S_OK ==  hr)
        {
            _tchmod(ptszRootName, _S_IREAD | _S_IWRITE);
        }
        
        // Try calling StgCreateDocFile with STGM_CREATE| STGM_DELETEONRELEASE 

        if (S_OK == hr)
        {
            pIStorage = NULL;

            hr = StgCreateDocfile(
                    poszRootTempName,
                    pTestChanceDF->GetRootMode()|
                    STGM_CREATE                 |
                    STGM_DELETEONRELEASE,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile pass exp with mode \
                      STGM_CREATE|STGM_DELETEONRELEASE.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile failed unexp with mode \
                      STGM_CREATE | STGM_DELETEONRELEASE, hr=0x%lx"), hr));
        }

        // Now do a valid commit.  BUGBUG: Use random modes..

        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }

        // Free the statStg.pwcsName

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        // Stat the root IStorage

        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr)
        {
           //Convert OLECHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR

            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx as exp before root release."), 
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr=0x%lx unexp before root release."), 
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now

        if(S_OK == hr)
        {
            HRESULT hr2 = StgIsStorageFile(poszRootTempName);

            if(STG_E_FILENOTFOUND == hr2)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgIsStorage hr=0x%lx as exp after root reelase."), 
                    hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgIsStorage hr = 0x%lx unexp after root release."), 
                    hr2));

                hr = (S_OK==hr2)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }

        // Check if a non docfile fails StgIsStorage 

        hFileRootNonDocFile = _tfopen(ptszRootName, TEXT("w+"));

        if(NULL == hFileRootNonDocFile)
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("fopen unexpectedly failed %s "),
                ptszRootName));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("fopen passed as expected of file %s "),
                ptszRootName));

            fclose(hFileRootNonDocFile);
        }


        // Delete temp string

        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        if(NULL != poszRootName)
        {
            delete poszRootName;
            poszRootName = NULL;
        }

        // Free the statStg.pwcsName

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if((S_OK == hr) && (NULL != ptszRootName))
        {
            if(FALSE == DeleteFile(ptszRootName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }

            delete ptszRootName;
            ptszRootName = NULL;
        }
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))                  
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_102 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete DataGen object
    
    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_103 
//
// Synopsis:A root docfile with a random name is created, committed, and release
//       For each of the access mode combinations listed in the table, the
//       the root docfile is instantiated with the permissions, and then
//       for each of the access mode combinations, a 2nd instantiation of
//       the root docfile is attempted.  After the 2nd instantiation call,
//       a check is made to determine whether the instantiation should have
//       worked or failed depending upon the 1st instantiation mode.  The
//       second instantiation is released if necessary.  Once all modes
//       have been attempted for the 2nd instantiation, the 1st instantiation
//       is released, and the test goes on the the next access mode entry
//       in the array.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-June-1996     NarindK     Created
//           12-Aug-1996      JiminLi     Updated
//
// Notes:    This test runs in direct, transacted modes
//
// New Test Notes:
// 1.  Old File: LRMULTAC.CXX
// 2.  Old name of test : LegitRootMultAccess test 
//     New Name of test : ROOTTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-103
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-103
//        /dfRootMode:xactReadWriteShEx 
// 
// BUGNOTE: Conversion: ROOTTEST-103 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    DWORD           dwOpenMode              = NULL;
    LPSTORAGE       pIStorageFirst          = NULL;
    LPSTORAGE       pIStorageSecond         = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING       *pdgu                   = NULL;
    BOOL            fShouldWork             = FALSE;
    ULONG           count                   = 0;
    ULONG           subcount                = 0;
    BOOL            fPass                   = TRUE;
    struct
    {
        DWORD       usMode;
        BOOL        afPermsOk[30];
    } aPerms[15]={ STGM_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,  
                       T,T,T,T,F,T,F,T,F,T,F,T,F,T,F,
                   STGM_WRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,T,F,F,T,T,F,F,
                   STGM_READWRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,F,F,F,T,F,F,F,
                   STGM_READ | STGM_SHARE_DENY_NONE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,T,F,T,F,T,F,T,F,T,F,
                   STGM_READ | STGM_SHARE_DENY_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F, 
                       F,T,F,F,F,F,F,T,F,T,F,F,F,F,F,
                   STGM_READ | STGM_SHARE_DENY_WRITE,
                       F,F,F,F,F,T,F,F,F,F,F,F,F,F,F,
                       T,F,F,T,F,T,F,F,F,F,F,F,F,F,F,
                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_WRITE | STGM_SHARE_DENY_NONE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,T,F,F,T,T,F,F,
                   STGM_WRITE | STGM_SHARE_DENY_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,T,F,F,F,F,F,T,T,F,F,F,F,F,F,
                   STGM_WRITE | STGM_SHARE_DENY_WRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,F,F,T,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_WRITE | STGM_SHARE_EXCLUSIVE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_READWRITE | STGM_SHARE_DENY_NONE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,F,F,F,T,F,F,F,
                   STGM_READWRITE | STGM_SHARE_DENY_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,T,F,F,F,F,F,T,F,F,F,F,F,F,F,
                   STGM_READWRITE | STGM_SHARE_DENY_WRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,F,F,T,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F
                   };

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt multiple accesses on a root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_103, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(pTestChanceDF->GetSeed());

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &pRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with mode as per dwRootFlags

    // Just make sure no DocFile of the name exists.  Delete if it does.

    if (S_OK == hr)
    {
        pIStorageFirst = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp,
                dwRootMode | STGM_CREATE,
                0,
                &pIStorageFirst);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgCreateDocFile failed unexpectedly, hr = 0x%lx ."), hr));
    }

    // Now do a valid commit

    if (S_OK == hr)
    {
        hr = pIStorageFirst->Commit(STGC_ONLYIFCURRENT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit couldn't complete successfully.")));
    }

    // Close the root docfile

    if (S_OK == hr)
    {
        ulRef = pIStorageFirst->Release();
        DH_ASSERT(0 == ulRef);
        pIStorageFirst = NULL;
    }
    
    for ( count=0; count<15; count++)
    {
        DH_ASSERT(count < 15);

        // For the first open:
        // if instantiation mode contains STGM_TRANSACTED, then always 
        // instantiated; otherwise, if read-only(STGM_READ) is specified in the
        // mode, then only instantiated when STGM_SHARE_DENY_WRITE or 
        // STGM_SHARE_EXCLUSIVE is also set; if STGM_WRITE is specified in the
        // mode, then only instantiated when STGM_SHARE_EXCLUSIVE is also set.

        if ((dwRootMode & STGM_TRANSACTED)                                   || 
            ((aPerms[count].usMode & STGM_RW) == STGM_READ && 
             ((aPerms[count].usMode & STGM_SHARE) == STGM_SHARE_DENY_WRITE ||
              (aPerms[count].usMode & STGM_SHARE) == STGM_SHARE_EXCLUSIVE))  ||
            (((aPerms[count].usMode & STGM_RW) == STGM_WRITE || 
              (aPerms[count].usMode & STGM_RW) == STGM_READWRITE) &&
             (aPerms[count].usMode & STGM_SHARE) == STGM_SHARE_EXCLUSIVE))
        { 
            pIStorageFirst = NULL;

            if (dwRootMode & STGM_TRANSACTED)
            {
                dwOpenMode = STGM_TRANSACTED | aPerms[count].usMode;
            }
            else
            {
                dwOpenMode = STGM_DIRECT | aPerms[count].usMode;
            }

            hr = StgOpenStorage(
                    pOleStrTemp,
                    NULL,
                    dwOpenMode,
                    NULL,
                    0,
                    &pIStorageFirst);

            if (S_OK != hr)
            {
                DH_TRACE((DH_LVL_ERROR, 
                        TEXT("Error in first open (mode=%#lx), hr=0x%lx"),
                        dwOpenMode,
                        hr));
                break;
            }
            else 
            {
                for (subcount=0;subcount<15;subcount++)
                {
                    DH_ASSERT(subcount < 15);

                    // For the second open:
                    // if the mode contains STGM_TRANSACTED then always
                    // instantiates; otherwise only instantiates if 
                    // STGM_SHARE_DENY_WRITE or STGM_SHARE_EXCLUSIVE
                    // is set for this index in the table because for
                    // direct mode, both STGM_READ or STGM_WRITE need
                    // combined with at least STGM_SHARE_DENY_WRITE.

                    if ((dwRootMode & STGM_TRANSACTED)          ||
                        ((aPerms[subcount].usMode & STGM_SHARE) == 
                                                    STGM_SHARE_DENY_WRITE ||
                         (aPerms[subcount].usMode & STGM_SHARE) ==
                                                    STGM_SHARE_EXCLUSIVE))
                    {
                        pIStorageSecond = NULL;

                        if (dwRootMode & STGM_TRANSACTED)
                        {
                            dwOpenMode = STGM_TRANSACTED 
                                            | aPerms[subcount].usMode;
                            fShouldWork = aPerms[count].afPermsOk[subcount+15];
                        }
                        else
                        {
                            dwOpenMode = STGM_DIRECT 
                                            | aPerms[subcount].usMode;
                            fShouldWork = aPerms[count].afPermsOk[subcount];
                        }

                        hr = StgOpenStorage(
                                pOleStrTemp,
                                NULL,
                                dwOpenMode,
                                NULL,
                                0,
                                &pIStorageSecond);

                        //  determine whether or not the instantiation should
                        //  have worked.  For every 'F' in the access modes
                        //  table, the 2nd instantion should fail.
                        if (((fShouldWork == FALSE) && (S_OK == hr)) ||
                            ((fShouldWork == TRUE)  && (S_OK != hr)))
                        {
                            DH_TRACE((
                                DH_LVL_TRACE1, 
                                TEXT("\t i=%u, j=%u "),
                                count,
                                subcount));
                            DWORD dwMode = dwRootMode & STGM_TRANSACTED ? 
                                        STGM_TRANSACTED : STGM_DIRECT;
                            DH_TRACE((DH_LVL_ERROR, 
                                    TEXT("Mode1:%#lx, Mode2:%lx; hr=%#lx; Expect %s"),
                                    aPerms[count].usMode | dwMode,
                                    aPerms[subcount].usMode | dwMode,
                                    hr,
                                    (LPTSTR)(FALSE == fShouldWork ? 
                                            TEXT("failure"):TEXT("success"))));
                            fPass = FALSE;
                            hr = S_OK;
                        }
                        else
                        {
                            // Success or fail as expected

                            hr = S_OK;
                        }

                        if(NULL != pIStorageSecond)
                        {
                            ulRef = pIStorageSecond->Release();
                            DH_ASSERT(0 == ulRef);
                            pIStorageSecond = NULL;
                        }
                    }
                } 
 
                if(NULL != pIStorageFirst)
                {
                    ulRef = pIStorageFirst->Release();
                    DH_ASSERT(0 == ulRef);
                    pIStorageFirst = NULL;
                }
            }
        }

        if (S_OK != hr)
        {
            break;
        }
    }

    // if everything goes well, log test as passed else failed.

    if (fPass && (S_OK == hr))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_103 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_103 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete temp string

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    // Delete DataGen object
    
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if ((S_OK == hr) && fPass && (NULL != pRootDocFileName))
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_104 
//
// Synopsis: This test first creates a root docfile.  An IStream is created
//        inside the root docfile and a random number of bytes are
//        written to it.  The stream is released, the root docfile is
//        committed, and the root docfile is released.
//        The root docfile is instantiated in STGM_TRANSACTED mode and
//        and then released.  A count of the files in the current directory
//        is then made and saved.  The root docfile is then instantiated
//        in STGM_TRANSACTED | STGM_SHARE_DENY_WRITE mode and another count is
//        made.  We then verify that only 1 scratch file was created,
//        indicating that for STGM_DENY_WRITE mode, no copy is made of
//        the instantiated IStorage.  (Note: if in the second time, the
//        file is opened in STGM_TRANSACTED mode only, not STGM_SHARE_DENY_
//        WRITE mode, two scratch files would be made.)
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-June-1996     NarindK     Created.
//
// Notes:    This test runs in transacted modes
//
// New Test Notes:
// 1.  Old File: LRTWWDW.CXX
// 2.  Old name of test : LegitRootTwwDenyWrite test 
//     New Name of test : ROOTTEST_104 
// 3.  To run the test, do the following at command prompt. 
//       stgbase /t:ROOTTEST-104
//
// BUGNOTE: Conversion: ROOTTEST-104 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_104(int /* UNREF argc */, char * * /* UNREF argv*/)
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!ROOTTEST_104 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    DWORD           dwRootMode              = STGM_READWRITE | STGM_TRANSACTED;
    LPSTORAGE       pIStorage               = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          ptszRootName            = NULL;
    LPOLESTR        poszRootName            = NULL;
    LPTSTR          ptszStreamName          = NULL;
    LPOLESTR        poszStreamName          = NULL;
    BOOL            fPass                   = TRUE;
    ULONG           culSeed                 = 0;
    ULONG           cRandom                 = 0;
    LPSTREAM        pIStream                = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    LPOLESTR        pocsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culFilesInDirectory     = 0;
    BOOL            fNssfile                = FALSE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt operations on root docfile in transacted mode.")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(culSeed);

        if (NULL == pdgu)
        {
           hr = E_OUTOFMEMORY;
        }
    }
        
    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszRootName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR name to OLECHAR

        hr = TStringToOleString(ptszRootName, &poszRootName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with above random name 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                    poszRootName,
                    dwRootMode | STGM_FAILIFTHERE,
                    0,
                    &pIStorage);

        DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgCreateDocFile failed unexpectedly, hr=0x%lx"), hr));
    }

    // Generate random name for stream

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR name to OLECHAR

        hr = TStringToOleString(ptszStreamName, &poszStreamName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Create a stream

    if (S_OK == hr)
    {
        hr = pIStorage->CreateStream(
                poszStreamName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                0,
                0,
                &pIStream);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("IStorage::CreateStream passed as expected")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("IStorage::CreateStream failed unexpectedly,hr=0x%lx"), hr));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random integers.

        pdgi = new(NullOnFail) DG_INTEGER(culSeed);

        if (NULL == pdgi)
        {
           hr = E_OUTOFMEMORY;
        }
    }
        
    // Write random size data into stream

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, 1, USHRT_MAX);

        DH_HRCHECK(hr, TEXT("Generate")) ;
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cRandom, cRandom, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if(S_OK == hr)
    {
        // Convert data to OLECHAR

        hr = TStringToOleString(ptcsBuffer, &pocsBuffer);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = pIStream->Write(pocsBuffer, cRandom, &culWritten);

        DH_HRCHECK(hr, TEXT("IStream::Write")) ;
    }

    // Release stream

    if (NULL != pIStream)
    {
       ulRef = pIStream->Release();
       DH_ASSERT(0 == ulRef);
       pIStream = NULL;
    }

    // Now do a valid commit.  BUGBUG: Use random modes..

    if (S_OK == hr)
    {
        hr = pIStorage->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close the root docfile

    if (NULL != pIStorage)
    {
       ulRef = pIStorage->Release();
       DH_ASSERT(0 == ulRef);
       pIStorage = NULL;
    }

    // Open the root docfile

    if (S_OK == hr)
    {
       pIStorage = NULL;

       hr = StgOpenStorage(
                 poszRootName,
                 NULL,
                 dwRootMode,
                 NULL,
                 0,
                 &pIStorage);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage couldn't complete successfully, hr = 0x%lx"),
            hr));
    }

    // Close the root docfile

    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    // count number of files in directory

    if (S_OK == hr)
    {
        culFilesInDirectory = CountFilesInDirectory(WILD_MASK);
        //If opening as nssfile, decrement # tempfiles, (uses a stream)
        if (DoingOpenNssfile ())
        {
            //VerifyNssfile returns S_OK if valid nssfile - else an error
            if (S_OK == VerifyNssfile (ptszRootName))
            {
                //nssfiles use a stream in file, not temp file.
                culFilesInDirectory--;
            }
        }
    }

    // Open the root docfile

    if (S_OK == hr)
    {
       pIStorage = NULL;

       hr = StgOpenStorage(
                 poszRootName,
                 NULL,
                 dwRootMode | STGM_SHARE_DENY_WRITE,
                 NULL,
                 0,
                 &pIStorage);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage with STGM_SHARE_DENY_WRITE passed.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage with STGM_SHARE_DENY_WRITE fail, hr=0x%lx"),
            hr));
    }

    // Check number of files

    if((culFilesInDirectory + 1) != CountFilesInDirectory(WILD_MASK))
    {
        DH_TRACE((
         DH_LVL_TRACE1,
         TEXT(">1 scratch file unexp STGM_SHARE_DENY_WRITE instantiation.")));

        hr = S_FALSE;
    }
    else
    {
        DH_TRACE((
         DH_LVL_TRACE1,
         TEXT("1 scratchfile exp with STGM_SHARE_DENY_WRITE instantiation")));

    }

    // Close the root docfile

    if (NULL != pIStorage)
    {
       ulRef = pIStorage->Release();
       DH_ASSERT(0 == ulRef);
       pIStorage = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)           
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_104 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete DataGen object
    
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    // Delete temp string

    if(NULL != ptszStreamName)
    {
        delete ptszStreamName;
        ptszStreamName = NULL;
    }

    if(NULL != poszStreamName)
    {
        delete poszStreamName;
        poszStreamName = NULL;
    }

    if(NULL != poszRootName)
    {
        delete poszRootName;
        poszRootName = NULL;
    }

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if(NULL != pocsBuffer)
    {
        delete pocsBuffer;
        pocsBuffer = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != ptszRootName))
    {
        if(FALSE == DeleteFile(ptszRootName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != ptszRootName)
    {
        delete ptszRootName;
        ptszRootName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
#endif //_MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\snbtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      snbtests.cxx
//
//  Contents:  storage base tests basically pertaining to String Name
//             Block (SNB) and STGM_PRIORITY mode.
//
//  Functions:  
//
//  History:    26-July-1996    Jiminli     Created.
//              27-Mar-97       SCousens    Conversionified
//
// BUGBUG: right now no snb params for nss apis.
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"
 
//----------------------------------------------------------------------------
//
// Test:    SNBTEST_100 
//
// Synopsis: The created root docfile is instantiated and traversed and the 
//           child objects found are selected at random for inclusion in an 
//           snbExclude structure. The docfile is commit and released. Then
//           the docfile is now re-instantiated with the just built SNB passed
//           in, indicating that the objects found in the SNB should be
//           returned as empty IStorages or zero length IStreams. The root 
//           docfile is then traversed and each object returned that matches
//           a name in the SNB is verified to determine that it's empty or
//           zero length.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  1-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LLNORM.CXX
// 2.  Old name of test : LegitLimitedInstNormal Test 
//     New Name of test : SNBTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:SNBTEST-100
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:8-10 /t:SNBTEST-100 
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:6-9 /t:SNBTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /logloc:2 /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-100 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt legitimate SNB tests on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));

    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }
  
    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) * 
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbNamesToExclude = NULL;
        }
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }
 
    // Since no actual operations on child storages and streams, only need 
    // commit and release root storage.

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, snbNamesToExclude, 0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }
  
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName= new TCHAR[_tcslen(
                            pTestVirtualDF->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    SNBTEST_101 
//
// Synopsis: The created root docfile is instantiated and traversed and the 
//           child objects found are selected at random for inclusion in an 
//           snbExclude structure. 50% of the time, a bogus name is placed in 
//           the snbExclude block instead. The test should verify that the
//           valid names were properly zeroed out, and that the bogus names in 
//           the SNB block are ignored, i.e. don't cause an error.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  30-July-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: ILNORM.CXX
// 2.  Old name of test : IllegitLimitedInstNormal Test 
//     New Name of test : SNBTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:SNBTEST-101 
//        /dfRootMode:dirReadWriteShEx  /logloc:2 /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:8-10 /t:SNBTEST-101 
//        /dfRootMode:xactReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:6-9 /t:SNBTEST-101 
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-101 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt illegitimate SNB tests on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }
  
    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) *
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbNamesToExclude = NULL;
        }
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                TRUE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }
 
    // Since no actual operations on child storages and streams, only need 
    // commit and release root storage.

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, snbNamesToExclude, 0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                TRUE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }
  
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName= new TCHAR[_tcslen(
                            pTestVirtualDF->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    SNBTEST_102
//
// Synopsis: The created root docfile is instantiated with STGM_PRIORITY 
//           specified and then it is traversed and the child objects found 
//           are selected at random for inclusion in an snbExclude structure.
//           Then the docfile is now re-instantiated using the just built SNB
//           and the original root IStorage passed as pstgPriority parameter.
//           This effectively removes the PRIORITY classification of this 
//           docfile while excluding the possibility of an opening of the root
//           docfile by another process. The SNB that was passed in indicates 
//           that the objects found in the SNB should be returned as empty 
//           IStorages or zero length IStreams. The root docfile is then 
//           traversed and each object returned that matches a name in the SNB
//           is verified to determine that it's empty or zero length.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  1-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in DIRECT mode only since DIRECT is the only
//           valid mode for a root instantiation with STGM_PRIORITY specified.
//
// New Test Notes:
// 1.  Old File: LLPRIOR.CXX
// 2.  Old name of test : LegitLimitedInstPriority Test 
//     New Name of test : SNBTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:6-8 /t:SNBTEST-102
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-102 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_102(int argc, char* argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualDF       *pTestVirtualCopyDF     = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pVirtualCopyDFRoot     = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootCopyDocFileName    = NULL;
    LPSTORAGE       pStgRootDF              = NULL;
    LPSTORAGE       pStgRootCopyDF          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt legitimate SNB tests on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName = new TCHAR[_tcslen(pTestVirtualDF
                                     ->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                NULL, 
                STGM_READ  | STGM_DIRECT | STGM_PRIORITY, 
                NULL, 
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    if (S_OK == hr)
    {
        pStgRootDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootDF);
    }

    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) * 
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }

        *snbNamesToExclude = NULL;
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    // Generate a copy of the original docfile

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->CopyVirtualDocFileTree(
                pVirtualDFRoot,
                NEW_STGSTM,
                &pVirtualCopyDFRoot);

        DH_ASSERT(NULL != pVirtualCopyDFRoot);

        DH_HRCHECK(hr, TEXT("VirtualDF::CopyVirtualDocFileTree"));
    }

    // Create a new VirtualDF tree

    if (S_OK == hr)
    {
        pTestVirtualCopyDF = new VirtualDF();

        if(NULL == pTestVirtualCopyDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude and also pass in previous opening of this root docfile
    // as parameter pstgPriority.

    // The reason of AddRefCount is Ole code just release pStgRootDF once, 
    // and it's user's responsibility to release all references to it and 
    // finally set it to NULL.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->AddRefCount();
        
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount"));
    }
   
    if (S_OK == hr)
    {
        hr = pVirtualCopyDFRoot->Open(
                pStgRootDF, 
                STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_NONE, 
                snbNamesToExclude, 
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        pStgRootCopyDF = pVirtualCopyDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootCopyDF);
    }

    // Assocaies a VirtualDF tree with a VirtualCtrNode and its _pstg
    // The purpose it later on we can delete the related space taken 
    // by the copied docfile.

    if (S_OK == hr)
    {
        hr = pTestVirtualCopyDF->Associate(pVirtualCopyDFRoot, pStgRootCopyDF);

        DH_HRCHECK(hr, TEXT("pTestVirtualCopyDF::Associate"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualCopyDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    // Release the copied root and all open IStorages/IStreams 
    // pointers under it. Note: now the original VirtualDFRoot is
    // not valid any more.
  
    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualCopyDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_102 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualCopyDFRoot && pTestVirtualCopyDF->GetDocFileName())
    {
        pRootCopyDocFileName = new TCHAR[_tcslen(pTestVirtualCopyDF
                                         ->GetDocFileName())+1];

        if (NULL != pRootCopyDocFileName)
        {
            _tcscpy(pRootCopyDocFileName, pTestVirtualCopyDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    if(NULL != pTestVirtualCopyDF)
    {
        hr2 = pTestVirtualCopyDF->DeleteVirtualDocFileTree(pVirtualCopyDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualCopyDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualCopyDF;
        pTestVirtualCopyDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if ((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }
 
    // Delete temp strings

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if (NULL != pRootCopyDocFileName)
    {
        delete pRootCopyDocFileName;
        pRootCopyDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr; 
}


//----------------------------------------------------------------------------
//
// Test:    SNBTEST_103
//
// Synopsis: The created root docfile is instantiated with STGM_PRIORITY 
//           specified and then it is traversed and the child objects found 
//           are selected at random for inclusion in an snbExclude structure.
//           50% of the time, a bogus name is placed in the snbExclude block
//           instead. The docfile is then re-instantiated using the just built
//           SNB and the original root IStorage passed as pstgPriority 
//           parameter. The root docfile is then traversed and the test should
//           verify that the valid names were properly zeroed out, and that 
//           the bogus names in the SNB block are ignored, i.e. do not cause 
//           an error.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  3-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in DIRECT mode only since DIRECT is the only
//           valid mode for a root instantiation with STGM_PRIORITY specified.
//
// New Test Notes:
// 1.  Old File: ILPRIOR.CXX
// 2.  Old name of test : IllegitLimitedInstPriority Test 
//     New Name of test : SNBTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:6-8 /t:SNBTEST-103
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-103 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_103(int argc, char* argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualDF       *pTestVirtualCopyDF     = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pVirtualCopyDFRoot     = NULL;
    VirtualCtrNode  *pVirtualChildStg       = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootCopyDocFileName    = NULL;
    LPSTORAGE       pStgRootDF              = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTORAGE       pStgRootCopyDF          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;  
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legitimate STGM_PRIORITY related test on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName = new TCHAR[_tcslen(
                            pTestVirtualDF->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Get the first child storage pointer for later illegitmate test,

    if (S_OK == hr)
    {
        pVirtualChildStg = pVirtualDFRoot->GetFirstChildVirtualCtrNode();
        DH_ASSERT(NULL != pVirtualChildStg);

        pStgChild = pVirtualChildStg->GetIStoragePointer();
        DH_ASSERT(NULL != pStgChild);
    }
 
    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL, and also
    // STGM_PRIORITY is set in grfMode.
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                STGM_READ | STGM_DIRECT | STGM_PRIORITY, 
                NULL,
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    if (S_OK == hr)
    {
        pStgRootDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootDF);
    }
  
    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) * 
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbNamesToExclude = NULL;
        }
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation. The sixth param == TRUE shows that this is an
    // illegit test, i.e. 50% chance we will add bogus names into SNB.

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                TRUE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }
 
    // Generate a copy of the original docfile

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->CopyVirtualDocFileTree(
                pVirtualDFRoot,
                NEW_STGSTM,
                &pVirtualCopyDFRoot);

        DH_ASSERT(NULL != pVirtualCopyDFRoot);

        DH_HRCHECK(hr, TEXT("VirtualDF::CopyVirtualDocFileTree"));
    }

    // Create a new VirtualDF tree

    if (S_OK == hr)
    {
        pTestVirtualCopyDF = new VirtualDF();

        if(NULL == pTestVirtualCopyDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude and also pass in previous opening of this root docfile
    // as parameter pstgPriority.
 
    // First we passed in the substorage pointer as pstgPriority parameter,
    // it is closed, so it should fail.

#ifdef _MAC 

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!Opening a VirtualCtrNode with invalid substorage ptr. skipped")) );

#else
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                pStgChild, 
                dwRootMode, 
                snbNamesToExclude, 
                0);
     
        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open failed as expected, hr=0x%lx."),
                hr));
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open should have failed.")));
            hr = E_FAIL;
        }
    }
#endif //_MAC

    // Now we passed in correct storage pointer and have illegimate
    // SNB test. The reason of AddRefCount is Ole code just release
    // pStgRootDF once, and it's user's responsibility to release all
    // references to it and finally set it to NULL.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->AddRefCount();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount"));
    }
   
    if (S_OK == hr)
    {
        hr = pVirtualCopyDFRoot->Open(
                pStgRootDF, 
                STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_NONE,
                snbNamesToExclude, 
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        pStgRootCopyDF = pVirtualCopyDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootCopyDF);
    }

    // Assocaies a VirtualDF tree with a VirtualCtrNode and its _pstg
    // The purpose it later on we can delete the related space taken 
    // by the copied docfile.

    if (S_OK == hr)
    {
        hr = pTestVirtualCopyDF->Associate(pVirtualCopyDFRoot, pStgRootCopyDF);

        DH_HRCHECK(hr, TEXT("pTestVirtualCopyDF::Associate"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualCopyDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    // Release the copied root and all open IStorages/IStreams 
    // pointers under it. Note: now the original VirtualDFRoot is
    // not valid any more.
  
    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualCopyDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_103 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if ((S_OK == hr) && (NULL != pVirtualCopyDFRoot))
    {
        pRootCopyDocFileName = new TCHAR[_tcslen(pTestVirtualCopyDF
                                         ->GetDocFileName())+1];

        if (NULL != pRootCopyDocFileName)
        {
            _tcscpy(pRootCopyDocFileName, pTestVirtualCopyDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    if ((S_OK == hr) && (NULL != pTestVirtualCopyDF))
    {
        hr2 = pTestVirtualCopyDF->DeleteVirtualDocFileTree(pVirtualCopyDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualCopyDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualCopyDF;
        pTestVirtualCopyDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if ((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }
 
    // Delete temp strings

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if (NULL != pRootCopyDocFileName)
    {
        delete pRootCopyDocFileName;
        pRootCopyDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\vcpytsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      vcpytsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage/IStream copy
//             ops 
//
//  Functions:  
//
//  History:    15-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//externs
extern BOOL     g_fRevert;

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_100 
//
// Synopsis: A random root DF is created with random storages/stms, committed 
//       The root docfile is searched to find a VirtualCtrNode node in tree 
//       that is a child of the root IStorage.  The child IStorage
//       is then copied with the destination being the root docfile itself.
//       If the 'RevertAfterCopy' switch was specified, the root docfile
//       is then reverted and the CRC is recomputed on the root docfile
//       and compared to the before copy CRC to verify that no changes
//       occurred in the docfile hierarchy.  Also it is verified by enum
//       rating the docfile before and after opeartion and testing the total
//       number of storages and streams in file remain unchanged.
//       If case of Revert being FALSE, the contents of the child IStorage 
//       should be merged in with the contents of the root level of the docfile.
//       Verify this case by enumerating the docfile before and after
//       CopyTo is done and test that the resulting number of storages &
//       streams in the DocFile is as expected. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    15-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCCTOP.CXX
// 2.  Old name of test : LegitCopyChildDFToParentDF Test 
//     New Name of test : VCPYTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-100
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRandomChild        = NULL;
    VirtualCtrNode  *pvcnTrav               = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           cChildren               = 0;
    ULONG           cRandomChild            = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cChildStg               = 0;
    ULONG           cChildStm               = 0;
    ULONG           cResStg                 = 0;
    ULONG           cResStm                 = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt valid copyto op fm child IStg to root")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG whole df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get IStorage pointer for Root

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot) ;
        if(NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }
   
    // Calulcate CRC for entire docfile.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }
   
    // Find the total number of VirtualCtrNodes and VirtualStmNodes in the
    // DocFile

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT,&cTotalStg, &cTotalStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
  
    // Find a random child VirtualCtrNode in the file.  First verify there
    // are child storages in the tree.

    if(S_OK == hr)
    {
        cChildren = pVirtualDFRoot->GetVirtualCtrNodeChildrenCount();

        if(0 == cChildren)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Max original tree depth inadequate to find a child")));

            hr = S_FALSE;
        }
    }
    
    if(S_OK == hr)
    {
        // Find a random child storage to pick from

        usErr = pdgi->Generate(&cRandomChild, 1, cChildren);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Pick up the random child node.

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        DH_ASSERT(NULL != pvcnTrav);

        while((0 != --cRandomChild) && 
              (NULL != pvcnTrav->GetFirstSisterVirtualCtrNode()))
        {
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }
        pvcnRandomChild = pvcnTrav;
    }

    if(S_OK == hr)
    {
        hr = OpenRandomVirtualCtrNodeStg(pvcnRandomChild, dwStgMode);

        DH_HRCHECK(hr, TEXT("OpenRandomVirtualCtrNodeStg")) ;
    }

    if(S_OK == hr)
    {
        pStgChild = pvcnRandomChild->GetIStoragePointer();

        DH_ASSERT(NULL != pStgChild) ;
    }
   
    // Find the total number of VirtualCtrNode(s) and VirtualStmNode(s) under
    // this node.

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgChild,VERIFY_SHORT,&cChildStg,&cChildStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }

    // Copy everything under this child node to the Root node.

    if(S_OK == hr)
    {
       hr = pvcnRandomChild->CopyTo(0, NULL, NULL, pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Adjust the virtual tree as a result of above operation.

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
       hr = pTestVirtualDF->AdjustTreeOnCopyTo(pvcnRandomChild, pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualDF::AdjustTreeOnCopyTo")) ;
    }

    // Commit if g_fRevert is false, else revert

    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
        else
        {
            hr = pVirtualDFRoot->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
    }

    if(S_OK == hr)
    {
        hr = CloseRandomVirtualCtrNodeStg(pvcnRandomChild);

        DH_HRCHECK(hr, TEXT("CloseRandomVirtualCtrNodeStg")) ;
    }

    // Calculate the CRC now for the docfile

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC2);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Enumerate the DocFile now

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot,VERIFY_SHORT,&cResStg, &cResStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
   
    // For verification, if this was a commit opeartion, then CRC's won't match
    // ,verify by checking total number of VirtualCtrNodes and VirtualStmNodes
    // expected as result of copy opeartion, therby number of IStorages/IStreams 
    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            if(cResStg == cTotalStg + (cChildStg-1))
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Commit not as exp")));
            } 

            if(cResStm == cTotalStm + cChildStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit not as exp.")));
            } 
        }
        else
        {
            if(cResStg == cTotalStg)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert not as exp.")));
            } 

            if(cResStm == cTotalStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert not as exp.")));
            }
        }
    }

    // If revert operations, the CRC's should match.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's match as exp after CopyTo & Revert Ops")));
        }
        else
        {
            fPass = FALSE;
        
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's don't match as exp after CopyTo & Revert Ops")));
        }
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_101 
//
// Synopsis: A random root DF is created with random storages/stms, committed 
//       The root docfile is tree is then searched for, and for each child
//       IStorage found, the CRC is computed for that IStorage (only
//       if Revert wasn't specified on the command line).  A new child IStorage
//       is then created in the root docfile with a unique, random name.  
//       If Revert was specified in command line,this new empty stg is CRC'd
//       The IStorage is then copied to the new child IStorage via CopyTo(). If
//       Revert was *not* speficied, the new child IStorage and the root 
//       docfile are committed, else the dest IStorage is Reverted().  The CRC 
//       is then computed for the dest IStorage and the CRCs are compared.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    17-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCCWPAR.CXX
// 2.  Old name of test : LegitCopyChildDFWithinParent Test 
//     New Name of test : VCPYTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-101
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTravChild          = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPSTORAGE       pStgChild               = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt valid copyto fm childstg to new child stg of parent")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG whole df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Go in a loop and for each child storage (child VirtualCtrNode) found,
    // do a CopyTo operation.  Verify with CRC mechanism usnder both commit/
    // Rvert conditions.

    if (S_OK == hr)
    {
        pvcnTravChild = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        if(NULL == pvcnTravChild)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualDF tree depth inadeuate to have a child.")));
            
            hr = S_FALSE;
        }
    }

    while((NULL != pvcnTravChild) && (S_OK == hr))
    {
        if(S_OK == hr)
        {
            hr = ParseVirtualDFAndCloseOpenStgsStms(
                    pvcnTravChild, 
                    NODE_EXC_TOPSTG);
        }

        // Calculate CRC for this child VirtualCtrNode

        if((S_OK == hr) && (FALSE == g_fRevert))
        {
            pStgChild = pvcnTravChild->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Now add a new storage
    
        if(S_OK == hr)
        {
            // Generate random name for storage

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            hr = AddStorage(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStgName,
                    dwStgMode | STGM_FAILIFTHERE,
                    &pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("AddStorage")) ;
            DH_ASSERT(S_OK == hr);
        }

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("AddStorage successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage unsuccessful, hr=0x%lx."),
                hr));
        }

        if((S_OK == hr) && (TRUE == g_fRevert))
        {
            pStgChild = pvcnRootNewChildStg->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }


        if(S_OK == hr)
        {
            hr = pvcnTravChild->CopyTo(0, NULL, NULL, pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
        }
        
        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr) 
        {
            if(FALSE == g_fRevert)
            {
                // Commit the new VirtualCtrNode and Root Node

                hr = pvcnRootNewChildStg->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }

                if(S_OK == hr)
                {
                    hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
                }

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Root VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Root VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
            else
            {
                // Revert the new child storage
                
                hr = pvcnRootNewChildStg->Revert();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Revert successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
        }

        // Calculate CRC for the destination storage now

        if(S_OK == hr)
        {
            pStgChild = pvcnRootNewChildStg->GetIStoragePointer();

            if(NULL == pStgChild)
            {
                hr = E_FAIL;
            }
        }

        if(S_OK == hr)
        {
            hr = CalculateCRCForDocFile(
                    pStgChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC2);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Verify CRC

        if((S_OK == hr) && (dwCRC1 == dwCRC2))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg match.")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg don't match.")));
            
            break;
        }

        // Release source child stg
        
        if(NULL != pvcnTravChild) 
        {
            hr = pvcnTravChild->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Release new child stg
        
        if(NULL != pvcnRootNewChildStg) 
        {
            hr = pvcnRootNewChildStg->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Destory new child stg since we are done with it.  Also the while
        // loop condition depends upon original number of VirtualCtrNodes

        if(NULL !=  pvcnRootNewChildStg)
        {
            hr =  DestroyStorage(pTestVirtualDF, pvcnRootNewChildStg);
            DH_HRCHECK(hr, TEXT("DestroyStorage")) ;
        }

        // Release temp string

        if(NULL != pRootNewChildStgName)
        {
            delete pRootNewChildStgName;
            pRootNewChildStgName = NULL;
        }

        // Advance pvcnTravChild to next and reset pointers to NULL. 

        pvcnTravChild = pvcnTravChild->GetFirstSisterVirtualCtrNode();
        pStgChild = NULL;
        pvcnRootNewChildStg = NULL;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_102 
//
// Synopsis: A random root DF is created with random storages/stms. 
//       The root docfile is searched for until an IStorage is found that is 
//       a grandchild of the root IStorage. The docfile is commited.
//       The grandchild IStorage is then copied with the destination being 
//       the root docfile itself.
//       If the 'Rever' switch was specified, the root docfile
//       is then reverted and the CRC is recomputed on the root docfile
//       and compared to the before copy CRC to verify that no changes
//       occurred in the docfile hierarchy.  Also it is verified by enum
//       rating the docfile before and after opeartion and testing the total
//       number of storages and streams in file remain unchanged.
//       If case of Revert being FALSE, the contents of the grandchild IStorage 
//       should be merged in with the contents of the root level of the docfile.
//       Verify this case by enumerating the docfile before and after
//       CopyTo is done and test that the resulting number of storages &
//       streams in the DocFile is as expected. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    17-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCGCTANC.CXX
// 2.  Old name of test : LegitCopyChildDFToAncestorDF Test 
//     New Name of test : VCPYTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-102
//
// This test is almost same as VCPYTEST-100 with difference being that the
// root's grandchild's contents are copied to the root. The difference in
// code is in picking up the random child and in command line parameters. 
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTrav               = NULL;
    VirtualCtrNode  *pvcnRandomParent       = NULL;
    VirtualCtrNode  *pvcnRandomGrandChild   = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgGrandChild          = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cChildStg               = 0;
    ULONG           cChildStm               = 0;
    ULONG           cResStg                 = 0;
    ULONG           cResStm                 = 0;
    ULONG           cDepth                  = 0;
    BOOL            fPass                   = TRUE;
    ULONG           cChildren               = 0;
    ULONG           cGrandChildren          = 0;
    ULONG           cParentOfGrandChild     = 0;
    ULONG           cRandomGrandChild       = 0;
    ULONG           cRandomParent           = 0;
    ULONG           counter                 = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt valid copyto operatons from grandchild to root stg")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }
   
    // Find a random grandchild VirtualCtrNode in the file.  

    // For that first find a random child storage in tree that has grandchild
    // storages in tree

    if(S_OK == hr)
    {
        cChildren = pVirtualDFRoot->GetVirtualCtrNodeChildrenCount();

        if(0 == cChildren)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Max tree depth inadequate to find a child")));

            hr = S_FALSE;
        }
    }

    // Find child nodes with grandchildren.

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        DH_ASSERT(NULL != pvcnTrav);

        while(NULL != pvcnTrav)
        {
            if(0 != pvcnTrav->GetVirtualCtrNodeChildrenCount())
            {
                cParentOfGrandChild++;
            }
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }

        if(0 == cParentOfGrandChild)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Max tree depth inadequate to find grandchild")));

            hr = S_FALSE;
        }
    }

    // Pick up a random Parent VirtualCtrNode whos have Grand children
    // Generate random number
    
    if(S_OK == hr)
    {
        // Find a random child storage to pick from

        usErr = pdgi->Generate(&cRandomParent, 1, cParentOfGrandChild);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Pick up the random parent
    if(S_OK == hr)
    {
        pvcnTrav = pVirtualDFRoot->GetFirstChildVirtualCtrNode();
        while(NULL != pvcnTrav)
        {
            if(0 != pvcnTrav->GetVirtualCtrNodeChildrenCount())
            {
                counter++;
            }
            if(counter == cRandomParent)
            {
                pvcnRandomParent = pvcnTrav;
                break;
            }
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }
    }

    // Now pick up a random GrandChild storage node from the above random
    // parent 

    if(S_OK == hr)
    {
        cGrandChildren = pvcnRandomParent->GetVirtualCtrNodeChildrenCount();
        DH_ASSERT(0 != cGrandChildren);
 
        // Find a random grandchild storage to pick from

        usErr = pdgi->Generate(&cRandomGrandChild, 1, cGrandChildren);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        if(S_OK == hr)
        {
            pvcnRandomGrandChild = 
                pvcnRandomParent->GetFirstChildVirtualCtrNode();

            while((0 != --cRandomGrandChild) && (NULL != pvcnRandomGrandChild))
            {
                pvcnRandomGrandChild = 
                    pvcnRandomGrandChild->GetFirstSisterVirtualCtrNode();
            }
        }
    }

    // Commit the storages from here upto root.

    if(S_OK == hr)
    {
        hr = pvcnRandomGrandChild->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if(S_OK == hr)
    {
        hr = pvcnRandomParent->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close all  open stgs/stms except root

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get IStorage pointer for Root

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot) ;
        if(NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }
   
    // Calulcate CRC for entire docfile.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Find the total number of VirtualCtrNodes and VirtualStmNodes in the
    // DocFile

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT,&cTotalStg, &cTotalStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
  
    // Open the grandChildStg from where CopyTo would be done to root.
 
    if(S_OK == hr)
    {
        hr = OpenRandomVirtualCtrNodeStg(pvcnRandomGrandChild, dwStgMode);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    // get its istorage pointer.

    if(S_OK == hr)
    {
        pStgGrandChild = pvcnRandomGrandChild->GetIStoragePointer();

        DH_ASSERT(NULL != pStgGrandChild) ;
        if(NULL == pStgGrandChild)
        {
            hr = E_FAIL;
        }
    }
   
    // Find the total number of VirtualCtrNode(s) and VirtualStmNode(s) under
    // this node. Used for verification of copyto operation.

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(
                pStgGrandChild,
                VERIFY_SHORT,
                &cChildStg,
                &cChildStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }

    // Copy everything under this child node to the Root node.

    if(S_OK == hr)
    {
       hr = pvcnRandomGrandChild->CopyTo(0, NULL, NULL, pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Adjust the virtual tree as a result of above operation.

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
       hr = pTestVirtualDF->AdjustTreeOnCopyTo(
                pvcnRandomGrandChild, 
                pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualDF::AdjustTreeOnCopyTo")) ;
    }

    // Commit if g_fRevert is false, else revert

    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
        else
        {
            hr = pVirtualDFRoot->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
    }

    if(S_OK == hr)
    {
        hr = CloseRandomVirtualCtrNodeStg(pvcnRandomGrandChild);

        DH_HRCHECK(hr, TEXT("CloseRandomVirtualCtrNodeStg")) ;
    }

    // Calculate the CRC now for the docfile

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC2);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Enumerate the DocFile now

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot,VERIFY_SHORT,&cResStg, &cResStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
   
    // For verification, if this was a commit opeartion, then CRC's won't match
    // ,verify by checking total number of VirtualCtrNodes and VirtualStmNodes
    // expected as result of copy opeartion, therby number of IStorages/IStreams 
    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            if(cResStg == cTotalStg + (cChildStg-1))
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Commit not as exp")));
            } 

            if(cResStm == cTotalStm + cChildStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit not as exp.")));
            } 
        }
        else
        {
            if(cResStg == cTotalStg)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert not as exp.")));
            } 

            if(cResStm == cTotalStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert not as exp.")));
            }
        }
    }

    // If revert operations, the CRC's should match.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's match as exp after CopyTo & Revert Ops")));
        }
        else
        {
            fPass = FALSE;
        
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's don't match as exp after CopyTo & Revert Ops")));
        }
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_103 
//
// Synopsis: A random root DF is created with random storages/stms, committed 
//       The root docfile is tree is then searched for, and for each grandchild
//       IStorage found, the CRC is computed for that IStorage (only
//       if Revert wasn't specified on the command line).  A new child IStorage
//       is then created in the root docfile with a unique, random name.  
//       If Revert was specified in command line,this new empty stg is CRC'd
//       The GrandChild IStorage is copied to new child IStorage via CopyTo().If
//       Revert was *not* speficied, the new child IStorage and the root 
//       docfile are committed, else the dest IStorage is Reverted().  The CRC 
//       is then computed for the dest IStorage and the CRCs are compared.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCGCWANC.CXX
// 2.  Old name of test : LegitCopyGrandChildDFWithinAncestorDF Test 
//     New Name of test : VCPYTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-103
//
// This test is almost same as VCPYTEST-101 with difference being that the
// root's grandchild's contents are copied to the root's new child stg. 
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTravGrandChild     = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPSTORAGE       pStgGrandChild          = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt copyto fm grandchild stg to new childstg of grandparent")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Go in a loop and for each grandchild storage (grandchild VirtualCtrNode)
    // found, do a CopyTo operation.  Verify with CRC mechanism under both 
    // commit/Revert conditions.

    if (S_OK == hr)
    {
        VirtualCtrNode* pNode = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        //keep looking till we think we find one
        while (NULL != pNode && NULL == pNode->GetFirstChildVirtualCtrNode())
        {
            pNode = pNode->GetFirstSisterVirtualCtrNode();
        }
        //this one has the the grandchild        
        if (NULL != pNode)
        {
            pvcnTravGrandChild = pNode->GetFirstChildVirtualCtrNode();
        }

        if (NULL == pvcnTravGrandChild)
        {
            hr = S_FALSE;
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualDF tree depth inadequate to have grandChild.")));
        }
    }

    while((NULL != pvcnTravGrandChild) && (S_OK == hr))
    {
        if(S_OK == hr)
        {
            hr = ParseVirtualDFAndCloseOpenStgsStms(
                    pvcnTravGrandChild, 
                    NODE_EXC_TOPSTG);
        }

        // Calculate CRC for this grandchild VirtualCtrNode

        if((S_OK == hr) && (FALSE == g_fRevert))
        {
            pStgGrandChild = pvcnTravGrandChild->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgGrandChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Now add a new storage
    
        if(S_OK == hr)
        {
            // Generate random name for storage

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            hr = AddStorage(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStgName,
                    dwStgMode | STGM_FAILIFTHERE,
                    &pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("AddStorage")) ;
            DH_ASSERT(S_OK == hr);
        }

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("AddStorage successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage unsuccessful, hr=0x%lx."),
                hr));
        }

        if((S_OK == hr) && (TRUE == g_fRevert))
        {
            pStgGrandChild = pvcnRootNewChildStg->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgGrandChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }


        if(S_OK == hr)
        {
            hr = pvcnTravGrandChild->CopyTo(0, NULL, NULL, pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
        }
        
        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr) 
        {
            if(FALSE == g_fRevert)
            {
                // Commit the new VirtualCtrNode and Root Node

                hr = pvcnRootNewChildStg->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }

                if(S_OK == hr)
                {
                    hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
                }

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Root VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Root VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
            else
            {
                // Revert the new child storage
                
                hr = pvcnRootNewChildStg->Revert();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Revert successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
        }

        // Calculate CRC for the destination storage now

        if(S_OK == hr)
        {
            pStgGrandChild = pvcnRootNewChildStg->GetIStoragePointer();
            if(NULL == pStgGrandChild)
            {
                hr = E_FAIL;
            }
        }

        if(S_OK == hr)
        {
            hr = CalculateCRCForDocFile(
                    pStgGrandChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC2);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Verify CRC

        if((S_OK == hr) && (dwCRC1 == dwCRC2))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg match.")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg don't match.")));
            
            break;
        }

        // Release source child stg
        
        if(NULL != pvcnTravGrandChild) 
        {
            hr = pvcnTravGrandChild->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Release new child stg
        
        if(NULL != pvcnRootNewChildStg) 
        {
            hr = pvcnRootNewChildStg->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Destory new child stg since we are done with it.  Also the while
        // loop condition depends upon original number of VirtualCtrNodes

        if(NULL !=  pvcnRootNewChildStg)
        {
            hr =  DestroyStorage(pTestVirtualDF, pvcnRootNewChildStg);
            DH_HRCHECK(hr, TEXT("DestroyStorage")) ;
        }

        // Release temp string

        if(NULL != pRootNewChildStgName)
        {
            delete pRootNewChildStgName;
            pRootNewChildStgName = NULL;
        }

        // Advance pvcnTravGrandChild to next and reset pointers to NULL. 

        pvcnTravGrandChild = pvcnTravGrandChild->GetFirstSisterVirtualCtrNode();
        pStgGrandChild = NULL;
        pvcnRootNewChildStg = NULL;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_103 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_104 
//
// Synopsis: A random root DF is created with random storages/stms, committed .
//       Then CRC is computed for entire entire docfile.  A new root docfile 
//       with a random name is then created.  The original root docfile is next
//       copied to the new root docfile via CopyTo() and the new root docfile 
//       is committed.  The CRC is computed for the new docfile and the CRCs 
//       are compared. If revert flag given, the new root docfile is reverted
//       instead of committed and the CRC of the new tree is compared
//       against the CRC of the empty tree.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCROOT.CXX
// 2.  Old name of test : LegitCopyDFToRootDF Test 
//     New Name of test : VCPYTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-104
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    ChanceDF        *pNewTestChanceDF       = NULL;
    VirtualDF       *pNewTestVirtualDF      = NULL;
    VirtualCtrNode  *pNewVirtualDFRoot      = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPSTORAGE       pStgRootFirstDF         = NULL;
    LPSTORAGE       pStgRootSecondDF        = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;
    CDFD            cdfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_104 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt copyto from one Root DocFile to new DocFile root")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close all  open stgs/stms except root

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    if ((S_OK == hr) && (FALSE == g_fRevert))
    {
        pStgRootFirstDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootFirstDF);

        hr = CalculateCRCForDocFile(
                pStgRootFirstDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Now Create a new DocFile with random name.

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pNewTestChanceDF = new ChanceDF();
        if(NULL == pNewTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = pTestChanceDF->GetSeed();
        cdfd.dwRootMode   = dwRootMode;

        hr = pNewTestChanceDF->Create(&cdfd, pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("pNewTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pNewTestVirtualDF = new VirtualDF();
        if(NULL == pNewTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pNewTestVirtualDF->GenerateVirtualDF(
                pNewTestChanceDF, 
                &pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pNewTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        pStgRootSecondDF = pNewVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootSecondDF);
        if(NULL == pStgRootSecondDF)
        {
            hr = E_FAIL;
        }
    }
    
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = CalculateCRCForDocFile(
                pStgRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }
        
    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr) 
    {
        if(FALSE == g_fRevert)
        {
            // Commit the new Root Node

            hr = pNewVirtualDFRoot->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Commit successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                    hr));
            }
        }
        else
        {
            // Revert the new root storage
                
            hr = pNewVirtualDFRoot->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Revert successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                    hr));
            }
        }
    }

    // Calculate CRC for the destination root storage now

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pStgRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Verify CRC

    if((S_OK == hr) && (dwCRC1 == dwCRC2))
    {
        DH_TRACE((
           DH_LVL_TRACE1, 
           TEXT("CRC's of source docfile and dest docfile match.")));
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("CRC's of source docfile and dest docfile don't match.")));
            
    }

    // Close first Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close second Root Docfile.

    if (S_OK == hr)
    {
        hr = pNewVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_104 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete Chance docfile tree for second DocFile

    if(NULL != pNewTestChanceDF)
    {
        hr2 = pNewTestChanceDF->DeleteChanceDocFileTree(
                pNewTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pNewTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pNewTestChanceDF;
        pNewTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree for second docfile

    if(NULL != pNewTestVirtualDF)
    {
        hr2 = pNewTestVirtualDF->DeleteVirtualDocFileTree(pNewVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pNewTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pNewTestVirtualDF;
        pNewTestVirtualDF = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_105 
//
// Synopsis: A random root DF is created with random storages/stms, committed .
//       Then CRC is computed for entire entire docfile.  A new root docfile 
//       with a random name is then created and a child storage is created
//       inside that.  The original root docfile is next copied to the child
//       storage of new root docfile via CopyTo() and the new child & root  
//       is committed.  The CRC is computed for child storage of new docfile 
//       and the CRCs are compared. If revert flag given, the new root docfile 
//       child stg is reverted instead of committed and the CRC of the new 
//       tree's child stg is compared against the CRC of the child stg before
//       revert.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  19-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCNEWPAR.CXX
// 2.  Old name of test : LegitCopyDFWithinNewPar Test 
//     New Name of test : VCPYTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-105
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    ChanceDF        *pNewTestChanceDF       = NULL;
    VirtualDF       *pNewTestVirtualDF      = NULL;
    VirtualCtrNode  *pNewVirtualDFRoot      = NULL;
    VirtualCtrNode  *pvcnNewRootNewChildStg = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPSTORAGE       pStgRootFirstDF         = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPTSTR          pNewRootNewChildStgName = NULL;
    LPSTORAGE       pStgChildRootSecondDF   = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;
    CDFD            cdfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_105 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Do copyto fm one Root DocFile to new DocFile's child stg")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close all  open stgs/stms except root

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    if ((S_OK == hr) && (FALSE == g_fRevert))
    {
        pStgRootFirstDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootFirstDF);

        hr = CalculateCRCForDocFile(
                pStgRootFirstDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Now Create a new DocFile with random name.

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pNewTestChanceDF = new ChanceDF();
        if(NULL == pNewTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = pTestChanceDF->GetSeed();
        cdfd.dwRootMode   = dwRootMode;

        hr = pNewTestChanceDF->Create(&cdfd, pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("pNewTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pNewTestVirtualDF = new VirtualDF();
        if(NULL == pNewTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pNewTestVirtualDF->GenerateVirtualDF(
                pNewTestChanceDF, 
                &pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pNewTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Create a new child storage in this new root docfile.

    if(S_OK == hr)
    {
        // Generate random name for this child stg 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pNewVirtualDFRoot,
                pNewRootNewChildStgName,
                dwStgMode | STGM_FAILIFTHERE,
                &pvcnNewRootNewChildStg);
    }

    if(S_OK == hr)
    {
       DH_TRACE((DH_LVL_TRACE1, TEXT("AddStorage successful.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("AddStorage unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        pStgChildRootSecondDF = pvcnNewRootNewChildStg->GetIStoragePointer();

        DH_ASSERT(NULL != pStgChildRootSecondDF);
        if(NULL == pStgChildRootSecondDF)
        {
            hr = E_FAIL;
        }
    }
    
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = CalculateCRCForDocFile(
                pStgChildRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pvcnNewRootNewChildStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }
        
    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr) 
    {
        if(FALSE == g_fRevert)
        {
            // Commit the new VirtualCtrNode and Root Node

            hr = pvcnNewRootNewChildStg->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Commit successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                    hr));
            }

            if(S_OK == hr)
            {
                hr = pNewVirtualDFRoot->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Root VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Root VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
        }
        else
        {
            // Revert the new child storage
                
            hr = pvcnNewRootNewChildStg->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Revert successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                    hr));
            }
        }
    }

    // Calculate CRC for the destination storage now

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pStgChildRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Verify CRC

    if((S_OK == hr) && (dwCRC1 == dwCRC2))
    {
        DH_TRACE((
           DH_LVL_TRACE1, 
           TEXT("CRC's of source docfile and dest docfile's stg match.")));
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
           DH_LVL_TRACE1, 
           TEXT("CRC's of source docfile &dest docfile's stg don't match.")));
            
    }

    // Close first Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close second Root Docfile's child stg.

    if (S_OK == hr)
    {
        hr = pvcnNewRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."), 
            hr));
    }

    // Close second Root Docfile.

    if (S_OK == hr)
    {
        hr = pNewVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_105 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete Chance docfile tree for second DocFile

    if(NULL != pNewTestChanceDF)
    {
        hr2 = pNewTestChanceDF->DeleteChanceDocFileTree(
                pNewTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pNewTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pNewTestChanceDF;
        pNewTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree for second docfile

    if(NULL != pNewTestVirtualDF)
    {
        hr2 = pNewTestVirtualDF->DeleteVirtualDocFileTree(pNewVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pNewTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pNewTestVirtualDF;
        pNewTestVirtualDF = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != pNewRootNewChildStgName)
    {
        delete pNewRootNewChildStgName;
        pNewRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_106 
//
// Synopsis: A root docfile is created and two streams are created within it,
//           a SOURCE IStream and a DEST IStream. A clone is made of the DEST
//           IStream. A random number of bytes are written to the SOURCE
//           IStream.
//           From 10 to 20 times, a random starting position and number of
//           bytes to copy is chosen in the SOURCE IStream.  These bytes are
//           read and CRC'd and the SOURCE IStream seek pointer is then
//           repositoned to the intended copy source offset. A random copy
//           destination offset is chosen in either the DEST or CLONE IStream.
//           The non-target regions of the destination IStream (those bytes
//           before and after the copy target region) are read and CRC'd
//           and the destination seek pointer is re-positioned to the
//           destination offset.  The SOURCE IStream region is then copied to
//           destination (DEST or CLONE) IStream.  The entire destination
//           stream is then read and CRCs are verified to ensure that the copy
//           was successful.
//          
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LCSTREAM.CXX
// 2.  Old name of test(s) : LegitCopyStream test 
//     New Name of test(s) : VCPYTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-106
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-106
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-106
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: VCPYTEST-106
//
// History:  Jiminli	24-July-96	Created
//-----------------------------------------------------------------------------
 
HRESULT VCPYTEST_106(int argc, char *argv[])
{

    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptcsBuffer              = NULL;
    LPBYTE          ptcsReadBuffer          = NULL;
    USHORT          usNumIterations         = 0;
    USHORT          usMinIteration          = 10;
    USHORT          usMaxIteration          = 20;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           culBytesRead            = 0;
    ULONG           ulIStreamSize           = 0;
    ULONG           culIOBytes              = 0;
    ULONG           culWritten              = 0; 
    ULONG           culRead                 = 0;
    ULONG           culRandomCommit         = 0;
    ULONG           ulRef                   = 0;
    DWORD           dwRootMode              = 0; 
    DWORD           dwCRC[3][3];
    DWORD           dwTempCRC               = 0; 
    DWORD           dwSourceCRC             = 0;
    BYTE            biIStream               = 0;
    BYTE            biInUse                 = 0;
    BOOL            fPass                   = TRUE; 
    ULONG           ulPosition[3];
    ULONG           ulNewPosition[3];
    VirtualStmNode  *pvsnRootNewChildStream[2];        
    LPTSTR          pRootNewChildStmName[2];
    LPSTREAM        pIStream[3];
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uliCopy;
    ULARGE_INTEGER  uli;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt valid CopyTo operation b/w streams.")) );

    // Initialize pointers
    pIStream[SOURCESTM] = pIStream[DESTSTM] = pIStream[CLONESTM] = NULL;
    pRootNewChildStmName[SOURCESTM] = pRootNewChildStmName[DESTSTM] = NULL;
    pvsnRootNewChildStream[SOURCESTM] = pvsnRootNewChildStream[DESTSTM] = NULL;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds source and destination IStreams to the root storage.

    if (S_OK == hr)
    {
        // Generate random names for streams

        for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
        {
            pRootNewChildStmName[biIStream] = NULL;
            hr = GenerateRandomName(
                    pdgu, 
                    MINLENGTH, 
                    MAXLENGTH, 
                    &pRootNewChildStmName[biIStream]);

            if(S_OK != hr)
            {
                break;
            }
        }

        DH_HRCHECK(hr, TEXT("GenerateRandomName"));
    }

    if (S_OK == hr)
    {
        for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
        {
            // Initialize

            pIStream[biIStream] = NULL;
            ulPosition[biIStream] = 0L;

            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStmName[biIStream],
                    0,
                    STGM_READWRITE  |
                    STGM_SHARE_EXCLUSIVE |
                    STGM_FAILIFTHERE,
                    &pvsnRootNewChildStream[biIStream]);

            if(S_OK != hr)
            {
                break;
            }

            // Get IStream pointers

            if(S_OK == hr)
            {
                pIStream[biIStream] = pvsnRootNewChildStream[biIStream]->
                                        GetIStreamPointer();
            }
        }

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // 
    // Generate Cloned IStream

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStream[SOURCESTM]->Clone(&pIStream[CLONESTM]);
        ulPosition[CLONESTM] = 0L;

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Clone")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone not successful, hr=0x%lx."),
            hr));
    }

    // Pick a size for the source IStream

    if (S_OK == hr)
    {
        // Generate random size for stream between 1L, and MIN_SIZE * 1.5
        // (from old test)

        usErr = pdgi->Generate(&ulIStreamSize, 1L,  (ULONG) (MIN_SIZE * 1.5));
        culIOBytes = ulIStreamSize;

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Call VirtualStmNode::Write to create random bytes in the stream.  
    // For our test purposes, we generate a random string of size 
    // culIOBytes using GenerateRandomString function.
 
    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culIOBytes,
                culIOBytes, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream[SOURCESTM]->Write(
                (LPBYTE)ptcsBuffer,
                culIOBytes,
                &culWritten);
    }

    if (S_OK != hr)
    { 
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate dwSourceCRC to be used in the first pass of the loop

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culIOBytes,
                &dwSourceCRC);
    }

    if (S_OK != hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("CalculateCRCForDataBuffer wasn't successful, hr=0x%lx."),
            hr));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }
    
    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successfully, hr=0x%lx."),
            hr));
    }

    // Reposition to start offset of the source IStream

    if (S_OK == hr)
    {
        memset(&liStreamPos, ulPosition[SOURCESTM], sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream[SOURCESTM]->Seek(
                liStreamPos, 
                STREAM_SEEK_SET, 
                NULL);
        
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // For the first pass of the loop, we'll specify that the DEST IStream
    // (as opposed to the CLONE) IStream will be the copy destination.
    // Also, for the first pass, we'll copy the whole source IStream to 
    // dest/clone IStream, so the length of bytes before/after CopyTo both
    // are 0L, i.e. ulPosition[biInUse].

    biInUse = DESTSTM;
    
    if (S_OK == hr)
    {
        // Generate random # of small objects for test between 
        // usMinIteration and usMaxIteration 

        usErr = pdgi->Generate(
                    &usNumIterations, 
                    usMinIteration, 
                    usMaxIteration);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Random # of small objects to test is: %d"),
            usNumIterations));
    }

    // Before doing a copy, we read and CRC the bytes in the destinaiton
    // IStream(DEST or CLONE) that *won't* be overwritten by the copy
    // call because we'll later need to ensure that these bytes weren't
    // inadvertently changed by the copy - because that would be a bug.

    while ((S_OK == hr) && (0 != usNumIterations))
    {
        // ***BEFORE COPY***

        // Read & CRC bytes in dest/clone before intended CopyTo() start
        // Offset
           
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
   
        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    ulPosition[biInUse],
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwCRC[biInUse][BYTES_BEFORE]);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // read & CRC bytes in dest/clone after intended CopyTo() start offset

        if (S_OK == hr)
        {
            LISet32(liStreamPos, (ulPosition[biInUse] + culIOBytes));

            hr = pIStream[biInUse]->Seek(
                    liStreamPos, 
                    STREAM_SEEK_SET, 
                    NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    culBytesRead,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwCRC[biInUse][BYTES_AFTER]);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Position to dest/clone intended start offset, ready for CopyTo().

        if (S_OK == hr)
        {
            LISet32(liStreamPos, ulPosition[biInUse]);
            hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        // Copy from current position of SOURCE IStream to the specified 
        // position in the dest/clone IStream

        if (S_OK == hr)
        {
            ULISet32(uliCopy, culIOBytes);

            hr = pIStream[SOURCESTM]->CopyTo(
                    pIStream[biInUse],
                    uliCopy,
                    NULL,
                    NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::CopyTo not successful, hr=0x%lx."),
                hr));
        }

        // For variety, only commit to the root 50% of the time

        if (S_OK == hr)
        {
            usErr = pdgi->Generate(&culRandomCommit, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
               hr = E_FAIL;
            }
        }

        if ((S_OK == hr) && (culRandomCommit > 50))
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successfully, hr=0x%lx."),
                hr));
        }

        // ***AFTER COPY***

        // After the copy, verify that the source and destination seek pointers
        // are set correctly

        if (S_OK == hr)
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
            hr = pIStream[SOURCESTM]->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

            ulNewPosition[SOURCESTM] = ULIGetLow(uli);
        }

        if (S_OK != hr)
        {         
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }
        
        if ((S_OK == hr) && 
            (ulNewPosition[SOURCESTM] != (ulPosition[SOURCESTM] + culIOBytes)))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Source seek pointer incorrect after copy.")));

            fPass = FALSE;
        }

        if (S_OK == hr)
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
            hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

            ulNewPosition[biInUse] = ULIGetLow(uli);
        }

        if (S_OK != hr)
        {         
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if ((S_OK == hr) && 
            (ulNewPosition[biInUse] != (ulPosition[biInUse] + culIOBytes)))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Destination seek pointer incorrect after copy.")));

            fPass = FALSE;
        }

        // After copy, read & CRC bytes in dest/clone before CopyTo() start 
        // offset and compare CRCs to ensure that these bytes haven't changed

        if (S_OK == hr)
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
            hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    ulPosition[biInUse],
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwTempCRC);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (dwCRC[biInUse][BYTES_BEFORE] != dwTempCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC mismatched at bytes before CopyTo start offset.")));

            fPass = FALSE;
        }

        // Read & CRC bytes in dest/clone that were target of CopyTo()

        if (S_OK == hr)
        {
            culBytesRead = culIOBytes;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    culBytesRead,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwCRC[biInUse][BYTES_COPIED]);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (dwCRC[biInUse][BYTES_COPIED] != dwSourceCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC mismatched at bytes of CopyTo() target.")));

            fPass = FALSE;
        }

        // Read & CRC bytes in dest/clone after CopyTo() start offset

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    culBytesRead,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwTempCRC);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (dwCRC[biInUse][BYTES_AFTER] != dwTempCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC mismatched at bytes after CopyTo() target.")));

            fPass = FALSE;
        }

        if (--usNumIterations)
        {
            // if we'll be looping again, pick a random copy starting position
            // in the source IStream and a random number of bytes to copy.

            if (S_OK == hr)
            {
                usErr = pdgi->Generate(
                            &ulPosition[SOURCESTM], 
                            0L, 
                            ulIStreamSize);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if (S_OK == hr)
            {		
                if((ulIStreamSize - ulPosition[SOURCESTM]) > 0)
                {
                    usErr = pdgi->Generate(
                            &culIOBytes, 
                            1L, 
                            ulIStreamSize - ulPosition[SOURCESTM]);
                }
                else
                {
                    culIOBytes = 1L; 
                }

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            // Now seek, read and CRC the source bytes and then seek back to
            // the intended copy start position

            if (S_OK == hr)
            {
                LISet32(liStreamPos, ulPosition[SOURCESTM]);

                hr = pIStream[SOURCESTM]->Seek(
                        liStreamPos, 
                        STREAM_SEEK_SET, 
                        NULL);
            }

            if (S_OK != hr)
            { 
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Seek not successful, hr=0x%lx."),
                    hr));
            }

            if (S_OK == hr)
            {
                culBytesRead = culIOBytes;
                ptcsReadBuffer = new BYTE[culBytesRead];

                if (NULL == ptcsReadBuffer)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
    
            if (S_OK == hr)
            {
                memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

                hr = pIStream[SOURCESTM]->Read(
                        ptcsReadBuffer,
                        culIOBytes,
                        &culRead);
            }

            if (S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                    hr));
            }

            // culRead is the actual number of bytes read from IStream
 
            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        (LPTSTR)ptcsReadBuffer,
                        culRead,
                        &dwSourceCRC);
            }

            if (S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CalculateCRCForDataBuffer not Ok, hr=0x%lx."),
                    hr));
            }

            if (NULL != ptcsReadBuffer)
            {
                delete []ptcsReadBuffer;
                ptcsReadBuffer = NULL;
            }

            if (S_OK == hr)
            {
                LISet32(liStreamPos, ulPosition[SOURCESTM]);

                hr = pIStream[SOURCESTM]->Seek(
                        liStreamPos, 
                        STREAM_SEEK_SET, 
                        NULL);
            }

            if (S_OK != hr)
            { 
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Seek not successful, hr=0x%lx."),
                    hr));
            }

            // Pick an IStream for the copy destination and a destination
            // offset within that IStream

            if (S_OK == hr)
            {
                usErr = pdgi->Generate(&biInUse, DESTSTM, CLONESTM);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if (S_OK == hr)
            {
                usErr = pdgi->Generate(&ulPosition[biInUse], 0L, ulIStreamSize);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }
        }

        if ((S_OK != hr) || (TRUE != fPass))
        { 
            break;
        }
    }

    // Release Clone stream

    if (NULL != pIStream[CLONESTM])
    {
        ulRef = pIStream[CLONESTM]->Release();

        DH_ASSERT(0 == ulRef);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close unsuccessful.")));
    }

    // Release all streams, irrespective of result

    if (S_OK == hr)
    {
        for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
        {
            hr = pvsnRootNewChildStream[biIStream]->Close();

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::Close completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
    }

    // Release Root

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation VCPYTEST_106 failed, hr=0x%lx."),
              hr));
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
    {
        if (NULL != pRootNewChildStmName[biIStream])
        {
            delete pRootNewChildStmName[biIStream];
            pRootNewChildStmName[biIStream] = NULL;
        }
    }

    // Stop logging the test

	DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_106 finished")) );
	DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\util.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       utl.cxx
//
//  Contents:   utilities for OLE storage base tests
//
//  Functions:   
//
//  History:    NarindK     Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "init.hxx"

//global array of interesting file sizes for IStream read/writes

USHORT ausSIZE_ARRAY[] =
    {0,1,2,255,256,257,511,512,513,2047,2048,2049,4095,4096,4097};

// externs
extern BOOL g_fUseStdBlk;
extern  ULONG           ulStreamSize;
extern  USHORT          usIterations;
extern  LPTSTR          ptszNames[MAX_DOCFILES];
extern  ULONG           *ulSeekOffset;
extern  TIMEINFO        Time[];

//----------------------------------------------------------------------------
//
// Function: CountFilesInDirectory
//
// Synopsis: count number of files in directory matching wildcard mask
//
// Arguments: [pszWildMask] - wild card mask string of files to find
//
// Returns: number of files found
//
// History: 2-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

ULONG CountFilesInDirectory(LPTSTR  ptszWildMask)
{
#ifdef _MAC
    DH_LOG((
           LOG_INFO,
           TEXT("!!!!!!!!!!!!!!CountFilesInDirectory not implemented yet.\n")));
      return 0;
#else
    
    ULONG           culFilesInDirectory     = 0;
    DWORD           cChar                   = 0;
    HANDLE          hFind                   = NULL;
    TCHAR           ptszTmpFileDir[_MAX_PATH];
    TCHAR           ptszTmpFilePath[_MAX_PATH];
    WIN32_FIND_DATA wfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CountFilesInDirectory"));

    cChar = GetEnvironmentVariable(
                TEXT("TMP"), 
                ptszTmpFileDir, 
                sizeof(ptszTmpFileDir));

    DH_ASSERT(0 != cChar);

    if (0 != cChar)
    {
        _tcscpy(ptszTmpFilePath, ptszTmpFileDir);
        _tcscat(ptszTmpFilePath, TEXT("\\"));
    }
    else
    {
        _tcscpy(ptszTmpFilePath, TEXT("C:\\"));
    }

    _tcscat(ptszTmpFilePath, ptszWildMask);

    DH_LOG((
        LOG_INFO,
        TEXT("Counting %s files in %s directory\n"),
        ptszWildMask,
        ptszTmpFileDir == NULL ? TEXT("C:\\") : ptszTmpFileDir));

    hFind = FindFirstFile(ptszTmpFilePath, &wfd);

    if(INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if(wfd.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)
            {
                culFilesInDirectory++;
            }
        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    DH_LOG((
        LOG_INFO,
        TEXT("Number of %s files in %s directory = %lu\n"),
        ptszWildMask,
        ptszTmpFileDir == NULL ? TEXT("C:\\") : ptszTmpFileDir,
        culFilesInDirectory));

    return culFilesInDirectory;
#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Function: GetRandomSeekOffset 
//
// Synopsis: Gets a random seek offset from either standard array or a random
//           number 
//
// Arguments: [plSeekPosition] - Pointer to seek position
//            [pdgi]           - Pointer to data generator object
//
// Returns: HResult 
//
// History: 5-Jul-1996    Narindk  Created
//
//-----------------------------------------------------------------------------

HRESULT GetRandomSeekOffset(LONG  *plSeekPosition, DG_INTEGER *pdgi)
{
    HRESULT hr              =   S_OK;
    ULONG   cArrayIndex     =   0;
    USHORT  usErr           =   0;
    LONG    lSeekPosition   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetRandomSeekOffset"));

    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(plSeekPosition, LONG ) ;

    DH_ASSERT(NULL != pdgi);

    if(TRUE == g_fUseStdBlk)
    {
       // Pick up a random array element.

        usErr = pdgi->Generate(&cArrayIndex, 0, MAX_SIZE_ARRAY);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            *plSeekPosition = *plSeekPosition + ausSIZE_ARRAY[cArrayIndex];
        }
    }
    else
    {
        // Pick up a random offset
        usErr = pdgi->Generate(
                     &lSeekPosition,
                     0,
                     ausSIZE_ARRAY[MAX_SIZE_ARRAY] * MAX_SIZE_MULTIPLIER );

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            *plSeekPosition = *plSeekPosition + lSeekPosition;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: SetItemsInStorage 
//
// Synopsis: Does random SetClass / SetStateBits/ Commit / Revert operations
//          on passed IStorage.
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to data generator object
//
// Returns: HResult 
//
// History: 15-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

HRESULT SetItemsInStorage(VirtualCtrNode *pvcn, DG_INTEGER *pdgi)
{
    HRESULT hr                  =   S_OK;
    USHORT  usErr               =   0;
    ULONG   cRandomVar          =   0;
    ULONG   cRandomClsid        =   0;
    ULONG   cMinVar             =   16;
    ULONG   cMaxVar             =   32;
    DWORD   grfStateBits        =   0;
    DWORD   grfMask             =   0;
    DWORD   grfDesiredStateBits =   0;
    BOOL    fStateBitsChanged   =   FALSE;
    BOOL    fPass               =   TRUE;
    STATSTG statStgCommited;
    STATSTG statStgCurrent;
    STATSTG statStgNew;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("SetItemsInStorage"));

    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);

    if (S_OK == hr)
    {
        // Generate random number of variations.

        usErr = pdgi->Generate(&cRandomVar, cMinVar, cMaxVar);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    //initialize STATSTG containing info about what is on persistent store

    if(S_OK == hr)
    {
        hr = pvcn->Stat(&statStgCommited, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
           LOG_INFO,
           TEXT("VirtualCtrNode::Stat completed successfully.\n")));
    }
    else
    {
        DH_LOG((
           LOG_INFO,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx.\n"),
           hr));
    }

    // Start while loop

    while((S_OK == hr) && (0 != cRandomVar))
    {
        if(S_OK == hr)
        {
            hr = pvcn->Stat(&statStgCurrent, STATFLAG_NONAME);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        }

        if(S_OK == hr)
        {
            // Randomly either change the CLSID or State Bits.

            if(0 == cRandomVar%2)
            {
                usErr = pdgi->Generate(&cRandomClsid, 1, 3);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
               
                if(S_OK == hr)
                {
                    // Call Set Class to change CLSID

                    switch(cRandomClsid)
                    {
                        case 1:
                        {
                            hr = pvcn->SetClass(IID_IUnknown); 
                            
                            break;
                        }
                        case 2:
                        {
                            hr = pvcn->SetClass(IID_IStorage); 
                            
                            break;
                        }
                        case 3:
                        {
                            hr = pvcn->SetClass(IID_IStream); 
                            
                            break;
                        }
                    }

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetClass")) ;
                }
            }
            else 
            {
                // Set boolean to true indicatinng changing state bits

                fStateBitsChanged = TRUE;

                usErr = pdgi->Generate(&grfStateBits, 0, ULONG_MAX);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
              
                if(S_OK == hr)
                {
                    usErr = pdgi->Generate(&grfMask, 0, ULONG_MAX);

                    if (DG_RC_SUCCESS != usErr)
                    {
                        hr = E_FAIL;
                    }
                }

                if(S_OK == hr)
                {
                    grfDesiredStateBits = (grfStateBits & grfMask) |
                                    (statStgCurrent.grfStateBits & ~grfMask); 

                    // Call SetStateBits to change State Bits

                    hr = pvcn->SetStateBits(grfStateBits, grfMask); 

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetStateBits")) ;
                }
            }
        }

        if(S_OK == hr)
        {
            // Get information about new state

            hr = pvcn->Stat(&statStgNew, STATFLAG_NONAME);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        }

        // Verify the new State

        // Verify state bits

        if((S_OK == hr) && (TRUE == fStateBitsChanged))
        {
            if(statStgNew.grfStateBits != grfDesiredStateBits)
            {
                fPass = FALSE;

                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits not changed correctly.\n")));

                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits Actual: 0x%lx, Exp: 0x%lx.\n"),
                    statStgNew.grfStateBits,
                    grfDesiredStateBits));
            }
            else
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits changed correctly.\n")));

                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits Actual: 0x%lx, Exp: 0x%lx.\n"),
                    statStgNew.grfStateBits,
                    grfDesiredStateBits));
            }
        }

        // Verify CLSID
    
        if(S_OK == hr)
        {
            switch(cRandomClsid)
            {
                case 1:
                {
                    if(!IsEqualCLSID(statStgNew.clsid, IID_IUnknown))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass didn't set CLSID IID_IUnknown.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass set CLSID to IID_IUnknown.\n")));
                    }

                    break;
                }
                case 2:
                {
                    if(!IsEqualCLSID(statStgNew.clsid, IID_IStorage))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass didn't set CLSID IID_IStorage.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass set CLSID to IID_IStorage.\n")));
                    }
                    break;
                }
                case 3:
                {
                    if(!IsEqualCLSID(statStgNew.clsid, IID_IStream))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass didn't set CLSID IID_IStream.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass set CLSID to IID_IStream.\n")));
                    }
                    break;
                }
            }
        }

        // Modify hr if required based on fPass Value so that we can fall
        // out of this loop in error.

        if((S_OK == hr) && (FALSE == fPass))
        {
            hr = S_FALSE;
        }

        // Do random commit or revert operations and verify the State then

        if(S_OK == hr)
        {
            // Randomly either commit or Revert.

            if(0 == cRandomVar%2)
            {
                // Commit the changes

                DH_LOG((
                    LOG_INFO,
                    TEXT("Random Commit operation chosen.\n")));
    
                hr = pvcn->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    // Store the information in statStgCommited

                    hr = pvcn->Stat(&statStgCommited, STATFLAG_NONAME);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;

                }
            }
            else if(statStgNew.grfMode & STGM_TRANSACTED)
            {
                // Revert the changes

                DH_LOG((
                    LOG_INFO,
                    TEXT("Random Revert operation chosen.\n")));

                hr = pvcn->Revert();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

                // Do Stat

                if(S_OK == hr)
                {
                    hr = pvcn->Stat(&statStgNew, STATFLAG_NONAME);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
                }

                // Verify values after Revert

                if(S_OK == hr)
                {
                    if(statStgNew.grfStateBits != statStgCommited.grfStateBits)
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("State Bits after Revert not correct.\n")));

                        DH_LOG((
                            LOG_INFO,
                            TEXT("State Bits Actual: 0x%lx, Exp: 0x%lx.\n"),
                            statStgNew.grfStateBits,
                            statStgCommited.grfStateBits));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("State Bits after Revert correct.\n")));
                    }

                    if(!IsEqualCLSID(statStgNew.clsid, statStgCommited.clsid))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("CLSID after Revert not correct.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("CLSID after Revert correct.\n")));
                    }
                }

                // Modify hr if reqd based on fPass Value so that we can fall
                // out of this loop in error.

                if((S_OK == hr) && (FALSE == fPass))
                {
                    hr = S_FALSE;
                }
            }
        }

        // Reset the variables

        fStateBitsChanged = FALSE; 
        cRandomClsid = 0;
   
        // Decrement counter
 
        cRandomVar--;
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// Function: EnumerateDocFileInRandomChunks 
//
// Synopsis: Enumerate DocFile in Random chunks and counts all the objects in
//           DocFile 
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to data generator object
//            [dwStgMode] - Mode for storage objects
//            [uNumObjs] - Max number of objs in DocFile to choose random 
//                         chunk number from
//            [pNumStg] - Out paramemter - Pointer to number of storages enum
//            [pNumStm] - Out paramemter - Pointer to number of streams enum
//
// Returns: HResult 
//
// History: 23-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

HRESULT EnumerateDocFileInRandomChunks(
    VirtualCtrNode  *pvcn,
    DG_INTEGER      *pdgi,  
    DWORD           dwStgMode,
    ULONG           uNumObjs,
    ULONG           *pNumStg,
    ULONG           *pNumStm )
{
    HRESULT         hr                  =   S_OK;
    ULONG           cChildStg           =   0;
    ULONG           cChildStm           =   0;
    USHORT          usErr               =   0;  
    ULONG           cRandomObjs         =   0;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    LPMALLOC        pMalloc             =   NULL;
    ULONG           celtFetched         =   0;
    STATSTG         *pstatStgEnum       =   NULL;
    ULONG           ulRef               =   0;
    ULONG           counter             =   0;
    LPTSTR          ptszStatStgEnumName =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateDocFileInRandomChunks"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdgi, DG_INTEGER) ;
    DH_VDATEPTROUT(pNumStg, ULONG) ;
    DH_VDATEPTROUT(pNumStm, ULONG) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pNumStg);
    DH_ASSERT(NULL != pNumStm);

    if(S_OK == hr)
    {
        // Count the storage passed in.

        *pNumStg = 1;
        *pNumStm = 0;

        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Get random number of objects to be asked from through Next

    if(S_OK == hr)
    {
        // Generate random number 

        usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Allocate memory for STATSTG strcuture

    if(S_OK == hr)
    {
        pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
        if(NULL == pstatStgEnum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // if successful to get enumerator, get the random element of the 
    // enumeration sequence.

    if(S_OK == hr)
    {
        hr = lpEnumStatStg->Next(cRandomObjs, pstatStgEnum, &celtFetched);

        if(S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    while(0 < celtFetched)
    {
        for (counter = 0; counter < celtFetched; counter++)
        {
            if (STGTY_STORAGE == pstatStgEnum[counter].type)
            {
                hr = OleStringToTString(
                        pstatStgEnum[counter].pwcsName,
                        &ptszStatStgEnumName);

                // Find the respective VirtualCtrNode with the name and recurse
                // into it after opening it.
           
                if(S_OK == hr)
                { 
                    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                    while((NULL != pvcnTrav) &&
                          ( 0 != _tcscmp(
                                    ptszStatStgEnumName, 
                                    pvcnTrav->GetVirtualCtrNodeName())))
                    {
                        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                    } 

                    DH_ASSERT(NULL != pvcnTrav);

                    if(NULL != pvcnTrav)
                    {
                        hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    }
                }

                // Delete temp string
                
                if(NULL != ptszStatStgEnumName)
                {
                    delete ptszStatStgEnumName;
                    ptszStatStgEnumName = NULL;
                }

                if(S_OK == hr)
                {
                    hr = EnumerateDocFileInRandomChunks(
                            pvcnTrav, 
                            pdgi, 
                            dwStgMode, 
                            uNumObjs, 
                            &cChildStg, 
                            &cChildStm);
                }

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
 
                // Update number of nodes on basis of child nodes as found

                if(0 != cChildStg)
                {
                    *pNumStg = *pNumStg + cChildStg;
                }

                if(0 != cChildStm)
                {
                    *pNumStm = *pNumStm + cChildStm;
                }

            }
            else
            if (STGTY_STREAM == pstatStgEnum[counter].type)
            {
                (*pNumStm)++;
            }
            else
            // The element is neither IStorage nor IStream, report error.
            {
                hr = E_UNEXPECTED;
            }

            // Clean up

            if(NULL != pstatStgEnum[counter].pwcsName)
            {
                pMalloc->Free(pstatStgEnum[counter].pwcsName);
                pstatStgEnum[counter].pwcsName = NULL;
            }

            // Break out of loop in error

            if(S_OK != hr)
            {
                break;
            }
        }

        // Get the next random elements from the enumeration sequence

        if(S_OK == hr)
        {
            // Generate random number.

            usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
        
        if (NULL != pstatStgEnum)
        {
            delete [] pstatStgEnum;
            pstatStgEnum = NULL;
        }

        if(S_OK == hr)
        {
            pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
            if(NULL == pstatStgEnum)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(cRandomObjs, pstatStgEnum, &celtFetched);

            if(S_FALSE == hr)
            {
                hr = S_OK;
            }
        }

        // Reinitialize the variables

        cChildStg = 0;
        cChildStm = 0;
    }

    // Clean up

    if (NULL != pstatStgEnum)
    {
        delete [] pstatStgEnum;
        pstatStgEnum = NULL;
    }

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//----------------------------------------------------------------------------
//
// Function: CompareSTATSTG
//
// Synopsis: Compares contents of two STATSTG structs
//
// Arguments: [sstg1] - first STATSTG struct to be compared
//            [sstg2] - second STATSTG struct to be compared
//
// Returns:  TRUE if storage buffers are the same; FALSE otherwise.
//
// History:  24-Jul-1996   Narindk   Enhanced 
//
//-----------------------------------------------------------------------------

BOOL CompareSTATSTG(STATSTG sstg1, STATSTG sstg2)
{
    HRESULT hr                  =   S_OK;
    LPTSTR  ptszStatStg1Name    =   NULL;
    LPTSTR  ptszStatStg2Name    =   NULL;
    BOOL    fEqual              =   FALSE;

    hr = OleStringToTString(sstg1.pwcsName, &ptszStatStg1Name);

    if(S_OK == hr)
    {
        hr = OleStringToTString(sstg2.pwcsName, &ptszStatStg2Name);
    }

    if(S_OK == hr)
    {
        fEqual=((!(_tcscmp(ptszStatStg1Name, ptszStatStg2Name))       &&
           (sstg1.type == sstg2.type)                                 &&
           (ULIGetLow(sstg1.cbSize) == ULIGetLow(sstg2.cbSize))       &&
           (sstg1.mtime.dwLowDateTime == sstg2.mtime.dwLowDateTime)   &&
           (sstg1.mtime.dwHighDateTime == sstg2.mtime.dwHighDateTime) &&
           (sstg1.ctime.dwLowDateTime == sstg2.ctime.dwLowDateTime)   &&
           (sstg1.ctime.dwHighDateTime == sstg2.ctime.dwHighDateTime) &&
           (sstg1.atime.dwLowDateTime == sstg2.atime.dwLowDateTime)   &&
           (sstg1.atime.dwHighDateTime == sstg2.atime.dwHighDateTime) &&
           (sstg1.grfMode == sstg2.grfMode)                           &&
           (sstg1.grfLocksSupported == sstg2.grfLocksSupported)       &&
           (sstg1.grfStateBits == sstg2.grfStateBits)                 &&
           IsEqualCLSID(sstg1.clsid, sstg2.clsid)));

    }

    DH_ASSERT(S_OK == hr);

    // Delete temp strings

    if(NULL != ptszStatStg1Name)
    {
        delete ptszStatStg1Name;
        ptszStatStg1Name = NULL;
    }

    if(NULL != ptszStatStg2Name)
    {
        delete ptszStatStg2Name;
        ptszStatStg1Name = NULL;
    }

    return fEqual;
}

//----------------------------------------------------------------------------
//
// Function: EnumerateDocFileAndVerifyEnumCloneResetSkipNext 
//
// Synopsis: Enumerate DocFile all at one level, Gets a clone of enumerator,
//           Uses Clone/Reset/Skip/Next method to get a Storage and verify that
//           with one obtained from original enumerator and counts all the 
//           objects ath the level.  If object is a storage, it is recursed
//           into and operation repeated. 
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [dwStgMode] - Mode for storage objects
//            [uNumObjs] - Max number of objs in DocFile to choose random 
//                         chunk number from
//            [pNumStg] - Out paramemter - Pointer to number of storages enum
//            [pNumStm] - Out paramemter - Pointer to number of streams enum
//
// Returns: HResult 
//
// History: 24-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

HRESULT EnumerateDocFileAndVerifyEnumCloneResetSkipNext(
    VirtualCtrNode  *pvcn,
    DWORD           dwStgMode,
    ULONG           uNumObjs,
    ULONG           *pNumStg,
    ULONG           *pNumStm )
{
    HRESULT         hr                  =   S_OK;
    ULONG           cChildStg           =   0;
    ULONG           cChildStm           =   0;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    LPENUMSTATSTG   lpEnumStatStgClone  =   NULL;
    LPMALLOC        pMalloc             =   NULL;
    ULONG           celtFetched         =   0;
    STATSTG         *pstatStgEnum       =   NULL;
    ULONG           ulRef               =   0;
    LPTSTR          ptszStatStgEnumName =   NULL;
    BOOL            fPass               =   FALSE;
    STATSTG         statStgEnumClone;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("EnumerateDocFileAndVerifyEnumCloneResetSkipNext"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pNumStg, ULONG) ;
    DH_VDATEPTROUT(pNumStm, ULONG) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pNumStg);
    DH_ASSERT(NULL != pNumStm);

    if(S_OK == hr)
    {
        // Count the storage passed in.

        *pNumStg = 1;
        *pNumStm = 0;

        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Make a clone of the enumerator

    if(S_OK == hr)
    {
        hr = lpEnumStatStg->Clone(&lpEnumStatStgClone);
    
        DH_ASSERT((S_OK == hr) && (NULL != lpEnumStatStgClone));
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Allocate memory for STATSTG strcuture

    if(S_OK == hr)
    {
        // We are allocating memory for more number of STATSTG objects than
        // what might be required, but is safer.

        pstatStgEnum = (STATSTG *) new STATSTG [uNumObjs];
        
        if(NULL == pstatStgEnum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // if successful to get enumerator, get all the element at same level of 
    // the enumeration sequence.

    if(S_OK == hr)
    {
        hr = lpEnumStatStg->Next(uNumObjs, pstatStgEnum, &celtFetched);

        if(S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    while((0 < celtFetched--) && (S_OK == hr))
    {
        // for each element, ->Skip() from beginning of enumeration
        // sequence (of clone) and check that it is the same as
        // was returned with the original ->Next()

        // The Reset call always returns S_OK, so need to check hr

        hr = lpEnumStatStgClone->Reset();

        DH_ASSERT(S_OK == hr);

        // Skip celtFetched elements with Clone enumerator

        hr = lpEnumStatStgClone->Skip(celtFetched);

        DH_ASSERT(S_OK == hr);

        // Retrieve next element from this clone enumerator

        if(S_OK == hr)
        {
            hr = lpEnumStatStgClone->Next(1, &statStgEnumClone, NULL);

            DH_ASSERT(S_OK == hr);
        }

        if(S_OK == hr)
        {
            // Compare the STATSTG structures of one that is retrieved through
            // Clone and the one returned from original enumerator

            fPass = CompareSTATSTG(
                        pstatStgEnum[celtFetched], 
                        statStgEnumClone);
        }
   
        if(FALSE == fPass)
        {
            hr = S_FALSE;

            DH_LOG((LOG_INFO, TEXT("The two STATSTG's don't match\n")));
        }   
        else
        {
            DH_LOG((
                LOG_INFO, 
                TEXT("IEnum org and Clone enumerator: two STATSTG's match\n")));
        }
 
        if(S_OK == hr)
        {
            if (STGTY_STORAGE == pstatStgEnum[celtFetched].type)
            {
                hr = OleStringToTString(
                        pstatStgEnum[celtFetched].pwcsName,
                        &ptszStatStgEnumName);

                // Find the respective VirtualCtrNode with the name and recurse
                // into it after opening it.
           
                if(S_OK == hr)
                { 
                    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                    while((NULL != pvcnTrav) &&
                          ( 0 != _tcscmp(
                                    ptszStatStgEnumName, 
                                    pvcnTrav->GetVirtualCtrNodeName())))
                    {
                        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                    } 

                    DH_ASSERT(NULL != pvcnTrav);

                    if(NULL != pvcnTrav)
                    {
                        hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    }
                }

                // Delete temp string
                
                if(NULL != ptszStatStgEnumName)
                {
                    delete ptszStatStgEnumName;
                    ptszStatStgEnumName = NULL;
                }

                if(S_OK == hr)
                {
                    hr = EnumerateDocFileAndVerifyEnumCloneResetSkipNext(
                            pvcnTrav, 
                            dwStgMode, 
                            uNumObjs, 
                            &cChildStg, 
                            &cChildStm);
                }

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
 
                // Update number of nodes on basis of child nodes as found

                if(0 != cChildStg)
                {
                    *pNumStg = *pNumStg + cChildStg;
                }

                if(0 != cChildStm)
                {
                    *pNumStm = *pNumStm + cChildStm;
                }

            }
            else
            if (STGTY_STREAM == pstatStgEnum[celtFetched].type)
            {
                (*pNumStm)++;
            }
            else
            // The element is neither IStorage nor IStream, report error.
            {
                hr = E_UNEXPECTED;
            }

        }

        // Clean up

        if(NULL != pstatStgEnum[celtFetched].pwcsName)
        { 
            pMalloc->Free(pstatStgEnum[celtFetched].pwcsName);
            pstatStgEnum[celtFetched].pwcsName = NULL;
        }

        if(NULL != statStgEnumClone.pwcsName)
        {
            pMalloc->Free(statStgEnumClone.pwcsName);
            statStgEnumClone.pwcsName = NULL;
        }
    }

    // Clean up

    if (NULL != pstatStgEnum)
    {
        delete [] pstatStgEnum;
        pstatStgEnum = NULL;
    }

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if (NULL != lpEnumStatStgClone)
    {
        ulRef = lpEnumStatStgClone->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStgClone = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//----------------------------------------------------------------------------
//
// Function: ModifyDocFile 
//
// Synopsis: Enumerate DocFile and randomly recurses into child storages, or
//           randomly destroys or renames elements.
//
// Arguments: [pVirtualDF] - Pointer to VirtualDF tree
//            [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to Data Integer object
//            [pdgu] - Pinter to Data Unicode objext
//            [fCommitRoot] - Bool to commit a root DocFile storage or not 
//
// Returns: HResult 
//
// History: 25-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT ModifyDocFile(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pvcn,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu,
    DWORD           dwStgMode,
    BOOL            fCommitRoot)    
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnTrav       =   NULL;
    VirtualStmNode  *pvsnTrav       =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    LPMALLOC        pMalloc         =   NULL;
    ULONG           celtFetched     =   0;
    ULONG           ulRef           =   0;
    USHORT          usErr           =   0;
    LPTSTR          ptszStatStgName =   NULL;
    LPTSTR          ptszNewName     =   NULL;
    UINT            cRandVal0       =   0;
    UINT            cRandVal1       =   0;
    UINT            cRandRange0     =   0;
    UINT            cRandRange1     =   1;
    UINT            cRandRange2     =   2;
    STATSTG         statStg;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ModifyDocFile"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((S_OK == lpEnumStatStg->Next(1, &statStg, &celtFetched)) &&
          (S_OK == hr))
    {
       hr = OleStringToTString(statStg.pwcsName, &ptszStatStgName);

        // If the element is an IStorage, randmly either open this and make a 
        // recursive call to ModifyDocFile function or randomly choose to
        // either rename or destory this element.

        if ((STGTY_STORAGE == statStg.type) && (S_OK == hr))
        {
            // Find the respective VirtualCtrNode with the name and recurse
            // into it after opening it.
           
            if(S_OK == hr)
            { 
                pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                while((NULL != pvcnTrav) &&
                      ( 0 != _tcscmp( 
                                ptszStatStgName,  
                                pvcnTrav->GetVirtualCtrNodeName())))
                {
                    pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                } 

                DH_ASSERT(NULL != pvcnTrav);

            }

            // Cloose random number

            if(S_OK == hr)
            { 
                usErr = pdgi->Generate(&cRandVal0, cRandRange0, cRandRange2);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            // Randomly choose either to open/recurse and Modify the Storage
            // or choose to either randomly rename or destory the storage

            if((S_OK == hr) && (0 == cRandVal0))
            {
                if(NULL != pvcnTrav)
                {
                    hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
                }

                // Call ModifyDocFile recursively on this node
           
                if(S_OK == hr)
                {
                    hr = ModifyDocFile(
                            pVirtualDF,
                            pvcnTrav, 
                            pdgi, 
                            pdgu, 
                            dwStgMode,
                            fCommitRoot);
                }

                // Close this storage

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
            }
 
            if((S_OK == hr) && (0 != cRandVal0))
            {
                // choose random number either to rename or destory this 
                // element

                if(S_OK == hr)
                { 
                    usErr = pdgi->Generate(&cRandVal1,cRandRange1,cRandRange2);

                    if (DG_RC_SUCCESS != usErr)
                    {
                        hr = E_FAIL;
                    }
                }

                if(S_OK == hr)
                {
                    switch(cRandVal1)
                    {
                        case 1:
                        {
                            hr = DestroyStorage(pVirtualDF, pvcnTrav);
    
                            DH_HRCHECK(hr, TEXT("DestoryStorage")) ;

                            break;
                        }
                        case 2:
                        {
                            // Generate random new name

                            hr = GenerateRandomName(pdgu,
                                    MINLENGTH,
                                    MAXLENGTH,
                                    &ptszNewName);

                            if(S_OK == hr)
                            {
                                hr = pvcnTrav->Rename(ptszNewName);  
    
                                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Rename")) ;
                            }
                            break;
                        }
                    }
                }
            }

        }

        // If the element is an IStream,  randomly choose to either rename 
        // or destory this element.

        else if ((STGTY_STREAM == statStg.type) && (S_OK == hr))
        {
            // Find the respective VirtualStmNode with the name 
           
            if(S_OK == hr)
            { 
                pvsnTrav = pvcn->GetFirstChildVirtualStmNode();

                while((NULL != pvsnTrav) &&
                      ( 0 != _tcscmp( 
                                ptszStatStgName,  
                                pvsnTrav->GetVirtualStmNodeName())))
                {
                    pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
                } 

                DH_ASSERT(NULL != pvsnTrav);
            }

            // choose random number either to rename or destory this element

            if(S_OK == hr)
            { 
                usErr = pdgi->Generate(&cRandVal1, cRandRange1, cRandRange2);

                if (DG_RC_SUCCESS != usErr)
                {
                   hr = E_FAIL;
                }
            }

            if(S_OK == hr)
            { 
                switch(cRandVal1)
                {
                    case 1:
                    {
                        hr = DestroyStream(pVirtualDF, pvsnTrav);

                        DH_HRCHECK(hr, TEXT("DestroyStream")) ;

                        break;
                    }
                    case 2:
                    {
                        // Generate random new name

                        hr = GenerateRandomName(pdgu,
                                MINLENGTH,
                                MAXLENGTH,
                                &ptszNewName);

                        if(S_OK == hr)
                        {
                            hr = pvsnTrav->Rename(ptszNewName);  

                            DH_HRCHECK(hr, TEXT("VirtualStmNode::Rename")) ;
                        }
                        break;
                    }
                }
            }
        }

        // Clean up

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszStatStgName)
        {
            delete ptszStatStgName;
            ptszStatStgName = NULL;
        }

        if(NULL != ptszNewName)
        {
            delete ptszNewName;
            ptszNewName = NULL;
        }
    }

    // Commit the passed in storage as case might be

    if((S_OK == hr) && 
       ((pvcn != pVirtualDF->GetVirtualDFRoot()) || (TRUE == fCommitRoot)))
    {
        hr = pvcn->Commit(STGC_DEFAULT);
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(0 == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//----------------------------------------------------------------------------
//
// Function: EnumerateAndWalkDocFile
//
// Synopsis: Enumerate /walks DocFile by either randomly skipping random
//           number of elements or getting random number of elements, recursing
//           if a child storage is found. 
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to data generator object
//            [dwStgMode] - Mode for storage objects
//            [uNumObjs] - Max number of objs in DocFile to choose random 
//                         chunk number from
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
// Notes: This doesn't provide any form of verification, but checks for any
//        unexpected errors/faults from ole while walking the docfile tree.
//-----------------------------------------------------------------------------

HRESULT EnumerateAndWalkDocFile(
    VirtualCtrNode  *pvcn,
    DG_INTEGER      *pdgi,  
    DWORD           dwStgMode,
    ULONG           uNumObjs)
{
    HRESULT         hr                  =   S_OK;
    USHORT          usErr               =   0;  
    ULONG           cRandomObjs         =   0;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    LPMALLOC        pMalloc             =   NULL;
    ULONG           celtFetched         =   0;
    STATSTG         *pstatStgEnum       =   NULL;
    ULONG           ulRef               =   0;
    ULONG           counter             =   0;
    LPTSTR          ptszStatStgEnumName =   NULL;
    UINT            cWhichOp            =   0;
    UINT            cRandomOpMin        =   1;
    UINT            cRandomOpMax        =   3;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateAndWalkDocFile"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdgi, DG_INTEGER) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);

    if(S_OK == hr)
    {
        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Get random number of objects to be asked from through Next or Skip

    if(S_OK == hr)
    {
        // Generate random number 

        usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Get random number to determine whether to do skip or next operation.
    // 67% Next operation would be done and 33% skip would be done. 

    if(S_OK == hr)
    {
        // Generate random number 

        usErr = pdgi->Generate(&cWhichOp, cRandomOpMin, cRandomOpMax);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Allocate memory for STATSTG strcuture

    if(S_OK == hr)
    {
        pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
        if(NULL == pstatStgEnum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // if successful to get enumerator, get the random element of the 
    // enumeration sequence.  33% do skip and 67% do Next.

    if(S_OK == hr)
    {
        if(cRandomOpMin == cWhichOp)
        {
            hr = lpEnumStatStg->Skip(cRandomObjs);

            if(S_OK == hr)
            {
                hr = lpEnumStatStg->Next(1, pstatStgEnum, &celtFetched);
            }
        }
        else
        {
            hr = lpEnumStatStg->Next(cRandomObjs, pstatStgEnum, &celtFetched);
        }

        if(S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    while(0 < celtFetched)
    {
        for (counter = 0; counter < celtFetched; counter++)
        {
            if (STGTY_STORAGE == pstatStgEnum[counter].type)
            {
                hr = OleStringToTString(
                        pstatStgEnum[counter].pwcsName,
                        &ptszStatStgEnumName);

                // Find the respective VirtualCtrNode with the name and recurse
                // into it after opening it.
           
                if(S_OK == hr)
                { 
                    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                    while((NULL != pvcnTrav) &&
                          ( 0 != _tcscmp(
                                    ptszStatStgEnumName, 
                                    pvcnTrav->GetVirtualCtrNodeName())))
                    {
                        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                    } 

                    DH_ASSERT(NULL != pvcnTrav);

                    if(NULL != pvcnTrav)
                    {
                        hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    }
                }

                // Delete temp string
                
                if(NULL != ptszStatStgEnumName)
                {
                    delete ptszStatStgEnumName;
                    ptszStatStgEnumName = NULL;
                }

                if(S_OK == hr)
                {
                    hr = EnumerateAndWalkDocFile(
                            pvcnTrav, 
                            pdgi, 
                            dwStgMode, 
                            uNumObjs); 
                }

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
            }

            // Clean up

            if(NULL != pstatStgEnum[counter].pwcsName)
            {
                pMalloc->Free(pstatStgEnum[counter].pwcsName);
                pstatStgEnum[counter].pwcsName = NULL;
            }

            // Break out of loop in error

            if(S_OK != hr)
            {
                break;
            }
        }

        // Reset the variables

        cWhichOp = 0;
        cRandomObjs = 0;
        celtFetched = 0;

        // Get random number to determine whether to do skip or next operation.
        // 67% Next operation would be done and 33% skip would be done. 

        if(S_OK == hr)
        {
            // Generate random number 

            usErr = pdgi->Generate(&cWhichOp, cRandomOpMin, cRandomOpMax);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        // Get the random number of elements from the enumeration sequence to
        // skip or get.

        if(S_OK == hr)
        {
            // Generate random number.

            usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
        
        if (NULL != pstatStgEnum)
        {
            delete [] pstatStgEnum;
            pstatStgEnum = NULL;
        }

        if(S_OK == hr)
        {
            pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
            if(NULL == pstatStgEnum)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(S_OK == hr)
        {
            if(cRandomOpMin == cWhichOp)
            {
                hr = lpEnumStatStg->Skip(cRandomObjs);

                if(S_OK == hr)
                {
                    hr = lpEnumStatStg->Next(1, pstatStgEnum, &celtFetched);
                }
            }
            else
            {
                hr = lpEnumStatStg->Next(cRandomObjs,pstatStgEnum,&celtFetched);
            }

            if(S_FALSE == hr)
            {
                hr = S_OK;
            }
        }
    }

    // Clean up

    if (NULL != pstatStgEnum)
    {
        delete [] pstatStgEnum;
        pstatStgEnum = NULL;
    }

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}


//----------------------------------------------------------------------------
//
// Function: CreateNewObject 
//
// Synopsis: Randomly creates a new storage or stream object in a DocFile 
//
// Arguments: [pVirtualDF] - Pointer to VirtualDF tree
//            [pvcn] - Pointer to VirtualCtrNode
//            [dwStgMode] - Used for random creation of storage object
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT CreateNewObject(
    LPSTORAGE       pIStorage,
    DWORD           dwStgMode, 
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    UINT            cRandom         =   0;
    LPTSTR          ptszNewName     =   NULL;
    LPTSTR          ptszNewData     =   NULL;
    LPOLESTR        poszNewName     =   NULL;
    LPOLESTR        poszNewData     =   NULL;
    ULONG           cb              =   0;
    ULONG           culWritten      =   0;
    LPSTORAGE       pIStorageNew    =   NULL;
    LPSTREAM        pIStreamNew     =   NULL;
    ULONG           ulRef           =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CreateNewObject"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    // Pick up a random number.  33% chance to generate a new IStorage element,
    // and 67% chance to generate a new IStream element. 

    usErr = pdgi->Generate(&cRandom, 0, 2);

    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
    }

    // flatfile only: storages are not allowed
    if(StorageIsFlat())
    {
        cRandom = 2; // force it to create only streams
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH, MAXLENGTH, &ptszNewName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptcsName to OLECHAR

        hr = TStringToOleString(ptszNewName, &poszNewName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        if(0 == cRandom)
        {
            // Create a new storage
            
            hr = pIStorage->CreateStorage(
                    poszNewName, 
                    dwStgMode | STGM_CREATE, 
                    0,
                    0,
                    &pIStorageNew);

            DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;

            if(S_OK == hr)
            {
                // Close the new storage

                ulRef = pIStorageNew->Release();
                DH_ASSERT(0 == ulRef);
                pIStorageNew = NULL;
            }
        }
        else
        {