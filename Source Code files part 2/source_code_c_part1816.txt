eCriticalSection( &_csNcSysMet );
    return hf;
}

//-------------------------------------------------------------------------//
void NcClearNonclientMetrics()
{
    _incmCurrent.Clear();
}


//-------------------------------------------------------------------------//
int NcGetSystemMetrics(int nIndex)
{
    if( _NcUsingPreviewMetrics() )
    {
        int iValue;
        const NONCLIENTMETRICS& ncmPreview = _incmPreview.GetNcm();

        switch (nIndex)
        {
            case SM_CXHSCROLL:  // fall through
            case SM_CXVSCROLL:  iValue = ncmPreview.iScrollWidth;  break;
            case SM_CYHSCROLL:  // fall through
            case SM_CYVSCROLL:  iValue = ncmPreview.iScrollHeight;  break;

            case SM_CXSIZE:     iValue = ncmPreview.iCaptionWidth;  break;
            case SM_CYSIZE:     iValue = ncmPreview.iCaptionHeight;  break;
            case SM_CYCAPTION:  iValue = ncmPreview.iCaptionHeight + 1;  break;
            case SM_CXSMSIZE:   iValue = ncmPreview.iSmCaptionWidth;  break;
            case SM_CYSMSIZE:   iValue = ncmPreview.iSmCaptionHeight;  break;
            case SM_CXMENUSIZE: iValue = ncmPreview.iMenuWidth;  break;
            case SM_CYMENUSIZE: iValue = ncmPreview.iMenuHeight;  break;
            
            default:            iValue = ClassicGetSystemMetrics(nIndex); break;
        }
        return iValue;
    }
    else
    {
        return ClassicGetSystemMetrics(nIndex);
    }
}

//-------------------------------------------------------------------------//
//  _InternalGetSystemMetrics() - Themed implementation of GetSystemMetrics().
//
int _InternalGetSystemMetrics( int iMetric, BOOL& fHandled )
{
    int         iRet = 0;
    int*        plSysMet = NULL;
    NCTHEMEMET  nctm;

    switch( iMetric )
    {
        case SM_CXSIZE:
            plSysMet = &nctm.theme_sysmets.cxBtn; break;

        case SM_CXSMSIZE:
            plSysMet = &nctm.theme_sysmets.cxSmBtn; break;
    }

    if( plSysMet &&
        GetCurrentNcThemeMetrics( &nctm ) && nctm.hTheme != NULL && 
        nctm.theme_sysmets.fValid )
    {
        iRet = *plSysMet;
        fHandled = TRUE; /*was missing (doh! - 408190)*/
    }

    return iRet;
}

//-------------------------------------------------------------------------//
//  _InternalSystemParametersInfo() - Themed implementation of SystemParametersInfo().
//  
//  return value of FALSE interpreted by caller as not handled.
BOOL _InternalSystemParametersInfo( 
    IN UINT uiAction, 
    IN UINT uiParam, 
    IN OUT PVOID pvParam, 
    IN UINT fWinIni,
    IN BOOL fUnicode,
    BOOL& fHandled )
{
    SYSTEMPARAMETERSINFO pfnDefault = 
                fUnicode ? ClassicSystemParametersInfoW : ClassicSystemParametersInfoA;\

    BOOL fRet = pfnDefault( uiAction, uiParam, pvParam, fWinIni );
    fHandled = TRUE;

    if( SPI_GETNONCLIENTMETRICS == uiAction && fRet )
    {
        NCTHEMEMET nctm;
        if( GetCurrentNcThemeMetrics( &nctm ) && nctm.hTheme != NULL && nctm.theme_sysmets.fValid )
        {
            NONCLIENTMETRICS* pncm = (NONCLIENTMETRICS*)pvParam;
            pncm->iCaptionWidth = nctm.theme_sysmets.cxBtn;
        }
    }
    return fRet;
}

//-------------------------------------------------------------------------//
THEMEAPI DrawNCWindow(CThemeWnd* pThemeWnd, HWND hwndFake, HDC hdc, DWORD dwFlags, LPRECT prc, NONCLIENTMETRICS* pncm, COLORREF* prgb)
{
    // Build up Overide structure
    NCPAINTOVERIDE ncpo;
    pThemeWnd->GetNcWindowMetrics( prc, &ncpo.pncwm, &ncpo.nctm, NCWMF_RECOMPUTE|NCWMF_PREVIEW );

    // Force window to look active
    if (dwFlags & NCPREV_ACTIVEWINDOW)
    {
        ncpo.pncwm->framestate = FS_ACTIVE;
        
        ncpo.pncwm->rawCloseBtnState = 
        ncpo.pncwm->rawMaxBtnState = 
        ncpo.pncwm->rawMinBtnState = CBS_NORMAL;
     }
    ncpo.pncwm->rgbCaption = prgb[FS_ACTIVE == ncpo.pncwm->framestate ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT];
    ncpo.pncwm->dwStyle &= ~WS_SIZEBOX;
    // Paint the beautiful visual styled window
    pThemeWnd->NcPaint(hdc, NCPF_DEFAULT, NULL, &ncpo);

    COLORREF rgbBk = prgb[(dwFlags & NCPREV_MESSAGEBOX) ? COLOR_3DFACE : COLOR_WINDOW];
    HBRUSH hbrBack = CreateSolidBrush(rgbBk);
    FillRect(hdc, &ncpo.pncwm->rcW0[NCRC_CLIENT], hbrBack);
    DeleteObject(hbrBack);

    WCHAR szText[MAX_PATH];
    // Draw client area

    HFONT hfont = CreateFont(-MulDiv(8, GetDeviceCaps(hdc, LOGPIXELSY), 72), 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, L"MS Shell Dlg");
    if (hfont)
    {
        if (dwFlags & NCPREV_MESSAGEBOX)
        {
            HTHEME htheme = OpenThemeData( hwndFake, L"Button" );
            int offsetX = ((ncpo.pncwm->rcW0[NCRC_CLIENT].right + ncpo.pncwm->rcW0[NCRC_CLIENT].left) / 2) - 40;
            int offsetY = ((ncpo.pncwm->rcW0[NCRC_CLIENT].bottom + ncpo.pncwm->rcW0[NCRC_CLIENT].top) / 2) - 15;
            RECT rcButton = { offsetX, offsetY, offsetX + 80, offsetY + 30 };
            NcDrawThemeBackground(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, &rcButton, 0);
            RECT rcContent;
            GetThemeBackgroundContentRect(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, &rcButton, &rcContent);
            LoadString(g_hInst, IDS_OKBUTTON, szText, ARRAYSIZE(szText));
            if (szText[0])
            {
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                DrawThemeText(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, szText, lstrlen(szText), DT_CENTER | DT_VCENTER | DT_SINGLELINE, 0, &rcContent);
                SelectObject(hdc, hfontOld);
            }
            CloseThemeData(htheme);
        }
        else if (dwFlags & NCPREV_ACTIVEWINDOW)
        {
            HTHEME htheme = OpenThemeData( hwndFake, L"Button" );
            RECT rcButton = ncpo.pncwm->rcW0[NCRC_CLIENT];
            LoadString(g_hInst, IDS_WINDOWTEXT, szText, ARRAYSIZE(szText));
            if (szText[0])
            {
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                DTTOPTS DttOpts = {sizeof(DttOpts)};
                DttOpts.dwFlags = DTT_TEXTCOLOR;
                DttOpts.crText = prgb[COLOR_WINDOWTEXT];

                DrawThemeTextEx(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, szText, lstrlen(szText), DT_SINGLELINE, &rcButton, &DttOpts);
                SelectObject(hdc, hfontOld);
            }
            CloseThemeData(htheme);
        }
    }
    DeleteObject(hfont);


    ClearNcThemeMetrics(&ncpo.nctm);

    return S_OK;
}

//-------------------------------------------------------------------------//
THEMEAPI DrawNCPreview(HDC hdc, DWORD dwFlags, LPRECT prc, LPCWSTR pszVSPath, LPCWSTR pszVSColor, LPCWSTR pszVSSize, NONCLIENTMETRICS* pncm, COLORREF* prgb)
{
    WNDCLASS wc;

    // Create a fake Window and attach NC themeing to it
    if (!GetClassInfo(g_hInst, NCPREV_CLASS, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = DefWindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = NCPREV_CLASS;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    _incmPreview = *pncm;
    _incmPreview._fPreview = TRUE;
    _NcSetPreviewMetrics( TRUE );
    
    DWORD dwExStyle = WS_EX_DLGMODALFRAME | ((dwFlags & NCPREV_RTL) ? WS_EX_RTLREADING : 0);
    HWND hwndFake = CreateWindowEx(dwExStyle, NCPREV_CLASS, L"", 0, 0, 0, RECTWIDTH(prc), RECTHEIGHT(prc), NULL, NULL, g_hInst, NULL);

    if (hwndFake)
    {
        HTHEMEFILE htFile = NULL;

        WCHAR szCurVSPath[MAX_PATH];
        WCHAR szCurVSColor[MAX_PATH];
        WCHAR szCurVSSize[MAX_PATH];

        GetCurrentThemeName(szCurVSPath, ARRAYSIZE(szCurVSPath), szCurVSColor, ARRAYSIZE(szCurVSColor), szCurVSSize, ARRAYSIZE(szCurVSSize));

        if ((lstrcmp(szCurVSPath,  pszVSPath) != 0) ||
            (lstrcmp(szCurVSColor, pszVSColor) != 0) ||
            (lstrcmp(szCurVSSize,  pszVSSize) != 0))
        {
            HRESULT hr = OpenThemeFile(pszVSPath, pszVSColor, pszVSSize, &htFile, FALSE);
            if (SUCCEEDED(hr))
            {
                //---- first, detach from the normal theme ----
                CThemeWnd::Detach(hwndFake, FALSE);

                //---- apply the preview theme ----
                hr = ApplyTheme(htFile, 0, hwndFake); 
            }
        }

        //---- attach to the preview theme ----
        CThemeWnd* pThemeWnd = CThemeWnd::Attach(hwndFake);

        if (VALID_THEMEWND(pThemeWnd))
        {
            struct {
                DWORD dwNcPrev;
                UINT uIDStr;
                DWORD dwFlags;
                RECT rc;
            } fakeWindow[]= {   {NCPREV_INACTIVEWINDOW, IDS_INACTIVEWINDOW, 0,                                       { prc->left, prc->top, prc->right - 17, prc->bottom - 20 }},
                                {NCPREV_ACTIVEWINDOW,   IDS_ACTIVEWINDOW,   NCPREV_ACTIVEWINDOW,                     { prc->left + 10, prc->top + 22, prc->right, prc->bottom }},
                                {NCPREV_MESSAGEBOX,     IDS_MESSAGEBOX,     NCPREV_ACTIVEWINDOW | NCPREV_MESSAGEBOX, { prc->left + (RECTWIDTH(prc)/2) - 75, prc->top + (RECTHEIGHT(prc)/2) - 50 + 22,
                                        prc->left + (RECTWIDTH(prc)/2) + 75, prc->top + (RECTHEIGHT(prc)/2) + 50 + 22}}};

            WCHAR szWindowName[MAX_PATH];
            for (int i = 0; i < ARRAYSIZE(fakeWindow); i++)
            {
                if (dwFlags & fakeWindow[i].dwNcPrev)
                {
                    LoadString(g_hInst, fakeWindow[i].uIDStr, szWindowName, ARRAYSIZE(szWindowName));
                    SetWindowText(hwndFake, szWindowName);
                    
                    if (fakeWindow[i].dwNcPrev & NCPREV_MESSAGEBOX)
                    {
                        SetWindowLongPtr(hwndFake, GWL_STYLE, WS_TILED | WS_CAPTION | WS_SYSMENU);
                    }
                    else
                    {
                        SetWindowLongPtr(hwndFake, GWL_STYLE, WS_TILEDWINDOW | WS_VSCROLL);
                    }

                    DrawNCWindow(pThemeWnd, hwndFake, hdc, fakeWindow[i].dwFlags, &fakeWindow[i].rc, pncm, prgb);
                }
            }

            // Clean Up
            CThemeWnd::Detach(hwndFake, 0);
        }

        if (htFile)
        {
            CloseThemeFile(htFile);
            
            //---- clear the preview hold on the theme file ----
            ApplyTheme(NULL, 0, hwndFake); 
        }

        DestroyWindow(hwndFake);
    }

    _NcSetPreviewMetrics( FALSE );
    _incmPreview.Clear();
    return S_OK;
}

//-------------------------------------------------------------------------//
//  CMdiBtns impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  ctor
CMdiBtns::CMdiBtns()
{
    ZeroMemory( _rgBtns, sizeof(_rgBtns) );
    _rgBtns[0].wID = SC_CLOSE;
    _rgBtns[1].wID = SC_RESTORE;
    _rgBtns[2].wID = SC_MINIMIZE;
}

//-------------------------------------------------------------------------//
//  Helper: button lookup based on syscmd ID.
CMdiBtns::MDIBTN* CMdiBtns::_FindBtn( UINT wID )
{
    for( int i = 0; i < ARRAYSIZE(_rgBtns); i++ )
    {
        if( wID == _rgBtns[i].wID )
        {
            return (_rgBtns + i);
        }
    }
    return NULL;
}

//-------------------------------------------------------------------------//
//  Acquires MDI button resources,.computes metrics
BOOL CMdiBtns::Load( HTHEME hTheme, IN OPTIONAL HDC hdc, UINT uSysCmd )
{
    //  if caller wants all buttons loaded, call recursively.
    if( 0 == uSysCmd )
    {
        return Load( hTheme, hdc, SC_CLOSE ) &&
               Load( hTheme, hdc, SC_RESTORE ) &&
               Load( hTheme, hdc, SC_MINIMIZE );
    }
    
    MDIBTN* pBtn = _FindBtn( uSysCmd );
    
    if( pBtn && !VALID_WINDOWPART(pBtn->iPartId) /*only if necessary*/ )
    {
        //  select appropriate window part
        WINDOWPARTS iPartId = BOGUS_WINDOWPART;
        switch( uSysCmd )
        {
            case SC_CLOSE:      iPartId = WP_MDICLOSEBUTTON;   break;
            case SC_RESTORE:    iPartId = WP_MDIRESTOREBUTTON; break;
            case SC_MINIMIZE:   iPartId = WP_MDIMINBUTTON;     break;
        }
        
        if( VALID_WINDOWPART(iPartId) )
        {
            if( IsThemePartDefined( hTheme, iPartId, 0) )
            {
                //  Retrieve sizing type, defaulting to 'stretch'.
                if( FAILED( GetThemeInt( hTheme, iPartId, 0, TMT_SIZINGTYPE, (int*)&pBtn->sizingType ) ) )
                {
                    pBtn->sizingType = ST_STRETCH;
                }
                
                //  if 'truesize', retrieve the size.
                if( ST_TRUESIZE == pBtn->sizingType )
                {
                    //  If no DC provided, base size on screen DC of default monitor.
                    HDC hdcSize = hdc;
                    if( NULL == hdcSize )
                    {
                        hdcSize = GetDC(NULL);
                    }

                    if( FAILED( GetThemePartSize( hTheme, hdc, iPartId, 0, NULL, TS_TRUE, &pBtn->size ) ) )
                    {
                        pBtn->sizingType = ST_STRETCH;
                    }

                    if( hdcSize != hdc )
                    {
                        ReleaseDC(NULL, hdcSize);
                    }
                }

                //  not 'truesize'; use system metrics for MDI buttons
                if( pBtn->sizingType != ST_TRUESIZE )
                {
                    pBtn->size.cx = NcGetSystemMetrics( SM_CXMENUSIZE );
                    pBtn->size.cy = NcGetSystemMetrics( SM_CYMENUSIZE );
                }
                
                //  assign button attributes
                pBtn->iPartId = iPartId;
            }
        }
    }
    return pBtn != NULL && VALID_WINDOWPART(pBtn->iPartId);
}

//-------------------------------------------------------------------------//
//  Releases MDI button resources,.resets metrics
void CMdiBtns::Unload( IN OPTIONAL UINT uSysCmd )
{
    //  if caller wants all buttons unloaded, call recursively.
    if( 0 == uSysCmd )
    {
        Unload( SC_CLOSE );
        Unload( SC_RESTORE );
        Unload( SC_MINIMIZE );
        return;
    }

    MDIBTN* pBtn = _FindBtn( uSysCmd );

    if( pBtn )
    {
        SAFE_DELETE_GDIOBJ(pBtn->hbmTheme);
        ZeroMemory(pBtn, sizeof(*pBtn));
        
        // restore our zeroed syscommand value
        pBtn->wID = uSysCmd;
    }
}

//-------------------------------------------------------------------------//
//  Theme/untheme MDI frame menubar's Minimize, Restore, Close menu items.
BOOL CMdiBtns::ThemeItem( HMENU hMenu, int iPos, MENUITEMINFO* pmii, BOOL fTheme )
{
    //  To theme, we simply make the item owner draw.  To untheme,
    //  we restore it to system-drawn.
    BOOL fRet = FALSE;
    MDIBTN* pBtn = _FindBtn( pmii->wID );

    if( pBtn && pmii && hMenu )
    {
        if( fTheme )
        {
            //  save off previous menuitem type, bitmap
            pBtn->fTypePrev = pmii->fType;
            pBtn->hbmPrev   = pmii->hbmpItem;

            pmii->fType    &= ~MFT_BITMAP;
            pmii->fType    |= MFT_OWNERDRAW|MFT_RIGHTJUSTIFY;
            pmii->hbmpItem  = NULL;
        }
        else
        {
            //  restore menuitem type, bitmap
            pmii->fType = pBtn->fTypePrev|MFT_RIGHTJUSTIFY /*409042 - force right-justify on the way out*/;
            pmii->hbmpItem = pBtn->hbmPrev;
        }
        
        pmii->fMask = MIIM_FTYPE;

        fRet = SetMenuItemInfo( hMenu, iPos, TRUE, pmii );

        if( !fRet || !fTheme )
        {
            pBtn->fTypePrev = 0;
            pBtn->hbmPrev = NULL;
        }
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  Computes button state identifier from Win32 owner draw state
CLOSEBUTTONSTATES CMdiBtns::_CalcState( ULONG ulOwnerDrawAction, ULONG ulOwnerDrawState )
{
    CLOSEBUTTONSTATES iStateId = CBS_NORMAL;

    if( TESTFLAG(ulOwnerDrawState, ODS_DISABLED|ODS_GRAYED|ODS_INACTIVE) )
    {
        iStateId = CBS_DISABLED;
    }
    else if( TESTFLAG(ulOwnerDrawState, ODS_SELECTED) )
    {
        iStateId = CBS_PUSHED;
    }
    else if( TESTFLAG(ulOwnerDrawState, ODS_HOTLIGHT) )
    {
        iStateId = CBS_HOT;
    }
    return iStateId;
}

//-------------------------------------------------------------------------//
//  MDI sys button WM_DRAWITEM handler
BOOL CMdiBtns::Measure( HTHEME hTheme, MEASUREITEMSTRUCT* pmis )
{
    MDIBTN* pBtn = _FindBtn( pmis->itemID );

    if( pBtn && VALID_WINDOWPART(pBtn->iPartId) )
    {
        pmis->itemWidth  = pBtn->size.cx;
        pmis->itemHeight = pBtn->size.cy;
        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
//  MDI sys button WM_DRAWITEM handler
BOOL CMdiBtns::Draw( HTHEME hTheme, DRAWITEMSTRUCT* pdis )
{
    MDIBTN* pBtn = _FindBtn( pdis->itemID );

    if( pBtn && VALID_WINDOWPART(pBtn->iPartId) )
    {
        return SUCCEEDED(NcDrawThemeBackground( 
            hTheme, pdis->hDC, pBtn->iPartId, _CalcState( pdis->itemAction, pdis->itemState ), &pdis->rcItem, 0 ));
    }
    return FALSE;
}

//-------------------------------------------------------------------------////
//  "Comments?" link in caption bar, known as the PHellyar (lame) button
//-------------------------------------------------------------------------//
#ifdef LAME_BUTTON

//-------------------------------------------------------------------------//
WCHAR   g_szLameText[50] = {0};

//-------------------------------------------------------------------------//
#define SZ_LAMETEXT_SUBKEY      TEXT("Control Panel\\Desktop")
#define SZ_LAMETEXT_VALUE       TEXT("LameButtonText")
#define SZ_LAMETEXT_DEFAULT     TEXT("Comments?")
#define CLR_LAMETEXT            RGB(91, 171, 245)

//-------------------------------------------------------------------------//
void InitLameText()
{
    CCurrentUser hkeyCurrentUser(KEY_READ);
    HKEY         hkLame;
    HRESULT      hr = E_FAIL;


    if ( RegOpenKeyEx(hkeyCurrentUser, SZ_LAMETEXT_SUBKEY, 0, KEY_QUERY_VALUE, &hkLame) == ERROR_SUCCESS )
    {
        hr = RegistryStrRead(hkLame, SZ_LAMETEXT_VALUE, g_szLameText, ARRAYSIZE(g_szLameText));
        RegCloseKey(hkLame);
    }

    if ( FAILED(hr) )
    {
        lstrcpy(g_szLameText, SZ_LAMETEXT_DEFAULT);
    }
}

//-------------------------------------------------------------------------//
VOID CThemeWnd::InitLameResources()
{
    //
    // Using GetWindowInfo here bc GetWindowLong masks 
    // out the WS_EX_LAMEBUTTON bit.
    //
    SAFE_DELETE_GDIOBJ(_hFontLame);

    WINDOWINFO wi = {0};

    wi.cbSize = sizeof(wi);
    if ( GetWindowInfo(_hwnd, &wi) && TESTFLAG(wi.dwExStyle, WS_EX_LAMEBUTTON) )
    {
        SIZE    sizeLame;
        HFONT   hfCaption = NcGetCaptionFont(TESTFLAG(wi.dwExStyle, WS_EX_TOOLWINDOW));

        if( hfCaption != NULL )
        {
            LOGFONT lfLame;
            if( GetObject( hfCaption, sizeof(lfLame), &lfLame ) )
            {
                lfLame.lfHeight    -= (lfLame.lfHeight > 0) ? 2 : -2;
                lfLame.lfUnderline = TRUE;
                lfLame.lfWeight    = FW_THIN;

                HFONT hFontLame = CreateFontIndirect(&lfLame);
                if ( hFontLame != NULL )
                {
                    HDC hdc = GetWindowDC(_hwnd);

                    if ( hdc != NULL )
                    {
                        SelectObject(hdc, hFontLame);

                        if (GetTextExtentPoint32(hdc, g_szLameText, lstrlen(g_szLameText), &sizeLame))
                        {
                            _hFontLame = hFontLame;
                            hFontLame = NULL;           // don't free at end of this function
                            _sizeLame = sizeLame;
                        }

                        ReleaseDC(_hwnd, hdc);
                    }
                }

                if (hFontLame)       // didn't assign this font
                    DeleteObject(hFontLame);
            }
        }
    }

}


//-------------------------------------------------------------------------//
VOID CThemeWnd::ClearLameResources()
{
    SAFE_DELETE_GDIOBJ(_hFontLame);
    ZeroMemory( &_sizeLame, sizeof(_sizeLame) );
}


//-------------------------------------------------------------------------//
inline VOID CThemeWnd::DrawLameButton(HDC hdc, IN const NCWNDMET* pncwm)
{
    if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAMEBUTTON) && _hFontLame )
    {
        Log(LOG_RFBUG, L"DrawLameButton; _hFontLame=0x%x", _hFontLame);

        HFONT    hFontSave = (HFONT)SelectObject(hdc, _hFontLame);
        COLORREF clrSave = SetTextColor(hdc, CLR_LAMETEXT);

        DrawText(hdc, g_szLameText, lstrlen(g_szLameText), (LPRECT)&pncwm->rcW0[NCRC_LAMEBTN], 
                 DT_LEFT | DT_SINGLELINE);

        SetTextColor(hdc, clrSave);
        SelectObject(hdc, hFontSave);
    }
}

//-------------------------------------------------------------------------//
VOID CThemeWnd::GetLameButtonMetrics( NCWNDMET* pncwm, const SIZE* psizeCaption )
{
    if( TESTFLAG(pncwm->dwExStyle, WS_EX_LAMEBUTTON) && _hFontLame )
    {
        BOOL  fLameOn;
        RECT  rcCaptionText = pncwm->rcS0[NCRC_CAPTIONTEXT];
        RECT* prcButton = &pncwm->rcS0[NCRC_LAMEBTN];
        int   cxPad = NcGetSystemMetrics(SM_CXEDGE) * 2;
        
        // Enough room to draw the lame button link?
        fLameOn = RECTWIDTH(&rcCaptionText) > 
                        psizeCaption->cx + 
                        cxPad + // between caption, lame text
                        _sizeLame.cx + 
                        cxPad; // between lame text, nearest button;

        //---- compute lame button alignment ----
        BOOL fReverse = TRUE;           // normally, lame goes on right side

        //---- WS_EX_RIGHT wants the opposite ----
        if (TESTFLAG(_ncwm.dwExStyle, WS_EX_RIGHT))
            fReverse = FALSE;

        DWORD dwFlags = GetTextAlignFlags(_hTheme, &_ncwm, fReverse);

        //---- turn off lame button for center captions ----
        if (dwFlags & DT_CENTER)
            fLameOn = FALSE;

        if ( fLameOn )
        {
            CopyRect(prcButton, &rcCaptionText);

            //---- note: pMargins already includes the theme specified ----
            //---- CaptionMargins (which scale with DPI) and the ----
            //---- icon and buttons widths ----

            if(dwFlags & DT_RIGHT)       // put lame on right
            {
                prcButton->left = (prcButton->right - _sizeLame.cx) - cxPad ;

                //---- adjust margins to remove lame area ----
                pncwm->CaptionMargins.cxRightWidth -= _sizeLame.cx;
            }
            else                        // put lame on left
            {
                prcButton->right = (prcButton->left + _sizeLame.cx) + cxPad;

                //---- adjust margins to remove lame area ----
                pncwm->CaptionMargins.cxLeftWidth += _sizeLame.cx;
            }

            //  vertically center the text between margins
            prcButton->top     += (RECTHEIGHT(&rcCaptionText) - _sizeLame.cy)/2;
            prcButton->bottom  =  prcButton->top + _sizeLame.cy;
        }
    }
}

#endif // LAME_BUTTON


#ifdef DEBUG
//-------------------------------------------------------------------------//
void CDECL _NcTraceMsg( ULONG uFlags, LPCTSTR pszFmt, ...)
{
    if( TESTFLAG(_NcTraceFlags, uFlags) || NCTF_ALWAYS == uFlags )
    {
        va_list args;
        va_start(args, pszFmt);

        TCHAR szSpew[2048];
        wvsprintf(szSpew, pszFmt, args);
        OutputDebugString(szSpew);
        OutputDebugString(TEXT("\n"));

        va_end(args);
    }
}

//-------------------------------------------------------------------------//
void INIT_THEMEWND_DBG( CThemeWnd* pwnd )
{
    if( IsWindow( *pwnd ) )
    {
        GetWindowText( *pwnd, pwnd->_szCaption, ARRAYSIZE(pwnd->_szCaption) );
        GetClassName( *pwnd, pwnd->_szWndClass, ARRAYSIZE(pwnd->_szWndClass) );
    }
}

//-------------------------------------------------------------------------//
void CThemeWnd::Spew( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszClassList )
{
    if( pszClassList && *pszClassList )
    {
        if( !_tcsstr( pszClassList, _szWndClass ) )
            return;
    }

    TCHAR szInfo[MAX_PATH*2];
    TCHAR szMsg[MAX_PATH*2];

    wsprintf( szInfo, TEXT("%08lX -'%s' ('%s') cf: %08lX"), _hwnd, _szCaption, _szWndClass, _fClassFlags );
    wsprintf( szMsg, pszFmt, szInfo );
    Log(LOG_NCATTACH, szMsg );
}

typedef struct
{
    DWORD dwProcessId;
    DWORD dwThreadId;
    DWORD dwSpewFlags;
    LPCTSTR pszFmt;
    LPCTSTR pszClassList;
} SPEW_ALL;

//-------------------------------------------------------------------------//
BOOL _SpewAllEnumCB( HWND hwnd, LPARAM lParam )
{
    SPEW_ALL* psa = (SPEW_ALL*)lParam;

    if( IsWindowProcess( hwnd, psa->dwProcessId ) )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd( hwnd );
        if( VALID_THEMEWND(pwnd) )
            pwnd->Spew( psa->dwSpewFlags, psa->pszFmt );
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
void CThemeWnd::SpewAll( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszClassList )
{
    SPEW_ALL sa;
    sa.dwThreadId  = GetCurrentThreadId();
    sa.dwProcessId = GetCurrentProcessId();
    sa.dwSpewFlags = dwSpewFlags;
    sa.pszFmt = pszFmt;
    sa.pszClassList = pszClassList;

    //---- this will enum all windows for this process (all desktops, all child levels) ----
    EnumProcessWindows( _SpewAllEnumCB, (LPARAM)&sa );
}

//-------------------------------------------------------------------------//
void CThemeWnd::SpewLeaks()
{
    if( _cObj > 0 )
    {
        Log(LOG_NCATTACH, L"LEAK WARNING: %d CThemeWnd instances outstanding.", _cObj );
    }
}

//-------------------------------------------------------------------------//
void SPEW_RECT( ULONG ulTrace, LPCTSTR pszMsg, LPCRECT prc )
{
    LPCTSTR pszFmt = TEXT("%s: {L:%d,T:%d,R:%d,B:%d}, (%d x %d)");
    WCHAR   szMsg[1024];

    wsprintfW( szMsg, pszFmt, pszMsg,
               prc->left, prc->top, prc->right, prc->bottom,
               RECTWIDTH(prc), RECTHEIGHT(prc) );
    _NcTraceMsg(ulTrace, szMsg);
}

//-------------------------------------------------------------------------//
void SPEW_MARGINS( ULONG ulTrace, LPCTSTR pszMsg, 
                   LPCRECT prcParent, LPCRECT prcChild )
{
    LPCTSTR pszFmt = TEXT("%s: {L:%d,T:%d,R:%d,B:%d}");
    WCHAR   szMsg[1024];

    wsprintfW( szMsg, pszFmt, pszMsg,
               prcChild->left - prcParent->left,
               prcChild->top  - prcParent->top,
               prcParent->right - prcChild->right,
               prcParent->bottom - prcChild->bottom );
    _NcTraceMsg(ulTrace, szMsg);
}


//-------------------------------------------------------------------------//
void SPEW_RGNRECT( ULONG ulTrace, LPCTSTR pszMsg, HRGN hrgn, int iPartID )
{
    RECT rc;
    if( NULLREGION == GetRgnBox( hrgn, &rc ) )
        FillMemory( &rc, sizeof(&rc), static_cast<UCHAR>(-1) );
    
    _NcTraceMsg( ulTrace, TEXT("Region %08lX for partID[%d]:\n\t"), hrgn, iPartID );
    SPEW_RECT( ulTrace, pszMsg, &rc );
}

//-------------------------------------------------------------------------//
void SPEW_WINDOWINFO( ULONG ulTrace, WINDOWINFO* pwi )
{
    SPEW_RECT(ulTrace,   TEXT("->wi.rcWindow"), &pwi->rcWindow );
    SPEW_RECT(ulTrace,   TEXT("->wi.rcClient"), &pwi->rcClient );
    _NcTraceMsg(ulTrace, TEXT("->wi.dwStyle: %08lX"), pwi->dwStyle );
    _NcTraceMsg(ulTrace, TEXT("->wi.dwExStyle: %08lX"), pwi->dwExStyle );
    _NcTraceMsg(ulTrace, TEXT("->wi.dwWindowStatus: %08lX"), pwi->dwWindowStatus );
    _NcTraceMsg(ulTrace, TEXT("->wi.cxWindowBorders: %d"), pwi->cxWindowBorders );
    _NcTraceMsg(ulTrace, TEXT("->wi.cyWindowBorders: %d"), pwi->cyWindowBorders );
}

//-------------------------------------------------------------------------//
void SPEW_NCWNDMET( ULONG ulTrace, LPCTSTR pszMsg, NCWNDMET* pncwm )
{
    _NcTraceMsg(ulTrace, TEXT("\n%s - Spewing NCWNDMET @ %08lx..."), pszMsg, pncwm );

    _NcTraceMsg(ulTrace, TEXT("->fValid:            %d"), pncwm->fValid );
    _NcTraceMsg(ulTrace, TEXT("->dwStyle:           %08lX"), pncwm->dwStyle );
    _NcTraceMsg(ulTrace, TEXT("->dwExStyle:         %08lX"), pncwm->dwExStyle );
    _NcTraceMsg(ulTrace, TEXT("->dwWindowStatus:    %08lX"), pncwm->dwWindowStatus );
    _NcTraceMsg(ulTrace, TEXT("->fFrame:            %d"), pncwm->fFrame );
    _NcTraceMsg(ulTrace, TEXT("->fSmallFrame:       %d"), pncwm->fSmallFrame );
    _NcTraceMsg(ulTrace, TEXT("->iFRAMEBOTTOM       %d"), pncwm->rgframeparts[iFRAMEBOTTOM] );
    _NcTraceMsg(ulTrace, TEXT("->iFRAMELEFT:        %d"), pncwm->rgframeparts[iFRAMELEFT] );
    _NcTraceMsg(ulTrace, TEXT("->iFRAMERIGHT:       %d"), pncwm->rgframeparts[iFRAMERIGHT] );
    _NcTraceMsg(ulTrace, TEXT("->framestate:        %d"), pncwm->framestate );
    _NcTraceMsg(ulTrace, TEXT("->iMinButtonPart:    %d"), pncwm->iMinButtonPart);
    _NcTraceMsg(ulTrace, TEXT("->iMaxButtonPart:    %d"), pncwm->iMaxButtonPart);
    _NcTraceMsg(ulTrace, TEXT("->rawCloseBtnState:  %d"), pncwm->rawCloseBtnState);
    _NcTraceMsg(ulTrace, TEXT("->rawMinBtnState:    %d"), pncwm->rawMinBtnState);
    _NcTraceMsg(ulTrace, TEXT("->rawMaxBtnState:    %d"), pncwm->rawMaxBtnState);
    _NcTraceMsg(ulTrace, TEXT("->cyMenu:            %d"), pncwm->cyMenu );
    _NcTraceMsg(ulTrace, TEXT("->cnMenuOffsetLeft:  %d"), pncwm->cnMenuOffsetLeft );
    _NcTraceMsg(ulTrace, TEXT("->cnMenuOffsetRight: %d"), pncwm->cnMenuOffsetRight );
    _NcTraceMsg(ulTrace, TEXT("->cnMenuOffsetTop:   %d"), pncwm->cnMenuOffsetTop );
    _NcTraceMsg(ulTrace, TEXT("->cnBorders:         %d"), pncwm->cnBorders );
    _NcTraceMsg(ulTrace, TEXT("->CaptionMargins: (%d,%d,%d,%d)"), pncwm->CaptionMargins );

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_WINDOW]   "), &pncwm->rcS0[NCRC_WINDOW] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CLIENT]   "), &pncwm->rcS0[NCRC_CLIENT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-Client margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CLIENT] );

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CONTENT]   "), &pncwm->rcS0[NCRC_CONTENT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-Content margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CONTENT]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_MENUBAR]   "), &pncwm->rcS0[NCRC_MENUBAR] );
    SPEW_MARGINS(ulTrace, TEXT("Window-Menubar margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_MENUBAR]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CAPTION]   "), &pncwm->rcS0[NCRC_CAPTION] ); 
    SPEW_MARGINS(ulTrace, TEXT("Window-Caption margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CAPTION]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_FRAMELEFT] "), &pncwm->rcS0[NCRC_FRAMELEFT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-FrameLeft margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_FRAMELEFT]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_FRAMERIGHT]"), &pncwm->rcS0[NCRC_FRAMERIGHT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-FrameRight margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_FRAMERIGHT]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_FRAMEBOTTOM]"), &pncwm->rcS0[NCRC_FRAMEBOTTOM] );
    SPEW_MARGINS(ulTrace, TEXT("Window-FrameBottom margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_FRAMEBOTTOM]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CLIENTEDGE]"), &pncwm->rcS0[NCRC_CLIENTEDGE] );
    SPEW_MARGINS(ulTrace, TEXT("Window-ClientEdge margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CLIENTEDGE]);
    
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_HSCROLL]   "), &pncwm->rcS0[NCRC_HSCROLL] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_VSCROLL]   "), &pncwm->rcS0[NCRC_VSCROLL] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_SIZEBOX]   "), &pncwm->rcS0[NCRC_SIZEBOX] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CLOSEBTN]  "), &pncwm->rcS0[NCRC_CLOSEBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_MINBTN]    "), &pncwm->rcS0[NCRC_MINBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_MAXBTN]    "), &pncwm->rcS0[NCRC_MAXBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_SYSBTN]    "), &pncwm->rcS0[NCRC_SYSBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_HELPBTN]   "), &pncwm->rcS0[NCRC_HELPBTN] );
#ifdef LAME_BUTTON
    SPEW_RECT(ulTrace, TEXT("rcLame"), &pncwm->rcS0[NCRC_LAMEBTN] );
#endif // LAME_BUTTON
}

//-------------------------------------------------------------------------//
void SPEW_THEMEMSG( ULONG ulTrace, LPCTSTR pszMsg, THEME_MSG* ptm )
{
    _NcTraceMsg(ulTrace, TEXT("%s hwnd: %08lX, uMsg: %04lX, handled?: %d"),
                pszMsg, (ptm)->hwnd, (ptm)->uMsg, (ptm)->fHandled );
}

//-------------------------------------------------------------------------//
void SPEW_SCROLLINFO( LPCTSTR pszMsg, HWND hwnd, LPCSCROLLINFO psi )
{
#ifdef _ENABLE_SCROLL_SPEW_
    _NcTraceMsg(ulTrace, L"%s for HWND %08lX...\ncbSize: %d\nfMask: %08lX\nnMin: %d\nnMax: %d\nnPage: %d\nnPos: %d",
                pszMsg, hwnd, psi->cbSize, psi->fMask, psi->nMin, psi->nMax, psi->nPage, psi->nPos );
#endif _ENABLE_SCROLL_SPEW_
}

#if defined(DEBUG_NCPAINT)

static int _cPaintSleep = 10;

void _DebugBackground(
    HDC hdc, 
    COLORREF rgb,
    const RECT *prc )
{
    //  paint some indicator stuff
    COLORREF rgb0 = SetBkColor( hdc, rgb );
    SPEW_RECT( NCTF_ALWAYS, TEXT("\tprc"), prc );
    ExtTextOut( hdc, prc->left, prc->top, ETO_OPAQUE, prc, NULL, 0, NULL );
    Sleep(_cPaintSleep);
    SetBkColor( hdc, rgb0 );
}


//-------------------------------------------------------------------------//
HRESULT _DebugDrawThemeBackground(
    HTHEME hTheme, 
    HDC hdc, 
    int iPartId, 
    int iStateId, 
    const RECT *prc,
    OPTIONAL const RECT* prcClip )
{
    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        _NcTraceMsg( NCTF_ALWAYS, TEXT("DrawThemeBackground( hTheme = %08lX, hdc = %08lX, iPartId = %d, iStateId = %d"),
                     hTheme, hdc, iPartId, iStateId );
        _DebugBackground( hdc, RGBDEBUGBKGND, prc );
    }

    //  paint the real background.
    HRESULT hr = DrawThemeBackground( hTheme, hdc, iPartId, iStateId, prc, prcClip );

    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        Sleep(_cPaintSleep);
    }

    return hr;
}

//-------------------------------------------------------------------------//
HRESULT _DebugDrawThemeBackgroundEx(
    HTHEME hTheme, 
    HDC hdc, 
    int iPartId, 
    int iStateId, 
    const RECT *prc, 
    OPTIONAL const DTBGOPTS *pOptions )
{
    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        _NcTraceMsg( NCTF_ALWAYS, TEXT("DrawThemeBackground( hTheme = %08lX, hdc = %08lX, iPartId = %d, iStateId = %d"),
                     hTheme, hdc, iPartId, iStateId );
        _DebugBackground( hdc, RGBDEBUGBKGND, prc );
    }

    //  paint the real background.
    HRESULT hr = DrawThemeBackgroundEx( hTheme, hdc, iPartId, iStateId, prc, pOptions );

    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        Sleep(_cPaintSleep);
    }

    return hr;
}


//-------------------------------------------------------------------------//
void NcDebugClipRgn( HDC hdc, COLORREF rgbPaint )
{
    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        HRGN hrgn = CreateRectRgn(0,0,1,1);

        if( hrgn )
        {
            if( GetClipRgn( hdc, hrgn ) > 0 )
            {
                HBRUSH hbr = CreateSolidBrush(rgbPaint);
                FillRgn( hdc, hrgn, hbr );
                DeleteObject(hbr);
                Sleep(_cPaintSleep);
            }
            DeleteObject(hrgn);
        }
    }
}

#endif //defined(DEBUG_NCPAINT)


#endif DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\ninegrid2.h ===
//  --------------------------------------------------------------------------
//  Module Name: NineGrid2.h
//
//  Copyright (c) 2000, 2001 Microsoft Corporation
//
//  Interface to the DrawNineGrid2 function
//
//  History:    2000-12-20  justmann    created
//  --------------------------------------------------------------------------
#ifndef _NINEGRID2_
#define _NINEGRID2_

#define NGI_ALPHA        0x00000001
#define NGI_TRANS        0x00000002
#define NGI_BORDERONLY   0x00000004

typedef struct NGIMAGEtag
{
    HBITMAP    hbm;
    ULONG*     pvBits;
    int        iWidth;
    int        iBufWidth;
    int        iHeight;
    MARGINS    margin;
    SIZINGTYPE eSize;
    DWORD      dwFlags;
    COLORREF   crTrans;
} NGIMAGE, *PNGIMAGE;

//---- these 2 functions should be called at PROCESS_ATTACH/DETACH ----
BOOL NineGrid2StartUp();
void NineGrid2ShutDown();

HRESULT BitmapToNGImage(HDC hdc, HBITMAP hbm, int left, int top, int right, int bottom, MARGINS margin, SIZINGTYPE eSize, DWORD dwFlags, COLORREF crTrans, PNGIMAGE pngi);
HRESULT FreeNGImage(PNGIMAGE pngi);

#define DNG_MUSTFLIP     0x00000004
#define DNG_FREE         0x00000008
#define DNG_SOURCEFLIPPED 0x00000010

HRESULT DrawNineGrid2(HDC hdc, PNGIMAGE pngiSrc, RECT* pRect, const RECT *prcClip, DWORD dwFlags);

#endif //_NINEGRID2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\ninegrid2.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: NineGrid2.cpp
//
//  Copyright (c) 2000, 2001 Microsoft Corporation
//
//  Implementation of the DrawNineGrid2 function
//
//  History:    2000-12-20  justmann    created
//  --------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "tmschema.h"
#include "ninegrid2.h"

#define DNG_BUF_WIDTH    256
#define DNG_BUF_HEIGHT   60

typedef struct STRETCH
{
	ULONG xStart;
	ULONG xAccum;
	ULONG xFrac;
	ULONG xInt;
    ULONG ulDestWidth;
    ULONG ulSrcWidth;
    int   left;
    int   right;
} STRETCH;

typedef struct DNGINTERNALDATAtag
{
    int     cxClipMin;
    int     cxClipMax;

    ULONG*  pvDestBits;
    int     iDestWidth;
    int     iClipWidth;

    ULONG*  pvSrcBits;
    int     iSrcWidth;
    int     iSrcBufWidth;

    int     cxLeftWidth;
    int     xMinLeft;
    int     xMaxLeft;

    int     cxRightWidth;
    int     xMinRight;
    int     xMaxRight;

    int     cxMiddleWidth;
    int     cxNewMiddleWidth;
    int     xMinMiddle;
    int     xMaxMiddle;

    // Variable for shrunken corners and sides
    BOOL    fShowMiddle;
    STRETCH stretchLeft;
    STRETCH stretchRight;
    int     cxNewLeftWidth;
    int     cxNewRightWidth;

    BOOL    fTileMode;
    // Specific to non-tile mode (i.e. stretch mode)
    STRETCH stretchMiddle;
} DNGINTERNALDATA;

static HDC     s_hdcBuf = NULL;
static HBITMAP s_hbmBuf = NULL;
static HBITMAP s_hbmOldBuf = NULL;
static CRITICAL_SECTION s_dngLock;

void DNG_FreeDIB(HDC* phdcDest, HBITMAP* phbmDest, HBITMAP* phbmDestOld);

BOOL NineGrid2StartUp()
{
    InitializeCriticalSection(&s_dngLock);
    return TRUE;
}

void NineGrid2ShutDown()
{
    DNG_FreeDIB(&s_hdcBuf, &s_hbmBuf, &s_hbmOldBuf);

    DeleteCriticalSection(&s_dngLock);
}

inline void DNG_CreateDIB(HDC hdc, int iWidth, int iHeight, ULONG** ppvDestBits, HDC* phdcDest, HBITMAP* phbmDest, HBITMAP* phbmDestOld)
{
    *phdcDest = CreateCompatibleDC(hdc);
    if (*phdcDest)
    {
        BITMAPINFO bi = {0};

        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = iWidth;
        bi.bmiHeader.biHeight = iHeight;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        *phbmDest = CreateDIBSection(*phdcDest, &bi, DIB_RGB_COLORS, (VOID**)ppvDestBits, NULL, 0);
        if (*phbmDest)
        {
            *phbmDestOld = (HBITMAP) SelectObject(*phdcDest, *phbmDest);
        }
        else
        {
            DeleteDC(*phdcDest);
            *phdcDest = NULL;
        }
    }
}

void DNG_FreeDIB(HDC* phdcDest, HBITMAP* phbmDest, HBITMAP* phbmDestOld)
{
    if (*phdcDest)
    {
        SelectObject(*phdcDest, *phbmDestOld);
        DeleteObject(*phbmDest);
        DeleteDC(*phdcDest);
    }

    *phdcDest = NULL;
}

HRESULT BitmapToNGImage(HDC hdc, HBITMAP hbm, int left, int top, int right, int bottom, MARGINS margin, SIZINGTYPE eSize, DWORD dwFlags, COLORREF crTrans, PNGIMAGE pngi)
{
    HRESULT hr = E_INVALIDARG;

    if (pngi)
    {
        pngi->margin = margin;
        pngi->eSize  = eSize;
        pngi->dwFlags = dwFlags;
        pngi->crTrans = crTrans;

        pngi->iWidth = right - left;
        pngi->iHeight = bottom - top;

        HDC hdcBuf = NULL;
        HBITMAP hbmOld;
        DNG_CreateDIB(hdc, pngi->iWidth, pngi->iHeight, &(pngi->pvBits), &hdcBuf, &pngi->hbm, &hbmOld);

        if (hdcBuf)
        {
            HDC hdcTempMem = CreateCompatibleDC(hdc);
            if (hdcTempMem)
            {
                HBITMAP hbmTempOld = (HBITMAP) SelectObject(hdcTempMem, hbm);

                BitBlt(hdcBuf, 0, 0, pngi->iWidth, pngi->iHeight, hdcTempMem, left, top, SRCCOPY);

                hr = S_OK;

                SelectObject(hdcTempMem, hbmTempOld);
                DeleteDC(hdcTempMem);
            }

            SelectObject(hdcBuf, hbmOld);
            DeleteDC(hdcBuf);
        }
    }

    return hr;
}


HRESULT FreeNGImage(PNGIMAGE pngi)
{
    HRESULT hr = E_INVALIDARG;

    if (pngi)
    {
        if (pngi->hbm)
        {
            DeleteObject(pngi->hbm);
        }
        pngi->hbm = NULL;

        hr = S_OK;
    }

    return hr;
}

inline void DNG_StretchRow(ULONG* pvDestBits, ULONG* pvSrcBits, STRETCH * ps)
{
    ULONG*	pvTemp = pvDestBits + ps->left;
	ULONG*	pvSentinel = pvDestBits + ps->right;

	ULONG	xInt = ps->xInt;
	ULONG	xFrac = ps->xFrac;
	ULONG	xTmp;
	ULONG	xAccum = ps->xAccum;
	ULONG * pulSrc = pvSrcBits + ps->xStart;
	ULONG	ulSrc;

    while (pvTemp != pvSentinel)
    {
        ulSrc  = *pulSrc;
        xTmp   = xAccum + xFrac;
        pulSrc = pulSrc + xInt + (xTmp < xAccum);
        *pvTemp = ulSrc;
        pvTemp++;
        xAccum = xTmp;
    }
}

inline void DNG_InitStretch(STRETCH* pStretch, ULONG ulDestWidth, ULONG ulSrcWidth, int left, int right)
{
    pStretch->right = right;
    pStretch->left  = left;

	ULONGLONG dx = ((((ULONGLONG) ulSrcWidth << 32) - 1) / (ULONGLONG) ulDestWidth) + 1;
	ULONGLONG x = (((ULONGLONG) ulSrcWidth << 32) / (ULONGLONG) ulDestWidth) >> 1;
	ULONG   xInt = pStretch->xInt = (ULONG) (dx >> 32);
	ULONG   xFrac = pStretch->xFrac = (ULONG) (dx & 0xFFFFFFFF);

	ULONG   xAccum = (ULONG) (x & 0xFFFFFFFF);
	ULONG	xTmp;
	ULONG   xStart = (ULONG) (x >> 32);

    for (int i = 0; i < left; i++)
    {
        xTmp   = xAccum + xFrac;
        xStart = xStart + xInt + (xTmp < xAccum);
        xAccum = xTmp;
    }

    pStretch->xStart = xStart;
    pStretch->xAccum = xAccum;
}

inline void DNG_DrawRow(DNGINTERNALDATA* pdng)
{
    ULONG* pvDestLoc = pdng->pvDestBits;
    ULONG* pvSrcLoc = pdng->pvSrcBits;

    // Left
    if (pdng->cxClipMin < pdng->cxNewLeftWidth)
    {
        if (pdng->cxLeftWidth == pdng->cxNewLeftWidth)
        {
            CopyMemory(pvDestLoc + pdng->xMinLeft, pvSrcLoc + pdng->xMinLeft, (pdng->xMaxLeft - pdng->xMinLeft) * sizeof(ULONG));
        }
        else
        {
            DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchLeft);
        }
    }
    pvDestLoc += pdng->cxNewLeftWidth;
    pvSrcLoc  += pdng->cxLeftWidth;
  
    // Middle
    if (pdng->fShowMiddle)
    {
        if (pdng->xMinMiddle < pdng->xMaxMiddle)
        {
            if (pdng->fTileMode)
            {
                ULONG* pvTempSrc = pvSrcLoc;
                ULONG* pvTempDest = pvDestLoc;

                // Fill in Top Tile
                int xMin = pdng->xMinMiddle;
                int xDiff = xMin - pdng->cxLeftWidth;
                pvDestLoc += xDiff;
                int iTileSize = pdng->cxMiddleWidth - (xDiff % pdng->cxMiddleWidth);
                pvSrcLoc += xDiff % pdng->cxMiddleWidth;

                int xMax = pdng->xMaxMiddle;
                for (int x = xMin; x < xMax; x++, pvDestLoc++ , pvSrcLoc++)
                {
                    *pvDestLoc = *pvSrcLoc;
                    iTileSize--;
                    if (iTileSize == 0)
                    {
                        iTileSize = pdng->cxMiddleWidth;
                        pvSrcLoc -= iTileSize;
                    }
                }

                pvDestLoc = pvTempDest;
                pvSrcLoc = pvTempSrc;
            }
            else
            {
                DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchMiddle);
            }
        }
        pvDestLoc += pdng->cxNewMiddleWidth;
    }   
    pvSrcLoc  += pdng->cxMiddleWidth;

    // Right
    if (pdng->cxClipMax > (pdng->iDestWidth - pdng->cxNewRightWidth))
    {
        if (pdng->cxRightWidth == pdng->cxNewRightWidth)
        {
            CopyMemory(pvDestLoc + pdng->xMinRight, pvSrcLoc + pdng->xMinRight, (pdng->xMaxRight - pdng->xMinRight) * sizeof(ULONG));
        }
        else
        {
            DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchRight);
        }
    }
}

inline void DNG_StretchCol(DNGINTERNALDATA* pdng, STRETCH * ps)
{
    ULONG*  pvOldDestBits = pdng->pvDestBits;
    ULONG*  pvOldSrcBits = pdng->pvSrcBits;
    
    ULONG*	pvTemp = pdng->pvDestBits + (DNG_BUF_WIDTH * ps->left);
    ULONG*	pvSentinel = pdng->pvDestBits + (DNG_BUF_WIDTH * ps->right); 

    ULONG	xInt = ps->xInt;
    ULONG	xFrac = ps->xFrac;
    ULONG	xTmp;
    ULONG	xAccum = ps->xAccum;
    ULONG * pulSrc = pdng->pvSrcBits + (pdng->iSrcBufWidth * ps->xStart);
    ULONG	xDelta = 1;	// force stretch on first scan

    while (pvTemp != pvSentinel)
    {
	    if (xDelta != 0)
        {
            pdng->pvDestBits = pvTemp;
            pdng->pvSrcBits = pulSrc;
            DNG_DrawRow(pdng);
        }
	    else
        {
		    memcpy(pvTemp + pdng->cxClipMin, pvTemp + pdng->cxClipMin - DNG_BUF_WIDTH, pdng->iClipWidth * sizeof(ULONG));
        }

        xTmp   = xAccum + xFrac;

	    xDelta = (xInt + (xTmp < xAccum));
	    pulSrc = pulSrc + (pdng->iSrcBufWidth * xDelta);
        pvTemp += DNG_BUF_WIDTH;
        xAccum = xTmp;
    }

    pdng->pvDestBits = pvOldDestBits;
    pdng->pvSrcBits = pvOldSrcBits;
}

HRESULT DrawNineGrid2(HDC hdc, PNGIMAGE pngiSrc, RECT* pRect, const RECT *prcClip, DWORD dwFlags)
{
    // Store the static buffer
    static ULONG*  s_pvBitsBuf = NULL;

    // Make sure that coordinates are valid;
    RECT rcDest = *pRect;
    if (rcDest.left > rcDest.right)
    {
        int xTemp = rcDest.left;
        rcDest.left = rcDest.right;
        rcDest.right = xTemp;
    }
    if (rcDest.top > rcDest.bottom)
    {
        int yTemp = rcDest.bottom;
        rcDest.bottom = rcDest.top;
        rcDest.top = yTemp;
    }

    RECT rcClip;
    if (prcClip)
    {
        IntersectRect(&rcClip, &rcDest, prcClip);
    }
    else
    {
        CopyRect(&rcClip, &rcDest);
    }

    HRESULT hr = S_OK;

    if ((pngiSrc->eSize == ST_TILE) || (pngiSrc->eSize == ST_STRETCH) || (pngiSrc->eSize == ST_TRUESIZE))
    {
        ULONG*  pvDestBits = NULL;

        int iDestWidth = rcDest.right - rcDest.left;
        int iDestHeight = rcDest.bottom - rcDest.top;
        int iClipWidth = rcClip.right - rcClip.left;
        int iClipHeight = rcClip.bottom - rcClip.top;

        if ((iClipWidth > DNG_BUF_WIDTH) || (iClipHeight > DNG_BUF_HEIGHT))
        {
            // Divide the image into chunks smaller or equal to the buffer
            for (int y = rcClip.top; y < rcClip.bottom; y += DNG_BUF_HEIGHT)
            {
                for (int x = rcClip.left; x < rcClip.right; x += DNG_BUF_WIDTH)
                {
                    RECT rcTemp = { x, y, x + DNG_BUF_WIDTH, y + DNG_BUF_HEIGHT };
                    RECT rcNewClip;
                    IntersectRect(&rcNewClip, &rcTemp, &rcClip);
                    DrawNineGrid2(hdc, pngiSrc, &rcDest, &rcNewClip, dwFlags);
                }
            }
        }
        else
        {
            EnterCriticalSection(&s_dngLock);

            // Use temporary buffer
            if (!s_hdcBuf)
            {
                DNG_CreateDIB(hdc, DNG_BUF_WIDTH, DNG_BUF_HEIGHT, &s_pvBitsBuf, &s_hdcBuf, &s_hbmBuf, &s_hbmOldBuf);
                SetLayout(s_hdcBuf, LAYOUT_BITMAPORIENTATIONPRESERVED); 
            }

            pvDestBits = s_pvBitsBuf;

            if (s_hdcBuf)
            {
                DNGINTERNALDATA dng;

                dng.cxClipMin = rcClip.left - rcDest.left;
                dng.cxClipMax = rcClip.right - rcDest.left;
                int cyClipMin = rcClip.top - rcDest.top;
                int cyClipMax = rcClip.bottom - rcDest.top;
                pvDestBits += ((cyClipMin - (iDestHeight - DNG_BUF_HEIGHT)) * DNG_BUF_WIDTH) - dng.cxClipMin;

                int cxImage = rcClip.right - rcClip.left;
                int cyImage = rcClip.bottom - rcClip.top;

                if (pngiSrc->eSize == ST_TRUESIZE)
                {
                    ULONG* pvDestLoc = pvDestBits + (iDestHeight - 1) * DNG_BUF_WIDTH;
                    ULONG* pvSrcLoc = pngiSrc->pvBits + pngiSrc->iBufWidth * (pngiSrc->iHeight - 1);
                    int yMin = cyClipMin;
                    pvDestLoc -= yMin * DNG_BUF_WIDTH;
                    pvSrcLoc -= yMin * pngiSrc->iBufWidth;
                    int yMax = min(pngiSrc->iHeight, cyClipMax);

                    int xMin = dng.cxClipMin;
                    int xMax = min(pngiSrc->iWidth, dng.cxClipMax);

                    if (xMax > xMin)
                    {
                        for (int y = yMin; y < yMax; y++, pvDestLoc -= DNG_BUF_WIDTH, pvSrcLoc -= pngiSrc->iBufWidth)
                        {
                            CopyMemory(pvDestLoc + xMin, pvSrcLoc + xMin, (xMax - xMin) * 4);
                        }
                    }

                    cxImage = xMax - xMin;
                    cyImage = yMax - yMin;
                }
                else
                {
                    // Setup data
                    dng.iDestWidth  = iDestWidth;
                    dng.iClipWidth  = iClipWidth;
                    dng.iSrcWidth   = pngiSrc->iWidth;
                    dng.iSrcBufWidth = pngiSrc->iBufWidth;

                    dng.cxLeftWidth    = pngiSrc->margin.cxLeftWidth;
                    dng.cxRightWidth   = pngiSrc->margin.cxRightWidth;

                    dng.fTileMode = (pngiSrc->eSize == ST_TILE);

                    // Calculate clip stuff

                    // Pre-calc corner stretching variables
                    dng.fShowMiddle = (iDestWidth  - pngiSrc->margin.cxLeftWidth - pngiSrc->margin.cxRightWidth > 0);
                    if (!dng.fShowMiddle)
                    {
                        dng.cxNewLeftWidth  = (dng.cxLeftWidth + dng.cxRightWidth == 0) ? 0 : (dng.cxLeftWidth * dng.iDestWidth) / (dng.cxLeftWidth + dng.cxRightWidth);
                        dng.cxNewRightWidth = dng.iDestWidth - dng.cxNewLeftWidth;
                    }
                    else
                    {
                        dng.cxNewLeftWidth  = pngiSrc->margin.cxLeftWidth;
                        dng.cxNewRightWidth = pngiSrc->margin.cxRightWidth;
                    }

                    // Pre-calc Left side variables
                    dng.xMinLeft = dng.cxClipMin;
                    dng.xMaxLeft = min(dng.cxNewLeftWidth, dng.cxClipMax);
                    if (!dng.fShowMiddle && dng.cxNewLeftWidth)
                    {
                        DNG_InitStretch(&dng.stretchLeft, dng.cxNewLeftWidth, dng.cxLeftWidth, dng.xMinLeft, dng.xMaxLeft);
                    }

                    // Pre-calc Horizontal Middle Variables
                    dng.cxMiddleWidth    = dng.iSrcWidth  - dng.cxLeftWidth - dng.cxRightWidth;
                    dng.cxNewMiddleWidth = dng.iDestWidth - dng.cxNewLeftWidth - dng.cxNewRightWidth;
                    dng.xMinMiddle = max(dng.cxNewLeftWidth, dng.cxClipMin);
                    dng.xMaxMiddle = min(dng.cxNewLeftWidth + dng.cxNewMiddleWidth, dng.cxClipMax);
                    if (dng.fShowMiddle)
                    {
                        DNG_InitStretch(&dng.stretchMiddle, dng.cxNewMiddleWidth, dng.cxMiddleWidth, dng.xMinMiddle - dng.cxNewLeftWidth, dng.xMaxMiddle - dng.cxNewLeftWidth);
                    }

                    // Pre-calc Right side variables
                    dng.xMinRight = max(dng.iDestWidth - dng.cxNewRightWidth, dng.cxClipMin) - dng.cxNewLeftWidth - dng.cxNewMiddleWidth;
                    dng.xMaxRight = min(dng.iDestWidth, dng.cxClipMax) - dng.cxNewLeftWidth - dng.cxNewMiddleWidth;
                    if (!dng.fShowMiddle && dng.cxNewRightWidth)
                    {
                        DNG_InitStretch(&dng.stretchRight, dng.cxNewRightWidth, dng.cxRightWidth, dng.xMinRight, dng.xMaxRight);
                    }

                    BOOL fShowVertMiddle = (iDestHeight - pngiSrc->margin.cyTopHeight - pngiSrc->margin.cyBottomHeight > 0);
                    int cyTopHeight    = pngiSrc->margin.cyTopHeight;
                    int cyBottomHeight = pngiSrc->margin.cyBottomHeight;
                    int cyNewTopHeight;
                    int cyNewBottomHeight;
                    if (!fShowVertMiddle)
                    {
                        cyNewTopHeight = (cyTopHeight + cyBottomHeight == 0) ? 0 : (cyTopHeight * iDestHeight) / (cyTopHeight + cyBottomHeight);
                        cyNewBottomHeight = iDestHeight - cyNewTopHeight;
                    }
                    else
                    {
                        cyNewTopHeight    = cyTopHeight;
                        cyNewBottomHeight = cyBottomHeight;
                    }

                    // Draw Bottom
                    // Draw the scan line from (iDestHeight - cyNewBottomHeight) to less than iDestHeight, in screen coordinates
                    int yMin = max(iDestHeight - cyNewBottomHeight, cyClipMin);
                    int yMax = min(iDestHeight, cyClipMax);

                    if (cyClipMax > iDestHeight - cyNewBottomHeight)
                    {
                        dng.pvDestBits = pvDestBits;
                        dng.pvSrcBits = pngiSrc->pvBits;
                        if (cyBottomHeight == cyNewBottomHeight)
                        {
                            int yDiff = yMin - (iDestHeight - cyNewBottomHeight);
                            dng.pvDestBits += (cyBottomHeight - 1 - yDiff) * DNG_BUF_WIDTH;
                            dng.pvSrcBits  += (cyBottomHeight - 1 - yDiff) * dng.iSrcBufWidth;

                            for (int y = yMin; y < yMax; y++, dng.pvDestBits -= DNG_BUF_WIDTH, dng.pvSrcBits -= dng.iSrcBufWidth)
                            {
                                DNG_DrawRow(&dng);
                            }
                        }
                        else if (cyNewBottomHeight > 0)
                        {
                            STRETCH stretch;
                            DNG_InitStretch(&stretch, cyNewBottomHeight, cyBottomHeight, cyNewBottomHeight - (yMax - iDestHeight + cyNewBottomHeight), cyNewBottomHeight - (yMin - iDestHeight + cyNewBottomHeight));
                            DNG_StretchCol(&dng, &stretch);
                        }
                    }

                    // Draw Middle
                    // Draw the scan line from cyNewTopHeight to less than (iDestHeight - cyNewBottomHeight), in screen coordinates
                    if (fShowVertMiddle && (cyClipMin < iDestHeight - cyNewBottomHeight) && (cyClipMax > cyNewTopHeight))
                    {
                        int cySrcTileSize = pngiSrc->iHeight - pngiSrc->margin.cyTopHeight - pngiSrc->margin.cyBottomHeight;
                        int cyDestTileSize = iDestHeight - pngiSrc->margin.cyTopHeight - pngiSrc->margin.cyBottomHeight;

                        dng.pvDestBits = pvDestBits + pngiSrc->margin.cyBottomHeight * DNG_BUF_WIDTH;
                        dng.pvSrcBits = pngiSrc->pvBits + pngiSrc->margin.cyBottomHeight * pngiSrc->iBufWidth;

                        int yMin = max(cyTopHeight, cyClipMin);

                        if (dng.fTileMode)
                        {
                            // Start off tile
                            dng.pvDestBits += (cyDestTileSize - 1) * DNG_BUF_WIDTH;
                            dng.pvSrcBits  += (cySrcTileSize - 1)  * dng.iSrcBufWidth;

                            int yDiff = yMin - cyTopHeight;
                            dng.pvDestBits -= yDiff * DNG_BUF_WIDTH;
                            int yOffset = (yDiff % cySrcTileSize);
                            dng.pvSrcBits -= yOffset * dng.iSrcBufWidth;
                            int iTileOffset = cySrcTileSize - yOffset;

                            int yMax = min(yMin + min(cySrcTileSize, cyDestTileSize), min(iDestHeight - cyBottomHeight, cyClipMax));

                            for (int y = yMin; y < yMax; y++, dng.pvDestBits -= DNG_BUF_WIDTH, dng.pvSrcBits -= dng.iSrcBufWidth)
                            {
                                DNG_DrawRow(&dng);
                                iTileOffset--;
                                if (iTileOffset == 0)
                                {
                                    iTileOffset = cySrcTileSize;
                                    dng.pvSrcBits += dng.iSrcBufWidth * cySrcTileSize;
                                }
                            }

                            // Repeat tile pattern
                            dng.pvSrcBits = dng.pvDestBits + (DNG_BUF_WIDTH * cySrcTileSize);
                            yMin = yMax;
                            yMax = min(iDestHeight - cyBottomHeight, cyClipMax);
                            for (int y = yMin; y < yMax; y++, dng.pvDestBits -= DNG_BUF_WIDTH, dng.pvSrcBits -= DNG_BUF_WIDTH)
                            {
                                CopyMemory(dng.pvDestBits + dng.cxClipMin, dng.pvSrcBits + dng.cxClipMin, dng.iClipWidth * sizeof(ULONG));
                            }
                        }
                        else
                        {
                            int yMax = min(iDestHeight - cyBottomHeight, cyClipMax);

                            STRETCH stretch;
                            DNG_InitStretch(&stretch, cyDestTileSize, cySrcTileSize, cyDestTileSize - (yMax - cyTopHeight), cyDestTileSize - (yMin - cyTopHeight));
                            // Convert from screen coords to DIB coords
                            DNG_StretchCol(&dng, &stretch);
                        }
                    }
            
                    // Draw Top
                    // Draw the scan line from 0 to less than cyNewTopHeight, in screen coordinates
                    yMin = cyClipMin;
                    yMax = min(cyNewTopHeight, cyClipMax);

                    if (cyClipMin < cyNewTopHeight)
                    {
                        dng.pvDestBits = pvDestBits + (iDestHeight - cyNewTopHeight) * DNG_BUF_WIDTH;
                        dng.pvSrcBits = pngiSrc->pvBits + (pngiSrc->iHeight - pngiSrc->margin.cyTopHeight) * pngiSrc->iBufWidth;
                        if (cyTopHeight == cyNewTopHeight)
                        {
                            dng.pvDestBits += (cyTopHeight - 1 - yMin) * DNG_BUF_WIDTH;
                            dng.pvSrcBits  += (cyTopHeight - 1 - yMin) * dng.iSrcBufWidth;

                            for (int y = yMin; y < yMax; y++, dng.pvDestBits -= DNG_BUF_WIDTH, dng.pvSrcBits -= dng.iSrcBufWidth)
                            {
                                DNG_DrawRow(&dng);
                            }
                        }
                        else if (cyNewTopHeight > 0)
                        {
                            STRETCH stretch;
                            DNG_InitStretch(&stretch, cyNewTopHeight, cyTopHeight, cyNewTopHeight - yMax, cyNewTopHeight - yMin);
                            DNG_StretchCol(&dng, &stretch);
                        }
                    }
                }

                if ((dwFlags & DNG_MUSTFLIP) && ((pngiSrc->dwFlags & NGI_TRANS) || (pngiSrc->dwFlags & NGI_ALPHA)))
                {
                    // Flip the buffer
                    for (int y = 0; y < DNG_BUF_HEIGHT; y++)
                    {
                        ULONG* pvLeftBits = s_pvBitsBuf + (y * DNG_BUF_WIDTH);
                        ULONG* pvRightBits = s_pvBitsBuf + (y * DNG_BUF_WIDTH) + iClipWidth - 1;
                        for (int x = 0; x < (iClipWidth / 2); x++)
                        {
                            ULONG ulTemp = *pvLeftBits;
                            *pvLeftBits = *pvRightBits;
                            *pvRightBits = ulTemp;

                            pvLeftBits++;
                            pvRightBits--;
                        }
                    }
                }

                if (pngiSrc->dwFlags & NGI_ALPHA)
                {
                    BLENDFUNCTION bf;
                    bf.BlendOp = AC_SRC_OVER;
                    bf.BlendFlags = 0;
                    bf.SourceConstantAlpha = 255;
                    bf.AlphaFormat = AC_SRC_ALPHA;

                    GdiAlphaBlend(hdc, rcClip.left, rcClip.top, cxImage, cyImage, s_hdcBuf, 0, 0, cxImage, cyImage, bf);
                }
                else if (pngiSrc->dwFlags & NGI_TRANS)
                {
                    GdiTransparentBlt(hdc, rcClip.left, rcClip.top, cxImage, cyImage, s_hdcBuf, 0, 0, cxImage, cyImage, pngiSrc->crTrans);
                }
                else
                {
                    BitBlt(hdc, rcClip.left, rcClip.top, cxImage, cyImage, s_hdcBuf, 0, 0, SRCCOPY);
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            LeaveCriticalSection(&s_dngLock);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\render.h ===
//---------------------------------------------------------------------------
//  Render.h - implements the themed drawing services 
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "SimpStr.h"
#include "loader.h"
#include "ThemeFile.h"
#include "NtlEng.h"
//---------------------------------------------------------------------------
#define FONTCOMPARE(f1, f2) ((memcmp(&(f1), &(f2), sizeof(LOGFONT)-LF_FACESIZE)==0) \
    && (lstrcmpi((f1).lfFaceName, (f2).lfFaceName)==0))
//---------------------------------------------------------------------------
#define DEFAULT_TRANSPARENT_COLOR   RGB(255, 0, 255)
//---------------------------------------------------------------------------
class CRenderCache;     // forward
class CDrawBase;        // forward
class CTextDraw;        // forward
struct BRUSHBUFF;       // forward
//---------------------------------------------------------------------------
struct PARTINFO
{
    int iMaxState;

    CDrawBase *pDrawObj;               // DrawObj[0]
    CTextDraw *pTextObj;               // TextObj[0]

    CDrawBase **pStateDrawObjs;        // DrawObjs[1..iMaxState]
    CTextDraw **pStateTextObjs;        // TextObjs[1..iMaxState]
};
//---------------------------------------------------------------------------
class CRenderObj : public INtlEngCallBack
{
public:
	CRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, int iClassNameOffset,
        __int64 iUniqueId, BOOL fEnableCache, DWORD dwOtdFlags);
    ~CRenderObj();
    HRESULT Init(CDrawBase *pBaseObj, CTextDraw *pTextObj);   // must be called after constructor

    HRESULT CreateImageBrush(HDC hdc, int IPartId, int iStateId, int iImageIndex, HBRUSH *phbr);
    BOOL ValidateObj();

public:
    //---- information methods ----
    HRESULT WINAPI GetColor(int iPartId, int iStateId, int iPropId, COLORREF *pColor);
    HRESULT WINAPI GetMetric(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, int *piVal);
    HRESULT WINAPI GetString(int iPartId, int iStateId, int iPropId, LPWSTR pszBuff, DWORD dwMaxBuffChars);
    HRESULT WINAPI GetBool(int iPartId, int iStateId, int iPropId, BOOL *pfVal);
    HRESULT WINAPI GetInt(int iPartId, int iStateId, int iPropId, int *piVal);
    HRESULT WINAPI GetEnumValue(int iPartId, int iStateId, int iPropId, int *piVal);
    HRESULT WINAPI GetPosition(int iPartId, int iStateId, int iPropId, POINT *pPoint);
    HRESULT WINAPI GetFont(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, BOOL fWantHdcScaling,
        LOGFONT *pFont);
    HRESULT WINAPI GetMargins(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, 
        OPTIONAL RECT *prc, MARGINS *pMargins);
    HRESULT WINAPI GetIntList(int iPartId, int iStateId, int iPropId, INTLIST *pIntList);
    HRESULT WINAPI GetRect(int iPartId, int iStateId, int iPropId, RECT *pRect);
    HRESULT WINAPI GetFilename(int iPartId, int iStateId, int iPropId, LPWSTR pszBuff, DWORD dwMaxBuffChars);
    HRESULT WINAPI GetPropertyOrigin(int iPartId, int iStateId, int iPropId, PROPERTYORIGIN *pOrigin);
    BOOL WINAPI IsPartDefined(int iPartId, int iStateId);

    HRESULT GetFilenameOffset(int iPartId, int iStateId, int iPropId, int *piFileNameOffset);

    HRESULT GetBitmap(HDC hdc, int iDibOffset, OUT HBITMAP *pBitmap);

    HRESULT GetScaledFontHandle(HDC hdc, LOGFONT *plf, HFONT *phFont);

    void ReturnBitmap(HBITMAP hBitmap);
    void ReturnFontHandle(HFONT hFont);

    HRESULT FindGlobalDrawObj(BYTE *pb, int iPartId, int iStateId, CDrawBase **ppObj);
    HRESULT GetGlobalDrawObj(int iPartId, int iStateId, CDrawBase **ppObj);
    HRESULT SetDpiOverride(int iDpiOverride);   
    int GetDpiOverride();
    //---------------------------------------------------------------------------
    inline HRESULT GetDrawObj(int iPartId, int iStateId, CDrawBase **ppObj)
    {
        HRESULT hr = S_OK;
        
        if (! _pParts)
        {
            hr = MakeError32(E_FAIL);
        }
        else
        {
            if ((iPartId < 0) || (iPartId > _iMaxPart))
                iPartId = 0;

            PARTINFO *ppi = &_pParts[iPartId];

            if (! ppi->pStateDrawObjs)      // good to go
            {
                *ppObj = ppi->pDrawObj;
            }
            else
            {
                if ((iStateId < 0) || (iStateId > ppi->iMaxState))
                    iStateId = 0;

                if (! iStateId)
                    *ppObj = ppi->pDrawObj;
                else
                    *ppObj = ppi->pStateDrawObjs[iStateId-1];
            }

            if (! *ppObj)
            {
                Log(LOG_ERROR, L"GetDrawObj() returned NULL");
                hr = MakeError32(E_FAIL);
            }
        }

        return hr;
    }
    //---------------------------------------------------------------------------
    inline HRESULT GetTextObj(int iPartId, int iStateId, CTextDraw **ppObj)
    {
        HRESULT hr = S_OK;
        
        if (! _pParts)
        {
            hr = MakeError32(E_FAIL);
        }
        else
        {
            if ((iPartId < 0) || (iPartId > _iMaxPart))
                iPartId = 0;

            PARTINFO *ppi = &_pParts[iPartId];

            if (! ppi->pStateTextObjs)      // good to go
            {
                *ppObj = ppi->pTextObj;
            }
            else
            {
                if ((iStateId < 0) || (iStateId > ppi->iMaxState))
                    iStateId = 0;

                if (! iStateId)
                    *ppObj = ppi->pTextObj;
                else
                    *ppObj = ppi->pStateTextObjs[iStateId-1];
            }

            if (! *ppObj)
            {
                Log(LOG_ERROR, L"GetTextObj() returned NULL");
                hr = MakeError32(E_FAIL);
            }
        }

        return hr;
    }
    //---------------------------------------------------------------------------
    inline bool IsReady()
    {
        if (_pThemeFile)
        {
            return _pThemeFile->IsReady();
        }
        return true;
    }
    //---------------------------------------------------------------------------
   
    int GetValueIndex(int iPartId, int iStateId, int iTarget);

    HRESULT PrepareRegionDataForScaling(RGNDATA *pRgnData, LPCRECT prcImage, MARGINS *pMargins);
    
protected:
    //---- helpers ----
    HRESULT GetData(int iPartId, int iStateId, int iPropId, BYTE **ppDibData, 
        OPTIONAL int *piDibSize=NULL);

    CRenderCache *GetTlsCacheObj();
 
    HRESULT WalkDrawObjects(MIXEDPTRS &u, int *iPartOffsets);
    HRESULT WalkTextObjects(MIXEDPTRS &u, int *iPartOffsets);
    
    HRESULT CreateBitmapFromData(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap);

    HRESULT BuildPackedPtrs(CDrawBase *pBaseObj, CTextDraw *pTextObj);
    
    HRESULT PrepareAlphaBitmap(HBITMAP hBitmap);

public:
    //---- data ----
    char _szHead[8];

    //---- object id ----
    CUxThemeFile *_pThemeFile;        // holds a refcnt on the binary theme file
    int _iCacheSlot;        // our index into thread local cache list
    __int64 _iUniqueId;     // used to validate cache objects against render objects 

    //---- cached info from theme ----
    BYTE *_pbThemeData;     // ptr to start of binary theme data
    BYTE *_pbSectionData;   // ptr to our section of binary theme data

    BOOL _fCacheEnabled;
    BOOL _fCloseThemeFile;

    THEMEMETRICS *_ptm;     // ptr to theme metrics
    LPCWSTR _pszClassName;  // ptr to class name we matched to create this obj

    //---- direct ptrs to packed structs ----
    int _iMaxPart;
    PARTINFO *_pParts;      // [0.._MaxPart]

    //---- OpenThemeData override flags ----
    DWORD _dwOtdFlags;
    int _iDpiOverride;

    char _szTail[4];
};
//---------------------------------------------------------------------------
HRESULT CreateRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, 
    int iClassNameOffset, __int64 iUniqueId, BOOL fEnableCache, CDrawBase *pBaseObj,
    CTextDraw *pTextObj, DWORD dwOtdFlags, CRenderObj **ppObj);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\renderlist.cpp ===
//---------------------------------------------------------------------------
//  RenderList.cpp - manages list of CRemderObj objects
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "RenderList.h"
#include "Render.h"
//---------------------------------------------------------------------------
#define MAKE_HTHEME(recycle, slot)  (HTHEME)IntToPtr((recycle << 16) | (slot & 0xffff))
//---------------------------------------------------------------------------
CRenderList::CRenderList()
{
    _iNextUniqueId = 0;

    InitializeCriticalSection(&_csListLock);
}
//---------------------------------------------------------------------------
CRenderList::~CRenderList()
{
    for (int i=0; i < _RenderEntries.m_nSize; i++)
    {
        //---- ignore refcount here (end of process) ----
        if (_RenderEntries[i].pRenderObj)
        {
            //Log(LOG_RFBUG, L"DELETED CRenderObj at: 0x%08x", _RenderEntries[i].pRenderObj);
            delete _RenderEntries[i].pRenderObj;
        }
    }

    DeleteCriticalSection(&_csListLock);
}
//---------------------------------------------------------------------------
HRESULT CRenderList::OpenRenderObject(CUxThemeFile *pThemeFile, int iThemeOffset, 
    int iClassNameOffset, CDrawBase *pDrawBase, CTextDraw *pTextObj, HWND hwnd,
    DWORD dwOtdFlags, HTHEME *phTheme)
{
    HRESULT hr = S_OK;
    CAutoCS autoCritSect(&_csListLock);

    CRenderObj *pRender = NULL;
    int iUsedSlot = -1;
    int iNextAvailSlot = -1;

    //---- see if OK to share an existing CRenderObj ----
    BOOL fShare = ((! pDrawBase) && (! pTextObj) && (! LogOptionOn(LO_TMHANDLE)));
    if (fShare)
    {
        if ((dwOtdFlags) && (dwOtdFlags != OTD_NONCLIENT))  // bits other than nonclient are set
            fShare = FALSE;
    }

    //---- loop for sharing and finding first avail entry ----
    for (int i=0; i < _RenderEntries.m_nSize; i++)
    {
        RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[i];
        pRender = pEntry->pRenderObj;

        //---- skip over available entries ----
        if (! pRender)
        {
            if (iNextAvailSlot == -1)       // take first found slot
                iNextAvailSlot = i;

            continue;
        }

        if ((fShare) && (! pEntry->fClosing))
        {
            pRender->ValidateObj();

            int iOffset = int(pRender->_pbSectionData - pRender->_pbThemeData);

            if ((pRender->_pThemeFile == pThemeFile) && (iOffset == iThemeOffset))
            {
                pEntry->iRefCount++;
                iUsedSlot = i;
                Log(LOG_CACHE, L"OpenRenderObject: found match for Offset=%d (slot=%d, refcnt=%d)", 
                    iThemeOffset, i, pEntry->iRefCount);
                break;
            }
        }
    }

    if (iUsedSlot == -1)        // not found
    {
        if (iNextAvailSlot == -1)           // add to end
            iUsedSlot = _RenderEntries.m_nSize ;
        else 
            iUsedSlot = iNextAvailSlot;

        _iNextUniqueId++;

        hr = CreateRenderObj(pThemeFile, iUsedSlot, iThemeOffset, iClassNameOffset, 
            _iNextUniqueId, TRUE, pDrawBase, pTextObj, dwOtdFlags, &pRender);
        if (FAILED(hr))
            goto exit;

        //Log(LOG_RFBUG, L"ALLOCATED CRenderObj at: 0x%08x", pRender);

        //---- extract theme file Load ID ----
        THEMEHDR *th = (THEMEHDR *)pRender->_pbThemeData;
        int iLoadId = 0;
        if (th)
            iLoadId = th->iLoadId;

        RENDER_OBJ_ENTRY entry = {pRender, 1, 1, 0, iLoadId, FALSE, hwnd};

        if (iUsedSlot == _RenderEntries.m_nSize)           // add new entry
        {
            if (! _RenderEntries.Add(entry))
            {
                delete pRender;

                hr = MakeError32(E_OUTOFMEMORY);
                goto exit;
            }

            Log(LOG_CACHE, L"OpenRenderObject: created new obj AT END (slot=%d, refcnt=%d)", 
                pRender->_iCacheSlot, 1);
        }
        else                // use an existing slot
        {
            entry.dwRecycleNum = _RenderEntries[iUsedSlot].dwRecycleNum + 1;

            _RenderEntries[iUsedSlot] = entry;

            Log(LOG_CACHE, L"OpenRenderObject: created new obj SLOT REUSE (slot=%d, refcnt=%d, recycle=%d)", 
                iUsedSlot, 1, _RenderEntries[iUsedSlot].dwRecycleNum);
        }

    }

    if (SUCCEEDED(hr))
    {
        RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iUsedSlot];

        *phTheme = MAKE_HTHEME(pEntry->dwRecycleNum, iUsedSlot);

        //---- for debugging refcount issues ----
        if (LogOptionOn(LO_TMHANDLE))
        {
            WCHAR buff[MAX_PATH];

            if (hwnd)
                GetClassName(hwnd, buff, ARRAYSIZE(buff));
            else
                buff[0] = 0;

            //if (lstrcmpi(pRender->_pszClassName, L"window")==0)
            {
                //Log(LOG_TMHANDLE, L"OTD: cls=%s (%s), hwnd=0x%x, htheme=0x%x, new refcnt=%d", 
                //    pRender->_pszClassName, buff, hwnd, *phTheme, pEntry->iRefCount);
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CRenderList::DeleteCheck(RENDER_OBJ_ENTRY *pEntry)
{
    BOOL fClosed = FALSE;

    if ((! pEntry->iRefCount) && (! pEntry->iInUseCount))
    {
        //Log(LOG_RFBUG, L"DELETED CRenderObj at: 0x%08x", pEntry->pRenderObj);
        delete pEntry->pRenderObj;

        //---- important: don't use RemoveAt() or entries will shift and ----
        //---- our "SlotNumber" model between RenderList & CacheList will ----
        //---- be broken ----

        pEntry->pRenderObj = NULL;
        pEntry->fClosing = FALSE;

        fClosed = TRUE;
    }

    return fClosed;
}
//---------------------------------------------------------------------------
HRESULT CRenderList::CloseRenderObject(HTHEME hTheme)
{
    CAutoCS autoCritSect(&_csListLock);
    HRESULT hr = S_OK;

    int iSlotNum = (DWORD(PtrToInt(hTheme)) & 0xffff);
    DWORD dwRecycleNum = (DWORD(PtrToInt(hTheme)) >> 16);

    if (iSlotNum >= _RenderEntries.m_nSize)
    {
        Log(LOG_BADHTHEME, L"Illegal Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iSlotNum];
    if ((! pEntry->pRenderObj) || (pEntry->fClosing) || (pEntry->dwRecycleNum != dwRecycleNum))
    {
        Log(LOG_BADHTHEME, L"Expired Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    //---- allow for our iRefCount to have been set to zero explicitly ----
    if (pEntry->iRefCount > 0)
        pEntry->iRefCount--;

#if 0
    //---- for debugging refcount issues ----
    if (LogOptionOn(LO_TMHANDLE))
    {
        CRenderObj *pRender = pEntry->pRenderObj;

        Log(LOG_TMHANDLE, L"CTD: cls=%s, hwnd=0x%x, htheme=0x%x, new refcnt=%d", 
            pRender->_pszClassName, pEntry->hwnd, hTheme, pEntry->iRefCount);
    }
#endif

    DeleteCheck(pEntry);
    
exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderList::OpenThemeHandle(HTHEME hTheme, CRenderObj **ppRenderObj, int *piSlotNum)
{
    CAutoCS autoCritSect(&_csListLock);
    HRESULT hr = S_OK;

    int iSlotNum = (int)(DWORD(PtrToInt(hTheme)) & 0xffff);
    DWORD dwRecycleNum = (DWORD(PtrToInt(hTheme)) >> 16);

    if (iSlotNum >= _RenderEntries.m_nSize)
    {
        Log(LOG_BADHTHEME, L"Illegal Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iSlotNum];
    if ((! pEntry->pRenderObj) || (pEntry->fClosing) || (pEntry->dwRecycleNum != dwRecycleNum))
    {
        Log(LOG_BADHTHEME, L"Expired Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    if (pEntry->iInUseCount > 25)
    {
        Log(LOG_BADHTHEME, L"Warning BREAK: high ThemeHandle inuse count=%d", pEntry->iInUseCount);
    }

    pEntry->iInUseCount++;

    *ppRenderObj = pEntry->pRenderObj;
    *piSlotNum = iSlotNum;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CRenderList::CloseThemeHandle(int iSlotNum)
{
    CAutoCS autoCritSect(&_csListLock);
    RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iSlotNum];

    if (pEntry->iInUseCount <= 0)
    {
        Log(LOG_ERROR, L"Bad iUseCount on CRenderObj at slot=%d", iSlotNum);
    }
    else
    {
        pEntry->iInUseCount--;
        DeleteCheck(pEntry);
    }
}
//---------------------------------------------------------------------------
void CRenderList::FreeRenderObjects(int iThemeFileLoadId)
{
    CAutoCS autoCritSect(&_csListLock);

    int iFoundCount = 0;
    int iClosedCount = 0;

    //---- theme hooking has been turned off - mark all ----
    //---- our objects so they can be freed as soon ----
    //---- as all wrapper API's are exited so that ----
    //---- we don't hold open those big theme files in memory ----

    for (int i=0; i < _RenderEntries.m_nSize; i++)
    {
        RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[i];

        if (pEntry->pRenderObj)
        {
            if ((iThemeFileLoadId == -1) || (iThemeFileLoadId == pEntry->iLoadId))
            {
                iFoundCount++;

                HTHEME hTheme = MAKE_HTHEME(pEntry->dwRecycleNum, i);

                Log(LOG_BADHTHEME, L"Unclosed RenderList[]: class=%s, hwnd=0x%x, htheme=0x%x, refcnt=%d", 
                    pEntry->pRenderObj->_pszClassName, pEntry->hwnd, hTheme, pEntry->iRefCount);

                pEntry->fClosing = TRUE;        // don't grant further access to this obj
                pEntry->iRefCount = 0;          // free it as soon as callers have exited

                if (DeleteCheck(pEntry))        // delete now or mark for "delete on API exit"
                {
                    //---- just deleted it ----
                    iClosedCount++;
                }
            }
        }
    }

    Log(LOG_TMHANDLE, L"FreeRenderObjects: iLoadId=%d, found-open=%d, closed-now=%d", 
        iThemeFileLoadId, iFoundCount, iClosedCount);
}
//---------------------------------------------------------------------------
#ifdef DEBUG
void CRenderList::DumpFileHolders()
{
    CAutoCS autoCritSect(&_csListLock);
 
    if (LogOptionOn(LO_TMHANDLE))
    {
        //---- find number of CRenderObj's ----
        int iCount = 0;
        _RenderEntries.m_nSize;

        for (int i=0; i < _RenderEntries.m_nSize; i++)
        {
            if (_RenderEntries[i].pRenderObj)
                iCount++;
        }

        if (! iCount)
        {
            Log(LOG_TMHANDLE, L"---- No CRenderObj objects ----");
        }
        else
        {
            Log(LOG_TMHANDLE, L"---- Dump of %d CRenderObj objects ----", iCount);

            for (int i=0; i < _RenderEntries.m_nSize; i++)
            {
                RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[i];

                if (pEntry->pRenderObj)
                {
                    CRenderObj *pr = pEntry->pRenderObj;
                    THEMEHDR *th = (THEMEHDR *)pr->_pbThemeData;
                    int iLoadId = 0;

                    if (th)
                        iLoadId = th->iLoadId;

                    LPCWSTR pszClass = NULL;

                    if (pr->_pszClassName)
                        pszClass = pr->_pszClassName;

                    Log(LOG_TMHANDLE, L"  RenderObj[%d]: class=%s, refcnt=%d, hwnd=0x%x", 
                        i, pszClass, pEntry->iRefCount, pEntry->hwnd);

                }
            }
        }
    }
}
#endif
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\paramchecks.h ===
//---------------------------------------------------------------------------
//  ParamChecks.h
//---------------------------------------------------------------------------
//  these param checkers are needed for both RETAIL and DEBUG
//---------------------------------------------------------------------------
//  CThemeApiHelper class:
//    - automatically logs entry/exit to function
//    - automatically does a "CloseHandle" on pRenderObj at exit
//    - holds _pszFuncName for use by param validating macros
//---------------------------------------------------------------------------
class CThemeApiHelper
{
public:
    inline CThemeApiHelper(LPCWSTR pszFuncName, HTHEME hTheme)
    {
        _iRenderSlotNum = -1;           // not yet set
        _pszFuncName = pszFuncName;

        if (! hTheme)
        {
            LogEntryW(_pszFuncName);
        }
    }

    inline ~CThemeApiHelper()
    {
        CloseHandle();

        LogExit(_pszFuncName);
    }

    inline HRESULT OpenHandle(HTHEME hTheme, CRenderObj **ppRenderObj)
    {
        CloseHandle();

        HRESULT hr = g_pRenderList->OpenThemeHandle(hTheme, 
            ppRenderObj, &_iRenderSlotNum);
        if (SUCCEEDED(hr))
        {
            LogEntryCW(_pszFuncName, CLASSPTR(*ppRenderObj));
        }
        else
        {
            Log(LOG_PARAMS, L"Bad HTHEME param in call to %s", _pszFuncName);
        }

        return hr;
    }

    inline void CloseHandle()
    {
        if (_iRenderSlotNum > -1)
        {
            g_pRenderList->CloseThemeHandle(_iRenderSlotNum);
            _iRenderSlotNum = -1;
        }
    }

public:
    LPCWSTR _pszFuncName;

private:
    int _iRenderSlotNum;
    int _iEntryValue;                // for log resource leak checking
};
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
#ifdef DEBUG
#define APIHELPER(Name, hTheme) CThemeApiHelper ApiHelper(Name, hTheme)
#else
#define APIHELPER(Name, hTheme) CThemeApiHelper ApiHelper(NULL, hTheme)
#endif
//---------------------------------------------------------------------------
#define VALIDATE_THEME_HANDLE(helper, hTheme, ppRenderObj)   \
{    \
    HRESULT hr = helper.OpenHandle(hTheme, ppRenderObj);  \
    RETURN_VALIDATE_RETVAL(hr);   \
} 
//---------------------------------------------------------------------------
#define VALIDATE_READ_PTR(helper, p, iSize)     \
{      \
    if (IsBadReadPtr(p, iSize))  \
    {     \
        Log(LOG_PARAMS, L"Bad output PTR param in call to %s", helper._pszFuncName);  \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }    \
}
//---------------------------------------------------------------------------
#define VALIDATE_WRITE_PTR(helper, p, iSize)        \
{         \
    if (IsBadWritePtr(p, iSize))  \
    {     \
        Log(LOG_PARAMS, L"Bad output PTR param in call to %s", helper._pszFuncName);  \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }    \
}
//---------------------------------------------------------------------------
#define VALIDATE_INPUT_STRING(helper, psz)       \
{       \
    if (IsBadStringPtr(psz, (UINT_PTR)-1))    \
    {      \
        Log(LOG_PARAMS, L"Bad input STRING param in call to: %s", helper._pszFuncName);   \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }    \
}
//---------------------------------------------------------------------------
#define VALIDATE_HDC(helper, hdc)       \
{     \
    if (! hdc)  \
    {    \
        Log(LOG_PARAMS, L"Bad HDC param in call to %s", helper._pszFuncName );    \
        RETURN_VALIDATE_RETVAL(E_HANDLE);    \
    }   \
}
//---------------------------------------------------------------------------
#define VALIDATE_HANDLE(helper, h)       \
{        \
    if (! h)  \
    {    \
        Log(LOG_PARAMS, L"Bad HANDLE param in call to %s", helper._pszFuncName);    \
        RETURN_VALIDATE_RETVAL(E_HANDLE);    \
    }   \
}
//---------------------------------------------------------------------------
#define VALIDATE_HWND(helper, hwnd)       \
{      \
    if (! IsWindow(hwnd))     \
    {     \
        Log(LOG_PARAMS, L"Bad HWND handle param in call to: %s", helper._pszFuncName);   \
        RETURN_VALIDATE_RETVAL(E_HANDLE);    \
    }        \
}
//---------------------------------------------------------------------------
#define VALIDATE_CALLBACK(helper, pfn)       \
{     \
    if (IsBadCodePtr((FARPROC)pfn))  \
    {    \
        Log(LOG_PARAMS, L"Bad CALLBACK param in call to %s", helper._pszFuncName);    \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }   \
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\ntleng.cpp ===
//-------------------------------------------------------------------------
//	NtlEng.cpp - support for Native Theme Language runtime graphics engine
//-------------------------------------------------------------------------
#include "stdafx.h"
#include "ntleng.h"
//---------------------------------------------------------------------------
#define COLORNULL 0xff000000
//---------------------------------------------------------------------------
POINT TranslateLogPoint(POINT &pt, RECT &rcLogRect, RECT &rcCaller)
{
    POINT ptNew;

    ptNew.x = rcCaller.left + (WIDTH(rcCaller) * (pt.x - rcLogRect.left))/WIDTH(rcLogRect);
    ptNew.y = rcCaller.top + (HEIGHT(rcCaller) * (pt.y - rcLogRect.top))/HEIGHT(rcLogRect);
    
    return ptNew;
}
//---------------------------------------------------------------------------
int TranslateLogSize(int iSize, RECT &rcLogRect, RECT &rcCaller)
{
    //---- "iSize" is somewhere between width & height ----
    int iWidthSize = (WIDTH(rcCaller) * iSize)/WIDTH(rcLogRect);
    int iHeightSize = (HEIGHT(rcCaller) * iSize)/HEIGHT(rcLogRect);

    return min(iWidthSize, iHeightSize);
}
//---------------------------------------------------------------------------
COLORREF GetParamColor(MIXEDPTRS &u)
{
    COLORREF crVal = 0;

    if (*u.pb == PT_COLORREF)
        crVal = *u.pi++;
    else if (*u.pb == PT_SYSCOLORINDEX)
        crVal = GetSysColor(*u.ps++);
    else if (*u.pb == PT_COLORNULL)
        crVal = COLORNULL;
    else
    {
        Log(LOG_ERROR, L"Bad color param value in NTL stream: 0x%0x", *u.pb);
    }
    
    return crVal;
}
//---------------------------------------------------------------------------
int GetParamInt(MIXEDPTRS &u)
{
    int iVal;

    if (*u.pb == PT_INT)
        iVal = *u.pi++;
    else
        iVal = ClassicGetSystemMetrics(*u.ps++);
    
    return iVal;
}
//---------------------------------------------------------------------------
POINT GetParamPoint(MIXEDPTRS &u, RECT &rcCaller, RECT &rcLogRect)
{
    POINT pt = *u.ppt++;
    pt = TranslateLogPoint(pt, rcCaller, rcLogRect);

    return pt;
}
//---------------------------------------------------------------------------
void SetPen(HDC hdc, HPEN &hPen, COLORREF crLine, int iLineWidth)
{
    DeleteObject(hPen);

    if (crLine == COLORNULL)
        hPen = (HPEN)GetStockObject(NULL_PEN);
    else
        hPen = CreatePen(PS_SOLID, iLineWidth, crLine);

    SelectObject(hdc, hPen);
}
//---------------------------------------------------------------------------
HRESULT GetImageBrush(HDC hdc, int iPartId, int iStateId, int iIndex, 
    INtlEngCallBack *pCallBack, HBRUSH *phbr)
{
    HRESULT hr;

    if (! pCallBack)
    {
        Log(LOG_ERROR, L"No callback for NtlRun specified");
        hr = MakeError32(ERROR_INTERNAL_ERROR); 
    }
    else
        hr = pCallBack->CreateImageBrush(hdc, iPartId, iStateId, iIndex, phbr);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT GetFillBrush(HDC hdc, MIXEDPTRS &u, int iPartId, int iStateId, 
      INtlEngCallBack *pCallBack, HBRUSH *phbr)
{
    HBRUSH hbr = NULL;
    BYTE bIndex;
    HRESULT hr = S_OK;

    switch (*u.pb)
    {
        case PT_IMAGEFILE:
            bIndex = *u.pb++;
            hr = GetImageBrush(hdc, iPartId, iStateId, bIndex, pCallBack, &hbr);
            break;

        default:
            COLORREF crVal = GetParamColor(u);
            if (crVal == COLORNULL)
                hbr = (HBRUSH)GetStockObject(NULL_BRUSH);
            else
                hbr = CreateSolidBrush(crVal);
            break;
    }

    if (SUCCEEDED(hr))
        *phbr = hbr;

    return hr;
}
//---------------------------------------------------------------------------
void DrawRect(HDC hdc, MIXEDPTRS &u, RECT &rcCaller)
{
    int iVals[4];
    COLORREF crVals[4];

    //---- get int params ----
    for (int i=0; i < 4; i++)
    {
        if ((*u.pb != PT_INT) && (*u.pb != PT_SYSMETRICINDEX))
            break;
        iVals[i] = GetParamInt(u);
    }

    int cInts = i;

    //---- get color param s----
    for (i=0; i < 4; i++)
    {
        if ((*u.pb != PT_COLORREF) && (*u.pb != PT_COLORNULL)
            && (*u.pb != PT_SYSCOLORINDEX))
            break;
        crVals[i] = GetParamColor(u);
    }

    int cColors = i;

    if ((cInts == 1) && (cColors == 1))        // single size/color for all 4 sides
    {
        if (crVals[0] != COLORNULL)
        {
            HPEN hpen = CreatePen(PS_SOLID | PS_INSIDEFRAME, iVals[0], crVals[0]);
            HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);

            HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

            Rectangle(hdc, rcCaller.left, rcCaller.top, rcCaller.right, rcCaller.bottom);

            SelectObject(hdc, hpenOld);
            SelectObject(hdc, hbrOld);

            DeleteObject(hpen);
        }

        InflateRect(&rcCaller, -iVals[0], -iVals[0]);
    }
    else                // need to draw each side one at a time
    {
        //---- expand int's into 4 values ----
        if (cInts == 1)
        {
            iVals[1] = iVals[2] = iVals[3] = iVals[0];
        }
        else if (cInts == 2)
        {
            iVals[2] = iVals[0];
            iVals[3] = iVals[1];
        }

        //---- expand colors's into 4 values ----
        if (cColors == 1)
        {
            crVals[1] = crVals[2] = crVals[3] = crVals[0];
        }
        else if (cColors == 2)
        {
            crVals[2] = crVals[0];
            crVals[3] = crVals[1];
        }

        HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));
        HBRUSH hbr = NULL;

        //---- left ----
        if ((crVals[0] != COLORNULL) && (iVals[0]))
        {
            hbr = CreateSolidBrush(crVals[0]);
            SelectObject(hdc, hbr);

            PatBlt(hdc, rcCaller.left, rcCaller.top, iVals[0], HEIGHT(rcCaller), PATCOPY);
        }
        rcCaller.left += iVals[0];

        //---- top ----
        if ((crVals[1] != COLORNULL) && (iVals[1]))    
        {
            if (crVals[1] != crVals[0])     // need new brush
            {
                hbr = CreateSolidBrush(crVals[1]);
                SelectObject(hdc, hbr);
            }

            PatBlt(hdc, rcCaller.left, rcCaller.top, WIDTH(rcCaller), iVals[0], PATCOPY);
        }
        rcCaller.top += iVals[1];

        //---- right ----
        if ((crVals[2] != COLORNULL) && (iVals[2]))    
        {
            if (crVals[2] != crVals[1])     // need new brush
            {
                hbr = CreateSolidBrush(crVals[2]);
                SelectObject(hdc, hbr);
            }

            PatBlt(hdc, rcCaller.right - iVals[0], rcCaller.top, iVals[0], HEIGHT(rcCaller), PATCOPY);
        }
        rcCaller.right -= iVals[2];

        //---- bottom ----
        if ((crVals[3] != COLORNULL) && (iVals[3]))    
        {
            if (crVals[3] != crVals[2])     // need new brush
            {
                hbr = CreateSolidBrush(crVals[3]);
                SelectObject(hdc, hbr);
            }

            PatBlt(hdc, rcCaller.left, rcCaller.bottom - iVals[0], WIDTH(rcCaller), iVals[0], PATCOPY);
        }
        rcCaller.bottom -= iVals[3];

        SelectObject(hdc, hbrOld);
        DeleteObject(hbr);
    }
}
//---------------------------------------------------------------------------
HRESULT RunNtl(HDC hdc, RECT &rcCaller, HBRUSH hbrBkDefault, DWORD dwOptions, 
     int iPartId, int iStateId, BYTE *pbCode, int iCodeLen, INtlEngCallBack *pCallBack)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;
    u.pb = pbCode;
    RECT rcLogRect = {0, 0, 1000, 1000};

    RESOURCE HPEN hPen = (HPEN)GetStockObject(BLACK_PEN);
    RESOURCE HBRUSH hBrush = (HBRUSH)GetStockObject(GRAY_BRUSH);
    BOOL fDeleteBrush = FALSE;

    if (hbrBkDefault)
        hBrush = hbrBkDefault;

    RESOURCE HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hBrush);
    RESOURCE HPEN hpenOld = (HPEN)SelectObject(hdc, hPen);

    while (*u.pb != NTL_RETURN)
    {
        switch (*u.pb)
        {
            case NTL_STATEJUMPTABLE:
            {
                BYTE bStateCount = *u.pb++;
                if ((iStateId < 1) || (iStateId > bStateCount))
                    iStateId = 1;
                u.pb = pbCode + u.pi[iStateId-1];
            }
            break;

            case NTL_JMPON:
            {
                BYTE bBitNum = *u.pb++;
                int iOffset = *u.pi++;
                if (dwOptions & (1 << bBitNum))
                    u.pb = pbCode + iOffset;
            }
            break;

            case NTL_JMPOFF:
            {
                BYTE bBitNum = *u.pb++;
                int iOffset = *u.pi++;
                if (! (dwOptions & (1 << bBitNum)))
                    u.pb = pbCode + iOffset;
            }
            break;

            case NTL_JMP:
            {
                int iOffset = *u.pi++;
                u.pb = pbCode + iOffset;
            }
            break;

            case NTL_LOGRECT:
                rcLogRect = *u.prc++;
                break;

            case NTL_LINEBRUSH:
            {
                COLORREF crLine = GetParamColor(u);
                int iLineWidth = GetParamInt(u);
                BOOL fLogWidth = *u.pb++;
                if (fLogWidth)
                    iLineWidth = TranslateLogSize(iLineWidth, rcCaller, rcLogRect);
                SetPen(hdc, hPen, crLine, iLineWidth);
            }
            break;

            case NTL_FILLBRUSH:
            {
                HBRUSH hbr;
                
                hr = GetFillBrush(hdc, u, iPartId, iStateId, pCallBack, &hbr);
                if (FAILED(hr))
                    goto exit;

                SelectObject(hdc, hbr);
                if (fDeleteBrush)
                    DeleteObject(hBrush);
                hBrush = hbr;
                fDeleteBrush = TRUE;
            }
            break;

            case NTL_MOVETO:
            {
                POINT pt = GetParamPoint(u, rcCaller, rcLogRect);
                MoveToEx(hdc, pt.x, pt.y, NULL);
            }
            break;
            
            case NTL_LINETO:
            {
                POINT pt = GetParamPoint(u, rcCaller, rcLogRect);
                LineTo(hdc, pt.x, pt.y);
            }
            break;

            case NTL_CURVETO:
            {
                POINT pts[3];
                pts[0] = GetParamPoint(u, rcCaller, rcLogRect);
                pts[1] = GetParamPoint(u, rcCaller, rcLogRect);
                pts[2] = GetParamPoint(u, rcCaller, rcLogRect);
                PolyBezierTo(hdc, pts, 3);
            }
            break;

            case NTL_SHAPE:
            {
                POINT pt = GetParamPoint(u, rcCaller, rcLogRect);
                BeginPath(hdc);
                MoveToEx(hdc, pt.x, pt.y, NULL);
            }
            break;

            case NTL_ENDSHAPE:
            {
                EndPath(hdc);
                StrokeAndFillPath(hdc);
            }
            break;

            case NTL_DRAWRECT:
            {
                DrawRect(hdc, u, rcCaller);
            }
            break;

            case NTL_FILLRECT:
            {
                HBRUSH hbr;
                
                hr = GetFillBrush(hdc, u, iPartId, iStateId, pCallBack, &hbr);
                if (FAILED(hr))
                    goto exit;

                FillRect(hdc, &rcCaller, hbr);
                DeleteObject(hbr);
            }
            break;
        }
    }

exit:
    SelectObject(hdc, hbrOld);
    SelectObject(hdc, hpenOld);

    DeleteObject(hPen);

    if (fDeleteBrush)
        DeleteObject(hBrush);

    return S_OK;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\render.cpp ===
//---------------------------------------------------------------------------
//  Render.cpp - implements the themed drawing services 
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "Parser.h"
#include "Loader.h"
#include "tmutils.h"
#include "gradient.h"
#include "rgn.h"
#include "info.h"
#include "cache.h"
#include "cachelist.h"
#include "borderfill.h"
#include "imagefile.h"

#ifdef DEBUG
    static DWORD s_dwSize = 0;
#endif

//---------------------------------------------------------------------------
HRESULT CreateRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, 
    int iClassNameOffset, __int64 iUniqueId, BOOL fEnableCache, CDrawBase *pBaseObj,
    CTextDraw *pTextObj, DWORD dwOtdFlags, CRenderObj **ppObj)
{
    HRESULT hr = S_OK;

    CRenderObj *pRender = new CRenderObj(pThemeFile, iCacheSlot, iThemeOffset, 
        iClassNameOffset, iUniqueId, fEnableCache, dwOtdFlags);
    
    if (! pRender)
    {
        hr = MakeError32(E_OUTOFMEMORY);
    }
    else
    {
        hr = pRender->Init(pBaseObj, pTextObj);

        if (FAILED(hr))
            delete pRender;
        else
            *ppObj = pRender;
    }

    return hr;
}
//---------------------------------------------------------------------------
CRenderObj::CRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, 
    int iClassNameOffset, __int64 iUniqueId, BOOL fEnableCache, DWORD dwOtdFlags)
{
    strcpy(_szHead, "rendobj"); 
    strcpy(_szTail, "end");
    
    _fCacheEnabled = fEnableCache;
    _fCloseThemeFile = FALSE;
    _dwOtdFlags = dwOtdFlags;

    if (pThemeFile)
    {
        if (SUCCEEDED(BumpThemeFileRefCount(pThemeFile)))
            _fCloseThemeFile = TRUE;
    }
    
    _pThemeFile = pThemeFile;
    _iCacheSlot = iCacheSlot;
    _iUniqueId = iUniqueId;

    if (pThemeFile)
    {
        _pbThemeData = pThemeFile->_pbThemeData;
        _pbSectionData = _pbThemeData + iThemeOffset;
        _ptm = GetThemeMetricsPtr(pThemeFile);
    }
    else
    {
        _pbThemeData = NULL;
        _pbSectionData = NULL;
        _ptm = NULL;
    }

    _pszClassName = ThemeString(pThemeFile, iClassNameOffset);

    _iMaxPart = 0;
    _pParts = NULL;

    _iDpiOverride = 0;

    //---- caller must call "Init()" after ctr! ----
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::PrepareAlphaBitmap(HBITMAP hBitmap)
{
    HRESULT hr = S_OK;

    //---- convert to DIBDATA ----
    CBitmapPixels pixels;
    DWORD *pPixelQuads;
    int iWidth, iHeight, iBytesPerPixel, iBytesPerRow;

    hr = pixels.OpenBitmap(NULL, hBitmap, TRUE, &pPixelQuads, &iWidth, &iHeight, 
        &iBytesPerPixel, &iBytesPerRow);
    if (FAILED(hr))
        goto exit;
    
    PreMultiplyAlpha(pPixelQuads, iWidth, iHeight);

    pixels.CloseBitmap(NULL, hBitmap);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::Init(CDrawBase *pBaseObj, CTextDraw *pTextObj)
{
    HRESULT hr = S_OK;

    if (_fCacheEnabled)
    {
        hr = BuildPackedPtrs(pBaseObj, pTextObj);
        if (FAILED(hr))
            goto exit;
    }

    //---- prepare direct objects ----
    if ((pBaseObj) && (pBaseObj->_eBgType == BT_IMAGEFILE))
    {
        CMaxImageFile *pMaxIf = (CMaxImageFile *)pBaseObj;

        //---- process primary image ----
        DIBINFO *pdi = &pMaxIf->_ImageInfo;

        if (pdi->fAlphaChannel)
        {
            hr = PrepareAlphaBitmap(pdi->hProcessBitmap);
            if (FAILED(hr))
                goto exit;
        }

        //---- process glyph image ----
        pdi = &pMaxIf->_GlyphInfo;

        if (pdi->fAlphaChannel)
        {
            hr = PrepareAlphaBitmap(pdi->hProcessBitmap);
            if (FAILED(hr))
                goto exit;
        }

        //---- process multiple images ----
        for (int i=0; i < pMaxIf->_iMultiImageCount; i++)
        {
            pdi = pMaxIf->MultiDibPtr(i);

            if (pdi->fAlphaChannel)
            {
                hr = PrepareAlphaBitmap(pdi->hProcessBitmap);
                if (FAILED(hr))
                    goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
CRenderObj::~CRenderObj()
{
    //---- delete memory allocated for pack objects looked ----
    if (_pParts)
    {
        for(int i=0; i<_iMaxPart+1; i++)
        {
            if (_pParts[i].pStateDrawObjs)
                delete[] _pParts[i].pStateDrawObjs;

            if (_pParts[i].pStateTextObjs)
                delete[] _pParts[i].pStateTextObjs;
        }
        delete[] _pParts;
    }

    //---- if we opened a refcount on a themefile, close it now ----
    if (_fCloseThemeFile)
        CloseThemeFile(_pThemeFile);

    //---- mark this object as "deleted" (for debugging) ----
    strcpy(_szHead, "deleted"); 
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::SetDpiOverride(int iDpiOverride)
{
    _iDpiOverride = iDpiOverride;

    return S_OK;
}
//---------------------------------------------------------------------------
int CRenderObj::GetDpiOverride()
{
    return _iDpiOverride;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::BuildPackedPtrs(CDrawBase *pBaseObj, CTextDraw *pTextObj)
{
    MIXEDPTRS u;
    HRESULT hr = S_OK;
    int iPackedOffset = 0;
    int *iPartOffsets = NULL;
    BOOL fSingleObj = FALSE;

    //---- extract _iMaxPart ----
    if ((pBaseObj) || (pTextObj))       // single object to be used for all parts/states
    {
        _iMaxPart = 1;          // dummy value
        fSingleObj = TRUE;
    }
    else
    {
        u.pb = _pbSectionData;
        if (*u.ps != TMT_PARTJUMPTABLE)
        {
            hr = MakeError32(E_FAIL);       // something went amiss
            goto exit;
        }

        u.pb += ENTRYHDR_SIZE;
        iPackedOffset = *u.pi++;
        
        _iMaxPart = *u.pb - 1;
        
        u.pb++;
        iPartOffsets = u.pi;
    }

    //---- allocate _pParts ----
    _pParts = new PARTINFO[_iMaxPart+1];
    if (! _pParts)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    memset(_pParts, 0, sizeof(PARTINFO)*(_iMaxPart+1));

    if (fSingleObj)
    {
        for (int i=0; i <= _iMaxPart; i++)
            _pParts[i].iMaxState = 1;           // dummy value

        if (pBaseObj)       // single draw object to be used for all parts/states
        {
            for (int i=0; i <= _iMaxPart; i++)
            {
                _pParts[i].pDrawObj = pBaseObj;
            }
        }

        if (pTextObj)       // single text object t to be used for all parts/states
        {
            for (int i=0; i <= _iMaxPart; i++)
            {
                _pParts[i].pTextObj = pTextObj;
            }
        }
    }
    else
    {
        u.pb = _pbThemeData + iPackedOffset;

        hr = WalkDrawObjects(u, iPartOffsets);
        if (FAILED(hr))
            goto exit;

        hr = WalkTextObjects(u, iPartOffsets);
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::WalkDrawObjects(MIXEDPTRS &u, int *iPartOffsets)
{
    int iPartId;
    int iStateId;
    HRESULT hr = S_OK;
    THEMEHDR *pHdr = (THEMEHDR *)_pbThemeData;
    UNPACKED_ENTRYHDR hdr;

    //---- get ptr to global text obj ----
	BYTE *pb = _pbThemeData + pHdr->iGlobalsDrawObjOffset;
	pb += ENTRYHDR_SIZE + sizeof(DRAWOBJHDR);
    CDrawBase *pGlobalObj = (CDrawBase *)pb;

    //---- start with all parts inheriting from [globals] ----
    for (int i=0; i <= _iMaxPart; i++)
        _pParts[i].pDrawObj = pGlobalObj;

    //---- now, process all specified objects ----
    while (1)
    {
        if ((*u.ps == TMT_RGNLIST) || (*u.ps == TMT_STOCKBRUSHES))
        {
            //---- skip over this entry ----
            FillAndSkipHdr(u, &hdr);
            u.pb += hdr.dwDataLen;
            continue;
        }

        if (*u.ps != TMT_DRAWOBJ)
            break;

        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        CDrawBase *pCurrentObj = (CDrawBase *)(u.pb + sizeof(DRAWOBJHDR));
        u.pb += hdr.dwDataLen;

        iPartId = ph->iPartNum;
        iStateId = ph->iStateNum;

        if ((! iPartId) && (! iStateId))
        {
            //---- all parts inherit from this obj ----
            for (int i=0; i <= _iMaxPart; i++)
                _pParts[i].pDrawObj = pCurrentObj;
            continue;
        }

        PARTINFO *ppi = &_pParts[iPartId];
        if (! iStateId)
        {
            ppi->pDrawObj = pCurrentObj;
        }
        else
        {
            if (! ppi->iMaxState)       // extract MaxState
            {
                MIXEDPTRS u2;
                u2.pb = _pbThemeData + iPartOffsets[iPartId];
                if (*u2.ps != TMT_STATEJUMPTABLE)
                {
                    hr = MakeError32(E_FAIL);       // something went amiss
                    goto exit;
                }
                u2.pb += ENTRYHDR_SIZE;
                ppi->iMaxState = *u2.pb - 1;
            }

            if (! ppi->pStateDrawObjs)      // allocate now
            {
                ppi->pStateDrawObjs = new CDrawBase *[ppi->iMaxState];
                if (! ppi->pStateDrawObjs)
                {
                    hr = MakeError32(E_OUTOFMEMORY);
                    goto exit;
                }

                //---- fill in default objs as state 0 ----
                for (int i=0; i < ppi->iMaxState; i++)
                    ppi->pStateDrawObjs[i] = ppi->pDrawObj;
            }

            ppi->pStateDrawObjs[iStateId-1] = pCurrentObj;
        }
            
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::WalkTextObjects(MIXEDPTRS &u, int *iPartOffsets)
{
    int iPartId;
    int iStateId;
    HRESULT hr = S_OK;
    THEMEHDR *pHdr = (THEMEHDR *)_pbThemeData;
    UNPACKED_ENTRYHDR hdr;

    //---- get ptr to global text obj ----
	BYTE *pb = _pbThemeData + pHdr->iGlobalsTextObjOffset;
	pb += ENTRYHDR_SIZE + sizeof(DRAWOBJHDR);
    CTextDraw *pGlobalObj = (CTextDraw *)pb;

    //---- start with all parts inheriting from [globals] ----
    for (int i=0; i <= _iMaxPart; i++)
        _pParts[i].pTextObj = pGlobalObj;

    while (*u.ps == TMT_TEXTOBJ)        
    {
        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        CTextDraw *pCurrentObj = (CTextDraw *)(u.pb + sizeof(DRAWOBJHDR));
        u.pb += hdr.dwDataLen;

        iPartId = ph->iPartNum;
        iStateId = ph->iStateNum;

        if ((! iPartId) && (! iStateId))
        {
            //---- all parts inherit from this obj ----
            for (int i=0; i <= _iMaxPart; i++)
                _pParts[i].pTextObj = pCurrentObj;
            continue;
        }

        PARTINFO *ppi = &_pParts[iPartId];
        if (! iStateId)
        {
            ppi->pTextObj = pCurrentObj;
        }
        else
        {
            if (! ppi->iMaxState)       // extract MaxState
            {
                MIXEDPTRS u2;
                u2.pb = _pbThemeData + iPartOffsets[iPartId];
                if (*u2.ps != TMT_STATEJUMPTABLE)
                {
                    hr = MakeError32(E_FAIL);       // something went amiss
                    goto exit;
                }
                u2.pb += ENTRYHDR_SIZE;
                ppi->iMaxState = *u2.pb - 1;
            }

            if (! ppi->pStateTextObjs)      // allocate now
            {
                ppi->pStateTextObjs = new CTextDraw *[ppi->iMaxState];
                if (! ppi->pStateTextObjs)
                {
                    hr = MakeError32(E_OUTOFMEMORY);
                    goto exit;
                }

                //---- fill in default objs as state 0 ----
                for (int i=0; i < ppi->iMaxState; i++)
                    ppi->pStateTextObjs[i] = ppi->pTextObj;
            }

            ppi->pStateTextObjs[iStateId-1] = pCurrentObj;
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetBitmap(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap)
{
    HRESULT hr = S_OK;
    HBITMAP hBitmap;

    if ((! iDibOffset) || (! _pbThemeData))
    {
        hr = E_FAIL;
        goto exit;
    }

    TMBITMAPHEADER *pThemeBitmapHeader;

    pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(_pbThemeData + iDibOffset);
    ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);

    *phBitmap = pThemeBitmapHeader->hBitmap;
    if (*phBitmap != NULL)
    {
        //Log(LOG_TMBITMAP, L"Used stock bitmap:%8X", *phBitmap);
        return hr;
    }

    hr = CreateBitmapFromData(hdc, iDibOffset + TMBITMAPSIZE, &hBitmap);
    if (FAILED(hr))
        goto exit;

    Log(LOG_TM, L"GetBitmap - CACHE MISS: class=%s, diboffset=%d, bitmap=0x%x", 
        SHARECLASS(this), iDibOffset, hBitmap);

#if 0
    if (lstrcmpi(SHARECLASS(this), L"progress")==0)
    {
        //---- validate the bitmap ----
        int iBytes = GetObject(hBitmap, 0, NULL);

        Log(LOG_RFBUG, L"progress: CREATE bitmap, diboff=%d, hbitmap=0x%x, iBytes=%d",
            iDibOffset, hBitmap, iBytes);
    }
#endif

    *phBitmap = hBitmap;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CRenderObj::ReturnBitmap(HBITMAP hBitmap)
{
    DeleteObject(hBitmap);
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::CreateBitmapFromData(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap)
{
    BYTE *pDibData;
    RESOURCE HDC hdcTemp = NULL;
    RESOURCE HBITMAP hBitmap = NULL;
    HRESULT hr = S_OK;

    if ((! iDibOffset) || (! _pbThemeData))
    {
        hr = E_FAIL;
        goto exit;
    }

    pDibData = (BYTE *)(_pbThemeData + iDibOffset);
    BITMAPINFOHEADER *pBitmapHdr;
    pBitmapHdr = (BITMAPINFOHEADER *)pDibData;

    BOOL fAlphaChannel;
    fAlphaChannel = (pBitmapHdr->biBitCount == 32);

    if (! hdc)
    {
        hdcTemp = GetWindowDC(NULL);
        if (! hdcTemp)
        {
            Log(LOG_ALWAYS, L"GetWindowDC() failed in CreateBitmapFromData");
            hr = MakeErrorLast();
            goto exit;
        }

        hdc = hdcTemp;
    }

    //---- create the actual bitmap ----
    //---- if using alpha channel, we must use a DIB ----
    if (fAlphaChannel)
    {
        void *pv;
        hBitmap = CreateDIBSection(hdc, (BITMAPINFO *)pBitmapHdr, DIB_RGB_COLORS, 
            &pv, NULL, 0);
    }
    else
    {
        hBitmap = CreateCompatibleBitmap(hdc, pBitmapHdr->biWidth, pBitmapHdr->biHeight);
    }

    if (! hBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    int iSetVal;

    //---- SetDIBits() can take unaligned data, right? ----
    iSetVal = SetDIBits(hdc, hBitmap, 0, pBitmapHdr->biHeight, DIBDATA(pBitmapHdr), (BITMAPINFO *)pBitmapHdr,
        DIB_RGB_COLORS);

    if (! iSetVal)
    {
        hr = MakeErrorLast();
        goto exit;
    }
        
    *phBitmap = hBitmap;
    
#ifdef DEBUG
    if (hBitmap)
    {
        BITMAP bm;

        GetObject(hBitmap, sizeof bm, &bm);
        s_dwSize += bm.bmWidthBytes * bm.bmHeight;
        //Log(LOG_TMBITMAP, L"Created a bitmap of %d bytes. total is %d", bm.bmWidthBytes * bm.bmHeight, s_dwSize);
    }
#endif

exit:
    if (hdcTemp)
        ReleaseDC(NULL, hdcTemp);

    if (FAILED(hr))
    {
        if (hBitmap)
            DeleteObject(hBitmap);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetScaledFontHandle(HDC hdc, LOGFONT *plf, HFONT *phFont)
{
    HRESULT hr = S_OK;

    if (_fCacheEnabled)
    {
        CRenderCache *pCacheObj = GetTlsCacheObj();
        if (pCacheObj)
            hr = pCacheObj->GetScaledFontHandle(hdc, plf, phFont);
    }
    else
    {
        LOGFONT lf = *plf;
        
        //---- convert to current screen dpi ----
        ScaleFontForHdcDpi(hdc, &lf);

        *phFont  = CreateFontIndirect(&lf);
        if (! *phFont)
            hr = MakeError32(E_OUTOFMEMORY);
    }

    return hr;
}
//---------------------------------------------------------------------------
void CRenderObj::ReturnFontHandle(HFONT hFont)
{
    if (_fCacheEnabled)
    {
        //--- cache currently doesn't refcnt so save time by not calling ---
        //CRenderCache *pCacheObj = GetTlsCacheObj();
        //if (pCacheObj)
        //{
            //pCacheObj->ReturnFontHandle(hFont);
            //goto exit;
        //}
    }
    else
    {
        DeleteObject(hFont);
    }
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::PrepareRegionDataForScaling(
    RGNDATA *pRgnData, LPCRECT prcImage, MARGINS *pMargins)
{
    //---- compute margin values ----
    int sw = prcImage->left;
    int lw = prcImage->left + pMargins->cxLeftWidth;
    int rw = prcImage->right - pMargins->cxRightWidth;

    int sh = prcImage->top;
    int th = prcImage->top + pMargins->cyTopHeight;
    int bh = prcImage->bottom - pMargins->cyBottomHeight;

    //---- step thru region data & customize it ----
    //---- classify each POINT according to a gridnum and ----
    //---- make it 0-relative to its grid location ----

    POINT *pt = (POINT *)pRgnData->Buffer;
    BYTE *pByte = (BYTE *)pRgnData->Buffer + pRgnData->rdh.nRgnSize;
    int iCount = 2 * pRgnData->rdh.nCount;

    for (int i=0; i < iCount; i++, pt++, pByte++)
    {
        if (pt->x < lw)
        {
            pt->x -= sw;

            if (pt->y < th)         // left top
            {
                *pByte = GN_LEFTTOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // left middle
            {
                *pByte = GN_LEFTMIDDLE;
                pt->y -= th;
            }
            else                    // left bottom
            {
                *pByte = GN_LEFTBOTTOM;
                pt->y -= bh;
            }
        }
        else if (pt->x < rw)
        {
            pt->x -= lw;

            if (pt->y < th)         // middle top
            {
                *pByte = GN_MIDDLETOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // middle middle
            {
                *pByte = GN_MIDDLEMIDDLE;
                pt->y -= th;
            }
            else                    // middle bottom
            {
                *pByte = GN_MIDDLEBOTTOM;
                pt->y -= bh;
            }
        }
        else
        {
            pt->x -= rw;

            if (pt->y < th)         // right top
            {
                *pByte = GN_RIGHTTOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // right middle
            {
                *pByte = GN_RIGHTMIDDLE;
                pt->y -= th;
            }
            else                    // right bottom
            {
                *pByte = GN_RIGHTBOTTOM;
                pt->y -= bh;
            }
        }

    }

    return S_OK;
} 
//---------------------------------------------------------------------------
HRESULT CRenderObj::CreateImageBrush(HDC hdc, int iPartId, int iStateId, 
    int iImageIndex, HBRUSH *phbr)
{
#if 0
    HRESULT hr;
    RESOURCE HDC dc2 = NULL;
    RESOURCE HBITMAP hOldBitmap2 = NULL;
    HBRUSH hBrush = NULL;

    //---- get our bitmap from the cache ----
    RESOURCE HBITMAP hBitmap;
    hr = GetBitmap(hdc, iPartId, iStateId, &hBitmap);
    if (FAILED(hr)) 
        goto exit;
    
    int iImageCount;
    if (FAILED(GetInt(iPartId, iStateId, TMT_IMAGECOUNT, &iImageCount)))
        iImageCount = 1;        /// default value

    if (iImageCount == 1)       // do easy case first
    {
        hBrush = CreatePatternBrush(hBitmap);
        goto gotit;
    }

    //---- create "dc2" to make our bitmap usable ----
    dc2 = CreateCompatibleDC(hdc);
    if (! dc2)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    hOldBitmap2 = (HBITMAP) SelectObject(dc2, hBitmap);

    //---- create a sub-bitmap of just our target image in "memoryDC" ----
    int width, height, xoffset, yoffset;
    GetImageInfo(hBitmap, iPartId, iStateId, iImageIndex, &width, &height, &xoffset, &yoffset);

    //---- local block ----
    {
        CMemoryDC memoryDC;
        hr = memoryDC.OpenDC(dc2, width, height);
        if (FAILED(hr))
            return hr;

        BitBlt(memoryDC, 0, 0, width, height, dc2, xoffset, yoffset, SRCCOPY);
    
        //---- finally, create our brush ----
        hBrush = CreatePatternBrush(memoryDC._hBitmap);
    }

gotit:
    if (hBrush)
    {
        *phbr = hBrush;
        hr = S_OK;
    }
    else
        hr = MakeErrorLast();

exit:
    //---- now clean up all resources ----
    if (dc2)
    {
        SelectObject(dc2, hOldBitmap2);
        DeleteDC(dc2);
    }

    ReturnBitmap(hBitmap);

    return hr;
#endif

    return E_NOTIMPL;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetColor(int iPartId, int iStateId, int iPropId, COLORREF *pColor)
{
    if (! pColor)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)          // not found
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;        // point at data

    *pColor = *u.pi;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetString(int iPartId, int iStateId, int iPropId, 
    LPWSTR pszBuff, DWORD dwMaxBuffChars)
{
    if (! pszBuff)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index - sizeof(int);      // point at length
    DWORD len = *u.pdw++;
    len /= sizeof(WCHAR);         // adjust to characters

    HRESULT hr = hr_lstrcpy(pszBuff, u.pw, dwMaxBuffChars);
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetBool(int iPartId, int iStateId, int iPropId, BOOL *pfVal)
{
    if (! pfVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *pfVal = *u.pb;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetInt(int iPartId, int iStateId, int iPropId, int *piVal)
{
    if (! piVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *piVal = *u.pi;
    return S_OK;
}
//---------------------------------------------------------------------------
static int iMetricDefaults[] = 
{
    1,      // TMT_BORDERWIDTH
    18,     // TMT_VERTSCROLLWIDTH
    18,     // TMT_HORZSCROLLHEIGHT
    27,     // TMT_CAPTIONBUTTONWIDTH
    27,     // TMT_CAPTIONBUTTONHEIGHT
    22,     // TMT_SMCAPTIONBUTTONWIDTH
    22,     // TMT_SMCAPTIONBUTTONHEIGHT
    22,     // TMT_MENUBUTTONWIDTH
    22,     // TMT_MENUBUTTONHEIGHT
};
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetMetric(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, int *piVal)
{
    if (! piVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    int value;

    if (index >= 0)      // found
    {
        MIXEDPTRS u;
        u.pb = _pbThemeData + index;      // point at data

        value = *u.pi;
    }
    else
        return MakeError32(ERROR_NOT_FOUND);
    
    *piVal = ScaleSizeForHdcDpi(hdc, value);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetEnumValue(int iPartId, int iStateId, int iPropId, int *piVal)
{
    if (! piVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *piVal = *u.pi;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetPosition(int iPartId, int iStateId, int iPropId, POINT *pPoint)
{
    if (! pPoint)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    pPoint->x = *u.pi++;
    pPoint->y = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetFont(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId,
    BOOL fWantHdcScaling, LOGFONT *pFont)
{
    if (! pFont)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *pFont = *(LOGFONT *)u.pb;
    
    if (fWantHdcScaling)
    {
        ScaleFontForHdcDpi(hdc, pFont);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetMargins(OPTIONAL HDC hdc, int iPartId, int iStateId, 
    int iPropId, OPTIONAL RECT *prc, MARGINS *pMargins)
{
    //---- return unscaled margins ----

    if (! pMargins)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    pMargins->cxLeftWidth = *u.pi++;
    pMargins->cxRightWidth = *u.pi++;
    pMargins->cyTopHeight = *u.pi++;
    pMargins->cyBottomHeight = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetIntList(int iPartId, int iStateId, int iPropId, INTLIST *pIntList)
{
    if (! pIntList)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    int iCount = *u.pi++;
    if (iCount > MAX_INTLIST_COUNT)
    {
        Log(LOG_ALWAYS, L"GetIntList() found bad theme data - Count=%d", iCount);

        return MakeError32(ERROR_NOT_FOUND);
    }

    pIntList->iValueCount = iCount;

    for (int i=0; i < iCount; i++)
        pIntList->iValues[i] = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetRect(int iPartId, int iStateId, int iPropId, RECT *pRect)
{
    if (! pRect)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    pRect->left = *u.pi++;
    pRect->top = *u.pi++;
    pRect->right = *u.pi++;
    pRect->bottom = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetFilenameOffset(int iPartId, int iStateId, int iPropId, 
   int *piFileNameOffset)
{
    if (! piFileNameOffset)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    *piFileNameOffset = index;      // offset to filename
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetFilename(int iPartId, int iStateId, int iPropId, LPWSTR pszBuff, 
   DWORD dwMaxBuffChars)
{
    if (! pszBuff)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index - sizeof(int);      // point at length
    DWORD len = *u.pdw++;
    len /= sizeof(WCHAR);             // adjust to chars size
    
    HRESULT hr = hr_lstrcpy(pszBuff, u.pw, dwMaxBuffChars);
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetData(int iPartId, int iStateId, int iPropId, BYTE **ppData,
    OPTIONAL int *piSize)
{
    if (! ppData)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index - sizeof(int);      // point at length
    DWORD len = *u.pdw++;

    *ppData = u.pb;

    if (piSize)
        *piSize = len;

    return S_OK;
}
//---------------------------------------------------------------------------
int CRenderObj::GetValueIndex(int iPartId, int iStateId, int iTarget)
{
    if (! iTarget)            
    {
        Log(LOG_PARAMS, L"Invalid iProperyId passed to GetValueIndex: %d", iTarget);
        return -1;
    }

    if (! _pbSectionData)
    {
        return -1;
    }

    MIXEDPTRS u;
    int index;

    u.pb = _pbSectionData;

    //---- find end of data ----
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;
    BYTE *pbLastValidChar = _pbThemeData + (hdr->dwTotalLength - 1) - kcbEndSignature;

    while (u.pb <= pbLastValidChar)           
    {
        UNPACKED_ENTRYHDR hdr;
        
        FillAndSkipHdr(u, &hdr);

        if (hdr.usTypeNum == TMT_PARTJUMPTABLE)   
        {
            u.pi++;     // skip over offset to first drawobj

            BYTE cnt = *u.pb++;

            if ((iPartId < 0) || (iPartId >= cnt))
            {
                index = u.pi[0];
            }
            else
            {
                index = u.pi[iPartId];
                if (index == -1)
                    index = u.pi[0];
            }

            u.pb = _pbThemeData + index;
            continue;
        }

        if (hdr.usTypeNum == (BYTE)TMT_STATEJUMPTABLE)   
        {
            BYTE cnt = *u.pb++;

            if ((iStateId < 0) || (iStateId >= cnt))
                index = u.pi[0];
            else
            {
                index = u.pi[iStateId];
                if (index == -1)
                    index = u.pi[0];
            }

            u.pb = _pbThemeData + index;
            continue;
        }

        if (hdr.usTypeNum == iTarget)        // got our target
        {
            // Log("GetValueIndex: match at index=%d", u.pb - _pbThemeData);
            return (int)(u.pb - _pbThemeData);      // point at actual data (not hdr)
        }

        if (hdr.ePrimVal == TMT_JUMPTOPARENT)
        {
            index = *u.pi;
            if (index == -1)
            {
                // Log("no match found");
                return -1;
            }

            // Log("GetValueIndex: jumping to parent at index=%d", index);
            u.pb = _pbThemeData + index;
            continue;
        }

        // Log("GetValueIndex: no match to hdr.usTypeNum=%d", hdr.usTypeNum);

        // advance to next value
        u.pb += hdr.dwDataLen;
    }

    //---- something went wrong ----
    Log(LOG_ERROR, L"GetValueIndex: ran off the valid data without a '-1' jump");
    return -1;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetPropertyOrigin(int iPartId, int iStateId, int iTarget, 
    PROPERTYORIGIN *pOrigin)
{
    if (! iTarget)            
    {
        Log(LOG_PARAMS, L"Invalid iProperyId passed to GetPropertyOrigin: %d", iTarget);
        return E_FAIL;
    }

    if (! _pbSectionData)
    {
        return E_FAIL;
    }

    MIXEDPTRS u;
    if (! pOrigin)
        return MakeError32(E_INVALIDARG);

    //---- start at our section ----
    u.pb = _pbSectionData;
    PROPERTYORIGIN origin = PO_CLASS;

    //---- find end of data ----
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;
    BYTE *pbLastValidChar = _pbThemeData + (hdr->dwTotalLength - 1) - kcbEndSignature;

    while (u.pb <= pbLastValidChar)           
    {
        UNPACKED_ENTRYHDR hdr;
        
        FillAndSkipHdr(u, &hdr);

        if (hdr.usTypeNum == TMT_PARTJUMPTABLE)   
        {
            u.pi++;     // skip over offset to first drawobj

            BYTE cnt = *u.pb++;
            int index;

            if ((iPartId <= 0) || (iPartId >= cnt))
            {
                index = u.pi[0];
            }
            else
            {
                index = u.pi[iPartId];
                if (index == -1)
                    index = u.pi[0];
            }

            if (index == u.pi[0])
                origin = PO_CLASS;
            else
                origin = PO_PART;

            u.pb = _pbThemeData + index;
            continue;
        }

        if (hdr.usTypeNum == TMT_STATEJUMPTABLE)   
        {
            BYTE cnt = *u.pb++;
            int index;

            if ((iStateId <= 0) || (iStateId >= cnt))
            {
                index = u.pi[0];
            }
            else
            {
                index = u.pi[iStateId];
                if (index == -1)
                    index = u.pi[0];
            }

            if (index != u.pi[0])
                origin = PO_STATE;

            u.pb = _pbThemeData + index;
            continue;
        }

        //Log("GetPropertyOrgin: iPartId=%d, iTarget=%d, DataIndex=%d", 
          //  iPartId, iTarget, u.pb - _pbThemeData);

        if ((iTarget == -1) || (hdr.usTypeNum == iTarget))        // got our target
        {
            // Log("GetPropertyOrgin: match at index=%d", u.pb - _pbThemeData);
            *pOrigin = origin;
            return S_OK;
        }

        if (hdr.ePrimVal == TMT_JUMPTOPARENT)
        {
            int index = *u.pi;
            if (index == -1)
            {
                // Log("GetPropertyOrgin: no match found");
                *pOrigin = PO_NOTFOUND;
                return S_OK;
            }

            // Log("GetPropertyOrgin: jumping to parent at index=%d", index);
            u.pb = _pbThemeData + index;
            origin = (PROPERTYORIGIN) (origin + 1);    // move down to next level of heirarchy
            continue;
        }

        // advance to next value
        u.pb += hdr.dwDataLen;
    }

    //---- something went wrong ----
    Log(LOG_ERROR, L"GetPropertyOrigin: ran off the valid data without a '-1' jump");
    return E_FAIL;
}
//---------------------------------------------------------------------------
BOOL WINAPI CRenderObj::IsPartDefined(int iPartId, int iStateId)
{
    PROPERTYORIGIN origin;
    HRESULT hr = GetPropertyOrigin(iPartId, iStateId, -1, &origin);
    SET_LAST_ERROR(hr);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (iStateId)
        return (origin == PO_STATE);

    return (origin == PO_PART);
}
//---------------------------------------------------------------------------
BOOL CRenderObj::ValidateObj()
{
    BOOL fValid = TRUE;

    //---- check object quickly ----
    if (   (! this)                         
        || (ULONGAT(_szHead) != 'dner')     // "rend"
        || (ULONGAT(&_szHead[4]) != 'jbo')  // "obj" 
        || (ULONGAT(_szTail) != 'dne'))     // "end"
    {
        Log(LOG_ALWAYS, L"CRenderObj is corrupt, addr=0x%08x", this);
        fValid = FALSE;
    }

    return fValid;
}
//---------------------------------------------------------------------------
CRenderCache *CRenderObj::GetTlsCacheObj()
{
    HRESULT hr = S_OK;
    CRenderCache *pCacheObj = NULL;

    CCacheList *pcl = GetTlsCacheList(TRUE);
    if (pcl)
        hr = pcl->GetCacheObject(this, _iCacheSlot, &pCacheObj);

    return pCacheObj;
}
//---------------------------------------------------------------------------
#if 0
HRESULT CRenderObj::DispatchDrawBg()
{
    HRESULT hr = S_OK;
    
    if (FAILED(GetEnumValue(iPartId, iStateId, TMT_BGTYPE, (int *)&eBgType)))
        eBgType = BT_BORDERFILL;      // default value
    
    if (eBgType == BT_NTLFILE)
    {
        BYTE *pNtlData;
        int iNtlLen;

        hr = GetData(iPartId, iStateId, TMT_NTLDATA, &pNtlData, &iNtlLen);
        if (FAILED(hr))
            goto exit;

        RECT rc = *pRect;

        //---- need to get these from callers... ---
        HBRUSH hbrDefault = NULL;
        DWORD dwOptions = 0;

        hr = RunNtl(hdc, rc, hbrDefault, dwOptions, iPartId, iStateId, pNtlData, iNtlLen, this);
        goto exit;
    }

    return hr;
}
#endif
//---------------------------------------------------------------------------
HRESULT CRenderObj::FindGlobalDrawObj(BYTE *pb, int iPartId, int iStateId, CDrawBase **ppObj)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;
    u.pb = pb;
    BOOL fFound = FALSE;
    UNPACKED_ENTRYHDR hdr;

    while (1)
    {
        if ((*u.ps == TMT_RGNLIST) || (*u.ps == TMT_STOCKBRUSHES))
        {
            //---- skip over this entry ----
            FillAndSkipHdr(u, &hdr);
            u.pb += hdr.dwDataLen;
            continue;
        }

        if (*u.ps != TMT_DRAWOBJ)
            break;

        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;

        if ((ph->iPartNum == iPartId) && (ph->iStateNum == iStateId))
        {
            *ppObj = (CDrawBase *)(u.pb + sizeof(DRAWOBJHDR));
            fFound = TRUE;
            break;
        }

        //---- skip over hdr+object ----
        u.pb += hdr.dwDataLen;
    }

    if (! fFound)
        hr = E_FAIL;

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetGlobalDrawObj(int iPartId, int iStateId, CDrawBase **ppObj)
{
    //---- perf note: we don't currently cache the ptrs for LINE and BORDER ----
    //---- global objects since they are not used much/at all ----

    HRESULT hr = S_OK;

    if (! _pbThemeData)
    {
        hr = E_FAIL;
        goto exit;
    }

    THEMEHDR *pHdr;
    pHdr = (THEMEHDR *)_pbThemeData;

    //---- get ptr to global text obj ----
    MIXEDPTRS u;
	u.pb = _pbThemeData + pHdr->iGlobalsDrawObjOffset;

    //---- first try exact match ---
    hr = FindGlobalDrawObj(u.pb, iPartId, iStateId, ppObj);
    if (FAILED(hr))
    {
        //---- look for state=0 ----
        hr = FindGlobalDrawObj(u.pb, iPartId, 0, ppObj);
        if (FAILED(hr))
        {
            //---- just use the global draw obj ----
            if (*u.ps == TMT_DRAWOBJ)
            {
        	    u.pb += ENTRYHDR_SIZE + sizeof(DRAWOBJHDR);
                *ppObj = (CDrawBase *)u.pb;
                hr = S_OK;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UxTheme.rc
//

#define IDC_STATIC                      -1

/////////////////////////////////////////////////////////////////////
// String Resource IDs (2000 - 10000)
/////////////////////////////////////////////////////////////////////
#define IDS_MESSAGEBOX         2000
#define IDS_ACTIVEWINDOW       2001
#define IDS_INACTIVEWINDOW     2002
#define IDS_OKBUTTON           2003
#define IDS_WINDOWTEXT         2004
#define IDS_WINDOWMETRICS      2005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        153
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\renderlist.h ===
//---------------------------------------------------------------------------
//  RenderList.h - manages list of CRemderObj objects
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Render.h"
//---------------------------------------------------------------------------
class CUxThemeFile;       // forward
//---------------------------------------------------------------------------
#define MAX_RETADDRS    10
//---------------------------------------------------------------------------
struct RENDER_OBJ_ENTRY
{
    CRenderObj *pRenderObj;
    DWORD dwRecycleNum;     // sequential number to validate handle against current obj

    //---- these control use/freeing of object ----
    int iRefCount;          // number of HTHEME handles returned for this obj
    int iInUseCount;        // number of active wrapper API calls for this obj
    int iLoadId;            // load ID of associated theme file
    BOOL fClosing;          // TRUE when we are forcing this object closed

    //---- for tracking foreign windows & debugging leaks ----
    HWND hwnd;
};
//---------------------------------------------------------------------------
class CRenderList
{
    //---- methods ----
public:
    CRenderList();
    ~CRenderList();

    HRESULT OpenRenderObject(CUxThemeFile *pThemeFile, int iThemeOffset, 
        int iClassNameOffset, CDrawBase *pDrawBase, CTextDraw *pTextObj, HWND hwnd,
        DWORD dwOtdFlags, HTHEME *phTheme);
    HRESULT CloseRenderObject(HTHEME hTheme);

    HRESULT OpenThemeHandle(HTHEME hTheme, CRenderObj **ppRenderObj, int *piSlotNum);
    void CloseThemeHandle(int iSlotNum);
    void FreeRenderObjects(int iThemeFileLoadId);

#ifdef DEBUG
    void DumpFileHolders();
#endif

protected:
    //---- helper methods ----
    BOOL DeleteCheck(RENDER_OBJ_ENTRY *pEntry);

    //---- data ----
protected:
    __int64 _iNextUniqueId;
    CSimpleArray<RENDER_OBJ_ENTRY> _RenderEntries;

    //---- lock for all methods of this object ----
    CRITICAL_SECTION _csListLock;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\rgn.cpp ===
//-------------------------------------------------------------------------//
//  Rgn.cpp - Bitmap-to-Region transforms
//
//  History:
//  01/31/2000  scotthan   created
//-------------------------------------------------------------------------//

#include "stdafx.h"
#include "rgn.h"
#include "tmutils.h"


//------------//
//  Helpers:

//-------------------------------------------------------------------------//
#define CX_USEDEFAULT   -1
#define CY_USEDEFAULT   -1

#define _ABS( val1, val2 )   ((val1)>(val2) ? (val1)-(val2) : (val2)-(val1))

//-------------------------------------------------------------------------//
inline BOOL IsColorMatch( COLORREF rgb1, COLORREF rgb2, int nTolerance = 0 )
{
    if( nTolerance == 0 )
        return (rgb1 << 8) == (rgb2 << 8);

    return _ABS(GetRValue(rgb1),GetRValue(rgb2)) <= nTolerance &&
           _ABS(GetGValue(rgb1),GetGValue(rgb2)) <= nTolerance &&
           _ABS(GetBValue(rgb1),GetBValue(rgb2)) <= nTolerance;
}

//-------------------------------------------------------------------------//
inline BOOL _IsNormalRect( IN LPCRECT prc )
{
    return (prc->right >= prc->left) &&
           (prc->bottom >= prc->top);
}

//-------------------------------------------------------------------------//
inline BOOL _IsOnScreenRect( IN LPCRECT prc )
{
    return prc->left >= 0 && prc->top >= 0 &&
           prc->right >= 0 && prc->bottom >= 0;
}

//-------------------------------------------------------------------------//
inline void _InPlaceUnionRect( IN OUT LPRECT prcDest, IN LPCRECT prcSrc )
{
    ASSERT(prcDest);
    ASSERT(prcSrc);
    ASSERT(_IsNormalRect(prcSrc));

    if( prcDest->left == -1 || prcDest->left > prcSrc ->left )
        prcDest->left = prcSrc ->left;

    if( prcDest->right == -1 || prcDest->right < prcSrc ->right )
        prcDest->right = prcSrc ->right;

    if( prcDest->top == -1 || prcDest->top > prcSrc ->top )
        prcDest->top = prcSrc ->top;

    if( prcDest->bottom == -1 || prcDest->bottom < prcSrc ->bottom )
        prcDest->bottom = prcSrc ->bottom;
}

//-------------------------------------------------------------------------//
//  Walks the pixels and computes the region
HRGN WINAPI _PixelsToRgn( 
    DWORD *pdwBits,
    int cxImageOffset,  // image cell horz offset
    int cyImageOffset,  // image cell vert offset
    int cxImage,        // image cell width
    int cyImage,        // image cell height
    int cxSrc,          // src bitmap width
    int cySrc,          // src bitmap height
    BOOL fAlphaChannel,
    int iAlphaThreshold,
    COLORREF rgbMask, 
    int nMaskTolerance )
{
    //  Establish a series of rectangles, each corresponding to a scan line (row)
    //  in the bitmap, that will comprise the region.
    const UINT RECTBLOCK = 512;
    UINT       nAllocRects = 0;
    HRGN       hrgnRet = NULL;
    HGLOBAL    hrgnData = GlobalAlloc( GMEM_MOVEABLE, 
                                    sizeof(RGNDATAHEADER) + (sizeof(RECT) * (nAllocRects + RECTBLOCK)) );

    if( hrgnData )
    {
        nAllocRects += RECTBLOCK;

        RGNDATA* prgnData = (RGNDATA*)GlobalLock( hrgnData );
        LPRECT   prgrc    = (LPRECT)prgnData->Buffer;

        ZeroMemory( prgnData, sizeof(prgnData->rdh) );
        prgnData->rdh.dwSize   = sizeof(prgnData->rdh);
        prgnData->rdh.iType    = RDH_RECTANGLES;
        SetRect( &prgnData->rdh.rcBound, -1, -1, -1, -1 );

        // invert offset in y dimension since bits are arrayed bottom to top
        int cyRow0 = cySrc - (cyImage + cyImageOffset);
        int cyRowN = (cyRow0 + cyImage) - 1 ;  // index of the last row

        //  Compute a transparency mask if not specified.
        if( -1 == rgbMask )
            rgbMask = pdwBits[cxImageOffset + (cyRowN * cxSrc)];

        //---- pixels in pdwBits[] have RBG's reversed ----
        //---- reverse our mask to match ----
        rgbMask = REVERSE3(rgbMask);        

        //---- rows in pdwBits[] are reversed (bottom to top) ----
        for( int y = cyRow0; y <= cyRowN; y++ ) // working bottom-to-top
        {
            //---- Scanning pixels left to right ----
            DWORD *pdwFirst = &pdwBits[cxImageOffset + (y * cxSrc)];
            DWORD *pdwLast = pdwFirst + cxImage - 1;
            DWORD *pdwPixel = pdwFirst;

            while (pdwPixel <= pdwLast)
            {
                //---- skip TRANSPARENT pixels to find next OPAQUE (on this row) ----
                if (fAlphaChannel)
                {
                    while ((pdwPixel <= pdwLast) && (ALPHACHANNEL(*pdwPixel) < iAlphaThreshold))
                        pdwPixel++;
                }
                else
                {
                    while ((pdwPixel <= pdwLast) && (IsColorMatch(*pdwPixel, rgbMask, nMaskTolerance)))
                        pdwPixel++;
                }

                if (pdwPixel > pdwLast)     // too far; try next row
                    break;       

                DWORD *pdw0 = pdwPixel;
                pdwPixel++;             // skip over current opaque pixel

                //---- skip OPAQUE pixels to find next TRANSPARENT (on this row) ----
                if (fAlphaChannel)
                {
                    while ((pdwPixel <= pdwLast) && (ALPHACHANNEL(*pdwPixel) >= iAlphaThreshold))
                        pdwPixel++;
                }
                else
                {
                    while ((pdwPixel <= pdwLast) && (! IsColorMatch(*pdwPixel, rgbMask, nMaskTolerance)))
                        pdwPixel++;
                }

                //---- got a stream of 1 or more opaque pixels on this row ----

                //  allocate more region rects if necessary (a particularly complex line)
                if( prgnData->rdh.nCount >= nAllocRects )
                {
                    GlobalUnlock( hrgnData );
                    prgnData = NULL;
                    HGLOBAL hNew = GlobalReAlloc( hrgnData, 
                            sizeof(RGNDATAHEADER) + (sizeof(RECT) * (nAllocRects + RECTBLOCK)),
                            GMEM_MOVEABLE );

                    if( hNew )
                    {
                        hrgnData = hNew;
                        nAllocRects += RECTBLOCK;
                        prgnData = (RGNDATA*)GlobalLock( hrgnData );
                        prgrc    = (LPRECT)prgnData->Buffer;
                        ASSERT(prgnData);
                    }
                    else
                        goto exit;      // out of memory
                }
                
                //  assign region rectangle
                int x0 = (int)(pdw0 - pdwFirst);
                int x = (int)(pdwPixel - pdwFirst);
                int y0 = cyRowN - y;

                SetRect( prgrc + prgnData->rdh.nCount, 
                         x0, y0, x, y0+1  /* each rectangle is always 1 pixel high */ );
                
                //  merge into bounding box
                _InPlaceUnionRect( &prgnData->rdh.rcBound, 
                                   prgrc + prgnData->rdh.nCount );
                prgnData->rdh.nCount++;

            } // while ()
        } // for(y)

        if( prgnData->rdh.nCount && _IsOnScreenRect(&prgnData->rdh.rcBound) )
        {
            //  Create the region representing the scan line.
            hrgnRet = ExtCreateRegion( NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * nAllocRects),
                                       prgnData );
        }

exit:
        // Free region def block.
        GlobalUnlock( hrgnData );
        GlobalFree( hrgnData );
    }

    return hrgnRet;
}

//-------------------------------------------------------------------------//
//  Creates a region based on a text string in the indicated font.
HRGN WINAPI CreateTextRgn( HFONT hf, LPCTSTR pszText )
{
    HRGN hrgnRet = NULL;

    if( pszText && *pszText )
    {
        int   cchText = lstrlen( pszText );

        //  Create a composite DC for assembling the region.
        HDC  hdcMem = CreateCompatibleDC( NULL );

        SetBkMode( hdcMem, TRANSPARENT );
        SetTextAlign( hdcMem, TA_TOP|TA_LEFT );
        HFONT hfOld = (HFONT)SelectObject( hdcMem, hf );

        //  Derive a region from a path.
        BeginPath( hdcMem );
        TextOut( hdcMem, 0, 0, pszText, cchText );
        EndPath( hdcMem );

        hrgnRet = PathToRegion( hdcMem );

        //  Clean up composite DC
        SelectObject( hdcMem, hfOld );
        DeleteDC( hdcMem );
    }

    return hrgnRet;
}

//-------------------------------------------------------------------------//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional 
//  (-1 == use the value of the first pixel as the key).
//
HRESULT WINAPI CreateBitmapRgn( 
    HBITMAP hbm, 
    int cxOffset,
    int cyOffset,
    int cx,
    int cy,
    BOOL fAlphaChannel,
    int iAlphaThreshold,
    COLORREF rgbMask, 
    int nMaskTolerance,
    OUT HRGN *phrgn)
{
    CBitmapPixels BitmapPixels;
    DWORD         *prgdwPixels;
    int           cwidth, cheight;

    HRESULT hr = BitmapPixels.OpenBitmap(NULL, hbm, TRUE, &prgdwPixels, &cwidth, &cheight);
    if (FAILED(hr))
        return hr;

    if (cx <= 0)
        cx = cwidth;

    if (cy <= 0)
        cy = cheight;

    HRGN hrgn = _PixelsToRgn(prgdwPixels, cxOffset, cyOffset, cx, cy, cwidth, cheight, fAlphaChannel,
        iAlphaThreshold, rgbMask, nMaskTolerance);
    if (! hrgn)
        return MakeError32(E_FAIL);      // unknown reason for failure

    *phrgn = hrgn;
    return S_OK;
}

//-------------------------------------------------------------------------//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional (-1 ==
//  use the value of the first pixel as the key).
//
HRGN WINAPI CreateScaledBitmapRgn( 
    HBITMAP hbm, 
    int cx,
    int cy,
    COLORREF rgbMask, 
    int nMaskTolerance )
{
    HRGN   hrgnRet = NULL;
    BITMAP bm;

    if( hbm && GetObject( hbm, sizeof(bm), &bm ) )
    {
        //  Create a memory DC to do the pixel walk
        HDC hdcMem = NULL;
        if( (hdcMem = CreateCompatibleDC(NULL)) != NULL )
        {
            if( CX_USEDEFAULT == cx )
                cx = bm.bmWidth;
            if( CY_USEDEFAULT == cy )
                cy = bm.bmHeight;

            //  Create a 32-bit empty bitmap for the walk
            BITMAPINFO bmi;
            ZeroMemory( &bmi, sizeof(bmi) );
            bmi.bmiHeader.biSize        = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth       = cx;
            bmi.bmiHeader.biHeight      = cy;
            bmi.bmiHeader.biPlanes      = 1;
            bmi.bmiHeader.biBitCount    = 32;
            bmi.bmiHeader.biCompression = BI_RGB; // uncompressed.

            VOID*   pvBits = NULL;
            HBITMAP hbmMem  = CreateDIBSection( hdcMem, &bmi, DIB_RGB_COLORS, &pvBits, NULL, NULL );
            BITMAP  bmMem;

            if( hbmMem )
            {
                //  Transfer the image to our 32-bit format for the pixel walk.
                HBITMAP hbmMemOld = (HBITMAP)SelectObject( hdcMem, hbmMem );
                HDC hdc = CreateCompatibleDC( hdcMem );
                HBITMAP hbmOld = (HBITMAP)SelectObject( hdc, hbm );

                StretchBlt( hdcMem, 0, 0, cx, cy, 
                            hdc, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
                SelectObject( hdc, hbmOld );
                DeleteDC( hdc );
                
                GetObject( hbmMem, sizeof(bmMem), &bmMem );
                ASSERT(bmMem.bmBitsPixel == 32);
                ASSERT(bmMem.bmWidthBytes/bmMem.bmWidth == sizeof(DWORD));
                LPDWORD pdwBits = (LPDWORD)bmMem.bmBits;
                ASSERT(pdwBits != NULL);

                hrgnRet = _PixelsToRgn(pdwBits, 0, 0, cx, cy, cx, cy, FALSE, 0, rgbMask, nMaskTolerance);
              
                //  Delete 32-bit memory bitmap
                SelectObject( hdcMem, hbmMemOld ); 
                DeleteObject( hbmMem ); 
            }
            //  Delete memory DC
            DeleteDC(hdcMem);

        }
    }
    return hrgnRet;
}

//-------------------------------------------------------------------------//
int WINAPI AddToCompositeRgn( 
    IN OUT HRGN* phrgnComposite, 
    IN OUT HRGN hrgnSrc, 
    IN int cxOffset, 
    IN int cyOffset )
{
    int nRet = ERROR;

    if( NULL != phrgnComposite && NULL != hrgnSrc )
    {
        nRet = OffsetRgn( hrgnSrc, cxOffset, cyOffset );
        if( nRet != ERROR )
        {
            int nMode = RGN_OR;
            if( NULL == *phrgnComposite )
            {
                *phrgnComposite = CreateRectRgn(0,0,1,1);
                if( NULL == *phrgnComposite )
                    return ERROR;
                nMode = RGN_COPY;
            }
            nRet = CombineRgn( *phrgnComposite, hrgnSrc, *phrgnComposite, nMode );
        }
    }

    return nRet;
}

//-------------------------------------------------------------------------//
int WINAPI RemoveFromCompositeRgn( 
    HRGN hrgnDest, 
    LPCRECT prcRemove )
{
    ASSERT(hrgnDest);
    ASSERT(prcRemove);
    ASSERT(!IsRectEmpty(prcRemove));

    int nRet = ERROR;
    
    RECT rc = *prcRemove;
    HRGN hrgn;
    if( (hrgn = CreateRectRgnIndirect( &rc )) != NULL )
    {
        nRet = CombineRgn( hrgnDest, hrgnDest, hrgn, RGN_DIFF );
        DeleteObject( hrgn );
    }
    return nRet;
}

//-------------------------------------------------------------------------//
HRGN WINAPI CreateTiledRectRgn( 
    IN HRGN hrgnSrc, 
    IN int cxSrc, 
    IN int cySrc, 
    IN int cxDest, 
    IN int cyDest )
{
    HRGN hrgnBound = NULL; // return value
    HRGN hrgnTile = _DupRgn( hrgnSrc );

    if( hrgnTile )
    {
        //  Build up an unplaced, unclipped composite
        HRGN hrgnTmp = NULL;
        for( int y = 0; y < cyDest; y += cySrc )
        {
            for( int x = 0; x < cxDest; x += cxSrc )
            {
                AddToCompositeRgn( &hrgnTmp, hrgnTile, 
                                   (x ? cxSrc  : 0), (y ? cySrc : 0) );
            }
        }

        if( NULL != hrgnTmp )
        {
            //  Clip the composite to the specified rectangle
            hrgnBound = CreateRectRgn( 0, 0, cxDest, cyDest );
            if( hrgnBound )
            {
                
                if( ERROR == CombineRgn( hrgnBound, hrgnTmp, hrgnBound, RGN_AND ) )
                {
                    DeleteObject( hrgnBound );
                    hrgnBound = NULL;
                }
            }
            DeleteObject( hrgnTmp );   
        }
        DeleteObject( hrgnTile );
    }
    return hrgnBound;
}

//-------------------------------------------------------------------------//
HRGN WINAPI _DupRgn( HRGN hrgnSrc )
{
    if( hrgnSrc )
    {
        HRGN hrgnDest = CreateRectRgn(0,0,1,1);
        if (hrgnDest)
        {
            if (CombineRgn( hrgnDest, hrgnSrc, NULL, RGN_COPY ) )
                return hrgnDest;
    
            DeleteObject(hrgnDest);
        }
    }
    return NULL; 
}

//-------------------------------------------------------------------------//
void FixMarginOverlaps(int szDest, int *pm1, int *pm2)
{
    int szSrc = (*pm1 + *pm2);

    if ((szSrc > szDest) && (szSrc > 0))
    {
        //---- reduce each but maintain ratio ----
        *pm1 = int(.5 + float(*pm1 * szDest)/float(szSrc));
        *pm2 = szDest - *pm1;
    }
}
//-------------------------------------------------------------------------//
HRESULT _ScaleRectsAndCreateRegion(
    RGNDATA     *prd, 
    const RECT  *prc,
    MARGINS     *pMargins,
    SIZE        *pszSrcImage, 
    HRGN        *phrgn)
{
    //---- note: "prd" is region data with the 2 points in each ----
    //---- rectangle made relative to its grid.  Also, after the points, ----
    //---- there is a BYTE for each point signifying the grid id (0-8) ----
    //---- that each point lies within.  the grid is determined using ----
    //---- the original region with the background "margins".   This is ----
    //---- done to make scaling the points as fast as possible. ----

    if (! prd)                  // required
        return MakeError32(E_POINTER);

    //---- easy access variables ----
    int lw = pMargins->cxLeftWidth;
    int rw = pMargins->cxRightWidth;
    int th = pMargins->cyTopHeight;
    int bh = pMargins->cyBottomHeight;

    int iDestW = WIDTH(*prc);
    int iDestH = HEIGHT(*prc);

    //---- prevent left/right dest margins from overlapping ----
    FixMarginOverlaps(iDestW, &lw, &rw);

    //---- prevent top/bottom dest margins from overlapping ----
    FixMarginOverlaps(iDestH, &th, &bh);

    int lwFrom = lw;
    int rwFrom = pszSrcImage->cx - rw;
    int thFrom = th;
    int bhFrom = pszSrcImage->cy - bh;

    int lwTo = prc->left + lw;
    int rwTo = prc->right - rw;
    int thTo = prc->top + th;
    int bhTo = prc->bottom - bh;

    //---- compute offsets & factors ----
    int iLeftXOffset = prc->left;
    int iMiddleXOffset = lwTo;
    int iRightXOffset = rwTo;

    int iTopYOffset = prc->top;
    int iMiddleYOffset = thTo;
    int iBottomYOffset = bhTo;
        
    int iToMiddleWidth = rwTo - lwTo;
    int iFromMiddleWidth = rwFrom - lwFrom;
    int iToMiddleHeight = bhTo - thTo;
    int iFromMiddleHeight = bhFrom - thFrom;

    if (! iFromMiddleWidth)        // avoid divide by zero
    {
        //--- map point to x=0 ----
        iToMiddleWidth = 0;       
        iFromMiddleWidth = 1;
    }

    if (! iFromMiddleHeight)        // avoid divide by zero
    {
        //--- map point to y=0 ----
        iToMiddleHeight = 0;       
        iFromMiddleHeight = 1;
    }

    //---- clipping values for adjusted lw/rw/th/bh ----
    int lwMaxVal = __max(lw - 1, 0);
    int rwMinVal = __min(pMargins->cxRightWidth - rw, __max(pMargins->cxRightWidth-1, 0));
    int thMaxVal = __max(th - 1, 0);
    int bhMinVal = __min(pMargins->cyBottomHeight - bh, __max(pMargins->cyBottomHeight-1, 0));

    //---- allocte a buffer for the new points (rects) ----
    int newlen = sizeof(RGNDATAHEADER) + prd->rdh.nRgnSize;    // same # of rects
    BYTE *newData = (BYTE *)new BYTE[newlen];
    
    RGNDATA *prdNew = (RGNDATA *)newData;
    if (! prdNew)
        return MakeError32(E_OUTOFMEMORY);

    ZeroMemory(prdNew, sizeof(prd->rdh));

    prdNew->rdh.dwSize = sizeof(prdNew->rdh);
    prdNew->rdh.iType  = RDH_RECTANGLES;
    int cRects         = prd->rdh.nCount;
    prdNew->rdh.nCount = cRects;
    SetRect(&prdNew->rdh.rcBound, -1, -1, -1, -1);

    //---- step thru our custom data (POINT + BYTE combos) ----
    POINT *pt     = (POINT *)prd->Buffer;
    BYTE *pByte   = (BYTE *)prd->Buffer + prd->rdh.nRgnSize;
    int cPoints   = 2 * cRects;
    POINT *ptNew  = (POINT *)prdNew->Buffer;

    for (int i=0; i < cPoints; i++, pt++, pByte++, ptNew++)        // transform each "point"
    {
        switch (*pByte)
        {
            //---- in the "don't scale" areas, we clip the translated values ----
            //---- for the case where the destination areas are too small ----
            //---- using the below "__min()" and "__max()" calls ----

            //---- remember: each point has been made 0-relative to its grid ----

            case GN_LEFTTOP:                 // left top
                ptNew->x = __min(pt->x, lwMaxVal) + iLeftXOffset;
                ptNew->y = __min(pt->y, thMaxVal) + iTopYOffset;
                break;

            case GN_MIDDLETOP:               // middle top
                ptNew->x = (pt->x*iToMiddleWidth)/iFromMiddleWidth + iMiddleXOffset;
                ptNew->y = __min(pt->y, thMaxVal) + iTopYOffset;
                break;

            case GN_RIGHTTOP:                // right top
                ptNew->x = __max(pt->x, rwMinVal) + iRightXOffset;
                ptNew->y = __min(pt->y, thMaxVal) + iTopYOffset;
                break;

            case GN_LEFTMIDDLE:              // left middle
                ptNew->x = __min(pt->x, lwMaxVal) + iLeftXOffset;
                ptNew->y = (pt->y*iToMiddleHeight)/iFromMiddleHeight + iMiddleYOffset;
                break;

            case GN_MIDDLEMIDDLE:            // middle middle
                ptNew->x = (pt->x*iToMiddleWidth)/iFromMiddleWidth + iMiddleXOffset;
                ptNew->y = (pt->y*iToMiddleHeight)/iFromMiddleHeight + iMiddleYOffset;
                break;

            case GN_RIGHTMIDDLE:             // right middle
                ptNew->x = __max(pt->x, rwMinVal) + iRightXOffset;
                ptNew->y = (pt->y*iToMiddleHeight)/iFromMiddleHeight + iMiddleYOffset;
                break;

            case GN_LEFTBOTTOM:              // left bottom
                ptNew->x = __min(pt->x, lwMaxVal) + iLeftXOffset;
                ptNew->y = __max(pt->y, bhMinVal) + iBottomYOffset;
                break;

            case GN_MIDDLEBOTTOM:             // middle bottom
                ptNew->x = (pt->x*iToMiddleWidth)/iFromMiddleWidth + iMiddleXOffset;
                ptNew->y = __max(pt->y, bhMinVal) + iBottomYOffset;
                break;

            case GN_RIGHTBOTTOM:              // right bottom
                ptNew->x = __max(pt->x, rwMinVal) + iRightXOffset;
                ptNew->y = __max(pt->y, bhMinVal) + iBottomYOffset;
                break;
        }
    }

    //---- compute bounding box of new region ----
    RECT *pRect = (RECT *)prdNew->Buffer;
    RECT newBox = {-1, -1, -1, -1};

    for (i=0; i < cRects; i++, pRect++)
        _InPlaceUnionRect(&newBox, pRect);

    //---- create the new region ----
    prdNew->rdh.rcBound = newBox;
    HRGN hrgn = ExtCreateRegion(NULL, newlen, prdNew);
    
    delete [] newData;          // free prdNew (aka newdata)
    if (! hrgn)
        return MakeErrorLast();

    *phrgn = hrgn;
    return S_OK;
}

//---------------------------------------------------------------------------------//
#ifdef _DEBUG
void RegionDebug(
  HRGN hrgn)
{
    DWORD len = GetRegionData(hrgn, 0, NULL);       // get required length
    ATLASSERT(len);

    RGNDATA *pRgnData = (RGNDATA *) new BYTE[len + sizeof(RGNDATAHEADER)];
    DWORD len2 = GetRegionData(hrgn, len, pRgnData);
    ATLASSERT(len == len2);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\rgn.h ===
//-------------------------------------------------------------------------//
//  BmpRgn.h - Bitmap-to-Region transforms
//
//  History:
//  01/31/2000  scotthan   created
//-------------------------------------------------------------------------//

#ifndef __RGN_H__
#define __RGN_H__
//-------------------------------------------------------------------------//
//  CreateBitmapRgn
//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional (-1 ==
//  use the value of the first pixel as the key).
//
EXTERN_C HRESULT WINAPI CreateBitmapRgn( 
    HBITMAP hbm, int cxOffset, int cyOffset, 
    int cx, int cy, BOOL fAlphaChannel, int iAlphaThreshold, COLORREF rgbMask, 
    int nMaskTolerance, OUT HRGN *phrgn);

//-------------------------------------------------------------------------//
//  CreateScaledBitmapRgn
//
//  Behaves in the same manner as CreateBitmapRgn, 
//  except builds a region based on a +scaled+ arbitrary bitmap.
EXTERN_C HRGN WINAPI CreateScaledBitmapRgn( 
    HBITMAP hbm, int cx, int cy, COLORREF rgbMask, int nMaskTolerance );

//-------------------------------------------------------------------------//
//  CreateTextRgn
//
//  Creates a region based on a text string in the indicated font.
//
EXTERN_C HRGN WINAPI CreateTextRgn( HFONT hf, LPCTSTR pszText );

//-------------------------------------------------------------------------//
//  AddToCompositeRgn
//
//  Wraps CombineRgn by managing composite creation and positioning
//  the source region (which is permanently offset). Returns one of:
//  NULLREGION, SIMPLEREGION, COMPLEXREGION, ERROR.
//
EXTERN_C int WINAPI AddToCompositeRgn( 
    HRGN* phrgnComposite, HRGN hrgnSrc, int cxOffset, int cyOffset );

//-------------------------------------------------------------------------//
//  RemoveFromCompositeRgn
//
//  Wraps CombineRgn by managing removal of rectangular region from
//  an existing destination region. Returns one of:
//  NULLREGION, SIMPLEREGION, COMPLEXREGION, ERROR.
//
EXTERN_C int WINAPI RemoveFromCompositeRgn( HRGN hrgnDest, LPCRECT prcRemove );

//-------------------------------------------------------------------------//
//  CreateTiledRectRgn
//
//  Returns a rectangular region composed of region tiles.
//
EXTERN_C HRGN WINAPI CreateTiledRectRgn( 
    HRGN hrgnTile, int cxTile, int cyTile, int cxBound, int cyBound );

//-------------------------------------------------------------------------//
//  Region utilities:
//
EXTERN_C HRGN WINAPI _DupRgn( HRGN hrgnSrc );

//-------------------------------------------------------------------------//
//  hit-testing
#define HTR_NORESIZE_USESEGCODE    0
#define HTR_NORESIZE_RETDEFAULT    -1
struct HITTESTRGN
{
    HRGN  hrgn;          // test region
    POINT pt;            // test point
    WORD  wSegCode;      // raw grid code, in the form of HTTOP, HTLEFT, HTTOPLEFT, etc.  This speeds calcs
    WORD  wDefault;      // return code on hit failure.
    BOOL  fCaptionAtTop; // interpret hits in top grid segs as a caption hit.
    UINT  cxLeftMargin;  // width of left resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
    UINT  cyTopMargin;   // height of top resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
    UINT  cxRightMargin; // width of right resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
    UINT  cyBottomMargin;// height of bottom resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
};

EXTERN_C WORD WINAPI _DefaultHitCodeFromSegCode( BOOL fHasCaption, WORD wSegHTcode );

//-------------------------------------------------------------------------//
//   Stretch/Tile rects from original region and create a new one
EXTERN_C HRESULT WINAPI _ScaleRectsAndCreateRegion(RGNDATA  *pCustomRgnData, 
    const RECT *pBoundRect, MARGINS *pMargins, SIZE *pszSrcImage, HRGN *pHrgn);

//-------------------------------------------------------------------------//
#ifdef _DEBUG
void RegionDebug(HRGN hrgn);
#endif

#endif __RGN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\scroll.cpp ===
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scroll.h"

#if defined(_UXTHEME_)

// non-client scrollbar 
#include "nctheme.h"
#include "scrollp.h"

#else

// scrollbar control 
#include "usrctl32.h"

#endif _UXTHEME_

//  comment this out to visually match user32 scrollbar:
//#define _VISUAL_DELTA_

#ifdef _VISUAL_DELTA_
#define CARET_BORDERWIDTH   2
#endif _VISUAL_DELTA_

//-------------------------------------------------------------------------//
#define FNID_SCROLLBAR          0x0000029A      // UxScrollBarWndProc;
#define GetOwner(hwnd)          GetWindow(hwnd, GW_OWNER)
#define HW(x)                   x
#define HWq(x)                  x
#define RIPERR0(s1,s2,errno)
#define RIPMSG1(errno,fmt,arg1)
#define RIPMSG2(errno,fmt,arg1,arg2)
#define RIPMSG3(errno,fmt,arg1,arg2,arg3)
#define RIP_VERBOSE()
#define ClrWF                   ClearWindowState
#define SetWF                   SetWindowState
#define Lock(phwnd, hwnd)       InterlockedExchangePointer((PVOID*)(phwnd), (PVOID)hwnd)
#define Unlock(phwnd)           Lock(phwnd, NULL)
#define CheckLock(hwnd)
#define ThreadLock(w,t)
#define ThreadUnlock(t)
#define VALIDATECLASSANDSIZE
#define DTTIME                  (MulDiv( GetDoubleClickTime(), 4, 5 ))
#define _KillSystemTimer              KillTimer
#define _SetSystemTimer               SetTimer
#define IsWinEventNotifyDeferredOK()  TRUE
#define IsWinEventNotifyDeferred()    FALSE

//-------------------------------------------------------------------------//
//  scroll type flags userk.h
#define SCROLL_NORMAL   0
#define SCROLL_DIRECT   1
#define SCROLL_MENU     2

//-------------------------------------------------------------------------//
//  internal Scrollbar state/style bits
//#define SBFSIZEBOXTOPLEFT       0x0C02
//#define SBFSIZEBOXBOTTOMRIGHT   0x0C04
//#define SBFSIZEBOX              0x0C08
#define SBFSIZEGRIP             0x0C10


//----------------------------------//
//  Scrollbar arrow disable flags
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.

//----------------------------------//
//  function forwards
UINT _SysToChar(UINT message, LPARAM lParam);

//-------------------------------------------------------------------------//
//  private hittest codes
//#define HTEXSCROLLFIRST     60
#define HTSCROLLUP          60
#define HTSCROLLDOWN        61
#define HTSCROLLUPPAGE      62
#define HTSCROLLDOWNPAGE    63
#define HTSCROLLTHUMB       64
//#define HTEXSCROLLLAST      64
//#define HTEXMENUFIRST       65
//#define HTMDISYSMENU        65
//#define HTMDIMAXBUTTON      66
//#define HTMDIMINBUTTON      67
//#define HTMDICLOSE          68
//#define HTMENUITEM          69
//#define HTEXMENULAST        69

#define IDSYS_SCROLL            0x0000FFFEL // timer ID, user.h

typedef HWND  SBHWND;
typedef HMENU PMENU;


//-------------------------------------------------------------------------//
//  SBDATA
typedef struct tagSBDATA 
{
    int     posMin;
    int     posMax;
    int     page;
    int     pos;
} SBDATA, *PSBDATA;

//-------------------------------------------------------------------------//
//  SBINFO is the set of values that hang off of a window structure, 
//  if the window has scrollbars.
typedef struct tagSBINFO 
{
    int     WSBflags;
    SBDATA  Horz;
    SBDATA  Vert;
} SBINFO, * PSBINFO;

//-------------------------------------------------------------------------//
//  SBCALC
//  Scrollbar metrics block.
typedef struct tagSBCALC
{
    SBDATA  data;               /* this must be first -- we cast structure pointers */
    int     pxTop;
    int     pxBottom;
    int     pxLeft;
    int     pxRight;
    int     cpxThumb;
    int     pxUpArrow;
    int     pxDownArrow;
    int     pxStart;         /* Initial position of thumb */
    int     pxThumbBottom;
    int     pxThumbTop;
    int     cpx;
    int     pxMin;
} SBCALC, *PSBCALC;

//-------------------------------------------------------------------------//
//  SBTRACK
//  Scrollbar thumb-tracking state block.
typedef struct tagSBTRACK {
    DWORD    fHitOld : 1;
    DWORD    fTrackVert : 1;
    DWORD    fCtlSB : 1;
    DWORD    fTrackRecalc: 1;
    HWND     hwndTrack;
    HWND     hwndSB;
    HWND     hwndSBNotify;
    RECT     rcTrack;
    VOID     (CALLBACK *pfnSB)(HWND, UINT, WPARAM, LPARAM, PSBCALC);
    UINT     cmdSB;
    UINT_PTR hTimerSB;
    int      dpxThumb;        /* Offset from mouse point to start of thumb box */
    int      pxOld;           /* Previous position of thumb */
    int      posOld;
    int      posNew;
    int      nBar;
    PSBCALC  pSBCalc;
} SBTRACK, *PSBTRACK;

//-------------------------------------------------------------------------//
//  Window scrollbars, control base.
class CUxScrollBar
//-------------------------------------------------------------------------//
{
public:
    CUxScrollBar();
    virtual ~CUxScrollBar() {}

    virtual BOOL          IsCtl() const { return FALSE;}
    operator HWND()       { return _hwnd; }
    static  CUxScrollBar* Calc(  HWND hwnd, PSBCALC pSBCalc, LPRECT prcOverrideClient, BOOL fVert); 
    virtual void          Calc2( PSBCALC pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert);
    virtual void          DoScroll( HWND hwndNotify, int cmd, int pos, BOOL fVert );

    virtual void          ClearTrack()  { ZeroMemory( &_track, sizeof(_track) ); }
    SBTRACK*              GetTrack()    { return &_track; }
    SBINFO*               GetInfo()     { return &_info; }
    HTHEME                GetTheme()    { return _hTheme; }
    BOOL                  IsAttaching() { return _fAttaching; }
    INT                   GetHotComponent(BOOL fVert) { return fVert ? _htVert : _htHorz; }
    VOID                  SetHotComponent(INT ht, BOOL fVert) { (fVert ? _htVert : _htHorz) = ht; }
    virtual void          ChangeSBTheme();
    virtual BOOL          FreshenSBData( int nBar, BOOL fRedraw );

    //  UxScrollBar API.
    static CUxScrollBar*  Attach( HWND hwnd, BOOL bCtl, BOOL fRedraw );
    static CUxScrollBar*  FromHwnd( HWND hwnd );
    static void           Detach( HWND hwnd );

    static SBTRACK*       GetSBTrack( HWND hwnd );
    static void           ClearSBTrack( HWND hwnd );
    static SBINFO*        GetSBInfo( HWND hwnd );
    static HTHEME         GetSBTheme( HWND hwnd );
    static INT            GetSBHotComponent( HWND hwnd, BOOL fVert);


protected:
    HWND        _hwnd;
    SBTRACK     _track;
    SBINFO      _info;
    INT         _htVert;            // Scroll bar part the mouse is currently over
    INT         _htHorz;            // Scroll bar part the mouse is currently over
    HTHEME      _hTheme;// Handle to theme manager
    BOOL        _fAttaching;
};

//-------------------------------------------------------------------------//
//  Scrollbar control
class CUxScrollBarCtl : public CUxScrollBar
//-------------------------------------------------------------------------//
{
public:
    CUxScrollBarCtl();

    virtual BOOL    IsCtl() const { return TRUE;}
    BOOL            AddRemoveDisableFlags( UINT wAdd, UINT wRemove );

    //  UxScrollBarCtl API.
    static CUxScrollBarCtl* FromHwnd( HWND hwnd );
    static UINT             GetDisableFlags( HWND hwnd );
    static SBCALC*          GetCalc( HWND hwnd );
    static BOOL             AddRemoveDisableFlags( HWND, UINT, UINT );
    static LRESULT CALLBACK WndProc( HWND, UINT, WPARAM, LPARAM );

    BOOL   _fVert;
    UINT   _wDisableFlags;      // Indicates which arrow is disabled;
    SBCALC _calc;
};

//-------------------------------------------------------------------------//
//  IsScrollBarControl
#ifdef PORTPORT
#define IsScrollBarControl(h) (GETFNID(h) == FNID_SCROLLBAR)
#else  //PORTPORT
inline BOOL IsScrollBarControl(HWND hwnd)   {
    return CUxScrollBarCtl::FromHwnd( hwnd ) != NULL;
}
#endif //PORTPORT

//-------------------------------------------------------------------------//
//  Forwards:
void           DrawScrollBar( HWND hwnd, HDC hdc, LPRECT prcOverrideClient, BOOL fVert);
HWND           SizeBoxHwnd( HWND hwnd );
VOID          _DrawPushButton( HWND hwnd, HDC hdc, LPRECT lprc, UINT state, UINT flags, BOOL fVert);
UINT          _GetWndSBDisableFlags(HWND, BOOL);
void CALLBACK _TrackThumb( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc);
void CALLBACK _TrackBox( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc);
void          _RedrawFrame( HWND hwnd );
BOOL          _FChildVisible( HWND hwnd );
LONG          _SetScrollBar( HWND hwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw);

HBRUSH        _UxGrayBrush(VOID);
void          _UxFreeGDIResources();

//-------------------------------------------------------------------------//
BOOL WINAPI InitScrollBarClass( HINSTANCE hInst )
{
    WNDCLASSEX wc;
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize = sizeof(wc);
    wc.style = CS_GLOBALCLASS|CS_PARENTDC|CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
    wc.lpfnWndProc = CUxScrollBarCtl::WndProc;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hInstance = hInst;
    wc.lpszClassName = WC_SCROLLBAR;
    wc.cbWndExtra = max(sizeof(CUxScrollBar), sizeof(CUxScrollBarCtl));
    return RegisterClassEx( &wc ) != 0;
}

//-------------------------------------------------------------------------//
//  CUxScrollBar impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
CUxScrollBar::CUxScrollBar()
    :   _hwnd(NULL), 
        _hTheme(NULL), 
        _htVert(HTNOWHERE), 
        _htHorz(HTNOWHERE), 
        _fAttaching(FALSE)
{
    ClearTrack();
    ZeroMemory( &_info, sizeof(_info) );
    _info.Vert.posMax = 100;    // ported from _InitPwSB
    _info.Horz.posMax = 100;    // ported from _InitPwSB
}

//-------------------------------------------------------------------------//
CUxScrollBar* CUxScrollBar::Attach( HWND hwnd, BOOL bCtl, BOOL fRedraw )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( NULL == psb )
    {
        psb = bCtl ? new CUxScrollBarCtl : new CUxScrollBar;

        if( psb != NULL )
        {
            ASSERT( psb->IsCtl() == bCtl );

            if( (! hwnd) || (! SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)), (HANDLE)psb ) ))
            {
                delete psb;
                psb = NULL;
            }
            else
            {
                psb->_hwnd = hwnd;
                psb->_fAttaching = TRUE;

                if (psb->IsCtl())
                {
                    psb->_hTheme = OpenThemeData(hwnd, L"ScrollBar");
                }
                else
                {
                    psb->_hTheme = OpenNcThemeData(hwnd, L"ScrollBar");

                    //
                    // window SBs must grovel for state data each 
                    // time attached [scotthan]
                    //
                    SCROLLINFO si;

                    ZeroMemory(&si, sizeof(si));
                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_ALL;
                    if (GetScrollInfo(hwnd, SB_VERT, &si))
                    {
                        si.fMask |= SIF_DISABLENOSCROLL;
                        _SetScrollBar(hwnd, SB_VERT, &si, FALSE);
                    }

                    ZeroMemory(&si, sizeof(si));
                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_ALL;
                    if (GetScrollInfo(hwnd, SB_HORZ, &si))
                    {
                        si.fMask |= SIF_DISABLENOSCROLL;
                        _SetScrollBar(hwnd, SB_HORZ, &si, FALSE);
                    }
                }

                psb->_fAttaching = FALSE;
            }
        }
    }

    return psb;
}

//-------------------------------------------------------------------------//
CUxScrollBar* CUxScrollBar::FromHwnd( HWND hwnd )
{
    if (! hwnd)
        return NULL;

    return (CUxScrollBar*)GetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)));
}

//-------------------------------------------------------------------------//
void CUxScrollBar::Detach( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if ( psb == NULL || !psb->_fAttaching )
    {
        if (hwnd)
        {
            RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)));
        }

        if( psb != NULL )
        {
            if ( psb->_hTheme )
            {
                CloseThemeData(psb->_hTheme);
            }
            delete psb;
        }
    }
}

//-------------------------------------------------------------------------//
void WINAPI AttachScrollBars( HWND hwnd )
{
    ASSERT( GetWindowLong( hwnd, GWL_STYLE ) & (WS_HSCROLL|WS_VSCROLL) );
    CUxScrollBar::Attach( hwnd, FALSE, FALSE );
}

//-------------------------------------------------------------------------//
void WINAPI DetachScrollBars( HWND hwnd )
{
    CUxScrollBar::Detach( hwnd );
}

//-------------------------------------------------------------------------//
SBTRACK* CUxScrollBar::GetSBTrack( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_track;
    return NULL;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::ClearSBTrack( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        psb->ClearTrack();
}

//-------------------------------------------------------------------------//
SBINFO* CUxScrollBar::GetSBInfo( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_info;
    return NULL;
}

//-------------------------------------------------------------------------//
HTHEME CUxScrollBar::GetSBTheme( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return psb->_hTheme;
    return NULL;
}

//-------------------------------------------------------------------------//
INT CUxScrollBar::GetSBHotComponent( HWND hwnd, BOOL fVert )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return psb->GetHotComponent(fVert);
    return 0;
}

//-------------------------------------------------------------------------//
BOOL CUxScrollBar::FreshenSBData( int nBar, BOOL fRedraw )
{
#ifdef __POLL_FOR_SCROLLINFO__

    ASSERT(IsWindow(_hwnd));

    if( !IsCtl() )
    {
        // Note scrollbar ctls don't go stale because
        // they receive SBM notifications
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask  = SIF_ALL;

        switch(nBar)
        {
            case SB_VERT:
            case SB_HORZ:
                if( GetScrollInfo( _hwnd, nBar, &si ) )
                {
                    _SetScrollBar( _hwnd, nBar, &si, fRedraw );
                }
                break;

            case SB_BOTH:
                return FreshenSBData( SB_VERT, fRedraw ) &&
                       FreshenSBData( SB_HORZ, fRedraw );
                break;

            default: return FALSE;
        }
    }
#endif __POLL_FOR_SCROLLINFO__

    return TRUE;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::ChangeSBTheme()
{
    if ( _hTheme )
    {
        CloseThemeData(_hTheme);
    }

    _hTheme = NULL;

    if (IsCtl())
        _hTheme = OpenThemeData(_hwnd, L"ScrollBar");
    else
        _hTheme = OpenNcThemeData(_hwnd, L"ScrollBar");
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
CUxScrollBarCtl::CUxScrollBarCtl()
    :   _wDisableFlags(0), _fVert(FALSE)
{
    ZeroMemory( &_calc, sizeof(_calc) );
}

//-------------------------------------------------------------------------//
CUxScrollBarCtl* CUxScrollBarCtl::FromHwnd( HWND hwnd )
{
    CUxScrollBarCtl* psb = (CUxScrollBarCtl*)CUxScrollBar::FromHwnd( hwnd );
    if( psb )
        return psb->IsCtl() ? psb : NULL;
    return NULL;
}

//-------------------------------------------------------------------------//
UINT CUxScrollBarCtl::GetDisableFlags( HWND hwnd )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return psb->_wDisableFlags;
    return 0;
}

//-------------------------------------------------------------------------//
SBCALC* CUxScrollBarCtl::GetCalc( HWND hwnd )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_calc;
    return NULL;
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl::AddRemoveDisableFlags() - static 
BOOL CUxScrollBarCtl::AddRemoveDisableFlags( HWND hwnd, UINT wAdd, UINT wRemove )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return psb->AddRemoveDisableFlags( wAdd, wRemove );
    return FALSE;
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl::AddRemoveDisableFlags() - instance member
BOOL CUxScrollBarCtl::AddRemoveDisableFlags( UINT wAdd, UINT wRemove )
{
    //  returns TRUE if flags changed, otherwise FALSE.
    UINT wOld = _wDisableFlags;
    _wDisableFlags |= wAdd;
    _wDisableFlags &= ~wRemove;
    return _wDisableFlags != wOld;
}

//-------------------------------------------------------------------------//
//  CUxScrollBar::Calc().  computes metrics for window SBs only.  
//  derives rect and calls Calc2.
CUxScrollBar* CUxScrollBar::Calc(
    HWND hwnd,
    PSBCALC pSBCalc,
    LPRECT prcOverrideClient,
    BOOL fVert)
{
    RECT    rcT;
#ifdef USE_MIRRORING
    int     cx, iTemp;
#endif

    //
    //  Get client rectangle in window-relative coords.  
    //  We know that window scrollbars always align to the right
    //  and to the bottom of the client area.
    //
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( !GetWindowInfo( hwnd, &wi ) )
        return NULL;
    OffsetRect( &wi.rcClient, -wi.rcWindow.left, -wi.rcWindow.top );

#ifdef USE_MIRRORING
    if (TestWF(hwnd, WEFLAYOUTRTL)) {
        cx                = wi.rcWindow.right - wi.rcWindow.left;
        iTemp             = wi.rcClient.left;
        wi.rcClient.left  = cx - wi.rcClient.right;
        wi.rcClient.right = cx - iTemp;
    }
#endif

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(hwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = wi.rcClient.left;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = wi.rcClient.right;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = wi.rcClient.top;
        rcT.bottom = wi.rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = wi.rcClient.bottom;
        if (TestWF(hwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = wi.rcClient.left;
        rcT.right = wi.rcClient.right;
    }

    if (prcOverrideClient)
    {
        rcT = *prcOverrideClient;
    }
    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    CUxScrollBar* psb = CUxScrollBar::Attach( hwnd, FALSE, FALSE );
    if( psb )
    {
        SBDATA*  pData = fVert ? &psb->_info.Vert : &psb->_info.Horz;
        if( psb )
            psb->Calc2( pSBCalc, &rcT, pData, fVert );
        return psb;
    }
    return NULL;
}

//-------------------------------------------------------------------------//
// CUxScrollBar::Calc2().  computes metrics for window SBs or SB ctls.  
void CUxScrollBar::Calc2( PSBCALC pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->data.pos = pw->pos;
    pSBCalc->data.page = pw->page;
    pSBCalc->data.posMin = pw->posMin;
    pSBCalc->data.posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->data.posMax - pSBCalc->data.posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing MulDiv twice.
         */
        int i = MulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = MulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::DoScroll( HWND hwndNotify, int cmd, int pos, BOOL fVert )
{
    HWND hwnd = _hwnd;
    
    //
    // Send scroll notification to the scrollbar owner. If this is a control
    // the lParam is the control's handle, NULL otherwise.
    //
    SendMessage(hwndNotify, 
                (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
                MAKELONG(cmd, pos), 
                (LPARAM)(IsCtl() ? _hwnd : NULL));

    //
    // The hwnd can have it's scrollbar removed as the result
    // of the previous sendmessge. 
    //
    if( CUxScrollBar::GetSBTrack(hwnd) && !IsCtl() )
    {
        FreshenSBData( fVert ? SB_VERT : SB_HORZ, TRUE );
    }
}


/*
 * Now it is possible to selectively Enable/Disable just one arrow of a Window
 * scroll bar; Various bits in the 7th word in the rgwScroll array indicates which
 * one of these arrows are disabled; The following masks indicate which bit of the
 * word indicates which arrow;
 */
#define WSB_HORZ_LF  0x0001  // Represents the Left arrow of the horizontal scroll bar.
#define WSB_HORZ_RT  0x0002  // Represents the Right arrow of the horizontal scroll bar.
#define WSB_VERT_UP  0x0004  // Represents the Up arrow of the vert scroll bar.
#define WSB_VERT_DN  0x0008  // Represents the Down arrow of the vert scroll bar.

#define WSB_VERT (WSB_VERT_UP | WSB_VERT_DN)
#define WSB_HORZ   (WSB_HORZ_LF | WSB_HORZ_RT)

void DrawCtlThumb( SBHWND );

/*
 * RETURN_IF_PSBTRACK_INVALID:
 * This macro tests whether the pSBTrack we have is invalid, which can happen
 * if it gets freed during a callback.
 * This protects agains the original pSBTrack being freed and no new one
 * being allocated or a new one being allocated at a different address.
 * This does not protect against the original pSBTrack being freed and a new
 * one being allocated at the same address.
 * If pSBTrack has changed, we assert that there is not already a new one
 * because we are really not expecting this.
 */
#define RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd) \
    if ((pSBTrack) != CUxScrollBar::GetSBTrack(hwnd)) {      \
        ASSERT(CUxScrollBar::GetSBTrack(hwnd) == NULL);  \
        return;                                    \
    }

/*
 * REEVALUATE_PSBTRACK
 * This macro just refreshes the local variable pSBTrack, in case it has
 * been changed during a callback.  After performing this operation, pSBTrack
 * should be tested to make sure it is not now NULL.
 */

#if (defined(DBG) || defined(DEBUG) || defined(_DEBUG))
    #define REEVALUATE_PSBTRACK(pSBTrack, hwnd, str)          \
        if ((pSBTrack) != CUxScrollBar::GetSBTrack(hwnd)) {             \
            RIPMSG3(RIP_WARNING,                              \
                    "%s: pSBTrack changed from %#p to %#p",   \
                    (str), (pSBTrack), CUxScrollBar::GetSBTrack(hwnd)); \
        }                                                     \
        (pSBTrack) = CUxScrollBar::GetSBTrack(hwnd)
#else
    #define REEVALUATE_PSBTRACK(pSBTrack, hwnd, str)          \
        (pSBTrack) = CUxScrollBar::GetSBTrack(hwnd)
#endif

/***************************************************************************\
* HitTestScrollBar
*
* 11/15/96      vadimg          ported from Memphis sources
\***************************************************************************/

int HitTestScrollBar(HWND hwnd, BOOL fVert, POINT pt)
{
    UINT wDisable;
    int px;
    CUxScrollBar*    psb    = CUxScrollBar::FromHwnd( hwnd );
    CUxScrollBarCtl* psbCtl = CUxScrollBarCtl::FromHwnd( hwnd );
    BOOL fCtl = psbCtl != NULL;

    SBCALC SBCalc = {0};
    SBCALC *pSBCalc = NULL;

    if (fCtl) {
        wDisable = psbCtl->_wDisableFlags;
    } else {
        RECT rcWindow;
        GetWindowRect( hwnd, &rcWindow );
#ifdef USE_MIRRORING
        //
        // Reflect the click coordinates on the horizontal
        // scroll bar if the window is mirrored
        //
        if (TestWF(hwnd,WEFLAYOUTRTL) && !fVert) {
            pt.x = rcWindow.right - pt.x;
        }
        else
#endif
        pt.x -= rcWindow.left;
        pt.y -= rcWindow.top;
        wDisable = _GetWndSBDisableFlags(hwnd, fVert);
    }

    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return HTERROR;
    }

    if (fCtl) {
        pSBCalc = CUxScrollBarCtl::GetCalc(hwnd);
    } else {
        pSBCalc = &SBCalc;
        psb->FreshenSBData( SB_BOTH, FALSE );
        psb->Calc(hwnd, pSBCalc, NULL, fVert);
    }

    px = fVert ? pt.y : pt.x;

    if( pSBCalc )
    {
        if (px < pSBCalc->pxUpArrow) {
            if (wDisable & LTUPFLAG) {
                return HTERROR;
            }
            return HTSCROLLUP;
        } else if (px >= pSBCalc->pxDownArrow) {
            if (wDisable & RTDNFLAG) {
                return HTERROR;
            }
            return HTSCROLLDOWN;
        } else if (px < pSBCalc->pxThumbTop) {
            return HTSCROLLUPPAGE;
        } else if (px < pSBCalc->pxThumbBottom) {
            return HTSCROLLTHUMB;
        } else if (px < pSBCalc->pxDownArrow) {
            return HTSCROLLDOWNPAGE;
        }
    }
    return HTERROR;
}

BOOL _SBGetParms(
    HWND hwnd,
    int code,
    PSBDATA pw,
    LPSCROLLINFO lpsi)
{
    PSBTRACK pSBTrack;

    pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    if (lpsi->fMask & SIF_RANGE) {
        lpsi->nMin = pw->posMin;
        lpsi->nMax = pw->posMax;
    }

    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw->page;

    if (lpsi->fMask & SIF_POS) {
        lpsi->nPos = pw->pos;
    }

    if (lpsi->fMask & SIF_TRACKPOS)
    {
        if (pSBTrack && (pSBTrack->nBar == code) && (pSBTrack->hwndTrack == hwnd)) {
            // posNew is in the context of psbiSB's window and bar code
            lpsi->nTrackPos = pSBTrack->posNew;
        } else {
            lpsi->nTrackPos = pw->pos;
        }
    }
    return ((lpsi->fMask & SIF_ALL) ? TRUE : FALSE);
}

//-------------------------------------------------------------------------//
BOOL WINAPI ThemeGetScrollInfo( HWND hwnd, int nBar, LPSCROLLINFO psi )
{
    CUxScrollBar* psb = CUxScrollBar::FromHwnd(hwnd);
    if((psb != NULL) && (psb->IsAttaching() == FALSE))
    {
#ifdef DEBUG
        if( psb->IsCtl() )
        {
            ASSERT(FALSE); // controls cooperate through an SBM_GETSCROLLINFO message.
        }
        else
#endif DEBUG
        {
            SBINFO* psbi;
            if( (psbi = psb->GetInfo()) != NULL )
            {
                SBDATA* psbd = SB_VERT == nBar ? &psbi->Vert :
                               SB_HORZ == nBar ? &psbi->Horz : NULL;
                if( psbd )
                    return _SBGetParms( hwnd, nBar, psbd, psi );
            }
        }
    }
    return FALSE;
}

/***************************************************************************\
* _GetWndSBDisableFlags
*
* This returns the scroll bar Disable flags of the scroll bars of a
*  given Window.
*
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

UINT _GetWndSBDisableFlags(
    HWND hwnd,  // The window whose scroll bar Disable Flags are to be returned;
    BOOL fVert)  // If this is TRUE, it means Vertical scroll bar.
{
    PSBINFO pw;

    if ((pw = CUxScrollBar::GetSBInfo( hwnd )) == NULL) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    return (fVert ? (pw->WSBflags & WSB_VERT) >> 2 : pw->WSBflags & WSB_HORZ);
}


/***************************************************************************\
*  xxxEnableSBCtlArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar Control
*
* History:
* 04-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableSBCtlArrows(
    HWND hwnd,
    UINT wArrows)
{
    UINT wOldFlags = CUxScrollBarCtl::GetDisableFlags( hwnd ); // Get the original status
    BOOL bChanged  = FALSE;

    if (wArrows == ESB_ENABLE_BOTH) {      // Enable both the arrows
        bChanged = CUxScrollBarCtl::AddRemoveDisableFlags( hwnd, 0, SB_DISABLE_MASK );
    } else {
        bChanged = CUxScrollBarCtl::AddRemoveDisableFlags( hwnd, wArrows, 0 );
    }

    /*
     * Check if the status has changed because of this call
     */
    if (!bChanged)
        return FALSE;

    /*
     * Else, redraw the scroll bar control to reflect the new state
     */
    if (IsWindowVisible(hwnd))
        InvalidateRect(hwnd, NULL, TRUE);

    UINT wNewFlags = CUxScrollBarCtl::GetDisableFlags(hwnd);

    // state change notifications
    if ((wOldFlags & ESB_DISABLE_UP) != (wNewFlags & ESB_DISABLE_UP))
    {
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_UP);
    }

    if ((wOldFlags & ESB_DISABLE_DOWN) != (wNewFlags & ESB_DISABLE_DOWN))
    {
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_DOWN);
    }

    return TRUE;
}


/***************************************************************************\
* xxxEnableWndSBArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a Window Scroll bar(s)
*
* History:
*  4-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableWndSBArrows(
    HWND hwnd,
    UINT wSBflags,
    UINT wArrows)
{
    INT wOldFlags;
    PSBINFO pw;
    BOOL bRetValue = FALSE;
    HDC hdc;

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if ((pw = CUxScrollBar::GetSBInfo( hwnd )) != NULL)
    {
        wOldFlags = pw->WSBflags;
    }
    else
    {
        // Originally everything is enabled; Check to see if this function is
        // asked to disable anything; Otherwise, no change in status; So, must
        // return immediately;
        if(!wArrows)
            return FALSE;          // No change in status!

        wOldFlags = 0;    // Both are originally enabled;

        CUxScrollBar::Attach( hwnd, FALSE, FALSE );
        if((pw = CUxScrollBar::GetSBInfo(hwnd)) == NULL)  // Allocate the pSBInfo for hWnd
            return FALSE;
    }

    hdc = GetWindowDC(hwnd);
    if (hdc != NULL)
    {

        /*
         *  First Take care of the Horizontal Scroll bar, if one exists.
         */
        if((wSBflags == SB_HORZ) || (wSBflags == SB_BOTH)) {
            if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
                pw->WSBflags &= ~SB_DISABLE_MASK;
            else
                pw->WSBflags |= wArrows;

            /*
             * Update the display of the Horizontal Scroll Bar;
             */
            if(pw->WSBflags != wOldFlags) {
                bRetValue = TRUE;
                wOldFlags = pw->WSBflags;
                if (TestWF(hwnd, WFHPRESENT) && !TestWF(hwnd, WFMINIMIZED) &&
                        IsWindowVisible(hwnd)) {
                    DrawScrollBar(hwnd, hdc, NULL, FALSE);  // Horizontal Scroll Bar.
                }
            }

            // Left button
            if ((wOldFlags & ESB_DISABLE_LEFT) != (pw->WSBflags & ESB_DISABLE_LEFT))
            {
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_HSCROLL, INDEX_SCROLLBAR_UP);
            }

            // Right button
            if ((wOldFlags & ESB_DISABLE_RIGHT) != (pw->WSBflags & ESB_DISABLE_RIGHT))
            {
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_HSCROLL, INDEX_SCROLLBAR_DOWN);
            }
        }

        // Then take care of the Vertical Scroll bar, if one exists.
        if ((wSBflags == SB_VERT) || (wSBflags == SB_BOTH))
        {
            if (wArrows == ESB_ENABLE_BOTH)
            {
                // Enable both the arrows
                pw->WSBflags &= ~(SB_DISABLE_MASK << 2);
            }
            else
            {
                pw->WSBflags |= (wArrows << 2);
            }

            // Update the display of the Vertical Scroll Bar;
            if(pw->WSBflags != wOldFlags)
            {
                bRetValue = TRUE;
                if (TestWF(hwnd, WFVPRESENT) && !TestWF(hwnd, WFMINIMIZED) && IsWindowVisible(hwnd))
                {
                    // Vertical Scroll Bar
                    DrawScrollBar(hwnd, hdc, NULL, TRUE);
                }

                // Up button
                if ((wOldFlags & (ESB_DISABLE_UP << 2)) != (pw->WSBflags & (ESB_DISABLE_UP << 2)))
                {
                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_VSCROLL, INDEX_SCROLLBAR_UP);
                }

                // Down button
                if ((wOldFlags & (ESB_DISABLE_DOWN << 2)) != (pw->WSBflags & (ESB_DISABLE_DOWN << 2)))
                {
                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_VSCROLL, INDEX_SCROLLBAR_DOWN);
                }
            }
        }

        ReleaseDC(hwnd,hdc);
    }

    return bRetValue;
}


/***************************************************************************\
* EnableScrollBar()
*
* This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar; It could be used with Windows Scroll
*     bars as well as scroll bar controls
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableScrollBar(
    HWND hwnd,
    UINT wSBflags,  // Whether it is a Window Scroll Bar; if so, HORZ or VERT?
                    // Possible values are SB_HORZ, SB_VERT, SB_CTL or SB_BOTH
    UINT wArrows)   // Which arrows must be enabled/disabled:
                    // ESB_ENABLE_BOTH = > Enable both arrows.
                    // ESB_DISABLE_LTUP = > Disable Left/Up arrow;
                    // ESB_DISABLE_RTDN = > DIsable Right/Down arrow;
                    // ESB_DISABLE_BOTH = > Disable both the arrows;
{
#define ES_NOTHING 0
#define ES_DISABLE 1
#define ES_ENABLE  2
    UINT wOldFlags;
    UINT wEnableWindow;

    CheckLock(hwnd);

    if(wSBflags != SB_CTL) {
        return xxxEnableWndSBArrows(hwnd, wSBflags, wArrows);
    }

    /*
     *  Let us assume that we don't have to call EnableWindow
     */
    wEnableWindow = ES_NOTHING;

    wOldFlags = CUxScrollBarCtl::GetDisableFlags( hwnd ) & (UINT)SB_DISABLE_MASK;

    /*
     * Check if the present state of the arrows is exactly the same
     *  as what the caller wants:
     */
    if (wOldFlags == wArrows)
        return FALSE ;          // If so, nothing needs to be done;

    /*
     * Check if the caller wants to disable both the arrows
     */
    if (wArrows == ESB_DISABLE_BOTH) {
        wEnableWindow = ES_DISABLE;      // Yes! So, disable the whole SB Ctl.
    } else {

        /*
         * Check if the caller wants to enable both the arrows
         */
        if(wArrows == ESB_ENABLE_BOTH) {

            /*
             * We need to enable the SB Ctl only if it was already disabled.
             */
            if(wOldFlags == ESB_DISABLE_BOTH)
                wEnableWindow = ES_ENABLE;// EnableWindow(.., TRUE);
        } else {

            /*
             * Now, Caller wants to disable only one arrow;
             * Check if one of the arrows was already disabled and we want
             * to disable the other;If so, the whole SB Ctl will have to be
             * disabled; Check if this is the case:
             */
            if((wOldFlags | wArrows) == ESB_DISABLE_BOTH)
                wEnableWindow = ES_DISABLE;      // EnableWindow(, FALSE);
         }
    }
    if(wEnableWindow != ES_NOTHING) {

        /*
         * EnableWindow returns old state of the window; We must return
         * TRUE only if the Old state is different from new state.
         */
        if(EnableWindow(hwnd, (BOOL)(wEnableWindow == ES_ENABLE))) {
            return !(TestWF(hwnd, WFDISABLED));
        } else {
            return TestWF(hwnd, WFDISABLED);
        }
    }

    return (BOOL)SendMessage(hwnd, SBM_ENABLE_ARROWS, (DWORD)wArrows, 0);
#undef ES_NOTHING
#undef ES_DISABLE
#undef ES_ENABLE
}

//-------------------------------------------------------------------------
BOOL WINAPI ThemeEnableScrollBar( HWND hwnd, UINT nSBFlags, UINT nArrows )
{
    return xxxEnableScrollBar( hwnd, nSBFlags, nArrows );
}


//-------------------------------------------------------------------------
//
// DrawSizeBox() - paints the scrollbar sizebox/gripper given top, left
// point in window coords.
//
void DrawSizeBox(HWND hwnd, HDC hdc, int x, int y)
{
    RECT rc;

    SetRect(&rc, x, y, x + SYSMET(CXVSCROLL), y + SYSMET(CYHSCROLL));
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    //
    // If we have a scrollbar control, or the sizebox is not associated with
    // a sizeable window, draw the flat gray sizebox.  Otherwise, use the
    // sizing grip.
    //

    if ((IsScrollBarControl(hwnd) && TestWF(hwnd, SBFSIZEGRIP)) || SizeBoxHwnd(hwnd))
    {
        HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

        if (!hTheme)
        {
            // Blt out the grip bitmap.
            DrawFrameControl( hdc, &rc, DFC_SCROLL,
                              TestWF(hwnd, WEFLEFTSCROLL) ? DFCS_SCROLLSIZEGRIPRIGHT : DFCS_SCROLLSIZEGRIP );
            
            //user: BitBltSysBmp(hdc, x, y, TestWF(hwnd, WEFLEFTSCROLL) ? OBI_NCGRIP_L : OBI_NCGRIP);
        }
        else
        {
            DrawThemeBackground(hTheme, hdc, SBP_SIZEBOX, TestWF(hwnd, WEFLEFTSCROLL) ? SZB_LEFTALIGN : SZB_RIGHTALIGN, &rc, 0);
        }
    }
}


//-------------------------------------------------------------------------
//
// _DrawSizeBoxFromFrame
//
// Calculates position and draws of sizebox/gripper at fixed offset from
// perimeter of host window frame.
//
// This, combined with implementation of DrawSizeBox(), 
// was the original DrawSize() port.  Needed to expost method to
// draw sizebox at absolute position.  [scotthan]
//
void _DrawSizeBoxFromFrame(HWND hwnd, HDC hdc, int cxFrame,int cyFrame )
{
    int     x, y;
    RECT    rcWindow;

    GetWindowRect(hwnd, &rcWindow);

    if (TestWF(hwnd, WEFLEFTSCROLL)) 
    {
        x = cxFrame;
    } 
    else 
    {
        x = rcWindow.right - rcWindow.left - cxFrame - SYSMET(CXVSCROLL);
    }

    y = rcWindow.bottom - rcWindow.top  - cyFrame - SYSMET(CYHSCROLL);

    DrawSizeBox(hwnd, hdc, x, y);
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetControlColor(HWND hwndParent, HWND hwndCtl, HDC hdc, UINT uMsg, BOOL *pfOwnerBrush)
{
    HBRUSH hbrush;
    BOOL   fOwnerBrush = FALSE;

    //
    // If we're sending to a window of another thread, don't send this message
    // but instead call DefWindowProc().  New rule about the CTLCOLOR messages.
    // Need to do this so that we don't send an hdc owned by one thread to
    // another thread.  It is also a harmless change.
    //
    if (GetWindowThreadProcessId(hwndParent, NULL) != GetCurrentThreadId()) 
    {
        hbrush = (HBRUSH)DefWindowProc(hwndParent, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);
    }
    else
    {
        hbrush = (HBRUSH)SendMessage(hwndParent, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);

        //
        // If the brush returned from the parent is invalid, get a valid brush from
        // DefWindowProc.
        //
        if (hbrush == NULL) 
        {
            hbrush = (HBRUSH)DefWindowProc(hwndParent, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);
        }
        else
        {
            fOwnerBrush = TRUE;
        }
    }

    if (pfOwnerBrush)
    {
        *pfOwnerBrush = fOwnerBrush;
    }

    return hbrush;
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetControlBrush(HWND hwnd, HDC hdc, UINT uMsg, BOOL *pfOwnerBrush)
{
    HWND hwndSend;

    hwndSend = TESTFLAG(GetWindowStyle(hwnd), WS_POPUP) ? GetOwner(hwnd) : GetParent(hwnd);
    if (hwndSend == NULL)
    {
        hwndSend = hwnd;
    }

    return ScrollBar_GetControlColor(hwndSend, hwnd, hdc, uMsg, pfOwnerBrush);
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetColorObjects(HWND hwnd, HDC hdc, BOOL *pfOwnerBrush)
{
    HBRUSH hbrRet;

    CheckLock(hwnd);

    // Use the scrollbar color even if the scrollbar is disabeld.
    if (!IsScrollBarControl(hwnd))
    {
        hbrRet = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)HWq(hwnd));
    }
    else 
    {
        // B#12770 - GetControlBrush sends a WM_CTLCOLOR message to the
        // owner.  If the app doesn't process the message, DefWindowProc32
        // will always return the appropriate system brush. If the app.
        // returns an invalid object, GetControlBrush will call DWP for
        // the default brush. Thus hbrRet doesn't need any validation
        // here.
        hbrRet = ScrollBar_GetControlBrush(hwnd, hdc, WM_CTLCOLORSCROLLBAR, pfOwnerBrush);
    }

    return hbrRet;
}


//-------------------------------------------------------------------------
//
// ScrollBar_PaintTrack
//
// Draws lines & middle of thumb groove
// Note that pw points into prc.  Moreover, note that both pw & prc are
// pointers, so *prc better not be on the stack.
//
void ScrollBar_PaintTrack(HWND hwnd, HDC hdc, HBRUSH hbr, LPRECT prc, BOOL fVert, INT iPartId, BOOL fOwnerBrush)
{
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    // If the scrollbar is unthemed or 
    // #374054 we've been passed an brush defined by the owner, paint 
    // the shaft using the brush 
    if ((hTheme == NULL) || (fOwnerBrush == TRUE))
    {
        if ((hbr == SYSHBR(3DHILIGHT)) || (hbr == SYSHBR(SCROLLBAR)) || (hbr == _UxGrayBrush()) )
        {
            FillRect(hdc, prc, hbr);
        }
        else
        {
    #ifdef PORTPORT // we need SystemParametersInfo for _UxGrayBrush
        // Draw sides
           CopyRect(&rc, prc);
           DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_FLAT |
                    (fVert ? BF_LEFT | BF_RIGHT : BF_TOP | BF_BOTTOM));
    #endif PORTPORT

        // Fill middle
            FillRect(hdc, prc, hbr);
        }
    }
    else
    {
        INT iStateId;
        INT ht = CUxScrollBar::GetSBHotComponent(hwnd, fVert);
        
        if ((CUxScrollBarCtl::GetDisableFlags(hwnd) & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)
        {
            iStateId = SCRBS_DISABLED;
        }
        else if ((((iPartId == SBP_LOWERTRACKHORZ) || (iPartId == SBP_LOWERTRACKVERT)) && (ht == HTSCROLLUPPAGE)) ||
                 (((iPartId == SBP_UPPERTRACKHORZ) || (iPartId == SBP_UPPERTRACKVERT)) && (ht == HTSCROLLDOWNPAGE)))
        {
            iStateId = SCRBS_HOT;
       }
        else
        {
            iStateId = SCRBS_NORMAL;
        }
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, prc, 0);
    }
}

/***************************************************************************\
* CalcTrackDragRect
*
* Give the rectangle for a scrollbar in pSBTrack->pSBCalc,
* calculate pSBTrack->rcTrack, the rectangle where tracking
* may occur without cancelling the thumbdrag operation.
*
\***************************************************************************/

void CalcTrackDragRect(PSBTRACK pSBTrack) {

    int     cx;
    int     cy;
    LPINT   pwX, pwY;

    //
    // Point pwX and pwY at the parts of the rectangle
    // corresponding to pSBCalc->pxLeft, pxTop, etc.
    //
    // pSBTrack->pSBCalc->pxLeft is the left edge of a vertical
    // scrollbar and the top edge of horizontal one.
    // pSBTrack->pSBCalc->pxTop is the top of a vertical
    // scrollbar and the left of horizontal one.
    // etc...
    //
    // Point pwX and pwY to the corresponding parts
    // of pSBTrack->rcTrack.
    //

    pwX = pwY = (LPINT)&pSBTrack->rcTrack;

    if (pSBTrack->fTrackVert) {
        cy = SYSMET(CYVTHUMB);
        pwY++;
    } else {
        cy = SYSMET(CXHTHUMB);
        pwX++;
    }
    /*
     * Later5.0 GerardoB: People keep complaining about this tracking region
     *  being too narrow so let's make it wider while PM decides what to do
     *  about it.
     * We also used to have some hard coded min and max values but that should
     *  depend on some metric, if at all needed.
     */
    cx = (pSBTrack->pSBCalc->pxRight - pSBTrack->pSBCalc->pxLeft) * 8;
    cy *= 2;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft - cx;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop - cy;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight + cx;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom + cy;
}

void RecalcTrackRect(PSBTRACK pSBTrack) {
    LPINT pwX, pwY;
    RECT rcSB;


    if (!pSBTrack->fCtlSB)
        CUxScrollBar::Calc(pSBTrack->hwndTrack, pSBTrack->pSBCalc, NULL, pSBTrack->fTrackVert);

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom;

    switch(pSBTrack->cmdSB) {
    case SB_LINEUP:
        *(pwY + 2) = pSBTrack->pSBCalc->pxUpArrow;
        break;
    case SB_LINEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    case SB_PAGEUP:
        *(pwY + 0) = pSBTrack->pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBTrack->pSBCalc->pxThumbTop;
        break;
    case SB_THUMBPOSITION:
        CalcTrackDragRect(pSBTrack);
        break;
    case SB_PAGEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    }

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }
}

//-------------------------------------------------------------------------
void DrawThumb2(
    HWND    hwnd,
    PSBCALC pSBCalc,
    HDC     hdc,
    HBRUSH  hbr,
    BOOL    fVert,
    UINT    wDisable,       // Disabled flags for the scroll bar
    BOOL    fOwnerBrush)
{
    int    *pLength;
    int    *pWidth;
    RECT   rcSB;
    PSBTRACK pSBTrack;
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    //
    // Bail out if the scrollbar has an empty rect
    //
    if ((pSBCalc->pxTop >= pSBCalc->pxBottom) || (pSBCalc->pxLeft >= pSBCalc->pxRight))
    {
        return;
    }

    pLength = (LPINT)&rcSB;
    if (fVert)
    {
        pWidth = pLength++;
    }
    else
    {
        pWidth  = pLength + 1;
    }

    pWidth[0] = pSBCalc->pxLeft;
    pWidth[2] = pSBCalc->pxRight;

    // If were're not themed and both buttons are disabled OR there isn't
    // enough room to draw a thumb just draw the track and run.
    //
    // When we are themed the thumb can be drawn disabled.
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) || 
        ((pSBCalc->pxDownArrow - pSBCalc->pxUpArrow) < pSBCalc->cpxThumb))
    {
        // draw the entire track
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxDownArrow;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ, fOwnerBrush);
        return;
    }

    if (pSBCalc->pxUpArrow < pSBCalc->pxThumbTop)
    {
        // draw the track above the thumb
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxThumbTop;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ, fOwnerBrush);
    }

    if (pSBCalc->pxThumbBottom < pSBCalc->pxDownArrow)
    {
        // draw the track below the thumb
        pLength[0] = pSBCalc->pxThumbBottom;
        pLength[2] = pSBCalc->pxDownArrow;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ, fOwnerBrush);
    }

    //
    // Draw elevator
    //
    pLength[0] = pSBCalc->pxThumbTop;
    pLength[2] = pSBCalc->pxThumbBottom;

    // Not soft!
    _DrawPushButton(hwnd, hdc, &rcSB, 0, 0, fVert);

#ifdef _VISUAL_DELTA_
    InflateRect( &rcSB, -CARET_BORDERWIDTH, -CARET_BORDERWIDTH);
    DrawEdge( hdc, &rcSB, EDGE_SUNKEN, BF_RECT );
#endif _VISUAL_DELTA_

    /*
     * If we're tracking a page scroll, then we've obliterated the hilite.
     * We need to correct the hiliting rectangle, and rehilite it.
     */
    pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    if (pSBTrack && (pSBTrack->cmdSB == SB_PAGEUP || pSBTrack->cmdSB == SB_PAGEDOWN) &&
            (hwnd == pSBTrack->hwndTrack) &&
            (BOOL)pSBTrack->fTrackVert == fVert) {

        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        pLength = (int *)&pSBTrack->rcTrack;

        if (fVert)
            pLength++;

        if (pSBTrack->cmdSB == SB_PAGEUP)
            pLength[2] = pSBCalc->pxThumbTop;
        else
            pLength[0] = pSBCalc->pxThumbBottom;

        if (pLength[0] < pLength[2])
        {
            if (!hTheme)
            {
                InvertRect(hdc, &pSBTrack->rcTrack);
            }
            else
            {
                DrawThemeBackground(hTheme, 
                                    hdc, 
                                    pSBTrack->cmdSB == SB_PAGEUP ? 
                                        (fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ) : 
                                        (fVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ), 
                                    SCRBS_PRESSED, 
                                    &pSBTrack->rcTrack, 
                                    0);
            }
        }
    }
}

/***************************************************************************\
* xxxDrawSB2
*
*
*
* History:
\***************************************************************************/

void xxxDrawSB2(
    HWND hwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    BOOL fVert,
    UINT wDisable)
{

    int      cLength;
    int      cWidth;
    int      *pwX;
    int      *pwY;
    HBRUSH   hbr;
    HBRUSH   hbrSave;
    int      cpxArrow;
    RECT     rc, rcSB;
    COLORREF crText, crBk;
    HTHEME   hTheme;
    INT      ht;
    INT      iStateId;
    BOOL     fOwnerBrush = FALSE;

    CheckLock(hwnd);

    cLength = (pSBCalc->pxBottom - pSBCalc->pxTop) / 2;
    cWidth = (pSBCalc->pxRight - pSBCalc->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0)) {
        return;
    }

    if (fVert)
    {
        cpxArrow = SYSMET(CYVSCROLL);
    }
    else
    {
        cpxArrow = SYSMET(CXHSCROLL);
    }

    // Save background and DC color, since they get changed in
    // ScrollBar_GetColorObjects. Restore before we return.
    crBk = GetBkColor(hdc);
    crText = GetTextColor(hdc);

    hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);

    if (cLength > cpxArrow)
    {
        cLength = cpxArrow;
    }

    pwX = (int *)&rcSB;
    pwY = pwX + 1;
    if (!fVert)
    {
        pwX = pwY--;
    }

    pwX[0] = pSBCalc->pxLeft;
    pwY[0] = pSBCalc->pxTop;
    pwX[2] = pSBCalc->pxRight;
    pwY[2] = pSBCalc->pxBottom;

    hbrSave = SelectBrush(hdc, SYSHBR(BTNTEXT));

    //
    // BOGUS
    // Draw scrollbar arrows as disabled if the scrollbar itself is
    // disabled OR if the window it is a part of is disabled?
    //
    hTheme = CUxScrollBar::GetSBTheme(hwnd);
    ht     = CUxScrollBar::GetSBHotComponent(hwnd, fVert);
    if (fVert) 
    {
        // up button
        CopyRect(&rc, &rcSB);
        rc.bottom = rc.top + cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLUP | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & LTUPFLAG) ? ABS_UPDISABLED : (ht == HTSCROLLUP) ? ABS_UPHOT : ABS_UPNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }

        // down button
        rc.bottom = rcSB.bottom;
        rc.top = rcSB.bottom - cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLDOWN | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & RTDNFLAG) ? ABS_DOWNDISABLED : (ht == HTSCROLLDOWN) ? ABS_DOWNHOT : ABS_DOWNNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }
    } 
    else 
    {
        // left button
        CopyRect(&rc, &rcSB);
        rc.right = rc.left + cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLLEFT | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & LTUPFLAG) ? ABS_LEFTDISABLED : (ht == HTSCROLLUP) ? ABS_LEFTHOT : ABS_LEFTNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }

        // right button
        rc.right = rcSB.right;
        rc.left = rcSB.right - cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLRIGHT | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & RTDNFLAG) ? ABS_RIGHTDISABLED : (ht == HTSCROLLDOWN) ? ABS_RIGHTHOT : ABS_RIGHTNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }
    }

    hbrSave = SelectBrush(hdc, hbrSave);
    DrawThumb2(hwnd, pSBCalc, hdc, hbr, fVert, wDisable, fOwnerBrush);
    SelectBrush(hdc, hbrSave);

    SetBkColor(hdc, crBk);
    SetTextColor(hdc, crText);
}

/***************************************************************************\
* zzzSetSBCaretPos
*
*
*
* History:
\***************************************************************************/

void zzzSetSBCaretPos(
    SBHWND hwndSB)
{

    if (GetFocus() == hwndSB) {
        CUxScrollBarCtl* psb = CUxScrollBarCtl::FromHwnd( hwndSB );
        if( psb )
        {
            int x = (psb->_fVert ? psb->_calc.pxLeft : psb->_calc.pxThumbTop) + SYSMET(CXEDGE);
            int y = (psb->_fVert ? psb->_calc.pxThumbTop : psb->_calc.pxLeft) + SYSMET(CYEDGE);

#ifdef _VISUAL_DELTA_
            x += CARET_BORDERWIDTH;
            y += CARET_BORDERWIDTH;
#endif _VISUAL_DELTA_

            SetCaretPos( x, y );
        }
    }
}

/***************************************************************************\
* CalcSBStuff2
*
*
*
* History:
\***************************************************************************/

void CalcSBStuff2(
    PSBCALC  pSBCalc,
    LPRECT lprc,
    CONST PSBDATA pw,
    BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->data.pos = pw->pos;
    pSBCalc->data.page = pw->page;
    pSBCalc->data.posMin = pw->posMin;
    pSBCalc->data.posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->data.posMax - pSBCalc->data.posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing MulDiv twice.
         */
        int i = MulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = MulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

}

/***************************************************************************\
* SBCtlSetup
*
*
*
* History:
\***************************************************************************/

CUxScrollBarCtl* SBCtlSetup(
    SBHWND hwndSB)
{
    RECT rc;
    GetClientRect( hwndSB, &rc );
    CUxScrollBarCtl* psb = (CUxScrollBarCtl*)CUxScrollBar::Attach( hwndSB, TRUE, FALSE );
    if( psb )
    {
        psb->Calc2( &psb->_calc, &rc, &psb->_calc.data, psb->_fVert );
    }
    return psb;
}

/***************************************************************************\
* HotTrackSB
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

DWORD GetTrackFlags(int ht, BOOL fDraw)
{
    if (fDraw) {
        switch(ht) {
        case HTSCROLLUP:
        case HTSCROLLUPPAGE:
            return LTUPFLAG;

        case HTSCROLLDOWN:
        case HTSCROLLDOWNPAGE:
            return RTDNFLAG;

        case HTSCROLLTHUMB:
            return LTUPFLAG | RTDNFLAG;

        default:
            return 0;
        }
    } else {
        return 0;
    }
}

BOOL xxxHotTrackSB(HWND hwnd, int htEx, BOOL fDraw)
{
    SBCALC SBCalc;
    HDC  hdc;
    BOOL fVert = HIWORD(htEx);
    int ht = LOWORD(htEx);
    DWORD dwTrack = GetTrackFlags(ht, fDraw);

    CheckLock(hwnd);

    /*
     * xxxDrawSB2 does not callback or leave the critical section when it's
     * not a SB control and the window belongs to a different thread. It
     * calls DefWindowProc which simply returns the brush color.
     */
    CalcSBStuff(hwnd, &SBCalc, fVert);
    hdc = _GetDCEx(hwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2(hwnd, &SBCalc, hdc, fVert, _GetWndSBDisableFlags(hwnd, fVert), dwTrack);
    ReleaseDC(hwnd, hdc);
    return TRUE;
}

void xxxHotTrackSBCtl(SBHWND hwndSB, int ht, BOOL fDraw)
{
    DWORD dwTrack = GetTrackFlags(ht, fDraw);
    HDC hdc;

    CheckLock(hwndSB);

    SBCtlSetup(hwndSB);
    hdc = _GetDCEx((HWND)hwndSB, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2((HWND)hwndSB, &psb->_calc, hdc, psb->_fVert, psb->_wDisableFlags, dwTrack);
    ReleaseDC(hwnd, hdc);
}
#endif // COLOR_HOTTRACKING

BOOL SBSetParms(PSBDATA pw, LPSCROLLINFO lpsi, LPBOOL lpfScroll, LPLONG lplres)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (lpsi->fMask & SIF_RETURNOLDPOS)
        // save previous position
        *lplres = pw->pos;

    if (lpsi->fMask & SIF_RANGE) {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (lpsi->nMax < lpsi->nMin)
            lpsi->nMax = lpsi->nMin;

        if ((pw->posMin != lpsi->nMin) || (pw->posMax != lpsi->nMax)) {
            pw->posMin = lpsi->nMin;
            pw->posMax = lpsi->nMax;

            if (!(lpsi->fMask & SIF_PAGE)) {
                lpsi->fMask |= SIF_PAGE;
                lpsi->nPage = pw->page;
            }

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_PAGE) {
        DWORD dwMaxPage = (DWORD) abs(pw->posMax - pw->posMin) + 1;

        // Clip page to 0, posMax - posMin + 1

        if (lpsi->nPage > dwMaxPage)
            lpsi->nPage = dwMaxPage;


        if (pw->page != (int)(lpsi->nPage)) {
            pw->page = lpsi->nPage;

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_POS) {
        int iMaxPos = pw->posMax - ((pw->page) ? pw->page - 1 : 0);
        // Clip pos to posMin, posMax - (page - 1).

        if (lpsi->nPos < pw->posMin)
            lpsi->nPos = pw->posMin;
        else if (lpsi->nPos > iMaxPos)
            lpsi->nPos = iMaxPos;


        if (pw->pos != lpsi->nPos) {
            pw->pos = lpsi->nPos;
            fChanged = TRUE;
        }
    }

    if (!(lpsi->fMask & SIF_RETURNOLDPOS)) {
        // Return the new position
        *lplres = pw->pos;
    }

    /*
     * This was added by JimA as Cairo merge but will conflict
     * with the documentation for SetScrollPos
     */
/*
    else if (*lplres == pw->pos)
        *lplres = 0;
*/
    if (lpsi->fMask & SIF_RANGE) {
        *lpfScroll = (pw->posMin != pw->posMax);
        if (*lpfScroll)
            goto checkPage;
    } else if (lpsi->fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw->page <= (pw->posMax - pw->posMin));

    return fChanged;
}


/***************************************************************************\
* CalcSBStuff
*
*
*
* History:
\***************************************************************************/
#if 0
void CalcSBStuff(
    HWND hwnd,
    PSBCALC pSBCalc,
    BOOL fVert)
{
    RECT    rcT;
    RECT    rcClient;
#ifdef USE_MIRRORING
    int     cx, iTemp;
#endif

    //
    // Get client rectangle.  We know that scrollbars always align to the right
    // and to the bottom of the client area.
    //
    GetClientRect( hwnd, &rcClient );
    ClientToScreen( hwnd, (LPPOINT)&rcClient.left );
    ClientToScreen( hwnd, (LPPOINT)&rcClient.right );
    MapWindowPoints( HWND_DESKTOP, hwnd, (LPPOINT)&rcClient, 2 );
    // GetRect(hwnd, &rcClient, GRECT_CLIENT | GRECT_WINDOWCOORDS);

#ifdef USE_MIRRORING
    if (TestWF(hwnd, WEFLAYOUTRTL)) {
        cx             = hwnd->rcWindow.right - hwnd->rcWindow.left;
        iTemp          = rcClient.left;
        rcClient.left  = cx - rcClient.right;
        rcClient.right = cx - iTemp;
    }
#endif

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(hwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = rcClient.left;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = rcClient.right;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = rcClient.top;
        rcT.bottom = rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = rcClient.bottom;
        if (TestWF(hwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = rcClient.left;
        rcT.right = rcClient.right;
    }

    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    if (_InitPwSB(hwnd))
        CalcSBStuff2(pSBCalc, &rcT, (fVert) ? &CUxScrollBar::GetSBInfo( hwnd )->Vert :  &CUxScrollBar::GetSBInfo( hwnd )->Horz, fVert);

}
#endif 0

/***************************************************************************\
*
*  DrawCtlThumb()
*
\***************************************************************************/
void DrawCtlThumb(SBHWND hwnd)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc = (HDC) GetWindowDC(hwnd);

    if ( hdc != NULL )
    {
        CUxScrollBarCtl* psb = SBCtlSetup(hwnd);

        if (psb)
        {
            BOOL fOwnerBrush = FALSE;

            hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
            hbrSave = SelectBrush(hdc, hbr);

            DrawThumb2(hwnd, &psb->_calc, hdc, hbr, psb->_fVert, psb->_wDisableFlags, fOwnerBrush);

            SelectBrush(hdc, hbrSave);
        }

        ReleaseDC(hwnd, hdc);
    }
}


//-------------------------------------------------------------------------
void xxxDrawThumb(HWND hwnd, PSBCALC pSBCalc, BOOL fVert)
{
    HBRUSH hbr, hbrSave;
    HDC hdc;
    UINT wDisableFlags;
    SBCALC SBCalc;

    CheckLock(hwnd);

    if (!pSBCalc) 
    {
        pSBCalc = &SBCalc;
    }

    CUxScrollBar::Calc( hwnd, pSBCalc, NULL, fVert );
    wDisableFlags = _GetWndSBDisableFlags(hwnd, fVert);

    hdc = GetWindowDC(hwnd);
    if ( hdc != NULL )
    {
        BOOL fOwnerBrush = FALSE;

        hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
        hbrSave = SelectBrush(hdc, hbr);
        DrawThumb2(hwnd, pSBCalc, hdc, hbr, fVert, wDisableFlags, fOwnerBrush);
        SelectBrush(hdc, hbrSave);
        ReleaseDC(hwnd, hdc);
    }
}


//-------------------------------------------------------------------------
UINT _GetArrowEnableFlags(HWND hwnd, BOOL fVert)
{
    SCROLLBARINFO sbi = {0};
    UINT uFlags = ESB_ENABLE_BOTH;

    sbi.cbSize = sizeof(sbi);
    if ( GetScrollBarInfo(hwnd, fVert ? OBJID_VSCROLL : OBJID_HSCROLL, &sbi) )
    {
        if ( TESTFLAG(sbi.rgstate[INDEX_SCROLLBAR_UP], (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE)) )
        {
            uFlags |= ESB_DISABLE_UP;
        }

        if ( TESTFLAG(sbi.rgstate[INDEX_SCROLLBAR_DOWN], (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE)) )
        {
            uFlags |= ESB_DISABLE_DOWN;
        }
    }

    return uFlags;
}


/***************************************************************************\
* _SetScrollBar
*
*
*
* History:
\***************************************************************************/

LONG _SetScrollBar(
    HWND hwnd,
    int code,
    LPSCROLLINFO lpsi,
    BOOL fRedraw)
{
    BOOL        fVert;
    PSBDATA     pw;
    PSBINFO     pSBInfo;
    BOOL        fOldScroll;
    BOOL        fScroll;
    WORD        wfScroll;
    LONG        lres;
    BOOL        fNewScroll;

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if (fRedraw)
        // window must be visible to redraw
        fRedraw = IsWindowVisible(hwnd);

    if (code == SB_CTL)
#ifdef FE_SB // xxxSetScrollBar()
        // scroll bar control; send the control a message
        if(GETPTI(hwnd)->TIF_flags & TIF_16BIT) {
            //
            // If the target application is 16bit apps, we don't pass win40's message.
            // This fix for Ichitaro v6.3. It eats the message. It never forwards
            // the un-processed messages to original windows procedure via
            // CallWindowProc().
            //
            // Is this from xxxSetScrollPos() ?
            if(lpsi->fMask == (SIF_POS|SIF_RETURNOLDPOS)) {
                return (int)SendMessage(hwnd, SBM_SETPOS, lpsi->nPos, fRedraw);
            // Is this from xxxSetScrollRange() ?
            } else if(lpsi->fMask == SIF_RANGE) {
                SendMessage(hwnd, SBM_SETRANGE, lpsi->nMin, lpsi->nMax);
                return TRUE;
            // Others...
            } else {
                return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
            }
        } else {
            return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
        }
#else
        // scroll bar control; send the control a message
        return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
#endif // FE_SB

    fVert = (code != SB_HORZ);

    wfScroll = (WORD)((fVert) ? WFVSCROLL : WFHSCROLL);

    fScroll = fOldScroll = (TestWF(hwnd, wfScroll)) ? TRUE : FALSE;

    /*
     * Don't do anything if we're setting position of a nonexistent scroll bar.
     */
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll && (CUxScrollBar::GetSBInfo( hwnd ) == NULL)) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    pSBInfo = CUxScrollBar::GetSBInfo( hwnd );
    fNewScroll = !pSBInfo;

    if (fNewScroll) {
        CUxScrollBar* psb = CUxScrollBar::Attach( hwnd, FALSE, fRedraw );
        if( NULL == psb )
            return 0;
        
        pSBInfo = psb->GetInfo();
    }

    pw = (fVert) ? &(pSBInfo->Vert) : &(pSBInfo->Horz);

    if (!SBSetParms(pw, lpsi, &fScroll, &lres) && !fNewScroll) 
    {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
        {
            goto redrawAfterSet;
        }

        if (lpsi->fMask & SIF_DISABLENOSCROLL)
        {
            xxxEnableWndSBArrows(hwnd, code, _GetArrowEnableFlags(hwnd, fVert));
        }

        return lres;
    }

    ClrWF(hwnd, wfScroll);

    if (fScroll)
        SetWF(hwnd, wfScroll);
    else if (!TestWF(hwnd, (WFHSCROLL | WFVSCROLL)))
    {
        // if neither scroll bar is set and both ranges are 0, then free up the
        // scroll info
        CUxScrollBar::Detach( hwnd );
    }

    if (lpsi->fMask & SIF_DISABLENOSCROLL) 
    {
        if (fOldScroll) 
        {
            SetWF(hwnd, wfScroll);
            xxxEnableWndSBArrows(hwnd, code, _GetArrowEnableFlags(hwnd, fVert));
        }
    } 
    else if (fOldScroll ^ fScroll) 
    {
        PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);
        if (pSBTrack && (hwnd == pSBTrack->hwndTrack)) 
        {
            pSBTrack->fTrackRecalc = TRUE;
        }

        _RedrawFrame(hwnd);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        return lres;
    }

    if (fScroll && fRedraw && (fVert ? TestWF(hwnd, WFVPRESENT) : TestWF(hwnd, WFHPRESENT)))
    {
        PSBTRACK pSBTrack;
redrawAfterSet:
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE,
                       hwnd,
                       (fVert ? OBJID_VSCROLL : OBJID_HSCROLL),
                       INDEX_SCROLLBAR_SELF);

        pSBTrack = CUxScrollBar::GetSBTrack(hwnd);
        // Bail out if the caller is trying to change the position of
        // a scrollbar that is in the middle of tracking.  We'll hose
        // TrackThumb() otherwise.

        if (pSBTrack && (hwnd == pSBTrack->hwndTrack) &&
                ((BOOL)(pSBTrack->fTrackVert) == fVert) &&
                (pSBTrack->pfnSB == _TrackThumb)) {
            return lres;
        }

        xxxDrawThumb(hwnd, NULL, fVert);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
    }

    return lres;
}

//-------------------------------------------------------------------------//
LONG WINAPI ThemeSetScrollInfo( HWND hwnd, int nBar, LPCSCROLLINFO psi, BOOL bRedraw )
{
    return _SetScrollBar( hwnd, nBar, (LPSCROLLINFO)psi, bRedraw );
}


//-------------------------------------------------------------------------//
BOOL WINAPI ScrollBar_MouseMove( HWND hwnd, LPPOINT ppt, BOOL fVert )
{
    BOOL fRet = FALSE;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );

    if (psb)
    {
        int htScroll = (ppt != NULL) ? HitTestScrollBar(hwnd, fVert, *ppt) : HTNOWHERE;

        //
        // Redraw the scroll bar if the mouse is over something different
        //
        if (htScroll != psb->GetHotComponent(fVert))
        {
            HDC hdc;

            //
            // save the hittest code of the Scrollbar element the mouse is 
            // currently over
            //
            psb->SetHotComponent(htScroll, fVert);

            hdc = GetDCEx(hwnd, NULL, DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE);
            if (hdc != NULL)
            {
                DrawScrollBar(hwnd, hdc, NULL, fVert);
                ReleaseDC(hwnd, hdc);
            }

            fRet = TRUE;
        }
    }
    
    return fRet;
}


//-------------------------------------------------------------------------//
void DrawScrollBar(HWND hwnd, HDC hdc, LPRECT prcOverrideClient, BOOL fVert)
{
    SBCALC SBCalc = {0};
    PSBCALC pSBCalc;
    PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    CheckLock(hwnd);
    if (pSBTrack && (hwnd == pSBTrack->hwndTrack) && (pSBTrack->fCtlSB == FALSE)
         && (fVert == (BOOL)pSBTrack->fTrackVert)) 
    {
        pSBCalc = pSBTrack->pSBCalc;
    } 
    else 
    {
        pSBCalc = &SBCalc;
    }
    CUxScrollBar::Calc(hwnd, pSBCalc, prcOverrideClient, fVert);

    xxxDrawSB2(hwnd, pSBCalc, hdc, fVert, _GetWndSBDisableFlags(hwnd, fVert));
}

/***************************************************************************\
* SBPosFromPx
*
* Compute scroll bar position from pixel location
*
* History:
\***************************************************************************/

int SBPosFromPx(
    PSBCALC  pSBCalc,
    int px)
{
    if (px < pSBCalc->pxMin) {
        return pSBCalc->data.posMin;
    }
    if (px >= pSBCalc->pxMin + pSBCalc->cpx) {
        return (pSBCalc->data.posMax - (pSBCalc->data.page ? pSBCalc->data.page - 1 : 0));
    }
    if (pSBCalc->cpx)
        return (pSBCalc->data.posMin + MulDiv(pSBCalc->data.posMax - pSBCalc->data.posMin -
            (pSBCalc->data.page ? pSBCalc->data.page - 1 : 0),
            px - pSBCalc->pxMin, pSBCalc->cpx));
    else
        return (pSBCalc->data.posMin - 1);
}

/***************************************************************************\
* InvertScrollHilite
*
*
*
* History:
\***************************************************************************/

void InvertScrollHilite(
    HWND hwnd,
    PSBTRACK pSBTrack)
{
    HDC hdc;

    /*
     * Don't invert if the thumb is all the way at the top or bottom
     * or you will end up inverting the line between the arrow and the thumb.
     */
    if (!IsRectEmpty(&pSBTrack->rcTrack))
    {
        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        hdc = (HDC)GetWindowDC(hwnd);
        if( hdc )
        {
            HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);
            if (!hTheme)
            {
                InvertRect(hdc, &pSBTrack->rcTrack);
            }
            else
            {
                DrawThemeBackground(hTheme, 
                                    hdc, 
                                    pSBTrack->cmdSB == SB_PAGEUP ? 
                                        (pSBTrack->fTrackVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ) : 
                                        (pSBTrack->fTrackVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ), 
                                    SCRBS_NORMAL, 
                                    &pSBTrack->rcTrack, 
                                    0);
            }
            ReleaseDC(hwnd, hdc);
        }
    }
}

/***************************************************************************\
* xxxDoScroll
*
* Sends scroll notification to the scroll bar owner
*
* History:
\***************************************************************************/

void xxxDoScroll(
    HWND hwnd,
    HWND hwndNotify,
    int cmd,
    int pos,
    BOOL fVert
)
{

    //
    // Send scroll notification to the scrollbar owner. If this is a control
    // the lParam is the control's handle, NULL otherwise.
    //
    SendMessage(hwndNotify, 
                (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
                MAKELONG(cmd, pos), 
                (LPARAM)(IsScrollBarControl(hwnd) ? hwnd : NULL));
}

// -------------------------------------------------------------------------
//
//  CheckScrollRecalc()
//
// -------------------------------------------------------------------------
//void CheckScrollRecalc(HWND hwnd, PSBSTATE pSBState, PSBCALC pSBCalc)
//{
//    if ((pSBState->pwndCalc != hwnd) || ((pSBState->nBar != SB_CTL) && (pSBState->nBar != ((pSBState->fVertSB) ? SB_VERT : SB_HORZ))))
//    {
//        // Calculate SB stuff based on whether it's a control or in a window
//        if (pSBState->fCtlSB)
//            SBCtlSetup((SBHWND) hwnd);
//        else
//            CalcSBStuff(hwnd, pSBCalc, pSBState->fVertSB);
//    }
//}


/***************************************************************************\
* xxxMoveThumb
*
* History:
\***************************************************************************/

void xxxMoveThumb(
    HWND hwnd,
    PSBCALC  pSBCalc,
    int px)
{
    HBRUSH        hbr, hbrSave;
    HDC           hdc;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    PSBTRACK      pSBTrack = psb->GetTrack();

    CheckLock(hwnd);

    if ((pSBTrack == NULL) || (px == pSBTrack->pxOld))
        return;

pxReCalc:

    pSBTrack->posNew = SBPosFromPx(pSBCalc, px);

    /* Tentative position changed -- notify the guy. */
    if (pSBTrack->posNew != pSBTrack->posOld) {
        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll(pSBTrack->hwndSBNotify, SB_THUMBTRACK, pSBTrack->posNew, pSBTrack->fTrackVert
            );

        }
        // After xxxDoScroll, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxMoveThumb(1)");
        if ((pSBTrack == NULL) || (pSBTrack->pfnSB == NULL))
            return;

        pSBTrack->posOld = pSBTrack->posNew;

        //
        // Anything can happen after the SendMessage above!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        //
//        CheckScrollRecalc(hwnd, pSBState, pSBCalc);
        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pSBCalc->pxMin + pSBCalc->cpx)
        {
            px = pSBCalc->pxMin + pSBCalc->cpx;
            goto pxReCalc;
        }

    }

    hdc = GetWindowDC(hwnd);
    if ( hdc != NULL )
    {
        BOOL fOwnerBrush = FALSE;

        pSBCalc->pxThumbTop = px;
        pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

        // at this point, the disable flags are always going to be 0 --
        // we're in the middle of tracking.
        hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
        hbrSave = SelectBrush(hdc, hbr);

        // After ScrollBar_GetColorObjects, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxMoveThumb(2)");
        if (pSBTrack == NULL) 
        {
            RIPMSG1(RIP_ERROR, "Did we use to leak hdc %#p?", hdc) ;
            ReleaseDC(hwnd, hdc);
            return;
        }
        DrawThumb2(hwnd, pSBCalc, hdc, hbr, pSBTrack->fTrackVert, 0, fOwnerBrush);
        SelectBrush(hdc, hbrSave);
        ReleaseDC(hwnd, hdc);
    }

    pSBTrack->pxOld = px;
}

/***************************************************************************\
* zzzDrawInvertScrollArea
*
*
*
* History:
\***************************************************************************/

void zzzDrawInvertScrollArea(
    HWND hwnd,
    PSBTRACK pSBTrack,
    BOOL fHit,
    UINT cmd)
{
    HDC hdc;
    RECT rcTemp;
    int cx, cy;
    HTHEME hTheme;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN)) {
        // not hitting on arrow -- just invert the area and return
        InvertScrollHilite(hwnd, pSBTrack);

        if (cmd == SB_PAGEUP)
        {
            if (fHit)
                SetWF(hwnd, WFPAGEUPBUTTONDOWN);
            else
                ClrWF(hwnd, WFPAGEUPBUTTONDOWN);
        }
        else
        {
            if (fHit)
                SetWF(hwnd, WFPAGEDNBUTTONDOWN);
            else
                ClrWF(hwnd, WFPAGEDNBUTTONDOWN);
        }

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE,
                       hwnd,
                       (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                       ((cmd == SB_PAGEUP) ? INDEX_SCROLLBAR_UPPAGE : INDEX_SCROLLBAR_DOWNPAGE));
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)
        return;
    }

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    CopyRect(&rcTemp, &pSBTrack->rcTrack);

    hdc = GetWindowDC(hwnd);
    if( hdc != NULL )
    {
        if (pSBTrack->fTrackVert) {
            cx = SYSMET(CXVSCROLL);
            cy = SYSMET(CYVSCROLL);
        } else {
            cx = SYSMET(CXHSCROLL);
            cy = SYSMET(CYHSCROLL);
        }

        hTheme = CUxScrollBar::GetSBTheme(hwnd);
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rcTemp, DFC_SCROLL,
                ((pSBTrack->fTrackVert) ? DFCS_SCROLLVERT : DFCS_SCROLLHORZ) |
                ((fHit) ? DFCS_PUSHED | DFCS_FLAT : 0) |
                ((cmd == SB_LINEUP) ? DFCS_SCROLLMIN : DFCS_SCROLLMAX));
        }
        else
        {
            INT iStateId;

            // Determine the pressed state of the button
            iStateId = fHit ? SCRBS_PRESSED : SCRBS_NORMAL;

            // Determine which kind of button it is.
            // NOTE: (phellyar) this is dependant on the order of
            //                  the ARROWBTNSTATE enum
            if (pSBTrack->fTrackVert)
            {
                if (cmd == SB_LINEUP)
                {
                    // Up button states are the first four entries
                    // in the enum
                    iStateId += 0;
                }
                else
                {
                    // Down button states are the second four entries
                    // in the enum
                    iStateId += 4;
                }
            }
            else
            {
                if (cmd == SB_LINEUP)
                {
                    // Left button states are the third four entries
                    // in the enum
                    iStateId += 8;
                }
                else
                {
                    // Right button states are the last four entries
                    // in the enum
                    iStateId += 12;
                }
            }
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rcTemp, 0);
        }

        ReleaseDC(hwnd, hdc);
    }

    if (cmd == SB_LINEUP) {
        if (fHit)
            SetWF(hwnd, WFLINEUPBUTTONDOWN);
        else
            ClrWF(hwnd, WFLINEUPBUTTONDOWN);
    } else {
        if (fHit)
            SetWF(hwnd, WFLINEDNBUTTONDOWN);
        else
            ClrWF(hwnd, WFLINEDNBUTTONDOWN);
    }

    NotifyWinEvent(EVENT_OBJECT_STATECHANGE,
                   hwnd,
                   (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                   (cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN));
    // Note: after zzz, pSBTrack may no longer be valid (but we return now)
}

/***************************************************************************\
* xxxEndScroll
*
*
*
* History:
\***************************************************************************/

void xxxEndScroll(
    HWND hwnd,
    BOOL fCancel)
{
    UINT oldcmd;
    PSBTRACK pSBTrack;
    CheckLock(hwnd);
    ASSERT(!IsWinEventNotifyDeferred());

    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    ASSERT(psb != NULL);
    pSBTrack = psb->GetTrack();

    if (pSBTrack && GetCapture() == hwnd && pSBTrack->pfnSB != NULL) {

        oldcmd = pSBTrack->cmdSB;
        pSBTrack->cmdSB = 0;
        ReleaseCapture();

        // After ReleaseCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        if (pSBTrack->pfnSB == _TrackThumb) {

            if (fCancel) {
                pSBTrack->posOld = pSBTrack->pSBCalc->data.pos;
            }

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->hwndSBNotify != NULL) {
                psb->DoScroll( pSBTrack->hwndSBNotify,
                               SB_THUMBPOSITION, pSBTrack->posOld, pSBTrack->fTrackVert
                );
                // After xxxDoScroll, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            if (pSBTrack->fCtlSB) {
                DrawCtlThumb((SBHWND) hwnd);
            } else {
                xxxDrawThumb(hwnd, pSBTrack->pSBCalc, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }

        } else if (pSBTrack->pfnSB == _TrackBox) {
            DWORD lParam;
            POINT ptMsg;
            RECT  rcWindow;

            if (pSBTrack->hTimerSB != 0) {
                _KillSystemTimer(hwnd, IDSYS_SCROLL);
                pSBTrack->hTimerSB = 0;
            }
            lParam = GetMessagePos();
            GetWindowRect( hwnd, &rcWindow );
#ifdef USE_MIRRORING
            if (TestWF(hwnd, WEFLAYOUTRTL)) {
                ptMsg.x = rcWindow.right - GET_X_LPARAM(lParam);
            } else
#endif
            {
                ptMsg.x = GET_X_LPARAM(lParam) - rcWindow.left;
            }
            ptMsg.y = GET_Y_LPARAM(lParam) - rcWindow.top;
            if (PtInRect(&pSBTrack->rcTrack, ptMsg)) {
                zzzDrawInvertScrollArea(hwnd, pSBTrack, FALSE, oldcmd);
                // Note: after zzz, pSBTrack may no longer be valid
            }
        }

        /*
         * Always send SB_ENDSCROLL message.
         *
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */

        // After xxxDrawThumb or zzzDrawInvertScrollArea, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll( pSBTrack->hwndSBNotify,
                           SB_ENDSCROLL, 0, pSBTrack->fTrackVert);
            // After xxxDoScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
        }

        ClrWF(hwnd, WFSCROLLBUTTONDOWN);
        ClrWF(hwnd, WFVERTSCROLLTRACK);

        NotifyWinEvent(EVENT_SYSTEM_SCROLLINGEND,
                       hwnd,
                       (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                       INDEXID_CONTAINER);
        // After xxxWindowEvent, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        // If this is a Scroll Bar Control, turn the caret back on.
        if (pSBTrack->hwndSB != NULL)
        {
            ShowCaret(pSBTrack->hwndSB);
            // After zzz, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
        }

        pSBTrack->pfnSB = NULL;

        /*
         * Unlock structure members so they are no longer holding down windows.
         */
        
        Unlock(&pSBTrack->hwndSB);
        Unlock(&pSBTrack->hwndSBNotify);
        Unlock(&pSBTrack->hwndTrack);
        CUxScrollBar::ClearSBTrack( hwnd );
    }
}


//-------------------------------------------------------------------------//
VOID CALLBACK xxxContScroll(HWND hwnd, UINT message, UINT_PTR ID, DWORD dwTime)
{
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(dwTime);

    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );

    if ( psb != NULL )
    {
        PSBTRACK pSBTrack = psb->GetTrack();

        if ( pSBTrack != NULL )
        {
            LONG pt;
            RECT rcWindow;

            CheckLock(hwnd);

            pt = GetMessagePos();
            GetWindowRect( hwnd, &rcWindow );

            if (TestWF(hwnd, WEFLAYOUTRTL)) 
            {
                pt = MAKELONG(rcWindow.right - GET_X_LPARAM(pt), GET_Y_LPARAM(pt) - rcWindow.top);
            } 
            else
            {
                pt = MAKELONG( GET_X_LPARAM(pt) - rcWindow.left, GET_Y_LPARAM(pt) - rcWindow.top);
            }

            _TrackBox(hwnd, WM_NULL, 0, pt, NULL);

            // After _TrackBox, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

            if (pSBTrack->fHitOld) 
            {
                pSBTrack->hTimerSB = _SetSystemTimer(hwnd, IDSYS_SCROLL, DTTIME/8, xxxContScroll);

                // DoScroll does thread locking on these two pwnds -
                // this is ok since they are not used after this call.
                if (pSBTrack->hwndSBNotify != NULL) 
                {
                    psb->DoScroll(pSBTrack->hwndSBNotify, pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
                    // Note: after xxx, pSBTrack may no longer be valid (but we return now)
                }
            }
        }
    }
}


//-------------------------------------------------------------------------//
void CALLBACK _TrackBox(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc)
{
    CUxScrollBar* psb = CUxScrollBar::FromHwnd(hwnd);

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(pSBCalc);

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if ( psb )
    {
        PSBTRACK pSBTrack = psb->GetTrack();

        if ( pSBTrack )
        {
            BOOL  fHit;
            POINT ptHit;
            int   cmsTimer;

            if ((uMsg != WM_NULL) && (HIBYTE(uMsg) != HIBYTE(WM_MOUSEFIRST)))
            {
                return;
            }

            if (pSBTrack->fTrackRecalc) 
            {
                RecalcTrackRect(pSBTrack);
                pSBTrack->fTrackRecalc = FALSE;
            }

            ptHit.x = GET_X_LPARAM(lParam);
            ptHit.y = GET_Y_LPARAM(lParam);
            fHit = PtInRect(&pSBTrack->rcTrack, ptHit);

            if (fHit != (BOOL)pSBTrack->fHitOld) 
            {
                zzzDrawInvertScrollArea(hwnd, pSBTrack, fHit, pSBTrack->cmdSB);
                // After zzz, pSBTrack may no longer be valid
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            cmsTimer = DTTIME/8;

            switch (uMsg) 
            {
            case WM_LBUTTONUP:
                xxxEndScroll(hwnd, FALSE);
                // Note: after xxx, pSBTrack may no longer be valid
                break;

            case WM_LBUTTONDOWN:
                pSBTrack->hTimerSB = 0;
                cmsTimer = DTTIME;

                //
                // FALL THRU
                //

            case WM_MOUSEMOVE:
                if (fHit && fHit != (BOOL)pSBTrack->fHitOld) 
                {
                    //
                    // We moved back into the normal rectangle: reset timer
                    //
                    pSBTrack->hTimerSB = _SetSystemTimer(hwnd, IDSYS_SCROLL,
                            cmsTimer, xxxContScroll);

                    //
                    // DoScroll does thread locking on these two pwnds -
                    // this is ok since they are not used after this
                    // call.
                    //
                    if (pSBTrack->hwndSBNotify != NULL) 
                    {
                        psb->DoScroll( pSBTrack->hwndSBNotify, pSBTrack->cmdSB, 
                                       0, pSBTrack->fTrackVert);
                        // Note: after xxx, pSBTrack may no longer be valid
                    }
                }

                break;
            }

            // After xxxDoScroll or xxxEndScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            pSBTrack->fHitOld = fHit;
        }
    }
}


/***************************************************************************\
* _TrackThumb
*
*
*
* History:
\***************************************************************************/

void CALLBACK _TrackThumb(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    int px;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    ASSERT(psb);
    PSBTRACK pSBTrack = psb->GetTrack();
    POINT pt;

    UNREFERENCED_PARAMETER(wParam);

    CheckLock(hwnd);

    if (HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack == NULL)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
//    CheckScrollRecalc(hwnd, pSBState, pSBCalc);
    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }


    pt.y = GET_Y_LPARAM(lParam);
    pt.x = GET_X_LPARAM(lParam);
    if (!PtInRect(&pSBTrack->rcTrack, pt))
        px = pSBCalc->pxStart;
    else {
        px = (pSBTrack->fTrackVert ? pt.y : pt.x) + pSBTrack->dpxThumb;
        if (px < pSBCalc->pxMin)
            px = pSBCalc->pxMin;
        else if (px >= pSBCalc->pxMin + pSBCalc->cpx)
            px = pSBCalc->pxMin + pSBCalc->cpx;
    }

    xxxMoveThumb(hwnd, pSBCalc, px);

    /*
     * We won't get the WM_LBUTTONUP message if we got here through
     * the scroll menu, so test the button state directly.
     */
    if (message == WM_LBUTTONUP || GetKeyState(VK_LBUTTON) >= 0) {
        xxxEndScroll(hwnd, FALSE);
    }

}

/***************************************************************************\
* _ClientToWindow
* History:
\***************************************************************************/
BOOL _ClientToWindow( HWND hwnd, LPPOINT ppt )
{
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( GetWindowInfo( hwnd, &wi ) )
    {
        ppt->x += (wi.rcClient.left - wi.rcWindow.left);
        ppt->y += (wi.rcClient.top -  wi.rcWindow.top);
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* xxxSBTrackLoop
*
*
*
* History:
\***************************************************************************/

void xxxSBTrackLoop(
    HWND hwnd,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    MSG msg;
    UINT cmd;
    VOID (*pfnSB)(HWND, UINT, WPARAM, LPARAM, PSBCALC);
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    PSBTRACK pSBTrack = psb->GetSBTrack(hwnd);

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());


    if (pSBTrack == NULL)
        // mode cancelled -- exit track loop
        return;
    
    pfnSB = pSBTrack->pfnSB;
    if (pfnSB == NULL)
        // mode cancelled -- exit track loop
        return;

    if (pSBTrack->fTrackVert)
        SetWF(hwnd, WFVERTSCROLLTRACK);

    NotifyWinEvent(EVENT_SYSTEM_SCROLLINGSTART,
                   hwnd,
                   (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                   INDEXID_CONTAINER);
    // Note: after xxx, pSBTrack may no longer be valid

    (*pfnSB)(hwnd, WM_LBUTTONDOWN, 0, lParam, pSBCalc);
    // Note: after xxx, pSBTrack may no longer be valid

    while (GetCapture() == hwnd) {
        if (!GetMessage(&msg, NULL, 0, 0)) {
            // Note: after xxx, pSBTrack may no longer be valid
            break;
        }

        if (!CallMsgFilter(&msg, MSGF_SCROLLBAR))
        {
            BOOL bTrackMsg = FALSE;
            cmd = msg.message;
            lParam = msg.lParam;

            if (msg.hwnd == HWq(hwnd))
            {
                if( cmd >= WM_MOUSEFIRST && cmd <= WM_MOUSELAST )
                {
                    if( !psb->IsCtl() )
                    {
                        POINT pt;
                        pt.x = GET_X_LPARAM(msg.lParam);
                        pt.y = GET_Y_LPARAM(msg.lParam);
                        _ClientToWindow( hwnd, &pt );
                        lParam = MAKELPARAM(pt.x, pt.y);
                    }
                    bTrackMsg = TRUE;
                }
                else if( cmd >= WM_KEYFIRST && cmd <= WM_KEYLAST )
                {
                    cmd = _SysToChar(cmd, msg.lParam);
                    bTrackMsg = TRUE;
                }
            }

            if( bTrackMsg )
            {
                // After NotifyWinEvent, pfnSB, TranslateMessage or
                // DispatchMessage, re-evaluate pSBTrack.
                REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxTrackLoop");
                if ((pSBTrack == NULL) || (NULL == (pfnSB = pSBTrack->pfnSB)))
                    // mode cancelled -- exit track loop
                    return;

                (*pfnSB)(hwnd, cmd, msg.wParam, lParam, pSBCalc);
            }
            else
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}


/***************************************************************************\
* _SBTrackInit
*
* History:
\***************************************************************************/

void _SBTrackInit(
    HWND hwnd,
    LPARAM lParam,
    int curArea,
    UINT uType)
{
    int px;
    LPINT pwX;
    LPINT pwY;
    UINT wDisable;     // Scroll bar disable flags;
    SBCALC SBCalc = {0};
    PSBCALC pSBCalc;
    RECT rcSB;
    PSBTRACK pSBTrack;

    CheckLock(hwnd);

#ifdef PORTPORT // unneccessary dbgchk w/ port
    if (CUxScrollBar::GetSBTrack(hwnd)) {
        RIPMSG1(RIP_WARNING, "_SBTrackInit: CUxScrollBar::GetSBTrack(hwnd) == %#p",
                CUxScrollBar::GetSBTrack(hwnd));
        return;
    }
#endif PORTPORT

    CUxScrollBar*    psb = CUxScrollBar::Attach( hwnd, !curArea, TRUE );

    if (!psb)
    {
        return;
    }
     
    CUxScrollBarCtl* psbCtl = psb->IsCtl() ? (CUxScrollBarCtl*)psb : NULL;

    pSBTrack = psb->GetTrack();
    if (pSBTrack == NULL)
        return;

    pSBTrack->hTimerSB = 0;
    pSBTrack->fHitOld = FALSE;

    pSBTrack->pfnSB = _TrackBox;

    pSBTrack->hwndTrack = NULL;
    pSBTrack->hwndSB = NULL;
    pSBTrack->hwndSBNotify = NULL;
    Lock(&pSBTrack->hwndTrack, hwnd); // pSBTrack->hwndTrack = hwnd;  

    pSBTrack->fCtlSB = (!curArea);
    if (pSBTrack->fCtlSB)
    {
        /*
         * This is a scroll bar control.
         */
        ASSERT(psbCtl != NULL);

        pSBTrack->hwndSB = hwnd; //Lock(&pSBTrack->hwndSB, hwnd);
        pSBTrack->fTrackVert = psbCtl->_fVert;
        Lock(&pSBTrack->hwndSBNotify, GetParent(hwnd)); // pSBTrack->hwndSBNotify = GetParent( hwnd );
        wDisable = psbCtl->_wDisableFlags;
        pSBCalc = &psbCtl->_calc;
        pSBTrack->nBar = SB_CTL;
    } else {

        /*
         * This is a scroll bar that is part of the window frame.
         */
        RECT rcWindow;
        GetWindowRect( hwnd, &rcWindow );
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);

#ifdef USE_MIRRORING
        //
        // Mirror the window coord of the scroll bar,
        // if it is a mirrored one
        //
        if (TestWF(hwnd,WEFLAYOUTRTL)) {
            lParam = MAKELONG(
                    rcWindow.right - x,
                    y - rcWindow.top);
        }
        else {
#endif
        lParam = MAKELONG( x - rcWindow.left, y - rcWindow.top);

#ifdef USE_MIRRORING
        }
#endif
        Lock(&pSBTrack->hwndSBNotify, hwnd); // pSBTrack->hwndSBNotify = hwnd; //
        Lock(&pSBTrack->hwndSB, NULL);       // pSBTrack->hwndSB = NULL;
        
        pSBTrack->fTrackVert = (curArea - HTHSCROLL);
        wDisable = _GetWndSBDisableFlags(hwnd, pSBTrack->fTrackVert);
        pSBCalc = &SBCalc;
        pSBTrack->nBar = (curArea - HTHSCROLL) ? SB_VERT : SB_HORZ;
    }

    pSBTrack->pSBCalc = pSBCalc;
    /*
     *  Check if the whole scroll bar is disabled
     */
    if((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        CUxScrollBar::Detach( hwnd );
        return;  // It is a disabled scroll bar; So, do not respond.
    }

    if (!pSBTrack->fCtlSB) {
        psb->FreshenSBData( pSBTrack->nBar, FALSE );
        CUxScrollBar::Calc(hwnd, pSBCalc, NULL, pSBTrack->fTrackVert);
    }

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    px = (pSBTrack->fTrackVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam));

    *(pwX + 0) = pSBCalc->pxLeft;
    *(pwY + 0) = pSBCalc->pxTop;
    *(pwX + 2) = pSBCalc->pxRight;
    *(pwY + 2) = pSBCalc->pxBottom;
    pSBTrack->cmdSB = (UINT)-1;
    if (px < pSBCalc->pxUpArrow) {

        /*
         *  The click occurred on Left/Up arrow; Check if it is disabled
         */
        if(wDisable & LTUPFLAG) {
            if(pSBTrack->fCtlSB) {   // If this is a scroll bar control,
                ShowCaret(pSBTrack->hwndSB);  // show the caret before returning;
                // After ShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }
            CUxScrollBar::Detach( hwnd );
            return;         // Yes! disabled. Do not respond.
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEUP;
        *(pwY + 2) = pSBCalc->pxUpArrow;
    } else if (px >= pSBCalc->pxDownArrow) {

        /*
         * The click occurred on Right/Down arrow; Check if it is disabled
         */
        if (wDisable & RTDNFLAG) {
            if (pSBTrack->fCtlSB) {    // If this is a scroll bar control,
                ShowCaret(pSBTrack->hwndSB);  // show the caret before returning;
                // After ShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            CUxScrollBar::Detach( hwnd );
            return;// Yes! disabled. Do not respond.
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEDOWN;
        *(pwY + 0) = pSBCalc->pxDownArrow;
    } else if (px < pSBCalc->pxThumbTop) {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pSBTrack->cmdSB = SB_PAGEUP;
        *(pwY + 0) = pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBCalc->pxThumbTop;
    } else if (px < pSBCalc->pxThumbBottom) {

DoThumbPos:
        /*
         * Elevator isn't there if there's no room.
         */
        if (pSBCalc->pxDownArrow - pSBCalc->pxUpArrow <= pSBCalc->cpxThumb) {
            CUxScrollBar::Detach( hwnd );
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pSBTrack->cmdSB = SB_THUMBPOSITION;
        CalcTrackDragRect(pSBTrack);

        pSBTrack->pfnSB = _TrackThumb;
        pSBTrack->pxOld = pSBCalc->pxStart = pSBCalc->pxThumbTop;
        pSBTrack->posNew = pSBTrack->posOld = pSBCalc->data.pos;
        pSBTrack->dpxThumb = pSBCalc->pxStart - px;

        SetCapture( hwnd ); //xxxCapture(PtiCurrent(), hwnd, WINDOW_CAPTURE);
        
        // After xxxCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll( pSBTrack->hwndSBNotify, SB_THUMBTRACK, 
                           pSBTrack->posOld, pSBTrack->fTrackVert
            );
            // Note: after xxx, pSBTrack may no longer be valid
        }
    } else if (px < pSBCalc->pxDownArrow) {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pSBTrack->cmdSB = SB_PAGEDOWN;
        *(pwY + 0) = pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBCalc->pxDownArrow;
    }

    /*
     * If the shift key is down, we'll position the thumb directly so it's
     * centered on the click point.
     */
    if ((uType == SCROLL_DIRECT && pSBTrack->cmdSB != SB_LINEUP && pSBTrack->cmdSB != SB_LINEDOWN) ||
            (uType == SCROLL_MENU)) {
        if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pSBTrack->dpxThumb = -(pSBCalc->cpxThumb / 2);
    }

    SetCapture( hwnd ); // xxxCapture(PtiCurrent(), hwnd, WINDOW_CAPTURE);
    // After xxxCapture, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }

    xxxSBTrackLoop(hwnd, lParam, pSBCalc);

    // After xxx, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxTrackLoop");
    if (pSBTrack) 
    {
        CUxScrollBar::ClearSBTrack( hwnd );
    }
}

/***************************************************************************\
* HandleScrollCmd
*
* History: added to support and encap SB tracking initialization originating
*          from WM_SYSCOMMAND::SC_VSCROLL/SC_HSCROLL [scotthan]
\***************************************************************************/
void WINAPI HandleScrollCmd( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    UINT uArea = (UINT)(wParam & 0x0F);
    _SBTrackInit( hwnd, lParam, uArea, 
                    (GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
}


//-------------------------------------------------------------------------
HMENU ScrollBar_GetMenu(HWND hwnd, BOOL fVert)
{
    static HMODULE hModUser = NULL;
    HMENU hMenu = NULL;

    if ( !hModUser )
    {
        hModUser = GetModuleHandle(TEXT("user32"));
    }

#define ID_HSCROLLMENU  0x40
#define ID_VSCROLLMENU  0x50

    if ( hModUser )
    {
        hMenu = LoadMenu(hModUser, MAKEINTRESOURCE((fVert ? ID_VSCROLLMENU : ID_HSCROLLMENU)));
        if ( hMenu ) 
        {
            hMenu = GetSubMenu(hMenu, 0);
        }
    }

    return hMenu;
}


//-------------------------------------------------------------------------
VOID ScrollBar_Menu(HWND hwndNotify, HWND hwnd, LPARAM lParam, BOOL fVert)
{
    CUxScrollBar*    psb    = CUxScrollBar::FromHwnd( hwnd );
    CUxScrollBarCtl* psbCtl = CUxScrollBarCtl::FromHwnd( hwnd );
    BOOL fCtl = (psbCtl != NULL);

    if ( psb || psbCtl )
    {
        UINT  wDisable;
        RECT  rcWindow;
        POINT pt;

        GetWindowRect(hwnd, &rcWindow);

        POINTSTOPOINT(pt, lParam);
        if ( TestWF(hwnd, WEFLAYOUTRTL) && !fVert ) 
        {
            MIRROR_POINT(rcWindow, pt);
        }
        pt.x -= rcWindow.left;
        pt.y -= rcWindow.top;

        if ( fCtl ) 
        {
            wDisable = psbCtl->_wDisableFlags;
        } 
        else 
        {
            wDisable = _GetWndSBDisableFlags(hwndNotify, fVert);
        }

        // Make sure the scrollbar isn't disabled.
        if ( (wDisable & SB_DISABLE_MASK) != SB_DISABLE_MASK) 
        {
            HMENU hMenu = ScrollBar_GetMenu(hwndNotify, fVert);

            // Put up a menu and scroll accordingly.
            if (hMenu != NULL) 
            {
                int iCmd;

                iCmd = TrackPopupMenuEx(hMenu,
                            TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                            GET_X_LPARAM(lParam),
                            GET_Y_LPARAM(lParam),
                            hwndNotify,
                            NULL);

                DestroyMenu(hMenu);

                if (iCmd) 
                {
                    if ((iCmd & 0x00FF) == SB_THUMBPOSITION) 
                    {
                        if ( fCtl ) 
                        {
                            _SBTrackInit(hwnd, MAKELPARAM(pt.x, pt.y), 0, SCROLL_MENU);
                        }   
                        else 
                        {
                            _SBTrackInit(hwndNotify, lParam, fVert ? HTVSCROLL : HTHSCROLL, SCROLL_MENU);
                        }
                    } 
                    else 
                    {
                        xxxDoScroll(hwnd, hwndNotify, (iCmd & 0x00FF), 0, fVert);
                        xxxDoScroll(hwnd, hwndNotify, SB_ENDSCROLL, 0, fVert);
                    }
                }
            }
        }
    }
}


//-------------------------------------------------------------------------
LRESULT CUxScrollBarCtl::WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LONG         l;
    LONG         lres = 0;
    int          cx, cy;
    UINT         cmd;
    UINT         uSide;
    HDC          hdc;
    RECT         rc;
    POINT        pt;
    BOOL         fSizeReal;
    HBRUSH       hbrSave;
    BOOL         fSize;
    PAINTSTRUCT  ps;
    DWORD        dwStyle;
    SCROLLINFO   si;
    LPSCROLLINFO lpsi = &si;
    BOOL         fRedraw = FALSE;
    BOOL         fScroll;
    
    CUxScrollBarCtl* psb = CUxScrollBarCtl::FromHwnd( hwnd );
    if (!psb && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(((HWND)hwnd), uMsg, wParam, lParam, FNID_SCROLLBAR, WM_CREATE);

    dwStyle = GetWindowStyle(hwnd);
    fSize = (((LOBYTE(dwStyle)) & (SBS_SIZEBOX | SBS_SIZEGRIP)) != 0);

    switch (uMsg) 
    {
    
    case WM_NCCREATE:
        
        if( NULL == psb )
        {
            psb = (CUxScrollBarCtl*)CUxScrollBar::Attach( hwnd, TRUE, FALSE );
        }

        goto CallDWP;
        
    case WM_NCDESTROY:
        CUxScrollBar::Detach(hwnd);
        psb = NULL;
        goto CallDWP;

    case WM_CREATE:
        /*
         * Guard against lParam being NULL since the thunk allows it [51986]
         */

        if (lParam) 
        {
            rc.right = (rc.left = ((LPCREATESTRUCT)lParam)->x) +
                    ((LPCREATESTRUCT)lParam)->cx;
            rc.bottom = (rc.top = ((LPCREATESTRUCT)lParam)->y) +
                    ((LPCREATESTRUCT)lParam)->cy;
            // This is because we can't just rev CardFile -- we should fix the
            // problem here in case anyone else happened to have some EXTRA
            // scroll styles on their scroll bar controls (jeffbog 03/21/94)
            if (!TestWF((HWND)hwnd, WFWIN40COMPAT))
                dwStyle &= ~(WS_HSCROLL | WS_VSCROLL);

            if (!fSize) 
            {
                l = PtrToLong(((LPCREATESTRUCT)lParam)->lpCreateParams);
                
                psb->_calc.data.pos = psb->_calc.data.posMin = LOWORD(l);
                psb->_calc.data.posMax = HIWORD(l);
                psb->_fVert = ((LOBYTE(dwStyle) & SBS_VERT) != 0);
                psb->_calc.data.page = 0;
            }

            if (dwStyle & WS_DISABLED)
                psb->_wDisableFlags = SB_DISABLE_MASK;

            if (LOBYTE(dwStyle) & (SBS_TOPALIGN | SBS_BOTTOMALIGN)) {
                if (fSize) {
                    if (LOBYTE(dwStyle) & SBS_SIZEBOXBOTTOMRIGHTALIGN) {
                        rc.left = rc.right - SYSMET(CXVSCROLL);
                        rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }

                    rc.right = rc.left + SYSMET(CXVSCROLL);
                    rc.bottom = rc.top + SYSMET(CYHSCROLL);
                } else {
                    if (LOBYTE(dwStyle) & SBS_VERT) {
                        if (LOBYTE(dwStyle) & SBS_LEFTALIGN)
                            rc.right = rc.left + SYSMET(CXVSCROLL);
                        else
                            rc.left = rc.right - SYSMET(CXVSCROLL);
                    } else {
                        if (LOBYTE(dwStyle) & SBS_TOPALIGN)
                            rc.bottom = rc.top + SYSMET(CYHSCROLL);
                        else
                            rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }
                }

                MoveWindow((HWND)hwnd, rc.left, rc.top, rc.right - rc.left,
                         rc.bottom - rc.top, FALSE);
            }
        } /* if */

        else {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                    "UxScrollBarCtlWndProc - NULL lParam for WM_CREATE\n") ;
        } /* else */

        break;

    case WM_SIZE:
        if (GetFocus() != (HWND)hwnd)
            break;

        // scroll bar has the focus -- recalc it's thumb caret size
        // no need to DeferWinEventNotify() - see CreateCaret below.
        DestroyCaret();

            //   |             |
            //   |  FALL THRU  |
            //   V             V

    case WM_SETFOCUS:
    {
        // REVIEW (phellyar) Do we want themed scroll bars to have
        //                   a caret?
        if ( !psb->GetTheme() )
        {
            SBCtlSetup(hwnd);
            RECT rcWindow;
            GetWindowRect( hwnd, &rcWindow );

            cx = (psb->_fVert ? rcWindow.right - rcWindow.left
                                : psb->_calc.cpxThumb) - 2 * SYSMET(CXEDGE);
            cy = (psb->_fVert ? psb->_calc.cpxThumb
                                : rcWindow.bottom - rcWindow.top) - 2 * SYSMET(CYEDGE);
#ifdef _VISUAL_DELTA_
            cx -= (CARET_BORDERWIDTH * 2);
            cy -= (CARET_BORDERWIDTH * 2);
#endif _VISUAL_DELTA_

            CreateCaret((HWND)hwnd, (HBITMAP)1, cx, cy);
            zzzSetSBCaretPos(hwnd);
            ShowCaret((HWND)hwnd);
        }
        break;
    }

    case WM_KILLFOCUS:
        DestroyCaret();
        break;

    case WM_ERASEBKGND:

        /*
         * Do nothing, but don't let DefWndProc() do it either.
         * It will be erased when its painted.
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if ((hdc = (HDC)wParam) == NULL) {
            hdc = BeginPaint((HWND)hwnd, (LPPAINTSTRUCT)&ps);
        }
        if (!fSize) {
            SBCtlSetup(hwnd);
            xxxDrawSB2((HWND)hwnd, &psb->_calc, hdc, psb->_fVert, psb->_wDisableFlags);
        } else {
            fSizeReal = TestWF((HWND)hwnd, WFSIZEBOX);
            if (!fSizeReal)
                SetWF((HWND)hwnd, WFSIZEBOX);

            _DrawSizeBoxFromFrame((HWND)hwnd, hdc, 0, 0);

            if (!fSizeReal)
                ClrWF((HWND)hwnd, WFSIZEBOX);
        }

        if (wParam == 0L)
            EndPaint((HWND)hwnd, (LPPAINTSTRUCT)&ps);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WM_CONTEXTMENU:
    {
        HWND hwndParent = GetParent(hwnd);
        if (hwndParent)
        {
            ScrollBar_Menu(hwndParent, hwnd, lParam, psb->_fVert);
        }
        break;

    }
    case WM_NCHITTEST:
        if (LOBYTE(dwStyle) & SBS_SIZEGRIP) {
#ifdef USE_MIRRORING
            /*
             * If the scroll bar is RTL mirrored, then
             * mirror the hittest of the grip location.
             */
            if (TestWF((HWND)hwnd, WEFLAYOUTRTL))
                return HTBOTTOMLEFT;
            else
#endif
                return HTBOTTOMRIGHT;
        } else {
            goto CallDWP;
        }
        break;

    case WM_MOUSELEAVE:
        //xxxHotTrackSBCtl(hwnd, 0, FALSE);
        psb->SetHotComponent(HTNOWHERE, psb->_fVert);
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_MOUSEMOVE:
    {
        INT ht;

        if (psb->GetHotComponent(psb->_fVert) == 0) 
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize      = sizeof(TRACKMOUSEEVENT);
            tme.dwFlags     = TME_LEAVE;
            tme.hwndTrack   = hwnd;
            tme.dwHoverTime = 0;

            TrackMouseEvent(&tme);
        }

        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ht = HitTestScrollBar((HWND)hwnd, psb->_fVert, pt);
        if (psb->GetHotComponent(psb->_fVert) != ht) 
        {
            //xxxHotTrackSBCtl(hwnd, ht, TRUE);
            psb->SetHotComponent(ht, psb->_fVert);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    }
    case WM_LBUTTONDBLCLK:
        cmd = SC_ZOOM;
        if (fSize)
            goto postmsg;

        /*
         *** FALL THRU **
         */

    case WM_LBUTTONDOWN:
            //
            // Note that SBS_SIZEGRIP guys normally won't ever see button
            // downs.  This is because they return HTBOTTOMRIGHT to
            // WindowHitTest handling.  This will walk up the parent chain
            // to the first sizeable ancestor, bailing out at caption windows
            // of course.  That dude, if he exists, will handle the sizing
            // instead.
            //
        if (!fSize) {
            if (TestWF((HWND)hwnd, WFTABSTOP)) {
                SetFocus((HWND)hwnd);
            }

            HideCaret((HWND)hwnd);
            SBCtlSetup(hwnd);

            /*
             * SBCtlSetup enters SEM_SB, and _SBTrackInit leaves it.
             */
            _SBTrackInit((HWND)hwnd, lParam, 0, (GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            break;
        } else {
            cmd = SC_SIZE;
postmsg:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            ClientToScreen((HWND)hwnd, &pt);
            lParam = MAKELONG(pt.x, pt.y);

            /*
             * convert HT value into a move value.  This is bad,
             * but this is purely temporary.
             */
#ifdef USE_MIRRORING
            if (TestWF(GetParent(hwnd),WEFLAYOUTRTL))
            {
                uSide = HTBOTTOMLEFT;
            } 
            else 
#endif
            {
                uSide = HTBOTTOMRIGHT;
            }
            ThreadLock(((HWND)hwnd)->hwndParent, &tlpwndParent);
            SendMessage(GetParent(hwnd), WM_SYSCOMMAND,
                    (cmd | (uSide - HTSIZEFIRST + 1)), lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_KEYUP:
        switch (wParam) {
        case VK_HOME:
        case VK_END:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:

            /*
             * Send end scroll uMsg when user up clicks on keyboard
             * scrolling.
             *
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll( (HWND)hwnd, GetParent(hwnd),
                         SB_ENDSCROLL, 0, psb->_fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_HOME:
            wParam = SB_TOP;
            goto KeyScroll;

        case VK_END:
            wParam = SB_BOTTOM;
            goto KeyScroll;

        case VK_PRIOR:
            wParam = SB_PAGEUP;
            goto KeyScroll;

        case VK_NEXT:
            wParam = SB_PAGEDOWN;
            goto KeyScroll;

        case VK_LEFT:
        case VK_UP:
            wParam = SB_LINEUP;
            goto KeyScroll;

        case VK_RIGHT:
        case VK_DOWN:
            wParam = SB_LINEDOWN;
KeyScroll:

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((HWND)hwnd, GetParent(hwnd), (int)wParam, 0, psb->_fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_ENABLE:
        return SendMessage((HWND)hwnd, SBM_ENABLE_ARROWS,
               (wParam ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH), 0);

    case SBM_ENABLE_ARROWS:

        /*
         * This is used to enable/disable the arrows in a SB ctrl
         */
        return (LONG)xxxEnableSBCtlArrows((HWND)hwnd, (UINT)wParam);

    case SBM_GETPOS:
        return (LONG)psb->_calc.data.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psb->_calc.data.posMin;
        *((LPINT)lParam) = psb->_calc.data.posMax;
        return MAKELRESULT(LOWORD(psb->_calc.data.posMin), LOWORD(psb->_calc.data.posMax));

    case SBM_GETSCROLLINFO:
        return (LONG)_SBGetParms((HWND)hwnd, SB_CTL, (PSBDATA)&psb->_calc, (LPSCROLLINFO) lParam);

    case SBM_SETRANGEREDRAW:
        fRedraw = TRUE;

    case SBM_SETRANGE:
        // Save the old values of Min and Max for return value
        si.cbSize = sizeof(si);
//        si.nMin = LOWORD(lParam);
//        si.nMax = HIWORD(lParam);
        si.nMin = (int)wParam;
        si.nMax = (int)lParam;
        si.fMask = SIF_RANGE | SIF_RETURNOLDPOS;
        goto SetInfo;

    case SBM_SETPOS:
        fRedraw = (BOOL) lParam;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS | SIF_RETURNOLDPOS;
        si.nPos  = (int)wParam;
        goto SetInfo;

    case SBM_SETSCROLLINFO:
    {
        lpsi = (LPSCROLLINFO) lParam;
        fRedraw = (BOOL) wParam;
SetInfo:
        fScroll = TRUE;
        lres = SBSetParms((PSBDATA)&psb->_calc, lpsi, &fScroll, &lres);

        if (SBSetParms((PSBDATA)&psb->_calc, lpsi, &fScroll, &lres))
        {
            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_SELF);
        }

        if (!fRedraw)
            return lres;

        /*
         * We must set the new position of the caret irrespective of
         * whether the window is visible or not;
         * Still, this will work only if the app has done a xxxSetScrollPos
         * with fRedraw = TRUE;
         * Fix for Bug #5188 --SANKAR-- 10-15-89
         * No need to DeferWinEventNotify since hwnd is locked.
         */
        HideCaret((HWND)hwnd);
        SBCtlSetup(hwnd);
        zzzSetSBCaretPos(hwnd);

            /*
             ** The following ShowCaret() must be done after the DrawThumb2(),
             ** otherwise this caret will be erased by DrawThumb2() resulting
             ** in this bug:
             ** Fix for Bug #9263 --SANKAR-- 02-09-90
             *
             */

            /*
             *********** ShowCaret((HWND)hwnd); ******
             */

        if (_FChildVisible((HWND)hwnd) && fRedraw)
        {
            UINT    wDisable;
            HBRUSH  hbrUse;

            if (!fScroll)
                fScroll = !(lpsi->fMask & SIF_DISABLENOSCROLL);

            wDisable = (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;
            xxxEnableScrollBar((HWND) hwnd, SB_CTL, wDisable);

            hdc = GetWindowDC((HWND)hwnd);
            if (hdc)
            {
                BOOL fOwnerBrush = FALSE;

                hbrUse = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
                hbrSave = SelectBrush(hdc, hbrUse);

                // Before we used to only hideshowthumb() if the mesage was
                // not SBM_SETPOS.  I am not sure why but this case was ever
                // needed for win 3.x but on NT it resulted in trashing the border
                // of the scrollbar when the app called SetScrollPos() during
                // scrollbar tracking.  - mikehar 8/26
                DrawThumb2((HWND)hwnd, &psb->_calc, hdc, hbrUse, psb->_fVert, psb->_wDisableFlags, fOwnerBrush);
                SelectBrush(hdc, hbrSave);
                ReleaseDC(hwnd, hdc);
            }
        }

            /*
             * This ShowCaret() has been moved to this place from above
             * Fix for Bug #9263 --SANKAR-- 02-09-90
             */
        ShowCaret((HWND)hwnd);
        return lres;
    }

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
             return MSAA_CLASSNAMEIDX_SCROLLBAR;
        }

        break;

    case WM_THEMECHANGED:

        psb->ChangeSBTheme();
        InvalidateRect(hwnd, NULL, TRUE);

        break;

    default:

CallDWP:
        return DefWindowProc((HWND)hwnd, uMsg, wParam, lParam);

    }

    return 0L;
}

//-------------------------------------------------------------------------//
//  Globals
static HBRUSH g_hbrGray = NULL;

//-------------------------------------------------------------------------//
HBRUSH _UxGrayBrush(VOID)
{
    if( NULL == g_hbrGray )
    {
        CONST static WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};
        HBITMAP hbmGray;
        /*
         * Create a gray brush to be used with GrayString
         */
        if( (hbmGray = CreateBitmap(8, 8, 1, 1, (LPBYTE)patGray)) != NULL )
        {
            g_hbrGray  = CreatePatternBrush(hbmGray);
            DeleteObject( hbmGray );
        }
    }
    return g_hbrGray;
}

//-------------------------------------------------------------------------//
void _UxFreeGDIResources()
{
    DeleteObject( g_hbrGray );
}

//-------------------------------------------------------------------------//
void _RedrawFrame( HWND hwnd )
{
    CheckLock(hwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
                  SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
}

//-------------------------------------------------------------------------//
//  from winmgr.c
BOOL _FChildVisible( HWND hwnd )
{
    while (GetWindowStyle( hwnd ) & WS_CHILD )
    {
        if( NULL == (hwnd = GetParent(hwnd)) )
        if (!TestWF(hwnd, WFVISIBLE))
            return FALSE;
    }

    return TRUE;
}


//-------------------------------------------------------------------------//
//
// SizeBoxHwnd
//
// Returns the HWND that will be sized if the user drags in the given window's
// sizebox -- If NULL, then the sizebox is not needed
//
// Criteria for choosing what window will be sized:
// find first sizeable parent; if that parent is not maximized and the child's
// bottom, right corner is within a scroll bar height and width of the parent's
//
HWND SizeBoxHwnd(HWND hwnd)
{
    BOOL bMirroredSizeBox = (BOOL)TestWF(hwnd, WEFLAYOUTRTL);
    RECT rc;
    int  xbrChild;
    int  ybrChild;

    GetWindowRect(hwnd, &rc);
    
    xbrChild = bMirroredSizeBox ? rc.left : rc.right;
    ybrChild = rc.bottom;

    while (hwnd != HWND_DESKTOP)
    {
        if (TestWF(hwnd, WFSIZEBOX)) 
        {
            //
            // First sizeable parent found
            //
            int xbrParent;
            int ybrParent;

            if (TestWF(hwnd, WFMAXIMIZED))
            {
                return NULL;
            }

            GetWindowRect(hwnd, &rc);

            xbrParent = bMirroredSizeBox ? rc.left : rc.right;
            ybrParent = rc.bottom;

            //
            // the sizebox dude is within an EDGE of the client's bottom
            // right corner (left corner for mirrored windows), let this succeed.
            // That way people who draw their own sunken clients will be happy.
            //
            if (bMirroredSizeBox) 
            {
                if ((xbrChild - SYSMETRTL(CXFRAME) > xbrParent) || (ybrChild + SYSMETRTL(CYFRAME) < ybrParent)) 
                {
                    //
                    // Child's bottom, left corner of SIZEBOX isn't close enough
                    // to bottom left of parent's client.
                    //
                    return NULL;
                }
            } 
            else
            {
                if ((xbrChild + SYSMETRTL(CXFRAME) < xbrParent) || (ybrChild + SYSMETRTL(CYFRAME) < ybrParent)) 
                {
                    //
                    // Child's bottom, right corner of SIZEBOX isn't close enough
                    // to bottom right of parent's client.
                    //
                    return NULL;
                }
            }

            return hwnd;
        }

        if (!TestWF(hwnd, WFCHILD) || TestWF(hwnd, WFCPRESENT))
        {
            break;
        }

        hwnd = GetParent(hwnd); 
    }

    return NULL;
}


//-------------------------------------------------------------------------//
//
// _DrawPushButton
//
// From ntuser\rtl\draw.c
// Draws a push style button in the given state.  Adjusts passed in rectangle
// if desired.
//
// Algorithm:
// Depending on the state we either draw
//      - raised edge   (undepressed)
//      - sunken edge with extra shadow (depressed)
// If it is an option push button (a push button that is
// really a check button or a radio button like buttons
// in tool bars), and it is checked, then we draw it
// depressed with a different fill in the middle.
//
VOID _DrawPushButton(HWND hwnd, HDC hdc, LPRECT lprc, UINT state, UINT flags, BOOL fVert)
{
    RECT   rc;
    HBRUSH hbrMiddle;
    DWORD  rgbBack = 0;
    DWORD  rgbFore = 0;
    BOOL   fDither;
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    if ( !hTheme )
    {
        rc = *lprc;

        DrawEdge(hdc,
                 &rc,
                 (state & (DFCS_PUSHED | DFCS_CHECKED)) ? EDGE_SUNKEN : EDGE_RAISED,
                 (UINT)(BF_ADJUST | BF_RECT | (flags & (BF_SOFT | BF_FLAT | BF_MONO))));

        //
        // BOGUS
        // On monochrome, need to do something to make pushed buttons look
        // better.
        //

        //
        // Fill in middle.  If checked, use dither brush (gray brush) with
        // black becoming normal color.
        //
        fDither = FALSE;

        if (state & DFCS_CHECKED) 
        {
            if ((GetDeviceCaps(hdc, BITSPIXEL) /*gpsi->BitCount*/ < 8) || (SYSRGBRTL(3DHILIGHT) == RGB(255,255,255))) 
            {
                hbrMiddle = _UxGrayBrush();
                rgbBack = SetBkColor(hdc, SYSRGBRTL(3DHILIGHT));
                rgbFore = SetTextColor(hdc, SYSRGBRTL(3DFACE));
                fDither = TRUE;
            } 
            else 
            {
                hbrMiddle = SYSHBR(3DHILIGHT);
            }

        } 
        else 
        {
            hbrMiddle = SYSHBR(3DFACE);
        }

        FillRect(hdc, &rc, hbrMiddle);

        if (fDither) 
        {
            SetBkColor(hdc, rgbBack);
            SetTextColor(hdc, rgbFore);
        }

        if (flags & BF_ADJUST)
        {
            *lprc = rc;
        }
    }
    else
    {
        INT  iStateId;
        INT  iPartId;
        SIZE sizeGrip;
        RECT rcContent;
        PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

        if ((CUxScrollBarCtl::GetDisableFlags(hwnd) & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)
        {
            iStateId = SCRBS_DISABLED;
        }
        else if (pSBTrack && ((BOOL)pSBTrack->fTrackVert == fVert) && (pSBTrack->cmdSB == SB_THUMBPOSITION))
        {
            iStateId = SCRBS_PRESSED;
        }
        else if (CUxScrollBar::GetSBHotComponent(hwnd, fVert) == HTSCROLLTHUMB)
        {
            iStateId = SCRBS_HOT;
        }
        else
        {
            iStateId = SCRBS_NORMAL;
        }

        iPartId = fVert ? SBP_THUMBBTNVERT : SBP_THUMBBTNHORZ;

        //
        // Draw the thumb
        //
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, lprc, 0);
        
        //
        // Lastly draw the little gripper image, if there is enough room 
        //
        if ( SUCCEEDED(GetThemeBackgroundContentRect(hTheme, hdc, iPartId, iStateId, lprc, &rcContent)) )
        {
            iPartId = fVert ? SBP_GRIPPERVERT : SBP_GRIPPERHORZ;

            if ( SUCCEEDED(GetThemePartSize(hTheme, hdc, iPartId, iStateId, &rcContent, TS_TRUE, &sizeGrip)) )
            {
                if ( (sizeGrip.cx < RECTWIDTH(&rcContent)) && (sizeGrip.cy < RECTHEIGHT(&rcContent)) )
                {
                    DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rcContent, 0);
                }
            }
        }                   
    }
}


//  user.h
#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000
         
//  mnaccel.h         
/***************************************************************************\
* _SysToChar
*
* EXIT: If the message was not made with the ALT key down, convert
*       the message from a WM_SYSKEY* to a WM_KEY* message.
*
* IMPLEMENTATION:
*     The 0x2000 bit in the hi word of lParam is set if the key was
*     made with the ALT key down.
*
* History:
*   11/30/90 JimA       Ported.
\***************************************************************************/

UINT _SysToChar(
    UINT message,
    LPARAM lParam)
{
    if (CheckMsgFilter(message, WM_SYSKEYDOWN, WM_SYSDEADCHAR) &&
            !(HIWORD(lParam) & SYS_ALTERNATE))
        return (message - (WM_SYSKEYDOWN - WM_KEYDOWN));

    return message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\scrollp.h ===
//-------------------------------------------------------------------------//
//  
//  scrollp.h
//
//  Definitions and decls used exclusively by the win32K->uxtheme scrollbar 
//  port for non-client theming.  Many of the same definitions are duplicated in 
//  usrctl32.h for base control ports to comctl [scotthan]
//
//-------------------------------------------------------------------------//
#ifndef __SCROLLPORT_H__
#define __SCROLLPORT_H__

#define SIF_RETURNOLDPOS        0x1000

#define SB_DISABLE_MASK         ESB_DISABLE_BOTH
#define abs(x)                  (((x)<0) ? -1 * x : x)
#define TEST_FLAG(dw,f)         ((BOOL)((dw) & (f)))
#define SYSMET(i)               NcGetSystemMetrics( SM_##i )
#define SYSMETRTL(i)            NcGetSystemMetrics( SM_##i )
#define SYSRGB(i)               GetSysColor(COLOR_##i)
#define SYSRGBRTL(i)            GetSysColor(COLOR_##i)
#define SYSHBR(i)               GetSysColorBrush(COLOR_##i)

#define UserAssert(x)

#define SelectBrush             (HBRUSH)SelectObject
#define GetWindowStyle(hwnd)    GetWindowLong(hwnd,GWL_STYLE)
#define GetWindowExStyle(hwnd)  GetWindowLong(hwnd,GWL_EXSTYLE)

//  lparam->point crackers from user.h
#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)    ((int)(short)LOWORD(lp))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)    ((int)(short)HIWORD(lp))

// from comctl32 v6
#define MSAA_CLASSNAMEIDX_SCROLLBAR (65536L + 10)
#endif

//-------------------------------------------------------------------------//
//  private DrawFrameControl values (winuserp.h)
//#define DFC_CACHE               0xFFFF
//#define DFCS_INMENU             0x0040
//#define DFCS_INSMALL            0x0080
#define DFCS_SCROLLMIN          0x0000
#define DFCS_SCROLLVERT         0x0000
#define DFCS_SCROLLMAX          0x0001
#define DFCS_SCROLLHORZ         0x0002
//#define DFCS_SCROLLLINE         0x0004

//-------------------------------------------------------------------------//
//  internal window state/style bits
#define WFMPRESENT              0x0001
#ifndef _UXTHEME_
#define WFVPRESENT              0x0002
#define WFHPRESENT              0x0004
#else _UXTHEME_
#define WFVPRESENT              WFVSCROLL /*0x0002*/
#define WFHPRESENT              WFHSCROLL /*0x0004*/
#endif _UXTHEME_
#define WFCPRESENT              0x0008
#define WFFRAMEPRESENTMASK      0x000F

#define WFSENDSIZEMOVE          0x0010
#define WFMSGBOX                0x0020  // used to maintain count of msg boxes on screen
#define WFFRAMEON               0x0040
#define WFHASSPB                0x0080
#define WFNONCPAINT             0x0101
#define WFSENDERASEBKGND        0x0102
#define WFERASEBKGND            0x0104
#define WFSENDNCPAINT           0x0108
#define WFINTERNALPAINT         0x0110
#define WFUPDATEDIRTY           0x0120
#define WFHIDDENPOPUP           0x0140
#define WFMENUDRAW              0x0180

/*
 * NOTE -- WFDIALOGWINDOW is used in WOW.  DO NOT CHANGE without
 *   changing WD_DIALOG_WINDOW in winuser.w
 */
#define WFDIALOGWINDOW          0x0201

#define WFTITLESET              0x0202
#define WFSERVERSIDEPROC        0x0204
#define WFANSIPROC              0x0208
#define WFBEINGACTIVATED        0x0210  // prevent recursion in xxxActivateThis Window
#define WFHASPALETTE            0x0220
#define WFPAINTNOTPROCESSED     0x0240  // WM_PAINT message not processed
#define WFSYNCPAINTPENDING      0x0280
#define WFGOTQUERYSUSPENDMSG    0x0301
#define WFGOTSUSPENDMSG         0x0302
#define WFTOGGLETOPMOST         0x0304  // Toggle the WS_EX_TOPMOST bit ChangeStates

/*
 * DON'T MOVE REDRAWIFHUNGFLAGS WITHOUT ADJUSTING WFANYHUNGREDRAW
 */
#define WFREDRAWIFHUNG          0x0308
#define WFREDRAWFRAMEIFHUNG     0x0310
#define WFANYHUNGREDRAW         0x0318

#define WFANSICREATOR           0x0320
#define WFREALLYMAXIMIZABLE     0x0340  // The window fills the work area or monitor when maximized
#define WFDESTROYED             0x0380
#define WFWMPAINTSENT           0x0401
#define WFDONTVALIDATE          0x0402
#define WFSTARTPAINT            0x0404
#define WFOLDUI                 0x0408
#define WFCEPRESENT             0x0410  // Client edge present
#define WFBOTTOMMOST            0x0420  // Bottommost window
#define WFFULLSCREEN            0x0440
#define WFINDESTROY             0x0480

/*
 * DON'T MOVE ANY ONE OF THE FOLLOWING WFWINXXCOMPAT FLAGS,
 * BECAUSE WFWINCOMPATMASK DEPENDS ON THEIR VALUES
 */
#define WFWIN31COMPAT           0x0501  // Win 3.1 compatible window
#define WFWIN40COMPAT           0x0502  // Win 4.0 compatible window
#define WFWIN50COMPAT           0x0504  // Win 5.0 compatibile window
#define WFWINCOMPATMASK         0x0507  // Compatibility flag mask

#define WFMAXFAKEREGIONAL       0x0508  // Window has a fake region for maxing on 1 monitor

// Active Accessibility (Window Event) state
#define WFCLOSEBUTTONDOWN       0x0510
#define WFZOOMBUTTONDOWN        0x0520
#define WFREDUCEBUTTONDOWN      0x0540
#define WFHELPBUTTONDOWN        0x0580
#define WFLINEUPBUTTONDOWN      0x0601  // Line up/left scroll button down
#define WFPAGEUPBUTTONDOWN      0x0602  // Page up/left scroll area down
#define WFPAGEDNBUTTONDOWN      0x0604  // Page down/right scroll area down
#define WFLINEDNBUTTONDOWN      0x0608  // Line down/right scroll area down
#define WFSCROLLBUTTONDOWN      0x0610  // Any scroll button down?
#define WFVERTSCROLLTRACK       0x0620  // Vertical or horizontal scroll track...

#define WFALWAYSSENDNCPAINT     0x0640  // Always send WM_NCPAINT to children
#define WFPIXIEHACK             0x0680  // Send (HRGN)1 to WM_NCPAINT (see PixieHack)

/*
 * WFFULLSCREENBASE MUST HAVE LOWORD OF 0. See SetFullScreen macro.
 */
#define WFFULLSCREENBASE        0x0700  // Fullscreen flags take up 0x0701
#define WFFULLSCREENMASK        0x0707  // and 0x0702 and 0x0704
#define WEFTRUNCATEDCAPTION     0x0708  // The caption text was truncated -> caption tootip

#define WFNOANIMATE             0x0710  // ???
#define WFSMQUERYDRAGICON       0x0720  // ??? Small icon comes from WM_QUERYDRAGICON
#define WFSHELLHOOKWND          0x0740  // ???
#define WFISINITIALIZED         0x0780  // Window is initialized -- checked by WoW32

/*
 * Add more state flags here, up to 0x0780.
 * Look for empty slots above before adding to the end.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */

/*
 * Window Extended Style, from 0x0800 to 0x0B80.
 */
#define WEFDLGMODALFRAME        0x0801  // WS_EX_DLGMODALFRAME
#define WEFDRAGOBJECT           0x0802  // ???
#define WEFNOPARENTNOTIFY       0x0804  // WS_EX_NOPARENTNOTIFY
#define WEFTOPMOST              0x0808  // WS_EX_TOPMOST
#define WEFACCEPTFILES          0x0810  // WS_EX_ACCEPTFILES
#define WEFTRANSPARENT          0x0820  // WS_EX_TRANSPARENT
#define WEFMDICHILD             0x0840  // WS_EX_MDICHILD
#define WEFTOOLWINDOW           0x0880  // WS_EX_TOOLWINDOW
#define WEFWINDOWEDGE           0x0901  // WS_EX_WINDOWEDGE
#define WEFCLIENTEDGE           0x0902  // WS_EX_CLIENTEDGE
#define WEFEDGEMASK             0x0903  // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
#define WEFCONTEXTHELP          0x0904  // WS_EX_CONTEXTHELP


// intl styles
#define WEFRIGHT                0x0910  // WS_EX_RIGHT
#define WEFRTLREADING           0x0920  // WS_EX_RTLREADING
#define WEFLEFTSCROLL           0x0940  // WS_EX_LEFTSCROLLBAR


#define WEFCONTROLPARENT        0x0A01  // WS_EX_CONTROLPARENT
#define WEFSTATICEDGE           0x0A02  // WS_EX_STATICEDGE
#define WEFAPPWINDOW            0x0A04  // WS_EX_APPWINDOW
#define WEFLAYERED              0x0A08  // WS_EX_LAYERED

#ifdef USE_MIRRORING
#define WEFNOINHERITLAYOUT      0x0A10  // WS_EX_NOINHERITLAYOUT
#define WEFLAYOUTVBHRESERVED    0x0A20  // WS_EX_LAYOUTVBHRESERVED
#define WEFLAYOUTRTL            0x0A40  // WS_EX_LAYOUTRTL
#define WEFLAYOUTBTTRESERVED    0x0A80  // WS_EX_LAYOUTBTTRESERVED
#endif

/*
 * To delay adding a new state3 DWORD in the WW structure, we're using
 * the extended style bits for now.  If we'll need more of these, we'll
 * add the new DWORD and move these ones around
 */
#define WEFPUIFOCUSHIDDEN         0x0B80  // focus indicators hidden
#define WEFPUIACCELHIDDEN         0x0B40  // keyboard acceleraors hidden
#define WEFPREDIRECTED            0x0B20  // redirection bit
#define WEFPCOMPOSITING           0x0B10  // compositing

/*
 * Add more Window Extended Style flags here, up to 0x0B80.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */
#ifdef REDIRECTION
#define WEFMSR                  0x0B01   // WS_EX_MSR
#endif // REDIRECTION

#define WEFCOMPOSITED           0x0B02   // WS_EX_COMPOSITED
#define WEFNOACTIVATE           0x0B08   // WS_EX_NOACTIVATE

#ifdef LAME_BUTTON
#define WEFLAMEBUTTONON         0x0908   // the "comments" button is displayed
#endif // LAME_BUTTON

/*
 * Window styles, from 0x0E00 to 0x0F80.
 */
#define WFMAXBOX                0x0E01  // WS_MAXIMIZEBOX
#define WFTABSTOP               0x0E01  // WS_TABSTOP
#define WFMINBOX                0x0E02  // WS_MAXIMIZEBOX
#define WFGROUP                 0x0E02  // WS_GROUP
#define WFSIZEBOX               0x0E04  // WS_THICKFRAME, WS_SIZEBOX
#define WFSYSMENU               0x0E08  // WS_SYSMENU
#define WFHSCROLL               0x0E10  // WS_HSCROLL
#define WFVSCROLL               0x0E20  // WS_VSCROLL
#define WFDLGFRAME              0x0E40  // WS_DLGFRAME
#define WFTOPLEVEL              0x0E40  // ???
#define WFBORDER                0x0E80  // WS_BORDER
#define WFBORDERMASK            0x0EC0  // WS_BORDER | WS_DLGFRAME
#define WFCAPTION               0x0EC0  // WS_CAPTION

#define WFTILED                 0x0F00  // WS_OVERLAPPED, WS_TILED
#define WFMAXIMIZED             0x0F01  // WS_MAXIMIZE
#define WFCLIPCHILDREN          0x0F02  // WS_CLIPCHILDREN
#define WFCLIPSIBLINGS          0x0F04  // WS_CLIPSIBLINGS
#define WFDISABLED              0x0F08  // WS_DISABLED
#define WFVISIBLE               0x0F10  // WS_VISIBLE
#define WFMINIMIZED             0x0F20  // WS_MINIMIZE
#define WFCHILD                 0x0F40  // WS_CHILD
#define WFPOPUP                 0x0F80  // WS_POPUP
#define WFTYPEMASK              0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONICPOPUP           0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONIC                WFMINIMIZED

#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000

//-------------------------------------------------------------------------//
//  Utility fn forwards.
LONG          TestWF(HWND hwnd, DWORD flag);
void          SetWindowState( HWND hwnd, UINT flags);
void          ClearWindowState( HWND hwnd, UINT flags);


#endif  __SCROLLPORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\scroll.h ===
#ifndef __SCROLL_H__
#define __SCROLL_H__

//-------------------------------------------------------------------------//
#ifndef WC_SCROLLBAR
// ScrollBar Ctl Class Name
#define WC_SCROLLBARW         L"UxScrollBar"
#define WC_SCROLLBARA         "UxScrollBar"

#ifdef UNICODE
#define WC_SCROLLBAR          WC_SCROLLBARW
#else
#define WC_SCROLLBAR          WC_SCROLLBARA
#endif
#endif WC_SCROLLBAR

//-------------------------------------------------------------------------//
//  Window scroll bar methods
void    WINAPI DrawSizeBox( HWND, HDC, int x, int y);
void    WINAPI DrawScrollBar( HWND, HDC, LPRECT, BOOL fVert);
HWND    WINAPI SizeBoxHwnd( HWND hwnd );
BOOL    WINAPI ScrollBar_MouseMove( HWND, LPPOINT, BOOL fVert);
VOID    WINAPI ScrollBar_Menu(HWND, HWND, LPARAM, BOOL fVert);
void    WINAPI HandleScrollCmd( HWND hwnd, WPARAM wParam, LPARAM lParam );
void    WINAPI DetachScrollBars( HWND hwnd );
void    WINAPI AttachScrollBars( HWND hwnd );
LONG    WINAPI ThemeSetScrollInfo( HWND, int, LPCSCROLLINFO, BOOL );
BOOL    WINAPI ThemeGetScrollInfo( HWND, int, LPSCROLLINFO );
BOOL    WINAPI ThemeEnableScrollBar( HWND, UINT, UINT );


#endif  //__SCROLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\services.h ===
//  --------------------------------------------------------------------------
//  Module Name: Services.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  APIs to communicate with the theme service.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

#ifndef     _UxThemeServices_
#define     _UxThemeServices_

//  --------------------------------------------------------------------------
//  CThemeServices
//
//  Purpose:    Class to implement APIs to communicate with the theme service.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

class   CThemeServices
{
    private:
                                    CThemeServices (void);
                                    ~CThemeServices (void);
    public:
        static  void                StaticInitialize (void);
        static  void                StaticTerminate (void);

        //  These are calls to the server.

        static  HRESULT             ThemeHooksOn (HWND hwndTarget);
        static  HRESULT             ThemeHooksOff (void);
        static  HRESULT             GetStatusFlags (DWORD *pdwFlags);
        static  HRESULT             GetCurrentChangeNumber (int *piValue);
        static  HRESULT             GetNewChangeNumber (int *piValue);
        static  HRESULT             SetGlobalTheme (HANDLE hSection);
        static  HRESULT             GetGlobalTheme (HANDLE *phSection);
        static  HRESULT             CheckThemeSignature (const WCHAR *pszThemeName);
        static  HRESULT             LoadTheme (HANDLE *phSection, const WCHAR *pszThemeName, const WCHAR *pszColor, const WCHAR *pszSize, BOOL fGlobal);

        //  These are calls implemented on the client side
        //  that may make calls to the server.

        static  HRESULT             ApplyTheme (CUxThemeFile *pThemeFile, DWORD dwFlags, HWND hwndTarget);
        static  HRESULT             InitUserTheme (BOOL fPolicyCheckOnly = FALSE);
        static  HRESULT             AdjustTheme(BOOL fEnable);
        static  HRESULT             InitUserRegistry (void);

        //  These are special private APIs

        static  HRESULT             ReestablishServerConnection (void);
        static  HRESULT             ClearStockObjects (HANDLE hSection, BOOL fForce = FALSE);
    private:
        static  void                ApplyDefaultMetrics(void);
        static  void                LockAcquire (void);
        static  void                LockRelease (void);
        static  bool                ConnectedToService (void);
        static  void                ReleaseConnection (void);
        static  void                CheckForDisconnectedPort (NTSTATUS status);
        static  bool                CurrentThemeMatch (LPCWSTR pszThemeName, LPCWSTR pszColor, LPCWSTR pszSize, LANGID wLangID, bool fLoadMetricsOnMatch);
        static  HRESULT             LoadCurrentTheme (void);
        static  int                 SectionProcessType (const BYTE *pbThemeData, MIXEDPTRS& u);
        static  void                SectionWalkData (const BYTE *pbThemeData, int iIndex);
        static  bool                ThemeSettingsModified (void);
        static  bool                ThemeEnforcedByPolicy (bool fActive);
        static  HRESULT             CheckColorDepth(CUxThemeFile *pThemeFile);
        static  HRESULT             UpdateThemeRegistry(BOOL fNewTheme, LPCWSTR pszThemeFileName, 
                                        LPCWSTR pszColorParam, LPCWSTR pszSizeParam, BOOL fJustSetActive, BOOL fJustApplied);
        static  void                SendThemeChangedMsg(BOOL fNewTheme, HWND hwndTarget, DWORD dwFlags,
                                        int iLoadId);
        static  int                 GetLoadId(HANDLE hSectionOld);
    private:
        static  CRITICAL_SECTION    s_lock;
        static  HANDLE              s_hAPIPort;
        static  const WCHAR         s_szDefault[];
};

#endif  /*  _UxThemeServices_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\scrollp.cpp ===
//-------------------------------------------------------------------------//
//  Module Name: scrollp.cpp
//  
//  Copyright (c) 1985 - 1999, Microsoft Corporation
//  
//  win32k->uxtheme port routines for scrollbar
//  
//  History:
//  03-21-00 ScottHan   Created
//-------------------------------------------------------------------------//
#include "stdafx.h"
#include "scrollp.h"

extern HBRUSH  _UxGrayBrush(VOID);
extern void    _UxFreeGDIResources();

enum {
    WF_STATE1 = 0,
    WF_STATE2,
    WF_EXSTYLE,
    WF_STYLE,
};

//-------------------------------------------------------------------------//
ULONG _ExpandWF( ULONG ulRaw, ULONG* pulField )
{
    ULONG ulField  = ( HIBYTE(ulRaw) & 0xFC ) >> 2;
    ULONG ulShift  = HIBYTE(ulRaw) & 0x03;
    ULONG ulResult = LOBYTE(ulRaw) << (ulShift << 3);
    if( pulField )
        *pulField  = ulField;
    return ulResult;
}

//-------------------------------------------------------------------------//
//  From usrctl32.h/.cpp
void SetWindowState(
    HWND hwnd,
    UINT flags)
{
    ULONG ulField;
    ULONG ulVal = _ExpandWF( flags, &ulField );

    if( WF_EXSTYLE == ulField || WF_STYLE == ulField)
    {
        ULONG dwBits = 0;
        ULONG dwGwl = (WF_EXSTYLE == ulField) ? GWL_EXSTYLE : 
                      (WF_STYLE   == ulField) ? GWL_STYLE : 0;
        UserAssert(dwGwl);

        dwBits = GetWindowLong( hwnd, dwGwl );

        if( (dwBits & ulVal) != ulVal )
            SetWindowLong(hwnd, dwGwl, dwBits | ulVal );
    }
}

//-------------------------------------------------------------------------//
//  From usrctl32.h/.cpp
void ClearWindowState(
    HWND hwnd,
    UINT flags)
{
    ULONG ulField;
    ULONG ulVal = _ExpandWF( flags, &ulField );

    if( WF_EXSTYLE == ulField || WF_STYLE == ulField)
    {
        ULONG dwBits = 0;
        ULONG dwGwl = (WF_EXSTYLE == ulField) ? GWL_EXSTYLE : 
                      (WF_STYLE   == ulField) ? GWL_STYLE : 0;
        UserAssert(dwGwl);

        dwBits = GetWindowLong( hwnd, dwGwl );

        if( (dwBits & ulVal) != ulVal )
            SetWindowLong(hwnd, dwGwl, dwBits &= ~ulVal );
    }
}

//-------------------------------------------------------------------------//
//  window bitfield discriminator (in lobyte of internal flags)
#define WF_SEL_STATE    0x00
#define WF_SEL_STATE2   0x04
#define WF_SEL_STYLE_EX 0x08
#define WF_SEL_STYLE    0x0C

#ifdef _WIN64
#undef GWL_WOWWORDS
#endif /* _WIN64 */
#define GWLP_WOWWORDS       (-1)
#define GCL_WOWWORDS        (-27)
#define GCL_WOWMENUNAME     (-29)
#ifdef _WIN64
#undef GCL_WOWWORDS
#endif /* _WIN64 */
#define GCLP_WOWWORDS       (-27)

LONG TestWF(HWND hwnd, DWORD flag)
{
    LPDWORD pdwWW;

    // GWLP_WOWWORDS returns a pointer to the WW struct in the hwnd.
    // We're interest in the first four DWORDS: state, state2, 
    // ExStyle (exposed, although not all bits, by GetWindowExStyle),
    // and style (exposed by GetWindowStyle). 
    //
    // The parameter flag, contains information on how to pick the field 
    // we want and how to build the WS_xxx or WS_EX_xxx we want to 
    // check for. 
    // 
    // See UsrCtl32.h for more details on how this is done. 
    //
    pdwWW = (LPDWORD)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if ( pdwWW )
    {
        INT  iField;     // the field we want
        INT  iShift;     // how many bytes to shift flag
        LONG ulMask;     // WS_xxx or WS_EX_xxx flag 

        iField = ( HIBYTE(flag) & 0xFC ) >> 2;
        iShift = HIBYTE(flag) & 0x03;
        ulMask = LOBYTE(flag) << (iShift << 3);

        UserAssert( 0 <= iField && iField < 4 );
        return pdwWW[iField] & ulMask;
    };

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\sethook.cpp ===
//---------------------------------------------------------------------------//
//  sethook.cpp - Window and DefWindowProc hooking impl.
//---------------------------------------------------------------------------//
#include "stdafx.h"
#include "sethook.h"
#include "handlers.h"
#include "scroll.h"
#include "nctheme.h"
#include "scroll.h"
#include <uxthemep.h>
#include "info.h"
#include "services.h"
#include "appinfo.h"
#include "tmreg.h"
#include "globals.h"
#include "renderlist.h"

//---------------------------------------------------//
//  statics
//---------------------------------------------------//
static int    _fShouldEnableApiHooks  = -1; // unitialized value
static BOOL   _fUnhooking             = FALSE;
static LONG   _cInitUAH      = 0;

static BOOL   _fSysMetCall            = FALSE; // anti-recursion bit on classic sysmet calls.
static CRITICAL_SECTION _csSysMetCall = {0};   // serialize ClassicXXX calls when hooks inactive.
extern CRITICAL_SECTION _csThemeMet;           // protects access to _nctmCurrent in nctheme.cpp
extern CRITICAL_SECTION _csNcSysMet;          // protects access to _ncmCurrent in nctheme.cpp
extern CRITICAL_SECTION _csNcPaint;            // protects thread-in-NCPAINT collection

typedef enum { PRE, DEF, POST } ePROCTYPE;

inline void ENTER_CLASSICSYSMETCALL()   { 
    if (IsAppThemed())
    {
        EnterCriticalSection(&_csSysMetCall); 
        _fSysMetCall = TRUE; 
    }
}
inline void LEAVE_CLASSICSYSMETCALL()   { 
    if (_fSysMetCall)
    {
        _fSysMetCall = FALSE; 
        LeaveCriticalSection(&_csSysMetCall); 
    }
}
inline BOOL IN_CLASSICSYSMETCALL() { 
    return _fSysMetCall;
}

//---------------------------------------------------------------------------//
typedef struct
{
    HINSTANCE       hInst;          // DLL hook instance
    USERAPIHOOK     uahReal;
} UXTHEMEHOOKS, *PUXTHEMEHOOKS;
//--------------------------------------------------------------------//

//---- Hook Instance static (unprotected - thread unsafe) ----
static UXTHEMEHOOKS  _hookinf = {0};   // one-and-only instance.

//---------------------------------------------------------------------------//
//  Module name for LoadLibrary
#define DLLNAME              TEXT(".\\UxTheme.dll")

//---------------------------------------------------------------------------//
//  UserApiHook callback functions
extern "C" 
{
BOOL WINAPI      ThemeInitApiHook( DWORD dwCmd, void * pvData );
LRESULT WINAPI   ThemeDefWindowProcA( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK ThemeDefWindowProcW( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
int  CALLBACK    ThemeSetScrollInfoProc( HWND hwnd, int nBar, IN LPCSCROLLINFO psi, BOOL fRedraw );
BOOL CALLBACK    ThemeGetScrollInfoProc( HWND hwnd, int nBar, IN OUT LPSCROLLINFO psi );
BOOL CALLBACK    ThemeEnableScrollInfoProc( HWND hwnd, UINT nSBFlags, UINT nArrows );
BOOL CALLBACK    ThemeAdjustWindowRectEx( LPRECT lprc, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
BOOL CALLBACK    ThemeSetWindowRgn( HWND hwnd, HRGN hrgn, BOOL fRedraw);
int  CALLBACK    ThemeGetSystemMetrics( int iMetric );
BOOL CALLBACK    ThemeSystemParametersInfoA( UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
BOOL CALLBACK    ThemeSystemParametersInfoW( UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
BOOL CALLBACK    ThemeDrawFrameControl( IN HDC hdc, IN OUT LPRECT, IN UINT, IN UINT );
BOOL CALLBACK    ThemeDrawCaption( IN HWND, IN HDC, IN CONST RECT *, IN UINT);
VOID CALLBACK    ThemeMDIRedrawFrame( IN HWND hwndChild, BOOL fAdd );
}

//---------------------------------------------------------------------------//
void OnHooksEnabled();                                  // forward
void OnHooksDisabled(BOOL fShutDown);                   // forward
BOOL NewThemeCheck(int iChangeNum, BOOL fMsgCheck);     // forward
//---------------------------------------------------------------------------//
BOOL WINAPI ThemeHookStartup()
{
    _hookinf.uahReal.cbSize = sizeof(_hookinf.uahReal);

    HandlerTableInit();

    InitializeCriticalSection( &_csSysMetCall );
    InitializeCriticalSection( &_csThemeMet );
    InitializeCriticalSection( &_csNcSysMet );
    InitializeCriticalSection( &_csNcPaint );

    InitNcThemeMetrics(NULL);

    Log(LOG_TMCHANGE, L"UxTheme - ThemeHookStartup");

    WindowDump(L"Startup");

    return TRUE;
}

//---------------------------------------------------------------------------//
BOOL WINAPI ThemeHookShutdown()
{
    _fUnhooking = TRUE;
    
    if (HOOKSACTIVE())        // we are hooking USER msgs
    {
        //---- tell user that we gotta go ----
        _hookinf.uahReal.pfnForceResetUserApiHook(g_hInst);
        InterlockedExchange( (LONG*)&g_eThemeHookState, HS_UNINITIALIZED );
        OnHooksDisabled(TRUE);
    }

    DeleteCriticalSection( &_csSysMetCall );
    DeleteCriticalSection( &_csThemeMet );
    DeleteCriticalSection( &_csNcSysMet );
    DeleteCriticalSection( &_csNcPaint );

    ClearNcThemeMetrics();
    NcClearNonclientMetrics();


#ifdef DEBUG
    CThemeWnd::SpewLeaks();
#endif DEBUG

    return TRUE;
}

//---------------------------------------------------------------------------//
//  Loads a DLL instance and retrieves addresses of key hook exports.
BOOL LoadHookInstance()
{
    if( _hookinf.hInst != NULL )
    {
#ifdef DEBUG
        Log(LOG_ALWAYS, L"%s hook instance already protected; refcount mismatch. No-op'ing self-load\n", DLLNAME);
#endif DEBUG
        return TRUE;
    }

    //-- Load a DLL instance
    _hookinf.hInst = LoadLibrary(DLLNAME);
    if( !_hookinf.hInst )
    {
        Log(LOG_ALWAYS, L"Cannot find dll: %s\r\r\n", DLLNAME);
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
inline BOOL IsTargetProcess(HWND hwnd = NULL)
{
    //---- if not initialize, leave everything alone ----
    if (! g_fUxthemeInitialized)
        return FALSE;

    //---- ensure this window is in our process ----
    return (HOOKSACTIVE() && (hwnd ? IsWindowProcess(hwnd, g_dwProcessId) : TRUE));
}

//---------------------------------------------------------------------------
inline void SpewHookExceptionInfo( 
    LPCSTR pszMsg, 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam )
{
#ifdef _ENABLE_HOOK_EXCEPTION_HANDLING_
    Log(LOG_ERROR, L"*** Theme Hook Exception Handler ***" );
    Log(LOG_ERROR, L"--- %s hwnd: %08lX, uMsg: %04lX, wParam: %08lX, lParam: %08lX.",
        pszMsg, hwnd, uMsg, wParam, lParam );
#endif _ENABLE_HOOK_EXCEPTION_HANDLING_
}

//---------------------------------------------------------------------------
//  Helper: initializes THEME_MSG structure in prep for call to msg handler
inline void _InitThemeMsg(
    PTHEME_MSG ptm,
    MSGTYPE    msgtype,
    BOOL       bUnicode,
    HWND       hwnd,
    UINT       uMsg,
    WPARAM     wParam,
    LPARAM     lParam,
    LRESULT    lRet = 0,
    WNDPROC    pfnDefProc = NULL )
{
#ifdef DEBUG
    if( MSGTYPE_DEFWNDPROC == msgtype )
    {
        ASSERT( pfnDefProc != NULL ); // DWP, handlers require default processing
    }
    else
    {
        ASSERT( NULL == pfnDefProc ); // no default processing for pre/post OWP, DDP callbacks
    }
#endif DEBUG

    ptm->hwnd       = hwnd;
    ptm->uMsg       = uMsg;
    ptm->uCodePage  = bUnicode ? CP_WINUNICODE : GetACP();
    ptm->wParam     = wParam;
    ptm->lParam     = lParam;
    ptm->type       = msgtype;
    ptm->lRet       = lRet;
    ptm->pfnDefProc = pfnDefProc;
    ptm->fHandled   = FALSE;
}

//---------------------------------------------------------------------------
#ifdef UNICODE
    const BOOL _fUnicode = TRUE;
#else  // UNICODE
    const BOOL _fUnicode = FALSE;
#endif // UNICODE

//---------------------------------------------------------------------------
void _PreprocessThemeChanged(HWND hwnd, WPARAM wParam, LPARAM lParam, ePROCTYPE eCallType,
    UINT *puDisposition)
{
    //---- is this msg meant for this process? ----
    if (IS_THEME_CHANGE_TARGET(lParam))
    {
        BOOL fActive = ((lParam & WTC_THEMEACTIVE) != 0);

        if (eCallType == PRE)           // only do this on the Pre (once is enough)
        {
            //Log(LOG_TMCHANGE, L"hwnd=0x%x received WM_THEMECHANGED, changenum=0x%x", 
            //    hwnd, wParam);

            ClearExStyleBits(hwnd);
        }

        //---- this part still needs to be done in both cases ----
        if(! (fActive))
            *puDisposition |= HMD_THEMEDETACH;
        else 
            *puDisposition |= HMD_CHANGETHEME;
    }
}
//---------------------------------------------------------------------------
BOOL CALLBACK TriggerCallback(HWND hwnd, LPARAM lParam)
{
    LPARAM *plParams = (LPARAM *)lParam;
    
    SafeSendMessage(hwnd, WM_THEMECHANGED, plParams[0], plParams[1]);

    return TRUE;
}
//---------------------------------------------------------------------------
void _PreprocessThemeChangedTrigger(HWND hwnd, WPARAM wParam, LPARAM lParamMixed) 
{
    int iLoadId = (int(lParamMixed) >> 4);
    LPARAM lParamBits = (int(lParamMixed) & 0xf);

    BOOL fFirstMsg = NewThemeCheck((int)wParam, TRUE);
    if (fFirstMsg)
    {
        //Log(LOG_TMLOAD, L"hwnd=0x%x received NEW WM_THEMECHANGED_TRIGGER, loadid=%d", hwnd, 
        //    iLoadId);

        //---- send WM_THEMECHANGED to all windows in this process ----
        //---- so they let go of previous theme now ----
        LPARAM lParams[2] = {wParam, lParamBits};
        EnumProcessWindows(TriggerCallback, (LPARAM)&lParams);

        if (iLoadId)      // there was a previous theme
        {
            g_pRenderList->FreeRenderObjects(iLoadId);
        }
    }
}
//---------------------------------------------------------------------------
inline UINT _PreprocessHookedMsg( 
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    ePROCTYPE eCallType )
{
    UINT uDisposition = HMD_NIL;
    static bool s_fTriggerDone = false; // For some USER-owned windows, we don't get PRE, only DEF.

    switch( uMsg )
    {
        case WM_THEMECHANGED:
        {
            _PreprocessThemeChanged(hwnd, wParam, lParam, eCallType, &uDisposition);
            break;
        }

        case WM_NCDESTROY:
            uDisposition |= HMD_WINDOWDESTROY;
            break;

        case WM_STYLECHANGED:
            uDisposition |= HMD_REATTACH;
            break;

        case WM_THEMECHANGED_TRIGGER:
            //---- NULL WPARAM means this is really a normal WM_UAHINIT msgs (shared msg num) ----
            if (wParam)
            {
                if (eCallType == PRE                            // This is the normal case
                    || (eCallType == DEF && !s_fTriggerDone))   // USER server-side window, we missed the PRE
                {
                    Log(LOG_TMCHANGE, L"Recv'd: WM_THEMECHANGED_TRIGGER, Change Num=%d", wParam);

                    _PreprocessThemeChangedTrigger(hwnd, wParam, lParam);
                }
                if (eCallType == PRE) // Mark it done for the incoming DEF call
                {
                    s_fTriggerDone = true;
                }
                else // After we're done, reset the flag for the next theme change
                {
                    s_fTriggerDone = false;
                }
            }
            break;
    }
            
    return uDisposition;
}

//---------------------------------------------------------------------------
//  Pre-CallWndProc hook procedure
BOOL CALLBACK ThemePreWndProc( 
    HWND     hwnd, 
    UINT     uMsg, 
    WPARAM   wParam, 
    LPARAM   lParam, 
    LRESULT* plRes,
    VOID**   ppvParam )
{
    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    BOOL fHandled = FALSE;

    //----------//
    LogEntryMsg(L"ThemePreWndProc", hwnd, uMsg);

    if( IsTargetProcess(hwnd) ) 
    {
        //  Retrieve window object from handle
        CThemeWnd *pwnd = CThemeWnd::FromHwnd(hwnd);

        //  #443100 InstallShield installs a global CBT hook. Their hook handler
        //  generates messages prior to the window receiving WM_NCCREATE which 
        //  causes us to exile the window prematurely because the window is temporarily
        //  parented by HWND_MESSAGE
        BOOL fPrematureExile = (EXILED_THEMEWND(pwnd) && WM_NCCREATE == uMsg);

        if ( (uMsg != WM_NCCREATE) || fPrematureExile )
        {
            //  Pre-process WM_THEMECHANGE message.
            //  Note: Pre-OWP does a detach only on theme removal.   Post-OWP takes care
            //        of window death.
            UINT uDisp        = _PreprocessHookedMsg( hwnd, uMsg, wParam, lParam, PRE );
            BOOL fLifeIsShort = TESTFLAG( uDisp, HMD_THEMEDETACH|HMD_WINDOWDESTROY );
            BOOL fDetach      = TESTFLAG( uDisp, HMD_THEMEDETACH );


            if( _WindowHasTheme(hwnd) || fLifeIsShort )
            {
                //  On STYLECHANGED or WM_THEMECHANGE, 
                //  try reattaching window that was previously rejected or failed, resp.
                if( (REJECTED_THEMEWND(pwnd) && TESTFLAG(uDisp, HMD_REATTACH)) ||
                    (FAILED_THEMEWND(pwnd) && WM_THEMECHANGED == uMsg) ||
                    fPrematureExile )
                {
                    CThemeWnd::Detach(hwnd, FALSE); // remove rejection tag.
                    pwnd = NULL;
                }
                                
                //  Attach window object if applicable.
                if( pwnd == THEMEWND_NIL && !(fLifeIsShort || _fUnhooking) )
                {
                    pwnd = CThemeWnd::Attach(hwnd);  // NOTE: Handle -1 ThemeWnd
                }

                if( VALID_THEMEWND(pwnd) )
                {
                    //  protect our themewnd pointer
                    pwnd->AddRef();

                    // set up a theme message block
                    THEME_MSG tm;
                    _InitThemeMsg( &tm, MSGTYPE_PRE_WNDPROC, _fUnicode, hwnd, uMsg, wParam, lParam );

                    //  is this a message we want to handle?
                    HOOKEDMSGHANDLER pfnPre;
                    if( FindOwpHandler( uMsg, &pfnPre, NULL ) )
                    {
                        //  call the message handler
                        LRESULT lRetHandler = pfnPre( pwnd, &tm );

                        fHandled = tm.fHandled;
                        if( fHandled )
                        {
                            *plRes = lRetHandler;
                        }
                    }

                    //  decrement themewnd ref
                    pwnd->Release();
                }
            }

            if( fDetach )
            {
                CThemeWnd::Detach( hwnd, uDisp );
                pwnd = NULL;
            }
        }
    }

    LogExitMsg(L"ThemePreWndProc");
    return fHandled;
}

//---------------------------------------------------------------------------
//  Post-CallWndProc hook procedure
BOOL CALLBACK ThemePostWndProc( 
    HWND     hwnd, 
    UINT     uMsg, 
    WPARAM   wParam, 
    LPARAM   lParam, 
    LRESULT* plRes,
    VOID**   ppvParam )
{
    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    LogEntryMsg(L"ThemePostWndProc", hwnd, uMsg);

    BOOL fHandled = FALSE;
    if( IsTargetProcess(hwnd) && WM_NCCREATE != uMsg )
    {
        UINT uDisp  = _PreprocessHookedMsg( hwnd, uMsg, wParam, lParam, POST );
        BOOL fDetach  = TESTFLAG(uDisp, HMD_WINDOWDESTROY);
        BOOL fRevoked = FALSE;

        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
        if( _WindowHasTheme(hwnd) && VALID_THEMEWND(pwnd) )
        {
            //  protect our themewnd pointer
            pwnd->AddRef();
        
            //  is this a message we want to handle?
            HOOKEDMSGHANDLER pfnPost = NULL;
            if( FindOwpHandler( uMsg, NULL, &pfnPost ) )
            {
                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_POST_WNDPROC, _fUnicode, hwnd, uMsg, wParam, lParam, *plRes );

                        //  call the message handler
                LRESULT lRetHandler = pfnPost( pwnd, &tm );

                fHandled = tm.fHandled;
                
                if( fHandled )
                {
                    *plRes = lRetHandler;
                }
            }

            fRevoked = (pwnd->IsRevoked() && !pwnd->IsRevoked(RF_DEFER));

            //  decrement themewnd ref
            pwnd->Release();
        }
        else
        {
            //  special back-end processing for non-themed windows.
            fHandled = CThemeWnd::_PostWndProc( hwnd, uMsg, wParam, lParam, plRes );
        }

        if( fDetach )
        {
            CThemeWnd::Detach( hwnd, uDisp );
            pwnd = NULL; // don't touch
        }
        else if( fRevoked ) 
        {
            pwnd = CThemeWnd::FromHwnd(hwnd);
            if( VALID_THEMEWND(pwnd) )
            {
                pwnd->Revoke();
                pwnd = NULL; // don't touch
            }
        }
    }
    
    LogExitMsg(L"ThemePostWndProc");
    return fHandled;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemePreDefDlgProc( 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT* plRes, 
    VOID** ppvData)
{
    LogEntryMsg(L"ThemePreDefDlgProc", hwnd, uMsg);

    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    BOOL       fHandled = FALSE;
    CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

    if( IsTargetProcess(hwnd) && g_pAppInfo->AppIsThemed() )
    {
        if( VALID_THEMEWND(pwnd) )
        {
            //  protect our themewnd pointer
            pwnd->AddRef();
        
            //  is this a message we want to handle?
            HOOKEDMSGHANDLER pfnPre = NULL;
            if( FindDdpHandler( uMsg, &pfnPre, NULL ) )
            {
                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_PRE_DEFDLGPROC, _fUnicode, 
                               hwnd, uMsg, wParam, lParam, *plRes );

                //  call the message handler
                LRESULT lRetHandler = pfnPre( pwnd, &tm );
                
                fHandled = tm.fHandled;
                if( fHandled )
                {
                    *plRes = lRetHandler;
                }
            }

            //  decrement themewnd ref
            pwnd->Release();
        }
    }

    LogExitMsg(L"ThemePreDefDlgProc");
    return fHandled;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemePostDefDlgProc( 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT* plRes, 
    VOID** ppvData)
{
    LogEntryMsg(L"ThemePostDefDlgProc", hwnd, uMsg);

    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    BOOL       fHandled = FALSE;
    if( IsTargetProcess(hwnd) )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

        if( _WindowHasTheme(hwnd) && VALID_THEMEWND(pwnd) )
        {
            //  protect our themewnd pointer
            pwnd->AddRef();
        
            //  is this a message we want to handle?
            HOOKEDMSGHANDLER pfnPost = NULL;
            if( FindDdpHandler( uMsg, NULL, &pfnPost ) )
            {
                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_POST_DEFDLGPROC, _fUnicode, 
                               hwnd, uMsg, wParam, lParam, *plRes );

                //  call the message handler
                LRESULT lRetHandler = pfnPost( pwnd, &tm );
                
                fHandled = tm.fHandled;
                if( fHandled )
                {
                    *plRes = lRetHandler;
                }
            }

            //  decrement themewnd ref
            pwnd->Release();
        }
        else
        {
            //  special back-end processing for non-themed windows.
            fHandled = CThemeWnd::_PostDlgProc( hwnd, uMsg, wParam, lParam, plRes );
        }
    }

    LogExitMsg(L"ThemePostDefDlgProc");
    return fHandled;
}

//---------------------------------------------------------------------------
BOOL _ShouldInitApiHook( DWORD dwCmd, void* pvData )
{
    if( -1 == _fShouldEnableApiHooks )
    {
        _fShouldEnableApiHooks = TRUE;

        if( IsDebuggerPresent() )
        {
            BOOL fHookDebuggees = TRUE;
            HRESULT hr = GetCurrentUserThemeInt( L"ThemeDebuggees", TRUE, &fHookDebuggees );

            if( SUCCEEDED(hr) && !fHookDebuggees )
            {
                _fShouldEnableApiHooks = FALSE;
            }
        }
    }
    return _fShouldEnableApiHooks;
}

//---------------------------------------------------------------------------
//  ThemeInitApiHook() - USER API subclassing initialization callback.
//  This is called by USER asynchronously after we call RegisterDefWindowProc().
BOOL CALLBACK ThemeInitApiHook( DWORD dwCmd, void * pvData )
{
    //Log(LOG_TMCHANGE, L"ThemeInitApiHook called with dwCmd=%d, ApiCallCount=%d", dwCmd, _cInitUAH);

    BOOL fRetVal = FALSE;

    //---- if wierd loading order has called us before DllMain(), deny hooking ----
    if (! g_fUxthemeInitialized)
    {
        g_fEarlyHookRequest = TRUE;      // remember that we denied at least one hook request
    }
    else if( _ShouldInitApiHook( dwCmd, pvData ) )
    {
        switch (dwCmd)
        {
            case UIAH_INITIALIZE:
            {
                if( !UNHOOKING() )
                {
                    int cInit = InterlockedIncrement(&_cInitUAH);
                    if (cInit != 1)     // another thread is taking (has taken) care of this
                    {
                        //Log(LOG_TMCHANGE, L"ThemeInitApiHook already called - will just exit");
                        InterlockedDecrement(&_cInitUAH);
                    }
                    else
                    {
                        PUSERAPIHOOK puah = (PUSERAPIHOOK)pvData;
                        //  stash 'real' defwindowproc functions
                        _hookinf.uahReal = *puah;

                        puah->pfnGetScrollInfo         = ThemeGetScrollInfoProc;
                        puah->pfnSetScrollInfo         = ThemeSetScrollInfoProc;
                        puah->pfnEnableScrollBar       = ThemeEnableScrollInfoProc;
                        puah->pfnSetWindowRgn          = ThemeSetWindowRgn;

                        //  DefWindowProc override hooks
                        puah->pfnDefWindowProcW        = ThemeDefWindowProcW;
                        puah->pfnDefWindowProcA        = ThemeDefWindowProcA;
                        puah->mmDWP.cb                 = GetDwpMsgMask( &puah->mmDWP.rgb );

                        //  WndProc override hooks
                        puah->uoiWnd.pfnBeforeOWP      = ThemePreWndProc;
                        puah->uoiWnd.pfnAfterOWP       = ThemePostWndProc;
                        puah->uoiWnd.mm.cb             = GetOwpMsgMask( &puah->uoiWnd.mm.rgb ); // OWP message bitmask

                        //  DefDlgProc override hooks
                        puah->uoiDlg.pfnBeforeOWP      = ThemePreDefDlgProc;
                        puah->uoiDlg.pfnAfterOWP       = ThemePostDefDlgProc;
                        puah->uoiDlg.mm.cb             = GetDdpMsgMask( &puah->uoiDlg.mm.rgb ); // OWP message bitmask

                        //  System metrics hooks
                        puah->pfnGetSystemMetrics      = ThemeGetSystemMetrics;
                        puah->pfnSystemParametersInfoA = ThemeSystemParametersInfoA;
                        puah->pfnSystemParametersInfoW = ThemeSystemParametersInfoW;

                        //  Drawing hooks
                        puah->pfnDrawFrameControl      = ThemeDrawFrameControl;
                        puah->pfnDrawCaption           = ThemeDrawCaption;

                        //  MDI sysmenu hooks
                        puah->pfnMDIRedrawFrame        = ThemeMDIRedrawFrame;

                        BOOL fNcThemed = g_pAppInfo ? TESTFLAG( g_pAppInfo->GetAppFlags(), STAP_ALLOW_NONCLIENT ) : FALSE;

                        if( !fNcThemed || !LoadHookInstance() || !ApiHandlerInit( g_szProcessName, puah, &_hookinf.uahReal ) )
                        {
                            // restore 'Real' function table:
                            *puah = _hookinf.uahReal;
                        }
                        else
                        {
                            InterlockedExchange( (LONG*)&g_eThemeHookState, HS_INITIALIZED );
                            CThemeServices::ReestablishServerConnection();
                            OnHooksEnabled();
                        }

                        fRetVal = TRUE; // acknowledge out args

                    }
                }
                break;
            }

            case UIAH_UNINITIALIZE:
            case UIAH_UNHOOK:
                //  It is possible to be called on UIAH_INITIALIZED and UIAH_UNHOOK 
                //  simultaneously on two separate threads.
                
                //  Here we allow only one thread to transition from INITIALIZED to UNHOOKING state, and racing threads 
                //  will no-op. [scotthan]
                if( HS_INITIALIZED == InterlockedCompareExchange( (LONG*)&g_eThemeHookState, HS_UNHOOKING, HS_INITIALIZED ) )
                {
                    //---- now that we are completely done, decrement the count ----
                    //Log(LOG_TMCHANGE, L"ThemeInitApiHook is now decrementing the CallCount");
                    int cInit;
                    cInit = InterlockedDecrement(&_cInitUAH);
                    ASSERT(0 == cInit);

                    //---- detach themed windows, revert global state, etc
                    OnHooksDisabled(FALSE);

                    //  one thread transitions to UNITIALIZED state:
                    InterlockedExchange( (LONG*)&g_eThemeHookState, HS_UNINITIALIZED );
                    break;
                }

                fRetVal = TRUE;  // allow the hook/unhook 
                break;
        }

    }

    //Log(LOG_TMCHANGE, L"ThemeInitApiHook exiting with fRetVal=%d, ApiCallCount=%d", 
    //    fRetVal, _cInitUAH);

    return fRetVal;
}
//---------------------------------------------------------------------------
BOOL NewThemeCheck(int iChangeNum, BOOL fMsgCheck)
{
    //---- return TRUE if this is the first WM_THEMECHANGEDTRIGGER msg of ----
    //---- current theme change ----

    Log(LOG_TMCHANGE, L"NewThemeCheck, iChangeNum=%d, fMsgCheck=%d", 
        iChangeNum, fMsgCheck);

    BOOL fFirstMsg = FALSE;     

    //---- update thememgr info now (don't wait for first WM_THEMECHANGED msg) ----
    if (! g_pAppInfo->CustomAppTheme())
    {
        //---- get real changenum to minimize redundant theme changes ----
        if (iChangeNum == -1)
        {
            CThemeServices::GetCurrentChangeNumber(&iChangeNum);
        }
        
        //---- fThemeChanged is TRUE if this is the first time we have seen this ----
        //---- change number or we recently found a new theme handle ----

        BOOL fThemeChanged;
        g_pAppInfo->ResetAppTheme(iChangeNum, fMsgCheck, &fThemeChanged, &fFirstMsg);

        if (fThemeChanged)       
        {
            //---- see if theme services has died and been reborn ----
            if( S_FALSE == CThemeServices::ReestablishServerConnection() )
            {
                //---- services are back up - simulate a reset ----
                Log(LOG_ALWAYS, L"Recovering from Themes service restart");
            }

            //---- refresh theme metrics cache ----
            AcquireNcThemeMetrics();
        }
    }

    return fFirstMsg;
}
//---------------------------------------------------------------------------
void OnHooksEnabled()
{
    WindowDump(L"OnHooksEnabled");

    //---- hooking is turned on now ----
    Log(LOG_TMCHANGE, L"*** LOCAL Hooks installed ***");

    //---- load app's custom theme file, if one is registered ----

    //---- for now, comment this out since its not needed & causes problems if advapi32.dll not yet init-ed ----
    // g_pAppInfo->LoadCustomAppThemeIfFound();

    //---- we may have started this process with themes already on; in this case, we ----
    //---- don't get a WM_THEMECHANGED msg, so we better check for a theme now ----
    NewThemeCheck(-1, FALSE);
}
//---------------------------------------------------------------------------
void OnHooksDisabled(BOOL fShutDown)  
{
    DWORD dwStartTime = StartTimer();

    WindowDump(L"OnHooksDisabled");

    //---- reset the AppTheme info to OFF ----
    g_pAppInfo->ResetAppTheme(-1, FALSE, NULL, NULL);

    g_pAppInfo->SetPreviewThemeFile(NULL, NULL);

    //---- keep the static theme info in sync ----
    AcquireNcThemeMetrics();

    // NOTE: this function called from ThemeInitApiHook()( & ThemeHookShutdown()

    // We need to release all nctheme state objects from windows in this process
    // in two cases:
    // (1) normal process shutdown.
    // (2) Themes being turned off (this case).  Here, we're relying on notification
    //     from USER that hooks are coming off this process.
 
    if (fShutDown)
        CThemeWnd::DetachAll( HMD_PROCESSDETACH );
    else
        CThemeWnd::DetachAll( HMD_THEMEDETACH );

#ifdef DEBUG
    //---- all nonclient & client code should have closed their HTHEME's by now ----
    g_pAppInfo->DumpFileHolders();
    g_pRenderList->DumpFileHolders();
#endif

    //---- force this process to remove its refcount on the global theme ----
    //---- this is allowed because hTheme's are no longer directly connected ----
    //---- to a CRenderObj ----
    g_pRenderList->FreeRenderObjects(-1);

    //  free hook instance
    if( _hookinf.hInst )
    {
        FreeLibrary( _hookinf.hInst );
        _hookinf.hInst = NULL;
    }

    if (LogOptionOn(LO_TMLOAD))
    {
        DWORD dwTicks;
        dwTicks = StopTimer(dwStartTime);

        WCHAR buff[100];
        TimeToStr(dwTicks, buff);
        Log(LOG_TMLOAD, L"OnHooksDisabled took: %s", buff);
    }

    Log(LOG_TMCHANGE, L"*** LOCAL Hooks removed ***");
}
//---------------------------------------------------------------------------
//  _ThemeDefWindowProc()  - defwindowproc worker
LRESULT CALLBACK _ThemeDefWindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bUnicode )
{
    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything that causes
    //  a message to be sent to the window.

    LRESULT lRet = 0L;

    LogEntryMsg(L"_ThemeDefWindowProc", hwnd, uMsg);

    BOOL    fHandled = FALSE;
    WNDPROC pfnDefault = bUnicode ? _hookinf.uahReal.pfnDefWindowProcW : 
                                    _hookinf.uahReal.pfnDefWindowProcA;

    //  Pre-process WM_THEMECHANGE message
    if( IsTargetProcess(hwnd) )
    {
        UINT uDisp        = _PreprocessHookedMsg( hwnd, uMsg, wParam, lParam, DEF );
        BOOL fLifeIsShort = TESTFLAG(uDisp, HMD_THEMEDETACH|HMD_WINDOWDESTROY);
        BOOL fDetach      = TESTFLAG(uDisp, HMD_WINDOWDESTROY) && IsServerSideWindow(hwnd);

        //  Try handling message
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

        //  special back-end processing for non-themed windows.
        fHandled = CThemeWnd::_PreDefWindowProc( hwnd, uMsg, wParam, lParam, &lRet );

        if(fHandled == FALSE && 
           (_WindowHasTheme(hwnd) || fLifeIsShort))
        {
            //  On STYLECHANGED or WM_THEMECHANGE, 
            //  try reattaching window that was previously rejected or failed, resp.
            if( (REJECTED_THEMEWND(pwnd) && TESTFLAG(uDisp, HMD_REATTACH)) ||
                (FAILED_THEMEWND(pwnd) && WM_THEMECHANGED == uMsg)  )
            {
                CThemeWnd::Detach(hwnd, FALSE); // remove rejection tag.
                pwnd = NULL;
            }

            //  Attach window object if applicable.
            if( pwnd == NULL && !(fLifeIsShort || _fUnhooking) )
            {
                pwnd = CThemeWnd::Attach(hwnd);
            }

            if( VALID_THEMEWND(pwnd) )
            {
                //  protect our themewnd pointer:
                pwnd->AddRef();

                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_DEFWNDPROC, bUnicode, hwnd, uMsg, 
                               wParam, lParam, 0, pfnDefault );

                //  is this a message we want to handle?
                HOOKEDMSGHANDLER pfnHandler = NULL;
                if( FindDwpHandler( uMsg, &pfnHandler ))
                {
                    //  call the message handler
                    LRESULT lRetHandler = pfnHandler( pwnd, &tm );
                    
                    fHandled = tm.fHandled;
                    if( fHandled )
                    {
                        lRet = lRetHandler;
                    }
                }

                //  decrement themewnd ref
                pwnd->Release();
            }
        }

        if( fDetach )
        {
            CThemeWnd::Detach( hwnd, uDisp );
            pwnd = NULL; // don't touch
        }

    }

    if( !fHandled )
        lRet = pfnDefault( hwnd, uMsg, wParam, lParam );

    LogExitMsg(L"_ThemeDefWindowProc");
    return lRet;
}

//---------------------------------------------------------------------------
//  ThemeDefWindowProcA()  - Themed ansi defwindowproc
LRESULT CALLBACK ThemeDefWindowProcA( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _ThemeDefWindowProc( hwnd, uMsg, wParam, lParam, FALSE );
}

//---------------------------------------------------------------------------
//  ThemeDefWindowProcW()  - Themed widechar defwindowproc
LRESULT CALLBACK ThemeDefWindowProcW( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _ThemeDefWindowProc( hwnd, uMsg, wParam, lParam, TRUE );
}

//---------------------------------------------------------------------------
BOOL IsEqualScrollInfo( LPCSCROLLINFO psi1, LPCSCROLLINFO psi2 )
{
    if( psi1->fMask != psi2->fMask )
        return FALSE;

    if( psi1->fMask & SIF_RANGE )
    {
        if( (psi1->nMin != psi2->nMin) ||
            (psi1->nMax != psi2->nMax) )
        {
            return FALSE;
        }
    }

    if( psi1->fMask & SIF_POS )
    {
        if( psi1->nPos != psi2->nPos )
            return FALSE;
    }

    if( psi1->fMask & SIF_PAGE )
    {
        if( psi1->nPage != psi2->nPage )
            return FALSE;
    }

    if( psi1->fMask & SIF_TRACKPOS )
    {
        if( psi1->nTrackPos != psi2->nTrackPos )
            return FALSE;
    }

    return TRUE;

}

//---------------------------------------------------------------------------
int CALLBACK ThemeSetScrollInfoProc( 
    HWND hwnd, 
    int nBar, 
    IN LPCSCROLLINFO psi, 
    BOOL fRedraw )
{
    int  nRet = 0;

    if ( psi != NULL )
    {
        LogEntryMsg(L"ThemeSetScrollInfoProc", hwnd, nBar);

        BOOL fHandled = FALSE;
        
        if ( IsTargetProcess(hwnd) && _WindowHasTheme(hwnd) && (nBar != SB_CTL) )
        {
            DWORD dwStyle;
            BOOL  fStyleChanged;

            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

            //
            // Call the real SetScrollInfo first to give user
            // a chance to update their internal state. They can
            // potentially set WS_VSCROLL/WS_HSCROLL without notifying
            // anyone at all (eg. defview's listview)
            //
            // If they do, we'll need to redraw the entire
            // scroll bar.
            //
            dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            nRet = _hookinf.uahReal.pfnSetScrollInfo( hwnd, nBar, psi, FALSE );
            fStyleChanged = (((dwStyle ^ GetWindowLong(hwnd, GWL_STYLE)) & (WS_VSCROLL|WS_HSCROLL)) != 0) ? TRUE : FALSE;

            //  If we previously rejected the host window, it's possible that it
            //  didn't have the WS_H/VSCROLL bits.   Now it will, so we can re-attach.
            if ( REJECTED_THEMEWND(pwnd) )
            {
                CThemeWnd::Detach(hwnd, FALSE);
                pwnd = CThemeWnd::Attach(hwnd);
            }

            if ( VALID_THEMEWND(pwnd) )
            {

                // SetScrollInfo can potentially change WS_VSCROLL/WS_HSCROLL but
                // no style change message gets send. User does this by directly changing
                // the wnd struct. We do this by calling SetWindowLong which will generated
                // stylchanging and stylechanged. For compatability, we'll need to suppress
                // these messages.
                pwnd->SuppressStyleMsgs();
                fHandled = TRUE;

                #ifdef _ENABLE_SCROLL_SPEW_
                SpewScrollInfo( "ThemeSetScrollInfoProc to RealSetScrollInfo:", hwnd, psi );
                #endif // _ENABLE_SCROLL_SPEW_

                SCROLLINFO si;
                si.cbSize = sizeof(si);
                si.fMask  = psi->fMask | SIF_DISABLENOSCROLL;
                if ( _hookinf.uahReal.pfnGetScrollInfo( hwnd, nBar, &si ) )
                {
                    ThemeSetScrollInfo( hwnd, nBar, &si, fRedraw );
                }
                else
                {
                    ThemeSetScrollInfo( hwnd, nBar, psi, fRedraw );
                }

                if ( fRedraw && fStyleChanged )
                {
                    HDC hdc = GetWindowDC(hwnd);

                    if ( hdc )
                    {
                        DrawScrollBar(hwnd, hdc, NULL, (nBar != SB_HORZ));
                        ReleaseDC(hwnd, hdc);
                    }
                }

                pwnd->AllowStyleMsgs();
            }
        }

        if( !fHandled )
        {
            nRet = _hookinf.uahReal.pfnSetScrollInfo( hwnd, nBar, psi, fRedraw );
        }

        LogExitMsg(L"ThemeSetScrollInfoProc");
    }

    return nRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeGetScrollInfoProc( 
    HWND hwnd, 
    int nBar, 
    IN OUT LPSCROLLINFO psi )
{
    BOOL fRet = FALSE;

    if ( psi != NULL )    
    {
        LogEntryMsg(L"ThemeGetScrollInfoProc", hwnd, nBar);

        if( IsTargetProcess(hwnd) && _WindowHasTheme(hwnd) )
        {
            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
            if( VALID_THEMEWND(pwnd) )
            {
                fRet = ThemeGetScrollInfo( hwnd, nBar, psi );
            }
        }

        if( !fRet )
        {
            fRet = _hookinf.uahReal.pfnGetScrollInfo( hwnd, nBar, psi );
        }

        LogExitMsg(L"ThemeGetScrollInfoProc");
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeEnableScrollInfoProc( HWND hwnd, UINT nSBFlags, UINT nArrows )
{
    LogEntryMsg(L"ThemeEnableScrollInfoProc", 0, 0);

    BOOL fRet = _hookinf.uahReal.pfnEnableScrollBar( hwnd, nSBFlags, nArrows );

    if( fRet )
    {
        if( IsTargetProcess(hwnd) && _WindowHasTheme(hwnd))
        {
            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
            if( VALID_THEMEWND(pwnd) )
            {
                ThemeEnableScrollBar( hwnd, nSBFlags, nArrows );
            }
        }
    }

    LogExitMsg(L"ThemeEnableScrollInfoProc");

    return fRet;
}

//---------------------------------------------------------------------------
int CALLBACK ThemeGetSystemMetrics( int iMetric )
{
    LogEntryMsg(L"ThemeGetSystemMetrics", 0, 0);

    int iRet;

    if( IsTargetProcess() && g_pAppInfo->AppIsThemed() && !IN_CLASSICSYSMETCALL() )
    {
        BOOL fHandled = FALSE;
        iRet = _InternalGetSystemMetrics( iMetric, fHandled );
        if( fHandled )
            return iRet;
    }
    iRet = _hookinf.uahReal.pfnGetSystemMetrics(iMetric);

    LogExitMsg(L"ThemeGetSystemMetrics");
    return iRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(int) ClassicGetSystemMetrics( int iMetric )
{
    LogEntryMsg(L"ThemeGetSystemMetrics", 0, 0);

    if( HOOKSACTIVE() && _hookinf.uahReal.pfnGetSystemMetrics != NULL )
    {
        return _hookinf.uahReal.pfnGetSystemMetrics( iMetric );
    }

    ENTER_CLASSICSYSMETCALL();
    int nRet =  GetSystemMetrics( iMetric );
    LEAVE_CLASSICSYSMETCALL();

    LogExitMsg(L"ThemeGetSystemMetrics");
    return nRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeSystemParametersInfoA( 
    IN UINT uiAction, 
    IN UINT uiParam, 
    IN OUT PVOID pvParam, 
    IN UINT fWinIni)
{
    LogEntryMsg(L"ThemeSystemParametersInfoA", 0, 0);

    BOOL fRet = FALSE;

    if( IsTargetProcess() && g_pAppInfo->AppIsThemed() && !IN_CLASSICSYSMETCALL() )
    {
        BOOL fHandled = FALSE;

        fRet = _InternalSystemParametersInfo( uiAction, uiParam, pvParam, fWinIni, FALSE, fHandled );
        if( fHandled )
            return fRet;
    }
    
    fRet = _hookinf.uahReal.pfnSystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );

    LogExitMsg(L"ThemeSystemParametersInfoA");

    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni)
{
    LogEntryMsg(L"ThemeSystemParametersInfoA", 0, 0);

    BOOL fRet = FALSE;

    if( IsTargetProcess() && g_pAppInfo->AppIsThemed() && !IN_CLASSICSYSMETCALL() )
    {
        BOOL fHandled = FALSE;

        fRet = _InternalSystemParametersInfo( uiAction, uiParam, pvParam, fWinIni, TRUE, fHandled );
        if( fHandled )
            return fRet;
    }
    
    fRet = _hookinf.uahReal.pfnSystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );

    LogExitMsg(L"ThemeSystemParametersInfoA");

    return fRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(BOOL) ClassicSystemParametersInfoA( IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni)
{
    if( HOOKSACTIVE() && _hookinf.uahReal.pfnSystemParametersInfoA ) 
    {
        return _hookinf.uahReal.pfnSystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );
    }
        
    ENTER_CLASSICSYSMETCALL();
    BOOL fRet =  SystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );
    LEAVE_CLASSICSYSMETCALL();
    
    return fRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(BOOL) ClassicSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni)
{
    if( HOOKSACTIVE() && _hookinf.uahReal.pfnSystemParametersInfoW ) 
    {
        return _hookinf.uahReal.pfnSystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );
    }
        
    ENTER_CLASSICSYSMETCALL();
    BOOL fRet =  SystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );
    LEAVE_CLASSICSYSMETCALL();
    
    return fRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, BOOL fMenu, DWORD dwExStyle )
{
   //  If hooks are active, simply call user32!RealAdjustWindowRectEx.
    if( HOOKSACTIVE() && _hookinf.uahReal.pfnAdjustWindowRectEx )
    {
        return _hookinf.uahReal.pfnAdjustWindowRectEx( prcWnd, dwStyle, fMenu, dwExStyle );
    }

    ENTER_CLASSICSYSMETCALL();
    BOOL fRet = AdjustWindowRectEx( prcWnd, dwStyle, fMenu, dwExStyle );
    LEAVE_CLASSICSYSMETCALL();

    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeSetWindowRgn( HWND hwnd, HRGN hrgn, BOOL fRedraw)
{
    LogEntryMsg(L"ThemeSetWindowRgn", hwnd, 0);
    BOOL fHandled = FALSE;

    if( IsTargetProcess(hwnd) )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
        
        if( VALID_THEMEWND(pwnd) )
        {
            if( _WindowHasTheme(hwnd) )
            {
                if( hrgn != NULL && 
                    pwnd->IsFrameThemed() && !pwnd->AssigningFrameRgn() /* don't hook our own call */ )
                {
                    //  If we're executing here, the window is being assigned a
                    //  region externally or by the app.   We'll want to revoke theming
                    //  of this window from this point forward.
                    pwnd->AddRef();
            
                    //  Disown our theme window region without directly removing it;
                    //  we'll simply fall through and let the theme region get stomped.
                    if( pwnd->AssignedFrameRgn() )
                        pwnd->AssignFrameRgn( FALSE, FTF_NOMODIFYRGN );

                    //  Exile the window.
                    pwnd->Revoke();

                    pwnd->Release();
                }
            }
        }
        else if( NULL == hrgn && !IsWindowInDestroy(hwnd) )
        {
            if( TESTFLAG( CThemeWnd::EvaluateWindowStyle( hwnd ), TWCF_FRAME|TWCF_TOOLFRAME ) )
            {
                if( pwnd )
                    RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );
                    
                NCEVALUATE nce = {0};
                nce.fIgnoreWndRgn = TRUE;
                pwnd = CThemeWnd::Attach(hwnd, &nce);

                if( VALID_THEMEWND(pwnd) )
                {
                    ASSERT(pwnd->TestCF(TWCF_FRAME|TWCF_TOOLFRAME));
                    fHandled = TRUE;
                    pwnd->SetFrameTheme( FTF_REDRAW, NULL );
                }
            }
        }
    }
    

    BOOL fRet = TRUE;
    if( !fHandled )
    {
        ASSERT(_hookinf.uahReal.pfnSetWindowRgn);
        fRet = _hookinf.uahReal.pfnSetWindowRgn( hwnd, hrgn, fRedraw );
    }

    LogExitMsg(L"ThemeSetWindowRgn");
    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeDrawFrameControl( 
    IN HDC hdc, IN OUT LPRECT prc, IN UINT uType, IN UINT uState )
{
    LogEntryMsg(L"ThemeDrawFrameControl", NULL, 0);

    if( IsTargetProcess() )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHdc(hdc);
        if( NULL == pwnd)  // HDC is a memory DC
        {
            //  Find the window in this thread that is processing WM_NCPAINT
            HWND hwnd = NcPaintWindow_Find();
            if( hwnd )
            {
                pwnd = CThemeWnd::FromHwnd(hwnd);
            }
        }
        
        if( VALID_THEMEWND(pwnd) && _WindowHasTheme(*pwnd) )
        {
            if( pwnd->IsFrameThemed() && pwnd->InNcPaint() && !pwnd->InNcThemePaint() )
            {
                DWORD dwFlags = RF_NORMAL|RF_DEFER;
                if( pwnd->AssignedFrameRgn() )
                {
                    dwFlags |= RF_REGION;
                }
                
                pwnd->SetRevokeFlags(dwFlags);
            }
        }
    }

    ASSERT(_hookinf.uahReal.pfnDrawFrameControl);
    BOOL fRet = _hookinf.uahReal.pfnDrawFrameControl( hdc, prc, uType, uState );

    LogExitMsg(L"ThemeDrawFrameControl");
    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeDrawCaption( IN HWND hwnd, IN HDC hdc, IN CONST RECT *prc, IN UINT uType)
{
    LogEntryMsg(L"ThemeDrawFrameControl", NULL, 0);

    if( IsTargetProcess() )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
        
        if( VALID_THEMEWND(pwnd) && _WindowHasTheme(*pwnd) )
        {
            if( pwnd->IsFrameThemed() && pwnd->InNcPaint() && !pwnd->InNcThemePaint() )
            {
                DWORD dwFlags = RF_NORMAL|RF_DEFER;
                if( pwnd->AssignedFrameRgn() )
                {
                    dwFlags |= RF_REGION;
                }
                
                pwnd->SetRevokeFlags(dwFlags);
            }
        }
    }

    ASSERT(_hookinf.uahReal.pfnDrawCaption);
    BOOL fRet = _hookinf.uahReal.pfnDrawCaption( hwnd, hdc, prc, uType );

    LogExitMsg(L"ThemeDrawFrameControl");
    return fRet;
}

//---------------------------------------------------------------------------
VOID CALLBACK ThemeMDIRedrawFrame( IN HWND hwndChild, BOOL fAdd )
{
    LogEntryMsg(L"ThemeMDIRedrawFrame", NULL, 0);

    if( IsTargetProcess() )
    {
        HWND hwndClient = GetParent(hwndChild);
        HWND hwndFrame  = GetParent(hwndClient); 

        if( hwndFrame )
        {
            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwndFrame);

            if( VALID_THEMEWND(pwnd) )
            {
                pwnd->ModifyMDIMenubar( fAdd, FALSE );
            }
        }
    }
    
    ASSERT(_hookinf.uahReal.pfnMDIRedrawFrame);
    _hookinf.uahReal.pfnMDIRedrawFrame( hwndChild, fAdd );
    LogExitMsg(L"ThemeMDIRedrawFrame");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\services.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Services.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  APIs to communicate with the theme service running in the winlogon
//  process context.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "Services.h"

#include <uxthemep.h>
#include <LPCThemes.h>

#include "errors.h"
#include "info.h"
#include "MessageBroadcast.h"
#include "stringtable.h"
#include "themefile.h"
#include "ThemeSection.h"
#include "ThemeServer.h"
#include "tmreg.h"
#include "tmutils.h"
#include <regstr.h>     // REGSTR_PATH_POLICIES

// Will statically link to this later (needs gdi32p.lib)
static HBRUSH (*s_pfnClearBrushAttributes)(HBRUSH, DWORD) = NULL;

#ifdef DEBUG
     // TODO: Isn't symchronized anymore (different processes), need to use a volatile reg key instead
    extern DWORD g_dwStockSize;
#endif

#define TBOOL(x)            ((BOOL)(x))
#define TW32(x)             ((DWORD)(x))
#define THR(x)              ((HRESULT)(x))
#define TSTATUS(x)          ((NTSTATUS)(x))
#undef  ASSERTMSG
#define ASSERTMSG(x, y)
#define goto                !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CThemeServices::s_hAPIPort
//
//  Purpose:    Static member variables for CThemeServices.
//
//              NOTE: The critical section provides a lock for s_hAPIPort.
//              It's not acquired consistently because most of the API calls
//              would block trying to acquire the lock while another API call
//              is holding the lock across a request. The handle could be
//              copied to a local variable but this would defeat the purpose
//              of the lock. So the lock isn't used. It's possible for the
//              handle to become invalid. If so the request will just fail.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CRITICAL_SECTION    CThemeServices::s_lock;
HANDLE              CThemeServices::s_hAPIPort      =   INVALID_HANDLE_VALUE;

//  --------------------------------------------------------------------------
//  CThemeServices::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initialize static member variables.
//
//  History:    2000-10-11  vtan        created
//              2000-11-09  vtan        make static
//  --------------------------------------------------------------------------

void    CThemeServices::StaticInitialize (void)

{
    (NTSTATUS)RtlInitializeCriticalSection(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::~CThemeServices
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release static resources used by CThemeServices.
//
//  History:    2000-10-11  vtan        created
//              2000-11-09  vtan        make static
//  --------------------------------------------------------------------------

void    CThemeServices::StaticTerminate (void)

{
    ReleaseConnection();
    (NTSTATUS)RtlDeleteCriticalSection(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeHooksOn
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Ask the server what the hook DLL HMODULE and
//              pfnInitUserApiHook is and call user32!RegisterUserApiHook on
//              the client side. This is done because it's specific to the
//              session on which the client runs.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ThemeHooksOn (HWND hwndTarget)

{
    HRESULT hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);

    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_THEMEHOOKSON;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiThemeHooksOn.out.hr;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }

        //---- send the WM_UAHINIT msg to engage hooking now ----
        if (SUCCEEDED(hr))
        {
            if (hwndTarget)
            {
                (LRESULT)SendMessage(hwndTarget, WM_UAHINIT, 0, 0);
            }
            else
            {
                CMessageBroadcast   messageBroadcast;
                messageBroadcast.PostAllThreadsMsg(WM_UAHINIT, 0, 0);

                //Log(LOG_TMCHANGEMSG, L"Just sent WM_UAHINIT, hwndTarget=0x%x", hwndTarget);
            }
        }

        Log(LOG_TMCHANGE, L"ThemeHooksOn called, hr=0x%x", hr);
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeHooksOff
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Tell the server that this session is unregistering hooks.
//              Call user32!UnregisterUserApiHook either way.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ThemeHooksOff (void)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_THEMEHOOKSOFF;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiThemeHooksOff.out.hr;
            }

            if (SUCCEEDED(hr))
            {
                //---- real unhooking happens on next window message in each process ----
                //---- so post a dummy msg to everyone to make it happen asap ----
                PostMessage(HWND_BROADCAST, WM_THEMECHANGED, WPARAM(-1), 0);

                Log(LOG_TMLOAD, L"Message to kick all window threads in session posted");
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetStatusFlags
//
//  Arguments:  pdwFlags    =   Status flags returned from the theme services.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets status flags from the theme services.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::GetStatusFlags (DWORD *pdwFlags)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETSTATUSFLAGS;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                *pdwFlags = portMessageOut.apiThemes.apiSpecific.apiGetStatusFlags.out.dwFlags;
                hr = S_OK;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetCurrentChangeNumber
//
//  Arguments:  piValue     =   Current change number returned to caller.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets the current change number of the theme services.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::GetCurrentChangeNumber (int *piValue)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETCURRENTCHANGENUMBER;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                *piValue = portMessageOut.apiThemes.apiSpecific.apiGetCurrentChangeNumber.out.iChangeNumber;
                hr = S_OK;
            }

            Log(LOG_TMLOAD, L"*** GetCurrentChangeNumber: num=%d, hr=0x%x", *piValue, hr);
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetNewChangeNumber
//
//  Arguments:  piValue     =   New change number returned to caller.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets a new change number from the theme services.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::GetNewChangeNumber (int *piValue)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETNEWCHANGENUMBER;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                *piValue = portMessageOut.apiThemes.apiSpecific.apiGetNewChangeNumber.out.iChangeNumber;
                hr = S_OK;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::SetGlobalTheme
//
//  Arguments:  hSection    =   Section to set as the global theme.
//
//  Returns:    HRESULT
//
//  Purpose:    Sets the current global theme section handle.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::SetGlobalTheme (HANDLE hSection)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_SETGLOBALTHEME;
        portMessageIn.apiThemes.apiSpecific.apiSetGlobalTheme.in.hSection = hSection;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiSetGlobalTheme.out.hr;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetGlobalTheme
//
//  Arguments:  phSection   =   Section object returned from theme services.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets the current global theme section handle.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------
HRESULT     CThemeServices::GetGlobalTheme (HANDLE *phSection)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETGLOBALTHEME;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiGetGlobalTheme.out.hr;
                if (SUCCEEDED(hr))
                {
                    *phSection = portMessageOut.apiThemes.apiSpecific.apiGetGlobalTheme.out.hSection;
                }
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::CheckThemeSignature
//
//  Arguments:  pszThemeName    =   File path of theme to check.
//
//  Returns:    HRESULT
//
//  Purpose:    Checks the given theme's signature.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::CheckThemeSignature (const WCHAR *pszThemeName)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_CHECKTHEMESIGNATURE;
        portMessageIn.apiThemes.apiSpecific.apiCheckThemeSignature.in.pszName = pszThemeName;
        portMessageIn.apiThemes.apiSpecific.apiCheckThemeSignature.in.cchName = lstrlen(pszThemeName) + sizeof('\0');
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiCheckThemeSignature.out.hr;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LoadTheme
//
//  Arguments:  phSection       =   Section object to theme returned.
//              pszThemeName    =   Theme file to load.
//              pszColorParam   =   Color.
//              pszSizeParam    =   Size.
//              fGlobal         =   FALSE for a preview.
//
//  Returns:    HRESULT
//
//  Purpose:    Loads the given theme and creates a section object for it.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::LoadTheme (HANDLE *phSection, 
    const WCHAR *pszThemeName, const WCHAR *pszColor, const WCHAR *pszSize, BOOL fGlobal)

{
    HRESULT     hr;

    *phSection = NULL; // Result if failure

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        HANDLE          hSection;
        CThemeLoader    *pLoader;
        WCHAR           szColor[MAX_PATH];
        WCHAR           szSize[MAX_PATH];

        //  Because the loader makes GDI calls that directly affect the
        //  client instance of win32k the theme must be loaded on the
        //  client side. Once the theme is loaded it is handed to the
        //  server (which creates a new section) and copies the data to
        //  it. The server then controls the theme data and the client
        //  discards the temporary theme.

        hSection = NULL;
        pLoader = new CThemeLoader;
        if (pLoader != NULL)
        {
            HINSTANCE hInst = NULL;
            
            // Keep the DLL loaded to avoid loading it 3 times below
            hr = LoadThemeLibrary(pszThemeName, &hInst);

            if (SUCCEEDED(hr) && (pszColor == NULL || *pszColor == L'\0'))
            {
                hr = GetThemeDefaults(pszThemeName, szColor, ARRAYSIZE(szColor), NULL, 0);
                pszColor = szColor;
            }

            if (SUCCEEDED(hr) && (pszSize == NULL || *pszSize == L'\0'))
            {
                hr = GetThemeDefaults(pszThemeName, NULL, 0, szSize, ARRAYSIZE(szSize));
                pszSize = szSize;
            }

            if (SUCCEEDED(hr))
            {
                hr = pLoader->LoadTheme(pszThemeName, pszColor, pszSize, &hSection, fGlobal);
            }
            
            delete pLoader;
            
            if (hInst)
            {
                FreeLibrary(hInst);
            }
        }
        else
        {
            hr = MakeError32(E_OUTOFMEMORY);
        }
        if (SUCCEEDED(hr) && (hSection != NULL))
        {
            NTSTATUS                status;
            THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

            ZeroMemory(&portMessageIn, sizeof(portMessageIn));
            ZeroMemory(&portMessageOut, sizeof(portMessageOut));
            portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_LOADTHEME;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.pszName = pszThemeName;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.cchName = lstrlen(pszThemeName) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.pszColor = pszColor;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.cchColor = lstrlen(pszColor) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.pszSize = pszSize;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.cchSize = lstrlen(pszSize) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.hSection = hSection;
            portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
            portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
            status = NtRequestWaitReplyPort(s_hAPIPort,
                                            &portMessageIn.portMessage,
                                            &portMessageOut.portMessage);
            CheckForDisconnectedPort(status);
            if (NT_SUCCESS(status))
            {
                status = portMessageOut.apiThemes.apiGeneric.status;
                if (NT_SUCCESS(status))
                {
                    hr = portMessageOut.apiThemes.apiSpecific.apiLoadTheme.out.hr;
                    if (SUCCEEDED(hr))
                    {
                        *phSection = portMessageOut.apiThemes.apiSpecific.apiLoadTheme.out.hSection;
                    }
                    else
                    {
                    }
                }
            }
            if (!NT_SUCCESS(status))
            {
                hr = HRESULT_FROM_NT(status);
            }
        }

        // Clear our temporary section
        if (hSection != NULL)
        {
            // If we didn't transfer the stock objects handles to a new section, clear them always
            if (*phSection == NULL)
            {
                THR(ClearStockObjects(hSection));
            }
            TBOOL(CloseHandle(hSection));
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
HRESULT CThemeServices::CheckColorDepth(CUxThemeFile *pThemeFile)
{
    HRESULT hr = S_OK;
    THEMEMETRICS *pMetrics = GetThemeMetricsPtr(pThemeFile);
    DWORD dwDepthRequired = pMetrics->iInts[TMT_MINCOLORDEPTH - TMT_FIRSTINT];

    if (MinimumDisplayColorDepth() < dwDepthRequired)
    {
        hr = MakeError32(ERROR_BAD_ENVIRONMENT);
    }

    return hr;
}

//  --------------------------------------------------------------------------
HRESULT CThemeServices::UpdateThemeRegistry(BOOL fThemeActive,
     LPCWSTR pszThemeFileName, LPCWSTR pszColorParam, LPCWSTR pszSizeParam, BOOL fJustSetActive,
     BOOL fJustApplied)
{
    if (fThemeActive)
    {
        if (fJustSetActive)    
        {
            //---- see if a theme was previously active ----
            WCHAR szThemeName[MAX_PATH];

            THR(GetCurrentUserThemeString(THEMEPROP_DLLNAME, L"", szThemeName, ARRAYSIZE(szThemeName)));
            if (szThemeName[0] != L'\0')
            {
                THR(SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 1));
            }
        }
        else
        {
            WCHAR szFullName[MAX_PATH];

            if (GetFullPathName(pszThemeFileName, ARRAYSIZE(szFullName), szFullName, NULL) == 0)
            {
                lstrcpy_truncate(szFullName, pszThemeFileName, ARRAYSIZE(szFullName));
            }

            THR(SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 1));

            if (fJustApplied)
            {
                THR(SetCurrentUserThemeInt(THEMEPROP_LOADEDBEFORE, 1));
                THR(SetCurrentUserThemeInt(THEMEPROP_LANGID, (int) GetUserDefaultUILanguage()));

                //  Theme identification

                THR(SetCurrentUserThemeStringExpand(THEMEPROP_DLLNAME, szFullName));
                THR(SetCurrentUserThemeString(THEMEPROP_COLORNAME, pszColorParam));
                THR(SetCurrentUserThemeString(THEMEPROP_SIZENAME, pszSizeParam));
            }
            else        // for forcing theme to be loaded from InitUserTheme()
            {
                WCHAR szThemeName[MAX_PATH];

                THR(GetCurrentUserThemeString(THEMEPROP_DLLNAME, L"", szThemeName, ARRAYSIZE(szThemeName)));

                if (lstrcmpiW(szThemeName, szFullName) != 0)
                {
                    THR(SetCurrentUserThemeString(THEMEPROP_DLLNAME, szFullName));

                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_LOADEDBEFORE));
                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_LANGID));
                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_COLORNAME));
                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_SIZENAME));
                } else
                {
                    return S_FALSE; // S_FALSE means we did nothing really
                }
            }
        }
    }
    else
    {
        THR(SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 0));

        if (! fJustSetActive)     // wipe out all theme info
        {
            THR(DeleteCurrentUserThemeValue(THEMEPROP_DLLNAME));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_COLORNAME));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_SIZENAME));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_LOADEDBEFORE));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_LANGID));
        }
    }

    return S_OK;
}

//  --------------------------------------------------------------------------
void CThemeServices::SendThemeChangedMsg(BOOL fNewTheme, HWND hwndTarget, DWORD dwFlags,
    int iLoadId)
{
    WPARAM wParam;
    LPARAM lParamBits, lParamMixed;

    BOOL fExcluding = ((dwFlags & AT_EXCLUDE) != 0);
    BOOL fCustom = ((dwFlags & AT_PROCESS) != 0);

    //---- change number was set in ApplyTheme() for both global and preview cases ----
    int iChangeNum;
    GetCurrentChangeNumber(&iChangeNum);

    wParam = iChangeNum;

    lParamBits = 0;
    if (fNewTheme)
    {
        lParamBits |= WTC_THEMEACTIVE;
    }

    if (fCustom)
    {
        lParamBits |= WTC_CUSTOMTHEME;
    }

    if ((hwndTarget) && (! fExcluding))
    {
        SendMessage(hwndTarget, WM_THEMECHANGED, wParam, lParamBits);
    }
    else
    {
        lParamMixed = (iLoadId << 4) | (lParamBits & 0xf);

        CMessageBroadcast messageBroadcast;

        //  POST the WM_THEMECHANGED_TRIGGER msg to all targeted windows
//        messageBroadcast.PostFilteredMsg(WM_THEMECHANGED_TRIGGER, wParam, lParamMixed,
  //          hwndTarget, fCustom, fExcluding);

        messageBroadcast.PostAllThreadsMsg(WM_THEMECHANGED_TRIGGER, wParam, lParamMixed);

        Log(LOG_TMCHANGEMSG, L"Just Broadcasted WM_THEMECHANGED_TRIGGER: iLoadId=%d", iLoadId);
    }
}
//  --------------------------------------------------------------------------
int CThemeServices::GetLoadId(HANDLE hSectionOld)
{
    int iLoadId = 0;

    //---- extract LoadId from old section ----
    if (hSectionOld)
    {
        CThemeSection   pThemeSectionFile;

        if (SUCCEEDED(pThemeSectionFile.Open(hSectionOld)))
        {
            CUxThemeFile *pThemeFile = pThemeSectionFile;
            if (pThemeFile)
            {
                THEMEHDR *hdr = (THEMEHDR *)(pThemeFile->_pbThemeData);
                if (hdr)
                {
                    iLoadId = hdr->iLoadId;
                }
            }
        }
    }

    return iLoadId;
}

//  --------------------------------------------------------------------------
//  CThemeServices::ApplyTheme
//
//  Arguments:  pThemeFile  =   Object wrapping the theme section to apply.
//              dwFlags     =   Flags.
//              hwndTarget  =   HWND.
//
//  Returns:    HRESULT
//
//  Purpose:    Applies the given theme. Do some metric and color depth
//              validation, clear the stock bitmaps of the old theme, set
//              the given theme as the current theme and broadcast this fact.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------
//  In the design notes below, note that SEND and POST differences are 
//  significant.  
//
//  Also, when the "WM_THEMECHANGED_TRIGGER" msg is sent,
//  the uxtheme hooking code in each process will:
//
//      1. enumerate all windows for process (using desktop enumeration and 
//         the per-process "foreign window list") to:
//
//            a. process WM_THEMECHANGED for nonclient area
//            b. SEND a WM_THEMECHANGED msg to regular window
//
//      2. call FreeRenderObjects() for old theme, if any
//  --------------------------------------------------------------------------
//  To ensure correct window notification of theme changes and correct removal 
//  of old theme file RefCounts, the following CRITICAL STEPS must be taken 
//  in the 4 basic theme transition sequences:
//
//      turning ON preview theme:
//          a. turn ON global UAE hooks 
//          b. SEND WM_UAHINIT msg to hwndTarget
//          c. SEND WM_THEMECHANGED to hwndTarget
//
//      turning ON global theme:
//          a. turn ON global UAE hooks 
//          b. POST WM_UAHINIT msg to all accessible windows
//          c. POST WM_THEMECHANGED_TRIGGER to all accessible window threads
//
//      turning OFF preview theme:
//          c. SEND WM_THEMECHANGED to hwndTarget
//
//      turning OFF global theme:
//          a. turn OFF global UAE hooks 
//          b. step "a" will cause WM_THEMECHANGED_TRIGGER-type processing 
//             to occur from OnHooksDisabled() in each process
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ApplyTheme (CUxThemeFile *pThemeFile, DWORD dwFlags, HWND hwndTarget)
{
    HRESULT         hr;
    bool            fNewTheme, fGlobal;
    int             iLoadId;
    WCHAR           szThemeFileName[MAX_PATH];
    WCHAR           szColorParam[MAX_PATH];
    WCHAR           szSizeParam[MAX_PATH];
    HANDLE          hSection = NULL;

    if (pThemeFile != NULL)
    {
        hSection = pThemeFile->Handle();
    }
    fGlobal = (((dwFlags & AT_EXCLUDE) != 0) ||
               ((hwndTarget == NULL) && ((dwFlags & AT_PROCESS) == 0)));
    fNewTheme = (hSection != NULL);
    iLoadId = 0;

    Log(LOG_TMHANDLE, L"ApplyTheme: hSection=0x%x, dwFlags=0x%x, hwndTarget=0x%x",
        hSection, dwFlags, hwndTarget);

    if (fNewTheme)
    {
        if (pThemeFile->HasStockObjects() && !fGlobal) // Don't do this
        {
            hr = E_INVALIDARG;
        }
        else
        {
            //---- get some basic info used thruout this function ----
            hr = GetThemeNameId(pThemeFile, 
                szThemeFileName, ARRAYSIZE(szThemeFileName),
                szColorParam, ARRAYSIZE(szColorParam),
                szSizeParam, ARRAYSIZE(szSizeParam),
                NULL, NULL);
            if (SUCCEEDED(hr))
            {
                //---- ensure color depth of monitor(s) are enough for theme ----
                if (GetSystemMetrics(SM_REMOTESESSION))     // only check for terminal server sessions
                {
                    hr = CheckColorDepth(pThemeFile);
                }

                if (SUCCEEDED(hr))
                {
                    //---- ensure hooks are on ----
                    hr = ThemeHooksOn(hwndTarget);
                }
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr) && fGlobal)
    {
        HANDLE  hSectionOld;

        //---- get a handle to the old global theme (for stock cleanup) ----
        hr = GetGlobalTheme(&hSectionOld);
        if (SUCCEEDED(hr))
        {
            //---- extract Load ID before theme becomes invalid (dwFlags & SECTION_READY=0) ----
            if (hSectionOld != NULL)
            {
                iLoadId = GetLoadId(hSectionOld);
            }

            //---- tell server to switch global themes ----
            hr = SetGlobalTheme(hSection);
            if (SUCCEEDED(hr))
            {
                //---- update needed registry settings ----
                if ((dwFlags & AT_NOREGUPDATE) == 0)       // if caller allows update
                {
                    hr = UpdateThemeRegistry(fNewTheme, szThemeFileName, szColorParam, szSizeParam, 
                        FALSE, TRUE);
                    if (FAILED(hr))
                    {
                        Log(LOG_ALWAYS, L"UpdateThemeRegistry call failed, hr=0x%x", hr);
                        hr = S_OK;      // not a fatal error
                    }
                }

                //---- set system metrics, if requested ----
                if ((dwFlags & AT_LOAD_SYSMETRICS) != 0)
                {
                    BOOL fSync = ((dwFlags & AT_SYNC_LOADMETRICS) != 0);

                    if (fNewTheme)
                    {
                        SetSystemMetrics(GetThemeMetricsPtr(pThemeFile), fSync);
                    }
                    else        // just load classic metrics 
                    {
                        LOADTHEMEMETRICS tm;

                        hr = InitThemeMetrics(&tm);
                        if (SUCCEEDED(hr))
                        {
                            SetSystemMetrics(&tm, fSync);
                        }
                    }
                }
            }
            if (hSectionOld != NULL)
            {
                TBOOL(CloseHandle(hSectionOld));
            }
        }
    }

    //---- if we turned off global theme, turn hooks off now ----
    if (SUCCEEDED(hr))
    {
        if (!fNewTheme && fGlobal)
        {
            hr = ThemeHooksOff(); 
        }
        else 
        {
            //---- send the correct WM_THEMECHANGED_XXX msg to window(s) ----
            SendThemeChangedMsg(fNewTheme, hwndTarget, dwFlags, iLoadId);
        }
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::AdjustTheme
//
//  Arguments:  BOOL fEnable - if TRUE, enable CU theme; if FALSE, disable it
//
//  Returns:    HRESULT
//              
//  Purpose:    for 3rd party skinning apps to cooperate better with theme mgr
//
//  History:    2001-03-12  rfernand        created
//  --------------------------------------------------------------------------
HRESULT CThemeServices::AdjustTheme(BOOL fEnable)
{
    HRESULT hr = UpdateThemeRegistry(fEnable, NULL, NULL, NULL, TRUE, FALSE);

    if (SUCCEEDED(hr))
    {
        hr = InitUserTheme(FALSE);
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeServices::ApplyDefaultMetrics
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Make sure the user metrics gets reset to Windows Standard
//
//  History:    2001-03-30  lmouton     created
//  --------------------------------------------------------------------------
void CThemeServices::ApplyDefaultMetrics(void)
{            
    HKEY            hKeyThemes;
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    Log(LOG_TMLOAD, L"Applying default metrics");

    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyCurrentUser,
                                       THEMES_REGKEY L"\\" SZ_DEFAULTVS_OFF,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKeyThemes)))
    {
        WCHAR szVisualStyle[MAX_PATH] = {L'\0'};
        WCHAR szColor[MAX_PATH] = {L'\0'};
        WCHAR szSize[MAX_PATH] = {L'\0'};
        BOOL  fGotOne;
        
        // Note: These will fail for the first user logon, themeui sets these keys and needs to call InstallVS itself

        fGotOne = SUCCEEDED(RegistryStrRead(hKeyThemes, SZ_INSTALLVISUALSTYLE, szVisualStyle, ARRAYSIZE(szVisualStyle)));
        fGotOne = SUCCEEDED(RegistryStrRead(hKeyThemes, SZ_INSTALLVISUALSTYLECOLOR, szColor, ARRAYSIZE(szColor))) 
            || fGotOne;
        fGotOne = SUCCEEDED(RegistryStrRead(hKeyThemes, SZ_INSTALLVISUALSTYLESIZE, szSize, ARRAYSIZE(szSize))) 
            || fGotOne;

        if (fGotOne)
        {
            // At least one key is present in the registry, it may be enough
            WCHAR szSysDir[MAX_PATH];

            if (0 < GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
            {
                WCHAR *pszCmdLine = (LPWSTR) LocalAlloc(LPTR, MAX_PATH * 5);

                if (pszCmdLine)
                {
                    wsprintf(pszCmdLine, L"%s\\regsvr32.exe /s /n /i:\"" SZ_INSTALL_VS L"%s','%s','%s'\" %s\\themeui.dll", szSysDir, szVisualStyle, szColor, szSize, szSysDir);
    
                    // Set a reg key to have themeui install the proper settings instead of defaults
                    // We can't do this now because the user could not be completely logged on

                    HKEY hKeyRun;

                    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyCurrentUser, REGSTR_PATH_RUNONCE, 0, KEY_SET_VALUE, &hKeyRun)))
                    {
                        THR(RegistryStrWrite(hKeyRun, szColor, pszCmdLine));
                        TW32(RegCloseKey(hKeyRun));
                    }
                    LocalFree(pszCmdLine);
                }
            }
        }
        TW32(RegCloseKey(hKeyThemes));
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::InitUserTheme
//
//  Arguments:  BOOL fPolicyCheckOnly 
//                 TRUE means 
//                 "only do something if the policy is different from the current loaded theme"
//
//  Returns:    HRESULT
//              
//  Purpose:    Special entry point for winlogon/msgina to control themes
//              for user logon/logoff.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::InitUserTheme (BOOL fPolicyCheckOnly)
{
    BOOL fActive = FALSE;
    BOOL fOldActive = FALSE;
    BOOL fPolicyActive = FALSE;

    //---- should theme be active for this user? ----
    if (! IsRemoteThemeDisabled())
    {
        THR(GetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, FALSE, &fActive));
    
        fOldActive = fActive;

        fPolicyActive = ThemeEnforcedByPolicy(fActive != FALSE);
        if (fPolicyActive)
        {
            // Refresh fActive because the policy changed it
            THR(GetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, FALSE, &fActive));
        }

        if ((fActive) && (ThemeSettingsModified()))
        {
            fActive = FALSE;
        }
    }

#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        WCHAR szUserName[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szUserName);
    
        GetUserName(szUserName, &dwSize);

        Log(LOG_TMLOAD, L"InitUserTheme: User=%s, ThemeActive=%d, SM_REMOTESESSION=%d, fPolicyActive=%d, fPolicyCheckOnly=%d", 
            szUserName, fActive, GetSystemMetrics(SM_REMOTESESSION), fPolicyActive, fPolicyCheckOnly);
    }
#endif

    BOOL fEarlyExit = FALSE;

    if (fPolicyCheckOnly)
    {
        // Bail out early if nothing has changed since last time, which is most of the time
        if (!fPolicyActive)
        {
            Log(LOG_TMLOAD, L"InitUserTheme: Nothing to do after Policy check");
            fEarlyExit = TRUE;
        } else
        {
            Log(LOG_TMLOAD, L"InitUserTheme: Reloading after Policy check");
        }
    }

    if (!fEarlyExit)
    {
        if (fActive)
        {
            //---- load this user's theme ----
            HRESULT hr = LoadCurrentTheme();

            if (FAILED(hr))
            {
                fActive = FALSE;
            }
        }

        if (! fActive)          // turn off themes
        {
            // if fPolicyActive, force refresh system metrics from temporary defaults
            THR(ApplyTheme(NULL, AT_NOREGUPDATE | (fPolicyActive ? AT_LOAD_SYSMETRICS | AT_SYNC_LOADMETRICS: 0), false));

            // Apply the proper default metrics
            if (fPolicyActive)
            {
                ApplyDefaultMetrics();
            }
        }
    }

    return S_OK;        // never fail this guy
}

//  --------------------------------------------------------------------------
//  CThemeServices::InitUserRegistry
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//              
//  Purpose:    Propogate settings from HKLM to HKCU. This should only be
//              invoked for ".Default" hives. Assert to ensure this.
//
//  History:    2000-11-11  vtan        created (ported from themeldr.cpp)
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::InitUserRegistry (void)

{
    HRESULT         hr;
    DWORD           dwErrorCode;
    HKEY            hklm;
    CCurrentUser    hkeyCurrentUser(KEY_READ | KEY_WRITE);

#ifdef      DEBUG
    ASSERT(CThemeServer::IsSystemProcessContext());
#endif  /*  DEBUG   */

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      THEMEMGR_REGKEY,
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hklm))
    {
        HKEY    hkcu;

        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCurrentUser,
                                            THEMEMGR_REGKEY,
                                            0,
                                            NULL,
                                            0,
                                            KEY_QUERY_VALUE | KEY_SET_VALUE,
                                            NULL,
                                            &hkcu,
                                            NULL))
        {
            int     iLMVersion;

            hr = RegistryIntRead(hklm, THEMEPROP_LMVERSION, &iLMVersion);
            if (SUCCEEDED(hr))
            {
                int     iCUVersion;

                if (FAILED(RegistryIntRead(hkcu, THEMEPROP_LMVERSION, &iCUVersion)))
                {
                    iCUVersion = 0;
                }
                if (iLMVersion != iCUVersion)
                {
                    BOOL    fOverride;
                    WCHAR   szValueData[MAX_PATH];

                    hr = RegistryIntWrite(hkcu, THEMEPROP_LMVERSION, iLMVersion);
                    if (FAILED(hr) || FAILED(RegistryIntRead(hklm, THEMEPROP_LMOVERRIDE, &fOverride)))
                    {
                        fOverride = FALSE;
                    }
                    if ((fOverride != FALSE) ||
                        FAILED(RegistryStrRead(hkcu, THEMEPROP_DLLNAME, szValueData, ARRAYSIZE(szValueData))) ||
                        (lstrlenW(szValueData) == 0))
                    {
                        DWORD   dwIndex;

                        dwIndex = 0;
                        do
                        {
                            DWORD   dwType, dwValueNameSize, dwValueDataSize;
                            WCHAR   szValueName[MAX_PATH];

                            dwValueNameSize = ARRAYSIZE(szValueName);
                            dwValueDataSize = sizeof(szValueData);
                            dwErrorCode = RegEnumValue(hklm,
                                                       dwIndex++,
                                                       szValueName,
                                                       &dwValueNameSize,
                                                       NULL,
                                                       &dwType,
                                                       reinterpret_cast<LPBYTE>(szValueData),
                                                       &dwValueDataSize);
                            if ((ERROR_SUCCESS == dwErrorCode) &&
                                ((REG_SZ == dwType) || (REG_EXPAND_SZ == dwType)) &&
                                (AsciiStrCmpI(szValueName, THEMEPROP_LMOVERRIDE) != 0))
                            {
                                if (AsciiStrCmpI(szValueName, THEMEPROP_DLLNAME) == 0)
                                {
                                    hr = RegistryStrWriteExpand(hkcu, szValueName, szValueData);
                                }
                                else
                                {
                                    hr = RegistryStrWrite(hkcu, szValueName, szValueData);
                                }
                            }
                        } while ((dwErrorCode == ERROR_SUCCESS) && SUCCEEDED(hr));
                        // Since we wrote a new DLL name, erase the old names
                        (DWORD)RegDeleteValue(hkcu, THEMEPROP_COLORNAME);
                        (DWORD)RegDeleteValue(hkcu, THEMEPROP_SIZENAME);
                    }
                }
            }
            else
            {
                hr = S_OK;
            }
            TW32(RegCloseKey(hkcu));
        }
        else
        {
            dwErrorCode = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }
        TW32(RegCloseKey(hklm));
    }
    else
    {
        //  It's possible for this key to be absent. Ignore the error.

        hr = S_OK;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ReestablishServerConnection
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//              
//  Purpose:    Forces an attempt to reconnect to the theme server. Used when
//              the port was disconnected but a refresh is desired because the
//              server came back up.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ReestablishServerConnection (void)

{
    HRESULT     hr;
    NTSTATUS    status;

    //---- do we have a good looking handle that as gone bad? ----
    if ((s_hAPIPort != NULL) && (s_hAPIPort != INVALID_HANDLE_VALUE))
    {
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_PING;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
        }
    }
    else
    {
        status = STATUS_PORT_DISCONNECTED;
    }

    if (NT_SUCCESS(status))
    {
        hr = S_OK;
    }
    else
    {
        //---- our handle has gone bad; reset for another try on next service call ----
        LockAcquire();
        if ((s_hAPIPort != NULL) && (s_hAPIPort != INVALID_HANDLE_VALUE))
        {
            TBOOL(CloseHandle(s_hAPIPort));
        }
        s_hAPIPort = INVALID_HANDLE_VALUE;
        LockRelease();
        hr = S_FALSE;
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LockAcquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Acquire the critical section.
//
//  History:    2000-12-01  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::LockAcquire (void)

{
    EnterCriticalSection(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LockRelease
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Release the critical section.
//
//  History:    2000-12-01  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::LockRelease (void)

{
    LeaveCriticalSection(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ConnectedToService
//
//  Arguments:  <none>
//
//  Returns:    bool
//              
//  Purpose:    Demand connect to service. Only do this once. This function
//              has knowledge of where the port exists within the NT object
//              namespace.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeServices::ConnectedToService (void)

{
    if (s_hAPIPort == INVALID_HANDLE_VALUE)
    {
        ULONG                           ulConnectionInfoLength;
        UNICODE_STRING                  portName;
        SECURITY_QUALITY_OF_SERVICE     sqos;
        WCHAR                           szConnectionInfo[32];

        RtlInitUnicodeString(&portName, THEMES_PORT_NAME);
        sqos.Length = sizeof(sqos);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = TRUE;
        lstrcpyW(szConnectionInfo, THEMES_CONNECTION_REQUEST);
        ulConnectionInfoLength = sizeof(szConnectionInfo);
        LockAcquire();
        if (!NT_SUCCESS(NtConnectPort(&s_hAPIPort,
                                      &portName,
                                      &sqos,
                                      NULL,
                                      NULL,
                                      NULL,
                                      szConnectionInfo,
                                      &ulConnectionInfoLength)))
        {
            s_hAPIPort = NULL;
        }
        LockRelease();
    }
    return(s_hAPIPort != NULL);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ReleaseConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Releases the API port connection.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::ReleaseConnection (void)

{
    if ((s_hAPIPort != INVALID_HANDLE_VALUE) && (s_hAPIPort != NULL))
    {
        LockAcquire();
        TBOOL(CloseHandle(s_hAPIPort));
        s_hAPIPort = INVALID_HANDLE_VALUE;
        LockRelease();
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::CheckForDisconnectedPort
//
//  Arguments:  status  =   NTSTATUS of last API request.
//
//  Returns:    <none>
//              
//  Purpose:    Checks for STATUS_PORT_DISCONNECTED. If found then it
//              releases the port object and NULL out the handle.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::CheckForDisconnectedPort (NTSTATUS status)

{
    if (STATUS_PORT_DISCONNECTED == status)
    {
        ReleaseConnection();
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::CurrentThemeMatch
//
//  Arguments:  pszThemeName            =   Name of theme.
//              pszColor                =   Color.
//              pszSize                 =   Size.
//              fLoadMetricsOnMatch     =   Load metrics.
//
//  Returns:    HRESULT
//              
//  Purpose:    Is the current theme the same as the theme specified? This
//              can be used to save reloading a theme when it's the same.
//
//  History:    2000-11-11  vtan        created (ported from themeldr.cpp)
//  --------------------------------------------------------------------------

bool    CThemeServices::CurrentThemeMatch (LPCWSTR pszThemeName, LPCWSTR pszColor, LPCWSTR pszSize, LANGID wLangID, bool fLoadMetricsOnMatch)

{
    bool    fMatch;
    HANDLE  hSection;

    fMatch = false;

    if (SUCCEEDED(GetGlobalTheme(&hSection)) && (hSection != NULL))
    {
        CThemeSection   pThemeSectionFile;

        if (SUCCEEDED(pThemeSectionFile.Open(hSection)))
        {
            fMatch = (ThemeMatch(pThemeSectionFile, pszThemeName, pszColor, pszSize, wLangID) != FALSE);

            if (fMatch)
            {
                //---- ensure color depth of monitor(s) are enough for theme ----
                if (GetSystemMetrics(SM_REMOTESESSION))     // only check for terminal server sessions
                {
                    if (FAILED(CheckColorDepth(pThemeSectionFile)))
                    {
                        fMatch = FALSE;
                    }
                }
            }

            if (fMatch && fLoadMetricsOnMatch)
            {
                SetSystemMetrics(GetThemeMetricsPtr(pThemeSectionFile), FALSE);
            }
        }
        TBOOL(CloseHandle(hSection));
    }
    return(fMatch);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LoadCurrentTheme
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//              
//  Purpose:    Loads the current theme as set in the registry for the
//              impersonated user.
//
//  History:    2000-11-11  vtan        created (ported from themeldr.cpp)
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::LoadCurrentTheme (void)

{
    HRESULT     hr = S_OK;
    WCHAR       szThemeName[MAX_PATH];
    WCHAR       szColorName[MAX_PATH];
    WCHAR       szSizeName[MAX_PATH];

    THR(GetCurrentUserThemeString(THEMEPROP_DLLNAME, L"", szThemeName, ARRAYSIZE(szThemeName)));
    if (szThemeName[0] != L'\0')
    {
        int     iLoadedBefore;
        HANDLE  hSection;
        int     nLangID;

        THR(GetCurrentUserThemeString(THEMEPROP_COLORNAME, L"", szColorName, ARRAYSIZE(szColorName)));
        THR(GetCurrentUserThemeString(THEMEPROP_SIZENAME, L"", szSizeName, ARRAYSIZE(szSizeName)));
        THR(GetCurrentUserThemeInt(THEMEPROP_LOADEDBEFORE, 0, &iLoadedBefore));
        THR(GetCurrentUserThemeInt(THEMEPROP_LANGID, -1, &nLangID));

    //  Does new user's theme match the current theme?
        if (nLangID != -1 && CurrentThemeMatch(szThemeName, szColorName, szSizeName, (LANGID) nLangID, (iLoadedBefore == 0)))
        {
            DWORD   dwFlags;

            //  Everything is done except this registry value.

            if (iLoadedBefore == 0)
            {
                THR(SetCurrentUserThemeInt(THEMEPROP_LOADEDBEFORE, 1));
            }

            hr = GetStatusFlags(&dwFlags);
            if (SUCCEEDED(hr))
            {
                if ((dwFlags & QTS_RUNNING) == 0)
                {
                    hr = GetGlobalTheme(&hSection);
                    if (SUCCEEDED(hr))
                    {
                        CUxThemeFile file; // Will clean up on destruction
                        
                        if (SUCCEEDED(file.OpenFromHandle(hSection, TRUE)))
                        {
                            hr = ApplyTheme(&file, 0, false);
                        }
                    }
                }
            }
        }
        else
        {
            hr = LoadTheme(&hSection, szThemeName, szColorName, szSizeName, TRUE);

            if (SUCCEEDED(hr))
            {
                DWORD   dwFlags;

                dwFlags = 0;

                //  Has this theme been loaded before?
                //  or has the user changed his/her language?
                if (iLoadedBefore == 0 || ((nLangID != -1) && ((LANGID) nLangID != GetUserDefaultUILanguage())))
                {
                    dwFlags |= AT_LOAD_SYSMETRICS;
                }

                CUxThemeFile file; // Will clean up on destruction
                
                if (SUCCEEDED(file.OpenFromHandle(hSection, TRUE)))
                {
                    hr = ApplyTheme(&file, dwFlags, false);
                }
            }
        }
    }
    else
    {
        hr = MakeError32(ERROR_NOT_FOUND);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::SectionProcessType
//
//  Arguments:  hSection    =   Section to walk and clear stock objects in.
//
//  Returns:    HRESULT
//              
//  Purpose:    Walks the section (read-only) and finds HBITMAPs and corresponding 
//              HBRUSHes  that are stock listed in the section and deletes these objects. 
//              This is work that needs to be done on the client.
//
//  History:    2000-11-17  lmouton     created
//                          vtan        rewritten from themeldr.cpp
//              2000-12-11  lmouton     added stock brushes
//  --------------------------------------------------------------------------

int     CThemeServices::SectionProcessType (const BYTE *pbThemeData, MIXEDPTRS& u)

{
    UNPACKED_ENTRYHDR   header;

    FillAndSkipHdr(u, &header);
    switch (header.ePrimVal)
    {
        case TMT_PARTJUMPTABLE:
        case TMT_STATEJUMPTABLE:
            break;
        case TMT_DIBDATA:
            TMBITMAPHEADER *pThemeBitmapHeader;

            pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(u.pb);
            ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);

            // Clean up stock bitmaps
            if (pThemeBitmapHeader->hBitmap != NULL)
            {
                HBITMAP     hBitmap;

                hBitmap = pThemeBitmapHeader->hBitmap;
                hBitmap = ClearBitmapAttributes(hBitmap, SBA_STOCK);
#ifdef DEBUG
                if (hBitmap == NULL)
                {
                    Log(LOG_TMBITMAP, L"UxTheme: ClearBitmapAttributes failed for %8X in SetGlobalTheme", hBitmap);
                }
                else
                {
                    BITMAP bm;

                    GetObject(hBitmap, sizeof bm, &bm);
                    g_dwStockSize -= bm.bmWidthBytes * bm.bmHeight;
                    if (DeleteObject(hBitmap))
                    {
                        //Log(LOG_TMBITMAP, L"Cleared stock bitmap:%8X, size is %d bytes, stock total is %d", 
                         //   pThemeBitmapHeader->hBitmap, bm.bmWidthBytes * bm.bmHeight, g_dwStockSize);
                    }
                    else
                    {
                        Log(LOG_TMBITMAP, L"Failed to delete bitmap:%8X", hBitmap);
                    }
                }
#else
                if (hBitmap != NULL)
                {
                    DeleteObject(hBitmap);
                }
#endif
            }

            // Clean up stock brushes
            if (pThemeBitmapHeader->iBrushesOffset != 0)
            {
                HBRUSH hBrush;
                HBRUSH *pBrushes; 
                
                pBrushes = (HBRUSH*) (pbThemeData + pThemeBitmapHeader->iBrushesOffset);

                for (UINT iBrush = 0; iBrush < pThemeBitmapHeader->nBrushes; iBrush++)
                {
                    if (pBrushes[iBrush] != NULL)
                    {
                        hBrush = NULL;

                        if (s_pfnClearBrushAttributes == NULL) 
                        {
                            HMODULE hMod = LoadLibrary(L"GDI32.DLL"); // No need to free
    
                            if (hMod)
                            {
                                s_pfnClearBrushAttributes = (HBRUSH (*)(HBRUSH, DWORD)) GetProcAddress(hMod, "ClearBrushAttributes");
                            }
                        }
                        if (s_pfnClearBrushAttributes != NULL)
                        {
                            hBrush = (*s_pfnClearBrushAttributes)(pBrushes[iBrush], SBA_STOCK);
                            if (hBrush != NULL)
                            {
                                Log(LOG_TMBRUSHES, L"Cleared stock brush %8X", pBrushes[iBrush]);
                            } else
                            {
                                Log(LOG_TMBRUSHES, L"ClearBrushAttributes FAILED for stock brush %8X", pBrushes[iBrush]);
                            }
                        } else
                        {
                            Log(LOG_TMBRUSHES, L"ClearBrushAttributes: Function not in GDI32.DLL");
                        }
                        if (hBrush == NULL) // Have to try to clean the brush anyway
                        {
                            hBrush = pBrushes[iBrush];
                        }
                        if (!DeleteObject(hBrush))
                        {
                            Log(LOG_TMBRUSHES, L"Failed to delete former stock brush %8X", hBrush);
                        }
                    }
                }
            }

            //  Fall thru to the default case that increments the mixed pointer.

        default:
            u.pb += header.dwDataLen;
            break;
    }
    return(header.ePrimVal);
}

//  --------------------------------------------------------------------------
//  CThemeServices::SectionWalkData
//
//  Arguments:  pV      =   Address of section data to walk.
//              iIndex  =   Index into section.
//
//  Returns:    <none>
//              
//  Purpose:    
//
//  History:    2000-11-17  lmouton     created
//                          vtan        rewritten from themeldr.cpp
//  --------------------------------------------------------------------------

void    CThemeServices::SectionWalkData (const BYTE *pbThemeData, int iIndexIn)

{
    bool        fDone;
    MIXEDPTRS   u;

    fDone = false;
    u.pb = const_cast<BYTE*>(pbThemeData + iIndexIn);
    while (!fDone)
    {
        //---- special post-handling ----
        switch (SectionProcessType(pbThemeData, u))
        {
            int     i, iLimit, iIndex;

            case TMT_PARTJUMPTABLE:
                u.pi++;
                iLimit = *u.pb++;
                for (i = 0; i < iLimit; ++i)
                {
                    iIndex = *u.pi++;
                    if (iIndex > -1)
                    {
                        SectionWalkData(pbThemeData, iIndex);
                    }
                }
                fDone = true;
                break;
            case TMT_STATEJUMPTABLE:
                iLimit = *u.pb++;
                for (i = 0; i < iLimit; ++i)
                {
                    iIndex = *u.pi++;
                    if (iIndex > -1)
                    {
                        SectionWalkData(pbThemeData, iIndex);
                    }
                }
                fDone = true;
                break;
            case TMT_JUMPTOPARENT:
                fDone = true;
                break;
            default:
                break;
        }
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::ClearStockObjects
//
//  Arguments:  hSection    =   Section to walk and clear bitmaps in.
//
//  Returns:    HRESULT
//              
//  Purpose:    Walks the section (read-only) and finds HBITMAPs and corresponding
//              HBRUSHes that are stock listed in the section and deletes these objects. 
//              This is work that needs to be done on the client.
//
//  History:    2000-11-17  lmouton     created
//                          vtan        rewritten from themeldr.cpp
//              2001-05-15  lmouton     Added semaphore support for cleaning from ~CUxThemeFile
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ClearStockObjects (HANDLE hSection, BOOL fForce)

{
    HRESULT         hr;
    BYTE*           pbThemeData;
    bool            bWriteable = true;
    HANDLE          hSectionWrite = NULL;

    // If the section is global, we can't write to it since only the server can.
    // So let's try to get write access, else we'll call the server
    pbThemeData = static_cast<BYTE*>(MapViewOfFile(hSection,
                                                   FILE_MAP_WRITE,
                                                   0,
                                                   0,
                                                   0));
    if (pbThemeData == NULL)
    {
        // Let's try to reopen a write handle for ourselves
        if (DuplicateHandle(GetCurrentProcess(),
                            hSection,
                            GetCurrentProcess(),
                            &hSectionWrite,
                            FILE_MAP_WRITE,
                            FALSE,
                            0) != FALSE)
        {
            pbThemeData = static_cast<BYTE*>(MapViewOfFile(hSectionWrite,
                                                           FILE_MAP_WRITE,
                                                           0,
                                                           0,
                                                           0));
        }

        if (pbThemeData == NULL)
        {
            // We can't open it for write, let's try read-only
            pbThemeData = static_cast<BYTE*>(MapViewOfFile(hSection,
                                                           FILE_MAP_READ,
                                                           0,
                                                           0,
                                                           0));
            bWriteable = false;
        }
#ifdef DEBUG
        else
        {
            Log(LOG_TMLOAD, L"Reopened section %d for write", reinterpret_cast<THEMEHDR*>(pbThemeData)->iLoadId);
        }
#endif
    }

#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        // Unexpected failure
        ASSERT(pbThemeData != NULL);
    }
#endif

    if (pbThemeData != NULL)
    {
        int                 i, iLimit;
        THEMEHDR            *pThemeHdr;
        APPCLASSLIVE        *pACL;

        pThemeHdr = reinterpret_cast<THEMEHDR*>(pbThemeData);
        hr = S_OK;

        Log(LOG_TMLOAD, L"ClearStockObjects for section %X, bWriteable=%d, dwFlags=%d, iLoadId=%d, fForce=%d", 
            hSection, bWriteable, pThemeHdr->dwFlags, pThemeHdr->iLoadId, fForce);

        if ((pThemeHdr->dwFlags & SECTION_HASSTOCKOBJECTS) && !(pThemeHdr->dwFlags & SECTION_GLOBAL))
        {
            // Make sure only one thread can do this
            WCHAR szName[64];

            if (pThemeHdr->iLoadId != 0)
            {
                // Each section has a unique iLoadId but not across sessions
                // It has to be global because the Theme service can create it
                wsprintf(szName, L"Global\\ClearStockGlobal%d-%d", pThemeHdr->iLoadId, NtCurrentPeb()->SessionId);
            }
            else
            {
                // The session is local to the process
                wsprintf(szName, L"ClearStockLocal%d-%d", GetCurrentProcessId(), NtCurrentPeb()->SessionId);
            }

            HANDLE hSemaphore = CreateSemaphore(NULL, 0, 1, szName);
            DWORD dwError = GetLastError();

            Log(LOG_TMLOAD, L"Opening semaphore %s, hSemaphore=%X, gle=%d", szName, hSemaphore, dwError);

            // If CreateSemaphore fails for another reason, ignore the failure, we have to clean and we only 
            //   risk a GDI assert on CHK builds.
            // We'll get access denied if the semaphore was created in the service on SetGlobalTheme, but 
            //   in this case fForce is true for winlogon, false for the other callers.
            bool bAlreadyExists = (dwError == ERROR_ALREADY_EXISTS || dwError == ERROR_ACCESS_DENIED);

#ifdef DEBUG
            if (LogOptionOn(LO_TMLOAD))
            {
                // Unexpected failure
                ASSERT(dwError == 0 || bAlreadyExists);
            }
#endif
            // If nobody else is already doing it
            if (!bAlreadyExists || fForce)
            {
                Log(LOG_TMLOAD, L"ClearStockObjects: Clearing data, semaphore = %s", szName);
#ifdef DEBUG
                bool bDisconnected = false;
#endif
                pACL = reinterpret_cast<APPCLASSLIVE*>(pbThemeData + pThemeHdr->iSectionIndexOffset);
                iLimit = pThemeHdr->iSectionIndexLength / sizeof(APPCLASSLIVE);

                for (i = 0; i < iLimit; ++pACL, ++i)
                {
                    SectionWalkData(pbThemeData, pACL->iIndex);
                }
                if (bWriteable)
                {
                    pThemeHdr->dwFlags &= ~SECTION_HASSTOCKOBJECTS; // To avoid doing it twice
                }
                else
                {
                    // Can't write to it, let's call MarkSection in the service to do it
                    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
                    if (ConnectedToService())
                    {
                        NTSTATUS                status;
                        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

                        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
                        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
                        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_MARKSECTION;
                        portMessageIn.apiThemes.apiSpecific.apiMarkSection.in.hSection = hSection;
                        portMessageIn.apiThemes.apiSpecific.apiMarkSection.in.dwAdd = 0;
                        portMessageIn.apiThemes.apiSpecific.apiMarkSection.in.dwRemove = SECTION_HASSTOCKOBJECTS;
                        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
                        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
                        status = NtRequestWaitReplyPort(s_hAPIPort,
                                                        &portMessageIn.portMessage,
                                                        &portMessageOut.portMessage);
                        CheckForDisconnectedPort(status);
#ifdef DEBUG
                        if (STATUS_PORT_DISCONNECTED == status)
                        {
                            bDisconnected = true; // This failure must not trigger the assert
                        }
#endif
                        if (NT_SUCCESS(status))
                        {
                            status = portMessageOut.apiThemes.apiGeneric.status;
                            if (NT_SUCCESS(status))
                            {
                                hr = S_OK;
                            }
                        }
                        if (!NT_SUCCESS(status))
                        {
                            hr = HRESULT_FROM_NT(status);
                        }
                    }
                }
#ifdef DEBUG
                // When the service goes down, we may fail ApplyTheme (so iLoadId is still 0), 
                //   and we fail MarkSection too, ignore this error.
                if (LogOptionOn(LO_TMLOAD) && !bDisconnected && pThemeHdr->iLoadId != 0)
                {
                    ASSERT(!(pThemeHdr->dwFlags & SECTION_HASSTOCKOBJECTS));
                }
#endif
            }
            else
            {
                Log(LOG_TMLOAD, L"ClearStockObjects: semaphore %s was already there", szName);
            }
            if (hSemaphore)
            {
                Log(LOG_TMLOAD, L"ClearStockObjects: Closing semaphore %X", hSemaphore);
                CloseHandle(hSemaphore);
            }
        }

        TBOOL(UnmapViewOfFile(pbThemeData));
    }
    else
    {
        DWORD   dwErrorCode;

        dwErrorCode = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }

    if (hSectionWrite != NULL)
    {
        CloseHandle(hSectionWrite);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeSettingsModified
//
//  Returns:    BOOL
//              
//  Purpose:    Detects that appearance settings have been changed on a
//                W2K machine by a roaming user.
//
//  History:    2000-11-28  lmouton          created
//  --------------------------------------------------------------------------

bool    CThemeServices::ThemeSettingsModified (void)

{
    WCHAR   szCurrent[MAX_PATH];
    WCHAR   szNewCurrent[MAX_PATH];

    //  If NewCurrent exists and is different from Current, Current
    //  has been tampered with on a roaming W2K machine

    THR(GetCurrentUserString(CONTROLPANEL_APPEARANCE_REGKEY, THEMEPROP_CURRSCHEME, L" ", szCurrent, ARRAYSIZE(szCurrent)));
    THR(GetCurrentUserString(CONTROLPANEL_APPEARANCE_REGKEY, THEMEPROP_NEWCURRSCHEME, L" ", szNewCurrent, ARRAYSIZE(szNewCurrent)));
    return((lstrcmpW(szNewCurrent, L" ") != 0) && (lstrcmpW(szCurrent, szNewCurrent) != 0));
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeEnforcedByPolicy
//
//  Arguments:  BOOL        TRUE if a .msstyles file is currently active for the user
//
//  Returns:    BOOL        TRUE if the policy changed something
//              
//  Purpose:    Loads the .msstyles file specified in the SetVisualStyle policy.
//
//  History:    2000-11-28  lmouton          created
//  --------------------------------------------------------------------------

bool    CThemeServices::ThemeEnforcedByPolicy (bool fActive)

{
    bool            fPolicyPresent;
    HKEY            hKeyPol = NULL;
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    fPolicyPresent = false;

    // See if a policy overrides the theme name
    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyCurrentUser,
                                       REGSTR_PATH_POLICIES L"\\" SZ_THEME_POLICY_KEY,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKeyPol)))
    {
        WCHAR   szNewThemeName[MAX_PATH + 1];

        lstrcpy(szNewThemeName, L" ");
        if (SUCCEEDED(RegistryStrRead(hKeyPol,
                                      SZ_POLICY_SETVISUALSTYLE,
                                      szNewThemeName,
                                      ARRAYSIZE(szNewThemeName))))
        {
            if (szNewThemeName[0] == L'\0') // Disable themes
            {
                if (fActive)
                {
                    THR(UpdateThemeRegistry(FALSE, NULL, NULL, NULL, FALSE, FALSE));

                    fPolicyPresent = true;
                }
            }
            else
            {
                if (FileExists(szNewThemeName))
                {
                    HRESULT hr = UpdateThemeRegistry(TRUE, szNewThemeName, NULL, NULL, FALSE, FALSE);

                    THR(hr);
                    if (!fActive || hr == S_OK)
                    {
                        // If we had no theme before or a different one, say we changed something
                        fPolicyPresent = true;
                    }
                }
            }
        }
        TW32(RegCloseKey(hKeyPol));
    }
    return(fPolicyPresent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set (doesn't use CrtDbgReport)
//---------------------------------------------------------------------------
#ifndef _STDAFX_UXTHEME_
#define _STDAFX_UXTHEME_
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define _ATL_NO_ATTRIBUTES
#define _ATL_APARTMENT_THREADED
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
#include <winuser.h>
#include <winnls.h>
//---------------------------------------------------------------------------
#include <w4warn.h>
//---------------------------------------------------------------------------
#define _UXTHEME_
//#define __NO_APPHACKS__  // disables app hacks
//---------------------------------------------------------------------------
//---- keep this for a while (allows building on win2000 for home development) ----
#ifndef SPI_GETDROPSHADOW
#define SPI_GETDROPSHADOW                   0x1024
#define SPI_SETDROPSHADOW                   0x1025
#endif
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "Errors.h"
#include "Utils.h"
#include "SimpStr.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#include "TmSchema.h"
#include <uxtheme.h>
#include <uxthemep.h>
#include "wrapper.h"

#undef  HKEY_CURRENT_USER
#define HKEY_CURRENT_USER   !!DO NOT USE HKEY_CURRENT_USER - USE CCurrentUser!!

#include "globals.h"
//---------------------------------------------------------------------------
#endif //_STDAFX_UXTHEME_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\textdraw.cpp ===
//---------------------------------------------------------------------------
//  TextDraw.cpp - implements the drawing API for text
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "TextDraw.h"
#include "info.h"
#include "DrawHelp.h"

//---------------------------------------------------------------------------
HRESULT CTextDraw::PackProperties(CRenderObj *pRender, int iPartId, int iStateId)
{
    memset(this, 0, sizeof(CTextDraw));     // allowed because we have no vtable

    //---- save off partid, stateid for debugging ----
    _iSourcePartId = iPartId;
    _iSourceStateId = iStateId;

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TEXTCOLOR, &_crText)))
        _crText = 0;          // default value
    
    //---- shadow ----
    if (SUCCEEDED(pRender->GetPosition(iPartId, iStateId, TMT_TEXTSHADOWOFFSET, &_ptShadowOffset)))
    {
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TEXTSHADOWCOLOR, &_crShadow)))
            _crShadow = RGB(0, 0, 0);          // default value = black

        if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_TEXTSHADOWTYPE, (int *)&_eShadowType)))
            _eShadowType = TST_NONE;           // default value
    }

    //---- border ----
    if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_TEXTBORDERSIZE, &_iBorderSize)))
    {
        _iBorderSize = 0;
    }
    else
    {
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TEXTBORDERCOLOR, &_crBorder)))
            _crBorder = RGB(0, 0, 0);     // default value
    }

    //---- font ----
    if (SUCCEEDED(pRender->GetFont(NULL, iPartId, iStateId, TMT_FONT, FALSE, &_lfFont)))
        _fHaveFont = TRUE;

    //---- edge colors ----
    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGELIGHTCOLOR, &_crEdgeLight)))
        _crEdgeLight = RGB(192, 192, 192);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGEHIGHLIGHTCOLOR, &_crEdgeHighlight)))
        _crEdgeHighlight = RGB(255, 255, 255);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGESHADOWCOLOR, &_crEdgeShadow)))
        _crEdgeShadow = RGB(128, 128, 128);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGEDKSHADOWCOLOR, &_crEdgeDkShadow)))
        _crEdgeDkShadow = RGB(0, 0, 0);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGEFILLCOLOR, &_crEdgeFill)))
        _crEdgeFill = _crEdgeLight;

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL CTextDraw::KeyProperty(int iPropId)
{
    BOOL fKey = FALSE;

    switch (iPropId)
    {
        case TMT_TEXTCOLOR:
        case TMT_TEXTSHADOWOFFSET:
        case TMT_TEXTSHADOWCOLOR:
        case TMT_TEXTSHADOWTYPE:
        case TMT_TEXTBORDERSIZE:
        case TMT_TEXTBORDERCOLOR:
        case TMT_FONT:
        case TMT_EDGELIGHTCOLOR:
        case TMT_EDGEHIGHLIGHTCOLOR:
        case TMT_EDGESHADOWCOLOR:
        case TMT_EDGEDKSHADOWCOLOR:
        case TMT_EDGEFILLCOLOR:
            fKey = TRUE;
            break;
    }

    return fKey;
}
//---------------------------------------------------------------------------
void CTextDraw::DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo)
{
    if (fFullInfo)
        pFile->OutLine(L"Dump of CTextDraw at offset=0x%x", (BYTE *)this - pbThemeData);
    else
        pFile->OutLine(L"Dump of CTextDraw");
    
    pFile->OutLine(L"  _crText=0x%08x", _crText);

    pFile->OutLine(L"  _ptShadowOffset=(%d, %d)", _ptShadowOffset.x, _ptShadowOffset.y);

    pFile->OutLine(L"  _crEdgeLight=0x%08x, _crEdgeHighlight=0x%08x, _crEdgeShadow=0x%08x",
        _crEdgeLight, _crEdgeHighlight, _crEdgeShadow);

    pFile->OutLine(L"  _crEdgeDkShadow=0x%08x, _crEdgeFill=0x%08x, _crShadow=0x%08x",
        _crEdgeDkShadow, _crEdgeFill, _crShadow);

    pFile->OutLine(L"  _eShadowType, _iBorderSize=%d, _crBorder=0x%08x",
        _eShadowType, _iBorderSize, _crBorder);

    //---- dump resolution-independent font points ----
    int iFontPoints = FontPointSize(_lfFont.lfHeight);

    pFile->OutLine(L"  _fHaveFont=%d, font: %s, size=%d points, bold=%d, italic=%d",
        _fHaveFont, _lfFont.lfFaceName, iFontPoints, _lfFont.lfWeight > 400, _lfFont.lfItalic);
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::DrawText(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
        DWORD dwCharCount, DWORD dwTextFlags, const RECT *pRect, const DTTOPTS *pOptions)
{
    Log(LOG_TM, L"DrawText(): iPartId=%d, pszText=%s", iPartId, _pszText);

    int iRetVal;
    HFONT hFont = NULL;
    COLORREF oldcolor = 0;

    HRESULT hr = S_OK;
    BOOL fOldColor = FALSE;
    RESOURCE HFONT oldfont = NULL;

    LPWSTR pszText = (LPWSTR)_pszText;      // so DrawText() calls are happy
    dwTextFlags &= ~(DT_MODIFYSTRING);      // we don't want to change the constant ptr

    int oldmode = SetBkMode(hdc, TRANSPARENT);
    RECT rect;

    COLORREF crText = _crText;
    COLORREF crBorder = _crBorder;
    COLORREF crShadow = _crShadow;

    TEXTSHADOWTYPE eShadowType = _eShadowType;
    POINT ptShadowOffset = _ptShadowOffset;
    int iBorderSize = _iBorderSize;

    if (pOptions)
    {
        DWORD dwFlags = pOptions->dwFlags;

        if (dwFlags & DTT_TEXTCOLOR)
            crText = pOptions->crText;

        if (dwFlags & DTT_BORDERCOLOR)
            crBorder = pOptions->crBorder;

        if (dwFlags & DTT_SHADOWCOLOR)
            crShadow = pOptions->crShadow;

        if (dwFlags & DTT_SHADOWTYPE)
            eShadowType = (TEXTSHADOWTYPE)pOptions->eTextShadowType;

        if (dwFlags & DTT_SHADOWOFFSET)
            ptShadowOffset = pOptions->ptShadowOffset;

        if (dwFlags & DTT_BORDERSIZE)
            iBorderSize = pOptions->iBorderSize;
    }

    BOOL fShadow = (eShadowType != TST_NONE);

    if (_fHaveFont)
    {
        hr = pRender->GetScaledFontHandle(hdc, &_lfFont, &hFont);
        if (FAILED(hr))
            goto exit;

        oldfont = (HFONT)SelectObject(hdc, hFont);
    }

    //---- BLURRED shadow approach ----
    if ((fShadow) && (eShadowType == TST_CONTINUOUS))   
    {
        SetRect(&rect, pRect->left, pRect->top, pRect->right, pRect->bottom);

        hr = EnsureUxCtrlLoaded();
        if (FAILED(hr))
            goto exit;

        //---- this will draw shadow & text (no outline support yet) ----
        iRetVal = CCDrawShadowText(hdc, pszText, dwCharCount, &rect, dwTextFlags, crText, crShadow,
            ptShadowOffset.x, ptShadowOffset.y);
    }
    else        //---- normal approach ----
    {
        //---- draw SINGLE shadow first ----
        if (fShadow) 
        {
            oldcolor = SetTextColor(hdc, crShadow);
            fOldColor = TRUE;

            //---- adjust rect for drawing shadow ----
            rect.left = pRect->left + ptShadowOffset.x;
            rect.top = pRect->top + ptShadowOffset.y;
            rect.right = pRect->right + ptShadowOffset.x;
            rect.bottom = pRect->bottom, ptShadowOffset.y;

            iRetVal = DrawTextEx(hdc, pszText, dwCharCount, &rect, dwTextFlags, NULL);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
        SetRect(&rect, pRect->left, pRect->top, pRect->right, pRect->bottom);

        //---- draw outline, if wanted ----
        if (iBorderSize)        // draw outline around text
        {
            iRetVal = BeginPath(hdc);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }

            iRetVal = DrawTextEx(hdc, pszText, dwCharCount, &rect, dwTextFlags, NULL);
            if (! iRetVal)
            {
                AbortPath(hdc);
                hr = MakeErrorLast();
                goto exit;
            }

            EndPath(hdc);

            HPEN pen, oldpen;
            HBRUSH brush, oldbrush;

            pen = CreatePen(PS_SOLID, iBorderSize, crBorder);
            brush = CreateSolidBrush(crText);
            if ((pen) && (brush))
            {
                oldpen = (HPEN)SelectObject(hdc, pen);
                oldbrush = (HBRUSH)SelectObject(hdc, brush);

                //---- this draws both outline & normal text ---
                StrokeAndFillPath(hdc);

                SelectObject(hdc, oldpen);
                SelectObject(hdc, oldbrush);
            }
        }
        else                    // draw normal text
        {
            if (fOldColor)
                SetTextColor(hdc, crText);
            else
            {
                oldcolor = SetTextColor(hdc, crText);
                fOldColor = TRUE;
            }

            iRetVal = DrawTextEx(hdc, pszText, dwCharCount, &rect, dwTextFlags, NULL);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
    }


    hr = S_OK;

exit:
    //---- restore hdc objects ----
    SetBkMode(hdc, oldmode);

    if (fOldColor)
        SetTextColor(hdc, oldcolor);

    if (oldfont)
        SelectObject(hdc, oldfont);

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::GetTextExtent(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
    int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect)
{
    LPWSTR pszText = (LPWSTR)_pszText;      // so DrawText() calls are happy
    dwTextFlags &= ~(DT_MODIFYSTRING);      // we don't want to change the constant ptr

    Log(LOG_TM, L"GetTextExtent(): iPartId=%d, pszText=%s", iPartId, pszText);

    RESOURCE HFONT oldfont = NULL;
    HFONT hFont = NULL;
    HRESULT hr = S_OK;

    if (_fHaveFont)
    {
        hr = pRender->GetScaledFontHandle(hdc, &_lfFont, &hFont);
        if (FAILED(hr))
            goto exit;

        oldfont = (HFONT)SelectObject(hdc, hFont);
    }

    RECT rect;
    int iRetVal;

    if (pBoundingRect)
        rect = *pBoundingRect;
    else
        SetRect(&rect, 0, 0, 0, 0);

    iRetVal = DrawTextEx(hdc, pszText, iCharCount, &rect, dwTextFlags | DT_CALCRECT, NULL);
    if (! iRetVal)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //----do NOT adjust for text shadow (ok if shadows overlap...) ----

    *pExtentRect = rect;

exit:
    //---- restore hdc objects ----
    if (oldfont)
        SelectObject(hdc, oldfont);

    Log(LOG_TM, L"END Of GetTextExtent()");

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::GetTextMetrics(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, TEXTMETRIC* ptm)
{
    Log(LOG_TM, L"GetTextMetrics(): iPartId=%d, ", iPartId);

    HRESULT hr = S_OK;
    RESOURCE HFONT hFont = NULL;
    RESOURCE HFONT oldfont = NULL;

    if (! ptm)
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    if (_fHaveFont)
    {
        hr = pRender->GetScaledFontHandle(hdc, &_lfFont, &hFont);
        if (FAILED(hr))
            goto exit;

        oldfont = (HFONT)SelectObject(hdc, hFont);
    }

    if (! ::GetTextMetrics(hdc, ptm))
    {
        hr = MakeErrorLast();
        goto exit;
    }

exit:
    //---- restore hdc objects ----
    if (oldfont)
        SelectObject(hdc, oldfont);

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    Log(LOG_TM, L"END Of GetTextMetrics()");
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::DrawEdge(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, const RECT *pDestRect, 
    UINT uEdge, UINT uFlags, OUT RECT *pContentRect)
{
    Log(LOG_TM, L"DrawEdge(): iPartId=%d, iStateId=%d, uEdge=0x%08x, uFlags=0x%08x", iPartId, iStateId, uEdge, uFlags);
    HRESULT hr = _DrawEdge(hdc, pDestRect, uEdge, uFlags, 
        _crEdgeLight, _crEdgeHighlight, _crEdgeShadow, _crEdgeDkShadow, _crEdgeFill, pContentRect);
    Log(LOG_TM, L"END Of DrawEdge()");
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\textfade.cpp ===
//---------------------------------------------------------------------------
//    TextFade.cpp - text fading code (removed from taskbar)
//---------------------------------------------------------------------------
//  BEGIN fade-text drawing functions and friends
//---------------------------------------------------------------------------
#include "stdafx.h"
//---------------------------------------------------------------------------
static HBITMAP CreateDibSection32Bit(int w, int h, void** ppv)
{
    HBITMAP bitmap;
    BITMAPINFO bmi;
    memset(&bmi, 0, sizeof(BITMAPINFO));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = w;
    bmi.bmiHeader.biHeight = h;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bitmap = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, ppv, NULL, 0);
    if (bitmap)
        memset(*ppv, 0xff, w*h*4); //32bpp=4bytes
    return bitmap;
}
//---------------------------------------------------------------------------
static void SetupAlphaChannel(DWORD* pdw, int w, int h, BYTE bstart, BYTE bend, int nExtra)
{
    //nExtra is extra space that we want to fill with the final value
    int i,j;
    w -= nExtra;
    if (bstart > bend)
    {
        BYTE bdiff = bstart - bend;
        for (j=0;j<h;j++)
        {
            for (i=0;i<w;i++)
            {
                BYTE a = bstart - bdiff * i/w; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
            for (i=w;i<w+nExtra;i++)
            {
                BYTE a = bend; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
        }
    }
    else
    {
        BYTE bdiff = bend - bstart;
        for (j=0;j<h;j++)
        {
            for (i=0;i<w;i++)
            {
                BYTE a = bstart + bdiff * i/w; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
            for (i=w;i<w+nExtra;i++)
            {
                BYTE a = bend; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
        }
    }
}
//---------------------------------------------------------------------------
int ExtTextOutAlpha(HDC dc, int X, int Y, UINT fuOptions, CONST RECT *lprc,
    LPCTSTR lpsz, UINT nCount, CONST INT *lpDx)
{
    BOOL bEffects = FALSE;
    SystemParametersInfo(SPI_GETUIEFFECTS, 0, (void*)&bEffects, 0);
    // don't alpha blend if ui effects off or number of colors <= 256
    if (!bEffects || 
        (GetDeviceCaps(dc, BITSPIXEL) * GetDeviceCaps(dc, PLANES) <= 8))
    {
        return ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nCount, lpDx);
    }

    if (lprc == NULL)
        return ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nCount, lpDx);

    RECT rc = *lprc;
    int nwidth = rc.right -rc.left;
    int nheight = rc.bottom - rc.top;
    int nLen = (nCount == -1) ? lstrlen(lpsz) : nCount;
    int nFit=0;
    int* pFit = new int[nLen];
    if (pFit == NULL)
        return 0;
    pFit[0] = 0;
    SIZE size;
    GetTextExtentExPoint(dc, lpsz, nLen, nwidth, &nFit, pFit, &size);
    if (nFit >= nLen)
        return ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nCount, lpDx);
        
    // too small, let's alpha blend it

    if ((nwidth <= 0) || (nheight <= 0))
        return 1;

    TEXTMETRIC tm;
    GetTextMetrics(dc, &tm);
    int nPix = tm.tmAveCharWidth*5;
    //don't fade out more than half the text
    if (nPix > nwidth)
        nPix = nwidth/2;

    //Create a 32bpp dibsection to store the background
    void* pv = NULL;
    HDC dcbitmap = CreateCompatibleDC(dc);
    int nRet = 0;
    if (dcbitmap != NULL)
    {
        HBITMAP bitmap = CreateDibSection32Bit(nPix, nheight, &pv);
        if (bitmap != NULL)
        {
            HBITMAP tmpbmp = (HBITMAP) SelectObject(dcbitmap, bitmap);
            BitBlt(dcbitmap, 0, 0, nPix, nheight, dc, rc.right-nPix, rc.top, SRCCOPY);
            //Setup the per-pixel alpha blending values
            SetupAlphaChannel((DWORD*)pv, nPix, nheight, 0x00, 0xdf, 0);
  
            //Draw the text onto the display DC
            ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nLen, lpDx);

            //Blend the background back into the display
            BLENDFUNCTION blend = {AC_SRC_OVER, 0, 0xff, AC_SRC_ALPHA};
            GdiAlphaBlend(dc, rc.right-nPix, rc.top, nPix, nheight, dcbitmap, 0, 0, nPix, nheight, blend);
            ::SelectObject(dcbitmap, tmpbmp);
            DeleteObject(bitmap);
            nRet = 1;
        }
        DeleteDC(dcbitmap);    
    }
    return nRet;
}
//---------------------------------------------------------------------------
int DrawTextAlpha(HDC hdc, LPCTSTR lpsz, int nCount, RECT* prc, UINT uFormat)
{
    BOOL bEffects = FALSE;
    SystemParametersInfo(SPI_GETUIEFFECTS, 0, (void*)&bEffects, 0);
    // don't alpha blend if ui effects off or number of colors <= 256
    if (!bEffects || 
        (GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) <= 8))
    {
        return DrawText(hdc, lpsz, nCount, prc, uFormat);
    }
    UINT nEllipsis = (DT_END_ELLIPSIS|DT_WORD_ELLIPSIS|DT_WORD_ELLIPSIS); 
    if (!(uFormat & DT_SINGLELINE) || !(uFormat & DT_END_ELLIPSIS) || (uFormat & DT_CALCRECT))
        return ::DrawText(hdc, lpsz, nCount, prc, uFormat);
    //we are single line and ellipses are requested
    //we are going to alpha blend though
    uFormat &= ~nEllipsis; //turn all ellipsis flags off
    if (nCount == -1)
        nCount = lstrlen(lpsz);

    RECT rc;
    CopyRect(&rc, prc);
    ::DrawText(hdc, (TCHAR*)lpsz, nCount, &rc, uFormat | DT_CALCRECT);
    if (rc.right <= prc->right) //not truncated
        return ::DrawText(hdc, lpsz, nCount, prc, uFormat);

    // DT_CENTER is effectively ignored when ellipses flags are on, 
    // because text is clipped to fit in rectangle.  With fading, we
    // need to justify the text.
    uFormat &= ~DT_CENTER;

    CopyRect(&rc, prc);
    int nwidth = RECTWIDTH(&rc);
    int nheight = RECTHEIGHT(&rc);

    if ((nwidth <= 0) || (nheight <= 0))
        return 1;

    // Figure out how much of the background to stash away
    TEXTMETRIC tm;
    GetTextMetrics(hdc, &tm);
    int nPix = tm.tmAveCharWidth*5; //five characters worth
    if (nPix > nwidth/2)
        nPix = nwidth/2;
    //Adjust by one max char width because DrawText can draw up to 
    //one extra character outside the clip rect.
    nPix += tm.tmMaxCharWidth;
    rc.right += tm.tmMaxCharWidth;

    //Create a 32bpp dibsection to store the background
    void* pv = NULL;
    HDC dcbitmap = CreateCompatibleDC(hdc);
    int nRet = 0;
    if (dcbitmap != NULL)
    {
        HBITMAP bitmap = CreateDibSection32Bit(nPix, nheight, &pv);
        if (bitmap != NULL)
        {
            HBITMAP tmpbmp = (HBITMAP) SelectObject(dcbitmap, bitmap);
            BitBlt(dcbitmap, 0, 0, nPix, nheight, hdc, rc.right-nPix, rc.top, SRCCOPY);
            //Setup the per-pixel alpha blending values
            SetupAlphaChannel((DWORD*)pv, nPix, nheight, 0x00, 0xdf, tm.tmMaxCharWidth);
            //Draw the text onto the display DC
            ::DrawText(hdc, lpsz, nCount, prc, uFormat);

            //Blend the background back into the display
            BLENDFUNCTION blend = {AC_SRC_OVER, 0, 0xff, AC_SRC_ALPHA};
            GdiAlphaBlend(hdc, rc.right-nPix, rc.top, nPix, nheight, dcbitmap, 0, 0, nPix, nheight, blend);
            ::SelectObject(dcbitmap, tmpbmp);
            DeleteObject(bitmap);
            nRet = 1;
        }
        DeleteDC(dcbitmap);    
    }
    return nRet;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\sethook.h ===
//---------------------------------------------------------------------------
//  SetHook.h - Window and DefWindowProc hooking decls.
//---------------------------------------------------------------------------
#pragma once

//---------------------------------------------------------------------------
//  Hooked message disposition flags
#define HMD_NIL           0x00000000  
#define HMD_THEMEDETACH   0x00000001  // detach: theme removed
#define HMD_WINDOWDESTROY 0x00000002  // detach: window is dying
#define HMD_CHANGETHEME   0x00000004  // theme is changing
#define HMD_REATTACH      0x00000008  // attempt attaching window that was previously rejected.
#define HMD_REVOKE        0x00000010  // theme revoked on non-compliant window.
#define HMD_PROCESSDETACH 0x00000020  // process is dying
#define HMD_BULKDETACH    0x00000040  // context is a DetachAll sequence.

//---------------------------------------------------------------------------
//  Query class-specific hooking

BOOL    WINAPI FrameHookEnabled();
BOOL    WINAPI CtlHooksEnabled();
BOOL    WINAPI CompositingEnabled();

//---------------------------------------------------------------------------
//  ThemeHookStartup/Shutdown() - invoked from DLL_PROCESS_ATTACH/DETACH, resp.
BOOL WINAPI ThemeHookStartup();
BOOL WINAPI ThemeHookShutdown();
//---------------------------------------------------------------------------
//  More helper macros.
#define STRINGIZE_ATOM(a)     MAKEINTATOM(a)
#define BOGUS_THEMEID         0

#define IS_THEME_CHANGE_TARGET(lParam) \
    ((! g_pAppInfo->CustomAppTheme()) || (lParam & WTC_CUSTOMTHEME))
//---------------------------------------------------------------------------
//  Nonclient theming target window classifications [scotthan]:

// NIL:    window has not been evaluated
// REJECT: window has been rejected on the basis of current attributes or conditions, 
//            but may be reconsidered a theming target
// EXILE:  window has been permanently rejected for attachment themewnd object because
//            it's wndproc has proven itself incompatible with theme protocol(s).

//  Helper macros:
#define THEMEWND_NIL                ((CThemeWnd*)NULL) 
#define THEMEWND_REJECT             ((CThemeWnd*)-1)   
#define THEMEWND_EXILE              ((CThemeWnd*)-2)   
#define THEMEWND_FAILURE            ((CThemeWnd*)-3)   

#define EXILED_THEMEWND(pwnd)   ((pwnd)==THEMEWND_EXILE)
#define REJECTED_THEMEWND(pwnd) ((pwnd)==THEMEWND_REJECT)
#define FAILED_THEMEWND(pwnd)   ((pwnd)==THEMEWND_FAILURE)

#define VALID_THEMEWND(pwnd)    (((pwnd) != THEMEWND_NIL) && !FAILED_THEMEWND(pwnd) &&\
                                  !REJECTED_THEMEWND(pwnd) && !EXILED_THEMEWND(pwnd))

#define ISWINDOW(hwnd)         ((hwnd) && (hwnd != INVALID_HANDLE_VALUE) && (IsWindow(hwnd)))
//---------------------------------------------------------------------------
extern "C" BOOL WINAPI ThemeInitApiHook( DWORD dwCmd, void * pvData );

//---- must manually call ProcessStartUp() if needed in ThemeInitApiHook() ----
BOOL ProcessStartUp(HINSTANCE hModule);

//---- avail for calling when tracking down leaks with BoundsChecker() ----
BOOL ProcessShutDown();
//---------------------------------------------------------------------------
inline void ShutDownCheck(HWND hwnd)
{
#ifdef LOGGING
    //---- if we just released APP Window, call ProcessShutDown() for best leak detection ----
    if (hwnd == g_hwndFirstHooked)
    {
        if (LogOptionOn(LO_SHUTDOWN))    // "+shutdown" log option selected
            ProcessShutDown();
    }
#endif
}
//---------------------------------------------------------------------------//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  UxTheme.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\themefile.cpp ===
//---------------------------------------------------------------------------
//  ThemeFile.cpp - manages loaded theme files
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "ThemeFile.h"
#include "Loader.h"
#include "Services.h"
//---------------------------------------------------------------------------
CUxThemeFile::CUxThemeFile()
{
    strcpy(_szHead, "thmfile"); 
    strcpy(_szTail, "end");

    Reset();
}
//---------------------------------------------------------------------------
CUxThemeFile::~CUxThemeFile()
{
    if (_pbThemeData || _hMemoryMap)
        CloseFile();

    strcpy(_szHead, "deleted"); 
}
//---------------------------------------------------------------------------
__inline bool CUxThemeFile::IsReady()
{
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;

    if (hdr != NULL && ((hdr->dwFlags & SECTION_READY) != 0))
    {
        return true;
    }
    return false;
}
//---------------------------------------------------------------------------
__inline bool CUxThemeFile::IsGlobal()
{
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;

    if (hdr != NULL && ((hdr->dwFlags & SECTION_GLOBAL) != 0))
    {
        return true;
    }
    return false;
}
//---------------------------------------------------------------------------
__inline bool CUxThemeFile::HasStockObjects()
{
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;

    if (hdr != NULL && ((hdr->dwFlags & SECTION_HASSTOCKOBJECTS) != 0))
    {
        return true;
    }
    return false;
}
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::CreateFile(int iLength, BOOL fReserve)
{
    Log(LOG_TM, L"CUxThemeFile::CreateFile");

    HRESULT hr = S_OK;

    if (_pbThemeData)
        CloseFile();

    //---- we rely on all theme section names containing "ThemeSection" in CHK build so ----
    //---- devs/testers can verify that all handles to old theme sections are released. ----
    //---- For FRE builds, we want a NULL name for security reasons. ----
    WCHAR *pszName = NULL;

#ifdef DEBUG
    WCHAR szSectionName[MAX_PATH];
    wsprintf(szSectionName, L"Debug_Create_ThemeSection_%d_%d", GetProcessWindowStation(), 
        GetTickCount());

    pszName = szSectionName;
#endif

    _hMemoryMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
        PAGE_READWRITE | (fReserve ? SEC_RESERVE : 0), 0, iLength, pszName);
    if (! _hMemoryMap)
    {
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFile: could not create shared memory mapping");
        hr = MakeErrorLast();
        goto exit;
    }

    _pbThemeData = (BYTE *)MapViewOfFile(_hMemoryMap, FILE_MAP_WRITE, 0, 0, 0);
    if (! _pbThemeData)
    {
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFile: could not create shared memory view");
        CloseHandle(_hMemoryMap);

        hr = MakeErrorLast();
        goto exit;
    }

    Log(LOG_TMHANDLE, L"CUxThemeFile::CreateFile FILE CREATED: len=%d, addr=0x%x", 
        iLength, _pbThemeData);

exit:
    if (FAILED(hr))
        Reset();

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::CreateFromSection(HANDLE hSection)
{
    Log(LOG_TM, L"CUxThemeFile::CreateFromSection");

    HRESULT hr = S_OK;
    void *pvOld = NULL;

    //---- ensure we start with all previous handles closed ----
    if (_pbThemeData)
        CloseFile();

    //---- get access to source section data ----
    pvOld = MapViewOfFile(hSection, FILE_MAP_READ, 0, 0, 0);
    if (! pvOld)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    THEMEHDR *pHdr = (THEMEHDR *)pvOld;
    DWORD dwTrueSize = pHdr->dwTotalLength;

    //---- we rely on all theme section names containing "ThemeSection" in CHK build so ----
    //---- devs/testers can verify that all handles to old theme sections are released. ----
    //---- For FRE builds, we want a NULL name for security reasons. ----
    WCHAR *pszName = NULL;

#ifdef DEBUG
    WCHAR szSectionName[MAX_PATH];
    wsprintf(szSectionName, L"Debug_CreateFromSection_ThemeSection_%d_%d", GetProcessWindowStation(), 
        GetTickCount());

    pszName = szSectionName;
#endif

    //---- create the new section ----
    _hMemoryMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
        PAGE_READWRITE, 0, dwTrueSize, pszName);
    if (! _hMemoryMap)
    {
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFromSection: could not create shared memory mapping");
        hr = MakeErrorLast();
        goto exit;
    }

    //---- get access to new section data ----
    _pbThemeData = (BYTE *)MapViewOfFile(_hMemoryMap, FILE_MAP_WRITE, 0, 0, 0);
    if (! _pbThemeData)
    {
        hr = MakeErrorLast();
        Log(LOG_ALWAYS, L"CThemeFile::CreateFromSection: could not create shared memory view");
        goto exit;
    }

    //---- copy the data from the old section to the new section ----
    __try
    {
        CopyMemory(_pbThemeData, pvOld, dwTrueSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = GetExceptionCode();
        goto exit;
    }

    //---- ensure version, checksum, etc. is all looking good ----
    hr = ValidateThemeData(TRUE);
    if (FAILED(hr))
        goto exit;

    Log(LOG_TMHANDLE, L"CUxThemeFile::CreateFromSection FILE CREATED: addr=0x%x", 
        _pbThemeData);

exit:
    if (pvOld != NULL)
        UnmapViewOfFile(pvOld);

    if (FAILED(hr))
        CloseFile();

    return hr;
}
//---------------------------------------------------------------------------
// If fCleanupOnFailure is FALSE, we won't close the handle passed, even on failure.
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::OpenFromHandle(HANDLE handle, BOOL fCleanupOnFailure)
{
    HRESULT hr = S_OK;

    if (_pbThemeData)
        CloseFile();

    _pbThemeData = (BYTE *)MapViewOfFile(handle, FILE_MAP_READ, 0, 0, 0);
    if (! _pbThemeData)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    _hMemoryMap = handle;

    //---- ensure data is valid ----
    hr = ValidateThemeData(FALSE);
    if (FAILED(hr))
    {   
        if (!fCleanupOnFailure)
        {
            _hMemoryMap = NULL;	// don't give up the refcount on the handle
            CloseFile();
        }

        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

#ifdef DEBUG
    THEMEHDR *ph;
    ph = (THEMEHDR *)_pbThemeData;
    Log(LOG_TMHANDLE, L"CUxThemeFile::OpenFromHandle OPENED: num=%d, addr=0x%x", 
        ph->iLoadId, _pbThemeData);
#endif

exit:
    if (FAILED(hr))
    {
        if (!fCleanupOnFailure)
        {
            Reset();
        }
        else
        {
            CloseFile();
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::ValidateThemeData(BOOL fFullCheck)
{
    HRESULT hr = S_OK;
    THEMEHDR *hdr;

    if (! ValidateObj())
    {
        hr = MakeError32(ERROR_INTERNAL_ERROR);
        goto exit;
    }

    if (IsBadReadPtr(_pbThemeData, 4))        // sufficient test
    {
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    hdr = (THEMEHDR *)_pbThemeData;

    if (0 != memcmp(hdr->szSignature, kszBeginCacheFileSignature, kcbBeginSignature)) // bad ptr
    {
#ifdef DEBUG
        CHAR szSignature[kcbBeginSignature + 1];

        memcpy(szSignature, hdr->szSignature, kcbBeginSignature);
        szSignature[kcbBeginSignature] = '\0';

        Log(LOG_ERROR, L"ValidateThemeData(): bad header signature: %S", szSignature);
#else
        Log(LOG_ERROR, L"ValidateThemeData(): bad header signature");
#endif
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if (hdr->dwVersion != THEMEDATA_VERSION)
    {
        Log(LOG_ALWAYS, L"ValidateThemeData(): wrong theme data version: 0x%x", hdr->dwVersion);
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if (!IsReady())               // data not ready to use
    {
        Log(LOG_ALWAYS, L"ValidateThemeData(): data not READY - hdr->dwFlags=%x", hdr->dwFlags);
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if (!fFullCheck)        // we are done
        goto exit;

    //---- check that checksum ----
#ifdef NEVER
    if (hdr->dwCheckSum != DataCheckSum())
#else // Whistler:190200:Instead of checking the checksum, check the end of file signature, to avoid paging in everything
    if (0 != memcmp(_pbThemeData + hdr->dwTotalLength - kcbEndSignature, kszEndCacheFileSignature, kcbEndSignature))
    {
        Log(LOG_ERROR, L"ValidateThemeData(): bad end of file signature");
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }
#endif // NEVER

exit:
    return hr;
}
//---------------------------------------------------------------------------
DWORD CUxThemeFile::DataCheckSum()
{
    DWORD sum = 0;

    if (ValidateObj())
    {
        THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;
        DWORD len = hdr->dwTotalLength - sizeof(THEMEHDR);
        BYTE *pData = _pbThemeData + sizeof(THEMEHDR);

        while (len--)
            sum += *pData++;
    }

    return sum;
}
//---------------------------------------------------------------------------
void CUxThemeFile::CloseFile()
{
#ifdef DEBUG
    THEMEHDR *ph = (THEMEHDR *)_pbThemeData;
    if (ph != NULL)
    {
        Log(LOG_TMHANDLE, L"Share CLOSED: num=%d, addr=0x%x", 
            ph->iLoadId, _pbThemeData);
    }
#endif

    if (_hMemoryMap && HasStockObjects() && !IsGlobal())
    {
        CThemeServices::ClearStockObjects(_hMemoryMap);
    }

    if (_pbThemeData)
        UnmapViewOfFile(_pbThemeData);

    if (_hMemoryMap)
        CloseHandle(_hMemoryMap);

    Reset();
}
//---------------------------------------------------------------------------
void CUxThemeFile::Reset()
{
    _pbThemeData = NULL;
    _hMemoryMap = NULL;
}
//---------------------------------------------------------------------------
BOOL CUxThemeFile::ValidateObj()
{
    BOOL fValid = TRUE;

    //---- check object quickly ----
    if (   (! this)                         
        || (ULONGAT(_szHead) != 'fmht')     // "thmf"
        || (ULONGAT(&_szHead[4]) != 'eli')  // "ile" 
        || (ULONGAT(_szTail) != 'dne'))     // "end"
    {
        Log(LOG_ERROR, L"*** ERROR: Invalid CUxThemeFile Encountered, addr=0x%08x ****", this);
        fValid = FALSE;
    }

    return fValid;
}
//---------------------------------------------------------------------------

HANDLE CUxThemeFile::Unload()
{
    HANDLE handle = _hMemoryMap;

    if (_pbThemeData != NULL)
    {
        UnmapViewOfFile(_pbThemeData);
    }
    Reset();          // don't free handle
    return handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\textdraw.h ===
//---------------------------------------------------------------------------
//  TextDraw.h - implements the drawing API for text
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "wrapper.h"
//---------------------------------------------------------------------------
class CRenderObj;       // forward
//---------------------------------------------------------------------------
//    Note: draw objects like CBorderFill cannot have virtual methods
//          since they reside in the shared memory map file.
//---------------------------------------------------------------------------
class CTextDraw 
{
public:
    //---- methods ----
    HRESULT PackProperties(CRenderObj *pRender, int iPartId, int iStateId);
    
    static BOOL KeyProperty(int iPropId);
    
    void DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo);

    HRESULT DrawText(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
        DWORD dwCharCount, DWORD dwTextFlags, const RECT *pRect, const DTTOPTS *pOptions);

    HRESULT DrawEdge(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, const RECT *pDestRect, 
        UINT uEdge, UINT uFlags, OUT RECT *pContentRect);

    HRESULT GetTextExtent(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
        int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect);

    HRESULT GetTextMetrics(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, TEXTMETRIC* ptm);

public:
    //---- data ----

    //---- text ----
    COLORREF _crText;

    //---- edge ----
    COLORREF _crEdgeLight;
    COLORREF _crEdgeHighlight;
    COLORREF _crEdgeShadow;
    COLORREF _crEdgeDkShadow;
    COLORREF _crEdgeFill;

    //---- shadow ----
    POINT _ptShadowOffset;
    COLORREF _crShadow;
    TEXTSHADOWTYPE _eShadowType;

    //---- border ----
    int _iBorderSize;
    COLORREF _crBorder;

    //---- font ----
    LOGFONT _lfFont;
    BOOL _fHaveFont;

    //---- id ----
    int _iSourcePartId; 
    int _iSourceStateId;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\cctl1632.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\themeldr.cpp ===
//---------------------------------------------------------------------------
//  ThemeLdr.cpp - entrypoints for routines declared in ThemeLdr.h
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Services.h"
#include "ThemeServer.h"
#include "loader.h"
//---------------------------------------------------------------------------

//  --------------------------------------------------------------------------
//  InjectedThreadDispatcherExceptionFilter
//
//  Arguments:  pExceptionInfo  =   Exception that happened.
//
//  Returns:    LONG
//
//  Purpose:    Filters exceptions that occur when executing injected threads
//              into another process context to prevent the process from
//              terminating due to unforeseen exceptions.
//
//  History:    2000-10-13  vtan        created
//              2001-05-18  vtan        copied from theme service LPC
//  --------------------------------------------------------------------------

LONG    WINAPI  InjectedThreadExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo)

{
    (LONG)RtlUnhandledExceptionFilter(pExceptionInfo);
    return(EXCEPTION_EXECUTE_HANDLER);
}

//  --------------------------------------------------------------------------
//  ::SessionAllocate
//
//  Arguments:  hProcess                =   Winlogon process for the session.
//              dwServerChangeNumber    =   Server base change number.
//              pfnRegister             =   Address of register function.
//              pfnUnregister           =   Address of unregister function.
//
//  Returns:    void*
//
//  Purpose:    Allocates a CThemeServer object that contains information
//              for a theme session. Wrapped in try/except because of
//              critical section initialization.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void*       WINAPI  SessionAllocate (HANDLE hProcess, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit)

{
    CThemeServer    *pvContext;

    __try
    {
        pvContext = new CThemeServer(hProcess, dwServerChangeNumber, pfnRegister, pfnUnregister, pfnClearStockObjects, dwStackSizeReserve, dwStackSizeCommit);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pvContext = NULL;
    }
    return(pvContext);
}

//  --------------------------------------------------------------------------
//  ::SessionFree
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    <none>
//
//  Purpose:    Destroys the CThemeServer object when the session goes away.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        WINAPI  SessionFree (void *pvContext)

{
    delete static_cast<CThemeServer*>(pvContext);
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksOn
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ThemeHooksOn (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->ThemeHooksOn());
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksOff
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ThemeHooksOff (void *pvContext)

{
    (HRESULT)static_cast<CThemeServer*>(pvContext)->ThemeHooksOff();
    return(S_OK);
}

//  --------------------------------------------------------------------------
//  ::AreThemeHooksActive
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    BOOL
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        WINAPI  AreThemeHooksActive (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->AreThemeHooksActive());
}

//  --------------------------------------------------------------------------
//  ::GetCurrentChangeNumber
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    int
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int         WINAPI  GetCurrentChangeNumber (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->GetCurrentChangeNumber());
}

//  --------------------------------------------------------------------------
//  ::GetNewChangeNumber
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    int
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int         WINAPI  GetNewChangeNumber (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->GetNewChangeNumber());
}

//  --------------------------------------------------------------------------
//  ::SetGlobalTheme
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  SetGlobalTheme (void *pvContext, HANDLE hSection)

{
    return(static_cast<CThemeServer*>(pvContext)->SetGlobalTheme(hSection));
}

//  --------------------------------------------------------------------------
//  ::GetGlobalTheme
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  GetGlobalTheme (void *pvContext, HANDLE *phSection)

{
    return(static_cast<CThemeServer*>(pvContext)->GetGlobalTheme(phSection));
}

//  --------------------------------------------------------------------------
//  ::LoadTheme
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  LoadTheme (void *pvContext, HANDLE hSection, HANDLE *phSection, LPCWSTR pszName, LPCWSTR pszColor, LPCWSTR pszSize)

{
    return(static_cast<CThemeServer*>(pvContext)->LoadTheme(hSection, phSection, pszName, pszColor, pszSize));
}

//  --------------------------------------------------------------------------
//  ::InitUserTheme
//
//  Arguments:  BOOL 
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  InitUserTheme (BOOL fPolicyCheckOnly)

{
    return(CThemeServices::InitUserTheme(fPolicyCheckOnly));
}

//  --------------------------------------------------------------------------
//  ::InitUserRegistry
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-15  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  InitUserRegistry (void)

{
    return(CThemeServices::InitUserRegistry());
}

//  --------------------------------------------------------------------------
//  ::ReestablishServerConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ReestablishServerConnection (void)

{
    return(CThemeServices::ReestablishServerConnection());
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksInstall
//
//  Arguments:  pvContext   =   Unused.
//
//  Returns:    DWORD
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ThemeHooksInstall (void *pvContext)

{
    UNREFERENCED_PARAMETER(pvContext);

    DWORD   dwResult;

    __try
    {
        dwResult = CThemeServer::ThemeHooksInstall();
    }
    __except (InjectedThreadExceptionFilter(GetExceptionInformation()))
    {
        dwResult = 0;
    }
    ExitThread(dwResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksRemove
//
//  Arguments:  pvContext   =   Unused.
//
//  Returns:    DWORD
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ThemeHooksRemove (void *pvContext)

{
    UNREFERENCED_PARAMETER(pvContext);

    DWORD   dwResult;

    __try
    {
        dwResult = CThemeServer::ThemeHooksRemove();
    }
    __except (InjectedThreadExceptionFilter(GetExceptionInformation()))
    {
        dwResult = 0;
    }
    ExitThread(dwResult);
}

//  --------------------------------------------------------------------------
//  ::ServerClearStockObjects
//
//  Arguments:  pvContext   =   ptr to section
//
//  Returns:    <none>
//
//  Purpose:    Pass thru function.
//
//  History:    2001-05-01 rfernand        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ServerClearStockObjects (void *pvContext)

{
    DWORD   dwResult;

    __try
    {
        dwResult = CThemeServer::ClearStockObjects(HANDLE(pvContext));
    }
    __except (InjectedThreadExceptionFilter(GetExceptionInformation()))
    {
        dwResult = 0;
    }
    ExitThread(dwResult);
}

//---------------------------------------------------------------------------

//  --------------------------------------------------------------------------
//  ::ClearTheme
//
//  Arguments:  hSection    =   Theme section to clear.
//
//  Returns:    HRESULT
//              
//  Purpose:    Clears stock bitmaps in the theme section data and closes it.
//
//  History:    2000-11-21  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  ClearTheme (HANDLE hSection, BOOL fForce)

{
    HRESULT     hr;

    if (hSection != NULL)
    {
        hr = CThemeServices::ClearStockObjects(hSection, fForce);
    }
    else
    {
        hr = S_OK;
    }

    //---- always close the handle ----
    CloseHandle(hSection);

    return(hr);
}

//  --------------------------------------------------------------------------
//  ::MarkSection
//
//  Arguments:  hSection            =   Section to change
//              dwAdd, dwRemove     =   Flags to set or clear in the header. 
//                                      See loader.h.
//
//  Returns:    void
//
//  Purpose:    Update the global section state.
//
//  History:    2001-05-08  lmouton     created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  MarkSection (HANDLE hSection, DWORD dwAdd, DWORD dwRemove)

{
    Log(LOG_TMLOAD, L"MarkSection: Add %d and remove %d on %X", dwAdd, dwRemove, hSection);

    void *pV = MapViewOfFile(hSection,
                       FILE_MAP_WRITE,
                       0,
                       0,
                       0);
    if (pV != NULL)
    {
        THEMEHDR *hdr = reinterpret_cast<THEMEHDR*>(pV);

        // Do some validation
        if (0 == memcmp(hdr->szSignature, kszBeginCacheFileSignature, kcbBeginSignature)
            && hdr->dwVersion == THEMEDATA_VERSION)
        {
            // Only allow this flag for now
            if (dwRemove == SECTION_HASSTOCKOBJECTS)
            {
                Log(LOG_TMLOAD, L"MarkSection: Previous flags were %d", hdr->dwFlags);
                hdr->dwFlags &= ~dwRemove;
            }
        }
        UnmapViewOfFile(pV);
    }
#ifdef DEBUG
    else
    {
        Log(LOG_TMLOAD, L"MarkSection: Failed to open write handle for %X", hSection);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\themesection.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeSection.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that wraps CUxThemeFile. CUxThemeFile automatically closes the section
//  member variable handle. This makes usage of the class difficult because
//  it doesn't duplicate the handle but it takes ownership. It does declare
//  the handle as a PUBLIC member variable so we capitalize on this poor
//  design. This class wraps CUxThemeFile to make the life of users of this
//  class easier by not having them worry about closing the handles or not.
//  When you use this class the handle is NOT closed.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeSection_
#define     _ThemeSection_

#include "ThemeFile.h"

//  --------------------------------------------------------------------------
//  CThemeSection
//
//  Purpose:    Class that wraps CUxThemeFile and doesn't release the handle on
//              closure.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

class   CThemeSection
{
    public:
                    CThemeSection (void);
                    ~CThemeSection (void);

                    operator CUxThemeFile* (void);

        HRESULT     Open (HANDLE hSection);
        HRESULT     ValidateData (bool fFullCheck);
        HRESULT     CreateFromSection (HANDLE hSection);
        HANDLE      Get (void)  const;
    private:
        CUxThemeFile  _themeFile;
};

#endif  /*  _ThemeSection_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\themeserver.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServer.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Functions that implement server functionality.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeServer_
#define     _ThemeServer_

//  --------------------------------------------------------------------------
//  CThemeServer
//
//  Purpose:    Class to implement server related functions. Functions
//              declared in this class execute on the server side of themes.
//
//              This means they are restricted in what functions they can and
//              cannot call on the client's behalf. Any win32k functions that
//              are per instance of win32k cannot be called.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

class   CThemeServer
{
    private:
        enum
        {
            FunctionNothing                 =   0,
            FunctionRegisterUserApiHook,
            FunctionUnregisterUserApiHook,
            FunctionClearStockObjects
        };
    private:
                                    CThemeServer (void);
    public:
                                    CThemeServer (HANDLE hProcessRegisterHook, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit);
                                    ~CThemeServer (void);

                HRESULT             ThemeHooksOn (void);
                HRESULT             ThemeHooksOff (void);
                bool                AreThemeHooksActive (void);
                int                 GetCurrentChangeNumber (void);
                int                 GetNewChangeNumber (void);
                HRESULT             SetGlobalTheme (HANDLE hSection);
                HRESULT             GetGlobalTheme (HANDLE *phSection);
                HRESULT             LoadTheme (HANDLE hSection, HANDLE *phSection, LPCWSTR pszName, LPCWSTR pszColor, LPCWSTR pszSize);

        static  bool                IsSystemProcessContext (void);
        static  DWORD               ThemeHooksInstall (void);
        static  DWORD               ThemeHooksRemove (void);
        static  DWORD               ClearStockObjects (HANDLE hSection);
    private:
                void                LockAcquire (void);
                void                LockRelease (void);
                HRESULT             InjectClientSessionThread (HANDLE hProcess, int iIndexFunction, void *pvParam);
    private:
                HANDLE              _hProcessRegisterHook;
                DWORD               _dwServerChangeNumber;
                void*               _pfnRegister;
                void*               _pfnUnregister;
                void*               _pfnClearStockObjects;
                DWORD               _dwStackSizeReserve;
                DWORD               _dwStackSizeCommit;
                DWORD               _dwSessionID;
                bool                _fHostHooksSet;
                HANDLE              _hSectionGlobalTheme;
                DWORD               _dwClientChangeNumber;
                CRITICAL_SECTION    _lock;
};

#endif  /*  _ThemeLoader_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\dlgcbid.inc ===
; Callback-type id's for COMMDLG callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in COMDLG.EXE (dlgcb16.asm) and COMDLG32.DLL 
;   (dlgcb32.asm). Those tables *must* match these id's or callbacks 
;   will fail miserably. Do everyone a big favor and add new id's only 
;   at the end, and never change an existing id.
;   


CBID_OPENFILENAME	equ	(0 + (CBCID_COMMDLG SHL 16))
CBID_CHOOSEFONT		equ	(1 + (CBCID_COMMDLG SHL 16))
CBID_CHOOSECOLOR	equ	(2 + (CBCID_COMMDLG SHL 16))
CBID_PRINTDLG		equ	(3 + (CBCID_COMMDLG SHL 16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\themeserver.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServer.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Functions that implement server functionality. Functions in this file
//  cannot execute per instance win32k functions that are done on the client's
//  behalf. That work must be done on the client side.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "ThemeServer.h"

#include <shfolder.h>

#include "Loader.h"
#include "Signing.h"
#include "ThemeSection.h"
#include "TmUtils.h"
#include "sethook.h"
#include "log.h"

#include "services.h"
#include <UxThemeServer.h>

#define TBOOL(x)    ((BOOL)(x))
#define TW32(x)     ((DWORD)(x))
#define THR(x)      ((HRESULT)(x))
#define TSTATUS(x)  ((NTSTATUS)(x))
#define goto        !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CThemeServer::CThemeServer
//
//  Arguments:  hProcessRegisterHook    =   Process used to install hooks.
//              dwServerChangeNumber    =   Server change number.
//              pfnRegister             =   Address of install hook function.
//              pfnUnregister           =   Address of remove hook function.
//              pfnClearStockObjects    =   Address of function to remove stock objects from section
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeServer. Initializes member variables
//              with information relevant for the session. Keeps a handle to
//              the process that called this to use to inject threads in to
//              handle hook installation and removal.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

CThemeServer::CThemeServer (HANDLE hProcessRegisterHook, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit) :
    _hProcessRegisterHook(NULL),
    _dwServerChangeNumber(dwServerChangeNumber),
    _pfnRegister(pfnRegister),
    _pfnUnregister(pfnUnregister),
    _pfnClearStockObjects(pfnClearStockObjects),
    _dwStackSizeReserve(dwStackSizeReserve),
    _dwStackSizeCommit(dwStackSizeCommit),
    _dwSessionID(NtCurrentPeb()->SessionId),
    _fHostHooksSet(false),
    _hSectionGlobalTheme(NULL),
    _dwClientChangeNumber(0)

{
    ULONG                           ulReturnLength;
    PROCESS_SESSION_INFORMATION     processSessionInformation;

    InitializeCriticalSection(&_lock);
    TBOOL(DuplicateHandle(GetCurrentProcess(),
                          hProcessRegisterHook,
                          GetCurrentProcess(),
                          &_hProcessRegisterHook,
                          0,
                          FALSE,
                          DUPLICATE_SAME_ACCESS));
    if (NT_SUCCESS(NtQueryInformationProcess(hProcessRegisterHook,
                                             ProcessSessionInformation,
                                             &processSessionInformation,
                                             sizeof(processSessionInformation),
                                             &ulReturnLength)))
    {
        _dwSessionID = processSessionInformation.SessionId;
    }
}

//  --------------------------------------------------------------------------
//  CThemeServer::~CThemeServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeServer. Releases resources used.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

CThemeServer::~CThemeServer (void)

{
    //---- important: turn off hooks so everyone gets unthemed ----
    if (!GetSystemMetrics(SM_SHUTTINGDOWN)) // Don't do this on shutdown to keep winlogon themed
    {
        ThemeHooksOff();        
    }

    //---- mark global theme invalid & release it ----
    if (_hSectionGlobalTheme != NULL)
    {
        SetGlobalTheme(NULL);
    }

    if (_hProcessRegisterHook != NULL)
    {
        TBOOL(CloseHandle(_hProcessRegisterHook));
        _hProcessRegisterHook = NULL;
    }
    
    DeleteCriticalSection(&_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksOn
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Install theme hooks via the session controlling process.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::ThemeHooksOn (void)

{
    HRESULT     hr;

    LockAcquire();
    if (!_fHostHooksSet)
    {
        if (ClassicGetSystemMetrics(SM_CLEANBOOT) == 0)
        {
            if (_hProcessRegisterHook != NULL)
            {
                hr = InjectClientSessionThread(_hProcessRegisterHook, FunctionRegisterUserApiHook, NULL);
                _fHostHooksSet = SUCCEEDED(hr);
            }
            else
            {
                hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
            }
        }
        else
        {
            hr = MakeError32(ERROR_BAD_ENVIRONMENT);        // themes not allowed in safe mode
        }
    }
    else
    {
        hr = S_OK;
    }
    LockRelease();
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksOff
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Remove theme hooks via the session controlling process.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::ThemeHooksOff (void)

{
    LockAcquire();
    if (_fHostHooksSet)
    {
        _fHostHooksSet = false;
        if (_hProcessRegisterHook != NULL)
        {
            THR(InjectClientSessionThread(_hProcessRegisterHook, FunctionUnregisterUserApiHook, NULL));
        }
    }
    LockRelease();
    return(S_OK);
}

//  --------------------------------------------------------------------------
//  CThemeServer::AreThemeHooksActive
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether theme hooks have been successfully installed.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeServer::AreThemeHooksActive (void)

{
    bool    fResult;

    LockAcquire();
    fResult = _fHostHooksSet;
    LockRelease();
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CThemeServer::GetCurrentChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns the current change number.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

int     CThemeServer::GetCurrentChangeNumber (void)

{
    int     iCurrentChangeNumber;

    LockAcquire();
    iCurrentChangeNumber = static_cast<int>((_dwServerChangeNumber << 16) | _dwClientChangeNumber);
    LockRelease();

    Log(LOG_TMCHANGE, L"GetCurrentChangeNumber: server: %d, client: %d, change: 0x%x", 
        _dwServerChangeNumber, _dwClientChangeNumber, iCurrentChangeNumber);

    return(iCurrentChangeNumber);
}

//  --------------------------------------------------------------------------
//  CThemeServer::GetNewChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns a new change number.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

int     CThemeServer::GetNewChangeNumber (void)

{
    int     iCurrentChangeNumber;

    LockAcquire();

    _dwClientChangeNumber = static_cast<WORD>(_dwClientChangeNumber + 1);
    iCurrentChangeNumber = static_cast<int>((_dwServerChangeNumber << 16) | _dwClientChangeNumber);

    Log(LOG_TMLOAD, L"GetNewChangeNumber: server: %d, client: %d, change: 0x%x", 
        _dwServerChangeNumber, _dwClientChangeNumber, iCurrentChangeNumber);

    LockRelease();
    return(iCurrentChangeNumber);
}

//  --------------------------------------------------------------------------
//  CThemeServer::SetGlobalTheme
//
//  Arguments:  hSection    =   Handle to section of new theme.
//
//  Returns:    HRESULT
//
//  Purpose:    Invalidates the old section and closes the handle to it.
//              Validates the new section and if valid sets it as the global
//              theme.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::SetGlobalTheme (HANDLE hSection)

{
    HRESULT     hr;

    LockAcquire();
    if (_hSectionGlobalTheme != NULL)
    {
        void    *pV;
        HANDLE hSemaphore = NULL;

        //  Before closing the section invalidate it.

        pV = MapViewOfFile(_hSectionGlobalTheme,
                           FILE_MAP_WRITE,
                           0,
                           0,
                           0);
        if (pV != NULL)
        {
            // Create a semaphore so that nobody will try to clean it before us, which would result in a double free
            // (as soon as we clear SECTION_GLOBAL, various CUxThemeFile destructors can call ClearStockObjects)
            WCHAR szName[64];

            wsprintf(szName, L"Global\\ClearStockGlobal%d-%d", reinterpret_cast<THEMEHDR*>(pV)->iLoadId, _dwSessionID);
            hSemaphore = CreateSemaphore(NULL, 0, 1, szName);

            Log(LOG_TMLOAD, L"SetGlobalTheme clearing section %d, semaphore=%s, hSemaphore=%X, gle=%d", reinterpret_cast<THEMEHDR*>(pV)->iLoadId, szName, hSemaphore, GetLastError());
            reinterpret_cast<THEMEHDR*>(pV)->dwFlags &= ~(SECTION_READY | SECTION_GLOBAL);
        }

#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        // Unexpected failure
        ASSERT(pV != NULL);
    }
#endif
        HANDLE hSectionForInjection = NULL;

        //---- create a handle for CLIENT process to use to clear stock bitmaps ----
        if (DuplicateHandle(GetCurrentProcess(),
                        _hSectionGlobalTheme,
                        _hProcessRegisterHook,
                        &hSectionForInjection,
                        FILE_MAP_READ,
                        FALSE,
                        0) != FALSE)
        {
            // This will close the handle
            THR(InjectClientSessionThread(_hProcessRegisterHook, FunctionClearStockObjects, hSectionForInjection));
        }

        if (pV != NULL)
        {
            reinterpret_cast<THEMEHDR*>(pV)->dwFlags &= ~SECTION_HASSTOCKOBJECTS;
            
            if (hSemaphore != NULL)
            {
                CloseHandle(hSemaphore);
            }

            TBOOL(UnmapViewOfFile(pV));
        }

        TBOOL(CloseHandle(_hSectionGlobalTheme));
        _hSectionGlobalTheme = NULL;
    }
    if (hSection != NULL)
    {
        CThemeSection   themeSection;

        hr = themeSection.Open(hSection);
        if (SUCCEEDED(hr))
        {
            hr = themeSection.ValidateData(true);
        }
        if (SUCCEEDED(hr))
        {
            if (DuplicateHandle(GetCurrentProcess(),
                                hSection,
                                GetCurrentProcess(),
                                &_hSectionGlobalTheme,
                                FILE_MAP_ALL_ACCESS,
                                FALSE,
                                0) != FALSE)
            {
                hr = S_OK;

            }
            else
            {
                hr = MakeErrorLast();
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        //---- bump the change number at the same time so everything is in sync. ----
        int iChangeNum = GetNewChangeNumber();

        if (_hSectionGlobalTheme)
        {
            //---- put changenum into theme hdr to help client keep things straight ----
            VOID *pv = MapViewOfFile(_hSectionGlobalTheme,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0);
            if (pv != NULL)
            {
                reinterpret_cast<THEMEHDR*>(pv)->dwFlags |= SECTION_GLOBAL;
                reinterpret_cast<THEMEHDR*>(pv)->iLoadId = iChangeNum;
                Log(LOG_TMLOAD, L"SetGlobalTheme: new section is %d", reinterpret_cast<THEMEHDR*>(pv)->iLoadId);
                TBOOL(UnmapViewOfFile(pv));
            }
        }
    }
    
    LockRelease();
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::GetGlobalTheme
//
//  Arguments:  phSection   =   Handle to the section received.
//
//  Returns:    HRESULT
//
//  Purpose:    Duplicates the section back to the caller.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::GetGlobalTheme (HANDLE *phSection)

{
    HRESULT     hr;

    LockAcquire();
    *phSection = NULL;
    if (_hSectionGlobalTheme != NULL)
    {
        if (DuplicateHandle(GetCurrentProcess(),
                            _hSectionGlobalTheme,
                            GetCurrentProcess(),
                            phSection,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            hr = S_OK;
        }
        else
        {
            hr = MakeErrorLast();
        }
    }
    else
    {
        hr = S_OK;
    }
    LockRelease();
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::LoadTheme
//
//  Arguments:  hSection    =   Section created by the client.
//              phSection   =   Section created by the server returned.
//              pszName     =   Theme name.
//              pszColor    =   Theme size.
//              pszSize     =   Theme color.
//
//  Returns:    HRESULT
//
//  Purpose:    Creates a new section in the server context based on the
//              section from the client. The contents are transferred across.
//              The section contents are also strictly verified.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::LoadTheme (HANDLE hSection, HANDLE *phSection, LPCWSTR pszName, LPCWSTR pszColor, LPCWSTR pszSize)

{
    HRESULT     hr;

    hr = CheckThemeSignature(pszName);          //  Check this is signed
    if (SUCCEEDED(hr))
    {
        CThemeSection   themeSectionIn;

        if (SUCCEEDED(themeSectionIn.Open(hSection)))
        {
            if (ThemeMatch(themeSectionIn, pszName, pszColor, pszSize, 0) != FALSE)
            {
                hr = themeSectionIn.ValidateData(true);
                if (SUCCEEDED(hr))
                {
                    CThemeSection   themeSectionOut;

                    // Note: we come here impersonating the user, we need for ThemeMatch.
                    // However the theme section must be created in the system context, so that only
                    // the system context has write access to it. We revert to self here based on the
                    // knowledge that nothing after this call needs to be done in the user context.
                    RevertToSelf();
                    hr = themeSectionOut.CreateFromSection(hSection);
                    if (SUCCEEDED(hr))
                    {
                        *phSection = themeSectionOut.Get();     //  We now own the handle
                    }
                }
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::IsSystemProcessContext
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Is the current process executing in the SYSTEM context?
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeServer::IsSystemProcessContext (void)

{
    bool    fResult;
    HANDLE  hToken;

    fResult = false;
    if (OpenProcessToken(GetCurrentProcess(),
                         TOKEN_QUERY,
                         &hToken) != FALSE)
    {
        static  const LUID  sLUIDSystem     =   SYSTEM_LUID;

        ULONG               ulReturnLength;
        TOKEN_STATISTICS    tokenStatistics;

        fResult = ((GetTokenInformation(hToken,
                                        TokenStatistics,
                                        &tokenStatistics,
                                        sizeof(tokenStatistics),
                                        &ulReturnLength) != FALSE) &&
                   RtlEqualLuid(&tokenStatistics.AuthenticationId, &sLUIDSystem));
        TBOOL(CloseHandle(hToken));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksInstall
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Thread entry point for injected thread running in session
//              creating process' context to call user32!RegisterUserApiHook.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThemeServer::ThemeHooksInstall (void)

{
    DWORD   dwErrorCode;

    if (IsSystemProcessContext())
    {
        INITUSERAPIHOOK pfnInitUserApiHook = ThemeInitApiHook;

        if (RegisterUserApiHook(g_hInst, pfnInitUserApiHook) != FALSE)
        {

            dwErrorCode = ERROR_SUCCESS;
        }
        else
        {
            dwErrorCode = GetLastError();
        }
    }
    else
    {
        dwErrorCode = ERROR_ACCESS_DENIED;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksRemove
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Thread entry point for injected thread running in session
//              creating process' context to call
//              user32!UnregisterUserApiHook.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThemeServer::ThemeHooksRemove (void)

{
    DWORD   dwErrorCode;

    if (IsSystemProcessContext())
    {
        if (UnregisterUserApiHook() != FALSE)
        {
            dwErrorCode = ERROR_SUCCESS;

            Log(LOG_TMLOAD, L"UnregisterUserApiHook() called");
        }
        else
        {
            dwErrorCode = GetLastError();
        }

    }
    else
    {
        dwErrorCode = ERROR_ACCESS_DENIED;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ClearStockObjects
//
//  Arguments:  HANDLE hSection
//
//  Returns:    DWORD
//
//  Purpose:    Thread entry point for injected thread running in session
//              creating process' context to clear stock objects in theme
//              section.
//           
//
//  History:    2001-05-01  rfernand        created
//  --------------------------------------------------------------------------

DWORD   CThemeServer::ClearStockObjects (HANDLE hSection)

{
    DWORD   dwErrorCode = ERROR_SUCCESS;

    if (IsSystemProcessContext())
    {
        if (hSection)
        {
            //---- Clearing the stock bitmaps in the section ----
            //---- is OK here since we are running in the context ----
            //---- of the current USER session ----

            HRESULT hr = ClearTheme(hSection, TRUE);
            if (FAILED(hr))
            {
                Log(LOG_ALWAYS, L"ClearTheme() failed, hr=0x%x", hr);
                hr = S_OK;      // not a fatal error
            }
        }
    }
    else
    {
        dwErrorCode = ERROR_ACCESS_DENIED;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CThemeServer::LockAcquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquires the object critical section.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServer::LockAcquire (void)

{
    EnterCriticalSection(&_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServer::LockRelease
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the object critical section.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServer::LockRelease (void)

{
    LeaveCriticalSection(&_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServer::InjectClientSessionThread
//
//  Arguments:  hProcess        =   Handle to process to inject thread in.
//              iIndexFunction  =   Function to call on injected thread.
//              pvParam         =   Ptr to param for entry function
//
//  Returns:    HRESULT
//
//  Purpose:    Create a user mode thread in the remote process (possibly
//              across sessions) and execute the entry point specified at
//              object construction which is valid in the remote process
//              context. Wait for the thread to finish. It will signal its
//              success of failure in the exit code.
//
//  History:    2000-11-11  vtan        created
//              2001-05-18  vtan        generic function index
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::InjectClientSessionThread (HANDLE hProcess, int iIndexFunction, void *pvParam)

{
    HRESULT                     hr;
    PUSER_THREAD_START_ROUTINE  pfnThreadStart;

    switch (iIndexFunction)
    {
        case FunctionRegisterUserApiHook:
            pfnThreadStart = reinterpret_cast<PUSER_THREAD_START_ROUTINE>(_pfnRegister);
            break;
        case FunctionUnregisterUserApiHook:
            pfnThreadStart = reinterpret_cast<PUSER_THREAD_START_ROUTINE>(_pfnUnregister);
            break;
        case FunctionClearStockObjects:
            pfnThreadStart = reinterpret_cast<PUSER_THREAD_START_ROUTINE>(_pfnClearStockObjects);
            break;
        default:
            pfnThreadStart = NULL;
            break;
    }
    if (pfnThreadStart != NULL)
    {
        NTSTATUS    status;
        HANDLE      hThread;

        status = RtlCreateUserThread(hProcess,
                                     NULL,
                                     FALSE,
                                     0,
                                     _dwStackSizeReserve,
                                     _dwStackSizeCommit,
                                     pfnThreadStart,
                                     pvParam,
                                     &hThread,
                                     NULL);
        if (NT_SUCCESS(status))
        {
            DWORD   dwWaitResult, dwExitCode;

            dwWaitResult = WaitForSingleObject(hThread, INFINITE);
            if (GetExitCodeThread(hThread, &dwExitCode) != FALSE)
            {
                hr = HRESULT_FROM_WIN32(dwExitCode);
            }
            else
            {
                hr = E_FAIL;
            }
            TBOOL(CloseHandle(hThread));
        }
        else
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\shl1632.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\themesection.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeSection.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that wraps CUxThemeFile. CUxThemeFile automatically closes the section
//  member variable handle. This makes usage of the class difficult because
//  it doesn't duplicate the handle but it takes ownership. It does declare
//  the handle as a PUBLIC member variable so we capitalize on this poor
//  design. This class wraps CUxThemeFile to make the life of users of this
//  class easier by not having them worry about closing the handles or not.
//  When you use this class the handle is NOT closed.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "ThemeSection.h"

#define goto        !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CThemeSection::CThemeSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeSection.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

CThemeSection::CThemeSection (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeSection::~CThemeSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeSection. This is TOTALLY BOGUS having to
//              set an internal member variable contents to NULL to prevent
//              it from releasing resources but the rest of the code relies
//              on the auto-release behavior without duplication of the
//              handle. This is done to protect this class from that hassle.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

CThemeSection::~CThemeSection (void)

{
    _themeFile._hMemoryMap = NULL;
}

//  --------------------------------------------------------------------------
//  CThemeSection::operator CUxThemeFile*
//
//  Arguments:  <none>
//
//  Returns:    CUxThemeFile*
//
//  Purpose:    Automagic operator to convert from CThemeSection to
//              CUxThemeFile* which keeps current usage transparent.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

CThemeSection::operator CUxThemeFile* (void)

{
    return(&_themeFile);
}

//  --------------------------------------------------------------------------
//  CThemeSection::Open
//
//  Arguments:  hSection    =   Section to use.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru to CUxThemeFile::OpenFile.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeSection::Open (HANDLE hSection)

{
    return(_themeFile.OpenFromHandle(hSection));
}

//  --------------------------------------------------------------------------
//  CThemeSection::ValidateData
//
//  Arguments:  fFullCheck  =   Perform a full check?
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru to CUxThemeFile::ValidateThemeData.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeSection::ValidateData (bool fFullCheck)

{
    return(_themeFile.ValidateThemeData(fFullCheck));
}

//  --------------------------------------------------------------------------
//  CThemeSection::CreateFromSection
//
//  Arguments:  hSection    =   Section to duplicate.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru to CUxThemeFile::CreateFromSection.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeSection::CreateFromSection (HANDLE hSection)
{
    return(_themeFile.CreateFromSection(hSection));
}

//  --------------------------------------------------------------------------
//  CThemeSection::Get
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the handle of the CUxThemeFile object. Because this
//              class always NULLs out the handle it will get leaked. Once
//              this handle is returned the caller owns the handle. 
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HANDLE      CThemeSection::Get (void)  const

{
    return(_themeFile._hMemoryMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\dlgthk.inc ===
CodeData equ <THUNK16BCodeData>

include     thkframe.inc
include     thkrp.inc
include     cbcheck.inc
include     public.inc

include     cbcid.inc
include     dlgcbid.inc

externDef FreeCallback:far16
externDef AllocCallback:far16
externDef ConvertDevModeHandleSL:far16
externDef ConvertDevNamesHandleSL:far16
externDef ConvertDevModeHandleLS:far16
externDef ConvertDevNamesHandleLS:far16


fLocalFlag      equ     fDlgLog16

; note: following size should be the same as in thunkcom\pack.h

OPENFILENAME16_SIZE         EQU  72
OPENFILENAME32_SIZE         EQU  76     ;4Ch
CHOOSECOLOR16_SIZE          EQU  32
CHOOSECOLOR32_SIZE          EQU  36     ;24h
CHOOSEFONT16_SIZE           EQU  46
CHOOSEFONT32_SIZE           EQU  60     ;3Ch
PRINTDLG16_SIZE             EQU  52
PRINTDLG32_SIZE             EQU  66     ;42h

LOGFONT16_SIZE              EQU  50

OFN16_Flags_OFFSET          EQU  48     ;30h 
CC16_rgbResult_OFFSET       EQU   8     ;08h
CF16_iPointSize_OFFSET      EQU  12     ;0Ch
CF16_Flags_OFFSET           EQU  14     ;0Dh
CF16_rgbColors_OFFSET       EQU  18     ;12h
CF16_nFontType_OFFSET       EQU  40     ;28h
PD16_hDevMode_OFFSET        EQU   6     ;06h
PD16_hDevNames_OFFSET       EQU   8     ;08h

OFN32_Flags_OFFSET          EQU  52     ;34h
OFN32_lpfnHook_OFFSET       EQU  68     ;44h
CC32_rgbResult_OFFSET       EQU  12     ;0Ch
CC32_Flags_OFFSET           EQU  20     ;14h
CC32_lpfnHook_OFFSET        EQU  28     ;1Ch
FR32_Flags_OFFSET           EQU  12     ;0CH
FR32_lpfnHook_OFFSET        EQU  32     ;20h
CF32_lpLogFont_OFFSET       EQU  12     ;0Ch
CF32_iPointSize_OFFSET      EQU  16     ;10h
CF32_Flags_OFFSET           EQU  20     ;14h
CF32_rgbColors_OFFSET       EQU  24     ;18h
CF32_lpfnHook_OFFSET        EQU  32     ;20h
CF32_nFontType_OFFSET       EQU  48     ;30h
PD32_Flags_OFFSET           EQU  20     ;1Ch
PD32_hDevMode_OFFSET        EQU   8     ;08h
PD32_hDevNames_OFFSET       EQU  12     ;0Ch
PD32_lpfnPrintHook_OFFSET   EQU  42     ;2Ah
PD32_lpfnSetupHook_OFFSET   EQU  46     ;2Eh


;---------------------------------------------------------------------------
; This macro does the work for GetOpenFilename() and GetSaveFilename().
; The argument "Flags" is a dword ptr expression denoting a thunk-compiler
; temporary that holds the Flags field of the OPENFILENAME struct.
;
; Assumption: If the hInst field is a global handle, the Win32 wrapper
; guaratees it's a (zero-extended) Win16 handle.
;---------------------------------------------------------------------------
RAWPACK__THKGETOPENORSAVEFILENAME_lpOfn    macro    iOffset,iTempOffset,Flags
    local   skip_it
    local    nohook,hook_done
    local    notemplate,template_done

    sub     sp,OPENFILENAME16_SIZE        ; alloc space for MapLS sels
    sub     sp,OPENFILENAME16_SIZE          ; alloc space on stack

    mov     eax,[bp+iOffset]             ; base address
    or      eax,eax                         ; check structure pointer
    jz      skip_it                         ; skip if null

    mov     [bp-iTempOffset],sp          ; save offset to buffer
    mov     [bp-iTempOffset+2],ss        ; save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp                          ; es:edi == destination address

    mov     esi,eax
    mov     ds,cs:CodeData                  ; need access to FlatData
    mov     ds,FlatData                     ; ds:esi == source address

    mov    eax,ds:[esi + OFN32_Flags_OFFSET]
    mov    Flags,eax

    cld


    lodsd   ds:[esi]              ;BUGBUG lStructSize should be checked here
    mov     eax,OPENFILENAME16_SIZE         ;sizeof(OPENFILENAME16)
    stosd   es:[edi]              ;lStructSize same size

; comments refer to action going 16->32

    ;hwndOwner
    copyt

    mov     ecx,Flags
    and     ecx,OFN_ENABLETEMPLATE
    lodsd   ds:[esi]        ;hInst
    MAP_CD_NULL_HINST    eax,ecx
    stosw   es:[edi]

    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrFilter
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrCustomFilter
    ncopyd  2                               ;nMaxCustFilter,nFilterIndex
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrFile
    copyd                                   ;nMaxFile
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrFileTitle
    copyd                                   ;nMaxFileTitle
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrInitialDir
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrTitle
    copyd                                   ;Flags
    ncopyw  2                               ;nFileOffset,nFileExtension
    MAP_POINTER  es:[di+OPENFILENAME16_SIZE];PLUGGED lpstrDefExt
    copyd                                   ;lCustData

    test    Flags,OFN_ENABLEHOOK
    jz      nohook
    MAP_CALLBACK CBID_OPENFILENAME           ;PLUGGED lpfnHook
    jmp     short hook_done
nohook:
    copyd
hook_done:

    ;lpTemplate must be mapped only if OFN_ENABLETEMPLATE is set
    xor     eax,eax
    mov     es:[di+OPENFILENAME16_SIZE],eax  ;in case we skip mapping
    test    Flags, OFN_ENABLETEMPLATE         ; if OFN_ENABLETEMPLATE is set
    jz      notemplate
    MAP_POINTER  es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpTemplateName
    jmp     short template_done
notemplate:
    copyd                       ;lpTemplate
template_done:
skip_it:
endm

RAWUNPACK__THKGETOPENORSAVEFILENAME_lpOfn macro    iOffset,iTempOffset,Flags
    local   skip_it
    local    nohook,hook_done
    local    notemplate,template_done

    mov     eax,[bp+iOffset]              ; base address
    or      eax,eax                          ; check structure pointer
    jz      skip_it                          ; skip if null

    mov     es,cs:CodeData
    mov     es,es:FlatData
    mov     edi,eax                          ; source in es:edi

    push    ds
    lds     si,[bp-iTempOffset]
    movzx   esi,si            ;in case code uses esi by accident

    cld

    lods    dword ptr ds:[si]               ;BUGBUG lStructSize should be checked here
    mov     eax,OPENFILENAME32_SIZE         ;sizeof(OPENFILENAME32)
    stos    dword ptr es:[edi]              ;lStructSize same size

; comments refer to action going 16->32

    copyzx
    mov     ecx,Flags
    and     ecx,OFN_ENABLETEMPLATE
    lodsw   ds:[si]         ;hInst
    UMAP_CD_NULL_HINST    ax,ecx
    stosd   es:[edi]
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrFilter must be mapped
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrCustomFilter must be mapped
    ncopyd  2
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrFile must be mapped
    copyd
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrFileTitle must be mapped
    copyd
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrInitialDir must be mapped
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrTitle must be mapped
    copyd
    ncopyw  2
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrDefExt must be mapped
    copyd

    test    Flags,OFN_ENABLEHOOK
    jz      nohook
    lodsd   ds:[si]
    FREE_CALLBACK  CBID_OPENFILENAME
    stos    dword ptr es:[edi]
    jmp     short hook_done
nohook:
    copyd
hook_done:

    test    Flags,OFN_ENABLETEMPLATE
    jz      notemplate
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpTemplateName must be mapped
    jmp     short template_done
notemplate:
    copyd
template_done:

    pop     ds
skip_it:

endm



;-----------------------------------------------------------------------------
; Pack/unpack OPENFILENAME struct for GetOpenFilename().
;-----------------------------------------------------------------------------
RAWPACK__THKGETOPENFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWPACK__THKGETOPENORSAVEFILENAME_lpOfn    iOffset,iTempOffset,dword ptr LOCAL__THKGETOPENFILENAME_Flags
endm

RAWUNPACK__THKGETOPENFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWUNPACK__THKGETOPENORSAVEFILENAME_lpOfn iOffset,iTempOffset,dword ptr LOCAL__THKGETOPENFILENAME_Flags
endm



;-----------------------------------------------------------------------------
; Pack/unpack OPENFILENAME struct for GetSaveFilename().
;-----------------------------------------------------------------------------
RAWPACK__THKGETSAVEFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWPACK__THKGETOPENORSAVEFILENAME_lpOfn    iOffset,iTempOffset,dword ptr LOCAL__THKGETSAVEFILENAME_Flags
endm

RAWUNPACK__THKGETSAVEFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWUNPACK__THKGETOPENORSAVEFILENAME_lpOfn iOffset,iTempOffset,dword ptr LOCAL__THKGETSAVEFILENAME_Flags
endm



;-----------------------------------------------------------------------------
; Pack CHOOSECOLOR struct for ChooseColor().
;
; Assumption: If the hInst field is a global handle, the Win32 wrapper
; guaratees it's a (zero-extended) Win16 handle.
;-----------------------------------------------------------------------------
RAWPACK__THKCHOOSECOLOR_lpcc        macro    iOffset,iTempOffset
    local        nohook,hook_done
    local        notemplate,template_done
    local        skip_it
    
    sub     sp,CHOOSECOLOR16_SIZE    ;Alloc space on stack

    mov     eax,[bp+iOffset]
    or      eax,eax
    jz      skip_it
    
    mov     [bp-iTempOffset],sp    ;Save offset to buffer
    mov     [bp-iTempOffset+2],ss    ;Save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp

    mov     esi,eax
    mov     ds,cs:CodeData
    mov     ds,FlatData

    mov     eax,ds:[esi + CC32_Flags_OFFSET]
    mov     LOCAL__THKCHOOSECOLOR_Flags,eax

    lodsd   ds:[esi]
    mov     eax,CHOOSECOLOR16_SIZE
    stosd   es:[di]    ;lStructSize

    ;hwndOwner
    copyt

    ;hInstance
    mov     ecx,LOCAL__THKCHOOSECOLOR_Flags
    and     ecx,CC_ENABLETEMPLATE
    lodsd   ds:[esi]    ;hInst
    MAP_CD_NULL_HINST    eax,ecx
    stosw   es:[di]

    ;rgbResult
    copyd

    MAP_POINTER    LOCAL__THKCHOOSECOLOR_lpCustColorsSeg  ;PLUGGED lpCustColors

    ;Flags, lCustData
    ncopyd  2

; Map hook function (only do the mapping if CC_ENABLEHOOK flag set).
    mov     eax,LOCAL__THKCHOOSECOLOR_Flags
    test    eax,CC_ENABLEHOOK
    jz      nohook
    MAP_CALLBACK    CBID_CHOOSECOLOR  ;PLUGGED lpfnHook
    jmp     short hook_done
nohook:
    copyd
hook_done:

; Map template name (only if CC_ENABLETEMPLATE flag set).
    mov     eax,LOCAL__THKCHOOSECOLOR_Flags
    test    eax,CC_ENABLETEMPLATE
    jz      notemplate
    MAP_POINTER    LOCAL__THKCHOOSECOLOR_lpTemplateNameSeg ;PLUGGED
    jmp     short template_done    ;lpTemplate
notemplate:
    copyd
template_done:
;  Finished

skip_it:
endm

;-----------------------------------------------------------------------------
; Unpack CHOOSECOLOR struct for ChooseColor().
;-----------------------------------------------------------------------------
RAWUNPACK__THKCHOOSECOLOR_lpcc    macro    iOffset,iTempOffset
    local   skip_it
    local    nohook

    mov     eax,[bp+iOffset]              ; base address
    or      eax,eax                          ; check structure pointer
    jz      skip_it                          ; skip if null

    mov     es,cs:CodeData
    mov     es,es:FlatData
    mov     edi,eax                          ; source in es:edi

; Free callback (if CC_ENABLEHOOK flag set).
    mov    eax,LOCAL__THKCHOOSECOLOR_Flags
    test    eax,CC_ENABLEHOOK
    jz    nohook
    mov     eax,es:[edi+CC32_lpfnHook_OFFSET]
    FREE_CALLBACK   CBID_CHOOSECOLOR
nohook:

; Propagate copy-outs field back to caller's struct.
    mov     si, [bp-iTempOffset]
    mov     eax,ss:[si+CC16_rgbResult_OFFSET]
    mov     es:[edi+CC32_rgbResult_OFFSET], eax

; Free up selectors (if no mapping happened, UnmapLS safely ignores
; NULL segments).
    pushd    LOCAL__THKCHOOSECOLOR_lpCustColorsSeg
    call    UnmapLS
    pushd    LOCAL__THKCHOOSECOLOR_lpTemplateNameSeg
    call    UnmapLS
skip_it:

endm




;-----------------------------------------------------------------------------
; Pack/unpack CHOOSEFONT struct for ChooseFont().
;
; Assumption: If the hInst field is a global handle, the Win32 wrapper
; guaratees it's a (zero-extended) Win16 handle.
;-----------------------------------------------------------------------------
RAWPACK__THKCHOOSEFONT_lpcf        macro    iOffset,iTempOffset
    local   skip_it
    local    nohook,hook_done
    local    notemplate,template_done
    local   no_log_font

    sub     sp,CHOOSEFONT16_SIZE+LOGFONT16_SIZE  ; alloc space on stack

    mov     eax,[bp+iOffset]             ; base address
    or      eax,eax                         ; check structure pointer
    jz      skip_it                         ; skip if null

    mov     [bp-iTempOffset],sp          ; save offset to buffer
    mov     [bp-iTempOffset+2],ss        ; save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp                          ; es:edi == destination address

    mov     esi,eax
    mov     ds,cs:CodeData                  ; need access to FlatData
    mov     ds,FlatData                     ; ds:esi == source address

    mov     eax,ds:[esi + CF32_Flags_OFFSET]
    mov     LOCAL__THKCHOOSEFONT_Flags,eax


    cld

; comments refer to action going 16->32

    lodsd   ds:[esi]              ;BUGBUG lStructSize should be checked here
    mov     eax,CHOOSEFONT16_SIZE           ;sizeof(CHOOSEFONT16)
    stosd   es:[di]                         ;lStructSize same size

    ;hwndOwner, hDC
    ncopyt  2

    lodsd   ds:[esi]
    or      eax,eax
    jz      no_log_font

    mov     ax,ss
    ror     eax,16
    mov     ax,di
    add     ax,CHOOSEFONT16_SIZE-8          ;already moved DI by 8

no_log_font:
    stosd   es:[di]                         ;lpLogFont widened (need to pack it)

    ;iPointSize
    copyt

    ;Flags, rgbColors, lCustData
    ncopyd  3
    
    test    dword ptr LOCAL__THKCHOOSEFONT_Flags,CF_ENABLEHOOK
    jz      nohook
    MAP_CALLBACK CBID_CHOOSEFONT            ;PLUGGED lpfnHook
    jmp     short hook_done
nohook:
    copyd
hook_done:

    test    dword ptr LOCAL__THKCHOOSEFONT_Flags,CF_ENABLETEMPLATE
    jz      notemplate
    MAP_POINTER  LOCAL__THKCHOOSEFONT_lpTemplateNameTemp  ;PLUGGED
    jmp     short template_done
notemplate:
    copyd
template_done:

    mov     ecx,LOCAL__THKCHOOSEFONT_Flags
    and     ecx,CF_ENABLETEMPLATE
    lodsd   ds:[esi]    ;hInst
    MAP_CD_NULL_HINST    eax,ecx
    stosw   es:[di]

    ;lpszStyle must be mapped
    MAP_POINTER LOCAL__THKCHOOSEFONT_lpszStyleTemp  ;PLUGGED

    ;nFontType, nSizeMin, nSizeMax
    ncopyt  3

    mov     esi,[bp+iOffset]             ; base address
    mov     esi,[esi].CF32_lpLogFont_OFFSET ; ds:esi == source address
    or      esi,esi                         ; check structure pointer
    jz      skip_it                         ; skip if null

    cld

; comments refer to action going 16->32

    ;lfHeight, lfWidth, lfEscapement, lfOrientation, lfWeight
    ncopyt  5

    ;lfItalic, ..., lfFaceName 
    ncopyd  (40/4)
skip_it:
endm

RAWUNPACK__THKCHOOSEFONT_lpcf        macro    iOffset,iTempOffset
    local   skip_it
    local    nohook

;!!! We're only unpacking the log font structure!  Does the rest of
;    the CHOOSEFONT structure need to be unpacked as well?

    mov     eax,[bp+iOffset]              ; base address
    or      eax,eax                          ; check structure pointer
    jz      skip_it                          ; skip if null

    

    mov     es,cs:CodeData
    mov     es,es:FlatData
    mov     edi,eax                          ; dest in es:edi

    test    dword ptr LOCAL__THKCHOOSEFONT_Flags,CF_ENABLEHOOK
    jz    nohook
    mov     eax,es:[edi+CF32_lpfnHook_OFFSET]
    FREE_CALLBACK   CBID_CHOOSEFONT
nohook:

;; The iPointSize, rgbColors, Flags & nFontType fields need to be copied back
;; to the caller's buffer.

    lds     si,dword ptr [bp-iTempOffset]
    movzx   esi,si

    mov     eax,[si+CF16_rgbColors_OFFSET]	; rgbColors
    mov     es:[edi+CF32_rgbColors_OFFSET],eax

    mov     ax,[si+CF16_iPointSize_OFFSET]	; iPointSize
    movsx   eax,ax
    mov     es:[edi+CF32_iPointSize_OFFSET],eax

    mov     eax,[si+CF16_Flags_OFFSET]		; Flags
    mov     es:[edi+CF32_Flags_OFFSET],eax

    mov     ax,[si+CF16_nFontType_OFFSET]	; nFontType
    movzx   eax,ax
    mov     es:[edi+CF32_nFontType_OFFSET],eax

    mov     edi,es:[edi+CF32_lpLogFont_OFFSET]
    or      edi,edi
    jz      skip_it

    add     si,CHOOSEFONT16_SIZE

; comments refer to action going 16->32

    cld

    ncopysx 5
    ncopyd  (40/4)

skip_it:
    pushd    LOCAL__THKCHOOSEFONT_lpszStyleTemp
    call    UnmapLS
    pushd    LOCAL__THKCHOOSEFONT_lpTemplateNameTemp
    call    UnmapLS

endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\wrapper.h ===
//---------------------------------------------------------------------------
//  Wrapper.h - wrappers for internal-only API's (not private)
//            - public and private API's in uxtheme.h, uxthemep.h
//---------------------------------------------------------------------------
#ifndef _WRAPPER_H
#define _WRAPPER_H
//---------------------------------------------------------------------------
#include "parser.h"
//---------------------------------------------------------------------------
//---- bits used in dwFlags of DTTOPTS ----
#define DTT_TEXTCOLOR     (1 << 0)   // crText has been specified
#define DTT_BORDERCOLOR   (1 << 1)   // crBorder has been specified
#define DTT_SHADOWCOLOR   (1 << 2)   // crShadow has been specified

#define DTT_SHADOWTYPE    (1 << 3)   // iTextShadowType has been specified
#define DTT_SHADOWOFFSET  (1 << 4)   // ptShadowOffset has been specified
#define DTT_BORDERSIZE    (1 << 5)   // iBorderSize has been specified

//------------------------------------------------------------------------
typedef struct _DTTOPTS
{
    DWORD dwSize;          // size of the struct
    DWORD dwFlags;         // which options have been specified

    COLORREF crText;       // color to use for text fill
    COLORREF crBorder;     // color to use for text outline
    COLORREF crShadow;     // color to use for text shadow

    int eTextShadowType;   // TST_SINGLE or TST_CONTINUOUS
    POINT ptShadowOffset;  // where shadow is drawn (relative to text)
    int iBorderSize;       // border around text
} 
DTTOPTS, *PDTTOPTS;
//------------------------------------------------------------------------

THEMEAPI GetThemeBitmap(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
    const RECT *prc, OUT HBITMAP *phBitmap);

THEMEAPI_(HTHEME) OpenNcThemeData(HWND hwnd, LPCWSTR pszClassIdList);

THEMEAPI DrawThemeTextEx(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    const RECT *pRect, OPTIONAL const DTTOPTS *pOptions);

THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient);

THEMEAPI ClearTheme (HANDLE hSection, BOOL fForce = FALSE);

//---------------------------------------------------------------------------
#endif // _WRAPPER_H
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\wrapper.cpp ===
//---------------------------------------------------------------------------
//  Wrapper.cpp - wrappers for win32-style API (handle-based)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"

#include "Utils.h"
#include "Loader.h"
#include "Wrapper.h"
#include "SetHook.h"
#include "Info.h"
#include "Services.h"
#include "appinfo.h"
#include "tmreg.h"
#include "tmutils.h"
#include "themeldr.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
#include "renderlist.h"
#include "filedump.h"
#include "Signing.h"
//---------------------------------------------------------------------------
#include "paramchecks.h"
//---------------------------------------------------------------------------
#define RETURN_VALIDATE_RETVAL(hr) { if (FAILED(hr)) return MakeError32(hr); }     // HRESULT functions
//---------------------------------------------------------------------------
THEMEAPI GetThemePropertyOrigin(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT PROPERTYORIGIN *pOrigin)
{
    APIHELPER(L"GetThemePropertyOrigin", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pOrigin, sizeof(PROPERTYORIGIN));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetPropertyOrigin(iPartId, iStateId, iPropId, pOrigin);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeColor(HTHEME hTheme, int iPartId, int iStateId,
   int iPropId, OUT COLORREF *pColor)
{
    APIHELPER(L"GetThemeColor", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pColor, sizeof(COLORREF));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetColor(iPartId, iStateId, iPropId, pColor);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBitmap(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
    const RECT *prc, OUT HBITMAP *phBitmap)
{
    APIHELPER(L"GetThemeBitmap", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, phBitmap, sizeof(HBITMAP));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    HRESULT hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_IMAGEFILE)
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBitmap(pRender, hdc, prc, phBitmap);
        }
        else        // BorderFill
        {
            hr = E_FAIL;
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeMetric(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, int iStateId,
     int iPropId, OUT int *piVal)
{
    APIHELPER(L"GetThemeMetric", hTheme);

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    VALIDATE_WRITE_PTR(ApiHelper, piVal, sizeof(int));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetMetric(hdc, iPartId, iStateId, iPropId, piVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeString(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars)
{
    APIHELPER(L"GetThemeString", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pszBuff, sizeof(WCHAR)*cchMaxBuffChars);

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetString(iPartId, iStateId, iPropId, pszBuff, cchMaxBuffChars);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBool(HTHEME hTheme, int iPartId, int iStateId,
     int iPropId, OUT BOOL *pfVal)
{
    APIHELPER(L"GetThemeBool", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pfVal, sizeof(BOOL));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetBool(iPartId, iStateId, iPropId, pfVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeInt(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT int *piVal)
{
    APIHELPER(L"GetThemeInt", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, piVal, sizeof(int));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetInt(iPartId, iStateId, iPropId, piVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeEnumValue(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT int *piVal)
{
    APIHELPER(L"GetThemeEnumValue", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, piVal, sizeof(int));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetEnumValue(iPartId, iStateId, iPropId, piVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemePosition(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT POINT *ppt)
{
    APIHELPER(L"GetThemePosition", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, ppt, sizeof(POINT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetPosition(iPartId, iStateId, iPropId, ppt);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeFont(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, int iStateId, 
    int iPropId, OUT LOGFONT *pFont)
{
    APIHELPER(L"GetThemeFont", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pFont, sizeof(LOGFONT));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetFont(hdc, iPartId, iStateId, iPropId, TRUE, pFont);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeIntList(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT INTLIST *pIntList)
{
    APIHELPER(L"GetThemeIntList", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pIntList, sizeof(INTLIST));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetIntList(iPartId, iStateId, iPropId, pIntList);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeMargins(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OPTIONAL RECT *prc, OUT MARGINS *pMargins)
{
    APIHELPER(L"GetThemeMargins", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pMargins, sizeof(MARGINS));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if (prc)
    {
        VALIDATE_READ_PTR(ApiHelper, prc, sizeof(RECT));
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    //---- look up unscaled value of margins ----
    HRESULT hr = pRender->GetMargins(hdc, iPartId, iStateId, iPropId, prc, pMargins);
    if (FAILED(hr))
        goto exit;
    
    //---- try to convert to scaled margins ----
    CDrawBase *pDrawObj;

    HRESULT hr2 = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr2))
    {
        if (pDrawObj->_eBgType == BT_IMAGEFILE)
        {
            SIZE szDraw;
            TRUESTRETCHINFO tsInfo;

            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            
            DIBINFO *pdi = pImageFile->SelectCorrectImageFile(pRender, hdc, prc, FALSE, NULL);

            pImageFile->GetDrawnImageSize(pdi, prc, &tsInfo, &szDraw);

            hr = pImageFile->ScaleMargins(pMargins, hdc, pRender, pdi, &szDraw);
        }
    }

exit:
    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeRect(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT RECT *pRect)
{
    APIHELPER(L"GetThemeRect", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pRect, sizeof(RECT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetRect(iPartId, iStateId, iPropId, pRect);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeFilename(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars)
{
    APIHELPER(L"GetThemeFilename", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pszBuff, sizeof(WCHAR)*cchMaxBuffChars);

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetFilename(iPartId, iStateId, iPropId, pszBuff, cchMaxBuffChars);
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    APIHELPER(L"DrawThemeBackground", hTheme);

    HRESULT hr = S_OK;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    if (pOptions)    
    {
        VALIDATE_READ_PTR(ApiHelper, pOptions, sizeof(*pOptions));
        if (pOptions->dwSize != sizeof(*pOptions))
        {
            hr = MakeError32(E_FAIL);
            return hr;
        }
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->DrawBackground(pRender, hdc, pRect, pOptions);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->DrawBackground(pRender, hdc, iStateId, pRect, pOptions);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect)
{
    APIHELPER(L"DrawThemeBackground", hTheme);

    HRESULT hr = S_OK;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    if (pClipRect)    
    {
        VALIDATE_READ_PTR(ApiHelper, pClipRect, sizeof(RECT));
        
        RECT rcx;
        if (! IntersectRect(&rcx, pRect, pClipRect))        // nothing to paint
            goto exit;
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        DTBGOPTS Opts = {sizeof(Opts)};
        DTBGOPTS *pOpts = NULL;

        if (pClipRect)
        {
            pOpts = &Opts;
            Opts.dwFlags |= DTBG_CLIPRECT;
            Opts.rcClip = *pClipRect;
        }

        if (pDrawObj->_eBgType == BT_BORDERFILL || 
            pDrawObj->_eBgType == BT_NONE)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->DrawBackground(pRender, hdc, pRect, pOpts);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->DrawBackground(pRender, hdc, iStateId, pRect, pOpts);
        }
    }

exit:
    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI HitTestThemeBackground(
    HTHEME hTheme, 
    OPTIONAL HDC hdc, 
    int iPartId, 
    int iStateId, 
    DWORD dwOptions, 
    const RECT *pRect, 
    OPTIONAL HRGN hrgn,
    POINT ptTest, 
    OUT WORD *pwHitTestCode)
{
    APIHELPER(L"HitTestThemeBackground", hTheme);
    
    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pwHitTestCode, sizeof(WORD));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if( hrgn )
    {
        VALIDATE_HANDLE(ApiHelper, hrgn);
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->HitTestBackground(pRender, hdc, dwOptions, pRect, 
                hrgn, ptTest, pwHitTestCode);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->HitTestBackground(pRender, hdc, iStateId, dwOptions, pRect, 
                hrgn, ptTest, pwHitTestCode);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeTextEx(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    const RECT *pRect, OPTIONAL const DTTOPTS *pOptions)
{
    APIHELPER(L"DrawThemeTextEx", hTheme);
    
    VALIDATE_HDC(ApiHelper, hdc);
    
    if (iCharCount == -1)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszText);
    }
    else
    {
        VALIDATE_READ_PTR(ApiHelper, pszText, sizeof(WCHAR)*iCharCount);
    }

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    if (pOptions)
    {
        VALIDATE_READ_PTR(ApiHelper, pOptions, sizeof(*pOptions));
        if (pOptions->dwSize != sizeof(*pOptions))
        {
            return MakeError32(E_FAIL);
        }
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->DrawText(pRender, hdc, iPartId, iStateId, pszText, iCharCount, 
            dwTextFlags, pRect, pOptions);
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeText(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    DWORD dwTextFlags2, const RECT *pRect)
{
    APIHELPER(L"DrawThemeText", hTheme);
    
    VALIDATE_HDC(ApiHelper, hdc);
    
    if (iCharCount == -1)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszText);
    }
    else
    {
        VALIDATE_READ_PTR(ApiHelper, pszText, sizeof(WCHAR)*iCharCount);
    }

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->DrawText(pRender, hdc, iPartId, iStateId, pszText, iCharCount, 
            dwTextFlags, pRect, NULL);
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI CloseThemeData(HTHEME hTheme)
{
    //---- don't take a refcount on hTheme since we are about to close it ----
    APIHELPER(L"CloseThemeData", NULL);

    return g_pRenderList->CloseRenderObject(hTheme);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBackgroundContentRect(HTHEME hTheme, OPTIONAL HDC hdc, 
    int iPartId, int iStateId, const RECT *pBoundingRect, 
    OUT RECT *pContentRect)
{
    APIHELPER(L"GetThemeBackgroundContentRect", hTheme);

    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_READ_PTR(ApiHelper, pBoundingRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pContentRect, sizeof(RECT));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetBackgroundContentRect(pRender, hdc, 
                pBoundingRect, pContentRect);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBackgroundContentRect(pRender, hdc, 
                pBoundingRect, pContentRect);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBackgroundRegion(HTHEME hTheme, OPTIONAL HDC hdc,  
    int iPartId, int iStateId, const RECT *pRect, OUT HRGN *pRegion)
{
    APIHELPER(L"GetThemeBackgroundRegion", hTheme);

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pRegion, sizeof(HRGN));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if (IsRectEmpty(pRect))
    {
        *pRegion = NULL;
        return S_FALSE;
    }

    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetBackgroundRegion(pRender, hdc, pRect, pRegion);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBackgroundRegion(pRender, hdc, iStateId, pRect, pRegion);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeTextExtent(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, 
    DWORD dwTextFlags, OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect)
{
    APIHELPER(L"GetThemeTextExtent", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);

    if (iCharCount == -1)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszText);
    } else
    {
        VALIDATE_READ_PTR(ApiHelper, pszText, sizeof(WCHAR)*iCharCount);
    }

    if (pBoundingRect)
    {
        VALIDATE_READ_PTR(ApiHelper, pBoundingRect, sizeof(RECT));
    }

    VALIDATE_WRITE_PTR(ApiHelper, pExtentRect, sizeof(RECT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->GetTextExtent(pRender, hdc, iPartId, iStateId, pszText, iCharCount,
            dwTextFlags, pBoundingRect, pExtentRect);
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeTextMetrics(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, OUT TEXTMETRIC* ptm)
{
    APIHELPER(L"GetThemeTextMetrics", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_WRITE_PTR(ApiHelper, ptm, sizeof(TEXTMETRIC));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->GetTextMetrics(pRender, hdc, iPartId, iStateId, ptm);
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBackgroundExtent(HTHEME hTheme, OPTIONAL HDC hdc,
    int iPartId, int iStateId, const RECT *pContentRect, OUT RECT *pExtentRect)
{
    APIHELPER(L"GetThemeBackgroundExtent", hTheme);

    VALIDATE_READ_PTR(ApiHelper, pContentRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pExtentRect, sizeof(RECT));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;
    HRESULT hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetBackgroundExtent(pRender, hdc, pContentRect,
                pExtentRect);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBackgroundExtent(pRender, hdc, 
                pContentRect, pExtentRect);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemePartSize(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, OPTIONAL RECT *prc, THEMESIZE eSize, OUT SIZE *psz)
{
    APIHELPER(L"GetThemePartSize", hTheme);

    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if (prc)
    {
        VALIDATE_READ_PTR(ApiHelper, prc, sizeof(RECT));
    }

    VALIDATE_WRITE_PTR(ApiHelper, psz, sizeof(SIZE));

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetPartSize(hdc, eSize, psz);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetPartSize(pRender, hdc, prc, eSize, psz);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList)
{
    APIHELPER(L"SetWindowTheme", NULL);

    VALIDATE_HWND(ApiHelper, hwnd);
    if (pszSubAppName)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSubAppName);
    }
    if (pszSubIdList)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSubIdList);
    }
    
    ApplyStringProp(hwnd, pszSubAppName, GetThemeAtom(THEMEATOM_SUBAPPNAME));
    ApplyStringProp(hwnd, pszSubIdList, GetThemeAtom(THEMEATOM_SUBIDLIST));

    //---- tell target window to get a new theme handle ----
    SendMessage(hwnd, WM_THEMECHANGED, static_cast<WPARAM>(-1), WTC_THEMEACTIVE | WTC_CUSTOMTHEME);

    return S_OK;
}
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    OUT LPWSTR pszNameBuff, int cchMaxNameChars, 
    OUT OPTIONAL LPWSTR pszColorBuff, int cchMaxColorChars,
    OUT OPTIONAL LPWSTR pszSizeBuff, int cchMaxSizeChars)
{
    APIHELPER(L"GetCurrentThemeName", NULL);

    VALIDATE_WRITE_PTR(ApiHelper, pszNameBuff, sizeof(WCHAR)*cchMaxNameChars);
    if (pszColorBuff)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pszColorBuff, sizeof(WCHAR)*cchMaxColorChars);
    }
    if (pszSizeBuff)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pszSizeBuff, sizeof(WCHAR)*cchMaxSizeChars);
    }

    HRESULT hr;
    CUxThemeFile *pThemeFile = NULL;

    //---- get a shared CUxThemeFile object ----
    hr = g_pAppInfo->OpenWindowThemeFile(NULL, &pThemeFile);
    if (FAILED(hr))
        goto exit;

    //---- get info about current theme ----
    hr = GetThemeNameId(pThemeFile, pszNameBuff, cchMaxNameChars, pszColorBuff, cchMaxColorChars,
        pszSizeBuff, cchMaxSizeChars, NULL, NULL);

exit:
    if (pThemeFile)
        g_pAppInfo->CloseThemeFile(pThemeFile);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFile(LPCWSTR pszThemeName, OPTIONAL LPCWSTR pszColorParam,
   OPTIONAL LPCWSTR pszSizeParam, OUT HTHEMEFILE *phThemeFile, BOOL fGlobalTheme)
{
    APIHELPER(L"OpenThemeFile", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName);

    if (pszColorParam)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszColorParam);
    }

    if (pszSizeParam)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSizeParam);
    }

    VALIDATE_WRITE_PTR(ApiHelper, phThemeFile, sizeof(HTHEMEFILE));

    HANDLE handle;
    HRESULT hr = CThemeServices::LoadTheme(&handle, pszThemeName, pszColorParam, pszSizeParam, 
        fGlobalTheme);
    if (FAILED(hr))
        goto exit;
    
    //---- convert from Memory Mapped File handle to a CUxThemeFile ptr ----
    CUxThemeFile *pThemeFile;
  
    //---- set new file ----
    hr = g_pAppInfo->OpenThemeFile(handle, &pThemeFile);
    if (SUCCEEDED(hr))
    {
        *phThemeFile = (HTHEMEFILE *)pThemeFile; 
    }
    else
    {
        // We don't have a CUxThemeFile, have to clear ourselves
        ClearTheme(handle);
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI ApplyTheme(OPTIONAL HTHEMEFILE hThemeFile, DWORD dwApplyFlags,
    OPTIONAL HWND hwndTarget)
{
    APIHELPER(L"ApplyTheme", NULL);

    HRESULT hr = S_OK;

    if (hThemeFile)
    {
        VALIDATE_READ_PTR(ApiHelper, hThemeFile, sizeof(HTHEMEFILE));
    }

    if (hwndTarget)
    {
        VALIDATE_HWND(ApiHelper, hwndTarget);
    }

    CUxThemeFile *pThemeFile = (CUxThemeFile *)hThemeFile;

    //----- set preview info, if targeted at a window ----
    if (hwndTarget)
        g_pAppInfo->SetPreviewThemeFile(pThemeFile->Handle(), hwndTarget);

    hr = CThemeServices::ApplyTheme(pThemeFile, dwApplyFlags, hwndTarget);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI CloseThemeFile(HTHEMEFILE hThemeFile)
{
    APIHELPER(L"CloseThemeFile", NULL);

    if (hThemeFile)
    {
        VALIDATE_READ_PTR(ApiHelper, hThemeFile, sizeof(HTHEMEFILE));
    }

    CUxThemeFile *pThemeFile = (CUxThemeFile *)hThemeFile;
    if (pThemeFile)
    {
        VALIDATE_READ_PTR(ApiHelper, pThemeFile, sizeof(CUxThemeFile));

        g_pAppInfo->CloseThemeFile(pThemeFile);
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
THEMEAPI EnumThemes(LPCWSTR pszThemeRoot, THEMEENUMPROC lpEnumFunc, LPARAM lParam)
{
    APIHELPER(L"EnumThemes", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeRoot);
    VALIDATE_CALLBACK(ApiHelper, lpEnumFunc);

    HRESULT hr;
    HANDLE hFile = NULL;
    if (! lpEnumFunc)
        hr = MakeError32(E_INVALIDARG);
    else
    {
        WCHAR szSearchPath[_MAX_PATH+1];
        WCHAR szFileName[_MAX_PATH+1];
        WCHAR szDisplayName[_MAX_PATH+1];
        WCHAR szToolTip[_MAX_PATH+1];

        wsprintf(szSearchPath, L"%s\\*.*", pszThemeRoot);

        //---- first find all child directories containing a *.msstyles files ----
        BOOL   bFile = TRUE;
        WIN32_FIND_DATA wfd;
        hr = S_FALSE;       // assume interrupted until we complete

        bool bRemote = GetSystemMetrics(SM_REMOTESESSION) ? true : false;

        DWORD dwCurMinDepth = 0;
            
        if (bRemote)
        {
            dwCurMinDepth = MinimumDisplayColorDepth();
        }

        for( hFile = FindFirstFile( szSearchPath, &wfd ); hFile != INVALID_HANDLE_VALUE && bFile;
             bFile = FindNextFile( hFile, &wfd ) )
        {
            if(! ( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ))
                continue;

            if ((lstrcmp(wfd.cFileName, TEXT("."))==0) || (lstrcmp(wfd.cFileName, TEXT(".."))==0))
                continue;

            wsprintf(szFileName, L"%s\\%s\\%s.msstyles", pszThemeRoot, wfd.cFileName, wfd.cFileName);

            //---- ensure its signed by ms ----
            hr = CThemeServices::CheckThemeSignature(szFileName);
            if (FAILED(hr))
                continue;

            //---- ensure its loadable & has a supported version ----
            HINSTANCE hInst;
            hr = LoadThemeLibrary(szFileName, &hInst);
            if (FAILED(hr))
                continue;

            int iBaseNum = RES_BASENUM_DOCPROPERTIES - TMT_FIRST_RCSTRING_NAME;

            //---- get DisplayName ----
            if (! LoadString(hInst, iBaseNum + TMT_DISPLAYNAME, szDisplayName, ARRAYSIZE(szDisplayName)))
                *szDisplayName = 0;

            //---- get ToolTip ----
            if (! LoadString(hInst, iBaseNum + TMT_TOOLTIP, szToolTip, ARRAYSIZE(szToolTip)))
                *szToolTip = 0;

            //---- see if one class file supports this color depth
            bool bMatch = true;
            
            // Check on remote sessions only (the console can be in 8-bit mode)
            if (bRemote)
            {
                bMatch = CheckMinColorDepth(hInst, dwCurMinDepth);
            }

            //---- free the lib ----
            FreeLibrary(hInst);

            if (bMatch)
            {
                //---- its a good one - call the callback ----
                BOOL fContinue = (*lpEnumFunc)(TCB_THEMENAME, szFileName, szDisplayName, 
                    szToolTip, 0, lParam);        // call the callback
    
                if (! fContinue)
                    goto exit;
            }
        }

        hr = S_OK;      // completed
    }

exit:
    if (hFile)
        FindClose(hFile);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI EnumThemeSizes(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, OUT THEMENAMEINFO *ptn)
{
    APIHELPER(L"EnumThemeSizes", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName);
    
    if (pszColorScheme)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszColorScheme);
    }

    VALIDATE_WRITE_PTR(ApiHelper, ptn, sizeof(THEMENAMEINFO));

    HINSTANCE hInst = NULL;
    HRESULT hr = LoadThemeLibrary(pszThemeName, &hInst);

    if (SUCCEEDED(hr))
    {
        hr = _EnumThemeSizes(hInst, pszThemeName, pszColorScheme, dwSizeIndex, ptn, (BOOL) GetSystemMetrics(SM_REMOTESESSION));
        FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI EnumThemeColors(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, OUT THEMENAMEINFO *ptn)
{
    APIHELPER(L"EnumThemeColors", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName);
    if (pszSizeName)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSizeName);
    }

    VALIDATE_WRITE_PTR(ApiHelper, ptn, sizeof(THEMENAMEINFO));

    HINSTANCE hInst = NULL;
    HRESULT hr = LoadThemeLibrary(pszThemeName, &hInst);

    if (SUCCEEDED(hr))
    {
        hr = _EnumThemeColors(hInst, pszThemeName, pszSizeName, dwColorIndex, ptn, (BOOL) GetSystemMetrics(SM_REMOTESESSION));
        FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI DrawThemeEdge(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
                       const RECT *pDestRect, UINT uEdge, UINT uFlags, OUT RECT *pContentRect)
{
    APIHELPER(L"DrawThemeEdge", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pDestRect, sizeof(RECT));
    if (pContentRect)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pContentRect, sizeof(RECT));
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->DrawEdge(pRender, hdc, iPartId, iStateId, pDestRect, uEdge, uFlags, pContentRect);
    }

    return hr;
}

//---------------------------------------------------------------------------
THEMEAPI DrawThemeIcon(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex)
{
    APIHELPER(L"DrawThemeIcon", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));
    VALIDATE_HANDLE(ApiHelper, himl);

    IMAGELISTDRAWPARAMS params = {sizeof(params)};

    HRESULT hr = EnsureUxCtrlLoaded();
    if (FAILED(hr))
        goto exit;

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    //---- build up the IMAGELISTDRAWPARAMS struct ----

    params.hdcDst = hdc;
    params.himl = himl;
    params.i = iImageIndex;
    params.x = pRect->left;
    params.y = pRect->top;
    params.cx = WIDTH(*pRect);
    params.cy = HEIGHT(*pRect);

    params.rgbBk = CLR_NONE;
    params.rgbFg = CLR_NONE;
    params.fStyle = ILD_TRANSPARENT;

    //---- get IconEffect ----
    ICONEFFECT effect;
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_ICONEFFECT, (int *)&effect)))
        effect = ICE_NONE;

    if (effect == ICE_GLOW)
    {
        params.fState = ILS_GLOW;

        //---- get GlowColor ----
        COLORREF glow;
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GLOWCOLOR, &glow)))
            glow = RGB(0, 0, 255);

        params.crEffect = glow;
    }
    else if (effect == ICE_SHADOW)
    {
        params.fState = ILS_SHADOW;

        //---- get ShadowColor ----
        COLORREF shadow;
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_SHADOWCOLOR, &shadow)))
            shadow = RGB(0, 0, 0);

        params.crEffect = shadow;
    }
    else if (effect == ICE_PULSE)
    {
        params.fState = ILS_SATURATE;

        //---- get Saturation ----
        int saturate;
        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_SATURATION, &saturate)))
            saturate = 128;          // 50% of 255

        params.Frame = saturate;
    }
    else if (effect == ICE_ALPHA)
    {
        params.fState = ILS_ALPHA;

        //---- get AlphaLevel ----
        int alpha;
        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_ALPHALEVEL, &alpha)))
            alpha = 128;        // 50% of 255
        
        params.Frame = alpha;
    }

    if (! (*ImageList_DrawProc)(&params))
        hr = MakeError32(E_FAIL);      // no other error info available

exit:
    return hr;
}

//---------------------------------------------------------------------------
THEMEAPI GetThemeDefaults(LPCWSTR pszThemeName, 
    OUT OPTIONAL LPWSTR pszDefaultColor, int cchMaxColorChars, 
    OUT OPTIONAL LPWSTR pszDefaultSize, int cchMaxSizeChars)
{
    APIHELPER(L"GetThemeDefaults", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName);
    if (pszDefaultColor)
    {
        VALIDATE_READ_PTR(ApiHelper, pszDefaultColor, cchMaxColorChars);
    }
    if (pszDefaultSize)
    {
        VALIDATE_READ_PTR(ApiHelper, pszDefaultSize, cchMaxSizeChars);
    }

    HRESULT hr;
    HINSTANCE hInst = NULL;
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;

    if (pszDefaultColor)
    {
        hr = GetResString(hInst, L"COLORNAMES", 0, pszDefaultColor, cchMaxColorChars);
        if (FAILED(hr))
            goto exit;
    } 

    if (pszDefaultSize)
    {
        hr = GetResString(hInst, L"SIZENAMES", 0, pszDefaultSize, cchMaxSizeChars);
        if (FAILED(hr))
            goto exit;
    }

exit:
    FreeLibrary(hInst);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeDocumentationProperty(LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName, OUT LPWSTR pszValueBuff, int cchMaxValChars)
{
    APIHELPER(L"GetThemeDocumentationProperty", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName);
    VALIDATE_INPUT_STRING(ApiHelper, pszPropertyName);
    VALIDATE_WRITE_PTR(ApiHelper, pszValueBuff, sizeof(WCHAR)*cchMaxValChars);

    HRESULT hr;
    CThemeParser *pParser = NULL;

    HINSTANCE hInst = NULL;
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;

    pParser = new CThemeParser;
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    //---- is this a recognized (localized) property name? ----
    int iPropNum;
    hr = pParser->GetPropertyNum(pszPropertyName, &iPropNum);
    if (SUCCEEDED(hr))
    {
        //---- try to read from string table of recognized [documentation] properties ----
        if (LoadString(hInst, iPropNum+RES_BASENUM_DOCPROPERTIES, pszValueBuff, cchMaxValChars))
            goto exit;
    }

    //---- load the themes.ini text into memory ----
    LPWSTR pThemesIni;
    hr = AllocateTextResource(hInst, CONTAINER_RESNAME, &pThemesIni);
    if (FAILED(hr))
        goto exit;

    hr = pParser->ParseThemeBuffer(pThemesIni, NULL, NULL, NULL, NULL, NULL, NULL, 
        PTF_QUERY_DOCPROPERTY | PTF_CONTAINER_PARSE, pszPropertyName, pszValueBuff, cchMaxValChars);

exit:

    if (pParser)
        delete pParser;

    FreeLibrary(hInst);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont96(HTHEME hTheme, int iFontId, OUT LOGFONT *plf)
{
    APIHELPER(L"GetThemeSysFont96", hTheme);

    CRenderObj *pRender = NULL;
    HRESULT hr = S_OK;

    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, plf, sizeof(LOGFONT)); 

    //---- check font index limits ----
    if ((iFontId < TMT_FIRSTFONT) || (iFontId > TMT_LASTFONT))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    //---- return unscaled value ----
    *plf = pRender->_ptm->lfFonts[iFontId - TMT_FIRSTFONT];

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont(OPTIONAL HTHEME hTheme, int iFontId, OUT LOGFONT *plf)
{
    APIHELPER(L"GetThemeSysFont", hTheme);

    CRenderObj *pRender = NULL;
    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    VALIDATE_WRITE_PTR(ApiHelper, plf, sizeof(LOGFONT)); 

    //---- check font index limits ----
    HRESULT hr = S_OK;

    if ((iFontId < TMT_FIRSTFONT) || (iFontId > TMT_LASTFONT))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    if (pRender)            // get theme value
    {
        *plf = pRender->_ptm->lfFonts[iFontId - TMT_FIRSTFONT];

        //---- convert to current screen dpi ----
        ScaleFontForScreenDpi(plf);
    }
    else                    // get system value
    {
        if (iFontId == TMT_ICONTITLEFONT)
        {
            BOOL fGet = ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), plf, 0);
            if (! fGet)
            {
                Log(LOG_ERROR, L"Error returned from ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT)");
                hr = MakeErrorLast();
                goto exit;
            }
        }
        else
        {
            NONCLIENTMETRICS ncm = {sizeof(ncm)};
            BOOL fGet = ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
            if (! fGet)
            {
                Log(LOG_ERROR, L"Error returned from ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS)");
                hr = MakeErrorLast();
                goto exit;
            }
        
            switch (iFontId)
            {
                case TMT_CAPTIONFONT:
                    *plf = ncm.lfCaptionFont;
                    break;

                case TMT_SMALLCAPTIONFONT:
                    *plf = ncm.lfSmCaptionFont;
                    break;

                case TMT_MENUFONT:
                    *plf = ncm.lfMenuFont;
                    break;

                case TMT_STATUSFONT:
                    *plf = ncm.lfStatusFont;
                    break;

                case TMT_MSGBOXFONT:
                    *plf = ncm.lfMessageFont;
                    break;

            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysString(HTHEME hTheme, int iStringId, 
    OUT LPWSTR pszStringBuff, int cchMaxStringChars)
{
    APIHELPER(L"GetThemeSysString", hTheme);

    CRenderObj *pRender = NULL;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, pszStringBuff, sizeof(WCHAR)*cchMaxStringChars); 

    HRESULT hr;

    //---- check string index limits ----
    if ((iStringId < TMT_FIRSTSTRING) || (iStringId > TMT_LASTSTRING))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    LPCWSTR p;
    p = ThemeString(pRender->_pThemeFile, pRender->_ptm->iStringOffsets[iStringId - TMT_FIRSTSTRING]);

    hr = hr_lstrcpy(pszStringBuff, p, cchMaxStringChars);
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysInt(HTHEME hTheme, int iIntId, int *piValue)
{
    APIHELPER(L"GetThemeSysInt", hTheme);

    CRenderObj *pRender = NULL;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, piValue, sizeof(int)); 

    HRESULT hr;

    //---- check int index limits ----
    if ((iIntId < TMT_FIRSTINT) || (iIntId > TMT_LASTINT))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    *piValue = pRender->_ptm->iInts[iIntId - TMT_FIRSTINT];
    hr = S_OK;

exit:
    return hr;
}
//---------------------------------------------------------------------------
#define THEME_FORCE_VERSION     103     // increment this when you want to force
                                        // new theme settings
//---------------------------------------------------------------------------
THEMEAPI RegisterDefaultTheme(LPCWSTR pszFileName, BOOL fOverride)
{
    APIHELPER(L"RegisterDefaultTheme", NULL);

    RESOURCE HKEY tmkey = NULL;
    HRESULT hr = S_OK;
    HKEY hKeyDefault = NULL;

    //---- Note: at install time, its not possible to access each ----
    //---- user's registry info (may be roaming on server) so ----
    //---- we put default theme under HKEY_LM.  Then, during ----
    //---- themeldr init for a user, we propagate the info ----
    //---- to the HKEY_CU root. ----

    //---- open LM + THEMEMGR key (create if needed) ----
    int code32 = RegCreateKeyEx(HKEY_LOCAL_MACHINE, THEMEMGR_REGKEY, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &tmkey, NULL);
    if (code32 != ERROR_SUCCESS)       
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- read the value of "THEMEPROP_LMVERSION" ----
    int iValue;
    hr = RegistryIntRead(tmkey, THEMEPROP_LMVERSION, &iValue);
    if (FAILED(hr))     
        iValue = 0;

  //** lMouton: Normally THEMEPROP_LMVERSION is the one we increment when we want to refresh .DEFAULT 
    // (which controls the winlogon dialog appearance), but Setup will write other values to 
    // .Default\Control Panel\Colors each time (hivexxx.inx), so here we force a refresh of the system 
    // metrics after each setup. This won't be called for Server installs.
    // Another benefit of this is that design changes to the default theme get automatically propagated
    // to winlogon. Themeui.dll takes care of propagating them for all users, when its version number changes.

    // Reset LoadedBefore for .default, to refresh the winlogon appearance settings
    if ((ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_USERS, L".DEFAULT\\" THEMEMGR_REGKEY, 0, KEY_WRITE, &hKeyDefault)))
    {
        RegistryIntWrite(hKeyDefault, THEMEPROP_LOADEDBEFORE, 0);
        ::RegCloseKey(hKeyDefault);
    }

    if (iValue == THEME_FORCE_VERSION)     // matches - don't update anything
        goto exit;
    
    //---- write the NEW value of "THEMEPROP_LMVERSION" ----
    hr = RegistryIntWrite(tmkey, THEMEPROP_LMVERSION, THEME_FORCE_VERSION);
    if (FAILED(hr))
        goto exit;

    //---- write the value of "THEMEPROP_LMOVERRIDE" ----
    iValue = (fOverride != 0);
    hr = RegistryIntWrite(tmkey, THEMEPROP_LMOVERRIDE, iValue);
    if (FAILED(hr))
        goto exit;

    //---- write the "THEMEPROP_THEMEACTIVE" = "1" ----
    hr = RegistryIntWrite(tmkey, THEMEPROP_THEMEACTIVE, 1);
    if (FAILED(hr))
        goto exit;

    //---- write the "THEMEPROP_LOADEDBEFORE" = "0" ----
    hr = RegistryIntWrite(tmkey, THEMEPROP_LOADEDBEFORE, 0);
    if (FAILED(hr))
        goto exit;

    //---- write "DllName=xxxx" string/value ----
    hr =  RegistryStrWriteExpand(tmkey, THEMEPROP_DLLNAME, pszFileName);
    if (FAILED(hr))
        goto exit;

exit:
    if (tmkey)
        RegCloseKey(tmkey);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, LPCWSTR pszTextFile, 
    BOOL fPacked, BOOL fFullInfo)
{
    APIHELPER(L"DumpLoadedThemeToTextFile", NULL);

    VALIDATE_READ_PTR(ApiHelper, hThemeFile, sizeof(HTHEMEFILE));
    VALIDATE_INPUT_STRING(ApiHelper, pszTextFile);

    CUxThemeFile *pThemeFile = (CUxThemeFile *)hThemeFile;

    return DumpThemeFile(pszTextFile, pThemeFile, fPacked, fFullInfo);
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo)
{
    APIHELPER(L"GetThemeParseErrorInfo", NULL);

    VALIDATE_WRITE_PTR(ApiHelper, pInfo, sizeof(*pInfo)); 

    return _GetThemeParseErrorInfo(pInfo);
}
//---------------------------------------------------------------------------
THEMEAPI ParseThemeIniFile(LPCWSTR pszFileName,  
    DWORD dwParseFlags, OPTIONAL THEMEENUMPROC pfnCallBack, OPTIONAL LPARAM lparam) 
{
    APIHELPER(L"ParseThemeIniFile", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszFileName);
    if (pfnCallBack)
    {
        VALIDATE_CALLBACK(ApiHelper, pfnCallBack);
    }

    return _ParseThemeIniFile(pszFileName, dwParseFlags, pfnCallBack, lparam);
}
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFileFromData(HTHEME hTheme, HTHEMEFILE *phThemeFile)
{
    APIHELPER(L"OpenThemeFileFromData", hTheme);

    CRenderObj *pRender = NULL;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, phThemeFile, sizeof(HTHEMEFILE));

    return _OpenThemeFileFromData(pRender, phThemeFile);
}
//---------------------------------------------------------------------------
THEMEAPI DrawThemeParentBackground(HWND hwnd, HDC hdc, OPTIONAL RECT* prc)
{
    APIHELPER(L"DrawThemeParentBackground", NULL);

    //---- param validation ----
    VALIDATE_HWND(ApiHelper, hwnd);
    
    VALIDATE_HDC(ApiHelper, hdc);
    
    if (prc)
    {
        VALIDATE_READ_PTR(ApiHelper, prc, sizeof(RECT)); 
    }

    // INVESTIGATE: There is a possible sync problem. If we have a window
    // parented to a window in another thread, then the property stuff may get out of
    // sync between the threads. If this is an issue, then we may have to leave the
    // property on the window instead of removing it when we're done.
    RECT rc; 
    POINT pt;
    CSaveClipRegion csrPrevClip;
    HRESULT hr = S_OK;
    HWND hwndParent = GetParent(hwnd);
    ATOM aIsPrinting = GetThemeAtom(THEMEATOM_PRINTING);

    if (prc)
    {
        rc = *prc;
        hr = csrPrevClip.Save(hdc);      // save current clipping region
        if (FAILED(hr))
            goto exit;

        IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
    }

    //---- get RECT of "hwnd" client area in parent coordinates ----
    GetClientRect(hwnd, &rc);
    MapWindowPoints(hwnd, hwndParent, (POINT*)&rc, 2);

    // Set a property saying "We want to see if this window handles WM_PRINTCLIENT. i.e. if it passes 
    // it to DefWindowProc it didn't handle it.
    SetProp(hwndParent, (PCTSTR)aIsPrinting, (HANDLE)PRINTING_ASKING);

    // Setup the viewport so that it is aligned with the parents.
    GetViewportOrgEx(hdc, &pt);
    SetViewportOrgEx(hdc, pt.x - rc.left, pt.y - rc.top, &pt);
    SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM)hdc, (LPARAM)0);
    SendMessage(hwndParent, WM_PRINTCLIENT, (WPARAM)hdc, (LPARAM)PRF_CLIENT);
    SetViewportOrgEx(hdc, pt.x, pt.y, NULL);

    // See if the window handled the print. If this is set to PRINTING_WINDOWDIDNOTHANDLE, 
    // it means they did not handle it (i.e. it was passed to DefWindowProc)
    if (PtrToUlong(GetProp(hwndParent, (PCTSTR)aIsPrinting)) == PRINTING_WINDOWDIDNOTHANDLE)
    {
        hr = S_FALSE;
    }

exit:
    RemoveProp(hwndParent, (PCTSTR)aIsPrinting);
    csrPrevClip.Restore(hdc);      // restore current clipping region

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI EnableThemeDialogTexture(HWND hwnd, DWORD dwFlagsIn)
{
    APIHELPER(L"EnableThemeDialogTexture", NULL);
    HRESULT hr = S_OK;

    if (TESTFLAG(dwFlagsIn, ETDT_DISABLE))
    {
        RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)));
    }
    else
    {
        ULONG ulFlagsOut = HandleToUlong(GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING))));
        
        //  validate and add requested flags:
        ulFlagsOut |= (dwFlagsIn & (ETDT_ENABLE|ETDT_USETABTEXTURE));

        if (!SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)), ULongToHandle(ulFlagsOut)))
        {
            DWORD dwErr = GetLastError();
            hr = (ERROR_SUCCESS == dwErr) ? E_FAIL : HRESULT_FROM_WIN32(dwErr);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI RefreshThemeForTS()
{
    APIHELPER(L"RefreshThemeForTS", NULL);

    return CThemeServices::InitUserTheme();
}
//---------------------------------------------------------------------------
//---- put all non-HRESULT returning functions down at the bottom here ----
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL(hr) { if (FAILED(hr)) { SET_LAST_ERROR(hr); return NULL; } }     // HANDLE functions
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags)
{
    APIHELPER(L"CreateThemeDataFromObjects", NULL);

    HTHEME hTheme = NULL;
    BOOL fGotOne = FALSE;
    HRESULT hr = S_OK;

    if (pDrawObj)
    {
        VALIDATE_READ_PTR(ApiHelper, pDrawObj, sizeof(pDrawObj->_eBgType));

        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            VALIDATE_READ_PTR(ApiHelper, pDrawObj, sizeof(CBorderFill));
        }
        else if (pDrawObj->_eBgType == BT_IMAGEFILE)
        {
            VALIDATE_READ_PTR(ApiHelper, pDrawObj, sizeof(CImageFile));
        }
        else
            goto exit;      // unknown object type

        fGotOne = TRUE;
    }

    if (pTextObj)
    {
        VALIDATE_READ_PTR(ApiHelper, pTextObj, sizeof(CTextDraw));

        fGotOne = TRUE;
    }

    if (! fGotOne)
    {
        hr = MakeError32(E_POINTER);
        goto exit;
    }

    hr = g_pRenderList->OpenRenderObject(NULL, 0, 0, pDrawObj, pTextObj, NULL, dwOtdFlags,
        &hTheme);

    if (FAILED(hr))
    {
        hTheme = NULL;
    }

exit:
    SET_LAST_ERROR(hr);
    return hTheme;
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeData(OPTIONAL HWND hwnd, LPCWSTR pszClassIdList)
{
    APIHELPER(L"OpenThemeData", NULL);

    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    VALIDATE_INPUT_STRING(ApiHelper, pszClassIdList);
    
    return _OpenThemeData(hwnd, pszClassIdList, 0);
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataEx(OPTIONAL HWND hwnd, LPCWSTR pszClassIdList, DWORD dwFlags)
{
    APIHELPER(L"OpenThemeDataEx", NULL);

    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    VALIDATE_INPUT_STRING(ApiHelper, pszClassIdList);
    
    return _OpenThemeData(hwnd, pszClassIdList, dwFlags);
}
//-----------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenNcThemeData(HWND hwnd, LPCWSTR pszClassIdList)
{
    APIHELPER(L"OpenNcThemeData", NULL);

    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    VALIDATE_INPUT_STRING(ApiHelper, pszClassIdList);

    return _OpenThemeData(hwnd, pszClassIdList, OTD_NONCLIENT);
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient)
{
    APIHELPER(L"OpenThemeDataFromFile", NULL);

    VALIDATE_READ_PTR(ApiHelper, hLoadedThemeFile, sizeof(HTHEMEFILE));
    
    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    if (pszClassList)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszClassList);
    }
    else
    {
        pszClassList = L"globals";
    }

    //---- caller holds a REFCOUNT on hLoadedThemeFile so we don't need to adjust it ----
    //---- for the call to _OpenThemeDataFromFile.  If it succeeds, CRenderObj will ----
    //---- add its own REFCOUNT.  If it fails, the REFCOUNT will be the orig REFCOUNT ----
    DWORD dwFlags = 0;

    if (! fClient)
    {
        dwFlags |= OTD_NONCLIENT;
    }

    return _OpenThemeDataFromFile(hLoadedThemeFile, hwnd, pszClassList, dwFlags);
}
//---------------------------------------------------------------------------
THEMEAPI EnableTheming(BOOL fEnable)
{
    APIHELPER(L"EnableTheming", NULL);
    
    return CThemeServices::AdjustTheme(fEnable);
}
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH) GetThemeSysColorBrush(OPTIONAL HTHEME hTheme, int iSysColorId)
{
    APIHELPER(L"GetThemeSysColorBrush", hTheme);
    HBRUSH hbr;

    CRenderObj *pRender = NULL;
    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    //---- keep orig & make our own version of ColorId ----
    int iThemeColorId = iSysColorId + TMT_FIRSTCOLOR;

    //---- check color index limits ----
    if ((iThemeColorId < TMT_FIRSTCOLOR) || (iThemeColorId > TMT_LASTCOLOR))
        iThemeColorId = TMT_FIRSTCOLOR;

    //---- make index 0-relative ----
    iThemeColorId -= TMT_FIRSTCOLOR;

    if (! pRender)
    {
        hbr = GetSysColorBrush(iSysColorId);
    }
    else
    {
        COLORREF cr = pRender->_ptm->crColors[iThemeColorId];
        hbr = CreateSolidBrush(cr);
    }

    return hbr;
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd)
{
    APIHELPER(L"GetWindowTheme", NULL);

    VALIDATE_HWND(ApiHelper, hwnd);
    
    return (HTHEME)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)));
}
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL { if (FAILED(hr)) { SET_LAST_ERROR(hr); return FALSE; } }     // BOOL functions
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeActive()
{
    APIHELPER(L"IsThemeActive", NULL);

    SetLastError(0);

    Log(LOG_TMLOAD, L"IsThemeActive(): start...");

    BOOL fThemeActive = g_pAppInfo->IsSystemThemeActive();

    Log(LOG_TMLOAD, L"IsThemeActive(): fThemeActive=%d", fThemeActive);

    return fThemeActive;
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemePartDefined(HTHEME hTheme, int iPartId, int iStateId)
{
    APIHELPER(L"IsThemePartDefined", hTheme);

    BOOL fDefined;
    
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    SetLastError(0);

    fDefined = pRender->IsPartDefined(iPartId, iStateId);

    return fDefined;
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeBackgroundPartiallyTransparent(HTHEME hTheme, int iPartId, int iStateId)
{
    APIHELPER(L"IsThemeBackgroundPartiallyTransparent", hTheme);

    BOOL fTrans = FALSE;
    HRESULT hr = S_OK;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;
    
    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            fTrans = pBorderFill->IsBackgroundPartiallyTransparent();
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            fTrans = pImageFile->IsBackgroundPartiallyTransparent(iStateId);
        }
    }
    
    SET_LAST_ERROR(hr);
    return fTrans;
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsAppThemed()
{
    APIHELPER(L"IsAppThemed", NULL);

    SetLastError(0);
    return g_pAppInfo->AppIsThemed(); 
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeDialogTextureEnabled(HWND hwnd)
{
    APIHELPER(L"IsThemeDialogTextureEnabled", NULL);

    SetLastError(0);
    INT_PTR iDialogTexture = (INT_PTR)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)));
    return iDialogTexture != 0; // If it's 1 or 2 then it's textured
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) GetThemeSysBool(OPTIONAL HTHEME hTheme, int iBoolId)
{
    APIHELPER(L"GetThemeSysBool", hTheme);
    BOOL fValue;

    CRenderObj *pRender = NULL;
    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    SetLastError(0);

    //---- check bool index limits ----
    if ((iBoolId < TMT_FIRSTBOOL) || (iBoolId > TMT_LASTBOOL))
    {
        fValue = FALSE;
        goto exit;
    }

    if (! pRender)
    {
        int iSpIndex;

        switch (iBoolId)
        {
            case TMT_FLATMENUS:
                iSpIndex = SPI_GETFLATMENU;
                break;

            default:
                Log(LOG_PARAMS, L"Unsupported system BOOL");
                fValue = FALSE;           // failed
                goto exit;
        }

        BOOL fGet = ClassicSystemParametersInfo(iSpIndex, 0, &fValue, 0);
        if (! fGet)
        {
            Log(LOG_ERROR, L"Error returned from ClassicSystemParametersInfo() getting a BOOL");
            fValue = FALSE;
        }

        goto exit;
    }

    fValue = pRender->_ptm->fBools[iBoolId - TMT_FIRSTBOOL];

exit:
    return fValue;
}
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL { if (FAILED(hr)) { SET_LAST_ERROR(hr); return 0; } }     // value functions
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) QueryThemeServices()
{
    APIHELPER(L"QueryThemeServices", NULL);

    DWORD dwBits;
    HRESULT hr = CThemeServices::GetStatusFlags(&dwBits);
    if (FAILED(hr))
        dwBits = 0;

    SET_LAST_ERROR(hr);
    return dwBits;
}
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF) GetThemeSysColor(OPTIONAL HTHEME hTheme, int iSysColorId)
{
    APIHELPER(L"GetThemeSysColor", hTheme);

    COLORREF crValue;
    CRenderObj *pRender = NULL;

    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    SetLastError(0);

    //---- keep orig & make our own version of ColorId ----
    int iThemeColorId = iSysColorId + TMT_FIRSTCOLOR;

    if ((iThemeColorId < TMT_FIRSTCOLOR) || (iThemeColorId > TMT_LASTCOLOR))
        iThemeColorId = TMT_FIRSTCOLOR;

    //---- make index 0-relative ----
    iThemeColorId -= TMT_FIRSTCOLOR;

    if (! pRender)
    {
        crValue = GetSysColor(iSysColorId);
    }
    else
    {
        crValue = pRender->_ptm->crColors[iThemeColorId];
    }

    return crValue;
}
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize96(HTHEME hTheme, int iSizeId)
{
    APIHELPER(L"GetThemeSysSize96", hTheme);

    SetLastError(0);

    CRenderObj *pRender = NULL;
    int iThemeSizeNum;
    int iValue = 0;

    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    HRESULT hr = GetThemeSizeId(iSizeId, &iThemeSizeNum);
    if (SUCCEEDED(hr))
    {
        //---- unscaled value ----
        iValue = pRender->_ptm->iSizes[iThemeSizeNum - TMT_FIRSTSIZE];
    }
    else
    {
        SET_LAST_ERROR(MakeError32(E_INVALIDARG));
    }

    return iValue;
}
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize(OPTIONAL HTHEME hTheme, int iSysSizeNum)
{
    APIHELPER(L"GetThemeSysSize", hTheme);

    SetLastError(0);

    CRenderObj *pRender = NULL;
    int iThemeSizeNum;
    int iValue = 0;

    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    HRESULT hr = S_OK;
    
    if (pRender)
    {
        hr = GetThemeSizeId(iSysSizeNum, &iThemeSizeNum);
        if (SUCCEEDED(hr))
        {
            iValue = pRender->_ptm->iSizes[iThemeSizeNum - TMT_FIRSTSIZE];

            //---- scale from 96 dpi to current screen dpi ----
            iValue = ScaleSizeForScreenDpi(iValue);
        }
        else
        {
            SET_LAST_ERROR(hr);
        }
    }
    else
    {
        iValue = ClassicGetSystemMetrics(iSysSizeNum);
    }

    return iValue;
}
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) GetThemeAppProperties()
{
    APIHELPER(L"GetThemeAppProperties", NULL);

    SetLastError(0);

    return g_pAppInfo->GetAppFlags();
}
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL { if (FAILED(hr)) { SET_LAST_ERROR(hr); return; } }     // null functions
//---------------------------------------------------------------------------
THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags)
{
    APIHELPER(L"SetThemeAppProperties", NULL);

    SetLastError(0);

    g_pAppInfo->SetAppFlags(dwFlags);
}
//---------------------------------------------------------------------------
//  --------------------------------------------------------------------------
//  ::CheckThemeSignature
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  CheckThemeSignature (LPCWSTR pszName)

{
    return CheckThemeFileSignature(pszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\shl3216.inc ===
; DWORD CallCPLEntry16(UINT hinst, DWORD lpfnEntry,
;                            HWND hwndCPL, UINT msg,
;                            DWORD lParam1, DWORD lParam2)

BODYQT_CALLCPLENTRY16 macro index

    local CPL_afMapping
    local do_callcplentry16
    local apm_map_explicit
    local before_call
    local call_the_bugger
    local no_unmapping

    hinst       equ   <[ebp_qttop]>
    lpfnEntry   equ   <[ebp_qttop+4]>
    hwndCPL     equ   <[ebp_qttop+8]>
    msg         equ   <[ebp_qttop+12]>
    lParam1     equ   <[ebp_qttop+16]>
    lParam2     equ   <[ebp_qttop+20]>

        ; skip past our table below to the meat of the routine
        jmp     do_callcplentry16

;
; This table indicates whether we need to thunk lParam2 or not.
;
CPL_afMapping	label byte
        db      0   ; CPL_INIT
        db      0   ; CPL_GETCOUNT
        db      1   ; CPL_INQUIRE      int, LPCPINFO
        db      0   ; CPL_SELECT       int, DWORD
        db      0   ; CPL_DBLCLK       int, DWORD
        db      0   ; CPL_STOP         int, DWORD
        db      0   ; CPL_EXIT
        db      1   ; CPL_NEWINQUIRE   int, LPNEWCPLINFO
        db      1   ; CPL_STARTWPARAMS int, LPSTR
CPL_MAX equ     ($-CPL_afMapping)

apm_map_explicit:
        inc     ecx                     ;explicitly set mapping flag
        jmp     before_call

do_callcplentry16:
        xor     ecx, ecx                ;ecx controls pointer mapping, init 0
        mov     edx, dword ptr msg      ;message index so we can decide

	; HACK: OEM APM extensions use entrypoints identical to CPlApplet,
	;	but have msgs needing special care.  Caller sets bit 15
	;	(0x8000) on these msgs.  Both msgs needing special care
	;	map identically to CPL_NEWINQUIRE
	test	edx, 8000h		;special APM msg?
	jnz	apm_map_explicit	;we will need to map

        ; use table above to determine mapping, assumes ecx is still zero
        dec     edx                     ;the table is 0 based
        cmp     edx, CPL_MAX            ;check for index within table
        jnc     before_call             ;let it through with no mapping

        ; move the correct mapping flag from our table into ecx
        mov     cl, byte ptr cs:[edx + CPL_afMapping]

before_call:
        push    ecx                     ;save mapping flag for thunk return
        jcxz    call_the_bugger         ;skip mapping if it's zero

        ; map lParam2 to 16:16
        push    dword ptr lParam2
        call    MapLS                   
        mov     dword ptr lParam2, eax  ;pass mapped result instead

call_the_bugger:
	push	word ptr hinst  	;hinst: dword->word
	push	dword ptr lpfnEntry	;lpfnEntry: dword->dword
	push	word ptr hwndCPL	;hwndCPL: dword->word
	push	word ptr msg    	;msg: dword->word
	push	dword ptr lParam1	;lParam1: dword->dword
	push	dword ptr lParam2	;lParam2: dword->dword
	mov	cl,index	        ;thunk index

	call	QT_Call16_DWordToDWord

        pop     ecx                     ;restore mapping flag from above
        jcxz    no_unmapping            ;skip unmapping if it's zero

        ; free 16:16 mapping for lParam2
        push     eax                    ;save CplApplet return value
	push	 dword ptr lParam2
	call	 UnMapLS
        pop      eax                    ;restore CplApplet return value

no_unmapping:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\win31err.inc ===
IFNDEF  _WIN31ERR_
_WIN31ERR_      EQU     1

;* Windows3.1 possible return value

W31RET_0                        EQU     0
W31RET_1                        EQU     1
W31RET_2                        EQU     2
W31RET_3                        EQU     3
W31RET_11                       EQU    11
W31RET_FFFF                     EQU    -1

ENDIF ; _WIN31ERR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\thk.inc ===
f16ptr  typedef ptr far16
f32ptr  typedef ptr far32


;==============================================================================
; BODY_PARAM_16
; Macro to generate equate for parameter on stack
;
;==============================================================================

BODY_PARAM_16 macro name, offset
name    equ <[bp+offsetThkParams+offset]>
        endm

;==============================================================================
; CB_THRU_COMMON
; Push address to be called and jump to common entry to 32bit code
;
;==============================================================================

CB_THRU_COMMON macro addr
        local   ret_addr
        local   log_msg_before
        local   log_msg_after

        externDef W32S_BackTo32:near32

ifdef DEBUG
LogCBThkSL  proto  near stdcall, psz:DWORD

        push    offset log_msg_before
        call    LogCBThkSL
endif

        push    ret_addr
        push    addr

; BUGBUG [KevinR] 12-Oct-1993
; This hardcoded offset is a hack for M5.  We should use a proper kernel
; dispatcher.
        assume  fs:nothing
Win16LockCount  equ  <word ptr fs:[30]> ; BUGBUG  from k32share.inc
        mov     di,-1
        xchg    di,Win16LockCount

        ; PERFORMANCE! is is possible to jump directly thru import thunk
        ; W32S_BackTo32 just does a retn
        jmp     W32S_BackTo32

ifdef DEBUG
log_msg_before  db  "SL before",0
log_msg_after   db  "SL after",0
endif

ret_addr:
        mov     Win16LockCount,di
        assume  fs:error

ifdef DEBUG
        push    offset log_msg_after
        call    LogCBThkSL
endif

        endm



;==============================================================================
; local macro, maps 32-bit pointer to 16-bit pointer,
;
; Guarantees:
;     If &SaveAddr& referenes di, the value of di entering MAP_POINTER
;     is used.
;==============================================================================
MAP_POINTER  macro   SaveAddr
    lodsd   ds:[esi]

    push    eax
    call    MapLS

ifnb <SaveAddr>
	mov	&SaveAddr&,eax
endif
    stosd   es:[di]              ; dst in 16:16 stack
endm

;==============================================================================
; local macro, clean up after MAP_POINTER.
;
; Guarantees:
;     If &SaveAddr& references si, the value of si entering UMAP_POINTER
;     is used.
;==============================================================================
UMAP_POINTER    macro   SaveAddr
ifnb <SaveAddr>
	push	es
	pushd	&SaveAddr&
	call	UnmapLS
	pop	    es
endif

    add     si,4
    add     edi,4
endm


;==============================================================================
; local macro, gets current process hInstance if null
; Win32/NT allows NULL hInstance where win3.1 doesn't
;
;==============================================================================
MAP_NULL_HINST  macro   hInst
        local   not_null
;        externDef GetNullhInst:far16
        externDef MaphInstLS:far16
        ifnb    <hInst>
        mov     eax, hInst
        endif
;        call    GetNullhInst
	call	MaphInstLS
not_null:
endm

;==============================================================================
; local macro, gets current process hInstance if null
; Win32/NT allows NULL hInstance where win3.1 doesn't
;
;==============================================================================
UMAP_NULL_HINST  macro   hInst
        local   not_null
        externDef MaphInstSL:far16
        ifnb    <hInst>
        mov     ax, hInst
        endif
	call	MaphInstSL
not_null:
endm



;==============================================================================
; Convert either an instance handle, a global Win16 handle or junk.
; Used by commdlg.
;==============================================================================
MAP_CD_NULL_HINST  macro   hInst,isInst
        local   not_inst,exit
	cmp	isInst,0
	jz	not_inst
	MAP_NULL_HINST	hinst
	jmp	exit
	
not_inst:  ;"hInst" is really 32-bit junk, or a zero-extended global handle.
	;; No need to do anything: "ax" already contains lo-word.
exit:
endm


;==============================================================================
; Convert either an instance handle, a global Win16 handle or junk.
; Used by commdlg.
;==============================================================================
UMAP_CD_NULL_HINST  macro   hInst,isInst
        local   not_inst,exit
	cmp	isInst,0
	jz	not_inst
	UMAP_NULL_HINST	hinst
	jmp	exit
	
not_inst:  ;"hInst" is really junk, or a global handle.
	ror	eax,16
	xor	ax,ax
	ror	eax,16
exit:
endm



;==============================================================================
; local macro, maps 32-bit call-back function pointer to 16-bit
; call back function pointer,
; check if it is a NULL pointer before calling AllocCallBack.
;==============================================================================
MAP_CALLBACK  macro   CallBackType:req
    lods    dword ptr ds:[esi]              ;wndproc must have a 16-bit
    push    bx                              ;save BX
    push    es                              ;save ES

    push    eax                             ;push address as parameter
    push    dword ptr CallBackType          ;push cb type as parameter
    call    AllocCallback                   ;DX:AX = 16-bit cb address
    pop     es                              ;restore ES
    pop     bx                              ;restore BX

    stos    dword ptr es:[di]               ;pass on NULL pointer
endm

;==============================================================================
; local macro, free resources allocated for a call-back function
; check if it is a NULL pointer before calling FreeCallBack.
; eax contains the 32-bit address of the mapped call-back function
;==============================================================================
FREE_CALLBACK  macro    iCallbackType:req
endm

;==============================================================================
; local macro, maps byte size field to byte size field
;==============================================================================
MAP_BYTETOBYTE  macro
    lodsb   ds:[esi]
    stosb   es:[di]
endm

;==============================================================================
; local macro, maps byte size field to byte size field
;==============================================================================
UMAP_BYTETOBYTE  macro
    lodsb   ds:[si]
    stosb   es:[edi]
endm

;==============================================================================
; local macro, maps word size field to word size field
;==============================================================================
MAP_WORDTOWORD  macro
    lodsw   ds:[esi]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps word size field to word size field
;==============================================================================
UMAP_WORDTOWORD  macro
    lodsw   ds:[si]
    stosw   es:[edi]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
MAP_DWORDTOWORD  macro
    lodsd   ds:[esi]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
UMAP_WORDTODWORD  macro
    lodsw   ds:[si]
    movzx   eax,ax
    stosd   es:[edi]
endm

;==============================================================================
; local macro, maps long size field to int size field
;==============================================================================
MAP_LONGTOINT  macro
    lodsd   ds:[esi]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps int size field to long size field
;==============================================================================
UMAP_INTTOLONG  macro
    lodsw   ds:[si]
    cwde
    stosd   es:[edi]
endm

;==============================================================================
; local macro, maps dword size field to dword size field
;==============================================================================
MAP_DWORDTODWORD  macro
    movsd   es:[di], ds:[esi]
endm

;==============================================================================
; local macro, maps dword size field to dword size field
;==============================================================================
UMAP_DWORDTODWORD  macro
    movsd   es:[edi], ds:[si]
endm

;==============================================================================
; The following are variants of the above macros that are better suited for
; repacking structures in-place.
;==============================================================================

;==============================================================================
; local macro, maps 32-bit call-back function pointer to 16-bit
; call back function pointer,
; check if it is a NULL pointer before calling AllocCallBack.
;==============================================================================
MAP_CALLBACK_32_16_IP  macro   reg:=<ds>,CallBackType:req
    lods    dword ptr reg:[si]              ;wndproc must have a 16-bit

    push    bx
    push    es
    push    eax
    push    dword ptr CallBackType
    call    AllocCallback
    pop     es
    pop     bx

    stosd
endm

;==============================================================================
; local macro, maps 16-bit call-back function pointer to 32-bit
; call back function pointer,
; check if it is a NULL pointer before calling AllocCallback.
;
; ASSUMES DIRECTION FLAG DOWN, i.e. STD.
;==============================================================================
MAP_CALLBACK_16_32_IP  macro   reg:=<ds>,CallBackType:req
    lods    dword ptr reg:[si]              ;wndproc must have a 16-bit

    push    bx
    push    es
    push    eax
    push    dword ptr CallBackType
    call    AllocCallback32
    pop     es
    pop     bx

    stosd
endm

;==============================================================================
; local macro, maps 32-bit pointer to 16-bit pointer,
;==============================================================================
MAP_POINTER_32_16_IP  macro   reg:=<ds>
    lodsd   reg:[si]
    push    eax
    call    MapLS
    stosd   es:[di]
endm


;==============================================================================
; MAP_HINST_32_16_IP
; Map an instance handle from 32->16 in-place.  If the original value is 0,
; replace it with the instance handle from win32s16.dll.
;
; Assumes ds = _DATA.
;==============================================================================
MAP_HINST_32_16_IP macro reg:=<ds>
        local   have_hinst

        lods    dword ptr reg:[si]              ; convert hinst to word
        or      ax,ax                           ; translate to hComboInst if
        jnz     have_hinst                      ;     null
        mov     ax,hComboInst
have_hinst:
        stosw
endm

;==============================================================================
; MAP_HINST_16_32_IP
; Map an instance handle from 16->32 in-place.  If the original value is
; hComboInst, replace it with 0.
;
; Assumes ds = _DATA.
;==============================================================================
MAP_HINST_16_32_IP macro reg:=<ds>
        local   have_hinst

        lods    word ptr reg:[si]               ; convert hinst to word
        cmp     ax,hComboInst                   ; translate to null if
        jnz     have_hinst                      ;     hComboInst
        sub     ax,ax
have_hinst:
        movzx   eax,ax
        stosd
endm

;==============================================================================
; local macro, maps word size field to word size field
;==============================================================================
MAP_WORDTOWORD_IP  macro        reg:=<ds>
    movsw   es:[di], reg:[si]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
MAP_DWORDTOWORD_IP  macro reg:=<ds>
    lodsd   reg:[si]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
MAP_LONGTOINT_IP  macro reg:=<ds>
    lodsd   reg:[si]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps dword size field to dword size field
;==============================================================================
MAP_DWORDTODWORD_IP  macro      reg:=<ds>
    movsd   es:[di], reg:[si]
endm

;==============================================================================
; local macro, maps word size field to dword size field by zero-extension
;==============================================================================
MAP_WORDTODWORD_IP  macro reg:=<ds>
    lodsw   reg:[si]
    movzx   eax,ax
    stosd   es:[di]
endm

;==============================================================================
; local macro, maps word size field to dword size field by sign-extension
;==============================================================================
MAP_INTTOLONG_IP  macro reg:=<ds>
    lodsw   reg:[si]
    cwde
    stosd   es:[di]
endm

;==============================================================================
; save all 16-bit registers, except dx:ax
;
;==============================================================================
SAVEALL     macro
    push    cx      ; save all 16-bit registers, except dx:ax
    push    bx
    push    bp
    push    si
    push    di
    push    ds
    push    es
endm


;==============================================================================
; restore all 16-bit registers, except dx:ax
;
;==============================================================================
RESTOREALL  macro  StackType:=<Stack16>
    POPW    es      ; restore all 16-bit registers, except dx:ax

    CHECKW  ds, StackType
    POPW    ds
    CHECKW  di, StackType
    pop     di

    CHECKW  si, StackType
    pop     si
    CHECKW  bp, StackType
    pop     bp

    pop     bx
    pop     cx
endm


;==============================================================================
; save all 32-bit registers, except eax
;
;==============================================================================
SAVEALL32     macro
    push    edx         ;save all 32-bit registers except eax
    push    ecx
    push    ebx
    push    ebp
    push    esi
    push    edi
    push    ds
    push    es
endm


;==============================================================================
; restore all 32-bit registers, except eax
;
;==============================================================================
RESTOREALL32  macro  StackType:=<Stack16>
    POPD    es      ; restore all 32-bit registers, except eax

    CHECKD  ds, StackType
    POPD    ds
    CHECKD  edi, StackType
    pop     edi
    CHECKD  esi, StackType
    pop     esi
    CHECKD  ebp, StackType
    pop     ebp
    CHECKD  ebx, StackType
    pop     ebx

    pop     ecx
    pop     edx
endm


;==============================================================================
; test two text macros for equality
;
;
;==============================================================================
TextEqual? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <not 0>
    endif
    exitm <0>
endm


;==============================================================================
; test two text macros for difference
;
;
;==============================================================================
TextDiff? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <0>
    endif
    exitm <not 0>
endm


;==============================================================================
; check a word on top of the stack
; if not equal, break
;
;==============================================================================
CHECKW    macro   CurrentReg, StackType:=<Stack16>
    local   skip_int3
    local   skip_another_int3

    if (@WordSize eq 4) and TextDiff? (&StackType&,Stack16)
    push    eax
    mov     ax,&CurrentReg&
    cmp     ax,word ptr [esp+4]
    pop     eax
    je      skip_int3
    int     3
skip_int3:
    else


    push    bp
    push    ax
    mov     ax,&CurrentReg&
    mov     bp,sp
    and     ebp,0ffffh
    cmp     ax,word ptr [ebp+4]
    pop     ax
    pop     bp
    je      skip_another_int3
    int     3
skip_another_int3:
    endif

endm


;==============================================================================
; check a dword on top of the stack
; if not equal, break
;
;==============================================================================
CHECKD    macro   CurrentReg, StackType:=<Stack32>
    local   skip_int3
    local   skip_another_int3

if 0
;!!! fix this
    if (@WordSize eq 4) and TextDiff? (&StackType&,Stack32)
    push    eax
    mov     ax,&CurrentReg&
    cmp     ax,word ptr [esp+4]
    pop     eax
    je      skip_int3
    int     3
skip_int3:
    else


    push    bp
    push    ax
    mov     ax,&CurrentReg&
    mov     bp,sp
    and     ebp,0ffffh
    cmp     ax,word ptr [ebp+4]
    pop     ax
    pop     bp
    je      skip_another_int3
    int     3
skip_another_int3:
    endif
endif
endm


;==============================================================================
; pop word
;
;==============================================================================
POPW    macro   SegReg
    if @WordSize eq 4
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; pop dword
;
;==============================================================================
POPD    macro   SegReg
    if @WordSize eq 2
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; operand-size override
;
;==============================================================================
OTHER_OPERAND_SIZE  macro   arg
    db  66h
    arg
endm


;==============================================================================
; address-size override
;
;==============================================================================
OTHER_ADDRESS_SIZE  macro   arg
    db  67h
    arg
endm


;==============================================================================
; pop 16
;
;==============================================================================
POP16    macro   Reg
    if @WordSize eq 4
        irp curreg,<cs,ds,ss,es,fs,gs>
           ifidni <curreg>,<Reg>
                db      66h
           endif
        endm
    endif
    pop     Reg
endm


;==============================================================================
; allocate and public a byte flag
;
;==============================================================================
PubByte  macro   name, value
    public  name
    name    db      value
endm





;==============================================================================
; log a 16=>32 api call
;
;==============================================================================
APILOGSL  macro   argName
        local   exit,szLogMsg

ifdef DEBUG

LogApiThkSL	proto	near stdcall, psz:dword

        push    offset szLogMsg
        call    LogApiThkSL
	jmp	exit

szLogMsg  db	'&argName&',13,10,0

exit:
endif
endm



;==============================================================================
; log a 32=>16 api call, non-flat
;
;==============================================================================
APILOGLS  macro   argName
        local   exit,szLogMsg

ifdef DEBUG
externDef LogApiThkLS:far16

        push    ax

	push	cs
	push	offset szLogMsg
        call    LogApiThkLS

        pop     ax
	jmp	exit

szLogMsg  db	'&argName&',13,10,0

exit:
endif
endm



;==============================================================================
; log an api call, 16-bit
;
; BUGBUG [KevinR] 26-Aug-1993
; rip out this macro when we get rid of fNewDispatcherLS
;
;==============================================================================
APILOG16  macro   argName, argUnused, argComment
        local   exit,szApiName,szComment

ifdef DEBUG
externDef Log16BitThunkCall:far16

dsOffsetInCS CATSTR @code, <CodeData>

        push    ds
        push    ax
        mov     ds,cs:dsOffsetInCS

        push    cs
        push    offset szApiName
	push	cs
	push	offset szComment
        call    Log16BitThunkCall
        pop     ax
        pop     ds
	jmp	exit

szApiName db	'&argName& ',0
szComment db	'&argComment& ',0

exit:
endif
endm



;==============================================================================
; log an api call, 32-bit
;
;==============================================================================
APILOG  macro   argName, argFlag
        local   do_it,done,szApiName
ifdef DEBUG
;externDef _DbgPrint:near32

        ;;If argFlag is nonzero, print out the message.
        cmp     argFlag&,0
        jnz     do_it
        jmp     short done
;;Define the name here so we can pass it to _DbgPrint.
szApiName db '&argName&',0
do_it:
        push    offset FLAT:szApiName
        push    offset FLAT:szApiFmt
        ;call    _DbgPrint
        add     esp,2*4
done:
endif
endm


;==============================================================================
; log 16-bit api return, in 32-bit code
;
;==============================================================================
RETLOG  macro   argFlag
endm



;==============================================================================
; conditionally break
;
;==============================================================================
SWITCHABLE_INT3 macro argLabel, argFlag
        local   skip_int3

externDef   argLabel :far16

        push    ds
        push    ax
        mov     ax,seg &argFlag
        mov     ds,ax
        cmp     &argFlag,0
        je      skip_int3
argLabel& label far16
        int     3
skip_int3:
        pop     ax
        pop     ds
endm


;==============================================================================
;
;
;==============================================================================
STUB0   macro   module, argLabel, nBytes, argComment:=<stub0>
externDef   argLabel&16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        xor     ax,ax
        cwd
ifdef FSAVEALL
        RESTOREALL
endif
        retf    &nBytes&
endm


;==============================================================================
;
;
;==============================================================================
STUB    macro   module, argLabel, nBytes, nRetAX, argComment:=<stub>
externDef   argLabel&16 :far16
externDef   PCodeDebug16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment nRetAX
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        mov     ax,&nRetAX
ifdef FSAVEALL
        RESTOREALL
endif
        retf    nBytes
endm

;==============================================================================
; entry code for flat common callback
;
;==============================================================================
CALLBACK_PROLOGUE   macro

        pop     eax                     ; 16:16 callback
        pop     edx                     ; eip, API32

        push    cs                      ; flat cs
        push    edx                     ; eip, API32
        push    eax                     ; 16:16 callback

        push    ebp
        mov     ebp,esp

        push    ds                      ; save registers
        push    es
        push    ebx
        push    edi
        push    esi
endm


;==============================================================================
; exit code for flat common callback
;
;==============================================================================
CALLBACK_EPILOGUE   macro   size

        LOCAL   bad_esp

;--------------------------------------------------
; switch stacks and jump to 16:16 callback

; when the 16:16 callback does a retf, we will hit our cleanup routine

        push    dword ptr ADDR_THK_CLEANUP_&size

; prepare to transfer to the 16-bit callback function

        push    pCallback16

; get the ss16 we had when we entered the callback API16
; make the 16-bit ss:sp point to the same linear address as the flat ss:esp

        call    UsrQuerySS16
        mov     esi,eax                 ; save ss16
        push    eax
        call    GetSelectorBase32       ; LATER: LDT lookup
        xchg    eax,esp
        sub     eax,esp
        jb      bad_esp
        cmp     eax,65535
        ja      bad_esp

        mov     ss,si
        mov     sp,ax

; effectively, jmp to 16:16 callback
        retw

bad_esp:
        int     3

endm




;==============================================================================
; save flat stack and thunkID
;
;==============================================================================
SAVE_STACK_AND_THUNKID  macro

        lea     eax,[addr_registers]    ; save flat stack
        push    ss
        push    eax

        call    GetThunkID32
        push    eax                     ; save 16:16 thunkID
endm

;==============================================================================
; 32-bit callback cleanup code
;
;==============================================================================
CALLBACK_CLEANUP32    macro   size
externDef CALLBACK_CLEANUP_&size&:near32
CALLBACK_CLEANUP_&size&:
;;;-----------------------------------------------------------------------
;;; DO NOT REMOVE THE OVERRIDE PREFIX. IT IS NEEDED TO GET PAST A BUG
;;; IN A CERTAIN BRAND OF CLONE CHIPS.
;;;-----------------------------------------------------------------------
        lss     sp,ss:[ebx]
        POP16   ds
        POP16   di
        POP16   si
        POP16   bp

        add     sp, 8                   ; pop dispatcher ptr+index


        OTHER_OPERAND_SIZE
        retf    size                    ; return to the 16-bit API
endm


;==============================================================================
; SetLastError mechanism
;
;==============================================================================
SETERROR     macro   Value:req, Error:req
        local   done

externDef SetLastError16:far16
        cmp     ax,Value
        jne     short done

        push    dword ptr Error
        call    SetLastError16
done:
endm

;-----------------------------------------------------------------------;
; MoveBytes -- generate code to move n consecutive bytes
;
; Entry:
;       DS:ESI --> source
;       ES:EDI --> destination
;-----------------------------------------------------------------------;
MoveBytes       macro   n
    local q, r

    q = n / 4
    r = n and 3

    if q
        if q lt 256
            mov     ecx,byte ptr q
        else
            mov     ecx,q
        endif
        rep     movs dword ptr es:[edi], dword ptr ds:[esi]
    endif

    if r
        mov     ecx,byte ptr r
        rep     movs byte ptr es:[edi], byte ptr ds:[esi]
    endif
endm

;-----------------------------------------------------------------------;
; ZeroBytes -- generate optimized code to set n consecutive bytes to 0
;
; Entry:
;       ES:EDI --> address at which to start
;-----------------------------------------------------------------------;
ZeroBytes       macro   n
    local q, r

    q = n / 4
    r = n and 3

        sub     eax,eax
    if q
        if q lt 256
            mov     ecx,byte ptr q
        else
            mov     ecx,q
        endif
        rep     stos dword ptr es:[edi]
    endif

    if r
        mov     ecx,byte ptr r
        rep     stos byte ptr es:[edi]
    endif
endm

;-----------------------------------------------------------------------;
; GMH2Sel
;
; This macro encapsulates the assumption that a global memory handle
; in win3.1 is either a selector (if fixed) or a selector with the
; low bit cleared (if moveable).  Therefore, it can be turned into a
; selector by always setting the low bit.
;-----------------------------------------------------------------------;
GMH2Sel         macro   reg:req, regMask1, regMask2
    ifb <regMask1>
        or      reg,1
    else
        .errb <regMask2>

        ;The following sequence uses two mask registers to
        ;convert only non-zero values of "reg" to selectors.
        mov     regMask1,1              ;mov cx,1
        cmp     reg,regMask1            ;cmp ax,cx      C=1 if AX=0
        cmc                             ;cmc            C=0 if AX=0
        sbb     regMask2,regMask2       ;sbb dx,dx      DX=0 if AX=0
        and     regMask1,regMask2       ;and cx,dx      CX=0 if AX=0
        or      reg,regMask1            ;or  ax,cx      AX=0 if AX=0
    endif
endm



;-----------------------------------------------------------------------;
; PACK_CALLBACK 
;-----------------------------------------------------------------------;

PACK_CALLBACK	macro	iOffset,iTempOffset,dwCallbackType

	local	exit
	local	not_null

	mov	esi,[bp+&iOffset&]
	or	esi,esi
	jnz	not_null

	sub	sp,18		;Space the thunklet would have taken
	jmp	exit

not_null:
; Push the following code on the stack:
;
;  66 68 xx xx xx xx    push  imm32 <flat lpCallback>
;  66 68 xx xx xx xx	push  imm32 <dwCallbackType>
;  90			nop		;for convenient
;  EA xx xx xx xx	jmp   CALLBACK_BODY_16

	mov	ax,seg CALLBACK_BODY_16
	push	ax
	mov	ax,offset CALLBACK_BODY_16
	push	ax
	push	0ea90h

	push	dword ptr &dwCallbackType&
	push	6866h

	push	esi
	push	6866h

	push	ss
	call	GetCSAlias
	mov	[bp-&iTempOffset&],sp
	mov	[bp-(&iTempOffset&)+2],ax

exit:

	
endm; PACK_CALLBACK


;-----------------------------------------------------------------------;
; UNPACK_CALLBACK 
;-----------------------------------------------------------------------;

UNPACK_CALLBACK	macro	iOffset,iTempOffset,dwCallbackType


	push	word ptr [bp-&iTempOffset&+2]
	call	FreeCSAlias


endm; UNPACK_CALLBACK




;-----------------------------------------------------------------------;
; TILE_BUFFER
;
;   Allocates overlapping tiling selectors for a huge memory block.
;
;   Inputs:
;       eax:        32-bit linear address (NULL is allowed)
;       ecx:        32-bit buffer size (if 0, eax is treated as NULL)
;
;   Outputs:
;	eax:	    upper 16 bits = first selector
;		    lower 16 bits = 0 (thus, eax is the 16:16 pointer)
;	ecx:	    upper 16 bits = first selector (same as upper eax)
;		    lower 16 bits = # of selectors allocated
;	CF:	    0 = success, 1 = failure.
;
;   Registers preserved:
;       bp, sp, all segment registers.
;
;   Special cases:
;       if buffer address is NULL or the size is 0, macro returns 
;          eax == ecx == 0, CF = 0.
;       if macro fails, it returns eax == 0, CF = 1.
;
;   Use UNTILE_BUFFER to deallocate tiling selectors.
;-----------------------------------------------------------------------;

TILE_BUFFER	macro
	extern	TileBuffer:far16	;Dynalink to win32c.dll
	call	TileBuffer
endm	;TILEBUFFER



;-----------------------------------------------------------------------;
; UNTILE_BUFFER
;
;   Releases tiling selectors allocated by TILE_BUFFER.
;
;   Inputs:
;	ecx == sel:count (as returned by TILE_BUFFER. 00:00 is legal).
;
;   Outputs:
;       None.
;
;   Registers preserved:
;       bp, sp, all segment registers
;
;   Special case:
;       UNTILE_BUFFER does nothing if sel:count == 00:00.
;-----------------------------------------------------------------------;
UNTILE_BUFFER	macro
	extern	UntileBuffer:far16	;Dynalink to win32c.dll
	call	UntileBuffer
endm	;UNTILE_BUFFER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\balloon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	balloon.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\balloon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _WIN32_WINNT 0x0501
#define _WIN32_IE    0x0501

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\balloon\balloon.cpp ===
#include "stdafx.h"

#include <shlobj.h>
#include <shellapi.h>

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[1]))

// Jay Simmons
// There are two ways to use the session moniker
// one is via IMoniker::BindToObject, the other IClassActivator::GetClassObject.   
// IMoniker::BindToObject has an advantage in that it will work remotely.    
// More importantly, the syntax that I mention below is different for the two methods.   
// For BindToObject, you must use the full syntax as I describe below.  
// For IClassActivator, the clsid is passed in on the GetClassObject call and so 
// the syntax is reduced to "Session:7" or "Session:Console".

HRESULT CoCreateOnConsoleWithBindToObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    *ppv = NULL;
    
    IBindCtx* pbc;
    HRESULT hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr)) 
    {
        WCHAR sz[128], szClsid[64];
        
        StringFromGUID2(rclsid, szClsid, ARRAYSIZE(szClsid)); 
        LPWSTR psz = szClsid + 1;   // skip "{"
        while (*psz != L'}') 
            psz++;
        *psz = NULL;
        
        lstrcpyW(sz, L"Session:Console!clsid:");
        lstrcatW(sz, &szClsid[1]);
        
        // Parse the name and get a moniker:
        ULONG ulEaten;
        IMoniker* pmk;
        hr = MkParseDisplayName(pbc, sz, &ulEaten, &pmk);
        if (SUCCEEDED(hr))
        {
            IClassFactory *pcf;
            hr = pmk->BindToObject(pbc, NULL, IID_PPV_ARG(IClassFactory, &pcf));
            if (SUCCEEDED(hr))
            {
                hr = pcf->CreateInstance(NULL, riid, ppv);
                pcf->Release();
            }
            pmk->Release();
        }
        pbc->Release();
    }
    return hr;
}

HRESULT CoCreateInSession(ULONG ulSessId, REFCLSID rclsid, DWORD dwClsContext, REFIID riid, void** ppv)
{
    *ppv = NULL;
    
    IBindCtx* pbc;
    HRESULT hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr)) 
    {
        // Form display name string
        WCHAR szDisplayName[64];
        if (-1 == ulSessId)
        {
            lstrcpyW(szDisplayName, L"Session:Console");
        }
        else
        {
            wsprintfW(szDisplayName, L"Session:%d", ulSessId);
        }
        
        // Parse the name and get a moniker:
        ULONG ulEaten;
        IMoniker* pmk;
        hr = MkParseDisplayName(pbc, szDisplayName, &ulEaten, &pmk);
        if (SUCCEEDED(hr))
        {
            IClassActivator* pclsact;
            hr = pmk->QueryInterface(IID_PPV_ARG(IClassActivator, &pclsact));
            if (SUCCEEDED(hr))
            {
                IClassFactory* pcf;
                hr = pclsact->GetClassObject(rclsid, dwClsContext, GetSystemDefaultLCID(), IID_PPV_ARG(IClassFactory, &pcf));
                if (SUCCEEDED(hr))
                {
                    hr = pcf->CreateInstance(NULL, riid, ppv);
                    pcf->Release();
                }
                pclsact->Release();
            }
            pmk->Release();
        }
        pbc->Release();
    }
    return hr;
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    
    HRESULT hr;

    // Sleep(5 * 1000);
    
    IUserNotification *pun;
    //hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUserNotification, &pun));
    //hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUserNotification, &pun));
    //hr = CoCreateInSession(WTSGetActiveConsoleSessionId(), CLSID_UserNotification, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUserNotification, &pun));
    //hr = CoCreateOnConsoleWithBindToObject(CLSID_UserNotification, IID_PPV_ARG(IUserNotification, &pun));
    hr = CoCreateInSession((ULONG)-1, CLSID_UserNotification, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUserNotification, &pun));
    if (SUCCEEDED(hr))
    {
        pun->PlaySound(L"SystemExit");

        pun->SetBalloonRetry(120 * 1000, 0, 0);
        WCHAR szTitle[128];
        wsprintfW(szTitle, L"ProcessID: %d, ActiveConsoleID: %d", GetCurrentProcessId(), WTSGetActiveConsoleSessionId());
        pun->SetIconInfo(LoadIcon(NULL, IDI_WINLOGO), szTitle);
        pun->SetBalloonInfo(szTitle, L"Balloon Text... 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 ", NIIF_INFO);
        
        hr = pun->Show(NULL, 0);
        
        pun->Release();
    }
    else
    {
        TCHAR szErr[128];
        wsprintf(szErr, TEXT("hr:%x"), hr);
        MessageBox(NULL, TEXT("Error"), szErr, MB_OK);
    }
    
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\thunk\winerror.inc ===
IFNDEF  _WINERROR_
_WINERROR_      EQU     1

;* DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
;* API functions.

; ** Error codes

NO_ERROR                        EQU     0

ERROR_INVALID_FUNCTION          EQU     1
ERROR_FILE_NOT_FOUND            EQU     2
ERROR_PATH_NOT_FOUND            EQU     3
ERROR_TOO_MANY_OPEN_FILES       EQU     4
ERROR_ACCESS_DENIED             EQU     5
ERROR_INVALID_HANDLE            EQU     6
ERROR_ARENA_TRASHED             EQU     7
ERROR_NOT_ENOUGH_MEMORY         EQU     8
ERROR_INVALID_BLOCK             EQU     9
ERROR_BAD_ENVIRONMENT           EQU     10
ERROR_BAD_FORMAT                EQU     11
ERROR_INVALID_ACCESS            EQU     12
ERROR_INVALID_DATA              EQU     13

ERROR_INVALID_DRIVE             EQU     15
ERROR_CURRENT_DIRECTORY         EQU     16
ERROR_NOT_SAME_DEVICE           EQU     17
ERROR_NO_MORE_FILES             EQU     18

; These are the universal int 24 mappings for the old INT 24 set of errors
ERROR_WRITE_PROTECT             EQU     19
ERROR_BAD_UNIT                  EQU     20
ERROR_NOT_READY                 EQU     21
ERROR_BAD_COMMAND               EQU     22
ERROR_CRC                       EQU     23
ERROR_BAD_LENGTH                EQU     24
ERROR_SEEK                      EQU     25
ERROR_NOT_DOS_DISK              EQU     26
ERROR_SECTOR_NOT_FOUND          EQU     27
ERROR_OUT_OF_PAPER              EQU     28
ERROR_WRITE_FAULT               EQU     29
ERROR_READ_FAULT                EQU     30
ERROR_GEN_FAILURE               EQU     31

; These are the new 3.0 error codes reported through INT 24
ERROR_SHARING_VIOLATION         EQU     32
ERROR_LOCK_VIOLATION            EQU     33
ERROR_WRONG_DISK                EQU     34
; ERROR_FCB_UNAVAILABLE		 EQU	 35
; ERROR_SHARING_BUFFER_EXCEEDED	 EQU	 36
; End of INT 24 reportable errors

ERROR_HANDLE_EOF		EQU	38
ERROR_HANDLE_DISK_FULL		EQU	39


; Network related errors
ERROR_NOT_SUPPORTED		EQU	50 ; Network request not supported
ERROR_REM_NOT_LIST              EQU     51 ; Remote computer not listening
ERROR_DUP_NAME                  EQU     52 ; Duplicate name on network
ERROR_BAD_NETPATH               EQU     53 ; Network path not found
ERROR_NETWORK_BUSY              EQU     54 ; Network busy
ERROR_DEV_NOT_EXIST             EQU     55 ; Network device no longer exists
ERROR_TOO_MANY_CMDS             EQU     56 ; Net BIOS command limit exceeded
ERROR_ADAP_HDW_ERR              EQU     57 ; Network adapter hardware error
ERROR_BAD_NET_RESP              EQU     58 ; Incorrect response from network
ERROR_UNEXP_NET_ERR             EQU     59 ; Unexpected network error
ERROR_BAD_REM_ADAP              EQU     60 ; Incompatible remote adapter
ERROR_PRINTQ_FULL               EQU     61 ; Print queue full
ERROR_NO_SPOOL_SPACE            EQU     62 ; Not enough space for print file
ERROR_PRINT_CANCELLED           EQU     63 ; Print file was cancelled
ERROR_NETNAME_DELETED           EQU     64 ; Network name was deleted
ERROR_NETWORK_ACCESS_DENIED     EQU     65 ; Access denied
ERROR_BAD_DEV_TYPE              EQU     66 ; Network device type incorrect
ERROR_BAD_NET_NAME              EQU     67 ; Network name not found
ERROR_TOO_MANY_NAMES            EQU     68 ; Network name limit exceeded
ERROR_TOO_MANY_SESS             EQU     69 ; Net BIOS session limit exceeded
ERROR_SHARING_PAUSED            EQU     70 ; Sharing temporarily paused
ERROR_REQ_NOT_ACCEP             EQU     71 ; Network request not accepted
ERROR_REDIR_PAUSED              EQU     72 ; Print|disk redirection is paused
ERROR_FILE_EXISTS               EQU     80
; ERROR_DUP_FCB			 EQU	 81
ERROR_CANNOT_MAKE               EQU     82
ERROR_FAIL_I24                  EQU     83

; New 3.0 network related error codes
ERROR_OUT_OF_STRUCTURES         EQU     84
ERROR_ALREADY_ASSIGNED          EQU     85
ERROR_INVALID_PASSWORD          EQU     86
ERROR_INVALID_PARAMETER         EQU     87
ERROR_NET_WRITE_FAULT           EQU     88

; New error codes for 4.0
ERROR_NO_PROC_SLOTS		EQU	89 ; no process slots available

; ERROR_NOT_FROZEN		 EQU	 90
; ERR_TSTOVFL			  EQU	  91 ; timer service table overflow
; ERR_TSTDUP			  EQU	  92 ; timer service table duplicate
; ERROR_NO_ITEMS		  EQU	  93 ; no items to operate upon
; ERROR_INTERRUPT		  EQU	  95 ; interrupted system call
; ERROR_DEVICE_IN_USE		  EQU	  99 ; Device in use by another thread
ERROR_TOO_MANY_SEMAPHORES       EQU     100
ERROR_EXCL_SEM_ALREADY_OWNED    EQU     101
ERROR_SEM_IS_SET                EQU     102
ERROR_TOO_MANY_SEM_REQUESTS     EQU     103
ERROR_INVALID_AT_INTERRUPT_TIME EQU     104
ERROR_SEM_OWNER_DIED            EQU     105 ; waitsem found owner died
ERROR_SEM_USER_LIMIT            EQU     106 ; too many procs have this sem
ERROR_DISK_CHANGE		EQU	107 ; insert disk b into drive a
ERROR_DRIVE_LOCKED              EQU     108 ; drive locked by another process
ERROR_BROKEN_PIPE               EQU     109 ; write on pipe with no reader

; New error codes for OS/2 */
ERROR_OPEN_FAILED               EQU     110 ; open/created failed due to
                                            ; explicit fail command
ERROR_BUFFER_OVERFLOW           EQU     111 ; buffer passed to system call
                                            ;  is too small to hold return
                                            ;  data.
ERROR_DISK_FULL                 EQU     112 ; not enough space on the disk
                                            ;  (DOSNEWSIZE/w_NewSize)
ERROR_NO_MORE_SEARCH_HANDLES    EQU     113 ; can't allocate another search
                                            ;  structure and handle.
                                            ;  (DOSFINDFIRST/w_FindFirst)
ERROR_INVALID_TARGET_HANDLE     EQU     114 ; Target handle in DOSDUPHANDLE
                                            ;  is invalid
; ERROR_PROTECTION_VIOLATION	  EQU	  115 ; Bad user virtual address
; ERROR_VIOKBD_REQUEST		  EQU	  116
ERROR_INVALID_CATEGORY	  EQU	  117 ; Category for DEVIOCTL in not
					      ;  defined
ERROR_INVALID_VERIFY_SWITCH     EQU     118 ; invalid value passed for
                                            ;  verify flag
ERROR_BAD_DRIVER_LEVEL          EQU     119 ; DosDevIOCTL looks for a level
                                            ;  four driver. If the driver
                                            ;  is not level four we return
                                            ;  this code
ERROR_CALL_NOT_IMPLEMENTED      EQU     120 ; returned from stub api calls.
                                            ;  This call will disappear when
                                            ;  all the api's are implemented.
ERROR_SEM_TIMEOUT               EQU     121 ; Time out happened from the
                                            ;  semaphore api functions.
ERROR_INSUFFICIENT_BUFFER       EQU     122 ; Some calls require the
                                            ;  application to pass in a buffer
                                            ;  filled with data.  This error is
                                            ;  returned if the data buffer is too
                                            ;  small.  For example: DosSetFileInfo
                                            ;  requires 4 bytes of data.  If a
                                            ;  two byte buffer is passed in then
                                            ;  this error is returned.
                                            ;  error_buffer_overflow is used when
                                            ;  the output buffer in not big enough.
ERROR_INVALID_NAME              EQU     123 ; illegal character or malformed
                                            ; file system name
ERROR_INVALID_LEVEL             EQU     124 ; unimplemented level for info
                                            ; retrieval or setting
ERROR_NO_VOLUME_LABEL           EQU     125 ; no volume label found with
                                            ; DosQFSInfo command
ERROR_MOD_NOT_FOUND             EQU     126 ; w_getprocaddr,w_getmodhandle
ERROR_PROC_NOT_FOUND            EQU     127 ; w_getprocaddr
; ERROR_WAIT_NO_CHILDREN	 EQU	 128 ; CWait finds to children
ERROR_CHILD_NOT_COMPLETE        EQU     129 ; CWait children not dead yet
ERROR_DIRECT_ACCESS_HANDLE      EQU     130 ; handle operation is invalid
                                            ; for direct disk access
                                            ; handles
ERROR_NEGATIVE_SEEK             EQU     131 ; application tried to seek
                                            ; with negitive offset
ERROR_SEEK_ON_DEVICE            EQU     132 ; application tried to seek
                                            ; on device or pipe

; The following are errors generated by the join and subst workers
ERROR_IS_JOIN_TARGET            EQU     133
ERROR_IS_JOINED                 EQU     134
ERROR_IS_SUBSTED                EQU     135
ERROR_NOT_JOINED                EQU     136
ERROR_NOT_SUBSTED               EQU     137
ERROR_JOIN_TO_JOIN              EQU     138
ERROR_SUBST_TO_SUBST            EQU     139
ERROR_JOIN_TO_SUBST             EQU     140
ERROR_SUBST_TO_JOIN             EQU     141
ERROR_BUSY_DRIVE                EQU     142
ERROR_SAME_DRIVE                EQU     143
ERROR_DIR_NOT_ROOT              EQU     144
ERROR_DIR_NOT_EMPTY             EQU     145
ERROR_IS_SUBST_PATH             EQU     146
ERROR_IS_JOIN_PATH              EQU     147
ERROR_PATH_BUSY                 EQU     148
ERROR_IS_SUBST_TARGET           EQU     149
ERROR_SYSTEM_TRACE              EQU     150 ; system trace error
ERROR_INVALID_EVENT_COUNT       EQU     151 ; DosMuxSemWait errors
ERROR_TOO_MANY_MUXWAITERS       EQU     152
ERROR_INVALID_LIST_FORMAT       EQU     153
ERROR_LABEL_TOO_LONG            EQU     154
ERROR_TOO_MANY_TCBS             EQU     155
ERROR_SIGNAL_REFUSED            EQU     156
ERROR_DISCARDED                 EQU     157
ERROR_NOT_LOCKED                EQU     158
ERROR_BAD_THREADID_ADDR         EQU     159
ERROR_BAD_ARGUMENTS             EQU     160
ERROR_BAD_PATHNAME              EQU     161
ERROR_SIGNAL_PENDING            EQU     162
; ERROR_UNCERTAIN_MEDIA		 EQU	 163
ERROR_MAX_THRDS_REACHED         EQU     164
; ERROR_MONITORS_NOT_SUPPORTED	 EQU	 165

ERROR_LOCK_FAILED		EQU	167
ERROR_BUSY			EQU	170

ERROR_INVALID_SEGMENT_NUMBER	EQU	180
; ERROR_INVALID_CALLGATE		EQU	181
ERROR_INVALID_ORDINAL		EQU	182
ERROR_ALREADY_EXISTS		EQU	183
; ERROR_NO_CHILD_PROCESS		EQU	184
; ERROR_CHILD_ALIVE_NOWAIT	EQU	185
ERROR_INVALID_FLAG_NUMBER	EQU	186
ERROR_SEM_NOT_FOUND		EQU	187

; following error codes have added to make the loader error
; messages distinct

ERROR_INVALID_STARTING_CODESEG	EQU	188
ERROR_INVALID_STACKSEG		EQU	189
ERROR_INVALID_MODULETYPE	EQU	190
ERROR_INVALID_EXE_SIGNATURE	EQU	191
ERROR_EXE_MARKED_INVALID	EQU	192
ERROR_BAD_EXE_FORMAT		EQU	193
ERROR_ITERATED_DATA_EXCEEDS_64k EQU	194
ERROR_INVALID_MINALLOCSIZE	EQU	195
ERROR_DYNLINK_FROM_INVALID_RING EQU	196
ERROR_IOPL_NOT_ENABLED		EQU	197
ERROR_INVALID_SEGDPL		EQU	198
ERROR_AUTODATASEG_EXCEEDS_64k	EQU	199
ERROR_RING2SEG_MUST_BE_MOVABLE	EQU	200
ERROR_RELOC_CHAIN_XEEDS_SEGLIM	EQU	201
ERROR_INFLOOP_IN_RELOC_CHAIN	EQU	202

ERROR_ENVVAR_NOT_FOUND		EQU	203
ERROR_NOT_CURRENT_CTRY		EQU	204
ERROR_NO_SIGNAL_SENT		EQU	205
ERROR_FILENAME_EXCED_RANGE	EQU	206 ; if filename > 8.3
ERROR_RING2_STACK_IN_USE	EQU	207 ; for FAPI
ERROR_META_EXPANSION_TOO_LONG	EQU	208 ; if "*a" > 8.3

ERROR_INVALID_SIGNAL_NUMBER	EQU	209
ERROR_THREAD_1_INACTIVE 	EQU	210
; ERROR_INFO_NOT_AVAIL		EQU	211 ; PTM 5550
ERROR_LOCKED			EQU	212
; ERROR_BAD_DYNALINK		EQU	213 ; PTM 5760
ERROR_TOO_MANY_MODULES		EQU	214
; ERROR_NESTING_NOT_ALLOWED	EQU	215

; Error codes 230 - 249 are reserved for MS Networks
ERROR_BAD_PIPE			EQU	230
ERROR_PIPE_BUSY 		EQU	231
ERROR_NO_DATA			EQU	232
ERROR_PIPE_NOT_CONNECTED	EQU	233
ERROR_MORE_DATA 		EQU	234
ERROR_VC_DISCONNECTED		EQU	240
ERROR_INVALID_EA_NAME		EQU	254
ERROR_NO_MORE_ITEMS		EQU	259
ERROR_DIRECTORY 		EQU	267
ERROR_EAS_DIDNT_FIT		EQU	275
ERROR_EAS_NOT_SUPPORTED 	EQU	282
ERROR_NOT_OWNER 		EQU	288
ERROR_TOO_MANY_POSTS		EQU	298
ERROR_MR_MID_NOT_FOUND		EQU	317
ERROR_INVALID_ADDRESS		EQU	487
ERROR_ARITHMETIC_OVERFLOW	EQU	534
ERROR_IO_INCOMPLETE		EQU	996
ERROR_IO_PENDING		EQU	997
ERROR_NOACCESS			EQU	998
ERROR_SWAPERROR 		EQU	999

; Errors added for DOS Extender

ERROR_SYS_INTERNAL		EQU	328

ENDIF ; _WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\blesslnk\blesslnk.cpp ===
// blesslnk.cpp : Program to bless a LNK file with darwin descriptor
// or logo3 app name/id

#include <tchar.h>
#include <stdio.h>
#include <windows.h>
#include <shlobj.h>
#include <shlguidp.h>
#include <shlwapi.h>
#include "cdfsubs.hpp"
#include "resource.h"

#define FAIL_ARGS       1
#define FAIL_OLE        2
#define FAIL_LOAD       3
#define FAIL_ENTRY      4
#define FAIL_REG        5
#define FAIL_SHELL      6

#define DARWIN_ID       0x1
#define LOGO3_ID        0x2

// The following strings are used to support the shell link set path feature that
// allows us to bless links for Darwin or Logo3 publising support in IE4

#define DARWINGUID_TAG TEXT("::{9db1186e-40df-11d1-aa8c-00c04fb67863}:")
#define DARWIN_TAG_LEN (ARRAYSIZE(DARWINGUID_TAG)-1)

#define LOGO3GUID_TAG  TEXT("::{9db1186f-40df-11d1-aa8c-00c04fb67863}:")
#define LOGO3_TAG_LEN  (ARRAYSIZE(LOGO3GUID_TAG)-1)


// checking for shell32 4.72.2106.0 or greater

#define IE401_SHELL_MAJOR               0x0004
#define IE401_SHELL_MINOR               0x48
#define IE401_SHELL_BUILD               0x083a

BOOL IE401ShellAvailable()
{
        BOOL bCanBlessLink = FALSE;
        DLLGETVERSIONPROC lpfnVersionProc = NULL;
        DLLVERSIONINFO dlinfo;

        HMODULE hMod = LoadLibrary("shell32.dll");

        if (hMod) {

                if ( (lpfnVersionProc = (DLLGETVERSIONPROC)GetProcAddress(hMod,"DllGetVersion")) ) 
                {

                        dlinfo.cbSize = sizeof(DLLVERSIONINFO);

                        if ( (lpfnVersionProc(&dlinfo) == S_OK) &&

                            (dlinfo.dwMajorVersion > IE401_SHELL_MAJOR) ||
                                ((dlinfo.dwMajorVersion == IE401_SHELL_MAJOR) &&
                                 (dlinfo.dwMinorVersion >= IE401_SHELL_MINOR)
                                ))

                        {
                                bCanBlessLink = TRUE;
                                if (dlinfo.dwMajorVersion == IE401_SHELL_MAJOR &&
                                    dlinfo.dwMinorVersion == IE401_SHELL_MINOR &&
                                    dlinfo.dwBuildNumber < IE401_SHELL_BUILD)
                                {
                                        bCanBlessLink = FALSE;
                                }
                                        
                        }
                }
        }


        if (hMod)
                FreeLibrary(hMod);

        return bCanBlessLink;
}

HRESULT SetLnkBlessing( IShellLink *pishl, DWORD dwSig, LPSTR szBlessing )
{
    HRESULT hr = S_OK;
    char szPath[MAX_PATH*4];
        char szTarget[MAX_PATH];

        if (dwSig == DARWIN_ID) {
                lstrcpy(szPath, DARWINGUID_TAG);
        } else if (dwSig == LOGO3_ID) {
                lstrcpy(szPath, LOGO3GUID_TAG);
        }else {
                hr = E_INVALIDARG;
        }

        if (SUCCEEDED(hr)) {

                lstrcat(szPath, szBlessing);

                lstrcat(szPath, "::");

                // get real target

                hr = pishl->GetPath(szTarget, MAX_PATH, NULL,0);

                // copy real target name

                if (SUCCEEDED(hr)) {
                        lstrcat(szPath, szTarget);

                        hr = pishl->SetPath( szPath );
                }
        }


    return hr;
}

int __cdecl main(int argc, char * argv[])
{
    int             iReturn = 0;
    HRESULT         hr = S_OK;
    LPSTR           pszLnkName = NULL;
    LPSTR           pszLogo3ID = NULL;
    LPSTR           pszDarwinID = NULL;
    LPSTR           pszCDFURL = NULL;
    LPSTR           pszTok;
    IPersistFile    *pipfLnk = NULL;


    // Parse command line arguments.
    int iTok;
    for (iTok = 1; iTok < argc; iTok++)
    {                                
            pszTok = argv[iTok];
            
            if ((pszTok[0] == '-') || (pszTok[0] == '/'))
            {
                    switch (pszTok[1])
                    {
                    case 'c':
                    case 'C':
                            pszCDFURL = argv[iTok+1];
                            iTok++;
                            break;

                    case 'l':
                    case 'L':
                            pszLogo3ID = argv[iTok+1];
                            iTok++;
                            break;
                                                            
                    case 'd':
                    case 'D':
                            pszDarwinID = argv[iTok+1];
                            iTok++;
                            break;
                            
                    case '?':
                            fprintf(stderr, "\nUsage: blesslnk [/l Logo3-ID] [/d Darwin-ID] lnkname\n/l - bless for Logo3 Application Channel notifcation.\n/d - bless for Darwin\n" );
                            break;

                    default:
                            fprintf(stderr, "err - unrecognized flag: %s\n", pszTok);
                            return FAIL_ARGS;
                    }
            }
            else
            {
                    if (pszLnkName == NULL)
                    {
                            pszLnkName = pszTok;
                            break;
                    }
                    else
                    {
                            fprintf(stderr, "err - extra argument: %s\n", pszTok);
                            return FAIL_ARGS;
                    }
            }
    }

    if (pszLnkName == NULL)
    {
            fprintf(stderr, "err - no lnk file specified\n" );
            return FAIL_ARGS;
    }

    if (!IE401ShellAvailable()) 
    {
            fprintf(stderr, "err - Need to have IE401 shell enabled for this feature.\n" );
            return FAIL_SHELL;
    }



    // Initialize OLE.                              
    if (FAILED(CoInitialize(NULL)))
    {
            return FAIL_OLE;
    }

    if ( SUCCEEDED(hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFile, (LPVOID*)&pipfLnk)) )
    {
        WCHAR szwLnkName[MAX_PATH];

        MultiByteToWideChar( CP_ACP, 0, pszLnkName, -1, szwLnkName, MAX_PATH );

        if ( SUCCEEDED(hr = pipfLnk->Load(szwLnkName, STGM_READ)) )
        {

            IShellLink *pishl = NULL;

            if ( SUCCEEDED(hr = pipfLnk->QueryInterface(IID_IShellLink, (LPVOID*)&pishl)) )
                        {
                    if ( pszLogo3ID )
                    {
                        if ( FAILED(hr = SetLnkBlessing( pishl, LOGO3_ID, pszLogo3ID )) )
                            fprintf( stderr, "err - failed to bless %s with Logo3-ID %s\n", pszLnkName, pszLogo3ID );
                    }

                    if ( pszDarwinID )
                    {
                        if ( FAILED(hr = SetLnkBlessing(pishl, DARWIN_ID, pszDarwinID)) )
                            fprintf( stderr, "err - failed to bless %s with Darwin-ID %s\n", pszLnkName, pszDarwinID );
                                        }

                        }

                        if ( SUCCEEDED(hr) )
                                hr = pipfLnk->Save( NULL, FALSE );

                        if ( FAILED(hr) )
                                fprintf( stderr, "err - failed with error %lx\n", hr );

        }

        pipfLnk->Release();
    }

    if (pszCDFURL && SUCCEEDED(hr)) {

        // FEATURE: pszLogo3ID is passed instead of a friendly name. In
        // the future, we can add another switch to blesslnk to accomodate
        // this. Also, we must subscribe with UI (non-silent mode) because
        // subscribing will not work properly otherwise.

        SubscribeChannel(NULL, pszLogo3ID, pszCDFURL, FALSE);
    }
        

    CoUninitialize();
            
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\blesslnk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BlessLnk.rc
//
#define IDS_USAGE                       1
#define IDS_UNRECOGNIZEDFLAG            2
#define IDS_EXTRAARGUMENT               3
#define IDS_NOPROJECT                   4
#define IDS_NODLLNAME                   5
#define IDS_NOLNKNAME                   5
#define IDS_OLEINITFAILED               6
#define IDS_COMINITFAILED               6
#define IDS_CALLFAILED                  10
#define IDS_CALLSUCCEEDED               11

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\blesslnk\cdfsubs.hpp ===
#ifndef __CDFSUBS_HPP_INCLUDED__
#define __CDFSUBS_HPP_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

BOOL CreateCDFCacheEntry(LPSTR szCDFUrl, LPSTR szLocalFileName);
BOOL SubscribeChannel(HWND hwnd, LPSTR szName, LPSTR szURL, BOOL bSilent);
BOOL WINAPI CDFAutoSubscribe(HWND hwnd, LPSTR szFriendlyName, LPSTR szCDFUrl,
                             LPSTR szCDFFilePath, BOOL bSilent);
HRESULT Ansi2Unicode(const char * src, wchar_t **dest);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\blesslnk\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BlessLnk.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\blesslnk\cdfsubs.cpp ===
#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <memory.h>
#include <subsmgr.h>
#include <mstask.h>
#include <wininet.h>
#include "cdfsubs.hpp"

// CDFAutoSubscribe
//
// Create the cache entry and subscribe to the channel.
//
// APPCOMPAT: Right now, if you create the cache entry for the CDF, subscribing
// to the channel doesn't work properly. Updating the channel will fail.
//

BOOL WINAPI CDFAutoSubscribe(HWND hwnd, LPSTR szFriendlyName, LPSTR szCDFUrl,
                             LPSTR szCDFFilePath, BOOL bSilent)
{
    BOOL                   bRet = FALSE;

    if (CreateCDFCacheEntry(szCDFUrl, szCDFFilePath)) {
        if (SubscribeChannel(hwnd, szFriendlyName, szCDFUrl, bSilent)) {
            bRet = TRUE;
        }
    }

    return bRet;
}

//
// CreateCDFCacheEntry
//

BOOL CreateCDFCacheEntry(LPSTR szCDFUrl, LPSTR szLocalFileName)
{
    BOOL                           bRet;
    FILETIME                       ftExpireTime;
    FILETIME                       ftLastMod;
    TCHAR                          achFileName[MAX_PATH];

    bRet = FALSE;
    GetSystemTimeAsFileTime(&ftLastMod);
    ftExpireTime.dwLowDateTime = (DWORD)0;
    ftExpireTime.dwHighDateTime = (DWORD)0;

    if (CreateUrlCacheEntry(szCDFUrl, 0, NULL, achFileName, 0)) {
        CopyFile(szLocalFileName, achFileName, FALSE);
        if (CommitUrlCacheEntry(szCDFUrl, achFileName, ftExpireTime,
                                ftLastMod, 0, NULL, 0, NULL, 0)) {
            bRet = TRUE;
        }
    }

    return bRet;
}

//
// SubscribeChannel
//

BOOL SubscribeChannel(HWND hwnd, LPSTR szName, LPSTR szURL, BOOL bSilent)
{
    ISubscriptionMgr              *pISubscriptionMgr = NULL;
    DWORD                          dwFlags = 0;
    BOOL                           bRet = FALSE;
    HRESULT                        hr = S_OK;
    SUBSCRIPTIONTYPE               subsType = SUBSTYPE_CHANNEL;
    SUBSCRIPTIONINFO               subsInfo;
    LPWSTR                         wzName = NULL;
    LPWSTR                         wzURL = NULL;

    if (FAILED(Ansi2Unicode(szName, &wzName))) {
        goto Exit;
    }

    if (FAILED(Ansi2Unicode(szURL, &wzURL))) {
        goto Exit;
    }

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr, (void **)&pISubscriptionMgr);
    if (FAILED(hr)) {
        goto Exit;
    }
                          
    ZeroMemory(&subsInfo, sizeof(SUBSCRIPTIONINFO));
    subsInfo.cbSize = sizeof(SUBSCRIPTIONINFO);
    subsInfo.fUpdateFlags = SUBSINFO_CHANNELFLAGS | SUBSINFO_TASKFLAGS | SUBSINFO_GLEAM;
    subsInfo.bGleam = TRUE;

    subsInfo.fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL |
                              CHANNEL_AGENT_DYNAMIC_SCHEDULE;

    subsInfo.fTaskFlags = TASK_FLAG_START_ONLY_IF_IDLE | 
                          TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET;
    
    dwFlags = CREATESUBS_ADDTOFAVORITES | CREATESUBS_SOFTWAREUPDATE;
    if (bSilent) {
        dwFlags |= CREATESUBS_NOUI;
    }

    hr = pISubscriptionMgr->CreateSubscription(hwnd, wzURL, wzName,
                                               dwFlags, subsType, &subsInfo);

    if (hr == S_OK) {
        bRet = TRUE;
    }

    pISubscriptionMgr->Release();

Exit:

    if (wzName) {
        delete wzName;
    }

    if (wzURL) {
        delete wzURL;
    }

    return bRet;
}

// Ansi2Unicode: Convert ANSI strings to Unicode
// Ripped from urlmon\download\helpers.cxx

HRESULT Ansi2Unicode(const char * src, wchar_t **dest)
{
    if ((src == NULL) || (dest == NULL))
        return E_INVALIDARG;

    // find out required buffer size and allocate it
    int len = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, NULL, 0);
    *dest = new WCHAR [len*sizeof(WCHAR)];
    if (!*dest)
        return E_OUTOFMEMORY;

    // Do the actual conversion.
    if ((MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, *dest, 
                                                    len*sizeof(wchar_t))) != 0)
        return S_OK; 
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\chinproc\debug.c ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "tests.ini"
#define SZ_DEBUGSECTION     "SWINPROC"
#define SZ_MODULE           "SWINPROC"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\blesslnk\subs.cpp ===
#include <windows.h>
#include <wininet.h>


void main()
{
    // Assume existing file C:\temp\foo.bar to be 
    // committed to cache associated with 
    // http://www.foo.bar/
    LPSTR szFile = "c:\\temp\\foo.bar";
    LPSTR szUrl  = "http://www.foo.bar/";
    CHAR szCacheFile[MAX_PATH];

    // Expiry and Last-Modified times of 0.
    LONGLONG llZero = 0;
    FILETIME ftExpire  = *((FILETIME*) & llZero);
    FILETIME ftLastMod = *((FILETIME*) & llZero);

    // Create cache file.
    CreateUrlCacheEntry(szUrl, 0, NULL, szCacheFile, 0);
    // Copy existing file to cache file.
    CopyFile(szFile, szCacheFile, FALSE);    

    CommitUrlCacheEntry(szUrl, 
                        szCacheFile, 
                        ftExpire,
                        ftLastMod, 
                        0, 
                        NULL, 
                        0, 
                        NULL, 
                        0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\chinproc\resource.h ===
#define MENU_ABOUT          2
#define MENU_EXIT           4
#define MENU_OPEN           5
#define MENU_COPY           6
#define MENU_PASTE          7
#define MENU_CUT            8
#define MENU_NEW            10
#define MENU_SETSPLAT       11
#define MENU_CLEARSPLAT     12
#define MENU_DELETEDB       13

#define MENU_VIEW           100
#define MENU_VIEW_ICON      100
#define MENU_VIEW_REPORT    101
#define MENU_VIEW_SMALLICON 102
#define MENU_VIEW_LIST      103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\cleaninf\debug.c ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "tests.ini"
#define SZ_DEBUGSECTION     "ICONVIEW"
#define SZ_MODULE           "ICONVIEW"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\cleaninf\resource.h ===
#define MENU_ABOUT          2
#define MENU_EXIT           4
#define MENU_OPEN           5
#define MENU_COPY           6
#define MENU_PASTE          7
#define MENU_CUT            8
#define MENU_NEW            10
#define MENU_SETSPLAT       11
#define MENU_CLEARSPLAT     12
#define MENU_DELETEDB       13

#define MENU_VIEW           100
#define MENU_VIEW_ICON      100
#define MENU_VIEW_REPORT    101
#define MENU_VIEW_SMALLICON 102
#define MENU_VIEW_LIST      103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\chinproc\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <windowsx.h>
#include <shlwapi.h>

#include <ccstock.h>
#include <debug.h>

#ifdef __cplusplus
#include <shstr.h>
#endif

#include "resource.h"

// Trace and Dump flags
#define BF_ONOPEN           0x00000010


#ifdef __cplusplus
}
#endif

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\cleaninf\parse.h ===
#ifndef _PARSE_H_
#define _PARSE_H_
#ifdef __cplusplus

#define CHAR_EOF    -1


class CParseFile
{
public:
    void    Parse(FILE * pfileSrc, FILE * pfileDest, DWORD dwFlags);
    
    CParseFile();
    ~CParseFile() {};
    
private:
    void    _ParseInf(void);
    void    _ParseHtml(void);
    void    _ParseJS(void);
    void    _ParseHtc(void);
    
    char    _ReadChar(DWORD dwFlags);
    char    _SniffChar(int ichAhead);
    BOOL    _IsTagEqual(LPSTR pszTag);
    BOOL    _IsEndTag(void);
    
    void    _WriteChar(char);
    void    _FlushWriteBuffer(void);
    
    void    _WriteTag(void);
    void    _SkipCommentTag(void);
    BOOL    _SkipComment(int * pcNestedComment);
    BOOL    _SkipWhitespace(BOOL bPreserveOneSpace = FALSE);
    void    _ParseInnerStyle(void);


    FILE *  _pfileSrc;
    FILE *  _pfileDest;
    
    char    _ch;
    int     _ichRead;
    int     _cchRead;
    int     _ichWrite;

    BITBOOL _bSkipWhitespace: 1;        // TRUE: skip whitespace

    BITBOOL _bFirstChar: 1;             // TRUE: current character is first one on a new line
    
    char    _szReadBuf[512];
    char    _szWriteBuf[512];
};


#endif // __cplusplus
#endif // _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\chinproc\app.cpp ===
#include "priv.h"       
#include <stdlib.h>
#include <stdio.h>

HINSTANCE g_hinst;

#define APP_VERSION         "Version 0.2"

#define PFF_SYSTEM      0x00000001


void PrintSyntax(void)
{
    fprintf(stderr, "chinproc.exe  " APP_VERSION "\n\n");
    fprintf(stderr, "Changes the InProcServer32 entry for any CLSID using\n");
    fprintf(stderr, "<dll> from %%SystemRoot%%\\system32 to a local path,\n");
    fprintf(stderr, "or vice versa.\n");
    fprintf(stderr, "Syntax:  chinproc [-s] {<path>|<dll>} \n\n");
    fprintf(stderr, "          -s   Change to %%SystemRoot%%\\system32\\foo.dll\n");
    fprintf(stderr, "               (NT only)\n\n");
    fprintf(stderr, "          Default action is to set the InProcServer32 to <path>\n");
}    


/*----------------------------------------------------------
Purpose: Worker function to do the work

Returns: 
Cond:    --
*/
int
DoWork(int cArgs, char * rgszArgs[])
{
    LPSTR psz;
    LPSTR pszDll = NULL;
    DWORD dwFlags = 0;
    int i;
    int nRet = 0;

    // (The first arg is actually the exe.  Skip that.)

    for (i = 1; i < cArgs; i++)
    {
        psz = rgszArgs[i];

        // Check for options
        if ('/' == *psz || '-' == *psz)
        {
            psz++;
            switch (*psz)
            {
            case '?':
                // Help
                PrintSyntax();
                return 0;

            case 's':
                dwFlags |= PFF_SYSTEM;
                *psz++;

                // Is this Win95?
                if (0x80000000 & GetVersion())
                {
                    // Yes; can't allow -s
                    fprintf(stderr, "Cannot use -s on Win95 machines.\n");
                    return -1;
                }
                break;

            default:
                // unknown
                fprintf(stderr, "Invalid option -%c\n", *psz);
                return -1;
            }
        }
        else if (!pszDll)
            pszDll = rgszArgs[i];
        else
        {
            fprintf(stderr, "Ignoring invalid parameter - %s\n", rgszArgs[i]);
        }
    }

    if (!pszDll)
    {
        PrintSyntax();
        return -2;
    }

    // Enumerate the HKCR\CLSID for any CLSIDs that use pszDll.
    DWORD dwRet;
    HKEY hkeyCLSID;

    dwRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_SET_VALUE | KEY_READ, &hkeyCLSID);
    if (NO_ERROR == dwRet)
    {
        DWORD dwIndex = 0;
        TCHAR szSubkey[MAX_PATH];

        while (ERROR_SUCCESS == RegEnumKey(hkeyCLSID, dwIndex++, szSubkey, SIZECHARS(szSubkey)))
        {
            TCHAR szPath[MAX_PATH];
            DWORD cbPath = sizeof(szPath);
            LPTSTR pszFile = PathFindFileName(pszDll);

            // Does this entry match pszDll?
            PathAppend(szSubkey, TEXT("InProcServer32"));
            if (NO_ERROR == SHGetValue(hkeyCLSID, szSubkey, NULL, NULL, szPath, &cbPath) &&
                0 == lstrcmpi(PathFindFileName(szPath), pszFile))
            {
                // Yes; change it according to dwFlags
                fprintf(stdout, ".");

                if (dwFlags & PFF_SYSTEM)
                {
                    // Prepend %SystemRoot%\system32 on it
                    lstrcpy(szPath, TEXT("%SystemRoot%\\system32"));
                    PathAppend(szPath, pszDll);
                    SHSetValue(hkeyCLSID, szSubkey, NULL, REG_EXPAND_SZ, szPath, sizeof(szPath));
                }
                else
                {
                    SHSetValue(hkeyCLSID, szSubkey, NULL, REG_SZ, pszDll, CbFromCch(lstrlen(pszDll) + 1));
                }
            }
        }

        fprintf(stdout, "\nFinished!\n");
        RegCloseKey(hkeyCLSID);
    }
    else
        fprintf(stderr, "Failed to open HKCR\\CLSID\n");

    return nRet;
}


int __cdecl main(int argc, char * argv[])
{
    return DoWork(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\cleaninf\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#include <windows.h>
#include <windowsx.h>

#include <ccstock.h>
#include <debug.h>

#ifdef __cplusplus
#include <shstr.h>
#endif

#include <stdlib.h>
#include <stdio.h>

#include "resource.h"

#include "parse.h"

#ifdef __cplusplus
extern "C" {
#endif

// Helper functions
// (Don't link to shlwapi.dll so this is a stand-alone tool)
//
void PathUnquoteSpaces(LPTSTR lpsz);
BOOL StrTrim(LPSTR  pszTrimMe, LPCSTR pszTrimChars);


// Trace and Dump flags
#define BF_ONOPEN           0x00000010


// Parse file flags
#define PFF_WHITESPACE      0x00000001
#define PFF_INF             0x00000002
#define PFF_HTML            0x00000004
#define PFF_JS              0x00000008
#define PFF_HTC             0x00000010


#ifdef __cplusplus
}
#endif

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\cleaninf\app.cpp ===
#include "priv.h"       

HINSTANCE g_hinst;

#define APP_VERSION         "Version 0.4"


// Don't link to shlwapi.dll so this is a stand-alone tool

/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

*/
void
PathUnquoteSpaces(
    LPTSTR lpsz)
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = TEXT('\0');
        hmemcpy(lpsz, lpsz+1, (cch-1) * SIZEOF(TCHAR));
    }
}


#define CH_WHACK TEXT(FILENAME_SEPARATOR)

LPTSTR
PathFindExtension(
    LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = CharNext(pszPath))
        {
            switch (*pszPath) {
            case TEXT('.'):
                pszDot = pszPath;         // remember the last dot
                break;
            case CH_WHACK:
            case TEXT(' '):         // extensions can't have spaces
                pszDot = NULL;       // forget last dot, it was in a directory
                break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}



__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


LPSTR FAR PASCAL StrChrA(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

BOOL
StrTrim(
    IN OUT LPSTR  pszTrimMe,
    IN     LPCSTR pszTrimChars)
    {
    BOOL bRet = FALSE;
    LPSTR psz;
    LPSTR pszStartMeat;
    LPSTR pszMark = NULL;

    ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    ASSERT(IS_VALID_STRING_PTRA(pszTrimChars, -1));

    if (pszTrimMe)
    {
        /* Trim leading characters. */

        psz = pszTrimMe;

        while (*psz && StrChrA(pszTrimChars, *psz))
            psz = CharNextA(psz);

        pszStartMeat = psz;

        /* Trim trailing characters. */

        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)

        while (*psz)
            {
            if (StrChrA(pszTrimChars, *psz))
                {
                pszMark = psz;
                }
            else
                {
                pszMark = NULL;
                }
            psz = CharNextA(psz);
            }

        // Any trailing characters to clip?
        if (pszMark)
            {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
            }

        /* Relocate stripped string. */

        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchA(lstrlenA(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);

        ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    }

    return bRet;
    }



void PrintSyntax(void)
{
    fprintf(stderr, "cleaninf.exe  " APP_VERSION "\n\n"
                    "Cleans up an inf, html, or script file for public distribution or for packing\n"
                    "into a resource.  Without any options, this removes all comments.  This\n"
                    "tool recognizes .inf, .htm, .hta, .js and .htc files by default.\n\n"
                    "Syntax:  cleaninf [-w] [-inf | -htm | -js | -htc] sourceFile destFile\n\n"
                    "          -w     Strip whitespace\n\n"
                    "         These flags are mutually exclusive, and will treat the file\n"
                    "         accordingly, regardless of extension:\n"
                    "          -inf   Treat file as a .inf file\n"
                    "          -htm   Treat file as a .htm file\n"
                    "          -js    Treat file as a .js file\n"
                    "          -htc   Treat file as a .htc file\n");
}    


/*----------------------------------------------------------
Purpose: Worker function to do the work

*/
int
DoWork(int cArgs, char * rgszArgs[])
{
    LPSTR psz;
    LPSTR pszSrc = NULL;
    LPSTR pszDest = NULL;
    DWORD dwFlags = 0;
    int i;
    int nRet = 0;

    // (The first arg is actually the exe.  Skip that.)

    for (i = 1; i < cArgs; i++)
    {
        psz = rgszArgs[i];

        // Check for options
        if ('/' == *psz || '-' == *psz)
        {
            psz++;
            switch (*psz)
            {
            case '?':
                // Help
                PrintSyntax();
                return 0;

            case 'w':
                dwFlags |= PFF_WHITESPACE;
                break;

            default:
                if (0 == strncmp(psz, "inf", 3))
                {
                    dwFlags |= PFF_INF;
                }
                else if (0 == strncmp(psz, "htm", 3))
                {
                    dwFlags |= PFF_HTML;
                }
                else if (0 == strncmp(psz, "js", 2))
                {
                    dwFlags |= PFF_JS;
                }
                else if (0 == strncmp(psz, "htc", 3))
                {
                    dwFlags |= PFF_HTC;
                }
                else
                {
                    // unknown
                    fprintf(stderr, "Invalid option -%c\n", *psz);
                    return -1;
                }
                break;
            }
        }
        else if (!pszSrc)
            pszSrc = rgszArgs[i];
        else if (!pszDest)
            pszDest = rgszArgs[i];
        else
        {
            fprintf(stderr, "Ignoring invalid parameter - %s\n", rgszArgs[i]);
        }
    }

    if (!pszSrc || !pszDest)
    {
        PrintSyntax();
        return -2;
    }

    // Has the file type already been explicitly specified?
    if ( !(dwFlags & (PFF_INF | PFF_HTML | PFF_JS | PFF_HTC)) )
    {
        // No; determine it based on the extension
        LPTSTR pszExt = PathFindExtension(pszSrc);

        if (pszExt)
        {
            if (0 == lstrcmpi(pszExt, ".htm") || 0 == lstrcmpi(pszExt, ".hta"))
                dwFlags |= PFF_HTML;
            else if (0 == lstrcmpi(pszExt, ".js"))
                dwFlags |= PFF_JS;
            else if (0 == lstrcmpi(pszExt, ".htc"))
                dwFlags |= PFF_HTC;
        }
    }
    
    // Open the files
    PathUnquoteSpaces(pszSrc);
    PathUnquoteSpaces(pszDest);

    FILE * pfileSrc = fopen(pszSrc, "r");

    if (NULL == pfileSrc)
    {
        fprintf(stderr, "\"%s\" could not be opened", pszSrc);
        nRet = -3;
    }
    else
    {
        FILE * pfileDest = fopen(pszDest, "w");

        if (NULL == pfileDest)
        {
            fprintf(stderr, "\"%s\" could not be created", pszDest);
            nRet = -4;
        }
        else
        {
            CParseFile parsefile;

            parsefile.Parse(pfileSrc, pfileDest, dwFlags);
            
            fclose(pfileDest);
        }
        
        fclose(pfileSrc);
    }
    return nRet;
}


#ifdef UNIX

EXTERN_C
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void* lParam);

EXTERN_C
HINSTANCE mainwin_init(int argc, char *argv[])
{
          return MwMainwinInitLite(argc, argv, NULL);
}

#endif

int __cdecl main(int argc, char * argv[])
{
    return DoWork(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\clip\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	clip.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\clip\idlist.h ===
LPITEMIDLIST  ILGetNext(LPCITEMIDLIST pidl);
UINT          ILGetSize(LPCITEMIDLIST pidl);
LPITEMIDLIST  ILCreate(void);
LPITEMIDLIST  ILCreateFromPath(LPCSTR szPath);
BOOL 	      ILGetDisplayName(LPCITEMIDLIST pidl, LPSTR pszName);
LPITEMIDLIST  ILFindLastID(LPCITEMIDLIST pidl);
BOOL          ILRemoveLastID(LPITEMIDLIST pidl);
LPITEMIDLIST  ILClone(LPCITEMIDLIST pidl);
LPITEMIDLIST  ILCloneFirst(LPCITEMIDLIST pidl);
BOOL          ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL          ILIsEqualItemID(LPCSHITEMID pmkid1, LPCSHITEMID pmkid2);
BOOL          ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
LPITEMIDLIST  ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
LPITEMIDLIST  ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
LPITEMIDLIST  ILCreateFromPath(LPCTSTR szPath);

// LPITEMIDLIST  ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);

STDAPI ILLoadFromStream(IStream *pstm, LPITEMIDLIST *pidl);
STDAPI ILSaveToStream(IStream *pstm, LPCITEMIDLIST pidl);

// helper macros
#define ILIsEmpty(pidl)	((pidl)->mkid.cb == 0)
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

// unsafe macros
#define _ILSkip(pidl, cb)	((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)		_ILSkip(pidl, (pidl)->mkid.cb)

#ifdef _HIDA

typedef HGLOBAL HIDA;

HIDA HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl);
void HIDA_Free(HIDA hida);
HIDA HIDA_Clone(HIDA hida);
UINT HIDA_GetCount(HIDA hida);
UINT HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax);

LPCITEMIDLIST HIDA_GetIDListPtr(HIDA hida, UINT i);
LPITEMIDLIST  HIDA_ILClone(HIDA hida, UINT i);
LPITEMIDLIST  IDA_ILClone(LPIDA pida, UINT i);
LPITEMIDLIST  HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl);

#define HIDA_Free(HIDA hida) GlobalFree(hida)

#endif _HIDA


#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#define SHAnsiToUnicode(psz, pwsz, cchwsz)  MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchwsz);
#define SHUnicodeToAnsi(pwsz, psz, cchsz)   WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cchsz, NULL, NULL);

#ifdef UNICODE
#define SHTCharToUnicode(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToUnicodeCP(uiCP, wzSrc, wzDest, cchSize)        SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToAnsi(wzSrc, szDest, cchSize)                   SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHTCharToAnsiCP(uiCP, wzSrc, szDest, cchSize)           SHUnicodeToAnsiCP(uiCP, wzSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHUnicodeToTCharCP(uiCP, wzSrc, wzDest, cchSize)        SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHAnsiToTChar(szSrc, wzDest, cchSize)                   SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHAnsiToTCharCP(uiCP, szSrc, wzDest, cchSize)           SHAnsiToUnicodeCP(uiCP, szSrc, wzDest, cchSize)
#else // UNICODE
#define SHTCharToUnicode(szSrc, wzDest, cchSize)                SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHTCharToUnicodeCP(uiCP, szSrc, wzDest, cchSize)        SHAnsiToUnicodeCP(uiCP, szSrc, wzDest, cchSize)
#define SHTCharToAnsi(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHTCharToAnsiCP(uiCP, szSrc, szDest, cchSize)           SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, szDest, cchSize)                SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHUnicodeToTCharCP(uiCP, wzSrc, szDest, cchSize)        SHUnicodeToAnsiCP(uiCP, wzSrc, szDest, cchSize)
#define SHAnsiToTChar(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHAnsiToTCharCP(uiCP, szSrc, szDest, cchSize)           SHAnsiToAnsi(szSrc, szDest, cchSize)
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\clip\clip.cpp ===
// clip.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

#include <shlobj.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <propidl.h>
#include "idlist.h"

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

LPCTSTR GetCmdLineArg()
{
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) 
    {
        while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) );
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
    {
        pszCmdLine++;
    }

    return pszCmdLine;
}

HRESULT GetUIObjectFromCmdLine(REFIID riid, void **ppv)
{
    *ppv = NULL;

    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        TCHAR szFolder[MAX_PATH], szSpec[MAX_PATH];

        GetCurrentDirectory(ARRAYSIZE(szFolder), szFolder);

        lstrcpyn(szSpec, GetCmdLineArg(), ARRAYSIZE(szSpec));
        PathUnquoteSpaces(szSpec);

        PathAppend(szFolder, szSpec);

        WCHAR wszPath[MAX_PATH];
        SHAnsiToUnicode(szFolder, wszPath, ARRAYSIZE(wszPath));

        LPITEMIDLIST pidl;
        hr = psfDesktop->ParseDisplayName(NULL, NULL, wszPath, NULL, &pidl, NULL);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            LPCITEMIDLIST pidlChild;
            hr = SHBindToParent(pidl, IID_IShellFolder, (void **)&psf, &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetUIObjectOf(NULL, 1, &pidlChild, riid, NULL, ppv);
            }
            CoTaskMemFree(pidl);
        }
        psfDesktop->Release();
    }
    return hr;
}

HRESULT BindToItemByName(LPCWSTR pszFile, REFIID riid, void **ppv)
{
    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        // cast needed for bad interface def
        hr = psfDesktop->ParseDisplayName(NULL, NULL, (LPWSTR)pszFile, NULL, &pidl, NULL);
        if (SUCCEEDED(hr))
        {
            hr = psfDesktop->BindToObject(pidl, NULL, riid, ppv);
            CoTaskMemFree(pidl);
        }
        psfDesktop->Release();
    }
    return hr;
}

HRESULT CoMarshallToCmdLine(REFIID riid, IUnknown *punk, LPTSTR pszCmdLine, UINT cch)
{
    *pszCmdLine = 0;

    IStream *pstm;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (SUCCEEDED(hr)) 
    {
        hr = CoMarshalInterface(pstm, riid, punk, MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_NORMAL);
        if (SUCCEEDED(hr))
        {
            const LARGE_INTEGER li = {0, 0};
            pstm->Seek(li, STREAM_SEEK_SET, NULL);

            char buf[255]; // big enough for a standard marshall record
            ULONG cb;
            hr = pstm->Read(buf, sizeof(buf), &cb);
            if (SUCCEEDED(hr))
            {
                StrCatBuff(pszCmdLine, TEXT("/DataObject:"), cch);
                pszCmdLine += lstrlen(pszCmdLine);
                // convert binary buffer to hex
                for (ULONG i = 0; i < cb; i++)
                {
                    *pszCmdLine++ = 'A' +  (0x0F & buf[i]);
                    *pszCmdLine++ = 'A' + ((0xF0 & buf[i]) >> 4);
                }
                *pszCmdLine = 0;
            }
        }
        pstm->Release();
    }
    return hr;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    OleInitialize(0);

#if 1
    IPropertySetStorage *ppss;
    if (SUCCEEDED(BindToItemByName(L"c:\\foo.jpg", IID_PPV_ARG(IPropertySetStorage, &ppss))))
    {
        ppss->Release();
    }
#endif

    IDataObject *pdtobj;

    if (SUCCEEDED(GetUIObjectFromCmdLine(IID_PPV_ARG(IDataObject, &pdtobj))))
    {
#if 1
        HRESULT hr = OleSetClipboard(pdtobj);
        OleFlushClipboard();    // seralize it
#else
        TCHAR szArgs[512];
        if (SUCCEEDED(CoMarshallToCmdLine(IID_IDataObject, pdtobj, szArgs, ARRAYSIZE(szArgs))))
        {
            SHELLEXECUTEINFO ei = {0};
            ei.cbSize = sizeof(ei);

            ei.lpFile = TEXT("test.exe");          // we have an app name
            ei.lpParameters = szArgs;   // and maybe some args
            ei.nShow = SW_SHOW;
            ei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_DOENVSUBST;

            ShellExecuteEx(&ei);
        }

        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
#endif
        pdtobj->Release();
    }


    OleUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\clip\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\clip\idlist.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <shlobj.h>

#define NO_SHLWAPI_TPS
#include <shlwapi.h>
#include "idlist.h"

#define VALIDATE_PIDL(pidl) // add debugging code behind this

LPITEMIDLIST ILGetNext(LPCITEMIDLIST pidl)
{
    if (pidl && pidl->mkid.cb)
    {
        VALIDATE_PIDL(pidl);
        return _ILNext(pidl);
    }
    return NULL;
}

UINT ILGetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        VALIDATE_PIDL(pidl);
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cbTotal;
}

#define CBIDL_MIN       256
#define CBIDL_INCL      256

LPITEMIDLIST ILCreate()
{
    return (LPITEMIDLIST)CoTaskMemAlloc(CBIDL_MIN);
}

/*
 ** _ILResize
 *
 *  PARAMETERS:
 *      cbExtra is the amount to add to cbRequired if the block needs to grow,
 *      or it is 0 if we want to resize to the exact size
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

LPITEMIDLIST _ILResize(LPITEMIDLIST pidl, UINT cbRequired, UINT cbExtra)
{
    if (pidl == NULL)
    {
        pidl = (LPITEMIDLIST)CoTaskMemAlloc(cbRequired + cbExtra);
    }
    else
    {
        pidl = (LPITEMIDLIST)CoTaskMemRealloc(pidl, cbRequired + cbExtra);
    }
    return pidl;
}

LPITEMIDLIST ILFindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    VALIDATE_PIDL(pidl);
    if (pidl == NULL)
        return NULL;

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = _ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}


BOOL ILRemoveLastID(LPITEMIDLIST pidl)
{
    BOOL fRemoved = FALSE;

    if (pidl == NULL)
        return(FALSE);

    if (pidl->mkid.cb)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST)ILFindLastID(pidl);
        pidlLast->mkid.cb = 0; // Remove the last one, null-terminator
        fRemoved = TRUE;
    }

    return fRemoved;
}

LPITEMIDLIST ILClone(LPCITEMIDLIST pidl)
{
    UINT cb = ILGetSize(pidl);
    LPITEMIDLIST pidlRet = (LPITEMIDLIST)CoTaskMemAlloc(cb);
    if (pidlRet)
        CopyMemory(pidlRet, pidl, cb);
    return pidlRet;
}

LPITEMIDLIST ILCloneFirst(LPCITEMIDLIST pidl)
{
    UINT cb = pidl->mkid.cb+sizeof(pidl->mkid.cb);
    LPITEMIDLIST pidlRet = (LPITEMIDLIST)CoTaskMemAlloc(cb);
    if (pidlRet)
    {
        CopyMemory(pidlRet, pidl, pidl->mkid.cb);
        _ILNext(pidlRet)->mkid.cb = 0;
    }
    return pidlRet;
}

BOOL ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL bRet = FALSE;
    IShellFolder *psfDesktop;
    if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
    {
        bRet = psfDesktop->CompareIDs(0, pidl1, pidl2) == 0;
        psfDesktop->Release();
    }
    return bRet;
}

// test if
//      pidl1 is a parent of pidl2

BOOL ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate)
{
    LPITEMIDLIST pidl2Prefix;
    UINT cb;
    LPCITEMIDLIST pidl1T;
    LPCITEMIDLIST pidl2T;

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);

    if (!pidl1 || !pidl2)
        return FALSE;

    for (pidl1T = pidl1, pidl2T = pidl2; !ILIsEmpty(pidl1T);
         pidl1T = _ILNext(pidl1T), pidl2T = _ILNext(pidl2T))
    {
        // if pidl2 is shorter than pidl1, pidl1 can't be its parent.
        if (ILIsEmpty(pidl2T))
            return FALSE;
    }

    if (fImmediate)
    {
        // If fImmediate is TRUE, pidl2T should contain exactly one ID.
        if (ILIsEmpty(pidl2T) || !ILIsEmpty(_ILNext(pidl2T)))
            return FALSE;
    }

    //
    // Create a new IDList from a portion of pidl2, which contains the
    // same number of IDs as pidl1.
    //
    cb = (UINT)pidl2T - (UINT)pidl2;
    pidl2Prefix = (LPITEMIDLIST)CoTaskMemAlloc(cb + sizeof(pidl2->mkid.cb));
    if (pidl2Prefix)
    {
        CopyMemory(pidl2Prefix, pidl2, cb);
        *(USHORT *)((BYTE *)pidl2Prefix + cb) = 0;

        BOOL fRet = ILIsEqual(pidl1, pidl2Prefix);

        CoTaskMemFree(pidl2Prefix);
        return fRet;
    }

    return FALSE;
}

// this returns a pointer to the child id ie:
// given pidlParent = \chicago\desktop
//      pidlChild = \chicago\desktop\foo\bar
// the return will point to the ID that represents \foo\bar
// NULL is returned if pidlParent is not a parent of pidlChild
LPITEMIDLIST ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    if (ILIsParent(pidlParent, pidlChild, FALSE))
    {
        while (!ILIsEmpty(pidlParent))
        {
            pidlChild = _ILNext(pidlChild);
            pidlParent = _ILNext(pidlParent);
        }
        return (LPITEMIDLIST)pidlChild;
    }
    return NULL;
}

LPITEMIDLIST  ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST pidlNew;
    UINT cb1 = ILGetSize(pidl1) - sizeof(pidl1->mkid.cb);
    UINT cb2 = ILGetSize(pidl2);

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);
    pidlNew = (LPITEMIDLIST)CoTaskMemAlloc(cb1 + cb2);
    if (pidlNew)
    {
        CopyMemory(pidlNew, pidl1, cb1);
        CopyMemory(((LPSTR)pidlNew) + cb1, pidl2, cb2);
    }
    return pidlNew;
}


LPITEMIDLIST ILCreateFromPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = NULL;
    IShellFolder *psfDesktop;
    if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
    {
        ULONG cchEaten;
        WCHAR wszPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));

        psfDesktop->ParseDisplayName(NULL, NULL, wszPath, &cchEaten, &pidl, NULL);
        psfDesktop->Release();
    }
    return pidl;
}

//===========================================================================
// IDLIST: Stream access
// FEATURE: check bytes read on Read calls?
//===========================================================================

STDAPI ILLoadFromStream(IStream *pstm, LPITEMIDLIST * ppidl)
{
    HRESULT hres;
    ULONG cb;

    // Delete the old one if any.
    if (*ppidl)
    {
        CoTaskMemFree(*ppidl);
        *ppidl = NULL;
    }

    // Read the size of the IDLIST
    cb = 0;             // WARNING: We need to fill its HIWORD!
    hres = pstm->Read(&cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hres) && cb)
    {
        // Create a IDLIST
        LPITEMIDLIST pidl = (LPITEMIDLIST)CoTaskMemAlloc(cb);
        if (pidl)
        {
            // Read its contents
            hres = pstm->Read(pidl, cb, NULL);
            if (SUCCEEDED(hres))
            {
                *ppidl = pidl;
            }
            else
            {
                CoTaskMemFree(pidl);
            }
        }
        else
        {
           hres = E_OUTOFMEMORY;
        }
    }

    return hres;
}

// FEATURE: check bytes written on Write calls?

STDAPI ILSaveToStream(IStream *pstm, LPCITEMIDLIST pidl)
{
    HRESULT hres;
    ULONG cb = ILGetSize(pidl);
    hres = pstm->Write(&cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hres) && cb)
    {
        if (SUCCEEDED(hres))
        {
            hres = pstm->Write(pidl, cb, NULL);
        }
    }

    return hres;
}

#ifdef _HIDA

//===========================================================================
// IDLARRAY stuff
//===========================================================================

#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])


HIDA HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST * apidl)
{
    HIDA hida;
    UINT i;
    UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
    UINT cbTotal = offset + ILGetSize(pidlFolder);
    for (i=0; i<cidl ; i++) {
        cbTotal += ILGetSize(apidl[i]);
    }

    hida = GlobalAlloc(GPTR, cbTotal);  // This MUST be GlobalAlloc!!!
    if (hida)
    {
        LPIDA pida = (LPIDA)hida;       // no need to lock

        LPCITEMIDLIST pidlNext;
        pida->cidl = cidl;

        for (i=0, pidlNext=pidlFolder; ; pidlNext=apidl[i++])
        {
            UINT cbSize = ILGetSize(pidlNext);
            pida->aoffset[i] = offset;
            CopyMemory(((LPBYTE)pida)+offset, pidlNext, cbSize);
            offset += cbSize;

            if (i==cidl)
                break;
        }
    }

    return hida;
}

HIDA HIDA_Create2(LPVOID pida, UINT cb)
{
    HIDA hida = GlobalAlloc(GPTR, cb);
    if (hida)
    {
        CopyMemory((LPIDA)hida, pida, cb);      // no need to lock
    }
    return hida;
}

HIDA HIDA_Clone(HIDA hida)
{
    UINT cbTotal = GlobalSize(hida);
    HIDA hidaCopy = GlobalAlloc(GPTR, cbTotal);
    if (hidaCopy)
    {
        LPIDA pida = (LPIDA)GlobalLock(hida);
        CopyMemory((LPIDA)hidaCopy, pida, cbTotal);     // no need to lock
        GlobalUnlock(hida);
    }
    return hidaCopy;
}

UINT HIDA_GetCount(HIDA hida)
{
    UINT count = 0;
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida) {
        count = pida->cidl;
        GlobalUnlock(hida);
    }
    return count;
}

UINT HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
        LPCITEMIDLIST pidlItem   = HIDA_GetPIDLItem(pida, i);
        UINT cbFolder  = ILGetSize(pidlFolder)-sizeof(USHORT);
        UINT cbItem = ILGetSize(pidlItem);
        if (cbMax < cbFolder+cbItem) {
            if (pidlOut) {
                pidlOut->mkid.cb = 0;
            }
        } else {
            CopyMemory(pidlOut, pidlFolder, cbFolder);
            CopyMemory(((LPBYTE)pidlOut)+cbFolder, pidlItem, cbItem);
        }
        GlobalUnlock(hida);

        return (cbFolder+cbItem);
    }
    return 0;
}

//
// This one reallocated pidl if necessary. NULL is valid to pass in as pidl.
//
LPITEMIDLIST HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl)
{
    UINT cbRequired = HIDA_GetIDList(hida, i, NULL, 0);
    pidl = _ILResize(pidl, cbRequired, 32); // extra 32-byte if we realloc
    if (pidl)
    {
        HIDA_GetIDList(hida, i, pidl, cbRequired);
    }

    return pidl;
}

LPCITEMIDLIST IDA_GetIDListPtr(LPIDA pida, UINT i)
{
    if (i == (UINT)-1 || i < pida->cidl)
    {
        return HIDA_GetPIDLItem(pida, i);
    }

    return NULL;
}

LPITEMIDLIST IDA_ILClone(LPIDA pida, UINT i)
{
    if (i < pida->cidl)
        return ILCombine(HIDA_GetPIDLFolder(pida), HIDA_GetPIDLItem(pida, i));
    return NULL;
}

LPITEMIDLIST HIDA_ILClone(HIDA hida, UINT i)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPITEMIDLIST pidl = IDA_ILClone(pida, i);
        GlobalUnlock(hida);
        return pidl;
    }
    return NULL;
}

void HIDA_ReleaseStgMedium(LPIDA pida, STGMEDIUM *pmedium)
{
    if (pmedium->hGlobal && (pmedium->tymed==TYMED_HGLOBAL))
    {
#ifdef DEBUG
        if (pida)
        {
            LPIDA pidaT = (LPIDA)GlobalLock(pmedium->hGlobal);
            GlobalUnlock(pmedium->hGlobal);
        }
#endif
        GlobalUnlock(pmedium->hGlobal);
    }
    SHReleaseStgMedium(pmedium);
}

#endif // _HIDA


#if 0
//
//  This is a helper function to be called from within IShellFolder::CompareIDs.
// When the first IDs of pidl1 and pidl2 are the (logically) same.
//
// Required:
//  psf && pidl1 && pidl2 && !ILEmpty(pidl1) && !ILEmpty(pidl2)
//
HRESULT ILCompareRelIDs(IShellFolder *psfParent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres;
    LPCITEMIDLIST pidlRel1 = _ILNext(pidl1);
    LPCITEMIDLIST pidlRel2 = _ILNext(pidl2);
    if (ILIsEmpty(pidlRel1))
    {
        if (ILIsEmpty(pidlRel2)) {
            hres = 0;
        } else {
            hres = (HRESULT)-1;
        }
    }
    else
    {
        if (ILIsEmpty(pidlRel2))
        {
            hres = 1;
        }
        else
        {
            //
            // Neither pidlRel1 nor pidlRel2 is empty.
            //  (1) Bind to the next level of the IShellFolder
            //  (2) Call its CompareIDs to let it compare the rest of IDs.
            //
            // Notes: We should create pidlNext not from pidl2 but from pidl1
            //  because fstreex.c may pass simple pidl2.
            //
            LPITEMIDLIST pidlNext = ILClone(pidl1);
            if (pidlNext)
            {
                IShellFolder *psfNext;
                _ILNext(pidlNext)->mkid.cb = 0;
                hres = psfParent->BindToObject(pidlNext, NULL,
                                &IID_IShellFolder, &psfNext);

                if (SUCCEEDED(hres))
                {
                    hres = psfNext->CompareIDs(0, pidlRel1, pidlRel2);
                    psfNext->Release();
                }
                CoTaskMemFree(pidlNext);
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }
    return hres;
}

void StrRetFormat(LPSTRRET pStrRet, LPCITEMIDLIST pidlRel, LPCSTR pszTemplate, LPCSTR pszAppend)
{
     LPSTR pszRet;
     char szT[MAX_PATH];

     StrRetToStrN(szT, sizeof(szT), pStrRet, pidlRel);
     pszRet = ShellConstructMessageString(HINST_THISDLL, pszTemplate, pszAppend, szT);
     if (pszRet)
     {
        pStrRet->uType = STRRET_CSTR;
        lstrcpyn(pStrRet->cStr, pszRet, sizeof(pStrRet->cStr));
        Free(pszRet);
     }
}

//
// Notes: This one passes SHGDN_FORMARSING to ISF::GetDisplayNameOf.
//
HRESULT ILGetRelDisplayName(IShellFolder *psf, LPSTRRET pStrRet,
                                   LPCITEMIDLIST pidlRel, LPCSTR pszName,
                                   LPCSTR pszTemplate)
{
    HRESULT hres;
    LPITEMIDLIST pidlLeft = ILCloneFirst(pidlRel);

    if (pidlLeft)
    {
        IShellFolder *psfNext;
        hres = psf->BindToObject(pidlLeft, NULL, &IID_IShellFolder, &psfNext);
        if (SUCCEEDED(hres))
        {
            LPCITEMIDLIST pidlRight = _ILNext(pidlRel);
            hres = psfNext->GetDisplayNameOf(pidlRight, SHGDN_INFOLDER|SHGDN_FORPARSING, pStrRet);
            if (SUCCEEDED(hres))
            {
                if (pszTemplate)
                {
                    StrRetFormat(pStrRet, pidlRight, pszTemplate, pszName);
                }
                else
                {
                    hres = StrRetCatLeft(pszName, pStrRet, pidlRight);
                }
            }
            psfNext->Release();
        }
        
        CoTaskMemFree(pidlLeft);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

LPITEMIDLIST ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend)
{
    UINT cbUsed, cbRequired;

    // Create the ID list, if it is not given.
    if (!pidl)
    {
        pidl = ILCreate();
        if (!pidl)
            return NULL;        // memory overflow
    }

    cbUsed = ILGetSize(pidl);
    cbRequired = cbUsed + pmkid->cb;

    pidl = _ILResize(pidl, cbRequired, CBIDL_INCL);
    if (!pidl)
        return NULL;    // memory overflow

    if (fAppend)
    {
        // Append it.
        CopyMemory(_ILSkip(pidl, cbUsed-sizeof(pidl->mkid.cb)), pmkid, pmkid->cb);
    }
    else
    {
        // Put it at the top
        MoveMemory(_ILSkip(pidl, pmkid->cb), pidl, cbUsed);
        CopyMemory(pidl, pmkid, pmkid->cb);
    }

    // We must put zero-terminator because of LMEM_ZEROINIT.
    _ILSkip(pidl, cbRequired-sizeof(pidl->mkid.cb))->mkid.cb = 0;
    return pidl;
}


BOOL ILGetDisplayName(LPCITEMIDLIST pidl, LPSTR pszPath)
{
    BOOL fSuccess = FALSE; // assume error
    STRRET srName;
    IShellFolder *psfDesktop;

    SHGetDesktopFolder(&psfDesktop);

    VALIDATE_PIDL(pidl);
    if (SUCCEEDED(psfDesktop->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &srName)))
    {
        StrRetToStrN(pszPath, MAX_PATH, &srName, pidl);
        fSuccess = TRUE;
    }

    return fSuccess;
}

#endif // not used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\ddespy.c ===
/****************************************************************************

    PROGRAM: DdeSpy.c

****************************************************************************/

#define UNICODE
#include <windows.h>                /* required for all Windows applications */
#include <windowsx.h>
#include <shellapi.h>
#include <dde.h>
#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "ddespy.h"
#include "lists.h"

/* GLOBAL Variables used for DDESPY */

UINT        idInst = 0;
HINSTANCE   hInst;
HICON       hIcon;
HWND        hWndString = NULL;
HWND        hwndSpy = NULL;
HANDLE      fhOutput = NULL;
OFSTRUCT    ofsOpen;
TCHAR        OpenName[MAX_FNAME + 1];
TCHAR        TBuf[BUFFER_SIZE];
TCHAR        TBuf2[BUFFER_SIZE];
TCHAR        szNULL[] = TEXT("");
LPTSTR        apszResources[IDS_LAST + 1];
PFNCALLBACK pfnDdeCallback = NULL;
HWND        hwndTrack[IT_COUNT] = { 0 };
LPTSTR        TrackTitle[IT_COUNT];
BOOL        fBlockMsg[WM_DDE_LAST - WM_DDE_FIRST + 1] = { 0 };
BOOL        fBlockCb[15] = { 0 };
LPTSTR        TrackHeading[IT_COUNT];
struct {                           /* profile data */
    BOOL fOutput[IO_COUNT];
    BOOL fFilter[IF_COUNT];
    BOOL fTrack[IT_COUNT];
    BOOL fTerse;
} pro;



BOOL LoadResourceStrings()
{
    int i, cbLeft, cbRes;
    LPTSTR psz;

    cbLeft = 0x1000;
    psz = LocalAlloc(LPTR, sizeof(TCHAR) * cbLeft);
    for (i = 0; i <= IDS_LAST; i++) {
        apszResources[i] = psz;
        cbRes = LoadString(hInst, i, psz, cbLeft) + 1;
        cbLeft -= cbRes;
        psz += cbRes;
    }
    for (i = 0; i < IT_COUNT; i++) {
        TrackTitle[i] = RefString(IDS_TRACKTITLE_1 + i);
        TrackHeading[i] = RefString(IDS_TRACKHEADING_1 + i);
    }
    lstrcpy(TBuf, RefString(IDS_DEFAULT_OUTPUT_FNAME));
    GetFullPathName(TBuf, sizeof(OpenName) / sizeof(TCHAR),
            OpenName, (LPTSTR *)TBuf2);
    return(TRUE);
}

int
WINAPI
WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{
    MSG msg;

    UNREFERENCED_PARAMETER(lpCmdLine);

    hInst = hInstance;

    if (!LoadResourceStrings()) {
        return (FALSE);
    }

    if (!hPrevInstance)
        if (!InitApplication(hInstance)) /* Initialize shared things */
            return (FALSE);              /* Exits if unable to initialize    */

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow)) {
        CloseApp();
        return (FALSE);
    }

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,        /* message structure                      */
            NULL,                  /* handle of window receiving the message */
            0,                     /* lowest message to examine              */
            0))                    /* highest message to examine             */
        {
        TranslateMessage(&msg);    /* Translates virtual key codes           */
        DispatchMessage(&msg);     /* Dispatches message to window           */
    }
    CloseApp();
    return ((int)msg.wParam);           /* Returns the value from PostQuitMessage */
}



BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;

    if (!InitTestSubs())
        return(FALSE);

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;                    /* Class style(s).                    */
    wc.lpfnWndProc = (WNDPROC)MainWndProc;       /* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra = 0;                  /* No per-class extra data.           */
    wc.cbWndExtra = 0;                  /* No per-window extra data.          */
    wc.hInstance = hInstance;           /* Application that owns the class.   */
					/* faster, also can localize "DDESpy" */
    hIcon = wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DDESPY));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MAKEINTRESOURCE(IDR_MENU);   /* Name of menu resource in .RC file. */
    wc.lpszClassName = RefString(IDS_CLASS);

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));
}


BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT            Rect;
    INT             i;

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    pfnDdeCallback = (PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback,
            hInstance);

    GetProfile();

    /* Create a main window for this application instance.  */

    hwndSpy = CreateWindow(
        RefString(IDS_CLASS),
        RefString(IDS_TITLE),
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT,                  /* Default horizontal position.       */
        CW_USEDEFAULT,                  /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
        NULL,                           /* Use the window class menu.         */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );


    GetClientRect(hwndSpy, (LPRECT) &Rect);

    hWndString = CreateWindow(          /* String Window (class Registered in Teststubs)*/
        RefString(IDS_STRINGCLASS),
        szNULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
        0,
        0,
        Rect.right - Rect.left,
        Rect.bottom - Rect.top,
        hwndSpy,
        NULL,
        hInst,
        (LPTSTR)LongToPtr(MAKELONG(CCHARS, CLINES)));

    for (i = 0; i < IT_COUNT; i++) {
        if (pro.fTrack[i]) {
            pro.fTrack[i] = FALSE;
            SendMessage(hwndSpy, WM_COMMAND,
                    GET_WM_COMMAND_MPS(IDM_TRACK_FIRST + i, 0, 0));
        }
    }

    if (!hwndSpy || !hWndString) {
        CloseApp();
        return (FALSE);
    }

    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hwndSpy, nCmdShow);  /* Show the window                        */
    UpdateWindow(hwndSpy);          /* Sends WM_PAINT message                 */

    if (SetFilters()) {
        return(FALSE);
    }

    return(TRUE);
}


VOID CloseApp()
{
    DdeUninitialize(idInst);        /* perform cleanup and store profile */
    SaveProfile();
    if (fhOutput != NULL)
        CloseHandle(fhOutput);
    UnregisterClass(RefString(IDS_CLASS), hInst);
    CloseTestSubs(hInst);
}



LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int i;

    switch (message) {
    case WM_CREATE:
        LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCEL));
        if (pro.fOutput[IO_FILE])
            fhOutput = (HANDLE)DoDialog(
                    MAKEINTRESOURCE(IDD_OPEN),
                    (DLGPROC)OpenDlg,
                    0,
                    TRUE,
                    hWnd,
                    hInst);
            pro.fOutput[IO_FILE] = (fhOutput != NULL);
        break;

    case WM_INITMENU:
        if (GetMenu(hWnd) != (HMENU)wParam)
            break;

        for (i = 0; i < IO_COUNT; i++) {
        CheckMenuItem((HMENU)wParam, IDM_OUTPUT_FIRST + i,
                pro.fOutput[i] ? MF_CHECKED : MF_UNCHECKED);
        }

        for (i = 0; i < IF_COUNT; i++) {
            CheckMenuItem((HMENU)wParam, IDM_FILTER_FIRST + i,
                pro.fFilter[i] ? MF_CHECKED : MF_UNCHECKED);
        }

        for (i = 0; i < IT_COUNT; i++) {
            CheckMenuItem((HMENU)wParam, IDM_TRACK_FIRST + i,
                pro.fTrack[i] ? MF_CHECKED : MF_UNCHECKED);
        }
        break;

    case WM_COMMAND:           /* message: command from application menu */
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDM_OUTPUT_FILE:
        case IDM_OUTPUT_DEBUG:
        case IDM_OUTPUT_SCREEN:
            switch (wParam) {
            case IDM_OUTPUT_FILE:
                if (fhOutput != NULL) {
                    wsprintf(TBuf, RefString(IDS_QCLOSEFILE_TEXT), OpenName);
                    if (IDYES != MessageBox(hWnd,
                            TBuf, RefString(IDS_QCLOSEFILE_CAPTION),
                            MB_YESNO | MB_ICONQUESTION)) {
                        break;
                    }
                    CloseHandle(fhOutput);
                }
                fhOutput = (HANDLE)DoDialog(
                        MAKEINTRESOURCE(IDD_OPEN),
                        (DLGPROC)OpenDlg,
                        0,
                        TRUE,
                        hWnd,
                        hInst);
                pro.fOutput[IO_FILE] = (fhOutput != NULL);
                break;

            case IDM_OUTPUT_DEBUG:
                pro.fOutput[IO_DEBUG] = !pro.fOutput[IO_DEBUG];
                break;

            case IDM_OUTPUT_SCREEN:
                pro.fOutput[IO_SCREEN] = !pro.fOutput[IO_SCREEN];
                break;

            }
            break;

        case IDM_CLEARSCREEN:
            if (hWndString) {
                HANDLE hpsw;
                STRWND *psw;

                hpsw = (HANDLE)GetWindowLongPtr(hWndString, 0);
                psw = (STRWND *)LocalLock(hpsw);
                ClearScreen(psw);
                LocalUnlock(hpsw);
                InvalidateRect(hWndString, NULL, TRUE);
            }
            break;

        case IDM_MARK:
            DoDialog(MAKEINTRESOURCE(IDD_VALUEENTRY), (DLGPROC)MarkDlgProc, 0, TRUE, hWnd, hInst);
            break;

        case IDM_FILTER_HSZINFO:
        case IDM_FILTER_INIT_TERM:
        case IDM_FILTER_DDEMSGS:
        case IDM_FILTER_CALLBACKS:
        case IDM_FILTER_ERRORS:
            pro.fFilter[wParam - IDM_FILTER_FIRST] =
                    !pro.fFilter[wParam - IDM_FILTER_FIRST];
            SetFilters();
            break;

        case IDM_FILTER_DIALOG:
            DoDialog(MAKEINTRESOURCE(IDD_MSGFILTERS), (DLGPROC)FilterDlgProc, 0, TRUE, hWnd, hInst);
            break;

        case IDM_TRACK_HSZS:
        case IDM_TRACK_CONVS:
        case IDM_TRACK_LINKS:
        case IDM_TRACK_SVRS:
            pro.fTrack[wParam - IDM_TRACK_FIRST] =
                    !pro.fTrack[wParam - IDM_TRACK_FIRST];
            if (pro.fTrack[wParam - IDM_TRACK_FIRST]) {
                hwndTrack[wParam - IDM_TRACK_FIRST] = CreateMCLBFrame(
                        NULL,
                        TrackTitle[wParam - IDM_TRACK_FIRST],
                        WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_MINIMIZE,
                        hIcon, (HBRUSH)(COLOR_APPWORKSPACE + 1),
                        TrackHeading[wParam - IDM_TRACK_FIRST]);
            } else {
                DestroyWindow(hwndTrack[wParam - IDM_TRACK_FIRST]);
                hwndTrack[wParam - IDM_TRACK_FIRST] = 0;
            }
            SetFilters();
            break;

        case IDM_ABOUT:
            DoDialog(MAKEINTRESOURCE(IDD_ABOUTBOX), (DLGPROC)About, 0, TRUE, hWnd, hInst);
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        break;

    case WM_DESTROY:                  /* message: window being destroyed */
        for (i = IDM_TRACK_FIRST; i <= IDM_TRACK_LAST; i++) {
            if (pro.fTrack[i - IDM_TRACK_FIRST]) {
                DestroyWindow(hwndTrack[i - IDM_TRACK_FIRST]);
                hwndTrack[i - IDM_TRACK_FIRST] = 0;
            }
        }
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        if (hWndString) {
            RECT rc;

            GetClientRect(hWnd, &rc);
            MoveWindow(hWndString, 0, 0, rc.right, rc.bottom, TRUE);
        }
        // fall through
    default:
        return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}





BOOL  CALLBACK About(
                    HWND hDlg,
                    UINT message,
                    WPARAM wParam,
                    LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDOK
                || GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL) {
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */
}


HDDEDATA CALLBACK DdeCallback(
                            UINT wType,
                            UINT wFmt,
                            HCONV hConv,
                            HSZ hsz1,
                            HSZ hsz2,
                            HDDEDATA hData,
                            UINT dwData1,
                            UINT dwData2)
{
    LPVOID pData;
    UINT cb;
    TCHAR *psz1, *psz2, *psz3;
    TCHAR *szAction;
    INT i;
    BOOL fInt = FALSE;
    wFmt;
    hConv;
    dwData1;

    switch (wType) {
    case XTYP_MONITOR:
    if (pData = DdeAccessData(hData, (LPDWORD)&cb)) {
        switch (dwData2) {
        case MF_HSZ_INFO:
            if (pro.fTrack[IT_HSZS]) {
                switch (((MONHSZSTRUCT FAR *)pData)->fsAction) {
                case MH_DELETE:
                    wsprintf(TBuf, fInt ? TEXT("0x%lx\t*\t%s(int)")
			    : TEXT("0x%lx\t*\t%s"),
                            ((MONHSZSTRUCT FAR *)pData)->hsz,
                            (LPTSTR)((MONHSZSTRUCT FAR *)pData)->str);
                    i = GetMCLBColValue(TBuf, hwndTrack[IT_HSZS], 2);
                    if (i > 1) {
                        wsprintf(TBuf2, fInt ? TEXT("0x%lx\t%d\t%s(int)")
				: TEXT("0x%lx\t%d\t%s"),
                                ((MONHSZSTRUCT FAR *)pData)->hsz,
                                 i - 1,
                                 (LPTSTR)((MONHSZSTRUCT FAR *)pData)->str);
                        AddMCLBText(TBuf, TBuf2, hwndTrack[IT_HSZS]);
                    } else if (i == 1) {
                        DeleteMCLBText(TBuf, hwndTrack[IT_HSZS]);
                    }
                    break;

                case MH_KEEP:
                case MH_CREATE:
                    wsprintf(TBuf, fInt ? TEXT("0x%lx\t*\t%s(int)")
			    : TEXT("0x%lx\t*\t%s"),
                            ((MONHSZSTRUCT FAR *)pData)->hsz,
                            (LPTSTR)((MONHSZSTRUCT FAR *)pData)->str);
                    i = GetMCLBColValue(TBuf, hwndTrack[IT_HSZS], 2) + 1;
                    wsprintf(TBuf2, fInt ? TEXT("0x%lx\t%d\t%s(int)")
			    : TEXT("0x%lx\t%d\t%s"),
                            ((MONHSZSTRUCT FAR *)pData)->hsz,
                             i,
                             (LPTSTR)((MONHSZSTRUCT FAR *)pData)->str);
                    AddMCLBText(TBuf, TBuf2, hwndTrack[IT_HSZS]);
                }
            }

            if (!pro.fFilter[IF_HSZ]) {
                DdeUnaccessData(hData);
                return(0);
            }

            switch (((MONHSZSTRUCT FAR *)pData)->fsAction) {
            case MH_CLEANUP:
                szAction = RefString(IDS_ACTION_CLEANEDUP);
                break;

            case MH_DELETE:
                szAction = RefString(IDS_ACTION_DESTROYED);
                break;

            case MH_KEEP:
                szAction = RefString(IDS_ACTION_INCREMENTED);
                break;

            case MH_CREATE:
                szAction = RefString(IDS_ACTION_CREATED);
                break;

            default:
                DdeUnaccessData(hData);
                return(0);
            }
            if (pro.fTerse) {
                wsprintf(TBuf, TEXT("[%x:%ld] HSZ %s: %lx(%s)"),
                        ((MONHSZSTRUCT FAR *)pData)->hTask,
                        ((MONHSZSTRUCT FAR *)pData)->dwTime,
                        (LPTSTR)szAction,
                        ((MONHSZSTRUCT FAR *)pData)->hsz,
                        (LPTSTR)((MONHSZSTRUCT FAR *)pData)->str);
            } else {
                wsprintf(TBuf,
			/* so we can localize message */
			RefString(IDS_FMT_SH_MSG1),
                        ((MONHSZSTRUCT FAR *)pData)->hTask,
                        ((MONHSZSTRUCT FAR *)pData)->dwTime,
                        (LPTSTR)szAction,
                        ((MONHSZSTRUCT FAR *)pData)->hsz,
                        (LPTSTR)((MONHSZSTRUCT FAR *)pData)->str);
            }
            break;


        case MF_SENDMSGS:
        case MF_POSTMSGS:
            if (fBlockMsg[((MONMSGSTRUCT FAR *)pData)->wMsg - WM_DDE_FIRST]) {
                DdeUnaccessData(hData);
                return(0);
            }
            if (pro.fTerse) {
                wsprintf(TBuf, RefString(IDS_FMT_TRS_MSG1),
                        ((MONMSGSTRUCT FAR *)pData)->hTask,
                        ((MONMSGSTRUCT FAR *)pData)->dwTime,
                        ((MONMSGSTRUCT FAR *)pData)->wParam,
                        ((MONMSGSTRUCT FAR *)pData)->hwndTo,
                        (dwData2 == MF_SENDMSGS) ? RefString(IDS_SENT) : RefString(IDS_POSTED),
                        (LPTSTR)DdeMsg2String(((MONMSGSTRUCT FAR *)pData)->wMsg));
            } else {
                wsprintf(TBuf, RefString(IDS_FMT_MSG1),
                        ((MONMSGSTRUCT FAR *)pData)->hTask,
                        ((MONMSGSTRUCT FAR *)pData)->dwTime,
                        ((MONMSGSTRUCT FAR *)pData)->hwndTo,
                        (dwData2 == MF_SENDMSGS) ? RefString(IDS_SENT) : RefString(IDS_POSTED),
                        (LPTSTR)DdeMsg2String(((MONMSGSTRUCT FAR *)pData)->wMsg));
            }
            OutputString(TBuf);
            wsprintf(TBuf, pro.fTerse ? RefString(IDS_FMT_TRS_MSG2) : RefString(IDS_FMT_MSG2),
                        ((MONMSGSTRUCT FAR *)pData)->wParam);
            DisectMsgLP(((MONMSGSTRUCT FAR *)pData)->wMsg,
                        ((MONMSGSTRUCT FAR *)pData),
                        &TBuf[lstrlen(TBuf)]);
            break;


        case MF_CALLBACKS:
            if (fBlockCb[(((MONCBSTRUCT FAR *)pData)->wType & XTYP_MASK) >> XTYP_SHIFT]) {
                DdeUnaccessData(hData);
                return(0);
            }
            wsprintf(TBuf,
                    pro.fTerse ? RefString(IDS_FMT_TRS_CB1) : RefString(IDS_FMT_CB1),
                    ((MONCBSTRUCT FAR *)pData)->hTask,
                    ((MONCBSTRUCT FAR *)pData)->dwTime,
                    (LPTSTR)Type2String(((MONCBSTRUCT FAR *)pData)->wType));
            wsprintf(DumpFormat(((MONCBSTRUCT FAR *)pData)->wFmt, &TBuf[lstrlen(TBuf)]),
                    pro.fTerse ? RefString(IDS_FMT_TRS_CB2) : RefString(IDS_FMT_CB2),
                    (UINT_PTR)((MONCBSTRUCT FAR *)pData)->hConv,
                    ((MONCBSTRUCT FAR *)pData)->hsz1,
                    (LPTSTR)(psz1 = GetHszName(((MONCBSTRUCT FAR *)pData)->hsz1)),
                    ((MONCBSTRUCT FAR *)pData)->hsz2,
                    (LPTSTR)(psz2 = GetHszName(((MONCBSTRUCT FAR *)pData)->hsz2)),
                    ((MONCBSTRUCT FAR *)pData)->hData,
                    ((MONCBSTRUCT FAR *)pData)->dwData1,
                    ((MONCBSTRUCT FAR *)pData)->dwData2,
                    ((MONCBSTRUCT FAR *)pData)->dwRet);
            MyFree(psz1);
            MyFree(psz2);
            OutputString(TBuf);
            if (((MONCBSTRUCT FAR *)pData)->dwData1 &&
               (((MONCBSTRUCT FAR *)pData)->wType == XTYP_CONNECT ||
               ((MONCBSTRUCT FAR *)pData)->wType == XTYP_WILDCONNECT)) {
                // display proposed context
                wsprintf(TBuf,
                    pro.fTerse ? RefString(IDS_FMT_TRS_CTXT1) : RefString(IDS_FMT_CTXT1),
                    ((MONCBSTRUCT FAR *)pData)->cc.wFlags,
                    ((MONCBSTRUCT FAR *)pData)->cc.wCountryID,
                    ((MONCBSTRUCT FAR *)pData)->cc.iCodePage,
                    ((MONCBSTRUCT FAR *)pData)->cc.dwLangID,
                    ((MONCBSTRUCT FAR *)pData)->cc.dwSecurity,
                    ((MONCBSTRUCT FAR *)pData)->cc.qos.ImpersonationLevel,
                    ((MONCBSTRUCT FAR *)pData)->cc.qos.ContextTrackingMode,
                    ((MONCBSTRUCT FAR *)pData)->cc.qos.EffectiveOnly);
                OutputString(TBuf);
            }
            if (((MONCBSTRUCT FAR *)pData)->hData && ((MONCBSTRUCT FAR *)pData)->cbData) {
                wsprintf(TBuf, RefString(IDS_INPUT_DATA));
                OutputString(TBuf);
                DumpData((LPBYTE)((MONCBSTRUCT FAR *)pData)->Data,
                                 ((MONCBSTRUCT FAR *)pData)->cbData,
                                 TBuf,
                                 ((MONCBSTRUCT FAR *)pData)->wFmt);
                OutputString(TBuf);
                if (cb > MAX_DISPDATA)
                    OutputString(RefString(IDS_TABDDD));
                // DdeUnaccessData(((MONCBSTRUCT FAR *)pData)->hData);
            }
            if ((((MONCBSTRUCT FAR *)pData)->wType & XCLASS_DATA) &&
                 ((MONCBSTRUCT FAR *)pData)->dwRet &&
                 ((MONCBSTRUCT FAR *)pData)->cbData) {
                wsprintf(TBuf, RefString(IDS_OUTPUT_DATA));
                OutputString(TBuf);
                DumpData((LPBYTE)((MONCBSTRUCT FAR *)pData)->Data,
                                 ((MONCBSTRUCT FAR *)pData)->cbData,
                                 TBuf,
                                 ((MONCBSTRUCT FAR *)pData)->wFmt);
                OutputString(TBuf);
                if (cb > MAX_DISPDATA)
                    OutputString(RefString(IDS_TABDDD));
                // DdeUnaccessData(((MONCBSTRUCT FAR *)pData)->dwRet);
            }
            DdeUnaccessData(hData);
            return(0);
            break;

        case MF_ERRORS:
            wsprintf(TBuf, pro.fTerse ? RefString(IDS_FMT_TRS_ER1) : RefString(IDS_FMT_ER1),
                    ((MONERRSTRUCT FAR *)pData)->hTask,
                    ((MONERRSTRUCT FAR *)pData)->dwTime,
                    ((MONERRSTRUCT FAR *)pData)->wLastError,
                    (LPTSTR)Error2String(((MONERRSTRUCT FAR *)pData)->wLastError));
            break;


        case MF_LINKS:
            psz1 = GetHszName(((MONLINKSTRUCT FAR *)pData)->hszSvc);
            psz2 = GetHszName(((MONLINKSTRUCT FAR *)pData)->hszTopic);
            psz3 = GetHszName(((MONLINKSTRUCT FAR *)pData)->hszItem);
            if (!GetClipboardFormatName(((MONLINKSTRUCT FAR *)pData)->wFmt, TBuf2, BUFFER_SIZE))
                lstrcpy(TBuf2, pdf(((MONLINKSTRUCT FAR *)pData)->wFmt));
            if (!lstrcmp(RefString(IDS_HUH), TBuf2)) {
                wsprintf(TBuf2, TEXT("%d"), ((MONLINKSTRUCT FAR *)pData)->wFmt);
            }

            wsprintf(TBuf, TEXT("%s\t%s\t%s\t%s\t%s\t%lx\t%lx"),
                    (LPTSTR)psz1, (LPTSTR)psz2, (LPTSTR)psz3,
                    (LPTSTR)TBuf2,
                    ((MONLINKSTRUCT FAR *)pData)->fNoData ?
                     RefString(IDS_WARM) : RefString(IDS_HOT),
                    ((MONLINKSTRUCT FAR *)pData)->hConvClient,
                    ((MONLINKSTRUCT FAR *)pData)->hConvServer);

            if (((MONLINKSTRUCT FAR *)pData)->fEstablished) {
                AddMCLBText(TBuf, TBuf, hwndTrack[IT_LINKS]);
            } else {
                DeleteMCLBText(TBuf, hwndTrack[IT_LINKS]);
            }

            MyFree(psz1);
            MyFree(psz2);
            MyFree(psz3);
            DdeUnaccessData(hData);
            return(0);


        case MF_CONV:
            psz1 = GetHszName(((MONCONVSTRUCT FAR *)pData)->hszSvc);
            psz2 = GetHszName(((MONCONVSTRUCT FAR *)pData)->hszTopic);

            wsprintf(TBuf, TEXT("%s\t%s\t%lx\t%lx"),
                    (LPTSTR)psz1, (LPTSTR)psz2,
                    ((MONCONVSTRUCT FAR *)pData)->hConvClient,
                    ((MONCONVSTRUCT FAR *)pData)->hConvServer);

            if (((MONCONVSTRUCT FAR *)pData)->fConnect) {
                AddMCLBText(TBuf, TBuf, hwndTrack[IT_CONVS]);
            } else {
                DeleteMCLBText(TBuf, hwndTrack[IT_CONVS]);
            }

            MyFree(psz1);
            MyFree(psz2);
            DdeUnaccessData(hData);
            return(0);


        default:
            lstrcpy(TBuf, RefString(IDS_UNKNOWN_CALLBACK));
        }
        DdeUnaccessData(hData);
        OutputString(TBuf);
    }
    break;

    case XTYP_REGISTER:
    case XTYP_UNREGISTER:
        if (!pro.fTrack[IT_SVRS]) {
            return(0);
        }
        psz1 = GetHszName(hsz1);
        psz2 = GetHszName(hsz2);
        wsprintf(TBuf, TEXT("%s\t%s"), (LPTSTR)psz1, (LPTSTR)psz2);
        if (wType == XTYP_REGISTER) {
            AddMCLBText(NULL, TBuf, hwndTrack[IT_SVRS]);
        } else {
            DeleteMCLBText(TBuf, hwndTrack[IT_SVRS]);
        }
        MyFree(psz1);
        MyFree(psz2);
        break;
    }
    return(0);
}


LPTSTR DisectMsgLP(UINT msg, MONMSGSTRUCT *pmms,  LPTSTR pszBuf)
{
    static LONG m2t[] = {

    /*              LOW                       HIGH */

        MAKELONG(T_APP | T_ATOM,        T_TOPIC | T_ATOM),  // WM_DDE_INITIATE
        0,                                                  // WM_DDE_TERMINATE
        MAKELONG(T_OPTIONHANDLE,        T_ITEM | T_ATOM),   // WM_DDE_ADVISE
        MAKELONG(T_FORMAT,              T_ITEM | T_ATOM),   // WM_DDE_UNADVISE
        MAKELONG(T_APP | T_ATOM | T_OR | T_STATUS,
                                        T_TOPIC | T_ITEM | T_ATOM | T_OR | T_STRINGHANDLE),
                                                            // WM_DDE_ACK
        MAKELONG(T_DATAHANDLE,          T_ITEM | T_ATOM),   // WM_DDE_DATA
        MAKELONG(T_FORMAT,              T_ITEM | T_ATOM),   // WM_DDE_REQUEST
        MAKELONG(T_DATAHANDLE,          T_ITEM | T_ATOM),   // WM_DDE_POKE
        MAKELONG(0,                     T_STRINGHANDLE),    // WM_DDE_EXECUTE
    };

    // ASSUMED: msg is a valid DDE message!!!

    pszBuf = DisectWord(LOWORD(m2t[msg - WM_DDE_FIRST]),
                        (UINT)pmms->dmhd.uiLo, &pmms->dmhd, pszBuf);
    *pszBuf++ = TEXT('\r');
    *pszBuf++ = TEXT('\n');
    *pszBuf++ = TEXT('\t');
    return(DisectWord(HIWORD(m2t[msg - WM_DDE_FIRST]),
                        (UINT)pmms->dmhd.uiHi, &pmms->dmhd, pszBuf));
}




/*
 * Allocates local memory for and retrieves the string form of an HSZ.
 * Returns a pointer to the local memory or NULL if failure.
 * The string must be freed via MyFree().
 */
LPTSTR GetHszName(HSZ hsz)
{
    LPTSTR psz;
    UINT cb;

    cb = (UINT)DdeQueryString(idInst, hsz, NULL, 0, 0) + 1;
    psz = LocalAlloc (LPTR, sizeof(TCHAR) * cb);
    DdeQueryString(idInst, hsz, psz, cb, 0);
    return(psz);
}


LPTSTR
DisectWord(
    UINT type,
    UINT data,
    DDEML_MSG_HOOK_DATA *pdmhd,
    LPTSTR pstr
    )
{
    UINT wT;

    *pstr = TEXT('\0');   // in case we do nothing.

    if (type & T_ATOM) {
        wT = GlobalGetAtomName((ATOM)data, (LPTSTR)pstr, 25);
        if (wT || data == 0) {
            if (type & T_APP) {
                lstrcpy(pstr, RefString(IDS_APPIS));
                pstr += lstrlen(pstr);
            }

            if (type & T_TOPIC) {
                lstrcpy(pstr, RefString(IDS_TOPICIS));
                pstr += lstrlen(pstr);
            }

            if (type & T_ITEM) {
                lstrcpy(pstr, RefString(IDS_ITEMIS));
                pstr += lstrlen(pstr);
            }
        }
        if (wT) {
            wsprintf(pstr, TEXT("0x%x(\""), data);
            pstr += lstrlen(pstr);
            GlobalGetAtomName((ATOM)data, (LPTSTR)pstr, 25);
            pstr += wT;
            if (wT == 25) {
                *pstr++ = TEXT('.');
                *pstr++ = TEXT('.');
                *pstr++ = TEXT('.');
            }
            *pstr++ = TEXT('\"');
            *pstr++ = TEXT(')');
            *pstr = TEXT('\0');
            type &= ~(T_OR | T_STRINGHANDLE);  // its an atom, so its not an object!
        } else if (data == 0) {     // could be a wild atom
            *pstr++ = TEXT('*');
            *pstr = TEXT('\0');
        } else if (type & T_OR) {
            type &= ~T_OR;   // not an atom, must be somthin else.
        } else {
	    /* so we can localize message */
            wsprintf(pstr, RefString(IDS_BADATOM), data);
            pstr += lstrlen(pstr);
        }
    }

    if (type & T_OR) {
        lstrcpy(pstr, RefString(IDS_OR));
        pstr += lstrlen(pstr);
    }


    if (type & T_OPTIONHANDLE) {
        if (pdmhd->cbData >= 4) {
            wsprintf(pstr, pro.fTerse ? RefString(IDS_FMT_TRS_STATUSIS) : RefString(IDS_FMT_STATUSIS), LOWORD(pdmhd->Data[0]));
            pstr += lstrlen(pstr);
            if (LOWORD(pdmhd->Data[0]) & DDE_FACKREQ) {
                lstrcpy(pstr, RefString(IDS_FACKREQ));
                pstr += lstrlen(pstr);
            }
            if (LOWORD(pdmhd->Data[0]) & DDE_FDEFERUPD) {
                lstrcpy(pstr, RefString(IDS_DEFERUPD));
                pstr += lstrlen(pstr);
            }
            *pstr++ = TEXT(')');
            *pstr++ = TEXT(' ');
            pstr = DumpFormat((UINT)HIWORD(pdmhd->Data[0]), pstr);
        }
    }

    if (type & T_FORMAT) {
        pstr = DumpFormat(data, pstr);
    }

    if (type & T_STATUS) {
        wsprintf(pstr, pro.fTerse ? RefString(IDS_FMT_TRS_STATUSIS) : RefString(IDS_FMT_STATUSIS), LOWORD(data));
        pstr += lstrlen(pstr);
        if (data & DDE_FACK) {
            lstrcpy(pstr, RefString(IDS_FACK));
            pstr += lstrlen(pstr);
        }
        if (data & DDE_FBUSY) {
            lstrcpy(pstr, RefString(IDS_FBUSY));
            pstr += lstrlen(pstr);
        }
        *pstr++ = TEXT(')');
        *pstr = TEXT('\0');
    }

    if (type & T_STRINGHANDLE && pdmhd->cbData) {
        WCHAR szData[16];

        memset(szData, '\0', 16 * sizeof(WCHAR));
        memcpy(szData, pdmhd->Data, min(16 * sizeof(WCHAR), pdmhd->cbData));
        szData[15] = L'\0';
        wsprintf(pstr, pro.fTerse ?
                    RefString(IDS_FMT_TRS_EXEC1) : RefString(IDS_FMT_EXEC1), (LPWSTR)szData);
        pstr += lstrlen(pstr);
        *pstr = TEXT('\0');
    }

    if (type & T_DATAHANDLE && pdmhd->cbData) {
        wsprintf(pstr, pro.fTerse ?
                    RefString(IDS_FMT_TRS_STATUSIS) : RefString(IDS_FMT_STATUSIS),
                    LOWORD(pdmhd->Data[0]));
        pstr += lstrlen(pstr);
        if (LOWORD(pdmhd->Data[0]) & DDE_FRELEASE) {
            lstrcpy(pstr, RefString(IDS_FRELEASE));
            pstr += lstrlen(pstr);
        }
        if (LOWORD(pdmhd->Data[0]) & DDE_FREQUESTED) {
            lstrcpy(pstr, RefString(IDS_FREQUESTED));
            pstr += lstrlen(pstr);
        }
        *pstr++ = TEXT(')');
        *pstr++ = TEXT(' ');
        pstr = DumpFormat(HIWORD(pdmhd->Data[0]), pstr);
        lstrcpy(pstr, pro.fTerse ? RefString(IDS_FMT_TRS_DATAIS1) : RefString(IDS_FMT_DATAIS1));
        pstr += lstrlen(pstr);
        pstr = DumpData((LPBYTE)&pdmhd->Data[1], min(28, pdmhd->cbData - 4),
                pstr, HIWORD(pdmhd->Data[0]));
    }
    return(pstr);
}


LPTSTR pdf(UINT fmt)
{
    INT i;
    static struct {
        UINT fmt;
        LPTSTR psz;
    } fmts[] = {
        { CF_TEXT             ,     TEXT("CF_TEXT")           }   ,
        { CF_UNICODETEXT      ,     TEXT("CF_UNICODETEXT")    }   ,
        { CF_BITMAP           ,     TEXT("CF_BITMAP")         }   ,
        { CF_METAFILEPICT     ,     TEXT("CF_METAFILEPICT")   }   ,
        { CF_ENHMETAFILE      ,     TEXT("CF_ENHMETAFILE")    }   ,
        { CF_SYLK             ,     TEXT("CF_SYLK")           }   ,
        { CF_DIF              ,     TEXT("CF_DIF")            }   ,
        { CF_TIFF             ,     TEXT("CF_TIFF")           }   ,
        { CF_OEMTEXT          ,     TEXT("CF_OEMTEXT")        }   ,
        { CF_DIB              ,     TEXT("CF_DIB")            }   ,
        { CF_PALETTE          ,     TEXT("CF_PALETTE")        }   ,
    };
    for (i = 0; i < 10; i++)
        if (fmts[i].fmt == fmt)
            return(fmts[i].psz);
    return(RefString(IDS_HUH));
}



LPTSTR DumpFormat(UINT fmt, LPTSTR pstr)
{
    UINT cb;

    wsprintf(pstr, TEXT("fmt=0x%x(\""), (WORD)fmt);
    pstr += lstrlen(pstr);
    if (cb = GetClipboardFormatName(fmt, pstr, 25)) {
        pstr += cb;
        *pstr++ = TEXT('\"');
        *pstr++ = TEXT(')');
    } else {
        wsprintf(pstr, TEXT("%s\")"), (LPTSTR)pdf(fmt));
        pstr += lstrlen(pstr);
    }
    return(pstr);
}



LPTSTR DumpData(LPBYTE pData, UINT cb, TCHAR *szBuf, UINT fmt)
{
    register INT i;
    LPTSTR psz = szBuf;


    while (cb) {
        if (fmt == CF_TEXT || fmt == CF_UNICODETEXT) {
            *szBuf++ = TEXT('\t');
            if (fmt == CF_UNICODETEXT) {
                *szBuf++ = TEXT('U');
            }
            *szBuf++ = TEXT('\"');
            if (fmt == CF_UNICODETEXT) {
                memcpy(szBuf, pData, cb);
            } else {
                MultiByteToWideChar(CP_ACP, 0, pData, cb, szBuf, cb / sizeof(TCHAR));
            }
            szBuf[cb - 2] = TEXT('\0');
            lstrcat(szBuf, TEXT("\""));
            cb = 0;
        } else {
            for (i = 0; i < 80 ; i++) {
                szBuf[i] = TEXT(' ');
            }
            szBuf[0] = TEXT('\t');
            i = 0;
            while (cb && (i < 16)) {
                wsprintf(&szBuf[i * 3 + 1], TEXT("%02x "), pData[0]);
                wsprintf(&szBuf[17 * 3 + i + 1], TEXT("%c"), MPRT(pData[0]));
                pData++;
                cb--;
                i++;
            }
            szBuf[i * 3 + 1] = TEXT(' ');
            szBuf[17 * 3 + i + 1] = TEXT(' ');
            szBuf[68] = TEXT('\0');
        }
        szBuf += lstrlen(szBuf);
    }
    return(szBuf);
}



LPTSTR Error2String(UINT error)
{
    static TCHAR szErr[23];

    if (error == 0) {
        lstrcpy(szErr, RefString(IDS_ZERO));
    } else if (error > DMLERR_LAST || error < DMLERR_FIRST) {
        lstrcpy(szErr, RefString(IDS_HUH));
    } else {
        lstrcpy(szErr, apszResources[IDS_ERRST0 + error - DMLERR_FIRST]);
    }
    return(szErr);
}



LPTSTR DdeMsg2String(UINT msg)
{
    static TCHAR szBadMsg[10];

    if (msg < WM_DDE_FIRST || msg > WM_DDE_LAST) {
       wsprintf (szBadMsg, TEXT("%ld"), szBadMsg);
       return (szBadMsg);
//        return((LPTSTR)itoa(msg, szBadMsg, 10));
    } else {
        return(apszResources[IDS_MSG0 + msg - WM_DDE_FIRST]);
    }
}



VOID OutputString(LPTSTR pstr)
{
    DWORD cbWritten;

    if (pro.fOutput[IO_FILE] && fhOutput != NULL) {
        static CHAR szT[200];

        WideCharToMultiByte(
                CP_ACP,
                0,
                pstr,
                -1,
                szT,
                200,
                NULL,
                NULL);
        WriteFile(fhOutput, (LPCSTR) szT, lstrlenA(szT), &cbWritten, NULL);
        WriteFile(fhOutput, (LPCSTR) "\r\n", 2, &cbWritten, NULL);
        FlushFileBuffers(fhOutput);
    }
    if (pro.fOutput[IO_DEBUG]) {
        OutputDebugString((LPTSTR)pstr);
        OutputDebugString(RefString(IDS_CRLF));
    }
    if (pro.fOutput[IO_SCREEN]) {
        if (IsWindow(hWndString))
            DrawString(hWndString, pstr);
    }
}



BOOL SetFilters()
{
    UINT cbf;

    cbf = 0;
    if (pro.fTrack[IT_HSZS] || pro.fFilter[IF_HSZ])
        cbf |= MF_HSZ_INFO;
    if (pro.fTrack[IT_LINKS])
        cbf |= MF_LINKS;
    if (pro.fTrack[IT_CONVS])
        cbf |= MF_CONV;
    if (pro.fFilter[IF_SEND])
        cbf |= MF_SENDMSGS;
    if (pro.fFilter[IF_POST])
        cbf |= MF_POSTMSGS;
    if (pro.fFilter[IF_CB])
        cbf |= MF_CALLBACKS;
    if (pro.fFilter[IF_ERR])
        cbf |= MF_ERRORS;
    return((BOOL)DdeInitialize(&idInst, pfnDdeCallback, APPCLASS_MONITOR | cbf, 0));
}





/*
 * This dialog returns a file handle to the opened file name given or NULL
 * if cancel.
 */

BOOL CALLBACK OpenDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HANDLE fh;
    lParam;

    switch (message) {
        case WM_INITDIALOG:
            SetDlgItemText(hDlg, IDC_EDIT, (LPTSTR)OpenName);
            SendDlgItemMessage(hDlg, IDC_EDIT, EM_SETSEL,
                    GET_EM_SETSEL_MPS(0, 0x7fff));
            SetFocus(GetDlgItem(hDlg, IDC_EDIT));
            return (FALSE); /* Indicates the focus is set to a control */
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    GetDlgItemText(hDlg, IDC_EDIT, TBuf, MAX_FNAME);
                    GetFullPathName(TBuf, sizeof(OpenName), OpenName, (LPTSTR *)TBuf2);
                    fh = CreateFile(
                            OpenName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            (PSECURITY_ATTRIBUTES)NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
                    if (fh == INVALID_HANDLE_VALUE) {
                        MessageBox(hDlg, RefString(IDS_INVALID_FNAME),
                            NULL, MB_OK | MB_ICONHAND);
                        return (TRUE);
                    }

                    EndDialog(hDlg, (INT_PTR)fh);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    return (FALSE);
            }
            break;
    }
    return FALSE;
}

BOOL CALLBACK FilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    int i;
    lParam;

    switch (message) {
    case WM_INITDIALOG:
            for (i = IDRB_WM_DDE_INITIATE; i <= IDRB_WM_DDE_EXECUTE; i++) {
                CheckDlgButton(hDlg, i, !fBlockMsg[i - IDRB_WM_DDE_INITIATE]);
            }
            for (i = IDRB_XTYP_ERROR; i <= IDRB_XTYP_WILDCONNECT; i++) {
                CheckDlgButton(hDlg, i, !fBlockCb[i - IDRB_XTYP_ERROR]);
            }
            CheckDlgButton(hDlg, IDRB_TERSE, pro.fTerse);
            return TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    for (i = IDRB_WM_DDE_INITIATE; i <= IDRB_WM_DDE_EXECUTE; i++) {
                        fBlockMsg[i - IDRB_WM_DDE_INITIATE] = !IsDlgButtonChecked(hDlg, i);
                    }
                    for (i = IDRB_XTYP_ERROR; i <= IDRB_XTYP_WILDCONNECT; i++) {
                        fBlockCb[i - IDRB_XTYP_ERROR] = !IsDlgButtonChecked(hDlg, i);
                    }
                    pro.fTerse = IsDlgButtonChecked(hDlg, IDRB_TERSE);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;
            }
            break;
    }
    return FALSE;
}




VOID GetProfile()
{
    pro.fOutput[IO_FILE]    = GetProfileBoolean(RefString(IDS_PROF_OUT_FILE),FALSE);
    pro.fOutput[IO_DEBUG]   = GetProfileBoolean(RefString(IDS_PROF_OUT_DEBUG),FALSE);
    pro.fOutput[IO_SCREEN]  = GetProfileBoolean(RefString(IDS_PROF_OUT_SCREEN),FALSE);

    pro.fFilter[IF_HSZ]     = GetProfileBoolean(RefString(IDS_PROF_MONITOR_STRINGHANDLES),FALSE);
    pro.fFilter[IF_SEND]    = GetProfileBoolean(RefString(IDS_PROF_MONITOR_INITIATES), FALSE);
    pro.fFilter[IF_POST]    = GetProfileBoolean(RefString(IDS_PROF_MONITOR_DDE_MESSAGES), FALSE);
    pro.fFilter[IF_CB]      = GetProfileBoolean(RefString(IDS_PROF_MONITOR_CALLBACKS), FALSE);
    pro.fFilter[IF_ERR]     = GetProfileBoolean(RefString(IDS_PROF_MONITOR_ERRORS),FALSE);

    pro.fTrack[IT_HSZS]     = GetProfileBoolean(RefString(IDS_PROF_TRACK_STRINGHANDLES), FALSE);
    pro.fTrack[IT_LINKS]    = GetProfileBoolean(RefString(IDS_PROF_TRACK_LINKS), FALSE);
    pro.fTrack[IT_CONVS]    = GetProfileBoolean(RefString(IDS_PROF_TRACK_CONVERSATIONS), FALSE);
    pro.fTrack[IT_SVRS]     = GetProfileBoolean(RefString(IDS_PROF_TRACK_SERVICES), FALSE);

    pro.fTerse              = GetProfileBoolean(RefString(IDS_PROF_TERSE), FALSE);
}



VOID SaveProfile()
{
    SetProfileBoolean(RefString(IDS_PROF_OUT_FILE), pro.fOutput[IO_FILE]  );
    SetProfileBoolean(RefString(IDS_PROF_OUT_DEBUG), pro.fOutput[IO_DEBUG] );
    SetProfileBoolean(RefString(IDS_PROF_OUT_SCREEN), pro.fOutput[IO_SCREEN]);

    SetProfileBoolean(RefString(IDS_PROF_MONITOR_STRINGHANDLES), pro.fFilter[IF_HSZ]   );
    SetProfileBoolean(RefString(IDS_PROF_MONITOR_INITIATES), pro.fFilter[IF_SEND]  );
    SetProfileBoolean(RefString(IDS_PROF_MONITOR_DDE_MESSAGES), pro.fFilter[IF_POST]  );
    SetProfileBoolean(RefString(IDS_PROF_MONITOR_CALLBACKS), pro.fFilter[IF_CB]    );
    SetProfileBoolean(RefString(IDS_PROF_MONITOR_ERRORS), pro.fFilter[IF_ERR]   );

    SetProfileBoolean(RefString(IDS_PROF_TRACK_STRINGHANDLES), pro.fTrack[IT_HSZS]   );
    SetProfileBoolean(RefString(IDS_PROF_TRACK_LINKS), pro.fTrack[IT_LINKS]  );
    SetProfileBoolean(RefString(IDS_PROF_TRACK_CONVERSATIONS), pro.fTrack[IT_CONVS]  );
    SetProfileBoolean(RefString(IDS_PROF_TRACK_SERVICES), pro.fTrack[IT_SVRS]   );

    SetProfileBoolean(RefString(IDS_PROF_TERSE), pro.fTerse   );
}




BOOL GetProfileBoolean(LPTSTR pszKey, BOOL fDefault)
{
    GetPrivateProfileString(RefString(IDS_TITLE), pszKey,
                    fDefault ? RefString(IDS_YES) : RefString(IDS_NO), TBuf,
                    sizeof(TBuf), RefString(IDS_INIFNAME));
    return(lstrcmpi(RefString(IDS_NO), TBuf));
}



VOID SetProfileBoolean(LPTSTR pszKey, BOOL fSet)
{
    WritePrivateProfileString(RefString(IDS_TITLE), pszKey,
                    fSet ? RefString(IDS_YES) : RefString(IDS_NO),
                    RefString(IDS_INIFNAME));
}

/*
 * Generic dialog invocation routine.  Handles procInstance stuff and param
 * passing.
 */
INT_PTR FAR
DoDialog(
    LPTSTR lpTemplateName,
    DLGPROC lpDlgProc,
    UINT param,
    BOOL fRememberFocus,
    HWND hwndParent,
    HANDLE hInst
    )
{
    UINT wRet;
    HWND hwndFocus;

    if (fRememberFocus)
        hwndFocus = GetFocus();
    lpDlgProc = (DLGPROC)MakeProcInstance(lpDlgProc, hInst);
    wRet = (UINT)DialogBoxParam(hInst, (LPCTSTR)lpTemplateName, hwndParent, lpDlgProc, param);
    FreeProcInstance((FARPROC)lpDlgProc);
    if (fRememberFocus)
        SetFocus(hwndFocus);
    return wRet;
}


BOOL CALLBACK MarkDlgProc(
                        HWND hwnd,
                        UINT msg,
                        WPARAM wParam,
                        LPARAM lParam)
{
    TCHAR szT[MAX_MARK + 1];
    lParam;

    switch (msg){
    case WM_INITDIALOG:
        SetWindowText(hwnd, RefString(IDS_MARKDLGTITLE));
        SendDlgItemMessage(hwnd, IDEF_VALUE, EM_LIMITTEXT, MAX_MARK, 0);
        SetDlgItemText(hwnd, IDEF_VALUE, RefString(IDS_SEPERATOR));
        SetDlgItemText(hwnd, IDTX_VALUE, RefString(IDS_MARKTEXT));
        return(1);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
            GetDlgItemText(hwnd, IDEF_VALUE, szT, MAX_MARK);
            OutputString(szT);
            // fall through
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        default:
            return(FALSE);
        }
        break;
    }
    return(FALSE);
}


#ifdef DBCS
/****************************************************************************
    My_mbschr:  strchr() DBCS version
****************************************************************************/
LPTSTR __cdecl My_mbschr(
   LPTSTR psz, TCHAR uiSep)
{
    while (*psz != '\0' && *psz != uiSep) {
        psz = CharNext(psz);
    }
    if (*psz == '\0' && uiSep != '\0') {
        return NULL;
    } else {
        return psz;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\dialog.h ===
/*
 * DIALOG.H
 *
 * Header file for Dialogs
 */


#define IDC_EDIT                400
#define IDEF_VALUE              500
#define IDTX_VALUE              501
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\globals.h ===
/*
 * GLOBALS.H
 *
 * Header file for DDESPY Global prototypes and Variables
 */

extern HINSTANCE hInst;
extern HICON hIcon;
extern HWND hWndString;
extern INT fhOutput;
extern OFSTRUCT ofsOpen;
extern CHAR OpenName[MAX_FNAME + 1];
extern CHAR TBuf[BUFFER_SIZE];
extern CHAR TBuf2[BUFFER_SIZE];
extern CHAR szNULL[];
extern PSTR apszResources[IDS_LAST];
extern PFNCALLBACK pfnDdeCallback;
extern HWND hwndTrack[IT_COUNT];
extern LPTSTR TrackTitle[IT_COUNT];
extern LPTSTR TrackHeading[IT_COUNT];

extern struct {                            /* profile data structure */
    BOOL fOutput[IO_COUNT];
    BOOL fFilter[IF_COUNT];
    BOOL fTrack[IT_COUNT];
} pro;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\ddespy.h ===
/*
 * DDESPY.H
 *
 * Header file for DDESPY Symbols
 */
#define DDEMLDB

#include <ddeml.h>
#include "dialog.h"

#define MH_INTCREATE                5
#define MH_INTKEEP                  6
#define MH_INTDELETE                7

#define IDI_DDESPY                  100
#define IDD_MSGFILTERS              300
#define IDRB_WM_DDE_INITIATE        305
#define IDRB_WM_DDE_TERMINATE       306
#define IDRB_WM_DDE_ADVISE          307
#define IDRB_WM_DDE_UNADVISE        308
#define IDRB_WM_DDE_ACK             309
#define IDRB_WM_DDE_DATA            310
#define IDRB_WM_DDE_REQUEST         311
#define IDRB_WM_DDE_POKE            312
#define IDRB_WM_DDE_EXECUTE         313
#define IDRB_XTYP_ERROR             314
#define IDRB_XTYP_ADVDATA           315
#define IDRB_XTYP_ADVREQ            316
#define IDRB_XTYP_ADVSTART          317
#define IDRB_XTYP_ADVSTOP           318
#define IDRB_XTYP_EXECUTE           319
#define IDRB_XTYP_CONNECT           320
#define IDRB_XTYP_CONNECT_CONFIRM   321
#define IDRB_XACT_COMPLETE          322
#define IDRB_XTYP_POKE              323
#define IDRB_XTYP_REGISTER          324
#define IDRB_XTYP_REQUEST           325
#define IDRB_XTYP_DISCONNECT        326
#define IDRB_XTYP_UNREGISTER        327
#define IDRB_XTYP_WILDCONNECT       328
#define IDRB_TERSE                  329

#define IDR_ACCEL                   30
#define IDR_MENU                    31
#define IDD_VALUEENTRY              50
#define IDD_ABOUTBOX                51
#define IDD_OPEN                    52
#define IDM_OUTPUT_FIRST            100
#define IDM_OUTPUT_FILE             100
#define IDM_OUTPUT_DEBUG            101
#define IDM_OUTPUT_SCREEN           102
#define IDM_CLEARSCREEN             103
#define IDM_MARK                    104
#define IDM_FILTER_FIRST            200
#define IDM_FILTER_HSZINFO          200
#define IDM_FILTER_INIT_TERM        201
#define IDM_FILTER_DDEMSGS          202
#define IDM_FILTER_CALLBACKS        203
#define IDM_FILTER_ERRORS           204
#define IDM_FILTER_DIALOG           205
#define IDM_TRACK_FIRST             301
#define IDM_TRACK_HSZS              301
#define IDM_TRACK_CONVS             302
#define IDM_TRACK_LINKS             303
#define IDM_TRACK_SVRS              304
#define IDM_TRACK_LAST              304
#define IDM_ABOUT                   401
#define IDM_TEST                    402

#define IDM_MSGF_0                  500
#define IDM_MSGF_1                  501
#define IDM_MSGF_2                  502
#define IDM_MSGF_3                  503
#define IDM_MSGF_4                  504
#define IDM_MSGF_5                  505
#define IDM_MSGF_6                  506
#define IDM_MSGF_7                  507
#define IDM_MSGF_8                  508

#define IDM_CBF_0                   600
#define IDM_CBF_1                   601
#define IDM_CBF_2                   602
#define IDM_CBF_3                   603
#define IDM_CBF_4                   604
#define IDM_CBF_5                   605
#define IDM_CBF_6                   606
#define IDM_CBF_7                   607
#define IDM_CBF_8                   608
#define IDM_CBF_9                   609
#define IDM_CBF_10                  610
#define IDM_CBF_11                  611
#define IDM_CBF_12                  612
#define IDM_CBF_13                  613
#define IDM_CBF_14                  614

#define IDS_TITLE                   0
#define IDS_DEFAULT_OUTPUT_FNAME    1
#define IDS_INIFNAME                2
#define IDS_CLASS                   3
#define IDS_HUH                     4
#define IDS_ZERO                    5
#define IDS_CRLF                    6
#define IDS_TRACKTITLE_1            7
#define IDS_TRACKTITLE_2            8
#define IDS_TRACKTITLE_3            9
#define IDS_TRACKTITLE_4            10
#define IDS_TRACKHEADING_1          11
#define IDS_TRACKHEADING_2          12
#define IDS_TRACKHEADING_3          13
#define IDS_TRACKHEADING_4          14
#define IDS_QCLOSEFILE_TEXT         15
#define IDS_QCLOSEFILE_CAPTION      16
#define IDS_ACTION_CLEANEDUP        17
#define IDS_ACTION_DESTROYED        18
#define IDS_ACTION_INCREMENTED      19
#define IDS_ACTION_CREATED          20
#define IDS_SENT                    21
#define IDS_POSTED                  22
#define IDS_INPUT_DATA              23
#define IDS_TABDDD                  24
#define IDS_OUTPUT_DATA             25
#define IDS_WARM                    26
#define IDS_HOT                     27
#define IDS_UNKNOWN_CALLBACK        28
#define IDS_APPIS                   29
#define IDS_TOPICIS                 30
#define IDS_ITEMIS                  31
#define IDS_OR                      32
#define IDS_FACKREQ                 33
#define IDS_DEFERUPD                34
#define IDS_FACK                    35
#define IDS_FBUSY                   36
#define IDS_FRELEASE                37
#define IDS_FREQUESTED              38
#define IDS_ERRST0                  39
#define IDS_ERRST1                  40
#define IDS_ERRST2                  41
#define IDS_ERRST3                  42
#define IDS_ERRST4                  43
#define IDS_ERRST5                  44
#define IDS_ERRST6                  45
#define IDS_ERRST7                  46
#define IDS_ERRST8                  47
#define IDS_ERRST9                  48
#define IDS_ERRST10                 49
#define IDS_ERRST11                 50
#define IDS_ERRST12                 51
#define IDS_ERRST13                 52
#define IDS_ERRST14                 53
#define IDS_ERRST15                 54
#define IDS_ERRST16                 55
#define IDS_ERRST17                 56
#define IDS_MSG0                    57
#define IDS_MSG1                    58
#define IDS_MSG2                    59
#define IDS_MSG3                    60
#define IDS_MSG4                    61
#define IDS_MSG5                    62
#define IDS_MSG6                    63
#define IDS_MSG7                    64
#define IDS_MSG8                    65
#define IDS_TYPE0                   66
#define IDS_TYPE1                   67
#define IDS_TYPE2                   68
#define IDS_TYPE3                   69
#define IDS_TYPE4                   70
#define IDS_TYPE5                   71
#define IDS_TYPE6                   72
#define IDS_TYPE7                   73
#define IDS_TYPE8                   74
#define IDS_TYPE9                   75
#define IDS_TYPE10                  76
#define IDS_TYPE11                  77
#define IDS_TYPE12                  78
#define IDS_TYPE13                  79
#define IDS_TYPE14                  80
#define IDS_TYPE15                  81
#define IDS_INVALID_FNAME           82
#define IDS_PROF_OUT_FILE           83
#define IDS_PROF_OUT_DEBUG          84
#define IDS_PROF_OUT_SCREEN         85
#define IDS_PROF_MONITOR_STRINGHANDLES   86
#define IDS_PROF_MONITOR_INITIATES       87
#define IDS_PROF_MONITOR_DDE_MESSAGES    88
#define IDS_PROF_MONITOR_CALLBACKS       89
#define IDS_PROF_MONITOR_ERRORS          90
#define IDS_PROF_TRACK_STRINGHANDLES     91
#define IDS_PROF_TRACK_LINKS             92
#define IDS_PROF_TRACK_CONVERSATIONS     93
#define IDS_PROF_TRACK_SERVICES          94
#define IDS_PROF_TERSE              95
#define IDS_YES                     96
#define IDS_NO                      97
#define IDS_MARKDLGTITLE            98
#define IDS_SEPERATOR               99
#define IDS_MARKTEXT                100
#define IDS_LISTCLASS               101
#define IDS_LBOX                    102
#define IDS_WILD                    103
#define IDS_STRINGCLASS             104
#define IDS_FMT_CB1                 105
#define IDS_FMT_CB2                 106
#define IDS_FMT_CTXT1               107
#define IDS_FMT_DATAIS1             108
#define IDS_FMT_ER1                 109
#define IDS_FMT_EXEC1               110
#define IDS_FMT_MSG1                111
#define IDS_FMT_MSG2                112
#define IDS_FMT_STATUSIS            113
#define IDS_FMT_TRS_CB1             114
#define IDS_FMT_TRS_CB2             115
#define IDS_FMT_TRS_CTXT1           116
#define IDS_FMT_TRS_DATAIS1         117
#define IDS_FMT_TRS_ER1             118
#define IDS_FMT_TRS_EXEC1           119
#define IDS_FMT_TRS_MSG1            120
#define IDS_FMT_TRS_MSG2            121
#define IDS_FMT_TRS_STATUSIS        122
#define IDS_FMT_SH_MSG1             123
#define IDS_BADATOM                 124
#define IDS_LAST                    124

#define T_ATOM                      0x0001
#define T_OPTIONHANDLE              0x0002
#define T_FORMAT                    0x0004
#define T_STATUS                    0x0008
#define T_DATAHANDLE                0x0010
#define T_STRINGHANDLE              0x0020
#define T_VALUE                     0x0040
#define T_APP                       0x0080
#define T_TOPIC                     0x0100
#define T_ITEM                      0x0200
#define T_OR                        0x0400


#define IO_FILE                     0
#define IO_DEBUG                    1
#define IO_SCREEN                   2
#define IO_COUNT                    3

#define IF_HSZ                      0
#define IF_SEND                     1
#define IF_POST                     2
#define IF_CB                       3
#define IF_ERR                      4

#define IF_COUNT                    5

#define IT_HSZS                     0
#define IT_CONVS                    1
#define IT_LINKS                    2
#define IT_SVRS                     3

#define IT_COUNT                    4

#define MAX_FNAME                   MAX_PATH
#define BUFFER_SIZE                 400
#define MAX_MARK                    32
#define MAX_DISPDATA                48      // max bytes of non-text data to dump

#define CLINES                      1000
#define CCHARS                      200

extern HINSTANCE hInst;

/* macro definitions */
#define MyAlloc(cb)         (LPTSTR)LocalAlloc(LPTR, (cb))
#define MyFree(p)           (LocalUnlock((HANDLE)(p)), LocalFree((HANDLE)(p)))
#define RefString(id)       (LPTSTR)apszResources[id]
#define Type2String(type)   apszResources[IDS_TYPE0 + ((type & XTYP_MASK) >> XTYP_SHIFT)]
#define MPRT(b)             (isprint(b) ? (b) : '.')

/* prototype definitions */
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, INT);
VOID CloseApp(VOID);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK About(HWND, UINT, WPARAM, LPARAM);
BOOL SetFilters(VOID);
BOOL CALLBACK OpenDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK FilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
LPTSTR DisectMsgLP(UINT msg, MONMSGSTRUCT *pmms, LPTSTR pszBuf);
LPTSTR DisectWord(UINT type, UINT data, DDEML_MSG_HOOK_DATA *pdmhd, LPTSTR pstr);
LPTSTR pdf(UINT fmt);
LPTSTR DumpFormat(UINT fmt, LPTSTR pstr);
LPTSTR DdeMsg2String(UINT msg);
LPTSTR Error2String(UINT error);
LPTSTR DumpData(LPBYTE pData, UINT cb, TCHAR *szBuf, UINT fmt);
LPTSTR GetHszName(HSZ hsz);
VOID OutputString(LPTSTR pstr);
VOID GetProfile(VOID);
VOID SaveProfile(VOID);
BOOL GetProfileBoolean(LPTSTR pszKey, BOOL fDefault);
VOID SetProfileBoolean(LPTSTR pszKey, BOOL fSet);
HDDEDATA CALLBACK DdeCallback(UINT wType, UINT wFmt, HCONV hConv, HSZ hsz1,
      HSZ hsz2, HDDEDATA hData, UINT lData1, UINT lData2);
INT_PTR FAR DoDialog(LPTSTR lpTemplateName, DLGPROC lpDlgProc, UINT param,
      BOOL fRememberFocus, HWND hwndParent, HANDLE hInst);
BOOL  CALLBACK MarkDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/* testsubs.c prototypes */

/* StringWindow structure */
typedef struct {
    INT cchLine;
    INT cLine;
    INT offBuffer;
    INT offBufferMax;
    INT offBottomLine;
    INT offOutput;
    INT cBottomLine;
    INT cLeftChar;
} STRWND;


BOOL InitTestSubs(VOID);
VOID CloseTestSubs(HANDLE hInst);
VOID NextLine(STRWND *psw);
VOID DrawString(HWND hwnd, TCHAR *sz);
VOID ClearScreen(STRWND *psw);
LRESULT CALLBACK StrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID scroll(HWND hwnd, UINT msg, UINT sliderpos, UINT style);
BOOL StrWndCreate(HWND hwnd, INT cchLine, INT cLine);
VOID PaintStrWnd(HWND hwnd, LPPAINTSTRUCT pps);

#ifdef DBCS
#define strchr      My_mbschr
#ifdef stricmp
#undef stricmp
#endif
#define stricmp     lstrcmpi
LPTSTR __cdecl My_mbschr(LPTSTR, TCHAR);
#endif  // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\lists.h ===
/*
 * LISTS.H
 *
 * Header file for multi-column listbox module.
 */

typedef struct {
    LPTSTR   lpszHeadings;
} MCLBCREATESTRUCT;


typedef struct {
    HWND    hwndLB;
    LPTSTR    pszHeadings;
    INT     cCols;
    INT     SortCol;
} MCLBSTRUCT;

#define MYLBSTYLE   WS_CHILD|WS_BORDER |LBS_SORT| \
                    WS_VSCROLL|LBS_OWNERDRAWFIXED|LBS_NOINTEGRALHEIGHT

HWND CreateMCLBFrame(
                    HWND hwndParent,
                    LPTSTR lpszTitle,       /* frame title string */
                    UINT dwStyle,          /* frame styles */
                    HICON hIcon,           /* icon */
                    HBRUSH hbrBkgnd,       /* background for heading.*/
                    LPTSTR lpszHeadings);   /* tab delimited list of headings.  */
                                           /* The number of headings indicate  */
                                           /* the number of collumns. */

VOID AddMCLBText(LPTSTR pszSearch, LPTSTR pszReplace, HWND hwndLBFrame);
INT GetMCLBColValue(LPTSTR pszSearch, HWND hwndLBFrame, int  cCol);
BOOL DeleteMCLBText(LPTSTR pszSearch, HWND hwndLBFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\cleaninf\parse.cpp ===
#include "priv.h"       



#define IS_WHITESPACE(ch)   (' ' == ch || '\t' == ch)
#define IS_NEWLINE(ch)      ('\n' == ch)


// Flags for _ReadChar
#define RCF_NEXTLINE        0x0001      // skip to next line
#define RCF_NEXTNWS         0x0002      // skip to next non-whitespace
#define RCF_SKIPTRAILING    0x0004      // skip trailing whitespace


// constructor
CParseFile::CParseFile()
{
}



/*-------------------------------------------------------------------------
Purpose: Parse the given file according to the provided flags.
*/
void CParseFile::Parse(FILE * pfileSrc, FILE * pfileDest, DWORD dwFlags)
{
    _bSkipWhitespace = BOOLIFY(dwFlags & PFF_WHITESPACE);
    
    _pfileSrc = pfileSrc;
    _pfileDest = pfileDest;
    _ichRead = 0;
    _cchRead = 0;
    
    _ichWrite = 0;
    
    _ch = 0;

    if (dwFlags & PFF_HTML)
        _ParseHtml();
    else if (dwFlags & PFF_HTC)
        _ParseHtc();
    else if (dwFlags & PFF_JS)
        _ParseJS();
    else
        _ParseInf();

    _FlushWriteBuffer();
}


/*-------------------------------------------------------------------------
Purpose: Read the next character in the file.  Sets _ch.

*/
char CParseFile::_ReadChar(DWORD dwFlags)
{
    BOOL bFirstCharSav = _bFirstChar;
    
    do 
    {
        _ichRead++;
        _bFirstChar = FALSE;

        // Are we past the buffer, or do we skip to next line?
        if (_ichRead >= _cchRead || dwFlags & RCF_NEXTLINE)
        {
            // Yes; read in more
            if (fgets(_szReadBuf, SIZECHARS(_szReadBuf), _pfileSrc))
            {
                _ichRead = 0;
                _cchRead = strlen(_szReadBuf);
                _bFirstChar = TRUE;
            }
            else
            {
                _ichRead = 0;
                _cchRead = 0;
            }
        }

        if (_ichRead < _cchRead)
            _ch = _szReadBuf[_ichRead];
        else
            _ch = CHAR_EOF;
    } while ((dwFlags & RCF_NEXTNWS) && IS_WHITESPACE(_ch));

    // Are we supposed to skip to the next non-whitespace?
    if (dwFlags & RCF_NEXTNWS)
    {
        // Yes; then retain the "first character" state
        _bFirstChar = bFirstCharSav;
    }
        
    return _ch;
}


/*-------------------------------------------------------------------------
Purpose: Read ahead to the next character in the buffer and return its
         value, but don't set _ch or increment the read pointer.
*/
char CParseFile::_SniffChar(int ichAhead)
{
    if (_ichRead + ichAhead < _cchRead)
        return _szReadBuf[_ichRead + ichAhead];
        
    return 0;
}



/*-------------------------------------------------------------------------
Purpose: Write the character to the file
*/
void CParseFile::_WriteChar(char ch)
{
    _szWriteBuf[_ichWrite++] = ch;
    _szWriteBuf[_ichWrite] = 0;

    if ('\n' == ch || SIZECHARS(_szWriteBuf)-1 == _ichWrite)
    {
        fputs(_szWriteBuf, _pfileDest);
        _ichWrite = 0;
    }
}


/*-------------------------------------------------------------------------
Purpose: Flushes the write buffer to the file
*/
void CParseFile::_FlushWriteBuffer(void)
{
    if (_ichWrite > 0)
    {
        fputs(_szWriteBuf, _pfileDest);
        _ichWrite = 0;
    }
}



/*-------------------------------------------------------------------------
Purpose: Parse a .inf file.
*/
void CParseFile::_ParseInf(void)
{
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        if (_bFirstChar)
        {
            // Is this a comment?
            if (';' == _ch)
            {
                // Yes; skip to next line
                _ReadChar(RCF_NEXTLINE);
                continue;
            }

            if (_SkipWhitespace())
                continue;
        }
        
        _WriteChar(_ch);
        _ReadChar(0);
    }
}    


/*-------------------------------------------------------------------------
Purpose: Write the current character and the rest of the tag.  Assumes
         _ch is the beginning of the tag ('<').

         There are some parts of the tag which may be compacted if _bSkipWhitespace
         is TRUE.  The general rule is only one space is required between attributes,
         and newlines are converted to spaces if necessary.  Anything in quotes 
         (single or double) are left alone.
*/
void CParseFile::_WriteTag(void)
{
    BOOL bSingleQuotes = FALSE;
    BOOL bDblQuotes = FALSE;
    
    // The end of the tag is the next '>' that is not in single or double-quotes.

    while (CHAR_EOF != _ch)
    {
        if ('\'' == _ch)
            bSingleQuotes ^= TRUE;
        else if ('"' == _ch)
            bDblQuotes ^= TRUE;

        if (!bSingleQuotes && !bDblQuotes)
        {
            // _SkipWhitespace returns TRUE if it skips any whitespace,
            // which means we've read some more input, which means we should
            // go to the top of the loop and check for EOF and quotes.
            if (_bSkipWhitespace && _SkipWhitespace(TRUE))
                continue;

            // End of tag?
            if ('>' == _ch)
            {
                // Yes
                _WriteChar(_ch);
                break;
            }
        }
        
        _WriteChar(_ch);
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Skip the current comment tag.  Assumes _ch is the beginning of
         the tag ('<').
*/
void CParseFile::_SkipCommentTag(void)
{
    // The end of the tag is the next '-->'

    while (CHAR_EOF != _ch)
    {
        // Is the end of the comment coming up?
        if ('-' == _ch && _SniffChar(1) == '-' && _SniffChar(2) == '>')
        {
            // Yes
            _ReadChar(0);   // skip '-'
            _ReadChar(0);   // skip '>'
            break;
        }
        
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Skip leading whitespace.

         Returns TRUE if anything was skipped
*/
BOOL CParseFile::_SkipWhitespace(BOOL bPreserveOneSpace)
{
    BOOL bRet = FALSE;
    
    if (_bSkipWhitespace)
    {
        if (IS_WHITESPACE(_ch))
        {
            // Skip leading whitespace in line
            _ReadChar(RCF_NEXTNWS);
            bRet = TRUE;
        }
        else if (IS_NEWLINE(_ch))
        {
            // Move to the next line
            _ReadChar(RCF_NEXTLINE);

            // Skip leading whitespace on the next line, but don't write
            // another space char (we'll do that here if necessary) and
            // ignore the return value since we've already skipped some
            // whitespace here (return TRUE).
            _SkipWhitespace(FALSE);

            bRet = TRUE;
        }
        // Write a single space char if we skipped something and the caller
        // asked us to preserve a space.
        if (bRet && bPreserveOneSpace)
            _WriteChar(' ');
    }
    return bRet;
}


/*-------------------------------------------------------------------------
Purpose: Skip a C or C++ style comment

         Returns TRUE if a comment boundary was encountered.
*/
BOOL CParseFile::_SkipComment(int * pcNestedComment)
{
    BOOL bRet = FALSE;
    
    if ('/' == _ch)
    {
        // Is this a C++ comment?
        if ('/' == _SniffChar(1))
        {
            // Yes; skip it to end of line
            if (!_bFirstChar || !_bSkipWhitespace)
                _WriteChar('\n');
                
            _ReadChar(RCF_NEXTLINE);
            bRet = TRUE;
        }
        // Is this a C comment?
        else if ('*' == _SniffChar(1))
        {
            // Yes; skip to respective '*/'
            _ReadChar(0);       // skip '/'
            _ReadChar(0);       // skip '*'
            (*pcNestedComment)++;
            bRet = TRUE;
        }
    }
    else if ('*' == _ch)
    {
        // Is this the end of a C comment?
        if ('/' == _SniffChar(1))
        {
            // Yes
            _ReadChar(0);       // skip '*'
            _ReadChar(0);       // skip '/'
            (*pcNestedComment)--;
            
            // Prevent writing an unnecessary '\n'
            _bFirstChar = TRUE;
            bRet = TRUE;
        }
    }
    return bRet;
}


/*-------------------------------------------------------------------------
Purpose: Parse the innertext of the STYLE tag, remove any comments
*/
void CParseFile::_ParseInnerStyle(void)
{
    int cNestedComment = 0;
    
    // The end of the tag is the next '</STYLE>'

    _ReadChar(0);

    while (CHAR_EOF != _ch)
    {
        if (_bFirstChar && _SkipWhitespace())
            continue;

        // Is the end of the styletag section coming up?
        if ('<' == _ch && _IsTagEqual("/STYLE"))
        {
            // Yes
            break;
        }

        if (_SkipComment(&cNestedComment))
            continue;

        if (0 == cNestedComment && !IS_NEWLINE(_ch))
            _WriteChar(_ch);
            
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if the given tagname matches the currently parsed token
*/
BOOL CParseFile::_IsTagEqual(LPSTR pszTag)
{
    int ich = 1;

    while (*pszTag)
    {
        if (_SniffChar(ich++) != *pszTag++)
            return FALSE;
    }

    // We should verify we've come to the end of the tagName
    char chEnd = _SniffChar(ich);
    
    return (' ' == chEnd || '>' == chEnd || '<' == chEnd);
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if the current tag is an end tag
*/
BOOL CParseFile::_IsEndTag(void)
{
    return (_SniffChar(1) == '/');
}


/*-------------------------------------------------------------------------
Purpose: Parse a .htm or .hta file.
*/
void CParseFile::_ParseHtml(void)
{
    BOOL bFollowingTag = FALSE;
    BOOL bFollowingEndTag = FALSE;
    
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        // Anytime we read another char, we should go to the top of the loop
        // to check for EOF and skip leading whitespace if it's a new line.
        //
        // Note that _SkipWhitespace returns TRUE if it has skipped something,
        // which also involves reading a new char.

        if (_bFirstChar && _SkipWhitespace())
            continue;

        // Is this a tag?
        if ('<' == _ch)
        {
            // Yes; looks like it

            // Since we've found a new tag, no need to remember if we just saw
            // an end tag. That only matters for text content following an end
            // tag. For example, given "<SPAN>foo</SPAN>  bar", we need to
            // preserve a space before the word "bar".
            bFollowingEndTag = FALSE;

            if (_IsTagEqual("!--"))
            {
                // Comment; skip it
                _SkipCommentTag();
            }
            else if (_IsTagEqual("SCRIPT"))
            {
                // Parse the script 
                _WriteTag();        // write the <SCRIPT> tag
                
                // FEATURE (scotth): we always assume javascript, maybe we should support something else
                _ParseJS();

                _WriteTag();        // write the </SCRIPT> tag
            }
            else if (_IsTagEqual("STYLE"))
            {
                _WriteTag();        // write the <STYLE> tag
                _ParseInnerStyle();
                _WriteTag();        // write the </STYLE> tag
            }
            else
            {
                // Check for end tag ("</") before calling _WriteTag
                bFollowingEndTag = _IsEndTag();

                // Any other tag: write the tag and go to the next one
                _WriteTag();
            }

            bFollowingTag = TRUE;
            _ReadChar(0);
            continue;
        }

        if (bFollowingTag && _bSkipWhitespace)
        {
            // We can't entirely skip whitespace following tags such as </SPAN>
            // or </A>, but we can at least collapse it down to a single space.
            BOOL bPreserveOneSpace = bFollowingEndTag;

            bFollowingEndTag = FALSE;
            bFollowingTag = FALSE;

            if (_SkipWhitespace(bPreserveOneSpace))
                continue;
        }
        
        _WriteChar(_ch);
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Parse a .js file.
*/
void CParseFile::_ParseJS(void)
{
    BOOL bDblQuotes = FALSE;
    BOOL bSingleQuotes = FALSE;
    int cNestedComment = 0;
    
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        // Are we in a comment?
        if (0 == cNestedComment)
        {
            // No; (we only pay attention to strings when they're not in comments)
            if ('\'' == _ch)
                bSingleQuotes ^= TRUE;
            else if ('"' == _ch)
                bDblQuotes ^= TRUE;

            if (_bSkipWhitespace && !bDblQuotes && !bSingleQuotes)
            {
                if (IS_WHITESPACE(_ch))
                {
                    // Skip whitespace
                    if (!_bFirstChar)
                        _WriteChar(' ');
                        
                    _ReadChar(RCF_NEXTNWS);
                    continue;
                }
                else if (IS_NEWLINE(_ch))
                {
                    // Since javascript doesn't require a ';' at the end of a statement,
                    // we should at least replace the newline with a space so tokens don't
                    // get appended accidentally.

                    // The javascript engine has a line-length limit.  So don't replace
                    // a newline with a space.
                    if (!_bFirstChar)
                        _WriteChar('\n');
                        
                    _ReadChar(RCF_NEXTLINE);
                    continue;
                }
            }

            // Are we in a string?
            if (!bDblQuotes && !bSingleQuotes)
            {
                // No; look for the terminating SCRIPT tag
                if ('<' == _ch)
                {
                    if (_IsTagEqual("/SCRIPT"))
                    {
                        // We've reached the end of the script block
                        break;
                    }
                }
            }
        }

        // Are we in a string?
        if (!bDblQuotes && !bSingleQuotes)
        {
            // No; look for comments...
            if (_SkipComment(&cNestedComment))
                continue;
        }
        
        if (0 == cNestedComment)
            _WriteChar(_ch);
            
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Parse a .htc file.
*/
void CParseFile::_ParseHtc(void)
{
    BOOL bFollowingTag = FALSE;
    int cNestedComment = 0;
    
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        if (_bFirstChar && _SkipWhitespace())
            continue;

        // Is this a tag?
        if ('<' == _ch)
        {
            // Yes; is it a script tag?
            if (_IsTagEqual("SCRIPT"))
            {
                // Yes; parse the script 
                _WriteTag();        // write the <SCRIPT> tag
                
                // FEATURE (scotth): we always assume javascript
                _ParseJS();

                _WriteTag();        // write the </SCRIPT> tag

                _ReadChar(0);
                bFollowingTag = TRUE;
                continue;
            }
            else
            {
                _WriteTag();
                _ReadChar(0);
                bFollowingTag = TRUE;
                continue;

            }
        }

        // Look for comments outside the SCRIPT block...
        if (_SkipComment(&cNestedComment))
            continue;
            
        if (bFollowingTag && _bSkipWhitespace)
        {
            bFollowingTag = FALSE;

            if (_SkipWhitespace())
                continue;
        }
        
        if (0 == cNestedComment)
             _WriteChar(_ch);
             
        _ReadChar(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\testsubs.c ===
/*
 * TESTSUBS.C
 *
 *   String formatting class, window procedure and helper functions
 */

#define UNICODE
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <string.h>
#include "ddespy.h"
#include "globals.h"

#define OFF2P(psw, off)  ((TCHAR *)psw + off)
#define BOUND(n, min, max) ((n) < (min) ? (min) : ((n) > (max) ? (max) : n))

INT cyChar;                     /* Height of a line */
INT cxChar;
INT cyDescent;


/***************************** Public  Function ****************************\
* BOOL InitTestSubs( )
*
* This routine MUST be called before using anything in this file.  Registers
* window classes, loads brushes, etc.  Returns TRUE if successful, FALSE
* otherwise.
*
\***************************************************************************/

BOOL InitTestSubs()
{
    WNDCLASS cls;

    cls.style =         0;
    cls.lpfnWndProc =   (WNDPROC)StrWndProc;
    cls.cbClsExtra =    0;
    cls.cbWndExtra =    sizeof(HANDLE);
    cls.hInstance =     hInst;
    cls.hIcon =         NULL;
    cls.hCursor =       LoadCursor(NULL, IDC_ARROW);
    cls.hbrBackground = (HBRUSH)COLOR_WINDOW;
    cls.lpszMenuName =  NULL;
    cls.lpszClassName = (LPCTSTR) RefString(IDS_STRINGCLASS);

    if (!RegisterClass((WNDCLASS FAR * ) & cls))
        return(FALSE);

    return(TRUE);
}


VOID CloseTestSubs(
HANDLE hInst)
{
    UnregisterClass((LPCTSTR) RefString(IDS_STRINGCLASS), hInst);
}



VOID NextLine( STRWND *psw)
{
    psw->offBottomLine += psw->cchLine;
    if (psw->offBottomLine == psw->offBufferMax)
        psw->offBottomLine = psw->offBuffer;
    psw->offOutput = psw->offBottomLine;
    *OFF2P(psw, psw->offOutput) = TEXT('\0');
}


/***************************** Public  Function ****************************\
* VOID DrawString(hwnd, sz)
*
* This routine prints a string in the specified StringWindow class window.
* sz is a NEAR pointer to a zero-terminated string, which can be produced
* with wsprintf().
\***************************************************************************/

VOID DrawString( HWND hwnd, TCHAR *sz)
{
    register STRWND *psw;
    INT cLines = 1;
    HANDLE hpsw;

    hpsw = (HANDLE)GetWindowLongPtr(hwnd, 0);
    psw = (STRWND *)LocalLock(hpsw);

    NextLine(psw);
    while (*sz) {
        switch (*sz) {
        case TEXT('\r'):
            break;

        case TEXT('\n'):
            *OFF2P(psw, psw->offOutput++) = TEXT('\0');
            NextLine(psw);
            cLines++;
            break;

        default:
            *OFF2P(psw, psw->offOutput++) = *sz;
        }
        sz++;
    }
    *OFF2P(psw, psw->offOutput++) = TEXT('\0');
    LocalUnlock(hpsw);

    ScrollWindow(hwnd, 0, -((cyChar + cyDescent) * cLines), (LPRECT)NULL,
            (LPRECT)NULL);
    UpdateWindow(hwnd);
}

/***************************** Public  Function ****************************\
* "StringWindow" window class
*
* Windows of the "StringWindow" window class are simple scrolling text output
* windows that are refreshed properly as windows are rearranged.  A text buffer
* is maintained to store the characters as they are drawn.
*
* When creating a StringWindow window, lpCreateParams is actually a UINT
* containing the dimensions of the text buffer to be created, if 0L, then
* a 80 by 25 buffer is created.
*
\***************************************************************************/

LRESULT CALLBACK StrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HANDLE hpsw;
    PAINTSTRUCT ps;
    RECT rc;

    switch (msg) {
    case WM_CREATE:
        cyChar = 14;
        cxChar = 8;
        cyDescent = 2;
        if (*(PUINT)lParam     == 0L) {
            *(PUINT)lParam     = MAKELONG(80, 50);
        }
        if (!StrWndCreate(hwnd, LOWORD(*(PUINT)lParam), HIWORD(*(PUINT)lParam)))
            return(TRUE);
        break;

    case WM_SIZE:
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_DESTROY:
        if ((hpsw = (HANDLE)GetWindowLongPtr(hwnd, 0)) != NULL)
            LocalFree(hpsw);
        break;

    case WM_ERASEBKGND:
        GetClientRect(hwnd, (LPRECT) &rc);
        FillRect((HDC) wParam, (LPRECT) &rc, GetStockObject(WHITE_BRUSH));
        break;

    case WM_VSCROLL:
        scroll(hwnd, GET_WM_VSCROLL_CODE(wParam, lParam),
                GET_WM_VSCROLL_POS(wParam, lParam), SB_VERT);
        break;

    case WM_HSCROLL:
        scroll(hwnd, GET_WM_HSCROLL_CODE(wParam, lParam),
                GET_WM_HSCROLL_POS(wParam, lParam), SB_HORZ);
        break;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        PaintStrWnd(hwnd, &ps);
        EndPaint(hwnd, &ps);
        break;

    default:
        return(DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }
    return(0L);
}



VOID scroll(HWND hwnd, UINT msg, UINT sliderpos, UINT style)
{
    RECT rc;
    INT iPos;
    INT dn;
    HANDLE hpsw;
    register STRWND *psw;

    GetClientRect(hwnd, (LPRECT) &rc);
    iPos = GetScrollPos(hwnd, style);
    hpsw = (HANDLE)GetWindowLongPtr(hwnd, 0);
    psw = (STRWND *)LocalLock(hpsw);

    switch (msg) {
    case SB_LINEDOWN:
        dn =  1;
        break;

    case SB_LINEUP:
        dn = -1;
        break;

    case SB_PAGEDOWN:
        if (style == SB_VERT) {
            dn = rc.bottom / (cyChar + cyDescent);
        } else {
            dn = rc.right / cxChar;
        }
        break;

    case SB_PAGEUP:
        if (style == SB_VERT) {
            dn = -rc.bottom / (cyChar + cyDescent);
        } else {
            dn = -rc.right / cxChar;
        }
        break;

    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        dn = sliderpos-iPos;
        break;

    default:
        dn = 0;
    }
    if (style == SB_VERT) {
        if (dn = BOUND (iPos + dn, 0, psw->cLine) - iPos) {
            psw->cBottomLine -= dn;
            ScrollWindow (hwnd, 0, -dn * (cyChar + cyDescent), NULL, NULL);
            SetScrollPos (hwnd, SB_VERT, iPos + dn, TRUE);
        }
    } else /* style == SB_HORZ */ {
        if (dn = BOUND (iPos + dn, 0, psw->cchLine) - iPos) {
            psw->cLeftChar += dn;
            ScrollWindow (hwnd, -dn * cxChar, 0, NULL, NULL);
            SetScrollPos (hwnd, SB_HORZ, iPos + dn, TRUE);
        }
    }
    LocalUnlock(hpsw);
}



BOOL StrWndCreate(HWND hwnd, INT cchLine, INT cLine)
{
    register INT off;
    STRWND *psw;
    HANDLE hpsw;

    if ((hpsw = LocalAlloc(LMEM_MOVEABLE, sizeof(STRWND)
	   + (sizeof (TCHAR) * cchLine * cLine))) == NULL)
        return(FALSE);
    SetWindowLongPtr(hwnd, 0, (UINT_PTR)hpsw);


    psw = (STRWND *)LocalLock(hpsw);
    psw->cchLine       = cchLine;
    psw->cLine         = cLine;
    off                = sizeof(STRWND);
    psw->offBuffer     = off;
    psw->offBufferMax  = off + cchLine * cLine;
    psw->offBottomLine = off;
    psw->offOutput     = off;
    psw->cBottomLine   = 0;
    psw->cLeftChar     = 0;

    ClearScreen(psw);

    SetScrollRange(hwnd, SB_VERT, 0, cLine, FALSE);
    SetScrollPos(hwnd, SB_VERT, cLine, TRUE);
    SetScrollRange(hwnd, SB_HORZ, 0, cchLine, TRUE);
    LocalUnlock(hpsw);
    return(TRUE);
}


VOID ClearScreen(register STRWND *psw)
{
    register INT off;
    /*
     * Make all the lines empty
     */
    off = psw->offBuffer;
    while (off < psw->offBufferMax) {
        *OFF2P(psw, off) = TEXT('\0');
        off += psw->cchLine;
    }
}




VOID PaintStrWnd( HWND hwnd, LPPAINTSTRUCT pps)
{
    register STRWND *psw;
    register INT off;
    INT x;
    INT y;
    RECT rc, rcOut;
    HANDLE hpsw;


    SelectObject(pps->hdc, GetStockObject(SYSTEM_FIXED_FONT));
    hpsw = (HANDLE)GetWindowLongPtr(hwnd, 0);
    psw = (STRWND *)LocalLock(hpsw);

    GetClientRect(hwnd, (LPRECT)&rc);
    if (!pps->fErase)
        FillRect(pps->hdc, (LPRECT)&rc, GetStockObject(WHITE_BRUSH));

    x = rc.left - cxChar * psw->cLeftChar;
    y = rc.bottom - cyDescent + (cyChar + cyDescent) * psw->cBottomLine;
    off = psw->offBottomLine;

    if (&pps->rcPaint != NULL)
        IntersectRect((LPRECT)&rc, (LPRECT)&rc, &pps->rcPaint);

    do {
        if (y <= rc.top - cyDescent)
            break;
        if (y - cyChar <= rc.bottom) {
            rcOut.left = x;
            rcOut.bottom = y + cyDescent;
            rcOut.right = 1000;
            rcOut.top = y - cyChar;
            DrawText(pps->hdc, (LPTSTR)OFF2P(psw, off), -1, (LPRECT)&rcOut,
                    DT_LEFT | DT_VCENTER | DT_NOCLIP | DT_EXPANDTABS |
                    DT_EXTERNALLEADING | DT_NOPREFIX | DT_TABSTOP | 0x0400);
        }
        y -= cyChar + cyDescent;
        /*
         * Back up to previous line
         */
        if (off == psw->offBuffer)
            off = psw->offBufferMax;
        off -= psw->cchLine;
    } while (off != psw->offBottomLine);
    LocalUnlock(hpsw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfcm.cpp ===
#include "dfcm.h"

#include <stdio.h>
#include <winuser.h>
#include <tchar.h>

#include "cfgmgr32.h"

#include "drvfull.h"

#include "dfhlprs.h"

#include "setupapi.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// 100 interface max
static GUID rgguidInterface[100];
static DWORD cguidInterface = 0;

static GUID g_guidVolume =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

static GUID g_guidUSB =
    {0x36fc9e60, 0xc465, 0x11cf,
    {0x80, 0x56, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

static GUID g_guidDiskDrive =
    {0x4d36e967, 0xe325, 0x11ce,
    {0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18}};

static GUID g_guidDiskDriveIntf =
    {0x53f56307L, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

struct DevInterface
{
    LPTSTR pszName;
    GUID guid;
};

// see HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceClasses for more

static DevInterface rgDevInterface[] =
{
    TEXT("DiskClassGuid"), {             0x53f56307L, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("CdRomClassGuid"), {             0x53f56308L, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("PartitionClassGuid"), {         0x53f5630aL, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("TapeClassGuid"), {              0x53f5630bL, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("WriteOnceDiskClassGuid"), {     0x53f5630cL, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("VolumeClassGuid"), {            0x53f5630dL, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("MediumChangerClassGuid"), {     0x53f56310L, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("FloppyClassGuid"), {            0x53f56311L, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("CdChangerClassGuid"), {         0x53f56312L, 0xb6bf, 0x11d0, { 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("StoragePortClassGuid"), {       0x2accfe60L, 0xc130, 0x11d2, { 0xb0, 0x82, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b }},
    TEXT("GUID_CLASS_COMPORT"), {         0x86e0d1e0L, 0x8089, 0x11d0, { 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73 }},
    TEXT("GUID_SERENUM_BUS_ENUMERATOR"), {0x4D36E978L, 0xE325, 0x11CE, { 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18 }},
};

static DWORD g_dwLevel = 0;

BOOL _HexStringToDword(LPCWSTR* ppsz, DWORD* lpValue, int cDigits,
    WCHAR chDelim)
{
    LPCWSTR psz = *ppsz;
    DWORD Value = 0;
    BOOL fRet = TRUE;

    for (int ich = 0; ich < cDigits; ich++)
    {
        WCHAR ch = psz[ich];
        if ((ch >= TEXT('0')) && (ch <= TEXT('9')))
        {
            Value = (Value << 4) + ch - TEXT('0');
        }
        else
        {
            if (((ch |= (TEXT('a')-TEXT('A'))) >= TEXT('a')) &&
                ((ch |= (TEXT('a')-TEXT('A'))) <= TEXT('f')))
            {
                Value = (Value << 4) + ch - TEXT('a') + 10;
            }
            else
            {
                return(FALSE);
            }
        }
    }

    if (chDelim)
    {
        fRet = (psz[ich++] == chDelim);
    }

    *lpValue = Value;
    *ppsz = psz+ich;

    return fRet;
}

BOOL StringToGUID(LPCWSTR psz, GUID *pguid)
{
    DWORD dw;
    if (*psz++ != TEXT('{') /*}*/ )
        return FALSE;

    if (!_HexStringToDword(&psz, &pguid->Data1, sizeof(DWORD)*2, TEXT('-')))
        return FALSE;

    if (!_HexStringToDword(&psz, &dw, sizeof(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, TEXT('-')))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, /*(*/ TEXT('}')))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

_sFLAG_DESCR _DevCapFD[] =
{
    FLAG_DESCR(CM_DEVCAP_LOCKSUPPORTED),
    FLAG_DESCR(CM_DEVCAP_EJECTSUPPORTED),
    FLAG_DESCR(CM_DEVCAP_REMOVABLE),
    FLAG_DESCR(CM_DEVCAP_DOCKDEVICE),
    FLAG_DESCR(CM_DEVCAP_UNIQUEID),
    FLAG_DESCR(CM_DEVCAP_SILENTINSTALL),
    FLAG_DESCR(CM_DEVCAP_RAWDEVICEOK),
    FLAG_DESCR(CM_DEVCAP_SURPRISEREMOVALOK),
    FLAG_DESCR(CM_DEVCAP_HARDWAREDISABLED),
    FLAG_DESCR(CM_DEVCAP_NONDYNAMIC),
};

int _PrintDeviceInfo(DEVINST devinst, HMACHINE hMachine, DWORD dwFlags[],
    DWORD cchIndent)
{
    // MAX_DEVICE_ID_LEN -> CM_Get_Device_ID_Size_Ex
    TCHAR szDeviceID[MAX_DEVICE_ID_LEN];
    LPTSTR pszDevIntf;

    int i = 0;

    CONFIGRET cr = CM_Get_Device_ID_Ex(devinst, szDeviceID,
        ARRAYSIZE(szDeviceID), 0, NULL); // hMachine?

    if (CR_SUCCESS == cr)
    {
        TCHAR szText[1024];
        DWORD cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
        GUID guid;
        DWORD cbguid = sizeof(guid);

        i += _PrintIndent(cchIndent);
        i += _tprintf(TEXT("+ (%d) '%s'\n"), g_dwLevel, szDeviceID);

        cr = CM_Get_DevNode_Registry_Property_Ex(devinst, CM_DRP_FRIENDLYNAME,
            NULL, szText, &cbText, 0, hMachine);

        if (CR_SUCCESS == cr)
        {
            i += _PrintIndent(cchIndent + 5);
            i += _tprintf(TEXT("('%s')\n"), szText);
        }

        cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
        cr = CM_Get_DevNode_Registry_Property_Ex(devinst, CM_DRP_DEVICEDESC,
            NULL, szText, &cbText, 0, hMachine);

        if (CR_SUCCESS == cr)
        {
            i += _PrintIndent(cchIndent + 5);
            i += _tprintf(TEXT("<'%s'>\n"), szText);
        }

        if (_IsFlagSet(MOD_FULLREPORT3, dwFlags))
        {
//
            //regkeys
            {
/*
                     CM_REGISTRY_HARDWARE (0x00000000)
                        Open a key for storing driver-independent information
                        relating to the device instance.  On Windows NT, the
                        full path to such a storage key is of the form:

                        HKLM\System\CurrentControlSet\Enum\<enumerator>\
                            <DeviceID>\<InstanceID>\Device Parameters

                     CM_REGISTRY_SOFTWARE (0x00000001)
                        Open a key for storing driver-specific information
                        relating to the device instance.  On Windows NT, the
                        full path to such a storage key is of the form:

                        HKLM\System\CurrentControlSet\Control\Class\
                            <DevNodeClass>\<ClassInstanceOrdinal>

                     CM_REGISTRY_USER (0x00000100)
                        Open a key under HKEY_CURRENT_USER instead of
                        HKEY_LOCAL_MACHINE.  This flag may not be used with
                        CM_REGISTRY_CONFIG.  There is no analagous kernel-mode
                        API on NT to get a per-user device configuration
                        storage, since this concept does not apply to device
                        drivers (no user may be logged on, etc).  However,
                        this flag is provided for consistency with Win95, and
                        because it is foreseeable that it could be useful to
                        Win32 services that interact with Plug-and-Play model.

                     CM_REGISTRY_CONFIG (0x00000200)
                        Open the key under a hardware profile branch instead
                        of HKEY_LOCAL_MACHINE.  If this flag is specified,
                        then ulHardwareProfile supplies the handle of the
                        hardware profile to be used.  This flag may not be
                        used with CM_REGISTRY_USER.
*/              
                {
                    HKEY hkeyDevInst;
                    cr = CM_Open_DevNode_Key(devinst, MAXIMUM_ALLOWED,
                        0, RegDisposition_OpenExisting,
                        &hkeyDevInst, CM_REGISTRY_SOFTWARE);

                    if (CR_SUCCESS == cr)
                    {
                        DWORD dwEnum = 0;
                        WCHAR szKeyName[256];
                        DWORD cchKeyName = ARRAYSIZE(szKeyName);

                        while (ERROR_SUCCESS == RegEnumKeyEx(
                            hkeyDevInst, dwEnum, szKeyName,
                            &cchKeyName, NULL, NULL,
                            NULL, NULL))
                        {
                            cchKeyName = ARRAYSIZE(szKeyName);

                            ++dwEnum;

                            _tprintf(TEXT("Dev Inst Key[%02d]: %s\n"),
                                dwEnum, szKeyName);
                        }
     
                        if (!dwEnum)
                        {
                            _tprintf(TEXT("Dev Inst: no subkey\n"));
                        }

                        RegCloseKey(hkeyDevInst);
                    }
                    else
                    {
                        _tprintf(TEXT("Failed to open Dev Inst key\n"));
                    }
                }
                {

                }
            }
//
            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst, CM_DRP_HARDWAREID,
                NULL, szText, &cbText, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                for (LPTSTR psz = szText; *psz; psz += lstrlen(psz) + 1)
                {
                    i += _PrintIndent(cchIndent + 5);
                    i += _tprintf(TEXT("~'%s'~\n"), psz);
                }
            }

            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst, CM_DRP_COMPATIBLEIDS,
                NULL, szText, &cbText, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                for (LPTSTR psz = szText; *psz; psz += lstrlen(psz) + 1)
                {
                    i += _PrintIndent(cchIndent + 5);
                    i += _tprintf(TEXT("::'%s'::\n"), psz);
                }
            }

            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                CM_DRP_LOCATION_INFORMATION,
                NULL, szText, &cbText, 0, hMachine);            

            if (CR_SUCCESS == cr)
            {
                i += _PrintIndent(cchIndent + 5);
                i += _tprintf(TEXT(">'%s'<\n"), szText);
            }

            DWORD dwAddress;
            DWORD cbAddress = sizeof(dwAddress);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                CM_DRP_ADDRESS,
                NULL, &dwAddress, &cbAddress, 0, hMachine);            

            if (CR_SUCCESS == cr)
            {
                i += _PrintIndent(cchIndent + 5);
                i += _tprintf(TEXT("^'%d'^\n"), dwAddress);
            }

            DWORD dwCap;
            DWORD cbCap = sizeof(dwCap);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                CM_DRP_CAPABILITIES,
                NULL, &dwCap, &cbCap, 0, hMachine);            

            if (CR_SUCCESS == cr)
            {
                i += _PrintFlag(dwCap, _DevCapFD, ARRAYSIZE(_DevCapFD),
                    cchIndent + 7, TRUE, TRUE, FALSE, TRUE);
                i+= _PrintCR();
            }

            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                CM_DRP_DRIVER, NULL, szText, &cbText, 0, hMachine);            

            if (CR_SUCCESS == cr)
            {
                i += _PrintIndent(cchIndent + 5);
                i += _tprintf(TEXT(">>'%s'<<\n"), szText);
            }

            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                CM_DRP_ENUMERATOR_NAME, NULL, szText, &cbText, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                i += _PrintIndent(cchIndent + 5);
                i += _tprintf(TEXT("!'%s'!\n"), szText);
            }

            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
            cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                CM_DRP_UI_NUMBER,
                NULL, szText, &cbText, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
/*                cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
                cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
                    CM_DRP_UI_NUMBER_DESC_FORMAT,
                    NULL, szText, &cbText, 0, hMachine);            

                if (CR_SUCCESS == cr)
                {
                    i += _PrintIndent(cchIndent + 5);
                    i += _tprintf(TEXT("$'%s'$\n"), szText);
                }*/

                if ((TEXT('P') == szDeviceID[0]) && (TEXT('C') == szDeviceID[1]) &&
                    (TEXT('I') == szDeviceID[2]) && (TEXT('\\') == szDeviceID[3]))
                {
                    i += _PrintIndent(cchIndent + 5);
                    i += _tprintf(TEXT("#PCI Slot: %d#\n"), (DWORD)*((DWORD*)szText));
                }
            }

            for (DWORD dwIntf = 0; dwIntf < ARRAYSIZE(rgDevInterface); ++dwIntf)
            {
                ULONG ulSize;

                cr = CM_Get_Device_Interface_List_Size(&ulSize,
                    &(rgDevInterface[dwIntf].guid), szDeviceID, 0);

                if ((CR_SUCCESS == cr) && (ulSize > 1))
                {
                    pszDevIntf = (LPTSTR)LocalAlloc(LPTR, 
                        ulSize * sizeof(TCHAR));

                    if (pszDevIntf)
                    {
                        // *sizeof(TCHAR) ?
                        cr = CM_Get_Device_Interface_List(&(rgDevInterface[dwIntf].guid),
                            szDeviceID, pszDevIntf, ulSize, 0); //CM_GET_DEVICE_INTERFACE_LIST_PRESENT

                        if (CR_SUCCESS == cr)
                        {
                            for (LPTSTR psz = pszDevIntf; *psz;
                                psz += lstrlen(psz) + 1)
                            {
                                i += _PrintIndent(cchIndent + 5);
                                i += _tprintf(TEXT("<>'%s'<> (%s)\n"), psz,
                                    rgDevInterface[dwIntf].pszName);
                            }
                        }

                        LocalFree(pszDevIntf);
                    }
                }
            }
        }

        cbText = ARRAYSIZE(szText) * sizeof(TCHAR);
        cr = CM_Get_DevNode_Registry_Property_Ex(devinst, CM_DRP_CLASSGUID,
            NULL, szText, &cbText, 0, hMachine);

        if (CR_SUCCESS == cr)
        {
            StringToGUID(szText, &guid);

            cbText = ARRAYSIZE(szText) * sizeof(TCHAR);

            cr = CM_Get_Class_Name_Ex(&guid, szText, &cbText, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                i += _PrintIndent(cchIndent + 5);
                i += _tprintf(TEXT("{'%s'}\n"), szText);
            }
        }

        {
            ULONG ulSize;

            cr = CM_Get_Device_Interface_List_Size(&ulSize, &g_guidVolume,
                   szDeviceID, 0);

            if ((CR_SUCCESS == cr) && (ulSize > 1))
            {
                pszDevIntf = (LPTSTR)LocalAlloc(LPTR,
                    ulSize * sizeof(TCHAR));

                if (pszDevIntf)
                {
                    // *sizeof(TCHAR) ?
                    cr = CM_Get_Device_Interface_List(&g_guidVolume,
                        szDeviceID, pszDevIntf, ulSize, 0); //CM_GET_DEVICE_INTERFACE_LIST_PRESENT

                    if (CR_SUCCESS == cr)
                    {
                        for (LPTSTR psz = pszDevIntf; *psz; psz += lstrlen(psz) + 1)
                        {
                            i += _PrintIndent(cchIndent + 5);
                            i += _tprintf(TEXT("['%s']\n"), psz);
                        }
                    }
                }
            }
        }
        {
            ULONG ulSize;

            cr = CM_Get_Device_Interface_List_Size(&ulSize, &g_guidDiskDriveIntf,
                   szDeviceID, 0);

            if ((CR_SUCCESS == cr) && (ulSize > 1))
            {
                pszDevIntf = (LPTSTR)LocalAlloc(LPTR,
                    ulSize * sizeof(TCHAR));

                if (pszDevIntf)
                {
                    // *sizeof(TCHAR) ?
                    cr = CM_Get_Device_Interface_List(&g_guidDiskDriveIntf,
                        szDeviceID, pszDevIntf, ulSize, 0); //CM_GET_DEVICE_INTERFACE_LIST_PRESENT

                    if (CR_SUCCESS == cr)
                    {
                        for (LPTSTR psz = pszDevIntf; *psz; psz += lstrlen(psz) + 1)
                        {
                            i += _PrintIndent(cchIndent + 5);
                            i += _tprintf(TEXT("[['%s']]\n"), psz);
                        }
                    }
                }
            }
        }
    }

    return i;
}

HRESULT _EnumChildRecurs(DEVINST devinst, HMACHINE hMachine, DWORD dwFlags[],
    DWORD cchIndent)
{
    HRESULT hres;
    DEVINST devinstChild;
    
    CONFIGRET cr = CM_Get_Child_Ex(&devinstChild, devinst, 0, hMachine);

    g_dwLevel += 1;

    if (CR_SUCCESS == cr)
    {
        do
        {
            DEVINST devinstChildNext;

            _PrintDeviceInfo(devinstChild, hMachine, dwFlags, cchIndent);

            hres = _EnumChildRecurs(devinstChild, hMachine, dwFlags,
                cchIndent + 4);

            // check return value

            cr = CM_Get_Sibling_Ex(&devinstChildNext, devinstChild, 0, 
                hMachine);

            if (CR_SUCCESS == cr)
            {
                devinstChild = devinstChildNext;
            }
        }
        while (CR_SUCCESS == cr);
    }

    g_dwLevel -= 1;

    return S_OK;
}

HRESULT _GetDeviceInstance(LPWSTR pszDeviceID, DEVINST* pdevinst)
{
    HRESULT hres = E_FAIL;
    HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pdevinst = NULL;

    if (INVALID_HANDLE_VALUE != hdevinfo)
    {
        SP_DEVICE_INTERFACE_DATA sdid = {0};

        sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceID, 0, &sdid))
        {
            DWORD cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

            SP_DEVINFO_DATA sdd = {0};
            SP_DEVICE_INTERFACE_DETAIL_DATA* psdidd =
                (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbsdidd);

            if (psdidd)
            {
                psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                // Stupidity Alert!
                //
                // SetupDiGetDeviceInterfaceDetail (below) requires that the
                // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                // to the size of the fixed part of the structure, and to pass
                // the size of the full thing as the 4th param.

                if (SetupDiGetDeviceInterfaceDetail(hdevinfo, &sdid, psdidd,
                    cbsdidd, NULL, &sdd))
                {
                    *pdevinst = sdd.DevInst;

                    hres = S_OK;
                }

                LocalFree((HLOCAL)psdidd);
            }
        }

        SetupDiDestroyDeviceInfoList(hdevinfo);
    }

    return hres;
}

HRESULT _DeviceInfo(DWORD dwFlags[], LPWSTR pszDeviceID, DWORD cchIndent)
{
    DEVINST devinst;
    HRESULT hres = _GetDeviceInstance(pszDeviceID, &devinst);

    if (SUCCEEDED(hres))
    {
        _PrintDeviceInfo(devinst, NULL, dwFlags, cchIndent);
    }

    return hres;
}

HRESULT _DeviceInterface(DWORD dwFlags[], LPWSTR pszDeviceID, DWORD cchIndent)
{
    int i = 0;

    {
        for (DWORD dwIntf = 0; dwIntf < ARRAYSIZE(rgDevInterface); ++dwIntf)
        {
            ULONG ulSize;

            CONFIGRET cr = CM_Get_Device_Interface_List_Size(&ulSize,
                &(rgDevInterface[dwIntf].guid), pszDeviceID, 0);

            if ((CR_SUCCESS == cr) && (ulSize > 1))
            {
                LPTSTR pszDevIntf = (LPTSTR)LocalAlloc(LPTR, 
                    ulSize * sizeof(TCHAR));

                if (pszDevIntf)
                {
                    // *sizeof(TCHAR) ?
                    cr = CM_Get_Device_Interface_List(&(rgDevInterface[dwIntf].guid),
                        pszDeviceID, pszDevIntf, ulSize, 0); //CM_GET_DEVICE_INTERFACE_LIST_PRESENT

                    if (CR_SUCCESS == cr)
                    {
                        for (LPTSTR psz = pszDevIntf; *psz;
                            psz += lstrlen(psz) + 1)
                        {
                            i += _PrintIndent(cchIndent + 5);
                            i += _tprintf(TEXT("<>'%s'<> (%s)\n"), psz,
                                rgDevInterface[dwIntf].pszName);
                        }
                    }

                    LocalFree(pszDevIntf);
                }
            }
        }
    }

    {
        ULONG ul = 0;
        cguidInterface = 0;
        CONFIGRET cr;

        do
        {
            GUID guid;
            HMACHINE hMachine = NULL;

            cr = CM_Enumerate_Classes_Ex(ul, &guid, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                TCHAR szText[1024];
                DWORD cchText = ARRAYSIZE(szText);

                                
                if (ul < ARRAYSIZE(rgguidInterface))
                {
                    rgguidInterface[ul] = guid;
                    ++cguidInterface;
                }

/*                cr = CM_Get_Class_Name(&guid, szText, &cchText, 0);

                if (CR_SUCCESS == cr)
                {
                    _tprintf(TEXT("'%s' ("), szText);
                    _PrintGUID(&guid);
                    _tprintf(TEXT(")\n"));
                }*/
            }

            ++ul;
        }
        while (CR_SUCCESS == cr);

        for (DWORD dwIntf = 0; dwIntf < cguidInterface; ++dwIntf)
        {
            ULONG ulSize;

            CONFIGRET cr = CM_Get_Device_Interface_List_Size(&ulSize,
                &(rgguidInterface[dwIntf]), pszDeviceID, 0);

            if ((CR_SUCCESS == cr) && (ulSize > 1))
            {
                LPTSTR pszDevIntf = (LPTSTR)LocalAlloc(LPTR, 
                    ulSize * sizeof(TCHAR));

                if (pszDevIntf)
                {
                    // *sizeof(TCHAR) ?
                    cr = CM_Get_Device_Interface_List(&(rgguidInterface[dwIntf]),
                        pszDeviceID, pszDevIntf, ulSize, 0); //CM_GET_DEVICE_INTERFACE_LIST_PRESENT

                    if (CR_SUCCESS == cr)
                    {
                        for (LPTSTR psz = pszDevIntf; *psz;
                            psz += lstrlen(psz) + 1)
                        {
                            i += _PrintIndent(cchIndent + 5);
                            i += _PrintGUID(&(rgguidInterface[dwIntf]));
                            i += _tprintf(TEXT(")\n"));
                        }
                    }

                    LocalFree(pszDevIntf);
                }
            }
        }
    }

    return S_OK;
}

HRESULT _DeviceIDList(DWORD dwFlags[], LPWSTR pszDeviceID, DWORD cchIndent)
{    
    ULONG ulSize;
    HMACHINE hMachine = NULL;
    int i = 0;

    ULONG uFlags = CM_GETIDLIST_FILTER_NONE;

    CONFIGRET cr = CM_Get_Device_ID_List_Size_Ex(&ulSize,
        NULL, uFlags, hMachine);

    if ((CR_SUCCESS == cr) && (ulSize > 1))
    {
        LPTSTR pszDevIDList = (LPTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));

        if (pszDevIDList)
        {
            // *sizeof(TCHAR) ?
            cr = CM_Get_Device_ID_List_Ex(NULL, pszDevIDList, ulSize,
                uFlags, hMachine);

            if (CR_SUCCESS == cr)
            {
                for (LPTSTR psz = pszDevIDList; *psz;
                    psz += lstrlen(psz) + 1)
                {
                    i += _PrintIndent(cchIndent + 5);
                    i += _tprintf(TEXT("'%s'\n"), psz);
                }
            }

            LocalFree(pszDevIDList);
        }
    }

    return S_OK;
}

HRESULT _EnumDevice(DWORD dwFlags[], LPWSTR pszArg, DWORD cchIndent)
{
    ULONG ulSize;
    LPTSTR pszDevIntf;
    ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;
    HMACHINE hMachine = NULL;

    GUID guid;

    if (StringToGUID(pszArg, &guid))
    {
        CONFIGRET cr = CM_Get_Device_Interface_List_Size(&ulSize, &guid,
               NULL, ulFlags);

        if ((CR_SUCCESS == cr) && (ulSize > 1))
        {
            pszDevIntf = (LPTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));

            if (pszDevIntf)
            {
                // *sizeof(TCHAR) ?
                cr = CM_Get_Device_Interface_List_Ex(&guid, NULL, pszDevIntf, ulSize,
                    ulFlags, hMachine);

                if (CR_SUCCESS == cr)
                {
                    for (LPTSTR psz = pszDevIntf; *psz; psz += lstrlen(psz) + 1)
                    {
                        _tprintf(TEXT("['%s']\n"), psz);

                        DEVINST devinst;

                        // for now
                        cr = CM_Locate_DevNode_Ex(&devinst, psz, 0, hMachine);

                        if (CR_SUCCESS == cr)
                        {
                            ULONG ulStatus;
                            ULONG ulProblem;

                            cr = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                devinst, 0, hMachine);
            
                            if (CR_SUCCESS == cr)
                            {
                                _tprintf(TEXT("    Status: 0x%08X]\n    Problem #: 0x%08X"),
                                    ulStatus, ulProblem);
                            }
                        }
                    }

                    _tprintf(TEXT("\n"));
                }
            }
        }
    }

    return S_OK;
}

HRESULT _FullTree(DWORD dwFlags[], DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    DEVINST devinstRoot;
    HMACHINE hMachine = NULL;
    CONFIGRET  cr;

    _tprintf(TEXT("==================================================\n"));

    {
        ULONG ul = 0;
        cguidInterface = 0;

        do
        {
            GUID guid;
            cr = CM_Enumerate_Classes_Ex(ul, &guid, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                TCHAR szText[1024];
                DWORD cchText = ARRAYSIZE(szText);

                                
                if (_IsFlagSet(MOD_FULLREPORT3, dwFlags))
                {
                    if (ul < ARRAYSIZE(rgguidInterface))
                    {
                        rgguidInterface[ul] = guid;
                        ++cguidInterface;
                    }
                }

                cr = CM_Get_Class_Name(&guid, szText, &cchText, 0);

                if (CR_SUCCESS == cr)
                {
                    _tprintf(TEXT("'%s' ("), szText);
                    _PrintGUID(&guid);
                    _tprintf(TEXT(")\n"));
                }
            }

            ++ul;
        }
        while (CR_SUCCESS == cr);
    }

    // Get Root Device node
    cr = CM_Locate_DevNode_Ex(&devinstRoot, NULL,
        CM_LOCATE_DEVNODE_NORMAL, hMachine);

    if (CR_SUCCESS == cr)
    {
        _PrintDeviceInfo(devinstRoot, hMachine, dwFlags, cchIndent);

        hres = _EnumChildRecurs(devinstRoot, hMachine, dwFlags, cchIndent + 4);
    }

    _tprintf(TEXT("=  Volumes ===========================================\n"));

    {
        ULONG ulSize;
        LPTSTR pszDevIntf;
        ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;
//        ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES;

        cr = CM_Get_Device_Interface_List_Size(&ulSize, &g_guidVolume,
               NULL, ulFlags);

        if ((CR_SUCCESS == cr) && (ulSize > 1))
        {
            pszDevIntf = (LPTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));

            if (pszDevIntf)
            {
                // *sizeof(TCHAR) ?
                cr = CM_Get_Device_Interface_List_Ex(&g_guidVolume, NULL, pszDevIntf, ulSize,
                    ulFlags, hMachine);

                if (CR_SUCCESS == cr)
                {
                    for (LPTSTR psz = pszDevIntf; *psz; psz += lstrlen(psz) + 1)
                    {
                        _tprintf(TEXT("['%s']\n"), psz);

                        DEVINST devinst;

                        // for now
                        cr = CM_Locate_DevNode_Ex(&devinst, psz, 0, hMachine);

                        if (CR_SUCCESS == cr)
                        {
                            ULONG ulStatus;
                            ULONG ulProblem;

                            cr = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                devinst, 0, hMachine);
                    
                            if (CR_SUCCESS == cr)
                            {
                                _tprintf(TEXT("    Status: 0x%08X]\n    Problem #: 0x%08X"),
                                    ulStatus, ulProblem);
                            }
                        }
                    }


                    _tprintf(TEXT("\n"));
                }
            }
        }
        else
        {
            _tprintf(TEXT("\n"));
        }
    }

    _tprintf(TEXT("= Drives ===========================================\n"));
    {
        ULONG ulSize;
        LPTSTR pszDevIntf;
        ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;
//        ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES;

        cr = CM_Get_Device_Interface_List_Size(&ulSize, &g_guidDiskDriveIntf,
               NULL, ulFlags);

        if ((CR_SUCCESS == cr) && (ulSize > 1))
        {
            pszDevIntf = (LPTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));

            if (pszDevIntf)
            {
                // *sizeof(TCHAR) ?
                cr = CM_Get_Device_Interface_List_Ex(&g_guidDiskDriveIntf, NULL, pszDevIntf, ulSize,
                    ulFlags, hMachine);

                if (CR_SUCCESS == cr)
                {
                    for (LPTSTR psz = pszDevIntf; *psz; psz += lstrlen(psz) + 1)
                    {
                        _tprintf(TEXT("['%s']\n"), psz);
                    }

                    _tprintf(TEXT("\n"));
                }
            }
        }
        else
        {
            _tprintf(TEXT("\n"));
        }
    }

    _tprintf(TEXT("==================================================\n"));

    {
        ULONG ul = 0;

        do
        {
            TCHAR szEnum[4096];
            ULONG ulEnum = sizeof(szEnum);

            cr = CM_Enumerate_Enumerators_Ex(ul, szEnum, &ulEnum, 0, hMachine);

            if (CR_SUCCESS == cr)
            {
                _tprintf(TEXT("'%s'\n"), szEnum);
            }

            ++ul;
        }
        while (CR_SUCCESS == cr);
    }

    return hres;
}

/*CM_Connect_Machine

CM_Get_Device_ID_List_Size_Ex
CM_Get_Child_Ex
CM_Get_Sibling_Ex
CM_Get_Parent_Ex

CM_Get_DevNode_Registry_Property_Ex
CM_Get_Class_Name_Ex
CM_Get_DevNode_Status_Ex
CM_Get_Device_ID_Ex

CM_Request_Device_Eject_Ex
CM_Locate_DevNode_Ex*/

/*

InitDevTreeDlgProc

DEVINST* DeviceInstance
HMACHINE DeviceTree->hMachine
DEVINST DeviceTree->DevInst
GUID DeviceTreeNode->ClassGuid
TCHAR   DeviceID[MAX_DEVICE_ID_LEN]
PTSTR DeviceInterface 

        //
        // Get the root devnode.
        //
        ConfigRet = CM_Locate_DevNode_Ex(&DeviceTree->DevInst,
                                         NULL,
                                         CM_LOCATE_DEVNODE_NORMAL,
                                         DeviceTree->hMachine (NULL)
                                         );
        if (ConfigRet != CR_SUCCESS) {

    ConfigRet = CM_Get_Child_Ex(&DeviceInstance, (Out param)
                                DeviceTree->DevInst, (prev call)
                                0,
                                DeviceTree->hMachine (NULL)
                                );
    if (ConfigRet == CR_SUCCESS) {

        // for info
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance, (from above)
                                                        CM_DRP_CLASSGUID,
                                                        NULL,
                                                        &Buffer,
                                                        &Len,
                                                        0,
                                                        DeviceTree->hMachine (NULL)
                                                        );


        if (ConfigRet == CR_SUCCESS) {
            Out:    // GUID_DEVCLASS_COMPUTER
                {0x4d36e966L, 0xe325, 0x11ce,
                {0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18}},


        if (ConfigRet == CR_SUCCESS) {
            ConfigRet = CM_Get_Class_Name_Ex(&DeviceTreeNode->ClassGuid,
                                         Buffer,
                                         &Len,
                                         0,
                                         DeviceTree->hMachine
                                         );
            Out: Computer

        if (ConfigRet == CR_SUCCESS) {

            // trying to find drive letter
x            DevNodeToDriveLetter(x
x
x            if (CM_Get_Device_ID_Ex(DevInst,
x                                    DeviceID,
x                                    sizeof(DeviceID)/sizeof(TCHAR),
x                                    0,
x                                    NULL
x                                    ) == CR_SUCCESS) {
x                Out: 0x0006ee8c "ROOT\ACPI_HAL\0000"
x
x
x            if (CM_Get_Device_Interface_List_Size(&ulSize,
x                                           (LPGUID)&VolumeClassGuid,
x                                           DeviceID,
x                                           0)  == CR_SUCCESS) &&
x
x                Out: FAILS
x                             (ulSize > 1) &&
x                ((DeviceInterface = LocalAlloc(LPTR, ulSize*sizeof(TCHAR))) != NULL) &&
x                    (CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid,
x                                      DeviceID,
x                                      DeviceInterface,
x                                      ulSize,
x                                      0
x                                      )  == CR_SUCCESS) &&


        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_FRIENDLYNAME,
                                                        NULL,
                                                        Buffer,
                                                        &Len,
                                                        0,
                                                        DeviceTree->hMachine
                                                        );

            then, CM_DRP_DEVICEDESC... out: "Advanced Configuration and Power Interface (ACPI) PC"

            ....

            BuildLocationInformation: Boring....

            // Get InstanceId
            ConfigRet = CM_Get_Device_ID_ExW(DeviceInstance, 
                                         Buffer,
                                         Len/sizeof(TCHAR),
                                         0,
                                         DeviceTree->hMachine
                                         );

            Out "ROOT\ACPI_HAL\0000"

            { // should skip
                BuildDeviceRelationsList

                    ConfigRet = CM_Get_Device_ID_List_Size_Ex(&Len,
                                                  DeviceId, ("ROOT\ACPI_HAL\0000")
                                                  FilterFlag, (CM_GETIDLIST_FILTER_EJECTRELATIONS)
                                                  hMachine (NULL)
                                                  );
                BuildDeviceRelationsList

                    ConfigRet = CM_Get_Device_ID_List_Size_Ex(&Len,
                                                  DeviceId, ("ROOT\ACPI_HAL\0000")
                                                  FilterFlag, (CM_GETIDLIST_FILTER_REMOVALRELATIONS)
                                                  hMachine
                                                  );

                // Both FAILED, if would have succeeded, would have trierd to enum drive letters
            }
            // If this devinst has children, then recurse to fill in its child sibling list.
    
            ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance, (out param)
                                        DeviceInstance, (same as above)
                                        0,
                                        DeviceTree->hMachine (NULL)
                                        );

            //recurse to redo the same as above for child, then ...

            // Next sibling ...
            ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance, (Ouch!)
                                          DeviceInstance,
                                          0,
                                          DeviceTree->hMachine
                                          );





///////////////////////////////////////////////////////////////////////////////
//
// Device Instance status flags, returned by call to CM_Get_DevInst_Status
//
#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be rebalanced
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed


// Flags for CM_Get_Device_ID_List, CM_Get_Device_ID_List_Size
//
#define CM_GETIDLIST_FILTER_NONE                (0x00000000)
#define CM_GETIDLIST_FILTER_ENUMERATOR          (0x00000001)
#define CM_GETIDLIST_FILTER_SERVICE             (0x00000002)
#define CM_GETIDLIST_FILTER_EJECTRELATIONS      (0x00000004)
#define CM_GETIDLIST_FILTER_REMOVALRELATIONS    (0x00000008)
#define CM_GETIDLIST_FILTER_POWERRELATIONS      (0x00000010)
#define CM_GETIDLIST_FILTER_BUSRELATIONS        (0x00000020)
#define CM_GETIDLIST_DONOTGENERATE              (0x10000040)
#define CM_GETIDLIST_FILTER_BITS                (0x1000007F)

//
// Flags for CM_Get_Device_Interface_List, CM_Get_Device_Interface_List_Size
//
#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT     (0x00000000)  // only currently 'live' device interfaces
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES (0x00000001)  // all registered device interfaces, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS        (0x00000001)
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drv\drv.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <windows.h>

#include <winnetp.h>

#define PRINTCASE(a) case (a): _tprintf(TEXT("%s"), TEXT(#a)); break;

#define FLAG_HELP           0x00000001
#define FLAG_DEBUG          0x00000002
#define FLAG_DRIVE          0x00000004
#define FLAG_FILE           0x00000008
#define FLAG_NETWORK        0x00000010
#define FLAG_LOGDRIVE       0x00000020
#define FLAG_MOUNTPOINT     0x00000040
#define FLAG_VOLUMEGUID     0x00000080

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

typedef struct _tagFLAGASSOC
{
    TCHAR szName;
    DWORD dwFlag;
} FLAGASSOC;

FLAGASSOC FlagList[] = 
{
    { TEXT('?'), FLAG_HELP       },
    { TEXT('b'), FLAG_DEBUG      },
    { TEXT('d'), FLAG_DRIVE      },
    { TEXT('f'), FLAG_FILE       },
    { TEXT('n'), FLAG_NETWORK    },
    { TEXT('l'), FLAG_LOGDRIVE   },
#if 0
    { TEXT('m'), FLAG_MOUNTPOINT },
    { TEXT('g'), FLAG_VOLUMEGUID },
#endif
};

#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
#else
int __cdecl main(int argc, char* argv[])
#endif
{
    TCHAR szName[MAX_PATH];
    DWORD dwFlags = 0;
    BOOL fGotFileName = FALSE;

    // process the args
    for (int i = 1; i < argc; ++i)
    {
        if ((TEXT('/') == argv[i][0]) || (TEXT('-') == argv[i][0]))
        {
            // This is a flag
            for (int j = 0; j < ARRAYSIZE(FlagList); ++j)
            {
                if ((FlagList[j].szName == argv[i][1]) || 
                    ((FlagList[j].szName + (TEXT('a') - TEXT('A'))) == argv[i][1]))
                {
                    dwFlags |= FlagList[j].dwFlag;
                    break;
                }
            }
        }
        else
        {
            // This is the filename
            lstrcpyn(szName, argv[i], ARRAYSIZE(szName));
            fGotFileName = TRUE;
        }
    }

    if (!fGotFileName)
    {
        if (!GetCurrentDirectory(ARRAYSIZE(szName), szName))
        {
            dwFlags = FLAG_HELP;
        }
    } 

    if (!dwFlags)
    {
        dwFlags = FLAG_FILE;
    }

    if (dwFlags & FLAG_HELP)
    {
        dwFlags = FLAG_HELP;
    }

    if (dwFlags & FLAG_DEBUG)
    {
        _tprintf(TEXT("DBG: %d\n"), argc);

        for (int i = 0; i < argc; ++i)
            _tprintf(TEXT("DBG: Arg #%d is \"%s\"\n"), i, argv[i]);

        _tprintf(TEXT("DBG: Flags\n"));
        for (DWORD j = 0; j < 32; ++j)
        {
            DWORD dw = 1 << j;

            if (dw & dwFlags)
            {
                _tprintf(TEXT("\n DBG: "));

                switch (dw)
                {
                    PRINTCASE(FLAG_HELP       );
                    PRINTCASE(FLAG_DEBUG      );
                    PRINTCASE(FLAG_DRIVE      );
                    PRINTCASE(FLAG_FILE       );
                    PRINTCASE(FLAG_NETWORK    );
                    PRINTCASE(FLAG_LOGDRIVE   );
                    PRINTCASE(FLAG_MOUNTPOINT );
                    PRINTCASE(FLAG_VOLUMEGUID );
                }
            }
        }
    }

    if (dwFlags & FLAG_HELP)
    {
        _tprintf(TEXT("\nDRV [/F] [/D] [/B] [/?] [path]"));
        _tprintf(TEXT("\n\n  [path]"));
        _tprintf(TEXT("\n              Specifies a drive, file, drive mounted on a folder, or Volume GUID."));
        _tprintf(TEXT("\n\n  /F          Retrieves file information (GetFileAttributes)."));
        _tprintf(TEXT("\n  /D          Retrieves drive information (GetDriveType + GetVolumeInformation)."));
        _tprintf(TEXT("\n  /N          Retrieves Network share information (WNetGetConnection)"));
        _tprintf(TEXT("\n  /L          Retrieves Logical drives info (GetLogicalDrives)"));
        _tprintf(TEXT("\n  /B          Dumps debug info."));
        _tprintf(TEXT("\n  /?          Displays this message."));
        _tprintf(TEXT("\n\nIf no switches are provided, '/F' is assumed.  For mounted volumes on\nfolder problems, try appending a backslash.\n\n(Source code: shell\\tools\\drv)"));
    }
    else
    {
        _tprintf(TEXT("\n---------------------------------------------------\n--- For: \"%s\""), szName);
    }

    if (dwFlags & FLAG_FILE)
    {
        // GetFileAttributes
        {
            _tprintf(TEXT("\n............................................................."));
            _tprintf(TEXT("\n... GetFileAttributes()\n"));

            DWORD dwFA = GetFileAttributes(szName);

            _tprintf(TEXT("\n    Return Value:    0x%08X"), dwFA);

            if (0xFFFFFFFF != dwFA)
            {
                for (DWORD i = 0; i < 32; ++i)
                {
                    DWORD dw = 1 << i;

                    if (dw & dwFA)
                    {
                        _tprintf(TEXT("\n    "));

                        switch (dw)
                        {
                            PRINTCASE(FILE_ATTRIBUTE_READONLY           );
                            PRINTCASE(FILE_ATTRIBUTE_HIDDEN             );
                            PRINTCASE(FILE_ATTRIBUTE_SYSTEM             );
                            PRINTCASE(FILE_ATTRIBUTE_DIRECTORY          );
                            PRINTCASE(FILE_ATTRIBUTE_ARCHIVE            );
                            PRINTCASE(FILE_ATTRIBUTE_DEVICE             );
                            PRINTCASE(FILE_ATTRIBUTE_NORMAL             );
                            PRINTCASE(FILE_ATTRIBUTE_TEMPORARY          );
                            PRINTCASE(FILE_ATTRIBUTE_SPARSE_FILE        );
                            PRINTCASE(FILE_ATTRIBUTE_REPARSE_POINT      );
                            PRINTCASE(FILE_ATTRIBUTE_COMPRESSED         );
                            PRINTCASE(FILE_ATTRIBUTE_OFFLINE            );
                            PRINTCASE(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);
                            PRINTCASE(FILE_ATTRIBUTE_ENCRYPTED          );

                            default:
                                _tprintf(TEXT("    %08X"), i);
                                break;
                        }
                    }
                }
            }
        }
    }

    if (dwFlags & FLAG_DRIVE)
    {
        // GetDriveType
        {
            _tprintf(TEXT("\n............................................................."));
            _tprintf(TEXT("\n... GetDriveType()\n"));

            UINT u = GetDriveType(szName);

            _tprintf(TEXT("\n    Return Value:    0x%08X"), u);
            _tprintf(TEXT("\n    "));

            switch (u)
            {
                PRINTCASE(DRIVE_UNKNOWN);
                PRINTCASE(DRIVE_NO_ROOT_DIR);
                PRINTCASE(DRIVE_REMOVABLE);
                PRINTCASE(DRIVE_FIXED);
                PRINTCASE(DRIVE_REMOTE);
                PRINTCASE(DRIVE_CDROM);
                PRINTCASE(DRIVE_RAMDISK);
            }
        }
    }

    if (dwFlags & FLAG_DRIVE)
    {
        // GetVolumeInformation
        {
            _tprintf(TEXT("\n............................................................."));
            _tprintf(TEXT("\n... GetVolumeInformation()\n"));
                           
            {
                TCHAR szVolumeName[MAX_PATH];
                DWORD dwVolSerialNumber;
                DWORD dwMaxCompName;
                DWORD dwFileSysFlags;
                TCHAR szFileSysName[MAX_PATH];

                BOOL b = GetVolumeInformation(
                    szName,
                    szVolumeName,
                    MAX_PATH,
                    &dwVolSerialNumber,
                    &dwMaxCompName,
                    &dwFileSysFlags,
                    szFileSysName,
                    MAX_PATH);

                _tprintf(TEXT("\n    Return Value:    0x%08X"), b);

                if (!b)
                {
                    _tprintf(TEXT(" (FALSE)"));
                }
                else
                {
                    if (TRUE == b)
                    {
                        _tprintf(TEXT(" (TRUE)"));
                    }

                    _tprintf(TEXT("\n    Volume Name:          \"%s\""), szVolumeName);
                    _tprintf(TEXT("\n    Volume Serial#:       %04X-%04X"), HIWORD(dwVolSerialNumber),
                        LOWORD(dwVolSerialNumber));
                    _tprintf(TEXT("\n    Volume Max Comp Name: %d"), dwMaxCompName);
                    _tprintf(TEXT("\n    File System Name:     \"%s\""), szFileSysName);
                    _tprintf(TEXT("\n    File System Flags:"));

                    for (DWORD i = 0; i < 32; ++i)
                    {
                        DWORD dw = 1 << i;

                        if (dw & dwFileSysFlags)
                        {
                            _tprintf(TEXT("\n        "));

                            switch (dw)
                            {
                                PRINTCASE(FILE_CASE_SENSITIVE_SEARCH  );
                                PRINTCASE(FILE_CASE_PRESERVED_NAMES   );
                                PRINTCASE(FILE_UNICODE_ON_DISK        );
                                PRINTCASE(FILE_PERSISTENT_ACLS        );
                                PRINTCASE(FILE_FILE_COMPRESSION       );
                                PRINTCASE(FILE_VOLUME_QUOTAS          );
                                PRINTCASE(FILE_SUPPORTS_SPARSE_FILES  );
                                PRINTCASE(FILE_SUPPORTS_REPARSE_POINTS);
                                PRINTCASE(FILE_SUPPORTS_REMOTE_STORAGE);
                                PRINTCASE(FILE_VOLUME_IS_COMPRESSED   );
                                PRINTCASE(FILE_SUPPORTS_OBJECT_IDS    );
                                PRINTCASE(FILE_SUPPORTS_ENCRYPTION    );

                                default:
                                    _tprintf(TEXT("    %08X"), i);
                                    break;
                            }
                        }
                    }
                }
            }
        }
    }

    if (dwFlags & FLAG_NETWORK)
    {
        TCHAR szRemote[MAX_PATH];
        lstrcpyn(szRemote, szName, ARRAYSIZE(szRemote));

        szRemote[2] = 0;
        
        {
            _tprintf(TEXT("\n............................................................."));
            _tprintf(TEXT("\n... WNetGetConnection()\n"));

            TCHAR szRemoteName[MAX_PATH];
            DWORD cchRemoteName = ARRAYSIZE(szRemoteName);

            DWORD dw = WNetGetConnection(szRemote, szRemoteName, &cchRemoteName);

            _tprintf(TEXT("\n    Return Value: 0x%08X ("), dw);
       
            switch (dw)
            {
                PRINTCASE(NO_ERROR         );     
                PRINTCASE(WN_NOT_CONNECTED         );     
                PRINTCASE(WN_OPEN_FILES              );   
                PRINTCASE(WN_DEVICE_IN_USE             ); 
                PRINTCASE(WN_BAD_NETNAME                );
                PRINTCASE(WN_BAD_LOCALNAME              );
                PRINTCASE(WN_ALREADY_CONNECTED          );
                PRINTCASE(WN_DEVICE_ERROR               );
                PRINTCASE(WN_CONNECTION_CLOSED          );
                PRINTCASE(WN_NO_NET_OR_BAD_PATH         );
                PRINTCASE(WN_BAD_PROVIDER               );
                PRINTCASE(WN_CANNOT_OPEN_PROFILE        );
                PRINTCASE(WN_BAD_PROFILE                );
                PRINTCASE(WN_BAD_DEV_TYPE               );
                PRINTCASE(WN_DEVICE_ALREADY_REMEMBERED  );
                PRINTCASE(WN_CONNECTED_OTHER_PASSWORD   );
            }

            if (WN_CONNECTION_CLOSED == dw)
            {
                _tprintf(TEXT(" == ERROR_CONNECTION_UNAVAIL)"));
            }
            else
            {
                _tprintf(TEXT(")"));
            }

            if (NO_ERROR == dw)
            {
                _tprintf(TEXT("\n    RemoteName:   \"%s\""), szRemoteName);
            }
        }

        {
            _tprintf(TEXT("\n\n............................................................."));
            _tprintf(TEXT("\n... WNetGetConnection3(..., WNGC_INFOLEVEL_DISCONNECTED, ...)\n"));

            WNGC_CONNECTION_STATE wngc;
            DWORD dwSize = sizeof(wngc.dwState);

            DWORD dw = WNetGetConnection3(szRemote, NULL, WNGC_INFOLEVEL_DISCONNECTED,
                &wngc.dwState, &dwSize);

            _tprintf(TEXT("\n    Return Value: 0x%08X ("), dw);

            switch (dw)
            {
                PRINTCASE(NO_ERROR         );     
                PRINTCASE(WN_NOT_CONNECTED         );     
                PRINTCASE(WN_OPEN_FILES              );   
                PRINTCASE(WN_DEVICE_IN_USE             ); 
                PRINTCASE(WN_BAD_NETNAME                );
                PRINTCASE(WN_BAD_LOCALNAME              );
                PRINTCASE(WN_ALREADY_CONNECTED          );
                PRINTCASE(WN_DEVICE_ERROR               );
                PRINTCASE(WN_CONNECTION_CLOSED          );
                PRINTCASE(WN_NO_NET_OR_BAD_PATH         );
                PRINTCASE(WN_BAD_PROVIDER               );
                PRINTCASE(WN_CANNOT_OPEN_PROFILE        );
                PRINTCASE(WN_BAD_PROFILE                );
                PRINTCASE(WN_BAD_DEV_TYPE               );
                PRINTCASE(WN_DEVICE_ALREADY_REMEMBERED  );
                PRINTCASE(WN_CONNECTED_OTHER_PASSWORD   );
            }

            if (WN_CONNECTION_CLOSED == dw)
            {
                _tprintf(TEXT(" == ERROR_CONNECTION_UNAVAIL)"));
            }
            else
            {
                _tprintf(TEXT(")"));
            }

            if (NO_ERROR == dw)
            {
                _tprintf(TEXT("\n    CONNECTIONSTATUS.dwState:  0x%08X ("), wngc.dwState);

                switch (wngc.dwState)
                {
                    PRINTCASE(WNGC_CONNECTED);     
                    PRINTCASE(WNGC_DISCONNECTED);     
                }

                _tprintf(TEXT(")"));
            }
        }
    }

    if (dwFlags & FLAG_LOGDRIVE)
    {
        _tprintf(TEXT("\n\n............................................................."));
        _tprintf(TEXT("\n... GetLogicalDrives()\n"));

        DWORD dwLG = GetLogicalDrives();

        _tprintf(TEXT("\n    Return Value:         0x%08X"), dwLG);

        for (DWORD i = 0; i < 32; ++i)
        {
            DWORD dw = 1 << i;

            if (dw & dwLG)
            {
                _tprintf(TEXT("\n        %c:"), TEXT('A') + (TCHAR)i);
            }
        }
    }

    _tprintf(TEXT("\n"));

    return 0;
}                       
#ifdef UNICODE
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\ddespy\lists.c ===
/*
 * LISTS.C
 *
 * This file implements a generalized multi-collumn listbox with a standard
 * frame window.
 */
#define UNICODE
#include <windows.h>
#include <windowsx.h>
#include <string.h>
#include <stdlib.h>
#include "ddespy.h"
#include "globals.h"
#include "lists.h"

int  CompareItems(LPTSTR psz1, LPTSTR psz2, INT SortCol, INT cCols);
int  CmpCols(LPTSTR psz1, LPTSTR psz2, INT SortCol);
void DrawLBItem(LPDRAWITEMSTRUCT lpdis);
LRESULT CALLBACK MCLBClientWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPAram);

UINT cyHeading;


#ifdef UNICODE

#define atoi    atoiW


//*********************************************************************
//
//  atoiW
//
//      Unicode version of atoi.
//

INT atoiW (LPTSTR s) {
   INT i = 0;

   while (isdigit (*s)) {
      i = i*10 + (BYTE)*s - TEXT('0');
      s++;
   }
   return i;
}

#endif

HWND CreateMCLBFrame(
                    HWND hwndParent,
                    LPTSTR lpszTitle,        // frame title string
                    UINT dwStyle,          // frame styles
                    HICON hIcon,
                    HBRUSH hbrBkgnd,        // background for heading.
                    LPTSTR lpszHeadings)     // tab delimited list of headings.  The number of
                        // headings indicate the number of collumns.
{
    static BOOL fRegistered = FALSE;
    MCLBCREATESTRUCT mclbcs;

    if (!fRegistered) {
        WNDCLASS wc;
        HDC hdc;
        TEXTMETRIC tm;

        wc.style = WS_OVERLAPPED | CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = MCLBClientWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 4;
        wc.hInstance = hInst;
        wc.hIcon = hIcon;
        wc.hCursor = NULL;
        wc.hbrBackground = hbrBkgnd;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = (LPCTSTR) RefString(IDS_LISTCLASS);
        RegisterClass(&wc);

        hdc = GetDC(GetDesktopWindow());
        GetTextMetrics(hdc, &tm);
        cyHeading = tm.tmHeight;
        ReleaseDC(GetDesktopWindow(), hdc);

        fRegistered = TRUE;
    }
    mclbcs.lpszHeadings = lpszHeadings;

    return(CreateWindow((LPCTSTR) RefString(IDS_LISTCLASS),
	    (LPCTSTR) lpszTitle, dwStyle,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            hwndParent, NULL, hInst, (LPVOID)&mclbcs));
}


LRESULT CALLBACK MCLBClientWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    MCLBSTRUCT *pmclb;
    RECT rc;
    INT  i;

    if (msg == WM_CREATE) {
        LPTSTR psz;
        MCLBCREATESTRUCT FAR *pcs;

        pcs = (MCLBCREATESTRUCT FAR *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        pmclb = (MCLBSTRUCT *)LocalAlloc(LPTR, sizeof(MCLBSTRUCT));
        psz = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)
	      * (lstrlen(pcs->lpszHeadings) + 1));
        lstrcpy((LPTSTR)psz, pcs->lpszHeadings);
        pmclb->pszHeadings = psz;
        pmclb->cCols = 1;
	while (*psz) {
	   if (*psz == '\t') {
	      pmclb->cCols++;
	   }
	   psz++;
	}
        pmclb->SortCol = 0;
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pmclb);
        GetClientRect(hwnd, &rc);
        pmclb->hwndLB = CreateWindow((LPCTSTR) RefString(IDS_LBOX),
	      (LPCTSTR) szNULL,
	       MYLBSTYLE | WS_VISIBLE,
               0, 0, 0, 0, hwnd, (HMENU)IntToPtr(pmclb->cCols), hInst, NULL);
        return(pmclb->hwndLB ? 0 : -1);
    }

    pmclb = (MCLBSTRUCT *)GetWindowLongPtr(hwnd, 0);

    switch (msg) {
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            DRAWITEMSTRUCT dis;

            BeginPaint(hwnd, &ps);
            SetBkMode(ps.hdc, TRANSPARENT);
            dis.hwndItem = hwnd;
            dis.hDC = ps.hdc;
            GetClientRect(hwnd, &dis.rcItem);
            dis.rcItem.bottom = dis.rcItem.top + cyHeading;
            dis.CtlType = ODT_BUTTON;   // hack to avoid erasure
            dis.CtlID = pmclb->cCols;
            dis.itemID = 0;
            dis.itemAction = ODA_DRAWENTIRE;
            dis.itemData = (UINT_PTR)(LPTSTR)pmclb->pszHeadings;
            dis.itemState = 0;
            DrawLBItem(&dis);
            EndPaint(hwnd, &ps);
        }
        break;

    case WM_SIZE:
        MoveWindow(pmclb->hwndLB, 0, cyHeading, LOWORD(lParam),
                HIWORD(lParam) - cyHeading, TRUE);
        break;

    case WM_LBUTTONDOWN:
        {
            HWND hwndLB;
            INT i;

            // determine which collumn the mouse landed and sort on that collumn.

            SendMessage(hwnd, WM_SETREDRAW, 0, 0);
            GetClientRect(hwnd, &rc);
            InflateRect(&rc, -1, -1);
            pmclb->SortCol = LOWORD(lParam) * pmclb->cCols / (rc.right - rc.left);
            hwndLB = CreateWindow((LPCTSTR) RefString(IDS_LBOX),
		    (LPCTSTR) szNULL, MYLBSTYLE, 1, cyHeading + 1,
                    rc.right - rc.left, rc.bottom - rc.top - cyHeading,
                    hwnd, (HMENU)IntToPtr(pmclb->cCols), hInst, NULL);
            for (i = (INT)SendMessage(pmclb->hwndLB, LB_GETCOUNT, 0, 0); i;
		   i--) {
                SendMessage(hwndLB, LB_ADDSTRING, 0,
                    SendMessage(pmclb->hwndLB, LB_GETITEMDATA, i - 1, 0));
                SendMessage(pmclb->hwndLB, LB_SETITEMDATA, i - 1, 0);
            }
            ShowWindow(hwndLB, SW_SHOW);
            ShowWindow(pmclb->hwndLB, SW_HIDE);
            DestroyWindow(pmclb->hwndLB);
            pmclb->hwndLB = hwndLB;
            SendMessage(hwnd, WM_SETREDRAW, 1, 0);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_DELETEITEM:

        if ((UINT)((LPDELETEITEMSTRUCT)lParam)->itemData)
            LocalFree(LocalHandle((PVOID)((LPDELETEITEMSTRUCT)lParam)->itemData));
        break;

    case WM_MEASUREITEM:
        ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = cyHeading;
        break;

    case WM_DRAWITEM:
        GetClientRect(hwnd, &rc);
        // This fudge makes the collumns line up with the heading.
        ((LPDRAWITEMSTRUCT)lParam)->rcItem.right = rc.right;
        DrawLBItem((LPDRAWITEMSTRUCT)lParam);
        return(DefWindowProc(hwnd, msg, wParam, lParam));
        break;

    case WM_COMPAREITEM:
        return(CompareItems((LPTSTR)((LPCOMPAREITEMSTRUCT)lParam)->itemData1,
                (LPTSTR)((LPCOMPAREITEMSTRUCT)lParam)->itemData2,
                pmclb->SortCol,
                pmclb->cCols));
        break;

    case WM_DESTROY:
        LocalFree(LocalHandle((PVOID)pmclb->pszHeadings));
        LocalFree(LocalHandle((PVOID)pmclb));
        break;

    case WM_CLOSE:
        for (i = 0; i < IT_COUNT && (hwndTrack[i] != hwnd); i++) {
            ;
        }
        pro.fTrack[i] = FALSE;
        hwndTrack[i] = NULL;
        SetFilters();
        DestroyWindow(hwnd);
        break;

    default:
        return(DefWindowProc(hwnd, msg, wParam, lParam));
    }

    return 0;
}




/*
 * Make this return FALSE if addition not needed.
 *
 * if pszSearch != NULL, searches for pszSearch - collumns may contain
 * wild strings - TEXT("*")
 * If found, the string is removed from the LB.
 * Adds pszReplace to LB.
 */
VOID AddMCLBText(LPTSTR pszSearch, LPTSTR pszReplace, HWND hwndLBFrame)
{
    MCLBSTRUCT *pmclb;
    INT lit;
    LPTSTR psz;

    pmclb = (MCLBSTRUCT *)GetWindowLongPtr(hwndLBFrame, 0);

    SendMessage(pmclb->hwndLB, WM_SETREDRAW, 0, 0);
    if (pszSearch != NULL) {
        lit = (INT)SendMessage(pmclb->hwndLB, LB_FINDSTRING, (WPARAM)-1, (LPARAM)pszSearch);
        if (lit >= 0) {
            SendMessage(pmclb->hwndLB, LB_DELETESTRING, lit, 0);
        }
    }
    psz = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (lstrlen(pszReplace) + 1));
    lstrcpy(psz, pszReplace);
    SendMessage(pmclb->hwndLB, WM_SETREDRAW, 1, 0);
    SendMessage(pmclb->hwndLB, LB_ADDSTRING, 0, (LPARAM)psz);
}


/*
 * This function assumes that the text in cCol is an ASCII number.  0 is
 * returned if it is not found.
 */
INT GetMCLBColValue(LPTSTR pszSearch, HWND hwndLBFrame, INT  cCol)
{
    MCLBSTRUCT *pmclb;
    LPTSTR psz;
    INT lit;

    pmclb = (MCLBSTRUCT *)GetWindowLongPtr(hwndLBFrame, 0);

    lit = (INT)SendMessage(pmclb->hwndLB, LB_FINDSTRING, (WPARAM)-1,
	  (LPARAM)(LPTSTR)pszSearch);
    if (lit < 0) {
        return(0);
    }
    psz = (LPTSTR)SendMessage(pmclb->hwndLB, LB_GETITEMDATA, lit, 0);
    while (--cCol && (psz = wcschr(psz, '\t') + 1)) {
        ;
    }
    if (psz) {
        return(atoi(psz));
    } else {
        return(0);
    }
}



/*
 * Returns fFoundAndRemoved
 */
BOOL DeleteMCLBText(LPTSTR pszSearch, HWND hwndLBFrame)
{
    MCLBSTRUCT *pmclb;
    INT lit;

    pmclb = (MCLBSTRUCT *)GetWindowLongPtr(hwndLBFrame, 0);
    lit = (INT)SendMessage(pmclb->hwndLB, LB_FINDSTRING, (WPARAM)-1, (LPARAM)pszSearch);
    if (lit >= 0) {
        SendMessage(pmclb->hwndLB, LB_DELETESTRING, lit, 0);
        return(TRUE);
    }
    return(FALSE);
}


/*
 * Returns >0 if item1 comes first, <0 if item2 comes first, 0 if ==.
 */
INT CompareItems(LPTSTR psz1, LPTSTR psz2, INT SortCol, INT cCols)
{
    INT i, Col;

    i = CmpCols(psz1, psz2, SortCol);
    if (i != 0) {
        return(i);
    }
    for (Col = 0; Col < cCols; Col++) {
        if (Col == SortCol) {
            continue;
        }
        i = CmpCols(psz1, psz2, Col);
        if (i != 0) {
            return(i);
        }
    }
    return(0);
}


INT CmpCols(LPTSTR psz1, LPTSTR psz2, INT SortCol)
{
    LPTSTR psz, pszT1, pszT2;
    INT iRet;

    while (SortCol--) {
        psz = wcschr(psz1, '\t');
        if (psz != NULL) {
            psz1 = psz + 1;
        } else {
            psz1 = psz1 + lstrlen(psz1);
        }
        psz = wcschr(psz2, '\t');
        if (psz != NULL) {
            psz2 = psz + 1;
        } else {
            psz2 = psz2 + lstrlen(psz2);
        }
    }
    pszT1 = wcschr(psz1, '\t');
    pszT2 = wcschr(psz2, '\t');

    if (pszT1) {
        *pszT1 = '\0';
    }
    if (pszT2) {
        *pszT2 = '\0';
    }

    if (!lstrcmp((LPCTSTR)RefString(IDS_WILD), psz1)
	     || !lstrcmp((LPCTSTR) RefString(IDS_WILD), psz2)) {
        iRet = 0;
    } else {
        iRet = lstrcmp(psz1, psz2);
    }

    if (pszT1) {
        *pszT1 = '\t';
    }
    if (pszT2) {
        *pszT2 = '\t';
    }

    return(iRet);
}



VOID DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    RECT rcDraw;
    INT cxSection;
    LPTSTR psz, pszEnd;

    if (!lpdis->itemData)
        return;
    if ((lpdis->itemAction & ODA_DRAWENTIRE) ||
            ((lpdis->itemAction & ODA_SELECT) &&
            (lpdis->itemState & ODS_SELECTED))) {
        rcDraw = lpdis->rcItem;
        if (lpdis->CtlType != ODT_BUTTON) { // hack to avoid erasure
            HBRUSH hbr;

            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            FillRect(lpdis->hDC, &lpdis->rcItem, hbr);
            DeleteObject(hbr);
        }
        cxSection = (rcDraw.right - rcDraw.left) / lpdis->CtlID;
        psz = (LPTSTR)lpdis->itemData;
        rcDraw.right = rcDraw.left + cxSection;
        while (pszEnd = wcschr(psz, '\t')) {
            *pszEnd = '\0';
            DrawText(lpdis->hDC, psz, -1, &rcDraw, DT_LEFT);
            OffsetRect(&rcDraw, cxSection, 0);
            *pszEnd = '\t';
            psz = pszEnd + 1;
        }
        DrawText(lpdis->hDC, psz, -1, &rcDraw, DT_LEFT);

        if (lpdis->itemState & ODS_SELECTED)
            InvertRect(lpdis->hDC, &lpdis->rcItem);

        if (lpdis->itemState & ODS_FOCUS)
            DrawFocusRect(lpdis->hDC, &lpdis->rcItem);

    } else if (lpdis->itemAction & ODA_SELECT) {

        InvertRect(lpdis->hDC, &lpdis->rcItem);

    } else if (lpdis->itemAction & ODA_FOCUS) {

        DrawFocusRect(lpdis->hDC, &lpdis->rcItem);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfcm2.cpp ===
/*CM_Connect_Machine

CM_Get_Device_ID_List_Size_Ex
CM_Get_Child_Ex
CM_Get_Sibling_Ex
CM_Get_Parent_Ex

CM_Get_DevNode_Registry_Property_Ex
CM_Get_Class_Name_Ex
CM_Get_DevNode_Status_Ex
CM_Get_Device_ID_Ex

CM_Request_Device_Eject_Ex
CM_Locate_DevNode_Ex*/

InitDevTreeDlgProc

DEVINST* DeviceInstance
HMACHINE DeviceTree->hMachine
DEVINST DeviceTree->DevInst
GUID DeviceTreeNode->ClassGuid
TCHAR   DeviceID[MAX_DEVICE_ID_LEN]
PTSTR DeviceInterface 

        //
        // Get the root devnode.
        //
        ConfigRet = CM_Locate_DevNode_Ex(&DeviceTree->DevInst,
                                         NULL,
                                         CM_LOCATE_DEVNODE_NORMAL,
                                         DeviceTree->hMachine (NULL)
                                         );
        if (ConfigRet != CR_SUCCESS) {

    ConfigRet = CM_Get_Child_Ex(&DeviceInstance, (Out param)
                                DeviceTree->DevInst, (prev call)
                                0,
                                DeviceTree->hMachine (NULL)
                                );
    if (ConfigRet == CR_SUCCESS) {

        // for info
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance, (from above)
                                                        CM_DRP_CLASSGUID,
                                                        NULL,
                                                        &Buffer,
                                                        &Len,
                                                        0,
                                                        DeviceTree->hMachine (NULL)
                                                        );


        if (ConfigRet == CR_SUCCESS) {
            Out:    // GUID_DEVCLASS_COMPUTER
                {0x4d36e966L, 0xe325, 0x11ce,
                {0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18}},


        if (ConfigRet == CR_SUCCESS) {
            ConfigRet = CM_Get_Class_Name_Ex(&DeviceTreeNode->ClassGuid,
                                         Buffer,
                                         &Len,
                                         0,
                                         DeviceTree->hMachine
                                         );
            Out: Computer

        if (ConfigRet == CR_SUCCESS) {

            // trying to find drive letter
x            DevNodeToDriveLetter(x
x
x            if (CM_Get_Device_ID_Ex(DevInst,
x                                    DeviceID,
x                                    sizeof(DeviceID)/sizeof(TCHAR),
x                                    0,
x                                    NULL
x                                    ) == CR_SUCCESS) {
x                Out: 0x0006ee8c "ROOT\ACPI_HAL\0000"
x
x
x            if (CM_Get_Device_Interface_List_Size(&ulSize,
x                                           (LPGUID)&VolumeClassGuid,
x                                           DeviceID,
x                                           0)  == CR_SUCCESS) &&
x
x                Out: FAILS
x                             (ulSize > 1) &&
x                ((DeviceInterface = LocalAlloc(LPTR, ulSize*sizeof(TCHAR))) != NULL) &&
x                    (CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid,
x                                      DeviceID,
x                                      DeviceInterface,
x                                      ulSize,
x                                      0
x                                      )  == CR_SUCCESS) &&


        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_FRIENDLYNAME,
                                                        NULL,
                                                        Buffer,
                                                        &Len,
                                                        0,
                                                        DeviceTree->hMachine
                                                        );

            then, CM_DRP_DEVICEDESC... out: "Advanced Configuration and Power Interface (ACPI) PC"

            ....

            BuildLocationInformation: Boring....

            // Get InstanceId
            ConfigRet = CM_Get_Device_ID_ExW(DeviceInstance, 
                                         Buffer,
                                         Len/sizeof(TCHAR),
                                         0,
                                         DeviceTree->hMachine
                                         );

            Out "ROOT\ACPI_HAL\0000"

            { // should skip
                BuildDeviceRelationsList

                    ConfigRet = CM_Get_Device_ID_List_Size_Ex(&Len,
                                                  DeviceId, ("ROOT\ACPI_HAL\0000")
                                                  FilterFlag, (CM_GETIDLIST_FILTER_EJECTRELATIONS)
                                                  hMachine (NULL)
                                                  );
                BuildDeviceRelationsList

                    ConfigRet = CM_Get_Device_ID_List_Size_Ex(&Len,
                                                  DeviceId, ("ROOT\ACPI_HAL\0000")
                                                  FilterFlag, (CM_GETIDLIST_FILTER_REMOVALRELATIONS)
                                                  hMachine
                                                  );

                // Both FAILED, if would have succeeded, would have trierd to enum drive letters
            }
            // If this devinst has children, then recurse to fill in its child sibling list.
    
            ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance, (out param)
                                        DeviceInstance, (same as above)
                                        0,
                                        DeviceTree->hMachine (NULL)
                                        );

            //recurse to redo the same as above for child, then ...

            // Next sibling ...
            ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance, (Ouch!)
                                          DeviceInstance,
                                          0,
                                          DeviceTree->hMachine
                                          );





///////////////////////////////////////////////////////////////////////////////
//
// Device Instance status flags, returned by call to CM_Get_DevInst_Status
//
#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be rebalanced
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed


// Flags for CM_Get_Device_ID_List, CM_Get_Device_ID_List_Size
//
#define CM_GETIDLIST_FILTER_NONE                (0x00000000)
#define CM_GETIDLIST_FILTER_ENUMERATOR          (0x00000001)
#define CM_GETIDLIST_FILTER_SERVICE             (0x00000002)
#define CM_GETIDLIST_FILTER_EJECTRELATIONS      (0x00000004)
#define CM_GETIDLIST_FILTER_REMOVALRELATIONS    (0x00000008)
#define CM_GETIDLIST_FILTER_POWERRELATIONS      (0x00000010)
#define CM_GETIDLIST_FILTER_BUSRELATIONS        (0x00000020)
#define CM_GETIDLIST_DONOTGENERATE              (0x10000040)
#define CM_GETIDLIST_FILTER_BITS                (0x1000007F)

//
// Flags for CM_Get_Device_Interface_List, CM_Get_Device_Interface_List_Size
//
#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT     (0x00000000)  // only currently 'live' device interfaces
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES (0x00000001)  // all registered device interfaces, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS        (0x00000001)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfcm.h ===
#ifndef _DFCM_H
#define _DFCM_H

#include <objbase.h>

HRESULT _FullTree(DWORD dwFlags[], DWORD cchIndent);
HRESULT _DeviceInfo(DWORD dwFlags[], LPWSTR pszDeviceID, DWORD cchIndent);
HRESULT _DeviceInterface(DWORD dwFlags[], LPWSTR pszDeviceID, DWORD cchIndent);
HRESULT _EnumDevice(DWORD dwFlags[], LPWSTR pszArg, DWORD cchIndent);
HRESULT _DeviceIDList(DWORD dwFlags[], LPWSTR pszDeviceID, DWORD cchIndent);

#endif // _DFCM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfeject.cpp ===
#include "dfeject.h"

#include <stdio.h>
#include <winioctl.h>

#include "drvfull.h"
#include "dfioctl.h"
#include "dferr.h"

#include "dfhlprs.h"

HRESULT _IOCTLEject(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    HANDLE hDevice;
    DWORD dwDesiredAccess;

    _StartClock();
   
    switch(GetDriveType(pszArg + 4))
    {
        case DRIVE_REMOVABLE:
            dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
            break;

        case DRIVE_CDROM:
            dwDesiredAccess = GENERIC_READ;
            break;

        default:
            hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres))
    {
        DWORD dwDummy;
        BOOL b;

        hDevice = _GetDeviceHandle(pszArg, dwDesiredAccess);

        if (INVALID_HANDLE_VALUE != hDevice)
        {
            // Lock the volume
            b = DeviceIoControl(hDevice,
                   FSCTL_LOCK_VOLUME,
                   NULL, 0,
                   NULL, 0,
                   &dwDummy,
                   NULL);
            
            if (b)
            {
                // Dismount the volume
                b = DeviceIoControl(hDevice,
                               FSCTL_DISMOUNT_VOLUME,
                               NULL, 0,
                               NULL, 0,
                               &dwDummy,
                               NULL);

                if (b)
                {
                    b = DeviceIoControl(hDevice,
                        IOCTL_STORAGE_EJECT_MEDIA, // dwIoControlCode operation to perform
                        NULL,                        // lpInBuffer; must be NULL
                        0,                           // nInBufferSize; must be zero
                        NULL,        // pointer to output buffer
                        0,      // size of output buffer
                        &dwDummy,   // receives number of bytes returned
                        NULL);

                    _StopClock();

                    _PrintIndent(cchIndent);
                    if (b)
                    {
                        wprintf(TEXT("Device ejected\n"));
                        hres = S_OK;
                    }
                    else
                    {
                        wprintf(TEXT("Cannot lock device\n"));
                        hres = E_FAIL;
                    }
                }
                else
                {
                    _PrintIndent(cchIndent);
                    wprintf(TEXT("Cannot lock device\n"));
                    hres = E_FAIL;
                }
            }
            else
            {
                _PrintIndent(cchIndent);
                wprintf(TEXT("Cannot lock device\n"));
                hres = E_FAIL;
            }

            CloseHandle(hDevice);
        }
        else
        {
            _PrintIndent(cchIndent);
            wprintf(TEXT("Cannot open device\n"));
            _PrintGetLastError(cchIndent);
            hres = E_DF_CANNOTOPENDEVICE;
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfeject.h ===
#ifndef _DFEJECT_H
#define _DFEJECT_H

#include <objbase.h>

HRESULT _IOCTLEject(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

#endif // _DFEJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfioctl.h ===
#ifndef _DFIOCTL_H
#define _DFIOCTL_H

#include <objbase.h>

HRESULT _ProcessIOCTL(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

// Helpers
HANDLE _GetDeviceHandle(LPTSTR psz, DWORD dwDesiredAccess, DWORD dwFileAttributes = 0);

#endif // _DFIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dferr.h ===
#define E_DF_CANNOTOPENDEVICE       MAKE_HRESULT(1, FACILITY_ITF, 0x200)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfhlprs.h ===
#ifndef _DFHLPRS_H
#define _DFHLPRS_H

#include <objbase.h>

struct _sFLAG_DESCR
{
    DWORD   dwFlag;
    LPTSTR  pszDescr;
    LPTSTR  pszComment;
};

#define FLAG_DESCR(a) { (DWORD)a, TEXT(#a), NULL }
#define FLAG_DESCR_COMMENT(a, c) { (DWORD)a, TEXT(#a), c }

struct _sGUID_DESCR
{
    GUID*   pguid;
    LPTSTR  pszDescr;
    LPTSTR  pszComment;
};

#define GUID_DESCR(a, b) { (GUID*)a, b, NULL }
#define GUID_DESCR_COMMENT(a, b, c) { (GUID*)a, b, c }

int _PrintIndent(DWORD cch);
int _PrintCR();
int _PrintGUID(CONST GUID* pguid);
int _PrintGUIDEx(CONST GUID* pguid, _sGUID_DESCR rgguid[], DWORD cguid,
    BOOL fPrintValue, DWORD cchIndent);

void _StartClock();
void _StopClock();

int _PrintElapsedTime(DWORD cchIndent, BOOL fCarriageReturn);
int _PrintGetLastError(DWORD cchIndent);

int _PrintFlag(DWORD dwFlag, _sFLAG_DESCR rgflag[], DWORD cflag,
    DWORD cchIndent, BOOL fPrintValue, BOOL fHex, BOOL fComment, BOOL fORed);

HANDLE _GetDeviceHandle(LPTSTR psz, DWORD dwDesiredAccess, DWORD dwFileAttributes);

#endif // _DFHLPRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfioctl.cpp ===
#include "dfioctl.h"

#include <stdio.h>
#include <winioctl.h>

#pragma warning(disable: 4200)
#include <ntddcdvd.h>

#include <ntddmmc.h>
#include <ntddcdrm.h>

#include "dferr.h"
#include "dfhlprs.h"
#include "drvfull.h"
#include "dfeject.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))


///////////////////////////////////////////////////////////////////////////////
// MEDIA_TYPE
_sFLAG_DESCR _mediatypeFD[] =
{
    FLAG_DESCR_COMMENT(Unknown, TEXT("Format is unknown")),
    FLAG_DESCR_COMMENT(F5_1Pt2_512, TEXT("5.25, 1.2MB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_1Pt44_512, TEXT("3.5,  1.44MB, 512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_2Pt88_512, TEXT("3.5,  2.88MB, 512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_20Pt8_512, TEXT("3.5,  20.8MB, 512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_720_512, TEXT("3.5,  720KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_360_512, TEXT("5.25, 360KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_320_512, TEXT("5.25, 320KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_320_1024, TEXT("5.25, 320KB,  1024 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_180_512, TEXT("5.25, 180KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_160_512, TEXT("5.25, 160KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(RemovableMedia, TEXT("Removable media other than floppy")),
    FLAG_DESCR_COMMENT(FixedMedia, TEXT("Fixed hard disk media")),
    FLAG_DESCR_COMMENT(F3_120M_512, TEXT("3.5, 120M Floppy")),
    FLAG_DESCR_COMMENT(F3_640_512, TEXT("3.5 ,  640KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_640_512, TEXT("5.25,  640KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_720_512, TEXT("5.25,  720KB,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_1Pt2_512, TEXT("3.5 ,  1.2Mb,  512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_1Pt23_1024, TEXT("3.5 ,  1.23Mb, 1024 bytes/sector")),
    FLAG_DESCR_COMMENT(F5_1Pt23_1024, TEXT("5.25,  1.23MB, 1024 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_128Mb_512, TEXT("3.5 MO 128Mb   512 bytes/sector")),
    FLAG_DESCR_COMMENT(F3_230Mb_512, TEXT("3.5 MO 230Mb   512 bytes/sector")),
    FLAG_DESCR_COMMENT(F8_256_128, TEXT("8, 256KB,  128 bytes/sector")),
    //
    FLAG_DESCR_COMMENT(DDS_4mm, TEXT("Tape - DAT DDS1,2,... (all vendors)")),
    FLAG_DESCR_COMMENT(MiniQic, TEXT("Tape - miniQIC Tape")),
    FLAG_DESCR_COMMENT(Travan, TEXT("Tape - Travan TR-1,2,3,...")),
    FLAG_DESCR_COMMENT(QIC, TEXT("Tape - QIC")),
    FLAG_DESCR_COMMENT(MP_8mm, TEXT("Tape - 8mm Exabyte Metal Particle")),
    FLAG_DESCR_COMMENT(AME_8mm, TEXT("Tape - 8mm Exabyte Advanced Metal Evap")),
    FLAG_DESCR_COMMENT(AIT1_8mm, TEXT("Tape - 8mm Sony AIT1")),
    FLAG_DESCR_COMMENT(DLT, TEXT("Tape - DLT Compact IIIxt, IV")),
    FLAG_DESCR_COMMENT(NCTP, TEXT("Tape - Philips NCTP")),
    FLAG_DESCR_COMMENT(IBM_3480, TEXT("Tape - IBM 3480")),
    FLAG_DESCR_COMMENT(IBM_3490E, TEXT("Tape - IBM 3490E")),
    FLAG_DESCR_COMMENT(IBM_Magstar_3590, TEXT("Tape - IBM Magstar 3590")),
    FLAG_DESCR_COMMENT(IBM_Magstar_MP, TEXT("Tape - IBM Magstar MP")),
    FLAG_DESCR_COMMENT(STK_DATA_D3, TEXT("Tape - STK Data D3")),
    FLAG_DESCR_COMMENT(SONY_DTF, TEXT("Tape - Sony DTF")),
    FLAG_DESCR_COMMENT(DV_6mm, TEXT("Tape - 6mm Digital Video")),
    FLAG_DESCR_COMMENT(DMI, TEXT("Tape - Exabyte DMI and compatibles")),
    FLAG_DESCR_COMMENT(SONY_D2, TEXT("Tape - Sony D2S and D2L")),
    FLAG_DESCR_COMMENT(CLEANER_CARTRIDGE, TEXT("Cleaner - All Drive types that support Drive Cleaners")),
    FLAG_DESCR_COMMENT(CD_ROM, TEXT("Opt_Disk - CD")),
    FLAG_DESCR_COMMENT(CD_R, TEXT("Opt_Disk - CD-Recordable (Write Once)")),
    FLAG_DESCR_COMMENT(CD_RW, TEXT("Opt_Disk - CD-Rewriteable")),
    FLAG_DESCR_COMMENT(DVD_ROM, TEXT("Opt_Disk - DVD-ROM")),
    FLAG_DESCR_COMMENT(DVD_R, TEXT("Opt_Disk - DVD-Recordable (Write Once)")),
    FLAG_DESCR_COMMENT(DVD_RW, TEXT("Opt_Disk - DVD-Rewriteable")),
    FLAG_DESCR_COMMENT(MO_3_RW, TEXT("Opt_Disk - 3.5\" Rewriteable MO Disk")),
    FLAG_DESCR_COMMENT(MO_5_WO, TEXT("Opt_Disk - MO 5.25\" Write Once")),
    FLAG_DESCR_COMMENT(MO_5_RW, TEXT("Opt_Disk - MO 5.25\" Rewriteable (not LIMDOW)")),
    FLAG_DESCR_COMMENT(MO_5_LIMDOW, TEXT("Opt_Disk - MO 5.25\" Rewriteable (LIMDOW)")),
    FLAG_DESCR_COMMENT(PC_5_WO, TEXT("Opt_Disk - Phase Change 5.25\" Write Once Optical")),
    FLAG_DESCR_COMMENT(PC_5_RW, TEXT("Opt_Disk - Phase Change 5.25\" Rewriteable")),
    FLAG_DESCR_COMMENT(PD_5_RW, TEXT("Opt_Disk - PhaseChange Dual Rewriteable")),
    FLAG_DESCR_COMMENT(ABL_5_WO, TEXT("Opt_Disk - Ablative 5.25\" Write Once Optical")),
    FLAG_DESCR_COMMENT(PINNACLE_APEX_5_RW, TEXT("Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical")),
    FLAG_DESCR_COMMENT(SONY_12_WO, TEXT("Opt_Disk - Sony 12\" Write Once")),
    FLAG_DESCR_COMMENT(PHILIPS_12_WO, TEXT("Opt_Disk - Philips/LMS 12\" Write Once")),
    FLAG_DESCR_COMMENT(HITACHI_12_WO, TEXT("Opt_Disk - Hitachi 12\" Write Once")),
    FLAG_DESCR_COMMENT(CYGNET_12_WO, TEXT("Opt_Disk - Cygnet/ATG 12\" Write Once")),
    FLAG_DESCR_COMMENT(KODAK_14_WO, TEXT("Opt_Disk - Kodak 14\" Write Once")),
    FLAG_DESCR_COMMENT(MO_NFR_525, TEXT("Opt_Disk - Near Field Recording (Terastor)")),
    FLAG_DESCR_COMMENT(NIKON_12_RW, TEXT("Opt_Disk - Nikon 12\" Rewriteable")),
    FLAG_DESCR_COMMENT(IOMEGA_ZIP, TEXT("Mag_Disk - Iomega Zip")),
    FLAG_DESCR_COMMENT(IOMEGA_JAZ, TEXT("Mag_Disk - Iomega Jaz")),
    FLAG_DESCR_COMMENT(SYQUEST_EZ135, TEXT("Mag_Disk - Syquest EZ135")),
    FLAG_DESCR_COMMENT(SYQUEST_EZFLYER, TEXT("Mag_Disk - Syquest EzFlyer")),
    FLAG_DESCR_COMMENT(SYQUEST_SYJET, TEXT("Mag_Disk - Syquest SyJet")),
    FLAG_DESCR_COMMENT(AVATAR_F2, TEXT("Mag_Disk - 2.5\" Floppy")),
    FLAG_DESCR_COMMENT(MP2_8mm, TEXT("Tape - 8mm Hitachi")),
    FLAG_DESCR_COMMENT(DST_S, TEXT("Ampex DST Small Tapes")),
    FLAG_DESCR_COMMENT(DST_M, TEXT("Ampex DST Medium Tapes")),
    FLAG_DESCR_COMMENT(DST_L, TEXT("Ampex DST Large Tapes")),
    FLAG_DESCR_COMMENT(VXATape_1, TEXT("Ecrix 8mm Tape")),
    FLAG_DESCR_COMMENT(VXATape_2, TEXT("Ecrix 8mm Tape")),
    FLAG_DESCR_COMMENT(LTO_Ultrium, TEXT("IBM, HP, Seagate LTO Ultrium")),
    FLAG_DESCR_COMMENT(LTO_Accelis, TEXT("IBM, HP, Seagate LTO Accelis")),
};

int _PrintMediaTypeReport(DWORD dwFlags[], DWORD cchIndent, MEDIA_TYPE mt)
{
    int i = 0;

    // for now let's assume raw

    i += _PrintFlag(mt, _mediatypeFD, ARRAYSIZE(_mediatypeFD), cchIndent, 
        TRUE, TRUE, TRUE, FALSE);

    return i;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_DISK_GET_DRIVE_LAYOUT
_sFLAG_DESCR _partitiontypeFD[] =
{
    FLAG_DESCR_COMMENT(PARTITION_ENTRY_UNUSED, TEXT("Entry unused")),
    FLAG_DESCR_COMMENT(PARTITION_FAT_12, TEXT("12-bit FAT entries")),
    FLAG_DESCR_COMMENT(PARTITION_XENIX_1, TEXT("Xenix")),
    FLAG_DESCR_COMMENT(PARTITION_XENIX_2, TEXT("Xenix")),
    FLAG_DESCR_COMMENT(PARTITION_FAT_16, TEXT("16-bit FAT entries")),
    FLAG_DESCR_COMMENT(PARTITION_EXTENDED, TEXT("Extended partition entry")),
    FLAG_DESCR_COMMENT(PARTITION_HUGE, TEXT("Huge partition MS-DOS V4")),
    FLAG_DESCR_COMMENT(PARTITION_IFS, TEXT("IFS Partition")),
    FLAG_DESCR_COMMENT(PARTITION_FAT32, TEXT("FAT32")),
    FLAG_DESCR_COMMENT(PARTITION_FAT32_XINT13, TEXT("FAT32 using extended int13 services")),
    FLAG_DESCR_COMMENT(PARTITION_XINT13, TEXT("Win95 partition using extended int13 services")),
    FLAG_DESCR_COMMENT(PARTITION_XINT13_EXTENDED, TEXT("Same as type 5 but uses extended int13 services")),
    FLAG_DESCR_COMMENT(PARTITION_PREP, TEXT("PowerPC Reference Platform (PReP) Boot Partition")),
    FLAG_DESCR_COMMENT(PARTITION_LDM, TEXT("Logical Disk Manager partition")),
    FLAG_DESCR_COMMENT(PARTITION_UNIX, TEXT("Unix")),
};

int _PrintLayoutReport(DWORD dwFlags[], DWORD cchIndent,
    DRIVE_LAYOUT_INFORMATION* pdli)
{
    int i = 0;

    // for now let's assume raw

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
        TEXT("IOCTL_DISK_GET_DRIVE_LAYOUT;\n")));

    _PrintElapsedTime(cchIndent, TRUE);

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("DRIVE_LAYOUT_INFORMATION\n"));
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("{\n"));
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("0x%02u (DWORD PartitionCount)\n"),
        pdli->PartitionCount);

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("0x%08X (DWORD Signature)\n"), pdli->Signature);

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("{\n"));

    for (DWORD dw = 0; dw < pdli->PartitionCount; ++dw)
    {
        PARTITION_INFORMATION* ppi = &(pdli->PartitionEntry[dw]);
        LPTSTR pszBool;
        TCHAR szTrue[] = TEXT("TRUE");
        TCHAR szFalse[] = TEXT("FALSE");
        
        _PrintIndent(cchIndent + 4);
        i += wprintf(TEXT("PARTITION_INFORMATION\n"));
        _PrintIndent(cchIndent + 4);
        i += wprintf(TEXT("{\n"));

        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("0x%08X (lo), 0x%08X (hi) (LARGE_INTEGER StartingOffset)\n"),
            ppi->StartingOffset.LowPart, ppi->StartingOffset.HighPart);
        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("0x%08X (lo), 0x%08X (hi) (LARGE_INTEGER PartitionLength)\n"),
            ppi->PartitionLength.LowPart, ppi->PartitionLength.HighPart);

        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("0x%08X (DWORD HiddenSectors)\n"),
            ppi->HiddenSectors);

        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("0x%02u (DWORD PartitionNumber)\n"),
            ppi->PartitionNumber);

        i += _PrintFlag(ppi->PartitionType, _partitiontypeFD, ARRAYSIZE(_partitiontypeFD),
            cchIndent + 6, TRUE, TRUE, TRUE, FALSE);
        i += wprintf(TEXT(" (BYTE PartitionType)\n"));

        if (ppi->BootIndicator)
        {
            pszBool = szTrue;
        }
        else
        {
            pszBool = szFalse;
        }
        
        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("%s (BOOLEAN BootIndicator)\n"),
            pszBool);

        if (ppi->RecognizedPartition)
        {
            pszBool = szTrue;
        }
        else
        {
            pszBool = szFalse;
        }
        
        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("%s (BOOLEAN RecognizedPartition)\n"),
            pszBool);
        
        if (ppi->RewritePartition)
        {
            pszBool = szTrue;
        }
        else
        {
            pszBool = szFalse;
        }
        
        _PrintIndent(cchIndent + 6);
        i += wprintf(TEXT("%s (BOOLEAN RewritePartition)\n"),
            pszBool);
        _PrintIndent(cchIndent + 4);
        i += wprintf(TEXT("}\n"));
    }

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("}\n"));
    
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("}\n"));

    return i;
}

HRESULT _IOCTLLayout(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;
        BOOL b;

        DWORD cbdli = 4096;//sizeof(DRIVE_LAYOUT_INFORMATION) + 8 * sizeof(PARTITION_INFORMATION);
        DRIVE_LAYOUT_INFORMATION* pdli = (DRIVE_LAYOUT_INFORMATION*)LocalAlloc(LPTR, cbdli);

        b = DeviceIoControl(hDevice,
            IOCTL_DISK_GET_DRIVE_LAYOUT, // dwIoControlCode operation to perform
            NULL,                        // lpInBuffer; must be NULL
            0,                           // nInBufferSize; must be zero
            (LPVOID)pdli,        // pointer to output buffer
            (DWORD)cbdli,      // size of output buffer
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        if (b)
        {
            _PrintLayoutReport(dwFlags, cchIndent, pdli);

            hres = S_OK;
        }
        else
        {
            _PrintGetLastError(cchIndent);

            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_DISK_GET_DRIVE_GEOMETRY
int _PrintGeometryReport(DWORD dwFlags[], DWORD cchIndent, DISK_GEOMETRY* pdg)
{
    int i = 0;

    // for now let's assume raw

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
        TEXT("IOCTL_DISK_GET_DRIVE_GEOMETRY;\n")));

    _PrintElapsedTime(cchIndent, TRUE);

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("DISK_GEOMETRY\n"));
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("{\n"));
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("0x%08X (lo), 0x%08X (hi) (LARGE_INTEGER Cylinders)\n"),
        pdg->Cylinders.LowPart, pdg->Cylinders.HighPart);

    i += _PrintMediaTypeReport(dwFlags, cchIndent + 2, pdg->MediaType);
    i += wprintf(TEXT(" (MEDIA_TYPE MediaType)\n"));

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD TracksPerCylinder)\n"), pdg->TracksPerCylinder); 
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD SectorsPerTrack)\n"), pdg->SectorsPerTrack);
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD BytesPerSector)\n"), pdg->BytesPerSector);
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("}\n"));

    return i;
}

HRESULT _IOCTLGeometry(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;
        BOOL b;

        DISK_GEOMETRY dg = {0};

        b = DeviceIoControl(hDevice,
            IOCTL_DISK_GET_DRIVE_GEOMETRY, // dwIoControlCode operation to perform
            NULL,                        // lpInBuffer; must be NULL
            0,                           // nInBufferSize; must be zero
            &dg,        // pointer to output buffer
            sizeof(dg),      // size of output buffer
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        if (b)
        {
            _PrintGeometryReport(dwFlags, cchIndent, &dg);

            hres = S_OK;
        }
        else
        {
            _PrintGetLastError(cchIndent);

            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

HRESULT _IOCTLPartition(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;

    if (_IsFlagSet(IOCTL_PARTITION, dwFlags))
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Are you really sure?  You know what partioning a drive does, right?  If so the real switch is \'-hpsure\'.\n"));
        hres = S_OK;
    }
    else
    {
        if (_IsFlagSet(IOCTL_PARTITIONSURE, dwFlags))
        {
            HANDLE hDevice;

            _StartClock();

            hDevice = _GetDeviceHandle(pszArg, GENERIC_WRITE | GENERIC_READ);

            if (INVALID_HANDLE_VALUE != hDevice)
            {
                DWORD dwDummy;
                BOOL b;

                DISK_GEOMETRY dg = {0};

                b = DeviceIoControl(hDevice,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY, // dwIoControlCode operation to perform
                    NULL,                        // lpInBuffer; must be NULL
                    0,                           // nInBufferSize; must be zero
                    &dg,        // pointer to output buffer
                    sizeof(dg),      // size of output buffer
                    &dwDummy,   // receives number of bytes returned
                    NULL);

                if (b)
                {
                    // Calc size
                    DRIVE_LAYOUT_INFORMATION dli = {0};

                    dli.PartitionCount = 1;
                    dli.Signature = 0x57EF57EF;
                    
                    dli.PartitionEntry[0].StartingOffset.QuadPart = ((LONGLONG)dg.SectorsPerTrack) *
                        ((LONGLONG)dg.BytesPerSector);
                    dli.PartitionEntry[0].PartitionLength.QuadPart = ((LONGLONG)(dg.Cylinders.QuadPart - 1)) *
                        ((LONGLONG)dg.TracksPerCylinder) * ((LONGLONG)dg.SectorsPerTrack) *
                        ((LONGLONG)dg.BytesPerSector) - ((LONGLONG)dg.SectorsPerTrack) *
                        ((LONGLONG)dg.BytesPerSector);
                    dli.PartitionEntry[0].PartitionNumber = 1;
                    dli.PartitionEntry[0].PartitionType = PARTITION_IFS; // is that OK?
                    dli.PartitionEntry[0].RecognizedPartition = TRUE;
                    dli.PartitionEntry[0].RewritePartition = TRUE;

                    b = DeviceIoControl(hDevice,
                        IOCTL_DISK_SET_DRIVE_LAYOUT, // dwIoControlCode operation to perform
                        &dli,        // pointer to output buffer
                        sizeof(dli),      // size of output buffer
                        NULL,                        // lpInBuffer; must be NULL
                        0,                           // nInBufferSize; must be zero
                        &dwDummy,   // receives number of bytes returned
                        NULL);

                    hres = S_OK;

                    if (b)
                    {
                        wprintf(TEXT("Succeeded!\n"));
                    }
                    else
                    {
                        wprintf(TEXT("Failed!\n"));
                    }
                }
                else
                {
                    _PrintGetLastError(cchIndent);

                    hres = E_FAIL;
                }

                CloseHandle(hDevice);
            }
            else
            {
                _PrintIndent(cchIndent);
                wprintf(TEXT("Cannot open device\n"));
                _PrintGetLastError(cchIndent);
                hres = E_DF_CANNOTOPENDEVICE;
            }
        }
    }

    return hres;
}

HRESULT _IOCTLPartitionGPT(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;

    //HANDLE hDevice = _GetDeviceHandle(pszArg, GENERIC_WRITE | GENERIC_READ);
    //HANDLE hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);
    HANDLE hDevice = _GetDeviceHandle(pszArg, FILE_READ_ATTRIBUTES);    

    if (hDevice)
    {
        PARTITION_INFORMATION_EX partitionEx;
        DWORD cbReturned;
        if (DeviceIoControl(hDevice, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, 
                            (void*)&partitionEx, sizeof(PARTITION_INFORMATION_EX), 
                            &cbReturned, NULL))
        {
            hres = S_OK;

            if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) 
            {
                wprintf(TEXT("Succeeded!\n"));
            }
            else
            {
                wprintf(TEXT("Failed!\n"));
            }
        }
        else
        {
            _PrintGetLastError(cchIndent);
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_CDROM_GET_CONFIGURATION
HRESULT _IOCTLCDROMGetConfig(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD cbReturned;

        GET_CONFIGURATION_IOCTL_INPUT input;
//        GET_CONFIGURATION_HEADER header;
        DWORD cbHeader = sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_HEADER);
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)LocalAlloc(LPTR, 
            cbHeader);

        if (pheader)
        {
            LPWSTR pszSucceeded = NULL;
            LPWSTR pszFailed = NULL;

            input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
            input.Reserved[0] = NULL;
            input.Reserved[1] = NULL;

            if (_IsFlagSet(IOCTL_CDROMGETCONFIGMMC2, dwFlags))
            {
                input.Feature = FeatureProfileList;

                pszSucceeded = TEXT("MMC2 Compliant drive\n");
                pszFailed = TEXT("NOT MMC2 Compliant drive\n");
            }
            else
            {
                if (_IsFlagSet(IOCTL_CDROMGETCONFIGDVDRAM, dwFlags))
                {
                    input.Feature = FeatureDvdRead;

                    pszSucceeded = TEXT("DVD RAM drive\n");
                    pszFailed = TEXT("NOT DVD RAM drive\n");
                }
                else
                {
                    if (_IsFlagSet(IOCTL_CDROMGETCONFIGRW, dwFlags))
                    {
                        input.Feature = FeatureRandomWritable;

                        pszSucceeded = TEXT("Random Writable drive\n");
                        pszFailed = TEXT("NOT Random Writable drive\n");
                    }
                    else
                    {
                        if (_IsFlagSet(IOCTL_CDROMGETCONFIGWO, dwFlags))
                        {
                            input.Feature = FeatureWriteOnce;

                            pszSucceeded = TEXT("Write Once drive\n");
                            pszFailed = TEXT("NOT Write Once drive\n");
                        }
                        else
                        {
                            if (_IsFlagSet(IOCTL_CDROMGETCONFIGISW, dwFlags))
                            {
                                input.Feature = FeatureIncrementalStreamingWritable;

                                pszSucceeded = TEXT("Inc Streaming Writable drive\n");
                                pszFailed = TEXT("NOT Inc Streaming Writable drive\n");
                            }
                            else
                            {
                                pszSucceeded = TEXT("ERROR: Bad option!\n");
                                pszFailed = pszSucceeded;
                            }
                        }
                    }
                }
            }

            BOOL f = DeviceIoControl(hDevice,
                                 IOCTL_CDROM_GET_CONFIGURATION,
                                 &input,
                                 sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                 pheader,
//                                 sizeof(GET_CONFIGURATION_HEADER),
                                 cbHeader,             
                                 &cbReturned,
                                 NULL);

            FEATURE_HEADER* pfh = (FEATURE_HEADER*)(pheader->Data);

            _StopClock();

            _PrintElapsedTime(cchIndent, TRUE);

            _PrintIndent(cchIndent);

            if (f)
            {
                hres = S_OK;
                wprintf(pszSucceeded);

                input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_CURRENT;

                f = DeviceIoControl(hDevice,
                                     IOCTL_CDROM_GET_CONFIGURATION,
                                     &input,
                                     sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                     pheader,
                                     cbHeader,             
                                     &cbReturned,
                                     NULL);

                if (f)
                {
                    if (pfh->Current)
                    {
                        wprintf(TEXT("Feature currently ON\n"));
                    }
                    else
                    {
                        wprintf(TEXT("Feature currently OFF\n"));
                    }
                }
            }
            else
            {
                wprintf(pszFailed);
            }

            CloseHandle(hDevice);
        }
        else
        {
            _PrintIndent(cchIndent);
            wprintf(TEXT("Cannot open device\n"));
            _PrintGetLastError(cchIndent);
            hres = E_DF_CANNOTOPENDEVICE;
        }
    }

    return hres;
}

_sFLAG_DESCR _featurenumberFD[] =
{
    FLAG_DESCR(FeatureProfileList),
    FLAG_DESCR(FeatureCore),
    FLAG_DESCR(FeatureMorphing),
    FLAG_DESCR(FeatureRemovableMedium),
    FLAG_DESCR(FeatureRandomReadable),
    FLAG_DESCR(FeatureMultiRead),
    FLAG_DESCR(FeatureCdRead),
    FLAG_DESCR(FeatureDvdRead),
    FLAG_DESCR(FeatureRandomWritable),
    FLAG_DESCR(FeatureIncrementalStreamingWritable),
    FLAG_DESCR(FeatureSectorErasable),
    FLAG_DESCR(FeatureFormattable),
    FLAG_DESCR(FeatureDefectManagement),
    FLAG_DESCR(FeatureWriteOnce),
    FLAG_DESCR(FeatureRestrictedOverwrite),
    FLAG_DESCR(FeatureWriteProtect),
    FLAG_DESCR(FeatureCdrwCAVWrite),
    FLAG_DESCR(FeatureRigidRestrictedOverwrite),
    FLAG_DESCR(FeatureCdTrackAtOnce),
    FLAG_DESCR(FeatureCdMastering),
    FLAG_DESCR(FeatureDvdRecordableWrite),
    FLAG_DESCR(FeaturePowerManagement),
    FLAG_DESCR(FeatureSMART),
    FLAG_DESCR(FeatureEmbeddedChanger),
    FLAG_DESCR(FeatureCDAudioAnalogPlay),
    FLAG_DESCR(FeatureMicrocodeUpgrade),
    FLAG_DESCR(FeatureTimeout),
    FLAG_DESCR(FeatureDvdCSS),
    FLAG_DESCR(FeatureRealTimeStreaming),
    FLAG_DESCR(FeatureLogicalUnitSerialNumber),
    FLAG_DESCR(FeatureDiscControlBlocks),
    FLAG_DESCR(FeatureDvdCPRM),
};
///////////////////////////////////////////////////////////////////////////////
// IOCTL_CDROM_GET_CONFIGURATION
HRESULT _IOCTLCDROMGetConfigListAll(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD cbReturned;

        GET_CONFIGURATION_IOCTL_INPUT input;
        DWORD cbHeader = sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_HEADER);
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)LocalAlloc(LPTR, 
            cbHeader);

        if (pheader)
        {
            FEATURE_HEADER* pfh;

            input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
            input.Reserved[0] = NULL;
            input.Reserved[1] = NULL;

            _PrintIndent(cchIndent);
            wprintf(TEXT("Supported features (* = Current):\n\n"));

            for (DWORD dw = 0; dw < ARRAYSIZE(_featurenumberFD); ++dw)
            {
                input.Feature = (FEATURE_NUMBER)(_featurenumberFD[dw].dwFlag);

                BOOL f = DeviceIoControl(hDevice,
                                     IOCTL_CDROM_GET_CONFIGURATION,
                                     &input,
                                     sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                     pheader,
                                     cbHeader,             
                                     &cbReturned,
                                     NULL);


                pfh = (FEATURE_HEADER*)(pheader->Data);

                if (f)
                {
                    WORD w = (pfh->FeatureCode[0]) << 8 | (pfh->FeatureCode[1]);

                    if (w == (WORD)(_featurenumberFD[dw].dwFlag))
                    {
                        _PrintIndent(cchIndent +2);

                        if (pfh->Current)
                        {
                            wprintf(TEXT("* "));
                        }
                        else
                        {
                            wprintf(TEXT("  "));
                        }

                        _PrintFlag(_featurenumberFD[dw].dwFlag, _featurenumberFD, ARRAYSIZE(_featurenumberFD),
                            0, FALSE, FALSE, FALSE, FALSE);

                        _PrintCR();
                    }

                    hres = S_OK;
                }
            }

            CloseHandle(hDevice);
        }
        else
        {
            _PrintIndent(cchIndent);
            wprintf(TEXT("Cannot open device\n"));
            _PrintGetLastError(cchIndent);
            hres = E_DF_CANNOTOPENDEVICE;
        }
    }

    return hres;
}
///////////////////////////////////////////////////////////////////////////////
// IOCTL_STORAGE_CHECK_VERIFY
HRESULT _IOCTLCheckVerify(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;

        SetLastError(0);

        BOOL b = DeviceIoControl(hDevice,
            IOCTL_STORAGE_CHECK_VERIFY, // dwIoControlCode operation to perform
            NULL,                        // lpInBuffer; must be NULL
            0,                           // nInBufferSize; must be zero
            NULL,        // pointer to output buffer
            0,      // size of output buffer
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        _PrintIndent(cchIndent);
        wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
            TEXT("IOCTL_STORAGE_CHECK_VERIFY;\n")));
    
        _PrintElapsedTime(cchIndent, TRUE);

        _PrintIndent(cchIndent);
        wprintf(TEXT("Accessible: "));

        hres = S_OK;

        if (b)
        {
            wprintf(TEXT("Y\n"));
        }
        else
        {
            if (ERROR_NOT_READY == GetLastError())
            {
                wprintf(TEXT("N\n"));
            }
            else
            {
                _PrintGetLastError(cchIndent);
                hres = E_FAIL;
            }
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_STORAGE_GET_DEVICE_NUMBER
_sFLAG_DESCR _devicetypeFD[] =
{
    FLAG_DESCR(FILE_DEVICE_BEEP),
    FLAG_DESCR(FILE_DEVICE_CD_ROM),
    FLAG_DESCR(FILE_DEVICE_CD_ROM_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_CONTROLLER),
    FLAG_DESCR(FILE_DEVICE_DATALINK),
    FLAG_DESCR(FILE_DEVICE_DFS),
    FLAG_DESCR(FILE_DEVICE_DISK),
    FLAG_DESCR(FILE_DEVICE_DISK_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_INPORT_PORT),
    FLAG_DESCR(FILE_DEVICE_KEYBOARD),
    FLAG_DESCR(FILE_DEVICE_MAILSLOT),
    FLAG_DESCR(FILE_DEVICE_MIDI_IN),
    FLAG_DESCR(FILE_DEVICE_MIDI_OUT),
    FLAG_DESCR(FILE_DEVICE_MOUSE),
    FLAG_DESCR(FILE_DEVICE_MULTI_UNC_PROVIDER),
    FLAG_DESCR(FILE_DEVICE_NAMED_PIPE),
    FLAG_DESCR(FILE_DEVICE_NETWORK),
    FLAG_DESCR(FILE_DEVICE_NETWORK_BROWSER),
    FLAG_DESCR(FILE_DEVICE_NETWORK_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_NULL),
    FLAG_DESCR(FILE_DEVICE_PARALLEL_PORT),
    FLAG_DESCR(FILE_DEVICE_PHYSICAL_NETCARD),
    FLAG_DESCR(FILE_DEVICE_PRINTER),
    FLAG_DESCR(FILE_DEVICE_SCANNER),
    FLAG_DESCR(FILE_DEVICE_SERIAL_MOUSE_PORT),
    FLAG_DESCR(FILE_DEVICE_SERIAL_PORT),
    FLAG_DESCR(FILE_DEVICE_SCREEN),
    FLAG_DESCR(FILE_DEVICE_SOUND),
    FLAG_DESCR(FILE_DEVICE_STREAMS),
    FLAG_DESCR(FILE_DEVICE_TAPE),
    FLAG_DESCR(FILE_DEVICE_TAPE_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_TRANSPORT),
    FLAG_DESCR(FILE_DEVICE_UNKNOWN),
    FLAG_DESCR(FILE_DEVICE_VIDEO),
    FLAG_DESCR(FILE_DEVICE_VIRTUAL_DISK),
    FLAG_DESCR(FILE_DEVICE_WAVE_IN),
    FLAG_DESCR(FILE_DEVICE_WAVE_OUT),
    FLAG_DESCR(FILE_DEVICE_8042_PORT),
    FLAG_DESCR(FILE_DEVICE_NETWORK_REDIRECTOR),
    FLAG_DESCR(FILE_DEVICE_BATTERY),
    FLAG_DESCR(FILE_DEVICE_BUS_EXTENDER),
    FLAG_DESCR(FILE_DEVICE_MODEM),
    FLAG_DESCR(FILE_DEVICE_VDM),
    FLAG_DESCR(FILE_DEVICE_MASS_STORAGE),
    FLAG_DESCR(FILE_DEVICE_SMB),
    FLAG_DESCR(FILE_DEVICE_KS),
    FLAG_DESCR(FILE_DEVICE_CHANGER),
    FLAG_DESCR(FILE_DEVICE_SMARTCARD),
    FLAG_DESCR(FILE_DEVICE_ACPI),
    FLAG_DESCR(FILE_DEVICE_DVD),
    FLAG_DESCR(FILE_DEVICE_FULLSCREEN_VIDEO),
    FLAG_DESCR(FILE_DEVICE_DFS_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_DFS_VOLUME),
    FLAG_DESCR(FILE_DEVICE_SERENUM),
    FLAG_DESCR(FILE_DEVICE_TERMSRV),
    FLAG_DESCR(FILE_DEVICE_KSEC),
};

int _PrintDeviceNumberReport(DWORD dwFlags[], DWORD cchIndent, 
    STORAGE_DEVICE_NUMBER* psdn)
{
    int i = 0;

    // for now let's assume raw

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
        TEXT("IOCTL_STORAGE_GET_DEVICE_NUMBER;\n")));

    _PrintElapsedTime(cchIndent, TRUE);

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("STORAGE_DEVICE_NUMBER\n"));

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("{\n"));

    i += _PrintFlag(psdn->DeviceType, _devicetypeFD, ARRAYSIZE(_devicetypeFD),
        cchIndent + 2, TRUE, TRUE, FALSE, FALSE);
    i += wprintf(TEXT(" (DEVICE_TYPE DeviceType)\n"));

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD DeviceNumber)\n"), psdn->DeviceNumber); 
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD PartitionNumber)\n"), psdn->PartitionNumber);
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("}\n"));

    return i;
}

HRESULT _IOCTLDeviceNumber(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, 0);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        STORAGE_DEVICE_NUMBER sdn = {0};
        DWORD dwDummy;

        BOOL b = DeviceIoControl(hDevice,
            IOCTL_STORAGE_GET_DEVICE_NUMBER, // dwIoControlCode operation to perform
            NULL,                        // lpInBuffer; must be NULL
            0,                           // nInBufferSize; must be zero
            &sdn,
            sizeof(sdn),
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        if (b)
        {
            _PrintDeviceNumberReport(dwFlags, cchIndent, &sdn);
            hres = S_OK;
        }
        else
        {
            _PrintGetLastError(cchIndent);
            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_STORAGE_MCN_CONTROL
HRESULT _IOCTLMCNControl(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, FILE_READ_ATTRIBUTES);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        STORAGE_DEVICE_NUMBER sdn = {0};
        DWORD dwDummy;

        PREVENT_MEDIA_REMOVAL mediaRemoval;
        mediaRemoval.PreventMediaRemoval = FALSE;

        BOOL b = DeviceIoControl(hDevice,
            IOCTL_STORAGE_MCN_CONTROL, // dwIoControlCode operation to perform
            &mediaRemoval,                        // lpInBuffer; must be NULL
            sizeof(mediaRemoval),                           // nInBufferSize; must be zero
            NULL,
            0,
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        if (b)
        {
            hres = S_OK;
        }
        else
        {
            _PrintGetLastError(cchIndent);
            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_DISK_IS_WRITABLE
HRESULT _IOCTLDiskWritable(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;

        SetLastError(0);

        BOOL b = DeviceIoControl(hDevice,
            IOCTL_DISK_IS_WRITABLE, // dwIoControlCode operation to perform
            NULL,                        // lpInBuffer; must be NULL
            0,                           // nInBufferSize; must be zero
            NULL,        // pointer to output buffer
            0,      // size of output buffer
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        _PrintIndent(cchIndent);
        wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
            TEXT("IOCTL_DISK_IS_WRITABLE;\n")));
    
        _PrintElapsedTime(cchIndent, TRUE);

        _PrintIndent(cchIndent);
        wprintf(TEXT("Write protected: "));

        hres = S_OK;

        // Don't check return value for nothing
        if (ERROR_WRITE_PROTECT == GetLastError())
        {
            wprintf(L"Y\n");
        }
        else
        {
            wprintf(L"N\n");
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_STORAGE_GET_MEDIA_TYPES
HRESULT _IOCTLMediaTypes(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;
        BOOL b;

        DISK_GEOMETRY dg[12] = {0};
        DWORD cb = sizeof(dg);

        DWORD dwIoCtl;

        if (_IsFlagSet(IOCTL_MEDIATYPES, dwFlags))
        {
            dwIoCtl = IOCTL_STORAGE_GET_MEDIA_TYPES;
        }
        else
        {
            dwIoCtl = IOCTL_DISK_GET_MEDIA_TYPES;
        }

        b = DeviceIoControl(hDevice,
            dwIoCtl,
            NULL,                        // lpInBuffer; must be NULL
            0,                           // nInBufferSize; must be zero
            dg,
            cb,
            &dwDummy,   // receives number of bytes returned
            NULL);

        _StopClock();

        _PrintIndent(cchIndent);
        wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
            TEXT("IOCTL_STORAGE_GET_MEDIA_TYPES;\n")));
    
        _PrintElapsedTime(cchIndent, TRUE);

        _PrintIndent(cchIndent);

        if (b)
        {
            DWORD c = dwDummy / sizeof(DISK_GEOMETRY);

            wprintf(TEXT("Media types:\n"));

            for (DWORD dw = 0; dw < c; ++dw)
            {
                _PrintMediaTypeReport(dwFlags, cchIndent + 2, dg[dw].MediaType);
                _PrintCR();
            }
        }
        else
        {
            _PrintGetLastError(cchIndent);

            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// FSCTL_GET_REPARSE_POINT
HRESULT _FSCTLGetReparsePoint(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();
    
    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ,
        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;
        BYTE buffer[1024];

        BOOL b = DeviceIoControl(hDevice, // 
                FSCTL_GET_REPARSE_POINT, //
                NULL,
                NULL,
                &buffer,
                sizeof(buffer),
                &dwDummy,
                NULL);

        _StopClock();

        _PrintElapsedTime(cchIndent, TRUE);

        _PrintIndent(cchIndent);

        if (!b)
        {
            if (ERROR_MORE_DATA == GetLastError())
            {
                // That's OK
                REPARSE_GUID_DATA_BUFFER* pb = (REPARSE_GUID_DATA_BUFFER*)&buffer;
                _PrintGUID(&(pb->ReparseGuid));
                hres = S_OK;
            }
            else
            {
                _PrintGetLastError(cchIndent);
                hres = E_FAIL;
            }
        }
        else
        {
            REPARSE_GUID_DATA_BUFFER* pb = (REPARSE_GUID_DATA_BUFFER*)&buffer;

            _PrintGUID(&(pb->ReparseGuid));
            hres = S_OK;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_DVD_READ_KEY
HRESULT _IOCTLDvd(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;
        BOOL b;
        BYTE bBuf[DVD_RPC_KEY_LENGTH];
        DWORD cbBuf = DVD_RPC_KEY_LENGTH;

        DVD_COPY_PROTECT_KEY* pdcpk = (DVD_COPY_PROTECT_KEY*)bBuf;

        ZeroMemory(pdcpk, cbBuf);

        pdcpk->KeyLength = cbBuf;
        pdcpk->KeyType = DvdGetRpcKey;

        b = DeviceIoControl(hDevice, // 
                IOCTL_DVD_READ_KEY, //
                pdcpk,
                cbBuf,
                pdcpk,
                cbBuf,
                &dwDummy,
                NULL);

        _StopClock();

        _PrintIndent(cchIndent);
        wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
            TEXT("IOCTL_DVD_READ_KEY;\n")));

        _PrintElapsedTime(cchIndent, TRUE);

        _PrintIndent(cchIndent);

        if (b)
        {
            // If succeeded, DVD drive
            wprintf(TEXT("Succeeded.\n"));

            hres = S_OK;
        }
        else
        {
            // If fail with 1 (ERROR_INVALID_FUNCTION), then it is not a DVD drive
            _PrintGetLastError(cchIndent);

            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// IOCTL_STORAGE_GET_MEDIA_TYPES_EX
_sFLAG_DESCR _devicemediatypeFD[] =
{
    FLAG_DESCR(MEDIA_ERASEABLE),
    FLAG_DESCR(MEDIA_WRITE_ONCE),
    FLAG_DESCR(MEDIA_READ_ONLY),
    FLAG_DESCR(MEDIA_READ_WRITE),
    FLAG_DESCR(MEDIA_WRITE_PROTECTED),
    FLAG_DESCR(MEDIA_CURRENTLY_MOUNTED),
};

int _PrintDeviceMediaInfoReport(DWORD dwFlags[], DWORD cchIndent,
    DEVICE_MEDIA_INFO* pdmi)
{
    int i = 0;

    // for now let's assume raw

    // BUGBUG: We use DiskInfo whatever what the disk is

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("DEVICE_MEDIA_INFO\n"));
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("{\n"));
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("0x%08X (lo), 0x%08X (hi) (LARGE_INTEGER Cylinders)\n"),
        pdmi->DeviceSpecific.DiskInfo.Cylinders.LowPart, pdmi->DeviceSpecific.DiskInfo.Cylinders.HighPart);

    i += _PrintMediaTypeReport(dwFlags, cchIndent + 2, (MEDIA_TYPE)pdmi->DeviceSpecific.DiskInfo.MediaType);
    i += wprintf(TEXT(" (MEDIA_TYPE MediaType)\n"));

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD TracksPerCylinder)\n"), pdmi->DeviceSpecific.DiskInfo.TracksPerCylinder); 
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD SectorsPerTrack)\n"), pdmi->DeviceSpecific.DiskInfo.SectorsPerTrack);
    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD BytesPerSector)\n"), pdmi->DeviceSpecific.DiskInfo.BytesPerSector);

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("%u (DWORD NumberMediaSides)\n"), pdmi->DeviceSpecific.DiskInfo.NumberMediaSides);

    _PrintIndent(cchIndent + 2);
    i += wprintf(TEXT("(DWORD MediaCharacteristics):\n"));
    i += _PrintFlag(pdmi->DeviceSpecific.DiskInfo.MediaCharacteristics, _devicemediatypeFD,
        ARRAYSIZE(_devicemediatypeFD), cchIndent + 4, TRUE, TRUE, FALSE, TRUE);

    _PrintCR();
    _PrintIndent(cchIndent);
    i += wprintf(TEXT("}\n"));

    return i;
}

HRESULT _IOCTLMediaTypesEx(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    HANDLE hDevice;

    _StartClock();

    hDevice = _GetDeviceHandle(pszArg, GENERIC_READ);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD dwDummy;
        BOOL b;
        BYTE bBuf[8192];

        b = DeviceIoControl(hDevice,
                IOCTL_STORAGE_GET_MEDIA_TYPES_EX,
                NULL,
                0,
                bBuf,
                sizeof(bBuf),
                &dwDummy,
                NULL);


        _StopClock();

        _PrintIndent(cchIndent);
        wprintf(TEXT("Oper: CreateFile + GENERIC_READ; DeviceIoControl + "\
            TEXT("IOCTL_STORAGE_GET_MEDIA_TYPES_EX;\n")));
    
        _PrintElapsedTime(cchIndent, TRUE);

        _PrintIndent(cchIndent);
        wprintf(TEXT("Media types:\n"));

        if (b)
        {
            GET_MEDIA_TYPES* pgmt = (GET_MEDIA_TYPES*)bBuf;
            DEVICE_MEDIA_INFO* pMediaInfo = pgmt->MediaInfo;
            DWORD cMediaInfo = pgmt->MediaInfoCount;

            for (DWORD dw = 0; dw < cMediaInfo; ++dw)
            {
                pMediaInfo += dw;

                _PrintDeviceMediaInfoReport(dwFlags, cchIndent, pMediaInfo);
                _PrintCR();
            }

            hres = S_OK;
        }
        else
        {
            _PrintGetLastError(cchIndent);

            hres = E_FAIL;
        }

        CloseHandle(hDevice);
    }
    else
    {
        _PrintIndent(cchIndent);
        wprintf(TEXT("Cannot open device\n"));
        _PrintGetLastError(cchIndent);
        hres = E_DF_CANNOTOPENDEVICE;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// 
typedef HRESULT (*_IOCTLHANDLER)(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

struct _sIOCtlHandler
{
    DWORD           dwFlag;
    _IOCTLHANDLER   ioctlhandler;
};

_sIOCtlHandler _ioctlhandlers[] =
{
    { IOCTL_LAYOUT, _IOCTLLayout },
    { IOCTL_GEOMETRY, _IOCTLGeometry },
    { IOCTL_PARTITION, _IOCTLPartition },
    { IOCTL_PARTITIONSURE, _IOCTLPartition },
    { IOCTL_PARTITIONGPT,  _IOCTLPartitionGPT },
    { IOCTL_MEDIAACCESSIBLE, _IOCTLCheckVerify },
    { IOCTL_DISKISWRITABLE, _IOCTLDiskWritable },
    { IOCTL_VOLUMENUMBER, _IOCTLDeviceNumber },
    { IOCTL_MEDIATYPES, _IOCTLMediaTypes },
    { IOCTL_MEDIATYPESEX, _IOCTLMediaTypesEx },
    { IOCTL_DVD, _IOCTLDvd },
    { IOCTL_EJECT, _IOCTLEject },
    { IOCTL_MCNCONTROL, _IOCTLMCNControl },
    { IOCTL_GETREPARSEPOINT, _FSCTLGetReparsePoint },
    { IOCTL_CDROMGETCONFIGMMC2, _IOCTLCDROMGetConfig },
    { IOCTL_CDROMGETCONFIGDVDRAM, _IOCTLCDROMGetConfig },
    { IOCTL_CDROMGETCONFIGRW, _IOCTLCDROMGetConfig },
    { IOCTL_CDROMGETCONFIGWO, _IOCTLCDROMGetConfig },
    { IOCTL_CDROMGETCONFIGISW, _IOCTLCDROMGetConfig },
    { IOCTL_CDROMGETCONFIGALL, _IOCTLCDROMGetConfigListAll },
};

HRESULT _ProcessIOCTL(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{   
    HRESULT hres = E_INVALIDARG;

    for (DWORD dw = 0; dw < ARRAYSIZE(_ioctlhandlers); ++dw)
    {
        if (_IsFlagSet(_ioctlhandlers[dw].dwFlag, dwFlags))
        {
            hres = (*(_ioctlhandlers[dw].ioctlhandler))(dwFlags, pszArg,
                cchIndent);
        }
    }

    return hres;
}

/*
   driveLayout->PartitionCount = MAX_PARTITIONS;
        driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                          (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));
        driveLayout->Signature = 2196277081;

        bytesPerTrack = diskGeometry.SectorsPerTrack *
                        diskGeometry.BytesPerSector;

        bytesPerCylinder = diskGeometry.TracksPerCylinder *
                           bytesPerTrack;


        partInfo = &driveLayout->PartitionEntry[0];
        partLength.QuadPart = bytesPerCylinder * diskGeometry.Cylinders.QuadPart;

        //
        // The partition offset is 1 track (in bytes).
        // Size is media_size - offset, rounded down to cylinder boundary.
        //
        partOffset.QuadPart = bytesPerTrack;
        partSize.QuadPart = partLength.QuadPart - partOffset.QuadPart;

        modulo.QuadPart = (partOffset.QuadPart + partSize.QuadPart) %
                          bytesPerCylinder;
        partSize.QuadPart -= modulo.QuadPart;

        partInfo = driveLayout->PartitionEntry;

        //
        // Initialize first partition entry.
        //
        partInfo->RewritePartition = TRUE;
        partInfo->PartitionType = PARTITION_IFS;
        partInfo->BootIndicator = FALSE;
        partInfo->StartingOffset.QuadPart = partOffset.QuadPart;
        partInfo->PartitionLength.QuadPart = partSize.QuadPart;
        partInfo->HiddenSectors = 0;
        partInfo->PartitionNumber = 1;

        //
        // For now the remaining partition entries are unused.
        //
        for ( index = 1; index < driveLayout->PartitionCount; index++ ) {
            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->PartitionType = PARTITION_ENTRY_UNUSED;
            partInfo->RewritePartition = TRUE;
            partInfo->BootIndicator = FALSE;
            partInfo->StartingOffset.QuadPart = 0;
            partInfo->PartitionLength.QuadPart = 0;
            partInfo->HiddenSectors = 0;
            partInfo->PartitionNumber = 0;
        }
*/

/*
++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ntddfuji.c

--

#include "getfeatures.h"

#define NTDDFUJI_VERSION 3  // the version this file is based off of


FUJI_STRING_INFO ProfileStrings[13] = {
    { ProfileInvalid,          "ProfileInvalid" },
    { ProfileNonRemovableDisk, "Non-Removable Disk" },
    { ProfileRemovableDisk,    "Removable Disk" },
    { ProfileMOErasable,       "Magneto-Optical Erasable" },
    { ProfileMOWriteOnce,      "Magneto-Optical Write-Once" },
    { ProfileAS_MO,            "AS Mageto-Optical" },
    { ProfileCdrom,            "CD-Rom" },
    { ProfileCdRecordable,     "CD Recordable" },
    { ProfileCdRewritable,     "CD Rewritable" },
    { ProfileDvdRom,           "DVD-Rom" },
    { ProfileDvdRecordable,    "DVD-Recordable" },
    { ProfileDvdRam,           "DVD-RAM" },
    { ProfileNonStandard,      "NonStandard Profile" }
};

FUJI_STRING_INFO FeatureStrings[28] = {
    { FeatureProfileList                  , "Profile List"               },
    { FeatureCore                         , "Core"                       },
    { FeatureMorphing                     , "Morphing"                   },
    { FeatureRemovableMedium              , "Removable Medium"           },
    { FeatureRandomReadable               , "Random Readable"            },
    { FeatureMultiRead                    , "MultiRead"                  },
    { FeatureCdRead                       , "CD Read"                    },
    { FeatureDvdRead                      , "DVD Read"                   },
    { FeatureRandomWritable               , "Random Writable"            },
    { FeatureIncrementalStreamingWritable , "Incremental Stream Writing" },
    { FeatureSectorErasable               , "Sector Erasable"            },
    { FeatureFormattable                  , "Formattable"                },
    { FeatureDefectManagement             , "Defect Management"          },
    { FeatureWriteOnce                    , "Write Once"                 },
    { FeatureRestrictedOverwrite          , "Restricted Overwrite"       },
    { FeatureCdTrackAtOnce                , "CD Track-At-Once"           },
    { FeatureCdMastering                  , "CD Mastering"               },
    { FeatureDvdRecordableWrite           , "DVD Recordable Writing"     },
    { FeaturePowerManagement              , "Power Management"           },
    { FeatureSMART                        , "S.M.A.R.T."                 },
    { FeatureEmbeddedChanger              , "Embedded Changer"           },
    { FeatureCDAudioAnalogPlay            , "CD Audio Analog Playback"   },
    { FeatureMicrocodeUpgrade             , "Microcode Upgrade"          },
    { FeatureTimeout                      , "Timeout"                    },
    { FeatureDvdCSS                       , "DVD CSS"                    },
    { FeatureRealTimeStreaming            , "Real-Time Streaming"        },
    { FeatureLogicalUnitSerialNumber      , "Logical Unit Serial Number" },
    { FeatureDiscControlBlocks            , "Disc Control Blocks"        }
};



FEATURE_PAGE_LIST RequiredFeaturePagesNonRemovableDisk = {
    FeatureCore,
    FeatureRandomReadable,
    FeatureRandomWritable,
    FeatureDefectManagement,
    FeaturePowerManagement,
    FeatureSMART,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesRemovableDisk = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureRandomWritable,
    FeatureFormattable,
    FeatureDefectManagement,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesMOErasable = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureRandomWritable,
    FeatureSectorErasable,
    FeatureFormattable,
    FeatureDefectManagement,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesMOWriteOnce = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureDefectManagement,
    FeatureWriteOnce,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesAS_MO = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureRandomWritable,
    FeatureFormattable,
    FeatureDefectManagement,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureRealTimeStreaming,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesCdrom = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureCdRead,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesCdRecordable = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureCdRead,
    FeatureIncrementalStreamingWritable,
    FeatureCdTrackAtOnce,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureRealTimeStreaming,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesCdRewritable = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureMultiRead,
    FeatureCdRead,
    FeatureIncrementalStreamingWritable,
    FeatureFormattable,
    FeatureRestrictedOverwrite,
    FeatureCdTrackAtOnce,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureRealTimeStreaming,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesDvdRom = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureDvdRead,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureRealTimeStreaming,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesDvdRecordable = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureDvdRead,
    FeatureIncrementalStreamingWritable,
    FeatureDvdRecordableWrite,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureRealTimeStreaming,
    FeatureLogicalUnitSerialNumber,
    FeatureProfileList
};

FEATURE_PAGE_LIST RequiredFeaturePagesDvdRam = {
    FeatureCore,
    FeatureMorphing,
    FeatureRemovableMedium,
    FeatureRandomReadable,
    FeatureDvdRead,
    FeatureRandomWritable,
    FeatureFormattable,
    FeatureDefectManagement,
    FeaturePowerManagement,
    FeatureTimeout,
    FeatureRealTimeStreaming,
    FeatureProfileList
};


FUJI_REQUIRED_FEATURE_PAGES const RequiredFeaturePages[] = {

    { ProfileNonRemovableDisk, &RequiredFeaturePagesNonRemovableDisk },
    { ProfileRemovableDisk,    &RequiredFeaturePagesRemovableDisk },
    { ProfileMOErasable,       &RequiredFeaturePagesMOErasable },
    { ProfileMOWriteOnce,      &RequiredFeaturePagesMOWriteOnce },
    { ProfileAS_MO,            &RequiredFeaturePagesAS_MO },
    { ProfileCdrom,            &RequiredFeaturePagesCdrom },
    { ProfileCdRecordable,     &RequiredFeaturePagesCdRecordable },
    { ProfileCdRewritable,     &RequiredFeaturePagesCdRewritable },
    { ProfileDvdRom,           &RequiredFeaturePagesDvdRom },
    { ProfileDvdRecordable,    &RequiredFeaturePagesDvdRecordable },
    { ProfileDvdRam,           &RequiredFeaturePagesDvdRam },

    { 0, NULL }
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfpnp.h ===
#ifndef _DFPNP_H
#define _DFPNP_H

#include <objbase.h>

HRESULT _ProcessPNP(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

#endif // _DFPNP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfstpdi.cpp ===
#include "dfstpdi.h"

#include <stdio.h>
#include <winuser.h>
#include <tchar.h>

#include "cfgmgr32.h"
#include "setupapi.h"
#include "dbt.h"

#include "drvfull.h"

#include "dfhlprs.h"

#include "shellapi.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

static GUID         g_guidIntfClass =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

static HDEVINFO     g_hdevinfo = NULL;

_sFLAG_DESCR _SPDID_FD[] =
{
    FLAG_DESCR(SPINT_ACTIVE),
    FLAG_DESCR(SPINT_DEFAULT),
    FLAG_DESCR(SPINT_REMOVED),
};

_sFLAG_DESCR _regpropFD[] =
{
    FLAG_DESCR_COMMENT(SPDRP_DEVICEDESC, TEXT("DeviceDesc (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_HARDWAREID, TEXT("HardwareID (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_COMPATIBLEIDS, TEXT("CompatibleIDs (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_SERVICE, TEXT("Service (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_CLASS, TEXT("Class (R--tied to ClassGUID)")),
    FLAG_DESCR_COMMENT(SPDRP_CLASSGUID, TEXT("ClassGUID (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_DRIVER, TEXT("Driver (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_CONFIGFLAGS, TEXT("ConfigFlags (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_MFG, TEXT("Mfg (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_FRIENDLYNAME, TEXT("FriendlyName (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_LOCATION_INFORMATION, TEXT("LocationInformation (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_PHYSICAL_DEVICE_OBJECT_NAME, TEXT("PhysicalDeviceObjectName (R)")),
    FLAG_DESCR_COMMENT(SPDRP_CAPABILITIES, TEXT("Capabilities (R)")),
    FLAG_DESCR_COMMENT(SPDRP_UI_NUMBER, TEXT("UiNumber (R)")),
    FLAG_DESCR_COMMENT(SPDRP_UPPERFILTERS, TEXT("UpperFilters (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_LOWERFILTERS, TEXT("LowerFilters (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_BUSTYPEGUID, TEXT("BusTypeGUID (R)")),
    FLAG_DESCR_COMMENT(SPDRP_LEGACYBUSTYPE, TEXT("LegacyBusType (R)")),
    FLAG_DESCR_COMMENT(SPDRP_BUSNUMBER, TEXT("BusNumber (R)")),
    FLAG_DESCR_COMMENT(SPDRP_ENUMERATOR_NAME, TEXT("Enumerator Name (R)")),
    FLAG_DESCR_COMMENT(SPDRP_SECURITY, TEXT("Security (R/W, binary form)")),
    FLAG_DESCR_COMMENT(SPDRP_SECURITY_SDS, TEXT("Security (W, SDS form)")),
    FLAG_DESCR_COMMENT(SPDRP_DEVTYPE, TEXT("Device Type (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_EXCLUSIVE, TEXT("Device is exclusive-access (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_CHARACTERISTICS, TEXT("Device Characteristics (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_ADDRESS, TEXT("Device Address (R)")),
    FLAG_DESCR_COMMENT(SPDRP_UI_NUMBER_DESC_FORMAT, TEXT("UiNumberDescFormat (R/W)")),
    FLAG_DESCR_COMMENT(SPDRP_MAXIMUM_PROPERTY, TEXT("Upper bound on ordinals")),
};

HRESULT _PrintDetailed(DWORD dwFlags[], DWORD cchIndent, HDEVINFO hdevinfo,
    SP_DEVINFO_DATA* pdevinfo, SP_DEVICE_INTERFACE_DATA* pspdid,
    SP_DEVICE_INTERFACE_DETAIL_DATA* pspdidd)
{
    HRESULT hres = S_OK;

    if (_IsFlagSet(MOD_FULLREPORT1, dwFlags))
    {
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("Registry properties (SetupDiGetDeviceRegistryProperty):\n"));
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("{\n"));

        TCHAR szTest[1024];
    
        if (SetupDiGetDeviceRegistryProperty(hdevinfo, pdevinfo,
            SPDRP_FRIENDLYNAME, NULL, (PBYTE)szTest,
            ARRAYSIZE(szTest) * sizeof(TCHAR), NULL))
        {
            _PrintIndent(cchIndent + 4);
            _tprintf(TEXT("%s ("), szTest);

            _PrintFlag(SPDRP_FRIENDLYNAME, _regpropFD, ARRAYSIZE(_regpropFD), 0,
                FALSE, FALSE, TRUE, FALSE);
            _tprintf(TEXT(")\n"));
        }

        if (SetupDiGetDeviceRegistryProperty(hdevinfo, pdevinfo,
            SPDRP_DEVICEDESC, NULL, (PBYTE)szTest,
            ARRAYSIZE(szTest) * sizeof(TCHAR), NULL))
        {
            _PrintIndent(cchIndent + 4);
            _tprintf(TEXT("%s ("), szTest);

            _PrintFlag(SPDRP_DEVICEDESC, _regpropFD, ARRAYSIZE(_regpropFD), 0,
                FALSE, FALSE, TRUE, FALSE);
            _tprintf(TEXT(")\n"));
        }
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("}\n"));
    }

    if (_IsFlagSet(MOD_FULLREPORT2, dwFlags))
    {
        _PrintCR();
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("SP_DEVICE_INTERFACE_DATA\n"));
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("{\n"));
        _PrintIndent(cchIndent + 4);
        _PrintGUID(&(pspdid->InterfaceClassGuid));
        _tprintf(TEXT(" (GUID InterfaceClassGuid)\n"));
        _PrintFlag(pspdid->Flags, _SPDID_FD, ARRAYSIZE(_SPDID_FD), cchIndent + 4,
            TRUE, TRUE, FALSE, FALSE);
        _tprintf(TEXT(" (DWORD Flags)\n"));
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("}\n"));

        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("SP_DEVINFO_DATA\n"));
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("{\n"));
        _PrintIndent(cchIndent + 4);
        _PrintGUID(&(pdevinfo->ClassGuid));
        _tprintf(TEXT(" (GUID ClassGuid)\n"));
        _PrintIndent(cchIndent + 4);
        _tprintf(TEXT("%u (DWORD DevInst)\n"), pdevinfo->DevInst);
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("}\n"));

        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("SP_DEVICE_INTERFACE_DETAIL_DATA\n"));
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("{\n"));

        DWORD cch = lstrlen(pspdidd->DevicePath);

        for (DWORD dw = 0; dw < cch; dw += 80)
        {
            TCHAR sz[81];

            if (dw && (dw < cch))
            {
                _tprintf(TEXT("...\n"));
            }

            lstrcpyn(sz, pspdidd->DevicePath + dw, ARRAYSIZE(sz));

            _PrintIndent(cchIndent + 4);
            _tprintf(sz);
        }

        _PrintIndent(cchIndent + 4);
        _tprintf(TEXT(" (TCHAR DevicePath)\n"));
        _PrintIndent(cchIndent + 2);
        _tprintf(TEXT("}\n"));
    }

    return hres;
}

extern int g_argc;
extern wchar_t** g_argv;

// drvfull -pnpcs <deviceID> <Property>

HRESULT _CustomProperty(DWORD dwFlags[], LPWSTR , DWORD cchIndent)
{
    HRESULT hr;

    HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    if (INVALID_HANDLE_VALUE != hdevinfo)
    {
        SP_DEVINFO_DATA sdd = {0};
        sdd.cbSize = sizeof(sdd);

        if ((TEXT('\\') == g_argv[2][0]) && (TEXT('\\') == g_argv[2][1]) &&
            (TEXT('?') == g_argv[2][2]) && (TEXT('\\') == g_argv[2][3]))
        {
            SP_DEVICE_INTERFACE_DATA sdid = {0};

            sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface(hdevinfo, (LPCWSTR)g_argv[2], 0, &sdid))
            {
                DWORD cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                    (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

                SP_DEVICE_INTERFACE_DETAIL_DATA* psdidd =
                    (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbsdidd);

                if (psdidd)
                {
                    psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                    // SetupDiGetDeviceInterfaceDetail (below) requires that the
                    // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                    // to the size of the fixed part of the structure, and to pass
                    // the size of the full thing as the 4th param.

                    if (SetupDiGetDeviceInterfaceDetail(hdevinfo, &sdid, psdidd,
                        cbsdidd, NULL, &sdd))
                    {
                        hr = S_OK;
                    }

                    LocalFree((HLOCAL)psdidd);
                }
            }
        }
        else
        {
            if (SetupDiOpenDeviceInfo(hdevinfo, (LPCWSTR)g_argv[2], NULL, 0, &sdd))
            {
                hr = S_OK;
            }

        }

        if (SUCCEEDED(hr))
        {
            WCHAR szTestProp[512];

            if (SetupDiGetCustomDeviceProperty(hdevinfo, &sdd,
                (LPCWSTR)g_argv[3], 0, NULL, (PBYTE)szTestProp,
                ARRAYSIZE(szTestProp), NULL))
            {
                _PrintIndent(cchIndent + 4);
                _tprintf(TEXT("%s = %s"), (LPCWSTR)g_argv[3], szTestProp);
            }
        }

        SetupDiDestroyDeviceInfoList(hdevinfo);
    }

    return hr;
}   

HRESULT _EnumDevices(DWORD dwFlags[], HDEVINFO hdevinfo,
    SP_DEVINFO_DATA* pdevinfoConstraint, CONST GUID *pguidIntfClass,
    DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    SP_DEVICE_INTERFACE_DATA            spdid = {0};
    SP_DEVICE_INTERFACE_DETAIL_DATA*    pspdidd = NULL;
    SP_DEVINFO_DATA                     devinfo = {0};
    DWORD                               cbspdidd = 0;

    devinfo.cbSize = sizeof(devinfo);
    spdid.cbSize = sizeof(spdid);

    for (DWORD dw = 0; SetupDiEnumDeviceInterfaces(hdevinfo, pdevinfoConstraint,
        pguidIntfClass, dw, &spdid); ++dw)
    {
        DWORD dwReqSize;

        hres = S_OK;

        // To retrieve the device interface name (e.g., that you can call
        // CreateFile() on...
        while (SUCCEEDED(hres) && !SetupDiGetDeviceInterfaceDetail(hdevinfo,
            &spdid, pspdidd, cbspdidd, &dwReqSize, &devinfo))
        {
            // We failed to get the device interface detail data--was it because
            // our buffer was too small? (Hopefully so!)
            DWORD dwErr = GetLastError();

            if (pspdidd)
            {
                free(pspdidd);
                pspdidd = NULL;
            }

            if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
                // We failed due to insufficient buffer.  Allocate one that's
                // sufficiently large and try again.

                pspdidd = (SP_DEVICE_INTERFACE_DETAIL_DATA*)malloc(dwReqSize);

                if (pspdidd)
                {
                    cbspdidd = dwReqSize;
                    pspdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                }
                else
                {
                    // Failure!
                    cbspdidd = 0;

                    _PrintIndent(cchIndent);
                    _tprintf(TEXT("Not enough memory\n"));

                    hres = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                // Failure!
                _PrintIndent(cchIndent);
                _tprintf(TEXT("SetupDiGetDeviceInterfaceDetail failed\n"));

                _PrintGetLastError(cchIndent);
                hres = E_FAIL;
                break;
            }
        }

        if (SUCCEEDED(hres))
        {
            if (!pdevinfoConstraint)
            {
                BOOL bResult;
                TCHAR szDeviceName[MAX_PATH];
                TCHAR szVolumeName[MAX_PATH * 2];

                lstrcpy(szDeviceName, pspdidd->DevicePath);
                lstrcat(szDeviceName, TEXT("\\"));

                bResult = GetVolumeNameForVolumeMountPoint(szDeviceName,
                    szVolumeName, MAX_PATH);

                if (bResult)
                {
                    _PrintCR();
                    _PrintIndent(cchIndent + 2);
                    _tprintf(TEXT("--------------------------------------------")\
                        TEXT("--------------------------\n"));
                    _PrintIndent(cchIndent + 2);
                    _tprintf(TEXT("-- Volume name: '%s'\n"), szVolumeName);
                }
            }

            if (_IsFlagSet(MOD_FULLREPORTFULL, dwFlags))
            {
                hres = _PrintDetailed(dwFlags, cchIndent, hdevinfo,
                    &devinfo, &spdid, pspdidd);
            }

/*            if (!pdevinfoConstraint)
            {
                GUID guidUSB = {0x36fc9e60, 0xc465, 0x11cf,
                                {0x80, 0x56, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

                hres = _EnumDevices(dwFlags, hdevinfo, &devinfo, &guidUSB,
                    cchIndent + 2);
            }*/
        }
    }

    if (pspdidd)
    {
        free(pspdidd);
    }

    return hres;
}

HRESULT _InitNotifSetupDI(DWORD dwFlags[], DWORD cchIndent)
{
    HRESULT hres = S_OK;

    // Create a device information set that will be the container for our
    // device interfaces.
    g_hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    if (INVALID_HANDLE_VALUE != g_hdevinfo)
    {
        // OK, now we can retrieve the existing list of active device
        // interfaces into the device information set we created above.
        HDEVINFO hdevinfo = SetupDiGetClassDevsEx(&g_guidIntfClass, NULL,
            NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE, g_hdevinfo, NULL,
            NULL);

        if (INVALID_HANDLE_VALUE != hdevinfo)
        {
            // If SetupDiGetClassDevsEx succeeds and it was passed in an
            // existing device information set to be used, then the HDEVINFO
            // it returns is the same as the one it was passed in.  Thus, we
            // can just use the original DeviceInfoSet handle from here on.

            // Now fill in our listbox with the current device interface list.
            hres = _EnumDevices(dwFlags, g_hdevinfo, NULL, &g_guidIntfClass,
                cchIndent);

            if (FAILED(hres))
            {
                _PrintGetLastError(cchIndent);
            }
        }
        else
        {
            _PrintIndent(cchIndent);
            _tprintf(TEXT("SetupDiGetClassDevsEx failed\n"));

            _PrintGetLastError(cchIndent);
            hres = E_FAIL;
        }
    }
    else
    {
        _PrintIndent(cchIndent);
        _tprintf(TEXT("SetupDiCreateDeviceInfoList failed\n"));

        _PrintGetLastError(cchIndent);
        hres = E_FAIL;
    }

    return hres;
}

HRESULT _CleanupSetupDI()
{
    if (g_hdevinfo)
    {
        SetupDiDestroyDeviceInfoList(g_hdevinfo);
    }

    return S_OK;
}

HRESULT _HandleNotifSetupDI(DWORD dwFlags[], DWORD cchIndent, WPARAM wParam,
    LPARAM lParam)
{
    HRESULT hres = E_FAIL;
    SP_DEVICE_INTERFACE_DATA spdid = {0};
    DEV_BROADCAST_DEVICEINTERFACE* pdbdi;

    if (DBT_DEVTYP_DEVICEINTERFACE ==
        ((DEV_BROADCAST_HDR*)lParam)->dbch_devicetype)
    {
        pdbdi = (DEV_BROADCAST_DEVICEINTERFACE*)lParam;

        if (DBT_DEVICEARRIVAL == wParam)
        {
            // Open this new device interface into our device information set.
            if (!SetupDiOpenDeviceInterface(g_hdevinfo,
                pdbdi->dbcc_name, 0, NULL))
            {
                _PrintIndent(cchIndent + 2);
                _tprintf(TEXT("SetupDiOpenDeviceInterface failed\n"));
                _PrintGetLastError(cchIndent + 2);
                _PrintCR();
            }
        }
        else
        {
            // First, locate this device interface in our device information set.
            spdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface(g_hdevinfo,
                pdbdi->dbcc_name, DIODI_NO_ADD, &spdid))
            {
                if (!SetupDiDeleteDeviceInterfaceData(g_hdevinfo,
                    &spdid))
                {
                    _PrintIndent(cchIndent + 2);
                    _tprintf(TEXT("SetupDiDeletespdid failed\n"));
                    _PrintGetLastError(cchIndent + 2);
                    _PrintCR();
                }
            }
            else
            {
                _PrintIndent(cchIndent + 2);
                _tprintf(TEXT("SetupDiOpenDeviceInterface failed\n"));
                _PrintGetLastError(cchIndent + 2);
                _PrintCR();
            }
        }
    }

    hres = _EnumDevices(dwFlags, g_hdevinfo, NULL, &g_guidIntfClass, cchIndent);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfhlprs.cpp ===
#include "dfhlprs.h"

#include <stdio.h>

static DWORD dwStartTick = 0;
static DWORD dwStopTick = 0;

int _PrintIndent(DWORD cch)
{
    // for now, stupid simple
    for (DWORD dw = 0; dw < cch; ++dw)
    {
        wprintf(TEXT(" "));
    }

    return cch;
}

int _PrintCR()
{
    return wprintf(TEXT("\n"));
}

int _PrintGUID(CONST GUID* pguid)
{
    return wprintf(L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",   
        pguid->Data1,
        pguid->Data2,
        pguid->Data3,
        pguid->Data4[0],
        pguid->Data4[1],
        pguid->Data4[2],
        pguid->Data4[3],
        pguid->Data4[4],
        pguid->Data4[5],
        pguid->Data4[6],
        pguid->Data4[7]); 
}

int _PrintGUIDEx(CONST GUID* pguid, _sGUID_DESCR rgguid[], DWORD cguid,
    BOOL fPrintValue, DWORD cchIndent)
{
    BOOL fFoundIt = FALSE;

    int i = _PrintIndent(cchIndent);

    for (DWORD dw = 0; dw < cguid; ++dw)
    {
        if (*(rgguid[dw].pguid) == *pguid)
        {
            i += wprintf(TEXT("%s"), rgguid[dw].pszDescr);

            fFoundIt = TRUE;
            break;
        }
    }

    if (fPrintValue)
    {
        if (fFoundIt)
        {
            i += wprintf(TEXT(", "));
        }

        i += _PrintGUID(pguid);
    }

    return i;    
}

int _PrintGetLastError(DWORD cchIndent)
{
    int i = _PrintIndent(cchIndent);

    i += wprintf(TEXT("GetLastError: 0x%08X"), GetLastError());

    return i;
}

void _StartClock()
{
    dwStartTick = GetTickCount();
}

void _StopClock()
{
    dwStopTick = GetTickCount();
}

int _PrintElapsedTime(DWORD cchIndent, BOOL fCarriageReturn)
{
    int i = _PrintIndent(cchIndent);

    // consider wrap
    DWORD dwDiff = dwStopTick - dwStartTick;
    
    DWORD dwSec = dwDiff / 1000;

    DWORD dwMill = dwDiff % 1000;

    i += wprintf(TEXT("Elapsed time: %01d.%03d"), dwSec, dwMill);

    if (fCarriageReturn)
    {
        wprintf(TEXT("\n"));
    }

    return i;
}

int _PrintFlag(DWORD dwFlag, _sFLAG_DESCR rgflag[], DWORD cflag,
    DWORD cchIndent, BOOL fPrintValue, BOOL fHex, BOOL fComment, BOOL fORed)
{
    int i = 0;
    BOOL fAtLeastOne = FALSE;

    for (DWORD dw = 0; dw < cflag; ++dw)
    {
        BOOL fPrint = FALSE;

        if (fORed)
        {
            if (rgflag[dw].dwFlag & dwFlag)
            {
                fPrint = TRUE;
            }
        }
        else
        {
            if (rgflag[dw].dwFlag == dwFlag)
            {
                fPrint = TRUE;
            }
        }

        if (fPrint)
        {
            if (fAtLeastOne)
            {
                i += wprintf(TEXT("\n"));
            }

            i += _PrintIndent(cchIndent);

            if (fPrintValue)
            {
                if (fHex)
                {
                    i += wprintf(TEXT("0x%08X, "), rgflag[dw].dwFlag);
                }
                else
                {
                    i += wprintf(TEXT("%u, "), rgflag[dw].dwFlag);
                }
            }

            i += wprintf(TEXT("%s"), rgflag[dw].pszDescr);

            if (fComment)
            {
                i += wprintf(TEXT(", '%s'"), rgflag[dw].pszComment);
            }

            fAtLeastOne = TRUE;
        }
    }

    return i;
}

HANDLE _GetDeviceHandle(LPTSTR psz, DWORD dwDesiredAccess, DWORD dwFileAttributes)
{
    HANDLE hDevice = CreateFile(psz, // drive to open
                           dwDesiredAccess,       // don't need any access to the drive
                           FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
                           NULL,    // default security attributes
                           OPEN_EXISTING,  // disposition
                           dwFileAttributes,       // file attributes
                           NULL);   // don't copy any file's attributes
    
    return hDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfpnp.cpp ===
#include "dfpnp.h"

#include <stdio.h>
#include <winuser.h>
#include <tchar.h>
#include <initguid.h>
#include <ioevent.h>

#include <winioctl.h>

#include "cfgmgr32.h"
#include "setupapi.h"
#include "dbt.h"
#include "dfstpdi.h"
#include "drvfull.h"

#include "dfhlprs.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

static HDEVNOTIFY   g_hdevnotify = NULL;

static DWORD        g_cchIndent = 0;
static DWORD        g_dwFlags[MAX_FLAGS] = {0};
static DWORD        g_dwEvent = 0;

static GUID         g_guidVolume =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

static GUID         g_guidUSB =
    {0x36fc9e60, 0xc465, 0x11cf,
    {0x80, 0x56, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

static GUID         g_guidIntfClass =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

static GUID         g_guid1 =
{0x7373654aL, 0x812a, 0x11d0, {0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f}};
static GUID         g_guid2 =
{0xd16a55e8L, 0x1059, 0x11d2, {0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32}};
static GUID         g_guid3 =
{0xe3c5b178L, 0x105d, 0x11d2, {0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32}};
static GUID         g_guid4 =
{0xb5804878L, 0x1a96, 0x11d2, {0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32}};
static GUID         g_guid5 =
{0x50708874L, 0xc9af, 0x11d1, {0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32}};
static GUID         g_guid6 =
{0xae2eed10L, 0x0ba8, 0x11d2, {0x8f, 0xfb, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32}};
static GUID         g_guid7 =
{0x9a8c3d68L, 0xd0cb, 0x11d1, {0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32}};
static GUID         g_guid8 =
{0x2de97f83, 0x4c06, 0x11d2, {0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a}};
static GUID         g_guid9 =
{0x2de97f84, 0x4c06, 0x11d2, {0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a}};
static GUID         g_guid10 =
{0x53f5630d, 0xb6bf, 0x11d0, {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};
static GUID         g_guid11 =
{0xd07433c0, 0xa98e, 0x11d2, {0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}};
static GUID         g_guid12 =
{0xd07433c1, 0xa98e, 0x11d2, {0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}};
static GUID         g_guid13 =
{0xd0744792, 0xa98e, 0x11d2, {0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}};

_sGUID_DESCR _rgintfguidGD2[] =
{
    GUID_DESCR(&g_guid1, TEXT("GUID_IO_VOLUME_CHANGE")),
    GUID_DESCR(&g_guid2, TEXT("GUID_IO_VOLUME_DISMOUNT")),
    GUID_DESCR(&g_guid3, TEXT("GUID_IO_VOLUME_DISMOUNT_FAILED")),
    GUID_DESCR(&g_guid4, TEXT("GUID_IO_VOLUME_MOUNT")),
    GUID_DESCR(&g_guid5, TEXT("GUID_IO_VOLUME_LOCK")),
    GUID_DESCR(&g_guid6, TEXT("GUID_IO_VOLUME_LOCK_FAILED")),
    GUID_DESCR(&g_guid7, TEXT("GUID_IO_VOLUME_UNLOCK")),
    GUID_DESCR(&g_guid8, TEXT("GUID_IO_VOLUME_NAME_CHANGE")),
    GUID_DESCR(&g_guid9, TEXT("GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE")),
    GUID_DESCR(&g_guid10, TEXT("GUID_IO_VOLUME_DEVICE_INTERFACE")),
    GUID_DESCR(&g_guid11, TEXT("GUID_IO_MEDIA_ARRIVAL")),
    GUID_DESCR(&g_guid12, TEXT("GUID_IO_MEDIA_REMOVAL")),
    GUID_DESCR(&g_guid13, TEXT("GUID_DEVICE_EVENT_RBC")),
};

LRESULT _FakeWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT _Cleanup(DWORD dwFlags[])
{
    if (g_hdevnotify)
    {
        UnregisterDeviceNotification(g_hdevnotify);
    }

    if (_IsFlagSet(PNP_WATCHSETUPDI, dwFlags))
    {
        _CleanupSetupDI();
    }

    return S_OK;
}

HRESULT _InitNotif(DWORD dwFlags[], HWND hwnd, LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;

    if (_IsFlagSet(PNP_WATCHSETUPDI, dwFlags))
    {
        DEV_BROADCAST_DEVICEINTERFACE dbdNotifFilter = {0};

        // Now register to begin receiving notifications for the comings
        // and goings of device interfaces which are members of the
        // interface class whose GUID was passed in as the lParam to this
        // dialog procedure.
        dbdNotifFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        dbdNotifFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;

        CopyMemory(&(dbdNotifFilter.dbcc_classguid), &g_guidIntfClass,
            sizeof(g_guidIntfClass));

        g_hdevnotify = RegisterDeviceNotification(hwnd, &dbdNotifFilter,
            DEVICE_NOTIFY_WINDOW_HANDLE);

        if (g_hdevnotify)
        {
            if (_IsFlagSet(PNP_WATCHSETUPDI, dwFlags))
            {
                hres = _InitNotifSetupDI(dwFlags, cchIndent);

                if (FAILED(hres))
                {
                    _Cleanup(dwFlags);
                }
            }
            else
            {
                hres = E_NOTIMPL;
            }
        }
        else
        {
            _PrintIndent(cchIndent);
            _tprintf(TEXT("RegisterDeviceNotification failed\n"));

            _PrintGetLastError(cchIndent);
            hres = E_FAIL;
        }
    }
    else
    {
        if (_IsFlagSet(PNP_HANDLE, dwFlags))
        {
            HANDLE hVol = CreateFile(
                pszArg,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

            if (INVALID_HANDLE_VALUE != hVol)
            {
                DEV_BROADCAST_HANDLE dbhNotifFilter = {0};
                dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
                dbhNotifFilter.dbch_handle = hVol;

                g_hdevnotify = RegisterDeviceNotification(hwnd, &dbhNotifFilter,
                    DEVICE_NOTIFY_WINDOW_HANDLE);
    
                if (g_hdevnotify)
                {
                    _PrintIndent(cchIndent);
                    _tprintf(TEXT("RegisterDeviceNotification SUCCEEDED: %s -> 0x%08X\n"),
                        pszArg, g_hdevnotify);
                }
                else
                {
                    _PrintIndent(cchIndent);
                    _tprintf(TEXT("RegisterDeviceNotification failed\n"));

                    _PrintGetLastError(cchIndent);
                    hres = E_FAIL;
                }

                CloseHandle(hVol);
            }
            else
            {
                _PrintIndent(cchIndent);
                _tprintf(TEXT("Cannot open volume\n"));

                _PrintGetLastError(cchIndent);
                hres = E_FAIL;
            }
        }
        else
        {
            if (_IsFlagSet(PNP_EJECTBUTTON, dwFlags))
            {
                HANDLE hVol = CreateFile(
                    pszArg,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

                if (INVALID_HANDLE_VALUE != hVol)
                {
                    DWORD dwDummy;
                    PREVENT_MEDIA_REMOVAL pmr = {0};

                    pmr.PreventMediaRemoval = TRUE;
                    
                    BOOL f = DeviceIoControl(hVol,
                        IOCTL_STORAGE_MEDIA_REMOVAL, // dwIoControlCode operation to perform
                        &pmr,                        // lpInBuffer; must be NULL
                        sizeof(pmr),                           // nInBufferSize; must be zero
                        NULL,        // pointer to output buffer
                        0,      // size of output buffer
                        &dwDummy,   // receives number of bytes returned
                        NULL);

                    if (f)
                    {
                        // Register for notification
                        DEV_BROADCAST_HANDLE dbhNotifFilter = {0};
                        dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                        dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
                        dbhNotifFilter.dbch_handle = hVol;

                        g_hdevnotify = RegisterDeviceNotification(hwnd, &dbhNotifFilter,
                            DEVICE_NOTIFY_WINDOW_HANDLE);
    
                        if (g_hdevnotify)
                        {
                            _PrintIndent(cchIndent);
                            _tprintf(TEXT("RegisterDeviceNotification SUCCEEDED: %s -> 0x%08X\n"),
                                pszArg, g_hdevnotify);
                        }
                        else
                        {
                            _PrintIndent(cchIndent);
                            _tprintf(TEXT("RegisterDeviceNotification failed\n"));

                            _PrintGetLastError(cchIndent);
                            hres = E_FAIL;
                        }
                    }
                    else
                    {
                        _PrintIndent(cchIndent);
                        _tprintf(TEXT("Could not lock the volume, GLE = 0x%08X\n"), GetLastError());
                    }

                    CloseHandle(hVol);
                }
                else
                {
                    _PrintIndent(cchIndent);
                    _tprintf(TEXT("Cannot open volume\n"));

                    _PrintGetLastError(cchIndent);
                    hres = E_FAIL;
                }
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //

    return hres;
}

_sFLAG_DESCR _dbtdevtypeFD[] =
{
    FLAG_DESCR(DBT_DEVTYP_OEM),
    FLAG_DESCR(DBT_DEVTYP_DEVNODE),
    FLAG_DESCR(DBT_DEVTYP_VOLUME),
    FLAG_DESCR(DBT_DEVTYP_PORT),
    FLAG_DESCR(DBT_DEVTYP_NET),
    FLAG_DESCR(DBT_DEVTYP_DEVICEINTERFACE),
    FLAG_DESCR(DBT_DEVTYP_HANDLE),
};

_sFLAG_DESCR _dbteventFD[] =
{
    FLAG_DESCR(DBT_APPYBEGIN),
    FLAG_DESCR(DBT_APPYEND),
    FLAG_DESCR(DBT_DEVNODES_CHANGED),
    FLAG_DESCR(DBT_QUERYCHANGECONFIG),
    FLAG_DESCR(DBT_CONFIGCHANGED),
    FLAG_DESCR(DBT_CONFIGCHANGECANCELED),
    FLAG_DESCR(DBT_MONITORCHANGE),
    FLAG_DESCR(DBT_SHELLLOGGEDON),
    FLAG_DESCR(DBT_CONFIGMGAPI32),
    FLAG_DESCR(DBT_VXDINITCOMPLETE),
    FLAG_DESCR(DBT_VOLLOCKQUERYLOCK),
    FLAG_DESCR(DBT_VOLLOCKLOCKTAKEN),
    FLAG_DESCR(DBT_VOLLOCKLOCKFAILED),
    FLAG_DESCR(DBT_VOLLOCKQUERYUNLOCK),
    FLAG_DESCR(DBT_VOLLOCKLOCKRELEASED),
    FLAG_DESCR(DBT_VOLLOCKUNLOCKFAILED),
    FLAG_DESCR(DBT_NO_DISK_SPACE),
    FLAG_DESCR(DBT_LOW_DISK_SPACE),
    FLAG_DESCR(DBT_CONFIGMGPRIVATE),
    FLAG_DESCR(DBT_DEVICEARRIVAL),
    FLAG_DESCR(DBT_DEVICEQUERYREMOVE),
    FLAG_DESCR(DBT_DEVICEQUERYREMOVEFAILED),
    FLAG_DESCR(DBT_DEVICEREMOVEPENDING),
    FLAG_DESCR(DBT_DEVICEREMOVECOMPLETE),
    FLAG_DESCR(DBT_DEVICETYPESPECIFIC),
    FLAG_DESCR(DBT_CUSTOMEVENT),
    FLAG_DESCR(DBT_DEVTYP_OEM),
    FLAG_DESCR(DBT_DEVTYP_DEVNODE),
    FLAG_DESCR(DBT_DEVTYP_VOLUME),
    FLAG_DESCR(DBT_DEVTYP_PORT),
    FLAG_DESCR(DBT_DEVTYP_NET),
    FLAG_DESCR(DBT_DEVTYP_DEVICEINTERFACE),
    FLAG_DESCR(DBT_DEVTYP_HANDLE),
    FLAG_DESCR(DBT_VPOWERDAPI),
    FLAG_DESCR(DBT_USERDEFINED),
};

HRESULT _HandleNotif(DWORD dwFlags[], DWORD cchIndent, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = E_NOTIMPL;

    if (_IsFlagSet(PNP_WATCHSETUPDI, dwFlags))
    {
        hres = _HandleNotifSetupDI(dwFlags, cchIndent, wParam, lParam);
    }

    return hres;
}

_sGUID_DESCR _rgintfguidGD[] =
{
    GUID_DESCR(&g_guidVolume, TEXT("Volume Device")),
};

LRESULT _FakeWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes;
    BOOL fProcessed = FALSE;

    switch (uMsg)
    {
        case WM_DEVICECHANGE:
            fProcessed = TRUE;

            _PrintIndent(g_cchIndent + 2);
            _tprintf(TEXT("Received WM_DEVICECHANGE:\n"));
            _PrintIndent(g_cchIndent + 4);
            _tprintf(TEXT("wParam: "));

            _PrintFlag((DWORD) wParam, _dbteventFD, ARRAYSIZE(_dbteventFD), 0, TRUE,
                TRUE, FALSE, FALSE);
            _PrintCR();

            _PrintIndent(g_cchIndent + 4);
            _tprintf(TEXT("lParam: "));
            
            if (lParam)
            {
                _PrintFlag((((DEV_BROADCAST_HDR*)lParam)->dbch_devicetype),
                    _dbtdevtypeFD, ARRAYSIZE(_dbtdevtypeFD), 0, TRUE, TRUE,
                    FALSE, FALSE);
                _PrintCR();

                _PrintIndent(g_cchIndent + 6);
                _tprintf(TEXT("dbch_size: %u"),
                    (((DEV_BROADCAST_HDR*)lParam)->dbch_size));
                _PrintCR();

                if (DBT_DEVTYP_DEVICEINTERFACE ==
                    ((DEV_BROADCAST_HDR*)lParam)->dbch_devicetype)
                {
                    _PrintIndent(g_cchIndent + 6);
                    _tprintf(TEXT("Interface: "));

                    _PrintGUIDEx(&(((DEV_BROADCAST_DEVICEINTERFACE*)lParam)->dbcc_classguid),
                        _rgintfguidGD, ARRAYSIZE(_rgintfguidGD), TRUE, 0);
                }
                else
                {
                    if (DBT_DEVTYP_HANDLE == ((DEV_BROADCAST_HDR*)lParam)->dbch_devicetype)
                    {
                        _PrintIndent(g_cchIndent + 6);
                        _tprintf(TEXT("dbch_hdevnotify: 0x%08X\n"),
                            ((DEV_BROADCAST_HANDLE*)lParam)->dbch_hdevnotify);

                        _PrintIndent(g_cchIndent + 6);
                        _tprintf(TEXT("Handle notif: "));

                        _PrintGUIDEx(&(((DEV_BROADCAST_HANDLE*)lParam)->dbch_eventguid),
                            _rgintfguidGD2, ARRAYSIZE(_rgintfguidGD2), TRUE, 0);
                    }
                }

                _HandleNotif(g_dwFlags, g_cchIndent + 4, wParam, lParam);
            }
            else
            {
                _tprintf(TEXT("NULL\n"));
            }


            lRes = TRUE;
            ++g_dwEvent;
            _PrintCR();
            _PrintIndent(g_cchIndent);
            _tprintf(TEXT("== (%d) Waiting for events ======================================\n"), g_dwEvent);

            break;

        case WM_DESTROY:

            _Cleanup(g_dwFlags);
            fProcessed = FALSE;
            break;

        default:

            fProcessed = FALSE;
            break;

    }

    if (!fProcessed)
    {
        lRes = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return lRes;
}

HRESULT _ProcessPNP(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = E_FAIL;
    WNDCLASSEX wndclass;
    HINSTANCE hinst = GetModuleHandle(NULL);

    g_cchIndent = cchIndent;

    for (DWORD dw = 0; dw < MAX_FLAGS; ++dw)
    {
        g_dwFlags[dw] = dwFlags[dw];
    }

    if (hinst)
    {
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = NULL;
        wndclass.lpfnWndProc   = _FakeWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = hinst;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = TEXT("FakeWnd");
        wndclass.hIconSm       = NULL;

        if (RegisterClassEx(&wndclass))
        {
            HWND hwnd = CreateWindow(TEXT("FakeWnd"), TEXT("FakeWnd"),
                WS_POPUPWINDOW, 0, 0, 100, 200, NULL, NULL, hinst, NULL);

            if (hwnd)
            {
                hres = _InitNotif(dwFlags, hwnd, pszArg, cchIndent);

                if (SUCCEEDED(hres))
                {
                    MSG msg;

                    _PrintCR();
                    _PrintIndent(cchIndent);
                    _tprintf(TEXT("== (%d) Waiting for events ======================================\n"), g_dwEvent);

                    while (GetMessage(&msg, NULL, 0, 0))
                    {
                        DispatchMessage(&msg) ;
                    }
                }
            }
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
/*Volume         {53f5630d-b6bf-11d0-94f2-00a0c91efb8b}

Mounted device {53f5630d-b6bf-11d0-94f2-00a0c91efb8b}

in \NT\public\sdk\inc\mountmgr.h:

//
// Devices that wish to be mounted should report this GUID in
// IoRegisterDeviceInterface.
//

DEFINE_GUID(MOUNTDEV_MOUNTED_DEVICE_GUID, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfuser.h ===
#ifndef _DFUSER_H
#define _DFUSER_H

#include <objbase.h>

HRESULT _ProcessUser(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

#endif // _DFUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfstpdi.h ===
#ifndef _DFSTPDI_H
#define _DFSTPDI_H

#include <objbase.h>

HRESULT _InitNotifSetupDI(DWORD dwFlags[], DWORD cchIndent);
HRESULT _CleanupSetupDI();
HRESULT _HandleNotifSetupDI(DWORD dwFlags[], DWORD cchIndent, WPARAM wParam,
    LPARAM lParam);

HRESULT _CustomProperty(DWORD dwFlags[], LPWSTR pszDeviceIntfID, DWORD cchIndent);

#endif // _DFSTPDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfwnet.cpp ===
#include "dfuser.h"

#include <stdio.h>

#include "dferr.h"
#include "dfhlprs.h"
#include "drvfull.h"

#include <winnetwk.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

_sFLAG_DESCR _scopeFD[] =
{
    FLAG_DESCR(RESOURCE_CONNECTED ),
    FLAG_DESCR(RESOURCE_GLOBALNET ),
    FLAG_DESCR(RESOURCE_REMEMBERED),
    FLAG_DESCR(RESOURCE_RECENT    ),
    FLAG_DESCR(RESOURCE_CONTEXT   ),
};

_sFLAG_DESCR _typeFD[] =
{
    FLAG_DESCR(RESOURCETYPE_ANY      ),
    FLAG_DESCR(RESOURCETYPE_DISK     ),
    FLAG_DESCR(RESOURCETYPE_PRINT    ),
    FLAG_DESCR(RESOURCETYPE_RESERVED ),
    FLAG_DESCR(RESOURCETYPE_UNKNOWN  ),
};

_sFLAG_DESCR _usageFD[] =
{
    FLAG_DESCR(RESOURCEUSAGE_CONNECTABLE   ),
    FLAG_DESCR(RESOURCEUSAGE_CONTAINER     ),
    FLAG_DESCR(RESOURCEUSAGE_NOLOCALDEVICE ),
    FLAG_DESCR(RESOURCEUSAGE_SIBLING       ),
    FLAG_DESCR(RESOURCEUSAGE_ATTACHED      ),
    FLAG_DESCR(RESOURCEUSAGE_RESERVED      ),
};

_sFLAG_DESCR _displaytypeFD[] =
{
    FLAG_DESCR(RESOURCEDISPLAYTYPE_GENERIC      ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_DOMAIN       ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_SERVER       ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_SHARE        ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_FILE         ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_GROUP        ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_NETWORK      ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_ROOT         ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_SHAREADMIN   ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_DIRECTORY    ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_TREE         ),
    FLAG_DESCR(RESOURCEDISPLAYTYPE_NDSCONTAINER ),
};

HRESULT _EnumConnections(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    HANDLE hEnum;
    DWORD dw;
    DWORD dwScope;

    _StartClock();

    if (_IsFlagSet(USER_WNETENUMRESOURCECONNECTED, dwFlags))
    {
        dwScope = RESOURCE_CONNECTED;
    }
    else
    {
        dwScope = RESOURCE_REMEMBERED;
    }

    dw = WNetOpenEnum(dwScope, RESOURCETYPE_DISK, 0, NULL, &hEnum);

    if (WN_SUCCESS == dw)
    {
        BOOL fExit = FALSE;
        DWORD cbBuf = 4096 * 4;
        PBYTE pbBuf = (PBYTE)LocalAlloc(LPTR, cbBuf);

        do
        {
            //return as much as possible
            DWORD c = 0xFFFFFFFF;

            ZeroMemory(pbBuf, cbBuf);

            dw = WNetEnumResource(hEnum, &c, pbBuf, &cbBuf);

            // we assume we'll call it only once
            _StopClock();

            _PrintElapsedTime(cchIndent, TRUE);

            switch (dw)
            {
                case WN_SUCCESS:
                {
                    NETRESOURCE* pnr = (NETRESOURCE*)pbBuf;
            
                    for (DWORD i = 0; i < c; ++i)
                    {
                        _PrintIndent(cchIndent);
                        wprintf(TEXT("NETRESOURCE\n"));

                        _PrintIndent(cchIndent);
                        wprintf(TEXT("{\n"));

                        // Scope
                        _PrintFlag(pnr->dwScope, _scopeFD, ARRAYSIZE(_scopeFD),
                            cchIndent + 2, TRUE, TRUE, FALSE, FALSE);
                        wprintf(TEXT(" (DWORD dwScope)\n"));

                        // Type
                        _PrintFlag(pnr->dwType, _typeFD, ARRAYSIZE(_typeFD),
                            cchIndent + 2, TRUE, TRUE, FALSE, FALSE);
                        wprintf(TEXT(" (DWORD dwType)\n"));

                        // DisplayType
                        _PrintFlag(pnr->dwDisplayType, _displaytypeFD,
                            ARRAYSIZE(_displaytypeFD), cchIndent + 2, TRUE, TRUE,
                            FALSE, FALSE);
                        wprintf(TEXT(" (DWORD dwDisplayType)\n"));

                        // Usage
                        _PrintFlag(pnr->dwUsage, _usageFD, ARRAYSIZE(_usageFD),
                            cchIndent + 2, TRUE, TRUE, FALSE, TRUE);
                        wprintf(TEXT(" (DWORD dwUsage)\n"));

                        // lpLocalName
                        _PrintIndent(cchIndent + 2);
                        if (pnr->lpLocalName)
                        {
                            wprintf(TEXT("'%s'"), pnr->lpLocalName);
                        }
                        else
                        {
                            wprintf(TEXT("<NULL>"));
                        }
                        wprintf(TEXT(" (LPTSTR lpLocalName)\n"));

                        // lpRemoteName
                        _PrintIndent(cchIndent + 2);
                        if (pnr->lpRemoteName)
                        {
                            wprintf(TEXT("'%s'"), pnr->lpRemoteName);
                        }
                        else
                        {
                            wprintf(TEXT("<NULL>"));
                        }
                        wprintf(TEXT(" (LPTSTR lpRemoteName)\n"));

                        // lpComment
                        _PrintIndent(cchIndent + 2);
                        if (pnr->lpComment)
                        {
                            wprintf(TEXT("'%s'"), pnr->lpComment);
                        }
                        else
                        {
                            wprintf(TEXT("<NULL>"));
                        }
                        wprintf(TEXT(" (LPTSTR lpComment)\n"));

                        // lpProvider
                        _PrintIndent(cchIndent + 2);
                        if (pnr->lpProvider)
                        {
                            wprintf(TEXT("'%s'"), pnr->lpProvider);
                        }
                        else
                        {
                            wprintf(TEXT("<NULL>"));
                        }
                        wprintf(TEXT(" (LPTSTR lpProvider)\n"));

                        _PrintIndent(cchIndent);
                        wprintf(TEXT("}\n\n"));

                        ++pnr;
                    }

                    break;
                }

                case ERROR_NO_MORE_ITEMS:
                {
                    fExit = TRUE;
                    break;
                }

                case ERROR_MORE_DATA:
                {
                    if (pbBuf)
                    {
                        LocalFree(pbBuf);
                    }

                    // cbBuf contains required size
                    pbBuf = (PBYTE)LocalAlloc(LPTR, cbBuf);

                    if (!pbBuf)
                    {
                        fExit = TRUE;
                    }

                    break;
                }
            }
        }
        while (!fExit);

        if (pbBuf)
        {
            LocalFree(pbBuf);
        }

        WNetCloseEnum(hEnum);
    }
    else
    {
        if (ERROR_NO_NETWORK == dw)
        {
            wprintf(TEXT("Error: No Network!\n"));
        }
        else
        {
            if (ERROR_NO_MORE_ITEMS == dw)
            {
                wprintf(TEXT("None\n"));
            }
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\dfuser.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include "dfuser.h"

#include <stdio.h>

#include "dferr.h"
#include "dfhlprs.h"
#include "drvfull.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

_sFLAG_DESCR drivetypeFD[] =
{
    FLAG_DESCR(DRIVE_UNKNOWN),
    FLAG_DESCR(DRIVE_NO_ROOT_DIR),
    FLAG_DESCR(DRIVE_REMOVABLE),
    FLAG_DESCR(DRIVE_FIXED),
    FLAG_DESCR(DRIVE_REMOTE),
    FLAG_DESCR(DRIVE_CDROM),
    FLAG_DESCR(DRIVE_RAMDISK),
};

HRESULT _GetDriveType(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    int i = 0;

    _StartClock();

    DWORD dw = GetDriveType(pszArg);

    _StopClock();

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: GetDriveType\n"));

    _PrintElapsedTime(cchIndent, TRUE);

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Return Value: "));

    i += _PrintFlag(dw, drivetypeFD, ARRAYSIZE(drivetypeFD), 0, TRUE, TRUE,
        FALSE, FALSE);

    i += _PrintCR();

    return hres;
}

_sFLAG_DESCR _fdFileSys[] =
{
    FLAG_DESCR(FS_CASE_IS_PRESERVED),
    FLAG_DESCR(FS_CASE_SENSITIVE),
    FLAG_DESCR(FS_UNICODE_STORED_ON_DISK),
    FLAG_DESCR(FS_PERSISTENT_ACLS),
    FLAG_DESCR(FS_FILE_COMPRESSION),
    FLAG_DESCR(FS_VOL_IS_COMPRESSED),
    FLAG_DESCR(FILE_NAMED_STREAMS),
    FLAG_DESCR(FILE_SUPPORTS_ENCRYPTION),
    FLAG_DESCR(FILE_SUPPORTS_OBJECT_IDS),
    FLAG_DESCR(FILE_SUPPORTS_REPARSE_POINTS),
    FLAG_DESCR(FILE_SUPPORTS_SPARSE_FILES),
    FLAG_DESCR(FILE_VOLUME_QUOTAS ),
};

HRESULT _GetVolumeInformation(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    int i = 0;

    WCHAR szLabel[250];
    WCHAR szFileSys[250];
    DWORD dwSerNum;
    DWORD dwMaxCompName;
    DWORD dwFileSysFlags;
    
    _StartClock();

    BOOL f = GetVolumeInformation(pszArg, szLabel, ARRAYSIZE(szLabel),
        &dwSerNum, &dwMaxCompName, &dwFileSysFlags, szFileSys,
        ARRAYSIZE(szFileSys));

    DWORD dw = GetDriveType(pszArg);

    _StopClock();

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: GetVolumeInformation\n"));

    _PrintElapsedTime(cchIndent, TRUE);

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Return Value: %s\n"), f ? TEXT("TRUE") : TEXT("FALSE"));

    if (f)
    {
        _PrintIndent(cchIndent + 2);
        i += wprintf(TEXT("%s (LPTSTR lpVolumeNameBuffer)\n"), szLabel);
        _PrintIndent(cchIndent + 2);
        i += wprintf(TEXT("0x%08X (LPDWORD lpVolumeSerialNumber)\n"), dwSerNum);
        _PrintIndent(cchIndent + 2);
        i += wprintf(TEXT("%d (LPDWORD lpMaximumComponentLength)\n"), dwMaxCompName);
        _PrintIndent(cchIndent + 2);
        i += wprintf(TEXT("0x%08X (LPDWORD lpFileSystemFlags)\n"), dwFileSysFlags);
        i += _PrintFlag(dwFileSysFlags, _fdFileSys, ARRAYSIZE(_fdFileSys), cchIndent + 4,
            TRUE, TRUE, FALSE, TRUE);
        _PrintCR();
        _PrintIndent(cchIndent + 2);
        i += wprintf(TEXT("%s (LPTSTR lpFileSystemNameBuffer)\n"), szFileSys);
    }

    i += _PrintCR();

    return hres;
}

_sFLAG_DESCR _fdFileAttrib[] =
{
    FLAG_DESCR(FILE_ATTRIBUTE_READONLY            ),
    FLAG_DESCR(FILE_ATTRIBUTE_HIDDEN              ),
    FLAG_DESCR(FILE_ATTRIBUTE_SYSTEM              ),
    FLAG_DESCR(FILE_ATTRIBUTE_DIRECTORY           ),
    FLAG_DESCR(FILE_ATTRIBUTE_ARCHIVE             ),
    FLAG_DESCR(FILE_ATTRIBUTE_DEVICE              ),
    FLAG_DESCR(FILE_ATTRIBUTE_NORMAL              ),
    FLAG_DESCR(FILE_ATTRIBUTE_TEMPORARY           ),
    FLAG_DESCR(FILE_ATTRIBUTE_SPARSE_FILE         ),
    FLAG_DESCR(FILE_ATTRIBUTE_REPARSE_POINT       ),
    FLAG_DESCR(FILE_ATTRIBUTE_COMPRESSED          ),
    FLAG_DESCR(FILE_ATTRIBUTE_OFFLINE             ),
    FLAG_DESCR(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED ),
    FLAG_DESCR(FILE_ATTRIBUTE_ENCRYPTED           ),
};

_sFLAG_DESCR _fdDEVINFODEVTYPE[] =
{
    FLAG_DESCR(FILE_DEVICE_BEEP               ),
    FLAG_DESCR(FILE_DEVICE_CD_ROM             ),
    FLAG_DESCR(FILE_DEVICE_CD_ROM_FILE_SYSTEM ),
    FLAG_DESCR(FILE_DEVICE_CONTROLLER         ),
    FLAG_DESCR(FILE_DEVICE_DATALINK           ),
    FLAG_DESCR(FILE_DEVICE_DFS                ),
    FLAG_DESCR(FILE_DEVICE_DISK               ),
    FLAG_DESCR(FILE_DEVICE_DISK_FILE_SYSTEM   ),
    FLAG_DESCR(FILE_DEVICE_FILE_SYSTEM        ),
    FLAG_DESCR(FILE_DEVICE_INPORT_PORT        ),
    FLAG_DESCR(FILE_DEVICE_KEYBOARD           ),
    FLAG_DESCR(FILE_DEVICE_MAILSLOT           ),
    FLAG_DESCR(FILE_DEVICE_MIDI_IN            ),
    FLAG_DESCR(FILE_DEVICE_MIDI_OUT           ),
    FLAG_DESCR(FILE_DEVICE_MOUSE              ),
    FLAG_DESCR(FILE_DEVICE_MULTI_UNC_PROVIDER ),
    FLAG_DESCR(FILE_DEVICE_NAMED_PIPE         ),
    FLAG_DESCR(FILE_DEVICE_NETWORK            ),
    FLAG_DESCR(FILE_DEVICE_NETWORK_BROWSER    ),
    FLAG_DESCR(FILE_DEVICE_NETWORK_FILE_SYSTEM),
    FLAG_DESCR(FILE_DEVICE_NULL               ),
    FLAG_DESCR(FILE_DEVICE_PARALLEL_PORT      ),
    FLAG_DESCR(FILE_DEVICE_PHYSICAL_NETCARD   ),
    FLAG_DESCR(FILE_DEVICE_PRINTER            ),
    FLAG_DESCR(FILE_DEVICE_SCANNER            ),
    FLAG_DESCR(FILE_DEVICE_SERIAL_MOUSE_PORT  ),
    FLAG_DESCR(FILE_DEVICE_SERIAL_PORT        ),
    FLAG_DESCR(FILE_DEVICE_SCREEN             ),
    FLAG_DESCR(FILE_DEVICE_SOUND              ),
    FLAG_DESCR(FILE_DEVICE_STREAMS            ),
    FLAG_DESCR(FILE_DEVICE_TAPE               ),
    FLAG_DESCR(FILE_DEVICE_TAPE_FILE_SYSTEM   ),
    FLAG_DESCR(FILE_DEVICE_TRANSPORT          ),
    FLAG_DESCR(FILE_DEVICE_UNKNOWN            ),
    FLAG_DESCR(FILE_DEVICE_VIDEO              ),
    FLAG_DESCR(FILE_DEVICE_VIRTUAL_DISK       ),
    FLAG_DESCR(FILE_DEVICE_WAVE_IN            ),
    FLAG_DESCR(FILE_DEVICE_WAVE_OUT           ),
    FLAG_DESCR(FILE_DEVICE_8042_PORT          ),
    FLAG_DESCR(FILE_DEVICE_NETWORK_REDIRECTOR ),
    FLAG_DESCR(FILE_DEVICE_BATTERY            ),
    FLAG_DESCR(FILE_DEVICE_BUS_EXTENDER       ),
    FLAG_DESCR(FILE_DEVICE_MODEM              ),
    FLAG_DESCR(FILE_DEVICE_VDM                ),
    FLAG_DESCR(FILE_DEVICE_MASS_STORAGE       ),
    FLAG_DESCR(FILE_DEVICE_SMB                ),
    FLAG_DESCR(FILE_DEVICE_KS                 ),
    FLAG_DESCR(FILE_DEVICE_CHANGER            ),
    FLAG_DESCR(FILE_DEVICE_SMARTCARD          ),
    FLAG_DESCR(FILE_DEVICE_ACPI               ),
    FLAG_DESCR(FILE_DEVICE_DVD                ),
    FLAG_DESCR(FILE_DEVICE_FULLSCREEN_VIDEO   ),
    FLAG_DESCR(FILE_DEVICE_DFS_FILE_SYSTEM    ),
    FLAG_DESCR(FILE_DEVICE_DFS_VOLUME         ),
    FLAG_DESCR(FILE_DEVICE_SERENUM            ),
    FLAG_DESCR(FILE_DEVICE_TERMSRV            ),
    FLAG_DESCR(FILE_DEVICE_KSEC               ),
    FLAG_DESCR(FILE_DEVICE_FIPS		          ),
};

_sFLAG_DESCR _fdDEVINFODEVCHARACT[] =
{
    FLAG_DESCR(FILE_REMOVABLE_MEDIA          ),
    FLAG_DESCR(FILE_READ_ONLY_DEVICE         ),
    FLAG_DESCR(FILE_FLOPPY_DISKETTE          ),
    FLAG_DESCR(FILE_WRITE_ONCE_MEDIA         ),
    FLAG_DESCR(FILE_REMOTE_DEVICE            ),
    FLAG_DESCR(FILE_DEVICE_IS_MOUNTED        ),
    FLAG_DESCR(FILE_VIRTUAL_VOLUME           ),
    FLAG_DESCR(FILE_AUTOGENERATED_DEVICE_NAME),
    FLAG_DESCR(FILE_DEVICE_SECURE_OPEN       ),
};

HRESULT _NtMediaPresent(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hr = S_OK;
    int i = 0;

    _StartClock();

    HANDLE h = _GetDeviceHandle(pszArg, FILE_READ_ATTRIBUTES, 0); 

    _StopClock();

    _PrintElapsedTime(cchIndent, TRUE);

    if (INVALID_HANDLE_VALUE != h)
    {        
        _PrintIndent(cchIndent);
        i += wprintf(TEXT("Was able to CreateFile\n"));

        NTSTATUS status;
        WCHAR buffer[sizeof(FILE_FS_VOLUME_INFORMATION) + MAX_PATH];
        FILE_FS_DEVICE_INFORMATION DeviceInfo;

        IO_STATUS_BLOCK ioStatus;

        status = NtQueryVolumeInformationFile(h, &ioStatus,
            buffer, sizeof(buffer), FileFsVolumeInformation);

        status = NtQueryVolumeInformationFile(h, &ioStatus,
            &DeviceInfo,
            sizeof(DeviceInfo),
            FileFsDeviceInformation);

        if (0 == status)
        {
            _PrintIndent(cchIndent);
            i += wprintf(TEXT("DeviceType\n"));

            i += _PrintFlag(DeviceInfo.DeviceType, _fdDEVINFODEVTYPE,
                ARRAYSIZE(_fdDEVINFODEVTYPE), cchIndent + 4,
                TRUE, TRUE, FALSE, FALSE);

            i += _PrintCR();
            _PrintIndent(cchIndent);
            i += wprintf(TEXT("Characteristics\n"));

            i += _PrintFlag(DeviceInfo.Characteristics, _fdDEVINFODEVCHARACT,
                ARRAYSIZE(_fdDEVINFODEVCHARACT), cchIndent + 4,
                TRUE, TRUE, FALSE, TRUE);
        }

        CloseHandle(h);
    }
    else
    {
        _PrintIndent(cchIndent);
        i += wprintf(TEXT("Was *NOT* able to CreateFile\n"));

        _PrintGetLastError(cchIndent);
    }

    return hr;
}

HRESULT _GetFileAttributes(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    int i = 0;

    _StartClock();

    DWORD dw = GetFileAttributes(pszArg);

    _StopClock();

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: GetFileAttributes\n"));

    _PrintElapsedTime(cchIndent, TRUE);

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Return Value: 0x%08X\n"), dw);

    if (-1 != dw)
    {
        i += _PrintFlag(dw, _fdFileAttrib, ARRAYSIZE(_fdFileAttrib), cchIndent + 4,
            TRUE, TRUE, FALSE, TRUE);
    }

    i += _PrintCR();

    return hres;
}

HRESULT _QueryDosDeviceNULL(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    TCHAR sz[8192];
    int i = 0;

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: QueryDosDevice with NULL\n"));

    _StartClock();

    DWORD dw = QueryDosDevice(NULL, sz, ARRAYSIZE(sz));

    _StopClock();

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Return Value: 0x%08X\n"), dw);
    i += _PrintCR();

    if (dw)
    {
        LPTSTR psz = sz;

        while (*psz)
        {
            i += wprintf(TEXT("%s\n"), psz);

            psz += lstrlen(psz) + 1;
        }
    }

    _PrintElapsedTime(cchIndent, TRUE);

    i += _PrintCR();

    return hres;
}

HRESULT _QueryDosDevice(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    TCHAR sz[4096];
    int i = 0;

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: QueryDosDevice\n"));

    _StartClock();

    DWORD dw = QueryDosDevice(pszArg, sz, ARRAYSIZE(sz));

    _StopClock();

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Return Value: 0x%08X\n"), dw);
    i += _PrintCR();

    if (dw)
    {
        i += wprintf(TEXT("Target path: %s\n"), sz);    
    }

    _PrintElapsedTime(cchIndent, TRUE);

    i += _PrintCR();

    return hres;
}

HRESULT _GetLogicalDrives(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{
    HRESULT hres = S_OK;
    TCHAR sz[4096];
    int i = 0;

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Oper: GetLogicalDrives\n"));

    _StartClock();

    DWORD dwLGD = GetLogicalDrives();

    _StopClock();

    _PrintIndent(cchIndent);
    i += wprintf(TEXT("Return Value: 0x%08X\n"), dwLGD);
    i += _PrintCR();

    if (dwLGD)
    {
        for (DWORD j = 0; j < 32; ++j)
        {
            DWORD dw = 1 << j;

            if (dw & dwLGD)
            {
                i += wprintf(TEXT("        %c:\n"), TEXT('A') + (TCHAR)j);
            }
        }
    }

    _PrintElapsedTime(cchIndent, TRUE);

    i += _PrintCR();

    return hres;
}

typedef HRESULT (*_USERHANDLER)(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

struct _UserHandler
{
    DWORD           dwFlag;
    _USERHANDLER    userhandler;
};

// from dfwnet.cpp
HRESULT _EnumConnections(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent);

_UserHandler _userhandlers[] =
{
    { USER_GETDRIVETYPE, _GetDriveType },
    { USER_GETVOLUMEINFORMATION, _GetVolumeInformation },
    { USER_GETFILEATTRIBUTES, _GetFileAttributes },
    { USER_QUERYDOSDEVICE, _QueryDosDevice },
    { USER_QUERYDOSDEVICENULL, _QueryDosDeviceNULL },
    { USER_GETLOGICALDRIVES, _GetLogicalDrives },
    { USER_WNETENUMRESOURCECONNECTED, _EnumConnections },
    { USER_WNETENUMRESOURCEREMEMBERED, _EnumConnections },
    { NT_MEDIAPRESENT, _NtMediaPresent },
};

HRESULT _ProcessUser(DWORD dwFlags[], LPTSTR pszArg, DWORD cchIndent)
{   
    HRESULT hres = E_INVALIDARG;

    for (DWORD dw = 0; dw < ARRAYSIZE(_userhandlers); ++dw)
    {
        if (_IsFlagSet(_userhandlers[dw].dwFlag, dwFlags))
        {
            hres = (*(_userhandlers[dw].userhandler))(dwFlags, pszArg,
                cchIndent);
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\drvfull.h ===
#ifndef _DRVFULL_H
#define _DRVFULL_H

#include <objbase.h>

#define MAX_FLAGS                       4

#define IOCTL_FLAGS                     0x10000000
#define PNP_FLAGS                       0x20000000
#define USER_FLAGS                      0x40000000
#define MOD_FLAGS                       0x80000000

#define OPER_MASK                       0x0FFFFFFF
#define CAT_MASK                        0xF0000000

// IOCTL
#define IOCTL_GEOMETRY                  (IOCTL_FLAGS | 0x01000000)
#define IOCTL_LAYOUT                    (IOCTL_FLAGS | 0x02000000)
#define IOCTL_EJECT                     (IOCTL_FLAGS | 0x08000000)
#define IOCTL_VOLUMENUMBER              (IOCTL_FLAGS | 0x00100000)
#define IOCTL_MEDIAACCESSIBLE           (IOCTL_FLAGS | 0x00010000)
#define IOCTL_DISKISWRITABLE            (IOCTL_FLAGS | 0x00020000)
#define IOCTL_MEDIATYPES                (IOCTL_FLAGS | 0x00040000)
#define IOCTL_MEDIATYPESEX              (IOCTL_FLAGS | 0x00080000)
#define IOCTL_MCNCONTROL                (IOCTL_FLAGS | 0x00001000)
#define IOCTL_DVD                       (IOCTL_FLAGS | 0x00002000)
#define IOCTL_GETREPARSEPOINT           (IOCTL_FLAGS | 0x00004000)
#define IOCTL_CDROMGETCONFIGMMC2        (IOCTL_FLAGS | 0x00008000)
#define IOCTL_CDROMGETCONFIGDVDRAM      (IOCTL_FLAGS | 0x00000100)
#define IOCTL_CDROMGETCONFIGRW          (IOCTL_FLAGS | 0x00000200)
#define IOCTL_CDROMGETCONFIGWO          (IOCTL_FLAGS | 0x00000400)
#define IOCTL_CDROMGETCONFIGISW         (IOCTL_FLAGS | 0x00000800)
#define IOCTL_CDROMGETCONFIGALL         (IOCTL_FLAGS | 0x00000010)
#define IOCTL_PARTITION                 (IOCTL_FLAGS | 0x00000020)
#define IOCTL_PARTITIONSURE             (IOCTL_FLAGS | 0x00000040)
#define IOCTL_MEDIATYPES2               (IOCTL_FLAGS | 0x00000080)
#define IOCTL_PARTITIONGPT              (IOCTL_FLAGS | 0x00000001)

// PNP
#define PNP_WATCHSETUPDI                (PNP_FLAGS | 0x00010000)
#define PNP_WATCHCM                     (PNP_FLAGS | 0x00020000)
#define PNP_HAL                         (PNP_FLAGS | 0x00040000)
#define PNP_HANDLE                      (PNP_FLAGS | 0x00080000)
#define PNP_CMDEVICE                    (PNP_FLAGS | 0x00100000)
#define PNP_CMINTERFACE                 (PNP_FLAGS | 0x00200000)
#define PNP_CMENUM                      (PNP_FLAGS | 0x00400000)
#define PNP_CMDEVICEIDLIST              (PNP_FLAGS | 0x00800000)
#define PNP_EJECTBUTTON                 (PNP_FLAGS | 0x01000000)
#define PNP_CUSTOMPROPERTY              (PNP_FLAGS | 0x02000000)

// Regular user mode calls
#define USER_GETDRIVETYPE               (USER_FLAGS | 0x00010000)
#define USER_QUERYDOSDEVICE             (USER_FLAGS | 0x00020000)
#define USER_QUERYDOSDEVICENULL         (USER_FLAGS | 0x00040000)
#define USER_GETLOGICALDRIVES           (USER_FLAGS | 0x00080000)
#define USER_WNETENUMRESOURCECONNECTED  (USER_FLAGS | 0x00100000)
#define USER_WNETENUMRESOURCEREMEMBERED (USER_FLAGS | 0x00200000)
#define USER_GETVOLUMEINFORMATION       (USER_FLAGS | 0x00400000)
#define USER_GETFILEATTRIBUTES          (USER_FLAGS | 0x00800000)

#define NT_MEDIAPRESENT                 (USER_FLAGS | 0x01000000)

// MODIFIER
#define MOD_FULLREPORT1                 (MOD_FLAGS | 0x00010000)
#define MOD_FULLREPORT2                 (MOD_FLAGS | 0x00020000)
#define MOD_FULLREPORT3                 (MOD_FLAGS | 0x00040000)
#define MOD_FULLREPORTFULL              (MOD_FLAGS | 0x00080000 | MOD_FULLREPORT3 | MOD_FULLREPORT2 | MOD_FULLREPORT1)

BOOL _IsFlagSet(DWORD dwFlag, DWORD dwFlags[]);

#endif // _DRVFULL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\drvfull\drvfull.cpp ===
#include "drvfull.h"

#include <tchar.h>
#include <stdio.h>
#include <windows.h>

//#include <winnetp.h>

#include "dfioctl.h"
#include "dfuser.h"
#include "dfpnp.h"
#include "dfcm.h"
#include "dfstpdi.h"

#include "dfhlprs.h"

#define CCHINDENT       2
#define CCHINDENT2      (CCHINDENT * 2)
#define CCHINDENT3      (CCHINDENT * 3)
#define CCHINDENT4      (CCHINDENT * 4)

#define FIRST_ARG                       1
#define SECOND_ARG                      2
#define THIRD_ARG                       3
#define FOURTH_ARG                      4

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

struct _sFlag
{
    LPTSTR  pszFlag;
    DWORD   dwFlag;
    DWORD   dwArg;
};

static _sFlag _flagTable[] =
{
    { TEXT("-hg"), IOCTL_GEOMETRY, FIRST_ARG},
    { TEXT("-hl"), IOCTL_LAYOUT, FIRST_ARG},
    { TEXT("-hp"), IOCTL_PARTITION, FIRST_ARG},
    { TEXT("-hpsure"), IOCTL_PARTITIONSURE, FIRST_ARG},
    { TEXT("-hpgpt"), IOCTL_PARTITIONGPT, FIRST_ARG},
    { TEXT("-vn"), IOCTL_VOLUMENUMBER, FIRST_ARG},
    { TEXT("-ma"), IOCTL_MEDIAACCESSIBLE, FIRST_ARG},
    { TEXT("-mw"), IOCTL_DISKISWRITABLE, FIRST_ARG},
    { TEXT("-mt"), IOCTL_MEDIATYPES, FIRST_ARG},
    { TEXT("-mt2"), IOCTL_MEDIATYPES2, FIRST_ARG},
    { TEXT("-mx"), IOCTL_MEDIATYPESEX, FIRST_ARG},
    { TEXT("-mdvd"), IOCTL_DVD, FIRST_ARG},
    { TEXT("-ej"), IOCTL_EJECT, FIRST_ARG},
    { TEXT("-dar"), IOCTL_MCNCONTROL, FIRST_ARG},
    { TEXT("-grp"), IOCTL_GETREPARSEPOINT, FIRST_ARG},
    { TEXT("-gcmmc2"), IOCTL_CDROMGETCONFIGMMC2, FIRST_ARG},
    { TEXT("-gcdvdram"), IOCTL_CDROMGETCONFIGDVDRAM, FIRST_ARG},
    { TEXT("-gcrw"), IOCTL_CDROMGETCONFIGRW, FIRST_ARG},
    { TEXT("-gcwo"), IOCTL_CDROMGETCONFIGWO, FIRST_ARG},
    { TEXT("-gcisw"), IOCTL_CDROMGETCONFIGISW, FIRST_ARG},
    { TEXT("-gcall"), IOCTL_CDROMGETCONFIGALL, FIRST_ARG},
    { TEXT("-pnpe"), PNP_CMENUM, SECOND_ARG},
    { TEXT("-pnps"), PNP_WATCHSETUPDI, SECOND_ARG},
    { TEXT("-pnpc"), PNP_WATCHCM, SECOND_ARG},
    { TEXT("-pnpd"), PNP_CMDEVICE, SECOND_ARG},
    { TEXT("-pnpi"), PNP_CMINTERFACE, SECOND_ARG},
    { TEXT("-pnph"), PNP_HANDLE, SECOND_ARG},
    { TEXT("-pnpeb"), PNP_EJECTBUTTON, SECOND_ARG},
    { TEXT("-pnpl"), PNP_CMDEVICEIDLIST, SECOND_ARG},
    { TEXT("-pnpcs"), PNP_CUSTOMPROPERTY, SECOND_ARG},
    { TEXT("-ugdt"), USER_GETDRIVETYPE, THIRD_ARG},
    { TEXT("-ugvi"), USER_GETVOLUMEINFORMATION, THIRD_ARG},
    { TEXT("-ugfa"), USER_GETFILEATTRIBUTES, THIRD_ARG},
    { TEXT("-uqdd"), USER_QUERYDOSDEVICE, THIRD_ARG},
    { TEXT("-uqddn"), USER_QUERYDOSDEVICENULL, THIRD_ARG},
    { TEXT("-ugld"), USER_GETLOGICALDRIVES, THIRD_ARG},
    { TEXT("-uwneterc"), USER_WNETENUMRESOURCECONNECTED, THIRD_ARG},
    { TEXT("-uwneterr"), USER_WNETENUMRESOURCEREMEMBERED, THIRD_ARG},
    { TEXT("-ntma"), NT_MEDIAPRESENT, THIRD_ARG},
    { TEXT("-Z"), MOD_FULLREPORTFULL, FOURTH_ARG},
    { TEXT("-Z1"), MOD_FULLREPORT1, FOURTH_ARG},
    { TEXT("-Z2"), MOD_FULLREPORT2, FOURTH_ARG},
    { TEXT("-Z3"), MOD_FULLREPORT3, FOURTH_ARG},
};

void _SetFlag(_sFlag* psflag, DWORD dwFlags[])
{
    dwFlags[psflag->dwArg - 1] |= psflag->dwFlag;
}

BOOL _IsFlagSet(DWORD dwFlag, DWORD dwFlags[])
{
    BOOL fRet = FALSE;

    for (DWORD dw = 0; dw < ARRAYSIZE(_flagTable); ++dw)
    {
        if (dwFlag == _flagTable[dw].dwFlag)
        {
            if ((dwFlags[_flagTable[dw].dwArg - 1] & OPER_MASK) & dwFlag)
            {
                fRet = TRUE;
            }

            break;
        }
    }
    
    return fRet;
}

BOOL _IsCategorySet(DWORD dwFlag, DWORD dwFlags[])
{
    BOOL fRet = FALSE;

    for (DWORD dw = 0; dw < ARRAYSIZE(_flagTable); ++dw)
    {
        if (dwFlag == (_flagTable[dw].dwFlag & CAT_MASK))
        {
            if ((dwFlags[_flagTable[dw].dwArg - 1] & CAT_MASK) & dwFlag)
            {
                fRet = TRUE;
            }

            break;
        }
    }
    
    return fRet;
}

HRESULT _ExtractFlags(int argc, wchar_t* argv[], DWORD dwFlags[])
{
    HRESULT hres = E_FAIL;

    // for now
    for (int i = 0; i < argc; ++i)
    {   
        for (DWORD dw = 0; dw < ARRAYSIZE(_flagTable); ++dw)
        {
            if (!lstrcmp(_flagTable[dw].pszFlag, argv[i]))
            {
                _SetFlag(&(_flagTable[dw]), dwFlags);

                hres = S_OK;

                break;
            }
        }
    }
 
    return hres;
}

HRESULT _Dispatch(DWORD dwFlags[], LPTSTR pszArg)
{
    HRESULT hres = S_OK;

    if (_IsCategorySet(IOCTL_FLAGS, dwFlags))
    {
        hres = _ProcessIOCTL(dwFlags, pszArg, CCHINDENT);
    }
    else
    {
        if (_IsCategorySet(PNP_FLAGS, dwFlags))
        {
            // for now
            if (_IsFlagSet(PNP_WATCHCM, dwFlags))
            {
                hres = _FullTree(dwFlags, 4);
            }
            else
            {
                // for now
/*                if (_IsFlagSet(PNP_HAL, dwFlags))
                {
                    hres = _HALGetPCIBusData(dwFlags, 4);
                }
                else
                {*/
                // for now
                if (_IsFlagSet(PNP_CMDEVICE, dwFlags))
                {
                    hres = _DeviceInfo(dwFlags, pszArg, 4);
                }
                else
                {
                    if (_IsFlagSet(PNP_CMINTERFACE, dwFlags))
                    {
                        hres = _DeviceInterface(dwFlags, pszArg, 4);
                    }
                    else
                    {
                        if (_IsFlagSet(PNP_CMENUM, dwFlags))
                        {
                            hres = _EnumDevice(dwFlags, pszArg, 4);
                        }
                        else
                        {
                            if (_IsFlagSet(PNP_CMDEVICEIDLIST, dwFlags))
                            {
                                hres = _DeviceIDList(dwFlags, pszArg, 4);
                            }
                            else
                            {
                                if (_IsFlagSet(PNP_CUSTOMPROPERTY, dwFlags))
                                {
                                    hres = _CustomProperty(dwFlags, pszArg, 4);
                                }
                                else
                                {
                                    hres = _ProcessPNP(dwFlags, pszArg, CCHINDENT);
                                }
                            }
                        }
                    }
                }
//                }
            }
        }
        else
        {
            if (_IsCategorySet(USER_FLAGS, dwFlags))
            {
                hres = _ProcessUser(dwFlags, pszArg, CCHINDENT);
            }
            else
            {
                hres = E_INVALIDARG;
            }
        }
    }

    return hres;
}

HRESULT _Help()
{
    HRESULT hres = S_OK;

    wprintf(TEXT("Some title\n\n"));

    _PrintIndent(CCHINDENT);
    wprintf(TEXT("Flags:\n"));

    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-h*     (Hard drive)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-hg         drive Geometry (1)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-hl         drive Layout (1)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-hp         partition drive (one partition) (1)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-hpgpt      is partition GPT? (guid partition table) (2)\n"));

    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-m*     (Media)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ma         is Media Accessible? (2)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-mt         Media Type (using IOCTL_STORAGE_GET_MEDIA_TYPES) (2)(3)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-mt2        Media Type (using IOCTL_DISK_GET_MEDIA_TYPES) (2)(3)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-mw         is Media Write-Protected? (2)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-mx         Media Type Ex (2)(4)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-mdvd       DVD drive? (2)(4)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-grp        Get Reparse Point Guid (6)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gc*    (CDROM Get Configuration)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gcmmc2     is MMC2 compliant? (5)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gcall      all MMC2 features implemented. (5)\n"));
/*    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gcdvdram   is DVD-RAM drive? (5)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gcrw       is random writable? (5)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gcwo       is write once (5)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-gcisw      is incremental streaming writable (5)\n"));*/

    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-v*     (Volume)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-vn         Volume Number? (2)\n"));

/*    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-e* (Eject)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ej     EJect media (2)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-el     Load Media (2)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ed     Disable hardware button (2)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ee     Enable hardware button (2)\n"));*/

    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-pnp*   Plug 'n' Play\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnps       Handle using SetupDI* API\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpc       Handle using CM_* API\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpd       Dump device info using CM_* API\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpi       Dump device interface info using CM_* API\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnph       Watch HANDLE event on Volume (5)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpeb      Monitor Eject button (5)\n"));    
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpe       Enum device implementing the interface (7)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpl       Enum device ID list\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-pnpcs      PnP device CustomProperties\n"));

    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-u*     User functions\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ugdt       GetDriveType ()\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ugvi       GetVolumeInformation (2)(5)\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ugfa       GetFileAttributes\n"));    
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-uqdd       QueryDosDevice ()\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-uqddn      QueryDosDevice with NULL for first param\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ugld       GetLogicalDrives\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-uwneterc   WNetEnumResource Connected\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-uwneterr   WNetEnumResource Remembered\n"));
    _PrintIndent(CCHINDENT4);
    wprintf(TEXT("-ntma       NtQueryVolumeInformationFile (TBD)\n"));

/*    _PrintCR();
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-?  This message.\n"));*/

    _PrintCR();
    _PrintIndent(CCHINDENT);
    wprintf(TEXT("Modifiers:\n"));

/*    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-F      Force\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-R      Raw function call\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-T      Elapsed time\n"));*/
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-Z      Full report - as much as possible\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-Z1     Full report - level 1\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-Z2     Full report - level 2\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("-Z3     Full report - level 3\n"));

    _PrintCR();
    _PrintIndent(CCHINDENT);
    wprintf(TEXT("Notes:\n"));

    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(1) Requires '\\\\.\\PhysicalDriveX' arg, where X is 0-n\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(2) Requires '\\\\.\\c:' arg or '\\\\?\\Volume{GUID}' (both without trailing '\\')\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(3) Floppy only\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(4) Non-Floppy only\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(5) Requires '\\\\?\\Volume{GUID}' (without trailing '\\')\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(6) Requires a junction point pathname\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(7) An interface GUID, e.g. '{4D36E967-E325-11CE-BFC1-08002BE10318}'\n"));
    _PrintIndent(CCHINDENT2);
    wprintf(TEXT("(8) A DOS device name, e.g. 'c:'\n"));

    return hres;
}

int g_argc = 0;
wchar_t** g_argv = NULL;

#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
#else
int __cdecl main(int argc, char* argv[])
#endif
{
    HRESULT hres = S_OK;

    if (argc > 1)
    {
        DWORD dwFlags[MAX_FLAGS] = {0};

        g_argv = argv;
        g_argc = argc;

        hres = _ExtractFlags(argc, argv, dwFlags);

        if (SUCCEEDED(hres))
        {
            hres = _Dispatch(dwFlags, argv[argc - 1]);
        }
    }
    else
    {
        hres = _Help();
    }

    return hres;
}
#ifdef UNICODE
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\debug.cpp ===
#include "stdafx.h"

#ifdef _PSEUDO_DEBUG   // entire file

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LONG AssertBusy = -1;
LONG AssertReallyBusy = -1;

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
	TCHAR szMessage[_MAX_PATH*2];

	InterlockedDecrement(&AssertReallyBusy);

	// format message into buffer
	wsprintf(szMessage, _T("File %hs, Line %d"),
		lpszFileName, nLine);

	TCHAR szT[_MAX_PATH*2 + 20];
	wsprintf(szT, _T("Assertion Failed: %s\n"), szMessage);
	OutputDebugString(szT);

	if (InterlockedIncrement(&AssertBusy) > 0)
	{
		InterlockedDecrement(&AssertBusy);

		// assert within assert (examine call stack to determine first one)
		DebugBreak();
		return FALSE;
	}

	// active popup window for the current thread
	HWND hWndParent = GetActiveWindow();
	if (hWndParent != NULL)
		hWndParent = GetLastActivePopup(hWndParent);

	// display the assert
	int nCode = ::MessageBox(hWndParent, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

	// cleanup
	InterlockedDecrement(&AssertBusy);

	if (nCode == IDIGNORE)
		return FALSE;   // ignore

	if (nCode == IDRETRY)
		return TRUE;    // will cause DebugBreak

	AfxAbort();     // should not return (but otherwise DebugBreak)
	return TRUE;
}

void Trace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	ASSERT(nBuf < (sizeof(szBuffer)/sizeof(szBuffer[0])));

	CString strMessage;

	if (AfxGetApp() != NULL)
		strMessage = ((CString) (AfxGetApp()->m_pszExeName)) + _T(": ");
	strMessage += szBuffer;
	OutputDebugString(strMessage);

	va_end(args);
}


#endif // _PSEUDO_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\debug.h ===
#if !defined(AFX_DEBUG_H__8DEDB8FC_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
#define AFX_DEBUG_H__8DEDB8FC_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _PSEUDO_DEBUG

#undef TRACE
#undef VERIFY
#undef ASSERT
#undef THIS_FILE
#undef TRACE0
#undef TRACE1
#undef TRACE2
#undef TRACE3


// Note: file names are still ANSI strings (filenames rarely need UNICODE)
BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);

void Trace(LPCTSTR lpszFormat, ...);

// by default, debug break is asm int 3, or a call to DebugBreak, or nothing
#if defined(_M_IX86)
#define CustomDebugBreak() _asm { int 3 }
#else
#define CustomDebugBreak() DebugBreak()
#endif

#define TRACE              ::Trace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
		CustomDebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::Trace(_T(sz))
#define TRACE1(sz, p1)          ::Trace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::Trace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::Trace(_T(sz), p1, p2, p3)

#endif // !_PSEUDO_DEBUG


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEBUG_H__8DEDB8FC_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\chooser.cpp ===
// chooser.cpp : Implements the CDialogChooser class
//

#include "stdafx.h"
#include "resource.h"
#include "ExtAw.h"
#include "chooser.h"
#include "extdlg.h"
#include "shextdlg.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// On construction, set up internal array with pointers to each step.
CDialogChooser::CDialogChooser()
{
	m_pDlgs[0] = NULL;

	m_pDlgs[1] = new ExtensionChoice;

	m_pDlgs[2] = new ShellExtensions;

	m_nCurrDlg = 0;
}
// Remember where the custom steps begin, so we can delete them in
//  the destructor
#define FIRST_CUSTOM_STEP 2
#define LAST_CUSTOM_STEP 2

// The destructor deletes entries in the internal array corresponding to
//  custom steps.
CDialogChooser::~CDialogChooser()
{
	// NOTE: Be sure to delete all of your custom steps here, but don't delete
	//  any standard AppWizard steps you got through the GetDialog API.
	for (int i = FIRST_CUSTOM_STEP; i <= LAST_CUSTOM_STEP; i++)
	{
		ASSERT(m_pDlgs[i] != NULL);
		delete m_pDlgs[i];
	}
}

// Use the internal array to determine the next step.
CAppWizStepDlg* CDialogChooser::Next(CAppWizStepDlg* pDlg)
{
	ASSERT(0 <= m_nCurrDlg && m_nCurrDlg < LAST_DLG);
	ASSERT(pDlg == m_pDlgs[m_nCurrDlg]);

	m_nCurrDlg++;
	return m_pDlgs[m_nCurrDlg];
}

// Use the internal array to determine the previous step.
CAppWizStepDlg* CDialogChooser::Back(CAppWizStepDlg* pDlg)
{
	ASSERT(1 <= m_nCurrDlg && m_nCurrDlg <= LAST_DLG);
	ASSERT(pDlg == m_pDlgs[m_nCurrDlg]);

	m_nCurrDlg--;
	return m_pDlgs[m_nCurrDlg];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\chooser.h ===
#if !defined(AFX_CHOOSER_H__8E5AF4C6_5EDE_11D1_8CD0_00C04FD918D0__INCLUDED_)
#define AFX_CHOOSER_H__8E5AF4C6_5EDE_11D1_8CD0_00C04FD918D0__INCLUDED_

// chooser.h : declaration of the CDialogChooser class
//             This class keeps track of what dialogs to pop up when.

#define LAST_DLG 2

class CDialogChooser
{
public:
	CDialogChooser();
	~CDialogChooser();

	// All calls by mfcapwz.dll to CTestAppWiz::Next
	//  & CTestAppWiz::Back are delegated to these member
	//  functions, which keep track of what dialog is up
	//  now, and what to pop up next.
	CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);

protected:
	// Current step's index into the internal array m_pDlgs
	int m_nCurrDlg;

	// Internal array of pointers to the steps
	CAppWizStepDlg* m_pDlgs[LAST_DLG + 1];
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSER_H__8E5AF4C6_5EDE_11D1_8CD0_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\ext.cpp ===
// Extensions.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>
#include "Ext.h"
#include "Extaw.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE ExtensionsDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("EXTENSIONS.AWX Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(ExtensionsDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(ExtensionsDLL);

		// Register this custom AppWizard with MFCAPWZ.DLL
		SetCustomAppWizClass(&Extensionsaw);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("EXTENSIONS.AWX Terminating!\n");

		// Terminate the library before destructors are called
		AfxTermExtensionModule(ExtensionsDLL);
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\ext.h ===
#if !defined(AFX_EXTENSIONS_H__8DEDB8F6_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
#define AFX_EXTENSIONS_H__8DEDB8F6_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

// TODO: You may add any other custom AppWizard-wide declarations here.

#define ARRAYSIZE(z) (sizeof(z)/sizeof(*z))
CString StripCurly(CString str);



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXTENSIONS_H__8DEDB8F6_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\extaw.cpp ===
// Extensionsaw.cpp : implementation file
//

#include "stdafx.h"
#include "Ext.h"
#include "Extaw.h"
#include "chooser.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This is called immediately after the custom AppWizard is loaded.  Initialize
//  the state of the custom AppWizard here.
void CExtensionsAppWiz::InitCustomAppWiz()
{
    GUID guidTemp;
    WCHAR wszGUID[50];

    _pChooser = new CDialogChooser;

	SetNumberOfSteps(2);

	// Inform AppWizard that we're making a DLL.
	m_Dictionary[_T("PROJTYPE_DLL")] = _T("1");

    	// Set template macros based on the project name entered by the user.

	// Get value of $$root$$ (already set by AppWizard)
	CString strRoot;
	m_Dictionary.Lookup(_T("root"), strRoot);
	
	// Set value of $$Doc$$, $$DOC$$
	CString strDoc = strRoot.Left(6);
	m_Dictionary[_T("Doc")] = strDoc;
	strDoc.MakeUpper();
	m_Dictionary[_T("DOC")] = strDoc;

	// Set value of $$MAC_TYPE$$
	strRoot = strRoot.Left(4);
	int nLen = strRoot.GetLength();
	if (strRoot.GetLength() < 4)
	{
		CString strPad(_T(' '), 4 - nLen);
		strRoot += strPad;
	}
	strRoot.MakeUpper();
	m_Dictionary[_T("MAC_TYPE")] = strRoot;

    if (SUCCEEDED(CoCreateGuid(&guidTemp)))
    {
        StringFromGUID2(guidTemp, wszGUID, ARRAYSIZE(wszGUID));
        Extensionsaw.m_Dictionary[TEXT("LibGUID")] = StripCurly(wszGUID);
    }
}

// This is called just before the custom AppWizard is unloaded.
void CExtensionsAppWiz::ExitCustomAppWiz()
{
    if (_pChooser)
    {
        delete _pChooser;
        _pChooser = NULL;
    }
}

// This is called when the user clicks "Create..." on the New Project dialog
CAppWizStepDlg* CExtensionsAppWiz::Next(CAppWizStepDlg* pDlg)
{
    return _pChooser->Next(pDlg);
}

// This is called when the user clicks "Back" on one of the custom
//  AppWizard's steps.
CAppWizStepDlg* CExtensionsAppWiz::Back(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return _pChooser->Back(pDlg);
}


void CExtensionsAppWiz::CustomizeProject(IBuildProject* pProject)
{
	// TODO: Add code here to customize the project.  If you don't wish
	//  to customize project, you may remove this virtual override.
	
	// This is called immediately after the default Debug and Release
	//  configurations have been created for each platform.  You may customize
	//  existing configurations on this project by using the methods
	//  of IBuildProject and IConfiguration such as AddToolSettings,
	//  RemoveToolSettings, and AddCustomBuildStep. These are documented in
	//  the Developer Studio object model documentation.

	// WARNING!!  IBuildProject and all interfaces you can get from it are OLE
	//  COM interfaces.  You must be careful to release all new interfaces
	//  you acquire.  In accordance with the standard rules of COM, you must
	//  NOT release pProject, unless you explicitly AddRef it, since pProject
	//  is passed as an "in" parameter to this function.  See the documentation
	//  on CCustomAppWiz::CustomizeProject for more information.



}


// Here we define one instance of the CExtensionsAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Extensionsaw.
CExtensionsAppWiz Extensionsaw;

CString StripCurly(CString str)
{
    return str.Mid(1, str.GetLength() - 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\extdlg.cpp ===
// ExtensionChoice.cpp : implementation file
//

#include "stdafx.h"
#include "Ext.h"
#include "Extaw.h"
#include "Extdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ExtensionChoice dialog


ExtensionChoice::ExtensionChoice()
	: CAppWizStepDlg(ExtensionChoice::IDD)
{
	//{{AFX_DATA_INIT(ExtensionChoice)
	m_strClassDescription = _T("");
	m_strClassType = _T("");
	m_strFileExt = _T("");
	//}}AFX_DATA_INIT
}


void ExtensionChoice::DoDataExchange(CDataExchange* pDX)
{
	CAppWizStepDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ExtensionChoice)
	DDX_Control(pDX, IDC_EXT_EDIT, m_edtExt);
	DDX_Text(pDX, IDC_CLASSDESC_EDIT, m_strClassDescription);
	DDX_Text(pDX, IDC_CLASSTYPE_EDIT, m_strClassType);
	DDX_Text(pDX, IDC_EXT_EDIT, m_strFileExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ExtensionChoice, CAppWizStepDlg)
	//{{AFX_MSG_MAP(ExtensionChoice)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ExtensionChoice message handlers

CString StripSpaces(CString& str)
{
    CString str2;
    for(int i = 0; i < str.GetLength(); i++)
    {
        if (str[i] != TEXT(' '))
            str2 += str[i];
    }
    return str2;
}


BOOL ExtensionChoice::OnDismiss()
{
    BOOL bRet = TRUE;
    UpdateData(TRUE);
    CString strWarn;
    if (m_strFileExt.Left(1) == TEXT("."))
    {
        strWarn.LoadString(IDS_FILEWARN);

        bRet = FALSE;
    }

    if (bRet)
    {
        if (!m_strFileExt.IsEmpty() && !m_strClassType.IsEmpty())
        {
            Extensionsaw.m_Dictionary[TEXT("Extension")] = m_strFileExt;
//            Extensionsaw.m_Dictionary[TEXT("Class Type")] = m_strClassType;
            Extensionsaw.m_Dictionary[TEXT("ClassType")] = m_strClassType;
            Extensionsaw.m_Dictionary[TEXT("ClassDescription")] = m_strClassDescription;
        }
        else
        {
            strWarn.LoadString(IDS_BLANKWARN);
            bRet = FALSE;
        }

    }

    if (!bRet)
    {
        CString strProgram((LPCTSTR)IDS_PROGRAM);
        MessageBox(strWarn, strProgram, MB_OK);
        m_edtExt.SetFocus();
    }


    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\extdlg.h ===
#if !defined(AFX_EXTENSIONCHOICE_H__AA4DBA53_5D3E_11D1_8CCE_00C04FD918D0__INCLUDED_)
#define AFX_EXTENSIONCHOICE_H__AA4DBA53_5D3E_11D1_8CCE_00C04FD918D0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ExtensionChoice.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// ExtensionChoice dialog

class ExtensionChoice : public CAppWizStepDlg
{
// Construction
public:
	ExtensionChoice();   // standard constructor

// Dialog Data
	//{{AFX_DATA(ExtensionChoice)
	enum { IDD = IDD_EXTENSION };
	CEdit	m_edtExt;
	CString	m_strClassDescription;
	CString	m_strClassType;
	CString	m_strFileExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ExtensionChoice)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    BOOL OnDismiss();

	// Generated message map functions
	//{{AFX_MSG(ExtensionChoice)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXTENSIONCHOICE_H__AA4DBA53_5D3E_11D1_8CCE_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\extaw.h ===
#if !defined(AFX_EXTENSIONSAW_H__8DEDB8FA_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
#define AFX_EXTENSIONSAW_H__8DEDB8FA_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_

// Extensionsaw.h : header file
//

class CDialogChooser;

// All function calls made by mfcapwz.dll to this custom AppWizard (except for
//  GetCustomAppWizClass-- see Extensions.cpp) are through this class.  You may
//  choose to override more of the CCustomAppWiz virtual functions here to
//  further specialize the behavior of this custom AppWizard.
class CExtensionsAppWiz : public CCustomAppWiz
{
    CDialogChooser* _pChooser;
public:
	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);
		
	virtual void InitCustomAppWiz();
	virtual void ExitCustomAppWiz();
	virtual void CustomizeProject(IBuildProject* pProject);
};

// This declares the one instance of the CExtensionsAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Extensionsaw.  (Its definition is in Extensionsaw.cpp.)
extern CExtensionsAppWiz Extensionsaw;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXTENSIONSAW_H__8DEDB8FA_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Extensions.rc
//
#define IDI_EXTENSIONS                  1
#define IDS_PROGRAM                     1
#define IDS_FILEWARN                    2
#define IDS_BLANKWARN                   3
#define IDD_EXTENSION                   107
#define IDD_SHELLOPTIONS                108
#define IDC_CONTEXTMENU                 1009
#define IDC_ICONHANDLER                 1010
#define IDC_PROPERTYSHEET               1011
#define IDC_DATAOBJECT                  1012
#define IDC_COPYHOOK                    1013
#define IDC_DROPTARGET                  1014
#define IDC_INFOTIP                     1015
#define IDC_DND                         1016
#define IDC_EXT_EDIT                    1017
#define IDC_CLASSTYPE_EDIT              1018
#define IDC_CLASSDESC_EDIT              1019
#define IDC_CONTEXTMENU2                1024
#define IDC_CONTEXTMENU3                1025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	again.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\stdafx.h ===
#if !defined(AFX_STDAFX_H__8DEDB8F8_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
#define AFX_STDAFX_H__8DEDB8F8_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#include "debug.h"			// For ASSERT, VERIFY, and TRACE
#include <customaw.h>		// Custom AppWizard interface
#include <afxole.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8DEDB8F8_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\shextdlg.cpp ===
// ShellExtensions.cpp : implementation file
//

#include "stdafx.h"
#include "Ext.h"
#include "Extaw.h"
#include "shextdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ShellExtensions dialog


ShellExtensions::ShellExtensions()
	: CAppWizStepDlg(ShellExtensions::IDD)
{
	//{{AFX_DATA_INIT(ShellExtensions)
	m_bContextMenu = FALSE;
	m_bContextMenu2 = FALSE;
	m_bContextMenu3 = FALSE;
	m_bCopyHook = FALSE;
	m_bDataObject = FALSE;
	m_bDragAndDrop = FALSE;
	m_bDropTarget = FALSE;
	m_bIcon = FALSE;
	m_bInfoTip = FALSE;
	m_bPropertySheet = FALSE;
	//}}AFX_DATA_INIT
}


void ShellExtensions::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ShellExtensions)
	DDX_Control(pDX, IDC_DND, m_btnDragAndDrop);
	DDX_Control(pDX, IDC_CONTEXTMENU3, m_btnContextMenu3);
//	DDX_Control(pDX, IDC_CONTEXTMENU2, m_btnContextMenu2);
	DDX_Check(pDX, IDC_CONTEXTMENU, m_bContextMenu);
//	DDX_Check(pDX, IDC_CONTEXTMENU2, m_bContextMenu2);
	DDX_Check(pDX, IDC_CONTEXTMENU3, m_bContextMenu3);
	DDX_Check(pDX, IDC_COPYHOOK, m_bCopyHook);
	DDX_Check(pDX, IDC_DATAOBJECT, m_bDataObject);
	DDX_Check(pDX, IDC_DND, m_bDragAndDrop);
	DDX_Check(pDX, IDC_DROPTARGET, m_bDropTarget);
	DDX_Check(pDX, IDC_ICONHANDLER, m_bIcon);
	DDX_Check(pDX, IDC_INFOTIP, m_bInfoTip);
	DDX_Check(pDX, IDC_PROPERTYSHEET, m_bPropertySheet);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ShellExtensions, CAppWizStepDlg)
	//{{AFX_MSG_MAP(ShellExtensions)
	ON_BN_CLICKED(IDC_CONTEXTMENU, OnContextmenu)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ShellExtensions message handlers

BOOL ShellExtensions::OnDismiss()
{
    UpdateData(TRUE);
    GUID guidTemp;
    WCHAR wszGUID[50];
    BOOL bSomethingSelected = FALSE;

    if (m_bContextMenu)
    {
        Extensionsaw.m_Dictionary[TEXT("IContextMenu")] = TEXT("1");

        if (m_bContextMenu3)
            Extensionsaw.m_Dictionary[TEXT("IContextMenu3")] = TEXT("1");
        else
            Extensionsaw.m_Dictionary.RemoveKey(TEXT("IContextMenu3"));


        if (m_bDragAndDrop)
            Extensionsaw.m_Dictionary[TEXT("DragAndDrop")] = TEXT("1");
        else
            Extensionsaw.m_Dictionary.RemoveKey(TEXT("DragAndDrop"));

        if (SUCCEEDED(CoCreateGuid(&guidTemp)))
        {
            StringFromGUID2(guidTemp, wszGUID, ARRAYSIZE(wszGUID));
            Extensionsaw.m_Dictionary[TEXT("ContextMenuGUID")] = StripCurly(wszGUID);
        }

        bSomethingSelected = TRUE;
    }
    else
    {
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("IContextMenu"));
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("IContextMenu3"));
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("DragAndDrop"));
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("ContextMenuGUID"));
    }

    
    if (m_bIcon)
    {
        Extensionsaw.m_Dictionary[TEXT("Icon")] = TEXT("1");
        if (SUCCEEDED(CoCreateGuid(&guidTemp)))
        {
            StringFromGUID2(guidTemp, wszGUID, ARRAYSIZE(wszGUID));
            Extensionsaw.m_Dictionary[TEXT("IconGUID")] = StripCurly(wszGUID);
        }
        bSomethingSelected = TRUE;
    }
    else
    {
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("Icon"));
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("IconGUID"));
    }


    if (m_bPropertySheet)
    {
        Extensionsaw.m_Dictionary[TEXT("PropertySheet")] = TEXT("1");
        if (SUCCEEDED(CoCreateGuid(&guidTemp)))
        {
            StringFromGUID2(guidTemp, wszGUID, ARRAYSIZE(wszGUID));
            Extensionsaw.m_Dictionary[TEXT("PropertySheetGUID")] = StripCurly(wszGUID);
        }
        bSomethingSelected = TRUE;
    }
    else
    {
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("PropertySheet"));
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("PropertySheetGUID"));
    }

    if (m_bInfoTip)
    {
        Extensionsaw.m_Dictionary[TEXT("InfoTip")] = TEXT("1");
        if (SUCCEEDED(CoCreateGuid(&guidTemp)))
        {
            StringFromGUID2(guidTemp, wszGUID, ARRAYSIZE(wszGUID));
            Extensionsaw.m_Dictionary[TEXT("InfoTipGUID")] = StripCurly(wszGUID);
        }
        bSomethingSelected = TRUE;
    }
    else
    {
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("InfoTip"));
        Extensionsaw.m_Dictionary.RemoveKey(TEXT("InfoTipGUID"));
    }
#if 0
    Extensionsaw.m_Dictionary[TEXT("CopyHook")] = m_bCopyHook? TEXT("TRUE") : TEXT("FALSE");
    Extensionsaw.m_Dictionary[TEXT("DataObject")] = m_bDataObject? TEXT("TRUE") : TEXT("FALSE");
    Extensionsaw.m_Dictionary[TEXT("DropTarget")] = m_bDropTarget? TEXT("TRUE") : TEXT("FALSE");
    Extensionsaw.m_Dictionary[TEXT("InfoTip")] = m_bInfoTip? TEXT("TRUE") : TEXT("FALSE");
#endif

    return bSomethingSelected;
;
}

void ShellExtensions::OnContextmenu() 
{
    UpdateData(TRUE);
    m_btnContextMenu2.EnableWindow(m_bContextMenu);
    m_btnContextMenu3.EnableWindow(m_bContextMenu);
    m_btnDragAndDrop.EnableWindow(m_bContextMenu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( shlobj )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( shlobj ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\cm.cpp ===
// $$ClassType$$CM.cpp : Implementation of C$$ClassType$$CM
#include "stdafx.h"
#include "$$root$$.h"
#include "$$ClassType$$CM.h"

#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))



#define IDI_EXECUTEITEM     0

/////////////////////////////////////////////////////////////////////////////
// CContents

HRESULT C$$ClassType$$CM::Initialize ( LPCITEMIDLIST pidlFolder,
                     LPDATAOBJECT lpdobj, 
                     HKEY hkeyProgID)
{
    // TODO: Extract items from the dataobject and Folder.

    return NOERROR;
}

HRESULT C$$ClassType$$CM::QueryContextMenu(HMENU hmenu,
                            UINT indexMenu,
                            UINT idCmdFirst,
                            UINT idCmdLast,
                            UINT uFlags)
{
    MENUITEMINFO mfi;
    UINT idCmd = idCmdFirst;

    if (idCmdFirst + IDI_EXECUTEITEM < idCmdLast)
    {
        // TODO: Chance this to match your item
        mfi.cbSize = sizeof(MENUITEMINFO);
        mfi.fMask = MIIM_ID|MIIM_TYPE;
        mfi.wID = idCmdFirst + IDI_EXECUTEITEM;
        mfi.fType = MFT_STRING;
        mfi.dwTypeData = (LPTSTR)TEXT("Example Item");

        idCmd++;
    }

    // TODO: Add more items here

    if (!InsertMenuItem(hmenu, indexMenu, TRUE, &mfi))
        idCmd--; // We weren't able to insert an item

    return ResultFromShort(idCmd - idCmdFirst);
}

HRESULT C$$ClassType$$CM::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    if (LOWORD(lpici->lpVerb) == IDI_EXECUTEITEM)
    {
        MessageBox(lpici->hwnd, "You Selected the example item", "C$$ClassType$$CM", MB_OK);
    }

    return NOERROR;
}

HRESULT C$$ClassType$$CM::GetCommandString(UINT  idCmd,
                            UINT        uType,
                            UINT      * pwReserved,
                            LPSTR       pszName,
                            UINT        cchMax)
{
    return E_NOTIMPL;
}

HRESULT C$$ClassType$$CM::HandleMenuMsg2(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             LRESULT* plResult)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        break;
    case WM_MEASUREITEM:
        break;
    case WM_DRAWITEM:
        break;
    case WM_MENUCHAR:
        lres = 0;   // Ignore the character, and issue a short beep.
        break;
    }

    if (plResult)
        *plResult = lres;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\cm.h ===
// $$ClassType$$CM.h : Declaration of the C$$ClassType$$CM

#ifndef __$$ClassType$$CM_H_
#define __$$ClassType$$CM_H_

#include "resource.h"       // main symbols
#include "shlobj.h"

/////////////////////////////////////////////////////////////////////////////
// CCM
class ATL_NO_VTABLE C$$ClassType$$CM : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<C$$ClassType$$CM, &CLSID_$$ClassType$$CM>,
	public IContextMenu3,
    public IShellExtInit
{

public:
	C$$ClassType$$CM()
	{
	}

    STDMETHODIMP Initialize ( LPCITEMIDLIST pidlFolder,
                         LPDATAOBJECT lpdobj, 
                         HKEY hkeyProgID);

    STDMETHODIMP QueryContextMenu( HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString( UINT idCmd,
                                UINT uType,
                                UINT* pwReserved,
                                LPSTR pszName,
                                UINT cchMax);

    STDMETHODIMP HandleMenuMsg(UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
    {   return HandleMenuMsg2(uMsg, wParam, lParam, NULL);  }


    STDMETHODIMP HandleMenuMsg2(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             LRESULT* plResult);


DECLARE_REGISTRY_RESOURCEID(IDR_SHELLEXTENSIONS)

BEGIN_COM_MAP(C$$ClassType$$CM)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IContextMenu)
	COM_INTERFACE_ENTRY(IContextMenu2)
	COM_INTERFACE_ENTRY(IContextMenu3)
END_COM_MAP()

public:
};

#endif //__$$ClassType$$CM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\shextdlg.h ===
#if !defined(AFX_SHELLEXTENSIONS_H__AA4DBA54_5D3E_11D1_8CCE_00C04FD918D0__INCLUDED_)
#define AFX_SHELLEXTENSIONS_H__AA4DBA54_5D3E_11D1_8CCE_00C04FD918D0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ShellExtensions.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// ShellExtensions dialog

class ShellExtensions : public CAppWizStepDlg
{
// Construction
public:
	ShellExtensions();   // standard constructor

// Dialog Data
	//{{AFX_DATA(ShellExtensions)
	enum { IDD = IDD_SHELLOPTIONS };
	CButton	m_btnDragAndDrop;
	CButton	m_btnContextMenu3;
	CButton	m_btnContextMenu2;
	BOOL	m_bContextMenu;
	BOOL	m_bContextMenu2;
	BOOL	m_bContextMenu3;
	BOOL	m_bCopyHook;
	BOOL	m_bDataObject;
	BOOL	m_bDragAndDrop;
	BOOL	m_bDropTarget;
	BOOL	m_bIcon;
	BOOL	m_bInfoTip;
	BOOL	m_bPropertySheet;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ShellExtensions)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL OnDismiss();

	// Generated message map functions
	//{{AFX_MSG(ShellExtensions)
	afx_msg void OnContextmenu();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHELLEXTENSIONS_H__AA4DBA54_5D3E_11D1_8CCE_00C04FD918D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\ei.cpp ===
// $$ClassType$$EI.cpp : Implementation of C$$ClassType$$EI
#include "stdafx.h"
#include "$$root$$.h"
#include "$$ClassType$$EI.h"

/////////////////////////////////////////////////////////////////////////////
// C$$ClassType$$EI

HRESULT C$$ClassType$$EI::Load(LPCOLESTR pszFileName,
                  DWORD dwMode)
{
    // TODO: Implement this function if the file itself 
    // contains the icon to be display (i.e. An image file)
    return NOERROR;
}

HRESULT C$$ClassType$$EI::GetIconLocation(UINT uFlags,
                         LPTSTR szIconFile,
                         UINT cchMax,
                         int* piIndex,
                         UINT* pwFlags)
{
    if (GetModuleFileName(_Module.GetModuleInstance(), szIconFile, cchMax))
    {
        *piIndex = 0;
        *pwFlags |= GIL_PERINSTANCE;
        return NOERROR;
    }
    return E_FAIL;
}

HRESULT C$$ClassType$$EI::Extract( LPCTSTR pszFile,
                                 UINT nIconIndex,
                                 HICON* phiconLarge,
                                 HICON* phiconSmall,
                                 UINT nIconSize)
{
    // TODO: Implement this function if the file itself 
    // contains the icon to be display (i.e. An image file)
    // and change the return type to NOERROR
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\it.h ===
// $$ClassType$$IT.h : Declaration of the C$$ClassType$$IT

#ifndef __IT_H_
#define __IT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// C$$ClassType$$IT
class ATL_NO_VTABLE C$$ClassType$$IT : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<C$$ClassType$$IT, &CLSID_$$ClassType$$IT>,
	public IPersistFile, public IQueryInfo
{
        WCHAR _wszFileName[MAX_PATH];
public:
	C$$ClassType$$IT()
	{
	}
    // IPersist methods

    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistFile methods

    STDMETHODIMP IsDirty(void)
        { return E_NOTIMPL; };
    STDMETHODIMP Save(LPCOLESTR pcwszFileName, BOOL bRemember)
        { return E_NOTIMPL; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pcwszFileName)
        { return E_NOTIMPL; };
    STDMETHODIMP Load(LPCOLESTR pcwszFileName, DWORD dwMode);

    STDMETHODIMP GetCurFile(LPOLESTR *ppwszFileName)
        { return E_NOTIMPL; };

    // IQueryInfo methods

    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

DECLARE_REGISTRY_RESOURCEID(IDR_SHELLEXTENSIONS)

BEGIN_COM_MAP(C$$ClassType$$IT)
	COM_INTERFACE_ENTRY(IPersistFile)
	COM_INTERFACE_ENTRY(IQueryInfo)
END_COM_MAP()

public:
};

#endif //__$$ClassType$$IT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\it.cpp ===
// $$ClassType$$IT.cpp : Implementation of C$$ClassType$$IT
#include "stdafx.h"
#include "InfoTipTest.h"
#include "$$ClassType$$IT.h"
#include "shlobj.h"

/////////////////////////////////////////////////////////////////////////////
// C$$ClassType$$IT

// IPersist methods

STDMETHODIMP C$$ClassType$$IT::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_$$ClassType$$IT;
    return NOERROR;
}

// IPersistFile methods

STDMETHODIMP C$$ClassType$$IT::Load(LPCOLESTR pcwszFileName, DWORD dwMode)
{
    lstrcpyW(_wszFileName, pcwszFileName);
    return NOERROR;
}

// IQueryInfo methods

STDMETHODIMP C$$ClassType$$IT::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    IShellLink* psl;
    HRESULT hres;
    hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, 
        (void **)&psl);

    if(SUCCEEDED(hres))
    {
        IPersistFile* ppf;
        hres = psl->QueryInterface(IID_IPersistFile, (void**)&ppf);
        if (SUCCEEDED(hres))
        {
            hres = ppf->Load(_wszFileName, 0);
            if (SUCCEEDED(hres))
            {
                TCHAR szTarget[MAX_PATH];

                hres = psl->GetPath(szTarget, MAX_PATH, NULL, 0);
                if (SUCCEEDED(hres))
                {
                    WCHAR* pwszOut = new WCHAR[MAX_PATH];
                    if (!pwszOut)
                        hres = E_OUTOFMEMORY;
                    else
                    {
                        MultiByteToWideChar(CP_ACP, 0, szTarget, -1, pwszOut, MAX_PATH);
                        *ppwszTip = pwszOut;

                        // Caller will free pszOut
                    }
                }
            }
            ppf->Release();
        }
        psl->Release();
    }

    return hres;
}

STDMETHODIMP C$$ClassType$$IT::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\ps.cpp ===
// C$$ClassType$$PS.cpp : Implementation of C$$ClassType$$PS
#include "stdafx.h"
#include "$$root$$.h"
#include "$$ClassType$$PS.h"

BOOL CALLBACK C$$ClassType$$PS_DlgProc(HWND hwnd, UINT uMsg, 
    WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = FALSE;
    static C$$ClassType$$PS* ppse = NULL;
    
    switch(uMsg)
    {
    case WM_INITDIALOG:
        ppse = (CPS*)lParam;
        bRet = TRUE;
        break;

    case WM_NOTIFY:
        switch(((NMHDR*)lParam)->code)
        {
        case PSN_APPLY:
            // TODO: Add code to apply changes in the dialog
            SetWindowLong(hwnd, DWL_MSGRESULT, TRUE);
            bRet = TRUE;
            break;
        case PSN_KILLACTIVE:
            // page is being deactivated either by another page being 
            // activated, or user chose OK.
            SetWindowLong(hwnd, DWL_MSGRESULT, FALSE);
            bRet = TRUE;
            break;
        case PSN_RESET:
            // TODO: Add any cleanup code 
            SetWindowLong(hwnd, DWL_MSGRESULT, FALSE);
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// C$$ClassType$$PS

STDMETHODIMP C$$ClassType$$PS::Initialize (LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, 
                     HKEY hkeyProgID)
{

    return NOERROR;
}

STDMETHODIMP C$$ClassType$$PS::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam)
{
    PROPSHEETPAGE psp;     
    HPROPSHEETPAGE hpage;  
    
    psp.dwSize      = sizeof(psp);   // no extra data 
    psp.dwFlags     = PSP_USEREFPARENT; 
    psp.hInstance   = _Module.GetModuleInstance(); 
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE); 
    psp.pfnDlgProc  = C$$ClassType$$PS_DlgProc;     
    psp.pcRefParent = (UINT*)&_Module.m_nLockCnt; 
    psp.lParam      = (LPARAM)this;  
    hpage = CreatePropertySheetPage(&psp);     
    if (hpage) 
    { 
        if (!lpfnAddPage(hpage, lParam)) 
            DestroyPropertySheetPage(hpage);     
    }
    return NOERROR;
}

STDMETHODIMP C$$ClassType$$PS::ReplacePage(UINT uPageID, 
    LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    // TODO: Implement this method if you want to replace a
    // Property page in a control panel 
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\ei.h ===
// $$ClassType$$EI.h : Declaration of the C$$ClassType$$EI

#ifndef __$$ClassType$$EI_H_
#define __$$ClassType$$EI_H_

#include "resource.h"       // main symbols
#include "shlobj.h"

/////////////////////////////////////////////////////////////////////////////
// CEI
class ATL_NO_VTABLE C$$ClassType$$EI : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<C$$ClassType$$EI, &CLSID_$$ClassType$$EI>,
    public IPersistFile, public IExtractIcon
{
public:
	C$$ClassType$$EI()
	{
	}
    STDMETHODIMP GetClassID(CLSID* pClassID)
        { return E_NOTIMPL; };

    STDMETHODIMP IsDirty(void)
        { return E_NOTIMPL; };
    
    STDMETHODIMP Load(LPCOLESTR pszFileName,
                      DWORD dwMode);
    
    STDMETHODIMP Save(LPCOLESTR pszFileName,
                      BOOL fRemember)
        { return E_NOTIMPL; };
    
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return E_NOTIMPL; };
    
    STDMETHODIMP GetCurFile(LPOLESTR*  ppszFileName)
        { return E_NOTIMPL; };

    STDMETHODIMP GetIconLocation( UINT   uFlags,
                             LPTSTR  szIconFile,
                             UINT   cchMax,
                             int   * piIndex,
                             UINT  * pwFlags);

    STDMETHODIMP Extract( LPCTSTR pszFile,
                     UINT   nIconIndex,
                     HICON   *phiconLarge,
                     HICON   *phiconSmall,
                     UINT    nIconSize);

DECLARE_REGISTRY_RESOURCEID(IDR_SHELLEXTENSIONS)

BEGIN_COM_MAP(C$$ClassType$$EI)
	COM_INTERFACE_ENTRY(IExtractIcon)
	COM_INTERFACE_ENTRY(IPersistFile)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

public:
};

#endif //__$$ClassType$$EI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\ps.h ===
// $$ClassType$$PS.h : Declaration of the C$$ClassType$$PS

#ifndef __$$ClassType$$PS_H_
#define __$$ClassType$$PS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// C$$ClassType$$PS
class ATL_NO_VTABLE C$$ClassType$$PS : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<C$$ClassType$$PS, &CLSID_$$ClassType$$PS>,
    public IShellPropSheetExt, public IShellExtInit
{
public:
    C$$ClassType$$PS()
    {
    }
    STDMETHODIMP Initialize (LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, 
                         HKEY hkeyProgID);

    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

DECLARE_REGISTRY_RESOURCEID(IDR_SHELLEXTENSIONS)

BEGIN_COM_MAP(C$$ClassType$$PS)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

public:
};

#endif //__$$ClassType$$PS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\root.cpp ===
// $$root$$.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ShellExtensionsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "$$root$$.h"

#include "ShellExtensions_i.c"
$$IF(Icon)
#include "$$ClassType$$EI.h"
$$ENDIF
$$IF(ContextMenu)
#include "$$ClassType$$CM.h"
$$ENDIF
$$IF(PropertySheet)
#include "$$ClassType$$PS.h"
$$ENDIF
$$IF(InfoTip)
#include "$$ClassType$$IT.h"
$$ENDIF


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
$$IF(Icon)
	OBJECT_ENTRY(CLSID_$$ClassType$$EI, C$$ClassType$$EI)
$$ENDIF
$$IF(ContextMenu)
	OBJECT_ENTRY(CLSID_$$ClassType$$CM, C$$ClassType$$CM)
$$ENDIF
$$IF(PropertySheet)
	OBJECT_ENTRY(CLSID_$$ClassType$$PS, C$$ClassType$$PS)
$$ENDIF
$$IF(InfoTip)
	OBJECT_ENTRY(CLSID_$$ClassType$$IT, C$$ClassType$$IT)
$$ENDIF
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8DEDB8E8_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_)
#define AFX_STDAFX_H__8DEDB8E8_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8DEDB8E8_5C6D_11D1_8CCD_00C04FD918D0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by $$root$$.rc
//
#define IDS_PROJNAME                    100
#define IDR_SHELLEXTENSIONS             101
#define IDI_ICON1                       201
#define IDD_PROPPAGE                    301

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\extwiz\template\root.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Nov 14 11:20:18 1997
 */
/* Compiler settings for ShellExtensions.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __ShellExtensions_h__
#define __ShellExtensions_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __EI_FWD_DEFINED__
#define __EI_FWD_DEFINED__

#ifdef __cplusplus
typedef class EI EI;
#else
typedef struct EI EI;
#endif /* __cplusplus */

#endif 	/* __EI_FWD_DEFINED__ */


#ifndef __CM_FWD_DEFINED__
#define __CM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CM CM;
#else
typedef struct CM CM;
#endif /* __cplusplus */

#endif 	/* __CM_FWD_DEFINED__ */


#ifndef __PS_FWD_DEFINED__
#define __PS_FWD_DEFINED__

#ifdef __cplusplus
typedef class PS PS;
#else
typedef struct PS PS;
#endif /* __cplusplus */

#endif 	/* __PS_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "shlobj.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ShellExtensionsLib_LIBRARY_DEFINED__
#define __ShellExtensionsLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ShellExtensionsLib
 * at Fri Nov 14 11:20:18 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_ShellExtensionsLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_EI;

class DECLSPEC_UUID("B0C53C9E-5B8D-11D1-8CC9-00C04FD918D0")
EI;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CM;

class DECLSPEC_UUID("D571A8F6-5AE0-11D1-8CC9-00C04FD918D0")
CM;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PS;

class DECLSPEC_UUID("8DEDB8E3-5C6D-11D1-8CCD-00C04FD918D0")
PS;
#endif
#endif /* __ShellExtensionsLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie30.c ===
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#undef _WIN32_IE
#define _WIN32_IE 0x0300
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie10.c ===
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#undef _WIN32_IE
#define _WIN32_IE 0x0100

#include <windows.h>
#include <shfusion.h>
#include <shlobj.h>
#include <shlobjp.h>

// Do the work in the lowest version number to ensure we are maximally
// downlevel-compatible.

int __cdecl main(int argc, char **argv)
{
    // That's right, we call SHFusionInitialize with NULL.  But that's
    // okay because this program doesn't actually run.  We just want to
    // make sure it builds and links.
    //
    SHFusionInitialize(0);
    SHFusionUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie40.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0400
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie50.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0500
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie51.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0501
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie55.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0550
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\hdrver\ie60.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0600
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\reginst\debug.c ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "tests.ini"
#define SZ_DEBUGSECTION     "ICONVIEW"
#define SZ_MODULE           "ICONVIEW"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\netplwiz\netplwizexe.c ===
#include "windows.h"
#include "windowsx.h"
#include "stdio.h"
#include "shlobj.h"

#define VERSION TEXT("0.00")
#define SIZEOF(x) sizeof(x)
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

typedef HRESULT(*PFNNETACCESSWIZARD)(HWND,UINT,BOOL*);

int UsageErr()
{
    fprintf(stderr, TEXT("netplwizexe: [NAW_NETID|NAW_PSDOMAINJOINFAILED|NAW_PSDOMAINJOINED]\n"));
    return -1;
}

INT __cdecl main(INT cArgs, LPTSTR pArgs[])
{
    UINT nid;
    HMODULE hLib;

    if (cArgs < 1)
        return UsageErr();

    if (!lstrcmp(pArgs[1], TEXT("NAW_NETID")))
        nid = NAW_NETID;
    else if (!lstrcmp(pArgs[1], TEXT("NAW_PSDOMAINJOINFAILED")))
        nid = NAW_PSDOMAINJOINFAILED;
    else if (!lstrcmp(pArgs[1], TEXT("NAW_PSDOMAINJOINED")))
        nid = NAW_PSDOMAINJOINED;
    else
        return UsageErr();

    hLib = LoadLibrary(TEXT("netplwiz.dll"));
    if (hLib)
    {
        PFNNETACCESSWIZARD pfnNetAccessWizard;
        pfnNetAccessWizard = (PFNNETACCESSWIZARD)GetProcAddress(hLib, TEXT("NetAccessWizard"));
        if (pfnNetAccessWizard)
        {
            HRESULT hr;
            BOOL fReboot;

            hr = pfnNetAccessWizard(NULL, nid, &fReboot);

            fprintf(stderr, TEXT("netplwizexe: hr=%X %s\n"), hr, fReboot?TEXT("REBOOT"):TEXT("NO reboot"));
        }
        else
        {
            fprintf(stderr, TEXT("netplwizexe: can not GetProcAddress(\"NetAccessWizard\")\n"));
        }
    }
    else
    {
        fprintf(stderr, TEXT("netplwizexe: can not LoadLibrary(\"netplwiz.dll\")\n"));
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\packchk\makefile.inc ===
$O\packchk1.inc $O\packchk2.inc: sources $(HEADERFILESTOCHECK)
    perl mkinc.pl -1$O\packchk1.inc -2$O\packchk2.inc $(HEADERFILESTOCHECK)

clean:
    del $O\packchk1.inc $O\packchk2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\regdate\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <windows.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
#else
int __cdecl main(int argc, char* argv[])
#endif
{
    HKEY hkey;
    FILETIME ft = {0};
    SYSTEMTIME st = {0};
    PBYTE pb = (PBYTE)&ft;

    GetSystemTimeAsFileTime(&ft);

    if (FileTimeToSystemTime(&ft, &st))
    {
        _tprintf(TEXT("\nTime: %04d-%02d-%02d %02d:%02d:%02d:%04d\n\n"), st.wYear,
            st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
            st.wMilliseconds);
    }

    _tprintf(TEXT("Put this in devxprop.inx:\n"));
    _tprintf(TEXT("HKLM,\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerHwIdStorage\",\"LastUpdateTime\",1,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x\n"),
        pb[0], pb[1], pb[2], pb[3], pb[4], pb[5], pb[6], pb[7]);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
        TEXT("Software\\Microsoft\\Test"), 0, NULL,
        REG_OPTION_VOLATILE, MAXIMUM_ALLOWED, NULL, &hkey, NULL))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey, TEXT("LastUpdateTimeCompare"),
            NULL, REG_BINARY, (PBYTE)&ft, sizeof(ft)))
        {
            _tprintf(TEXT("\n> Successfully written value HKCU\\Software\\Microsoft\\Test!LastUpdateTime for comparison.\n"));
        }        

        CloseHandle(hkey);
    }

    return 0;
}                       
#ifdef UNICODE
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\packchk\packchk.cpp ===
/*****************************************************************************
 *
 *  packchk.cpp
 *
 *  Tool-like thing that lets you check that you didn't mess up any
 *  structure packing.
 *
 *****************************************************************************/

#define STRICT
#include <windows.h>

/* Header file hacks */

#include <wininet.h>            /* needed by shlobj to get all structures defined */
#include <oaidl.h>              /* needed by shlwapip to get all structures defined */

typedef BYTE ADJUSTINFO;        /* hack for comctrlp.h - Win16-only structure */
typedef BYTE EDITMENU;          /* hack for commdlg.h - MAC-only structure */
#define UXCTRL_VERSION 0x0100   /* Get all the new UXCTRL structures */

#include "packchk1.inc"

typedef struct PACKTABLE {
    LPCSTR pszHeader;
    LPCSTR pszName;
    UINT cb;
} PACKTABLE;

#define _(S) { H, #S, sizeof(S) },

const PACKTABLE c_rgpt[] = {
#include "packchk2.inc"
};

#define cpt (sizeof(c_rgpt)/sizeof(c_rgpt[0]))

int PASCAL
IWinMain(HINSTANCE hinst, LPCTSTR ptszCmdLine)
{
    int i;
    for (i = 0; i < cpt; i++) {
        char szBuf[1024];
        int cch;
        cch = wsprintf(szBuf, "%s,%s,%d\r\n",
                       c_rgpt[i].pszHeader,
                       c_rgpt[i].pszName, c_rgpt[i].cb);
        _lwrite(PtrToLong(GetStdHandle(STD_OUTPUT_HANDLE)), szBuf, cch);
    }

    return 0;
}

EXTERN_C void PASCAL
Entry(void)
{
    LPCTSTR ptszCmdLine = GetCommandLine();

    if (*ptszCmdLine == '"') {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while (*(ptszCmdLine = CharNext(ptszCmdLine)) && *ptszCmdLine != '"');
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if (*ptszCmdLine == '"') ptszCmdLine = CharNext(ptszCmdLine);
    } else {
        while (*ptszCmdLine > ' ') ptszCmdLine = CharNext(ptszCmdLine);
    }

    /*
     * Skip past any white space preceding the second token.
     */
    while (*ptszCmdLine && *ptszCmdLine <= ' ') ptszCmdLine = CharNext(ptszCmdLine);

    ExitProcess(IWinMain(GetModuleHandle(0), ptszCmdLine));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\reginst\app.cpp ===
#include "priv.h"       

const TCHAR c_szAppName[]   = TEXT("reginst");
const TCHAR c_szDllReg[]    = TEXT("DllRegisterServer");
const TCHAR c_szDllUnreg[]  = TEXT("DllUnregisterServer");

typedef HRESULT (CALLBACK* DLLREGPROC)(void);
typedef HRESULT (CALLBACK* DLLINSTALLPROC)(BOOL bInstall, LPCWSTR pszCmdLine);

HINSTANCE g_hinst;

#define RIF_QUIET       0x00000001
#define RIF_UNINSTALL   0x00000002
#define RIF_INSTALLONLY 0x00000004
#define RIF_REGONLY     0x00000008
#define RIF_HELP        0x00000010

// Don't link to shlwapi.dll so this is a stand-alone tool

/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

Returns: --
Cond:    --
*/
void
PathUnquoteSpaces(
    LPTSTR lpsz)
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = TEXT('\0');
        hmemcpy(lpsz, lpsz+1, (cch-1) * SIZEOF(TCHAR));
    }
}


// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// "foo.exe bar.txt"    -> "bar.txt"
// "foo.exe"            -> ""
//
// Spaces in filenames must be quoted.
// " "A long name.txt" bar.txt " -> "bar.txt"

LPTSTR
PathGetArgs(
    LPCTSTR pszPath)
{
    BOOL fInQuotes = FALSE;

    if (!pszPath)
            return NULL;

    while (*pszPath)
    {
        if (*pszPath == TEXT('"'))
            fInQuotes = !fInQuotes;
        else if (!fInQuotes && *pszPath == TEXT(' '))
            return (LPTSTR)pszPath+1;
        pszPath = CharNext(pszPath);
    }

    return (LPTSTR)pszPath;
}


__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


LPSTR FAR PASCAL StrChrA(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

BOOL
StrTrim(
    IN OUT LPSTR  pszTrimMe,
    IN     LPCSTR pszTrimChars)
    {
    BOOL bRet = FALSE;
    LPSTR psz;
    LPSTR pszStartMeat;
    LPSTR pszMark = NULL;

    ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    ASSERT(IS_VALID_STRING_PTRA(pszTrimChars, -1));

    if (pszTrimMe)
    {
        /* Trim leading characters. */

        psz = pszTrimMe;

        while (*psz && StrChrA(pszTrimChars, *psz))
            psz = CharNextA(psz);

        pszStartMeat = psz;

        /* Trim trailing characters. */

        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)

        while (*psz)
            {
            if (StrChrA(pszTrimChars, *psz))
                {
                pszMark = psz;
                }
            else
                {
                pszMark = NULL;
                }
            psz = CharNextA(psz);
            }

        // Any trailing characters to clip?
        if (pszMark)
            {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
            }

        /* Relocate stripped string. */

        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchA(lstrlenA(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);

        ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    }

    return bRet;
    }


HRESULT ParseOption(LPCTSTR * ppsz, LPDWORD pdwFlags)
{
    HRESULT hres = S_FALSE;
    LPCTSTR psz = *ppsz;

    // Skip any leading whitespace
    while (*psz && (' ' == *psz || '\t' == *psz))
        psz++;

    if ('/' == *psz || '-' == *psz)
    {
        hres = S_OK;

        psz++;
        switch (*psz)
        {
        case '?':
            *pdwFlags |= RIF_HELP;
            break;

        case 'q':
            *pdwFlags |= RIF_QUIET;
            break;

        case 'u':
            *pdwFlags |= RIF_UNINSTALL;
            break;

        case 'i':
            *pdwFlags |= RIF_INSTALLONLY;
            break;

        case 'r':
            *pdwFlags |= RIF_REGONLY;
            break;

        default:
            hres = E_FAIL;
            break;
        }

        // Return the new position in the string
        *ppsz = psz+1;
    }
    else
    {
        *ppsz = psz;
    }

    return hres;
}   


HRESULT CallInstall(UINT * pids, DLLREGPROC pfnRegSvr, DLLINSTALLPROC pfnInstall, BOOL bInstall, LPCWSTR psz)
{
    HRESULT hres = S_OK;

    ASSERT(NULL == pfnRegSvr || IS_VALID_CODE_PTR(pfnRegSvr, DLLREGPROC));
    ASSERT(NULL == pfnInstall || IS_VALID_CODE_PTR(pfnInstall, DLLINSTALLPROC));
    ASSERT(IS_VALID_STRING_PTRW(psz, -1));

    _try
    {
        if (pfnRegSvr)
        {
            hres = pfnRegSvr();
            
            if (FAILED(hres))
                *pids = IDS_INSTALLFAILED;
            else
                *pids = IDS_REGSUCCESS;
        }

        if (SUCCEEDED(hres) && pfnInstall)
        {
            hres = pfnInstall(bInstall, psz);
            
            if (FAILED(hres))
                *pids = IDS_INSTALLFAILED;
            else
                *pids = IDS_INSTALLSUCCESS;
            
        }
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
        hres = E_UNEXPECTED;
        *pids = IDS_UNEXPECTED;
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: Worker function to do the work

         reginst /q /u /i /r foo.dll <cmdline>

            /q  Quiet
            /u  Uninstall

         Calls both DllInstall and DllRegisterServer unless:

            /i  Call DllInstall only
            /r  Call DllRegisterServer/DllUnregisterServer only

         <cmdline> is passed to DllInstall if it exists.

*/
HRESULT
DoWork(HWND hwnd, LPCTSTR pszCmdLine)
{
    TCHAR szDll[MAX_PATH];
    WCHAR wszArgs[MAX_PATH];
    LPCTSTR psz;
    LPCTSTR pszArgs;
    DWORD dwFlags = 0;
    HRESULT hres;
    UINT ids = 0;
    LPCTSTR pszFnError = NULL;


    // Options come first
    psz = PathGetArgs(pszCmdLine);

    while (S_OK == (hres = ParseOption(&psz, &dwFlags)))
        ;  // Loop thru options

    if (dwFlags & RIF_HELP)
    {
        ids = IDS_HELP;
        hres = S_OK;
    }
    else
    {
        // Now psz should point at DLL or null terminator
        lstrcpyn(szDll, psz, SIZECHARS(szDll));

        // Strip off args from the dll name
        LPTSTR pszT = PathGetArgs(szDll);
        if (*pszT)
            *pszT = 0;
        StrTrim(szDll, " \t");
        PathUnquoteSpaces(szDll);

        // Get args to pass to DllInstall
        pszArgs = PathGetArgs(psz);
        MultiByteToWideChar(CP_ACP, 0, pszArgs, -1, wszArgs, SIZECHARS(wszArgs));

        HINSTANCE hinst = LoadLibrary(szDll);
        if (hinst)
        {
            DLLREGPROC pfnRegSvr = NULL;
            DLLINSTALLPROC pfnInstall = NULL;
            
            hres = S_OK;

            if (IsFlagClear(dwFlags, RIF_INSTALLONLY))
            {
                if (dwFlags & RIF_UNINSTALL)
                {
                    pfnRegSvr = (DLLREGPROC)GetProcAddress(hinst, "DllUnregisterServer");
                    pszFnError = c_szDllUnreg;
                }
                else
                {
                    pfnRegSvr = (DLLREGPROC)GetProcAddress(hinst, "DllRegisterServer");
                    pszFnError = c_szDllReg;
                }
            }

            if (IsFlagClear(dwFlags, RIF_REGONLY))
            {
                pfnInstall = (DLLINSTALLPROC)GetProcAddress(hinst, "DllInstall");
                pszFnError = TEXT("DllInstall");
            }

            if (NULL == pfnInstall && NULL == pfnRegSvr)
            {
                ids = IDS_FAILED;
                hres = E_FAIL;
            }
            else
            {
                hres = CallInstall(&ids, pfnRegSvr, pfnInstall, IsFlagClear(dwFlags, RIF_UNINSTALL), wszArgs);

                if (SUCCEEDED(hres))
                {
                    if (pfnRegSvr && pfnInstall)
                        ids = IDS_FULLSUCCESS;
                    
                    if (IsFlagSet(dwFlags, RIF_UNINSTALL))
                    {
                        // refer to "uninstall" msgs instead
                        ids += (IDS_UNREGSUCCESS - IDS_REGSUCCESS);   
                    }
                }
            }

            FreeLibrary(hinst);
        }
        else 
        {
            ids = IDS_LOADFAILED;
            hres = E_FAIL;
        }
    }


    if (0 != ids && IsFlagClear(dwFlags, RIF_QUIET))
    {
        TCHAR szFmt[512];
        TCHAR szMsg[1024];
        TCHAR szT[32];
        LPCTSTR rgpsz[2];
        UINT uFlags = MB_OK;

        rgpsz[0] = szDll;
        rgpsz[1] = pszFnError;

        LoadString(g_hinst, IDS_TITLE, szT, SIZECHARS(szT));
        LoadString(g_hinst, ids, szFmt, SIZECHARS(szFmt));

        FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                      szFmt, 0, 0, szMsg, SIZECHARS(szMsg), (va_list *)rgpsz);

        switch (ids)
        {
        case IDS_UNEXPECTED:
            uFlags |= MB_ICONERROR;
            break;

        case IDS_FAILED:
        case IDS_LOADFAILED:
        case IDS_INSTALLFAILED:
            uFlags |= MB_ICONWARNING;
            break;

        default:
            uFlags |= MB_ICONINFORMATION;
            break;
        }
        MessageBox(hwnd, szMsg, szT, uFlags);
    }
    return hres;
}


// stolen from the CRT, used to shrink our code

int 
_stdcall 
ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), 
                NULL, 
                pszCmdLine,
                (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;           // We never come here
}


/*----------------------------------------------------------
Purpose: Stub window proc

Returns: 
Cond:    --
*/
LRESULT 
CALLBACK 
WndProc(
    HWND hWnd, 
    UINT iMessage, 
    WPARAM wParam, 
    LPARAM lParam)
{
    switch(iMessage)
    {
    case WM_CREATE:
            break;

    case WM_DESTROY:
            break;

    default:
            return DefWindowProc(hWnd, iMessage, wParam, lParam);
            break;
    }

    return 0L;
}


/*----------------------------------------------------------
Purpose: Initialize a stub window

Returns: 
Cond:    --
*/
BOOL 
InitStubWindow(
    IN  HINSTANCE hInst, 
    IN  HINSTANCE hPrevInstance,
    OUT HWND *    phwnd)
{
    WNDCLASS wndclass;

    if (!hPrevInstance)
    {
        wndclass.style         = 0 ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInst ;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wndclass.lpszMenuName  = NULL ;
        wndclass.lpszClassName = c_szAppName;

        if (!RegisterClass(&wndclass))
        {
            return(FALSE);
        }
    }

    *phwnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                            c_szAppName, 
                            TEXT(""), 
                            WS_OVERLAPPED, 
                            CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, 
                            NULL, NULL, hInst, NULL);

    return (NULL != *phwnd);
}


/*----------------------------------------------------------
Purpose: WinMain

Returns: 
Cond:    --
*/
int 
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance, 
    LPTSTR pszCmdLine, 
    int nCmdShow)
{
    HWND hwndStub;
    int nRet = 0;

    g_hinst = hInstance;

#ifdef DEBUG

    CcshellGetDebugFlags();

    if (IsFlagSet(g_dwBreakFlags, BF_ONOPEN))
        DebugBreak();

#endif

    // turn off critical error stuff
    SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    if (InitStubWindow(hInstance, hPrevInstance, &hwndStub))
    {
        // Do work here
        nRet = DoWork(hwndStub, pszCmdLine);

        DestroyWindow(hwndStub);
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\reginst\resource.h ===
#define IDS_HELP            1
#define IDS_FAILED          2
#define IDS_LOADFAILED      3
#define IDS_INSTALLFAILED   4
#define IDS_TITLE           5
#define IDS_REGSUCCESS      6
#define IDS_INSTALLSUCCESS  7
#define IDS_FULLSUCCESS     8
#define IDS_UNREGSUCCESS      9
#define IDS_UNINSTALLSUCCESS  10
#define IDS_UNFULLSUCCESS     11
#define IDS_UNEXPECTED        12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\reginst\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <windowsx.h>

#include <ccstock.h>
#include <debug.h>

#ifdef __cplusplus
#include <shstr.h>
#endif

#include "resource.h"

// Dump and trace flags
#define BF_ONOPEN       0x00000010


#ifdef __cplusplus
}
#endif

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\genuedef.c ===
LIBRARY SHLEXTS

; DESCRIPTION is obsolete and gives the IA64 linker the heebie-jeebies
;DESCRIPTION 'SHELL Debugger Extensions'

;
; This file generates shlexts.def. This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to shlexts.c
;

//#ifdef _FE_
//#define FE_IME 1
//#endif

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\drawicon.cpp ===
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
};

#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))
#define MIN_WIDTH     96 
#define MIN_HEIGHT    64
#define BORDER_WIDTH  32 

typedef struct _DRAW_ICON_STRUCT
{
    HBITMAP hBitmap;
    BYTE* psBits;
    BITMAPINFO bmi;
    HICON hIcon;
    int zoom;
} DRAW_ICON_STRUCT;

/************************************************************************\
* Procedure: CreateDIBSectionFromIcon
*
* Description:
*
*     Creates a DIB section given the handle to an icon
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
BOOL CreateDIBSectionFromIcon(DRAW_ICON_STRUCT* pDIS)
{
    ICONINFO info;

    if (!pDIS->hIcon)
    {
        Print("Invalid HICON handle\n");
        return FALSE;
    }

    if (GetIconInfo (pDIS->hIcon, &info))
    {
        HDC     hdc = NULL;
        HDC		dc  = NULL;
        HBRUSH	hBrush  = NULL;
        BITMAP	bitmap;
        
        hdc = CreateDC(L"DISPLAY", NULL, NULL, NULL);
        if (!hdc)
        {
            Print("CreateDC failed\n");
            return FALSE;
        }
            
        dc = CreateCompatibleDC(hdc);
        if (!dc)
        {
            Print("CreateCompatiblDC failed\n");
            return FALSE;
        }
                                                                                                                                                                                                                                                       
        if (!GetObject (info.hbmColor, sizeof (BITMAP), &bitmap))
        {
            Print("GetObject failed\n");
            return FALSE;
        }

        pDIS->bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
        pDIS->bmi.bmiHeader.biWidth    = bitmap.bmWidth;
        pDIS->bmi.bmiHeader.biHeight   = bitmap.bmHeight;
        pDIS->bmi.bmiHeader.biPlanes   = 1;
        pDIS->bmi.bmiHeader.biBitCount = bitmap.bmPlanes * bitmap.bmBitsPixel;
        
        if (pDIS->bmi.bmiHeader.biBitCount <= 1)
        {
            pDIS->bmi.bmiHeader.biBitCount = 1;
        }
        else if (pDIS->bmi.bmiHeader.biBitCount <= 4) 
        {
            pDIS->bmi.bmiHeader.biBitCount = 4;
        }
        else if (pDIS->bmi.bmiHeader.biBitCount <= 8)
        {
            pDIS->bmi.bmiHeader.biBitCount = 8;
        }
        else
        {
            pDIS->bmi.bmiHeader.biBitCount = 24;
        }
        
        pDIS->bmi.bmiHeader.biCompression = BI_RGB;
        
        // Create a DIB section so we don't have to worry about the display settings
        pDIS->hBitmap = CreateDIBSection(dc, (const BITMAPINFO *)&pDIS->bmi, DIB_RGB_COLORS, (void**)&pDIS->psBits, NULL, 0); 
        if (pDIS->hBitmap == NULL)
        {
            Print("CreateDIBSection failed\n");
            return FALSE;
        }
        
        SelectObject (dc, pDIS->hBitmap);
        hBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
        DrawIconEx (dc, 0, 0, pDIS->hIcon, 0, 0, 0, hBrush, DI_NORMAL);
        
        if (NULL == pDIS->psBits)
        {
            Print("CreateDIBSection failed.\n");
            return FALSE;
        }

        DeleteObject (info.hbmMask);
        DeleteObject (info.hbmColor);
        DeleteDC (hdc);
        DeleteDC (dc);
    }
        
    return TRUE;
}

/************************************************************************\
* Procedure: ZoomIn
*
* Description:
*
*     Zooms the window in by a factor of 2
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
void ZoomIn(HWND hwnd)
{
    DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    int w, h;
            
    pDIS->zoom++;

    w = pDIS->bmi.bmiHeader.biWidth * pDIS->zoom + BORDER_WIDTH;
    h = pDIS->bmi.bmiHeader.biHeight * pDIS->zoom + BORDER_WIDTH;
 
    if (w < MIN_WIDTH) w = MIN_WIDTH;
    if (h < MIN_HEIGHT) h = MIN_HEIGHT;
    
    SetWindowPos(hwnd, 0, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
    InvalidateRect(hwnd, NULL, TRUE);
}

/************************************************************************\
* Procedure: ZoomOut
*
* Description:
*
*     Zooms the window out by a factor of 2
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
void ZoomOut(HWND hwnd)
{
    DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    pDIS->zoom--;

    if (pDIS->zoom < 1)
    { 
        pDIS->zoom = 1;
    }
    else
    {
        int w = pDIS->bmi.bmiHeader.biWidth * pDIS->zoom + BORDER_WIDTH;
        int h = pDIS->bmi.bmiHeader.biHeight * pDIS->zoom + BORDER_WIDTH;
            
        if (w < MIN_WIDTH) w = MIN_WIDTH;
        if (h < MIN_HEIGHT) h = MIN_HEIGHT;
    
        SetWindowPos(hwnd, 0, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        InvalidateRect(hwnd, NULL, TRUE);
    }
}

/************************************************************************\
* Procedure: WndProc
*
* Description:
*
*     The wndproc for the icon window
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_NCHITTEST: return HTCAPTION;
        
        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            HDC buf = CreateCompatibleDC(hdc);
            HBITMAP oldbuf;
            RECT r;
            DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            
            GetClientRect(hwnd, &r);
            FillRect(hdc, &r, (HBRUSH)GetStockObject(WHITE_BRUSH));
            
            if (pDIS)
            {
                int x, y, w, h;
 
                w = pDIS->bmi.bmiHeader.biWidth * pDIS->zoom;
                h = pDIS->bmi.bmiHeader.biHeight * pDIS->zoom;
                
                x = r.right/2 - w/2;
                y = r.bottom/2 - h/2;
                
                oldbuf = (HBITMAP)SelectObject(buf, pDIS->hBitmap);
                StretchBlt(hdc, x, y, w, h, buf, 0, 0, w/pDIS->zoom, h/pDIS->zoom, SRCCOPY);
            }

            SelectObject(buf, oldbuf);
            DeleteDC(buf);
            EndPaint(hwnd, &ps);
        }
        break;
        
        case WM_NCLBUTTONDBLCLK:
        {
            ZoomIn(hwnd);
        }
        break;
        
        case WM_NCRBUTTONDBLCLK:
        {
            ZoomOut(hwnd);
        }
        break;
        
        case WM_KEYDOWN:
        {
            switch (wParam)
            {
                case 187: // '+'
                {
                    ZoomIn(hwnd);
                }
                break;

                case 189: // '-'
                {
                    ZoomOut(hwnd);
                }
                break;

                case 81: // 'q'
                {
                    PostQuitMessage(0);
                }
                break;

                /*default:
                {
                    TCHAR szTemp[256];
                    wsprintf(szTemp, L"%d", wParam);
                    MessageBox(hwnd, szTemp, szTemp, MB_OK);
                }
                break;*/
            }
            break;
        }
        break;
        
        case WM_SYSCOMMAND:
        {
            switch (wParam)
            {
                case SC_CLOSE:
                {
                    PostQuitMessage(0);
                }
                break;
            }
        }
        break;

        case WM_TIMER:
        {
            if (IsCtrlCHit())
            {
                PostQuitMessage(0);
            }
        }
        break;
    }
 
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/************************************************************************\
* Procedure: DrawIconWindow
*
* Description:
*
*     Draws the icon in a window on the remote side
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
DWORD WINAPI DrawIconWindow(LPVOID inpDIS)
{
    MSG msg;
	WNDCLASS wc;
    HWND hwnd;
    DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)inpDIS;
    LPCTSTR szClassName = L"ntsd - drawicon";
    TCHAR szTitle[32] = {0};
    int w, h;

	memset(&wc,0,sizeof(wc));
	wc.lpfnWndProc = WndProc;
	wc.hInstance = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.style = CS_DBLCLKS;
	wc.lpszClassName = szClassName;
	RegisterClass(&wc);

    w = pDIS->bmi.bmiHeader.biWidth + BORDER_WIDTH; 
    h = pDIS->bmi.bmiHeader.biHeight + BORDER_WIDTH; 

    if (w < MIN_WIDTH)  w = MIN_WIDTH;
    if (h < MIN_HEIGHT) h = MIN_HEIGHT;

    wsprintf(szTitle, L"%08x", pDIS->hIcon);
	hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, 
                          szClassName, szTitle, 
                          WS_POPUPWINDOW | WS_CAPTION | WS_VISIBLE, 
                          10, 10, 
                          w, h,
                          NULL, NULL, NULL, NULL);
	if (!hwnd) return FALSE;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDIS);
    SetTimer(hwnd, 0, 100, NULL);
    SetForegroundWindow(hwnd);
    SetFocus(hwnd);

	while (GetMessage(&msg, (HWND) NULL, 0, 0))
	{ 
		TranslateMessage(&msg); 
		DispatchMessage(&msg); 
    }

    KillTimer(hwnd, 0);
    DestroyWindow(hwnd);
    UnregisterClass(szClassName, NULL);
    return TRUE;
}

/************************************************************************\
* Procedure: DrawIconASCII
*
* Description:
*
*     Prints the icon in ASCII format through the ntsd session
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
BOOL DrawIconASCII(DRAW_ICON_STRUCT* pDIS, BOOL bColor)
{
    HANDLE hConsole;
    DWORD dwWritten;
    WORD wOldColorAttrs; 
    CONSOLE_SCREEN_BUFFER_INFO csbiInfo; 
    

    if (bColor)
    {
        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hConsole)
        {
            if (!GetConsoleScreenBufferInfo(hConsole, &csbiInfo)) 
            {
                bColor = FALSE;
            }
        }
        else
        {
            bColor = FALSE;
        }
        
        wOldColorAttrs = csbiInfo.wAttributes; 
    }

/*
    // Uncomment this to get a nice big list of all the chars to choose from
    for (int x = 0; x < 256; x++)
    {
        TCHAR szPrint[10];
        wsprintf(szPrint, L"%d = %c\n", x, x);
        WriteConsole(hConsole, szPrint, lstrlen(szPrint), &dwWritten, NULL);
    }
*/
    
    for (int y = pDIS->bmi.bmiHeader.biHeight*3 - 3; y; y-=3)
    {
        int Offset = y * pDIS->bmi.bmiHeader.biWidth;
                
        for (int x = 0; x < pDIS->bmi.bmiHeader.biWidth*3; x+=3)
        {
            RGBQUAD* prgb = (RGBQUAD*)&pDIS->psBits[x + Offset];

            if (bColor)
            {
                TCHAR szPrint[3];
                WORD wForeground = 0;

                if (prgb->rgbRed > 128)
                {
                    wForeground |= FOREGROUND_RED;
                }

                if (prgb->rgbGreen > 128)
                {
                    wForeground |= FOREGROUND_GREEN;
                }
            
                if (prgb->rgbBlue > 128)
                {
                    wForeground |= FOREGROUND_BLUE;
                }

                if (prgb->rgbRed > 192 || prgb->rgbGreen > 192 || prgb->rgbBlue > 192)
                {
                    wForeground |= FOREGROUND_INTENSITY;
                }

                SetConsoleTextAttribute(hConsole, wForeground);
                wsprintf(szPrint, L"%c%c", 15, 15);
                WriteConsole(hConsole, szPrint, 2, &dwWritten, NULL);
            }
            else
            {
                int val = (prgb->rgbRed + prgb->rgbGreen + prgb->rgbBlue) / 3; 

                if (val > 0 && val <= 25) Print("  ");
                else if (val > 25 && val <= 100)  Print("%c%c", 176, 176);
                else if (val > 100 && val <= 165) Print("%c%c", 177, 177);
                else if (val > 165 && val <= 215) Print("%c%c", 178, 178);
                else if (val > 215 && val <= 255) Print("%c%c", 219, 219);
                else Print("  ");
            }
        }
        
        if (bColor)
        {
            WriteConsole(hConsole, L"\n", 1, &dwWritten, NULL);
        }
        else
        {
            Print("\n");
        }
    }
 
    if (bColor)
    {
        WriteConsole(hConsole, L"\n", 1, &dwWritten, NULL);
        SetConsoleTextAttribute(hConsole, wOldColorAttrs);
    }
    else
    {
        Print("\n");
    }

    return TRUE;
}

/************************************************************************\
* Procedure: Idrawicon
*
* Description:
*
*     Draws the given icon in ASCII or in a popup window
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
extern "C" BOOL Idrawicon(DWORD dwOpts,
                          LPVOID pArg )
{
    DRAW_ICON_STRUCT DIS;
    BOOL ret=FALSE;
    HICON hIcon = (HICON)pArg;
            
    DIS.zoom = 1;
    DIS.hIcon = hIcon;

    ret = CreateDIBSectionFromIcon(&DIS);
 
    if (ret)
    {
        if (OFLAG(w) & dwOpts)
        {
            ret = DrawIconWindow(&DIS);
        }
        else
        {
            ret = DrawIconASCII(&DIS, (OFLAG(c) & dwOpts)? TRUE : FALSE);
        }
        
        DeleteObject(DIS.hBitmap);
    }
    
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
* 10/28/97 butchered by cdturner to work for the shell team
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                  - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   pidl
        ,"pidl -vrf [address]            - Display contents of pidl at address [address]\n"
        ,"pidl -r [address]   - To dump the contents of a RegItem pidl at [address]\n"
         "pidl -f [address]   - To dump the contents of a FileSys pidl at [address]\n"
         "pidl -vr [address]  - Dumps the verbose info for each pidl\n"
        , "vrf" 
        , STDARGS1)

DOIT(   filever
        ,"filever [-nd] [<filename>]     - Display file version information\n"
        ,"filever -d <filename>     - DllGetVersionInfo (requires LoadLibrary)\n"
         "filever -n <filename>     - File version resource information (default)\n"
         "filever -v <filename>     - Verbose file version resource information\n"
         "\n"
         "          If omitted, <filename> defaults to shell32.dll\n"
         "          Flags may be combined to dump multiple info\n"
        ,"vnd"
        ,CUSTOM)

DOIT(   test
        ,"test                           - Test basic debug functions.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   ver
        ,"ver                            - show versions of shlexts.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   hwnd
        ,"hwnd                           - show HWND info (doesn't require symbols)\n"
        ,"hwnd windowhandle              - display basic informatione\n"
         "hwnd -b windowhandle           - display window extra bytes\n"
         "hwnd -p windowhandle           - display window properties\n"
         "hwnd -m                        - display miscellaneous windows\n"
         "\n"
         "Window <hwnd> \"<title>\" (<class>)\n"
         "  N=<hwndNext> C=<hwndChild> P=<hwndParent> O=<hwndOwner>\n"
         "  W=<windowrect> C=<clientrect>\n"
         "  pid.tid=<pid>.<tid> hinst=<hinstance> wp=<wndproc>\n"
         "  style=<style> exstyle=<exstyle>\n"
        ,"bpm"
        , STDARGS1)

DOIT(   hmenu
        ,"hmenu                          - show HMENU info (doesn't require symbols)\n"
        ,"hmenu menuhandle               - display basic information\n"
         "\n"
         "Menu <hmenu> %d items\n"
         " n: id=<id> ref=<refdata> type <desc> <flags> [-> <submenu>]\n"
        ,""
        , STDARGS1)


DOIT(   dlgt
       ,"dlgt address                    - dump dialog template\n"
       ,"dlgt address                    - dump dialog template\n"
       ,"" 
       , STDARGS1)

DOIT(   stackpig
       ,"stackpig [nFrames]              - stack trace with stack usage\n"
       ,"    [nFrames]                   - number of frames to walk, default 25\n"
       ,"" 
       , STDARGS1)

DOIT(   wmex 
       ,"wmex msg [hwnd]                 - print window message\n"
       ,"wmex msg                        - print the name of all window messages with value msg\n"
        "wmex msg hwnd                   - print the name of msg specific to window class of hwnd\n" 
       ,"" 
       , STDARGS2)

DOIT(   drawicon 
        ,"drawicon [-cw] handle           - Draws the given icon as ASCII or in a window\n"
        ,"drawicon handle                - Draws icon as ASCII in ntsd session\n"
         "drawicon -c handle             - Draws icon as ASCII in ntsd session w/ color\n"
         "                                 (Colors will not work through a remote)\n"
         "drawicon -w handle             - Draws icon in popup window on remote side\n"
         "                                 Left double-click or '+' to zoom in\n"
         "                                 Right double-click or '-' to zoom out\n"
        ,"cw"
        , STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\makefile.inc ===
HDEPENDENCIES=..\exts.h $(WINDOWS_INC_PATH)\stdexts.h

GENUEDEFDEFINES=/D_$(ALT_PROJECT)_
!if !$(FREEBUILD)
GENUEDEFDEFINES=$(GENUEDEFDEFINES) /DDEBUGTAGS=1
!endif

precomp.h: ..\precomp.h

$(O)\shlexts.def: ..\genuedef.c $(HDEPENDENCIES)
    $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP ..\genuedef.c > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\msgs.cpp ===
//-----------------------------------------------------------------------------
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
#include <dbgeng.h>
#include <commctrl.h>
#include <comctrlp.h>

#include "msgs.h"
};


//-----------------------------------------------------------------------------
void PrintUser32Message(UINT uMsg)
{
    IDebugClient*  pDebugClient;
    IDebugControl* pDebugControl;

    if (SUCCEEDED(DebugCreate(__uuidof(IDebugClient), (void**)&pDebugClient)))
    {
        if (SUCCEEDED(pDebugClient->QueryInterface(__uuidof(IDebugControl), (void**)&pDebugControl)))
        {
            // Try calling the wm extension from userexts.dll
            ULONG64 ulExtension = 0;
            CHAR szMsg[64];

            pDebugControl->AddExtension("userexts", DEBUG_EXTENSION_AT_ENGINE, &ulExtension);
            pDebugControl->CallExtension(ulExtension, "wm", _itoa(uMsg, szMsg, 16)); 

            pDebugControl->Release();
        }

        pDebugClient->Release();
    }
}


//-----------------------------------------------------------------------------
void PrintRegisteredMessage(UINT uMsg)
{
    CHAR szMsg[64];

    if (GetClipboardFormatNameA(uMsg, szMsg, ARRAYSIZE(szMsg)))
    {
        Print("  %x %s\n", uMsg, szMsg);
    }
    else
    {
        Print("  %x ???\n", uMsg);
    }
}


//-----------------------------------------------------------------------------
void PrintComctl32Message(UINT uMsg, HWND hwnd)
{
    BOOL fMatchClass = FALSE;
    BOOL fFound      = FALSE;

    CHAR szClassName[64];
    if (hwnd && IsWindow(hwnd))
    {
        if (GetClassNameA(hwnd, szClassName, ARRAYSIZE(szClassName)))
        {
            fMatchClass = TRUE;
        }
    }


    for (int i = 0; !IsCtrlCHit() && (i < ARRAYSIZE(rgMsgMap)); i++)
    {
        if ((i > 0) &&  // always execute first iteration, contains msgs common to all
            (fMatchClass && (_stricmp(szClassName, rgMsgMap[i].szClassName) != 0)))
        {
            continue;
        }

        int j;
        MSGNAME* pmm;
        for (j = 0, pmm = rgMsgMap[i].rgMsgName; !IsCtrlCHit() && (j < rgMsgMap[i].chMsgName); j++)
        {
            if (pmm[j].uMsg == uMsg)
            {
                Print("  %x %-25s%s\n", pmm[j].uMsg, pmm[j].szMsg, fMatchClass ? "" : rgMsgMap[i].szFriendlyClassName);
                fFound = TRUE;
                break;
            }
        }
    }

    if (!fFound)
    {
        Print("  %x ???\n", uMsg);
    }
}


//-----------------------------------------------------------------------------
void PrintWindowMessageEx(UINT uMsg, HWND hwnd)
{
    if (uMsg <= WM_USER)
    {
        PrintUser32Message(uMsg);
    }
    else if (uMsg >= 0xC000)
    {
        PrintRegisteredMessage(uMsg);
    }
    else
    {
        PrintComctl32Message(uMsg, hwnd);
    }
}


//-----------------------------------------------------------------------------
extern "C" BOOL Iwmex(DWORD dwOpts, LPVOID pArg1, LPVOID pArg2)
{
    PrintWindowMessageEx(PtrToUint(pArg1), (HWND)(HWND *)pArg2);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <stdio.h>
#include <limits.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <string.h>
#include <ntstatus.h>
#include <windows.h>
#include <ntddvdeo.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commdlg.h>

#ifndef FIELDOFFSET
#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\pidlcmds.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "shguidp.h"
#include "..\..\shell32\pidl.h"
#include "..\..\shell32\shitemid.h"

// We never want assertions since we are the debugger extension!
#undef DBG
#undef DEBUG
#include "..\..\lib\idhidden.cpp"

extern "C"
{
#include <stdexts.h>
};

UNALIGNED WCHAR * ualstrcpyW(UNALIGNED WCHAR * dst, UNALIGNED const WCHAR * src)
{
    UNALIGNED WCHAR * cp = dst;

    while( *cp++ = *src++ )
        NULL ;

    return( dst );
}

///////////////////////////////////////////////////////////////////////////////
// Pidl Cracking function                                                    //
//                                                                           //
// returns fSuccess                                                          //
//                                                                           //
// History:                                                                  //
//     11/4/97 Created by cdturner                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// NOTE: the options are autovalidate before they are passed to us

typedef enum _PidlTypes
{
    PIDL_UNKNOWN,
    PIDL_ROOT,
    PIDL_FILESYS,
    PIDL_DRIVES,
    PIDL_NET,
    PIDL_INTERNET,
    PIDL_FAVORITES
} PIDLTYPE;

#define PIDL_BUFFER_SIZE    400

class CPidlBreaker
{
    public:
    
        CPidlBreaker( LPVOID pArg );
        ~CPidlBreaker( );

        void SetVerbose() {_fVerbose = TRUE;};

        VOID SetType( PIDLTYPE eType );
        BOOL FillBuffer( DWORD cbSize, BOOL fAppend );
        VOID ResetBuffer( void );

        WORD FetchWord();
        DWORD FetchDWORD();
        LPBYTE GetBuffer( int iPos = 0);

        PIDLTYPE CrackType( BYTE bType );
        void PrintType( PIDLTYPE eType );
        
        BOOL PrintPidl();
        BOOL PrintRootPidl();
        BOOL PrintDrivePidl();
        BOOL PrintFileSysPidl();
        BOOL PrintInternetPidl();
        BOOL PrintNetworkPidl();

        BOOL GetSHIDFlags( BYTE bFlags, CHAR * pszBuffer, DWORD cbSize );

        void CLSIDToString( CHAR * pszBuffer, DWORD cbSize, REFCLSID rclsid );

        BOOL GetCLSIDText( const CHAR * pszCLSID, CHAR * pszBuffer, DWORD cbSize );
        
    private:
        PIDLTYPE _eType;
        LPVOID _pArg;
        BYTE _rgBuffer[PIDL_BUFFER_SIZE];
        int _iCurrent;
        int _iMax;
        BOOL _fVerbose;

        // used to display slashes right when we are not in verbose mode...
        BOOL _fSlash;
};

extern "C" BOOL Ipidl( DWORD dwOpts,
                       LPVOID pArg )
{
    PIDLTYPE eType = PIDL_UNKNOWN;

    CPidlBreaker Breaker( pArg );
    
    if ( dwOpts & OFLAG(r))
    {
        Breaker.SetType( PIDL_ROOT );
    }
    else if ( dwOpts & OFLAG(f))
    {
        Breaker.SetType( PIDL_FILESYS );
    }

    if (dwOpts & OFLAG(v))
    {
        Breaker.SetVerbose();
    }

    BOOL bRes = FALSE;
    __try
    {
        bRes = Breaker.PrintPidl();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Print( "Exception caught in !pidl\n");
    }

    if ( !(dwOpts & OFLAG(v)) )
        Print( "\n" );
    
    return bRes;
}

VOID CPidlBreaker::SetType( PIDLTYPE eType )
{
    _eType = eType;
}

CPidlBreaker::CPidlBreaker( LPVOID pArg )
{
    _pArg = pArg;
    _iCurrent = 0;
    _iMax = 0;
    _eType = PIDL_UNKNOWN;
    _fVerbose = FALSE;
    _fSlash = FALSE;
}

CPidlBreaker::~CPidlBreaker( )
{
}

BOOL CPidlBreaker::FillBuffer( DWORD cbSize, BOOL fAppend )
{
    if ( !fAppend )
    {
        _iCurrent = 0;
        _iMax = 0;
    }

    int iStart = fAppend ? _iMax : 0;

    if ( cbSize + iStart > PIDL_BUFFER_SIZE )
    {
        return FALSE;
    }

#ifdef DEBUG
    char szBuffer[50];
    sprintf( szBuffer, "****Moving %d from %8X\n", cbSize, _pArg );
    Print( szBuffer );
#endif
    
    if ( tryMoveBlock( _rgBuffer + iStart, _pArg, cbSize ))
    {

#ifdef DEBUG
        for ( int iByte = 0; iByte < (int) cbSize; iByte ++ )
        {
            sprintf( szBuffer, "Byte %2x\n", _rgBuffer[iByte + iStart] );
            Print( szBuffer );
        }
#endif

        _pArg = (LPBYTE) _pArg + cbSize;
        _iMax += cbSize;

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

WORD CPidlBreaker::FetchWord()
{
    // assume that the buffer has been filled...
    if ( _iCurrent + 1 >= _iMax )
    {
        return 0;
    }
    
    WORD wRet = MAKEWORD( _rgBuffer[_iCurrent], _rgBuffer[_iCurrent + 1]);
    _iCurrent += 2;

#ifdef DEBUG
    char szBuffer[200];
    sprintf( szBuffer, "FetchWord() == %4X\n", wRet );
    Print( szBuffer );
#endif
    
    return wRet;
}

DWORD CPidlBreaker::FetchDWORD()
{
    // assume that the buffer has been filled...
    if ( _iCurrent + 3 >= _iMax )
    {
        return 0;
    }
    
    DWORD dwRet = MAKELONG( MAKEWORD( _rgBuffer[_iCurrent], _rgBuffer[_iCurrent + 1]), 
                            MAKEWORD( _rgBuffer[_iCurrent + 2], _rgBuffer[_iCurrent + 3] ));
    _iCurrent += 4;

#ifdef DEBUG
    char szBuffer[200];
    sprintf( szBuffer, "FetchDWord() == %8X\n", dwRet );
    Print( szBuffer );
#endif

    return dwRet;
    
}

LPBYTE CPidlBreaker::GetBuffer(int iPos)
{
    return _rgBuffer + _iCurrent + iPos;
}

VOID CPidlBreaker::ResetBuffer( )
{
    _iCurrent = 0;
    _iMax = 0;
}

BOOL CPidlBreaker::PrintRootPidl()
{
    CHAR szBuffer[200];
    
    if ( !FillBuffer( sizeof( WORD ), FALSE ))
    {
        Print( "ERROR Unable to get the pidl size\n");
        return FALSE;
    }
    

    // get the size of the first chunk
    WORD wSize = FetchWord();


    // root pidls always have the size field as 14 
    if ( wSize != sizeof( IDREGITEM ))
    {
        sprintf( szBuffer, "Pidl Size %d seems bogus for a regitem\n", wSize );
        
        Print( szBuffer );
        return FALSE;
    }
    else
    {
        if ( !FillBuffer( wSize - sizeof(WORD) , TRUE ))
        {
            sprintf( szBuffer, "Error: unable to access the data for the pidl of size %d\n", wSize );
            Print( szBuffer );
            return FALSE;
        }

        LPBYTE pBuf = GetBuffer(- ((int) sizeof(WORD)));
        char szBuffer2[200];

        if ( pBuf[2] != SHID_ROOT_REGITEM )
        {
            Print( "Pidl has incorrect flags, should have SHID_ROOT_REGITEM\n");
        }
        
        // now map it to a Root structure
        LPIDREGITEM pRegItem = (LPIDREGITEM) pBuf;

        GetSHIDFlags( pRegItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2 ));
        
        Print( "RegItem Pidl:\n");

        if ( _fVerbose )
        {
            sprintf( szBuffer, "    bFlags = %d (%s)\n", pRegItem->bFlags, szBuffer2 ); 
            Print( szBuffer );
            sprintf( szBuffer, "    bOrder = %d\n", pRegItem->bOrder );
            Print( szBuffer );
        }
        
        CHAR szCLSID[40];
        CLSIDToString( szCLSID, ARRAYSIZE( szCLSID ), pRegItem->clsid );

        sprintf( szBuffer, "    CLSID = %s ", szCLSID );
        Print( szBuffer );

        if ( GetCLSIDText( szCLSID, szBuffer2 + 1, ARRAYSIZE( szBuffer2 ) -2))
        {
            szBuffer2[0] = '(';
            lstrcatA( szBuffer2, ")\n" );
            Print( szBuffer2 );
        }

        if ( _fVerbose )
            Print( "\n" );
        
        ResetBuffer();
        
        if ( pRegItem->clsid == CLSID_ShellNetwork )
        {
            PrintNetworkPidl();
        }
        else if ( pRegItem->clsid == CLSID_ShellInetRoot )
        {
            // internet root
            PrintInternetPidl();
        }
        else if ( pRegItem->clsid == CLSID_ShellDrives )
        {
            // file system pidls ...
            PrintDrivePidl();
        }
        else
        {
            // unknown pidl type ....
            Print( "unknown pidl type, can't crack any further\n");
        }
    }

    return TRUE;
}

void _SprintDosDateTime(LPSTR szBuffer, LPCSTR pszType, WORD wDate, WORD wTime)
{
    sprintf( szBuffer, "    date/time %s = 0x%04x/%04x = %04d/%02d/%02d %02d:%02d:%02d\n",
             pszType,
             wDate, wTime,
             ((wDate & 0xFE00) >> 9)+1980,
              (wDate & 0x01E0) >> 5,
              (wDate & 0x001F) >> 0,
              (wTime & 0xF800) >> 11,
              (wTime & 0x07E0) >> 5,
              (wTime & 0x001F) << 1 );
}

BOOL CPidlBreaker::PrintFileSysPidl()
{
    CHAR szBuffer[200];
    CHAR szBuffer2[200];
    
    if ( !FillBuffer( sizeof( WORD ), FALSE ))
    {
        Print( "ERROR Unable to get the pidl size\n");
        return FALSE;
    }
    
    // get the size of the first chunk
    WORD wSize = FetchWord();

    if ( wSize == 0 )
    {
        // end of the pidl chain....
        return TRUE;
    }
    
    if ( !FillBuffer( wSize - sizeof(WORD) , TRUE ))
    {
        sprintf( szBuffer, "Error: unable to access the data for the pidl of size %d\n", wSize );
        Print( szBuffer );
        return FALSE;
    }

    LPBYTE pBuf = GetBuffer(- ((int)sizeof(WORD)));

    if (( pBuf[2] & SHID_FS ) != SHID_FS )
    {
        sprintf( szBuffer, "Error, Unknown Pidl flag, use !db %8X\n", (DWORD_PTR) _pArg - wSize);
        Print( szBuffer );
        return FALSE;
    }
    if ((( pBuf[2] & SHID_FS_UNICODE ) == SHID_FS_UNICODE ) && wSize > sizeof( IDFOLDER ) )
    {
        sprintf( szBuffer, "Error, size to big for a UNICODE FileSys Pidl, use !db %8X\n", (DWORD_PTR) _pArg - wSize);
        Print( szBuffer );
        return FALSE;
    }
    if ((( pBuf[2] & SHID_FS_UNICODE) != SHID_FS_UNICODE ) && wSize > sizeof( IDFOLDER ))
    {
        sprintf( szBuffer, "Error, size to big for a ANSI FileSys Pidl, use !db %8X\n", (DWORD_PTR) _pArg - wSize);
        Print( szBuffer );
        return FALSE;
    }

    if ( _fVerbose )
        Print("FileSystem pidl:\n");
    
    LPIDFOLDER pItem = (LPIDFOLDER) pBuf;

    if ( _fVerbose )
    {
        GetSHIDFlags( pItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2));
        sprintf( szBuffer, "    bFlags = %d (%s)\n", pItem->bFlags, szBuffer2 );
        Print( szBuffer );

        sprintf( szBuffer, "    dwSize = %d,\tattrs = 0x%X\n", pItem->dwSize, pItem->wAttrs );
        Print( szBuffer );

        _SprintDosDateTime(szBuffer, "modified", pItem->dateModified, pItem->timeModified);
        Print( szBuffer );
    }

    BOOL fPathShown = FALSE;

    PIDFOLDEREX pidlx = (PIDFOLDEREX)ILFindHiddenIDOn((LPITEMIDLIST)pBuf, IDLHID_IDFOLDEREX, FALSE);
    if (pidlx && pidlx->hid.cb >= sizeof(IDFOLDEREX))
    {
        LPBYTE pbMax = pBuf + wSize;

        if (_fVerbose)
        {
            _SprintDosDateTime(szBuffer, "created", pidlx->dsCreate.wDate, pidlx->dsCreate.wTime);
            Print(szBuffer);

            _SprintDosDateTime(szBuffer, "accessed", pidlx->dsAccess.wDate, pidlx->dsAccess.wTime);
            Print(szBuffer);

            if (pidlx->offResourceA)
            {
                LPSTR pszResourceA = (LPSTR)pidlx + pidlx->offResourceA;
                if ((LPBYTE)pszResourceA < pbMax)
                {
                    Print("    MUI = ");
                    Print(pszResourceA);
                    Print("\n");
                }
            }
        }

        // Do a "cheap" UnicodeToAnsi because
        //
        //  1. There's really no point in getting it right, since there
        //     is no guarantee that the debugger is running the same
        //     codepage as the app, and...
        //  2. The string is unaligned so we have to walk it manually anyway.
        //
        if (pidlx->offNameW)
        {
            LPBYTE pbName = (LPBYTE)pidlx + pidlx->offNameW;
            int i = 0;
            while (pbName < pbMax && *pbName && i < ARRAYSIZE(szBuffer2) - 1)
            {
                szBuffer2[i++] = *pbName;
                pbName += 2;
            }
            szBuffer2[i] = TEXT('\0');
        }

        if (_fVerbose)
        {
            Print("    NameW = ");
            Print(szBuffer2);
            Print("\n");
        }
        else
        {
            fPathShown = TRUE;
            if ( !_fSlash )
                Print( "\\" );

            Print( szBuffer2 );
        }

    }


    if (( pItem->bFlags & SHID_FS_UNICODE ) == SHID_FS_UNICODE )
    {
        WCHAR szTemp[MAX_PATH];

        ualstrcpyW( szTemp, (LPCWSTR)pItem->cFileName );
        
        WideCharToMultiByte( CP_ACP, 0, szTemp, -1, szBuffer2, ARRAYSIZE( szBuffer2 ),0 ,0 );

        if ( _fVerbose )
        {
            sprintf( szBuffer, "    cFileName = %s\n", szBuffer2 );
            Print( szBuffer );
        }
        else if (!fPathShown)
        {
            fPathShown = TRUE;
            if ( !_fSlash )
                Print( "\\" );

            Print( szBuffer2 );
        }
    }
    else
    {
        // assume to be ansi ...
        if ( _fVerbose )
        {
            sprintf( szBuffer, "    cFileName = %s\n", pItem->cFileName);
            Print( szBuffer );
        }
        else if (!fPathShown)
        {
            fPathShown = TRUE;
            if ( !_fSlash )
                Print( "\\" );

            Print( pItem->cFileName );
        }

        if ( _fVerbose )
        {
            int cLen = lstrlenA( pItem->cFileName);
            
            sprintf( szBuffer, "    cAltName = %s\n", pItem->cFileName + cLen + 1);
            Print( szBuffer );
        }
    }

    if ( pItem->bFlags & SHID_JUNCTION )
    {
         // it is a junction point, so the CLASSID is tagged on the end

         /*[TODO]*/
    }

    _fSlash = FALSE;
    
    ResetBuffer();
    
    PrintFileSysPidl();
    return TRUE;
}

BOOL CPidlBreaker::PrintPidl()
{
    if ( _eType == PIDL_UNKNOWN )
    {
        LPVOID pPrevArg = _pArg;
        // check the 3rd byte in, it might be a SHID value...
        if ( !FillBuffer(3, FALSE ))
        {
            Print( "Unable to access the memory\n");
            return FALSE;
        }

        LPBYTE pBuf = GetBuffer();

        _eType = CrackType( pBuf[2] );

        ResetBuffer();
        _pArg = pPrevArg;
    }

    PrintType( _eType );
    return TRUE;
}

BOOL CPidlBreaker::PrintInternetPidl()
{
    return TRUE;
}

BOOL CPidlBreaker::PrintNetworkPidl()
{
    return TRUE;
}

BOOL CPidlBreaker::PrintDrivePidl()
{
    CHAR szBuffer[200];
    CHAR szBuffer2[200];
    
    if ( !FillBuffer( sizeof( WORD ), FALSE ))
    {
        Print( "ERROR Unable to get the pidl size\n");
        return FALSE;
    }
    
    // get the size of the first chunk
    WORD wSize = FetchWord();

    if ( wSize == 0 )
    {
        return TRUE;
    }
    
    if ( !FillBuffer( wSize - sizeof(WORD) , TRUE ))
    {
        sprintf( szBuffer, "Error: unable to access the data for the pidl of size %d\n", wSize );
        Print( szBuffer );
        return FALSE;
    }

    LPBYTE pBuf = GetBuffer(- ((int)sizeof(WORD)));
    
    // need to check to see if it is an IDDrive structure or a regitem ....
    if ( wSize == sizeof( IDDRIVE ) || wSize == FIELD_OFFSET(IDDRIVE, clsid) )
    {
        // must be a drive structure....
        if ( _fVerbose )
            Print( "(My Computer) Drives Pidl:\n");
        else
            Print( "Path = ");

        LPIDDRIVE pDriveItem = (LPIDDRIVE) pBuf;

        if ( _fVerbose )
        {
            GetSHIDFlags( pDriveItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2 ));
            sprintf( szBuffer, "    bFlags = %d (%s)\n", pDriveItem->bFlags, szBuffer2 );
            Print( szBuffer );
            
            sprintf( szBuffer, "    cName = %s\n", pDriveItem->cName );
            Print( szBuffer );
            
            sprintf( szBuffer, "    qwSize = 0x%lX\tqwFree = 0x%lX\n", pDriveItem->qwSize, pDriveItem->qwFree );
            Print( szBuffer );
            sprintf( szBuffer, "    wSig = 0x%X\n\n", pDriveItem->wSig);
            Print( szBuffer );
            if ( wSize == sizeof( IDDRIVE ) )
            {
                CHAR szCLSID[40];
                CLSIDToString( szCLSID, ARRAYSIZE( szCLSID ), pDriveItem->clsid  );
                sprintf( szBuffer, "    CLSID = %s ", szCLSID );
                Print( szBuffer );
            }
        }
        else
            Print( pDriveItem->cName );

        // coming from a drive, we already have a slash at the start
        _fSlash = TRUE;
        
        // assume the next pidl is a standard file-sys one...
        PrintFileSysPidl();
    }
    else if ( wSize == sizeof( IDREGITEM ))
    {
        // must be a reg item like control panel or printers...

        Print( "Drives (My Computer) RegItem Pidl\n");
        
        if ( pBuf[2] != SHID_COMPUTER_REGITEM )
        {
            Print( "Pidl has incorrect flags, should have SHID_ROOT_REGITEM\n");
        }
        
        // now map it to a Root structure
        LPIDREGITEM pRegItem = (LPIDREGITEM) pBuf;

        GetSHIDFlags( pRegItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2 ));
        
        Print( "RegItem Pidl:\n");

        if ( _fVerbose )
        {
            sprintf( szBuffer, "    bFlags = %d (%s)\n", pRegItem->bFlags, szBuffer2 ); 
            Print( szBuffer );
            sprintf( szBuffer, "    bOrder = %d\n", pRegItem->bOrder );
            Print( szBuffer );
        }
        
        CHAR szCLSID[40];
        CLSIDToString( szCLSID, ARRAYSIZE( szCLSID ), pRegItem->clsid );

        sprintf( szBuffer, "    CLSID = %s ", szCLSID );
        Print( szBuffer );

        if ( GetCLSIDText( szCLSID, szBuffer2 + 1, ARRAYSIZE( szBuffer2 ) -2))
        {
            szBuffer2[0] = '(';
            lstrcatA( szBuffer2, ")\n" );
            Print( szBuffer2 );
        }

        ResetBuffer();

        LPVOID _pPrevArg = _pArg;
        
        if ( !FillBuffer( sizeof( WORD ), FALSE ))
        {
            Print( "Error unable to access next pidl section\n");
        }
        if ( FetchWord() != 0 )
        {
            // unknown hierarchy pidl type
            sprintf( szBuffer, "Unknown Pidl Type contents, use !db %8X\n", (DWORD_PTR) _pPrevArg );
        }

        _pArg = _pPrevArg;
    }
    else
    {
        Print( "Unknown Drives pidl type\n");
        return FALSE;
    }

    return TRUE;
}

PIDLTYPE CPidlBreaker::CrackType( BYTE bType )
{
    PIDLTYPE eType = PIDL_UNKNOWN;
    
    switch( bType & 0xf0 )
    {
        case SHID_ROOT:
            eType = PIDL_ROOT;
            break;
            
        case SHID_COMPUTER:
            eType = PIDL_DRIVES;
            break;
            
        case SHID_FS:
            eType = PIDL_FILESYS;
            break;
            
        case SHID_NET:
            eType = PIDL_NET;
            break;
            
        case 0x60:  // SHID_INTERNET
            eType = PIDL_INTERNET;
            break;
    }
    return eType;
}

void CPidlBreaker::PrintType( PIDLTYPE eType )
{
    switch( eType )
    {
        case PIDL_ROOT:
            PrintRootPidl();
            break;

        case PIDL_FILESYS:
            PrintFileSysPidl();
            break;

        case PIDL_DRIVES:
            PrintDrivePidl();
            break;
            
        case PIDL_NET:
        case PIDL_INTERNET:
        default:
            Print( "Unknown Pidl Type\n");
            break;
    }
}
        

typedef struct _tagSHIDs
{
    BYTE bFlag;
    LPCSTR pszText;
} SHIDFLAGS;

SHIDFLAGS g_argSHID[] =
{
    {SHID_ROOT,                 "SHID_ROOT" },
    {SHID_ROOT_REGITEM,         "SHID_ROOT_REGITEM"},
    {SHID_COMPUTER,             "SHID_COMPUTER"},
    {SHID_COMPUTER_1,           "SHID_COMPUTER_1"},
    {SHID_COMPUTER_REMOVABLE,   "SHID_COMPUTER_REMOVABLE"},
    {SHID_COMPUTER_FIXED,       "SHID_COMPUTER_FIXED"},
    {SHID_COMPUTER_REMOTE,      "SHID_COMPUTER_REMOTE"},
    {SHID_COMPUTER_CDROM,       "SHID_COMPUTER_CDROM"},
    {SHID_COMPUTER_RAMDISK,     "SHID_COMPUTER_RAMDISK"},
    {SHID_COMPUTER_7,           "SHID_COMPUTER_7"},
    {SHID_COMPUTER_DRIVE525,    "SHID_COMPUTER_DRIVE525"},
    {SHID_COMPUTER_DRIVE35,     "SHID_COMPUTER_DRIVE35"},
    {SHID_COMPUTER_NETDRIVE,    "SHID_COMPUTER_NETDRIVE"},
    {SHID_COMPUTER_NETUNAVAIL,  "SHID_COMPUTER_NETUNAVAIL"},
    {SHID_COMPUTER_C,           "SHID_COMPUTER_C"},
    {SHID_COMPUTER_D,           "SHID_COMPUTER_D"},
    {SHID_COMPUTER_REGITEM,     "SHID_COMPUTER_REGITEM"},
    {SHID_COMPUTER_MISC,        "SHID_COMPUTER_MISC"},
    {SHID_FS,                   "SHID_FS"},
    {SHID_FS_TYPEMASK,          "SHID_FS_TYPEMASK"},
    {SHID_FS_DIRECTORY,         "SHID_FS_DIRECTORY"},
    {SHID_FS_FILE,              "SHID_FS_FILE"},
    {SHID_FS_UNICODE,           "SHID_FS_UNICODE"},
    {SHID_FS_DIRUNICODE,        "SHID_FS_DIRUNICODE"},
    {SHID_FS_FILEUNICODE,       "SHID_FS_FILEUNICODE"},
    {SHID_NET,                  "SHID_NET"},
    {SHID_NET_DOMAIN,           "SHID_NET_DOMAIN"},
    {SHID_NET_SERVER,           "SHID_NET_SERVER"},
    {SHID_NET_SHARE,            "SHID_NET_SHARE"},
    {SHID_NET_FILE,             "SHID_NET_FILE"},
    {SHID_NET_GROUP,            "SHID_NET_GROUP"},
    {SHID_NET_NETWORK,          "SHID_NET_NETWORK"},
    {SHID_NET_RESTOFNET,        "SHID_NET_RESTOFNET"},
    {SHID_NET_SHAREADMIN,       "SHID_NET_SHAREADMIN"},
    {SHID_NET_DIRECTORY,        "SHID_NET_DIRECTORY"},
    {SHID_NET_TREE,             "SHID_NET_TREE"},
    {SHID_NET_REGITEM,          "SHID_NET_REGITEM"},
    {SHID_NET_PRINTER,          "SHID_NET_PRINTER"}
};

BOOL CPidlBreaker::GetSHIDFlags( BYTE bFlags, CHAR * pszBuffer, DWORD cbSize )
{
    LPCSTR pszText = NULL;
    for ( int iFlag = 0; iFlag < ARRAYSIZE( g_argSHID ); iFlag ++ )
    {
        if ( g_argSHID[iFlag].bFlag == ( bFlags & SHID_TYPEMASK ))
        {
            pszText = g_argSHID[iFlag].pszText;
            break;
        }
    }

    if ( pszText == NULL )
    {
        sprintf( pszBuffer, "unknown SHID value %2X", bFlags );
        return FALSE;
    }
    else
    {
        lstrcpyA( pszBuffer, pszText );
    }
    
    if (bFlags & SHID_JUNCTION)
    {
        lstrcatA(pszBuffer, " | SHID_JUNCTION");
    }
    return TRUE;
}

void CPidlBreaker::CLSIDToString( CHAR * pszBuffer, DWORD cbSize, REFCLSID rclsid )
{
    WCHAR szBuffer[40];

    StringFromGUID2( rclsid, szBuffer, ARRAYSIZE( szBuffer ));
    WideCharToMultiByte( CP_ACP, 0, szBuffer, -1, pszBuffer, cbSize, 0, 0 );
}

//
//  Some CLSIDs have "known" names which are used if there is no custom name
//  in the registry.
//
typedef struct KNOWNCLSIDS
{
    LPCSTR pszCLSID;
    LPCSTR pszName;
} KNOWNCLSIDS;

const KNOWNCLSIDS c_kcKnown[] = {
    { "{20D04FE0-3AEA-1069-A2D8-08002B30309D}", "My Computer" },
    { "{21EC2020-3AEA-1069-A2DD-08002B30309D}", "Control Panel" },
    { "{645FF040-5081-101B-9F08-00AA002F954E}", "Recycle Bin" },
    { "{450D8FBA-AD25-11D0-98A8-0800361B1103}", "My Documents" },
    { "{871C5380-42A0-1069-A2EA-08002B30309D}", "The Internet" },
};

BOOL CPidlBreaker::GetCLSIDText( const CHAR * pszCLSID, CHAR * pszBuffer, DWORD cbSize )
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_kcKnown); i++)
    {
        if (lstrcmpiA(c_kcKnown[i].pszCLSID, pszCLSID) == 0)
        {
            lstrcpynA(pszBuffer, c_kcKnown[i].pszName, cbSize);
            return TRUE;
        }
    }


    HKEY hKey;
    LONG lRes = RegOpenKeyA( HKEY_CLASSES_ROOT, "CLSID", &hKey );
    if ( ERROR_SUCCESS == lRes )
    {
        LONG lSize = cbSize;
        lRes = RegQueryValueA( hKey, pszCLSID, pszBuffer, &lSize );
        return ( ERROR_SUCCESS == lRes );
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\msgs.h ===
typedef struct tagMSGNAME
{
    UINT    uMsg;
    LPSTR   szMsg;
} MSGNAME;

typedef struct tagMSGMAP
{
    LPSTR       szClassName;
    LPSTR       szFriendlyClassName;
    MSGNAME     *rgMsgName;
    int         chMsgName;
} MSGMAP;


#define MSGNAME_ENTRY(x)    {x, #x}


//-----------------------------------------------------------------------------
// Common Control Messages
MSGNAME rgMsgNameCCM[] = 
{
    // control message range declarations, put them in the common bucket
    MSGNAME_ENTRY(LVM_FIRST),
    MSGNAME_ENTRY(TV_FIRST),
    MSGNAME_ENTRY(HDM_FIRST),
    MSGNAME_ENTRY(TCM_FIRST),
    MSGNAME_ENTRY(PGM_FIRST),
    MSGNAME_ENTRY(ECM_FIRST),
    MSGNAME_ENTRY(BCM_FIRST),
    MSGNAME_ENTRY(CBM_FIRST),

    // common control messages
    MSGNAME_ENTRY(CCM_FIRST),
    MSGNAME_ENTRY(CCM_LAST),
    MSGNAME_ENTRY(CCM_SETBKCOLOR),
    MSGNAME_ENTRY(CCM_SETCOLORSCHEME),
    MSGNAME_ENTRY(CCM_GETCOLORSCHEME),
    MSGNAME_ENTRY(CCM_GETDROPTARGET),
    MSGNAME_ENTRY(CCM_SETUNICODEFORMAT),
    MSGNAME_ENTRY(CCM_GETUNICODEFORMAT),
    MSGNAME_ENTRY(CCM_SETVERSION),
    MSGNAME_ENTRY(CCM_GETVERSION),
    MSGNAME_ENTRY(CCM_SETNOTIFYWINDOW),
    MSGNAME_ENTRY(CCM_TRANSLATEACCELERATOR),
    MSGNAME_ENTRY(CCM_SETWINDOWTHEME),
    MSGNAME_ENTRY(CCM_DPISCALE),
};

//-----------------------------------------------------------------------------
// Header Control Messages
MSGNAME rgMsgNameHDM[] = 
{
    MSGNAME_ENTRY(HDM_GETITEMCOUNT),
    MSGNAME_ENTRY(HDM_INSERTITEMA),
    MSGNAME_ENTRY(HDM_INSERTITEMW),
    MSGNAME_ENTRY(HDM_DELETEITEM),
    MSGNAME_ENTRY(HDM_GETITEMA),
    MSGNAME_ENTRY(HDM_GETITEMW),
    MSGNAME_ENTRY(HDM_SETITEMA),
    MSGNAME_ENTRY(HDM_SETITEMW),
    MSGNAME_ENTRY(HDM_LAYOUT),
    MSGNAME_ENTRY(HDM_HITTEST),
    MSGNAME_ENTRY(HDM_GETITEMRECT),
    MSGNAME_ENTRY(HDM_SETIMAGELIST),
    MSGNAME_ENTRY(HDM_GETIMAGELIST),
    MSGNAME_ENTRY(HDM_ORDERTOINDEX),
    MSGNAME_ENTRY(HDM_CREATEDRAGIMAGE),
    MSGNAME_ENTRY(HDM_GETORDERARRAY),
    MSGNAME_ENTRY(HDM_SETORDERARRAY),
    MSGNAME_ENTRY(HDM_SETHOTDIVIDER),
    MSGNAME_ENTRY(HDM_SETBITMAPMARGIN),
    MSGNAME_ENTRY(HDM_GETBITMAPMARGIN),
    MSGNAME_ENTRY(HDM_SETFILTERCHANGETIMEOUT),
    MSGNAME_ENTRY(HDM_EDITFILTER),
    MSGNAME_ENTRY(HDM_CLEARFILTER),
};


//-----------------------------------------------------------------------------
// Toolbar Control Messages
MSGNAME rgMsgNameTB[] = 
{
    MSGNAME_ENTRY(TB_ENABLEBUTTON),
    MSGNAME_ENTRY(TB_CHECKBUTTON),
    MSGNAME_ENTRY(TB_PRESSBUTTON),
    MSGNAME_ENTRY(TB_HIDEBUTTON),
    MSGNAME_ENTRY(TB_INDETERMINATE),
    MSGNAME_ENTRY(TB_MARKBUTTON),
    MSGNAME_ENTRY(TB_ISBUTTONENABLED),
    MSGNAME_ENTRY(TB_ISBUTTONCHECKED),
    MSGNAME_ENTRY(TB_ISBUTTONPRESSED),
    MSGNAME_ENTRY(TB_ISBUTTONHIDDEN),
    MSGNAME_ENTRY(TB_ISBUTTONINDETERMINATE),
    MSGNAME_ENTRY(TB_ISBUTTONHIGHLIGHTED),
    MSGNAME_ENTRY(TB_SETSTATE),
    MSGNAME_ENTRY(TB_GETSTATE),
    MSGNAME_ENTRY(TB_ADDBITMAP),
    MSGNAME_ENTRY(TB_ADDBUTTONSA),
    MSGNAME_ENTRY(TB_INSERTBUTTONA),
    MSGNAME_ENTRY(TB_ADDBUTTONS),
    MSGNAME_ENTRY(TB_INSERTBUTTON),
    MSGNAME_ENTRY(TB_DELETEBUTTON),
    MSGNAME_ENTRY(TB_GETBUTTON),
    MSGNAME_ENTRY(TB_BUTTONCOUNT),
    MSGNAME_ENTRY(TB_COMMANDTOINDEX),
    MSGNAME_ENTRY(TB_SAVERESTOREA),
    MSGNAME_ENTRY(TB_SAVERESTOREW),
    MSGNAME_ENTRY(TB_CUSTOMIZE),
    MSGNAME_ENTRY(TB_ADDSTRINGA),
    MSGNAME_ENTRY(TB_ADDSTRINGW),
    MSGNAME_ENTRY(TB_GETITEMRECT),
    MSGNAME_ENTRY(TB_BUTTONSTRUCTSIZE),
    MSGNAME_ENTRY(TB_SETBUTTONSIZE),
    MSGNAME_ENTRY(TB_SETBITMAPSIZE),
    MSGNAME_ENTRY(TB_AUTOSIZE),
    MSGNAME_ENTRY(TB_SETBUTTONTYPE),
    MSGNAME_ENTRY(TB_GETTOOLTIPS),
    MSGNAME_ENTRY(TB_SETTOOLTIPS),
    MSGNAME_ENTRY(TB_SETPARENT),
    MSGNAME_ENTRY(TB_ADDBITMAP32),
    MSGNAME_ENTRY(TB_SETROWS),
    MSGNAME_ENTRY(TB_GETROWS),
    MSGNAME_ENTRY(TB_SETCMDID),
    MSGNAME_ENTRY(TB_CHANGEBITMAP),
    MSGNAME_ENTRY(TB_GETBITMAP),
    MSGNAME_ENTRY(TB_GETBUTTONTEXTA),
    MSGNAME_ENTRY(TB_GETBUTTONTEXTW),
    MSGNAME_ENTRY(TB_REPLACEBITMAP),
    MSGNAME_ENTRY(TB_SETINDENT),
    MSGNAME_ENTRY(TB_SETIMAGELIST),
    MSGNAME_ENTRY(TB_GETIMAGELIST),
    MSGNAME_ENTRY(TB_LOADIMAGES),
    MSGNAME_ENTRY(TB_GETRECT),
    MSGNAME_ENTRY(TB_SETHOTIMAGELIST),
    MSGNAME_ENTRY(TB_GETHOTIMAGELIST),
    MSGNAME_ENTRY(TB_SETDISABLEDIMAGELIST),
    MSGNAME_ENTRY(TB_GETDISABLEDIMAGELIST),
    MSGNAME_ENTRY(TB_SETSTYLE),
    MSGNAME_ENTRY(TB_GETSTYLE),
    MSGNAME_ENTRY(TB_GETBUTTONSIZE),
    MSGNAME_ENTRY(TB_SETBUTTONWIDTH),
    MSGNAME_ENTRY(TB_SETMAXTEXTROWS),
    MSGNAME_ENTRY(TB_GETTEXTROWS),
    MSGNAME_ENTRY(TB_GETOBJECT),
    MSGNAME_ENTRY(TB_GETHOTITEM),
    MSGNAME_ENTRY(TB_SETHOTITEM),
    MSGNAME_ENTRY(TB_SETANCHORHIGHLIGHT),
    MSGNAME_ENTRY(TB_GETANCHORHIGHLIGHT),
    MSGNAME_ENTRY(TB_MAPACCELERATORA),
    MSGNAME_ENTRY(TB_GETINSERTMARK),
    MSGNAME_ENTRY(TB_SETINSERTMARK),
    MSGNAME_ENTRY(TB_INSERTMARKHITTEST),
    MSGNAME_ENTRY(TB_MOVEBUTTON),
    MSGNAME_ENTRY(TB_GETMAXSIZE),
    MSGNAME_ENTRY(TB_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TB_GETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TB_GETPADDING),
    MSGNAME_ENTRY(TB_SETPADDING),
    MSGNAME_ENTRY(TB_SETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TB_GETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TB_MAPACCELERATORW),
    MSGNAME_ENTRY(TB_GETBITMAPFLAGS),
    MSGNAME_ENTRY(TB_GETBUTTONINFOW),
    MSGNAME_ENTRY(TB_SETBUTTONINFOW),
    MSGNAME_ENTRY(TB_GETBUTTONINFOA),
    MSGNAME_ENTRY(TB_SETBUTTONINFOA),
    MSGNAME_ENTRY(TB_INSERTBUTTONW),
    MSGNAME_ENTRY(TB_ADDBUTTONSW),
    MSGNAME_ENTRY(TB_HITTEST),
    MSGNAME_ENTRY(TB_SETDRAWTEXTFLAGS),
    MSGNAME_ENTRY(TB_GETSTRINGW),
    MSGNAME_ENTRY(TB_GETSTRINGA),
    MSGNAME_ENTRY(TB_SETBOUNDINGSIZE),
    MSGNAME_ENTRY(TB_SETHOTITEM2),
    MSGNAME_ENTRY(TB_HASACCELERATOR),
    MSGNAME_ENTRY(TB_SETLISTGAP),
    MSGNAME_ENTRY(TB_GETIMAGELISTCOUNT),
    MSGNAME_ENTRY(TB_GETIDEALSIZE),
    MSGNAME_ENTRY(TB_SETDROPDOWNGAP),
    MSGNAME_ENTRY(TB_GETMETRICS),
    MSGNAME_ENTRY(TB_SETMETRICS),
};


//-----------------------------------------------------------------------------
// Rebar Control Messages
MSGNAME rgMsgNameRB[] = 
{
    MSGNAME_ENTRY(RB_INSERTBANDA),
    MSGNAME_ENTRY(RB_DELETEBAND),
    MSGNAME_ENTRY(RB_GETBARINFO),
    MSGNAME_ENTRY(RB_SETBARINFO),
    MSGNAME_ENTRY(RB_GETBANDINFOOLD),
    MSGNAME_ENTRY(RB_GETBANDINFO),
    MSGNAME_ENTRY(RB_SETBANDINFOA),
    MSGNAME_ENTRY(RB_SETPARENT),
    MSGNAME_ENTRY(RB_HITTEST),
    MSGNAME_ENTRY(RB_GETRECT),
    MSGNAME_ENTRY(RB_INSERTBANDW),
    MSGNAME_ENTRY(RB_SETBANDINFOW),
    MSGNAME_ENTRY(RB_GETBANDCOUNT),
    MSGNAME_ENTRY(RB_GETROWCOUNT),
    MSGNAME_ENTRY(RB_GETROWHEIGHT),
    MSGNAME_ENTRY(RB_GETOBJECT),
    MSGNAME_ENTRY(RB_IDTOINDEX),
    MSGNAME_ENTRY(RB_GETTOOLTIPS),
    MSGNAME_ENTRY(RB_SETTOOLTIPS),
    MSGNAME_ENTRY(RB_SETBKCOLOR),
    MSGNAME_ENTRY(RB_GETBKCOLOR),
    MSGNAME_ENTRY(RB_SETTEXTCOLOR),
    MSGNAME_ENTRY(RB_GETTEXTCOLOR),
    MSGNAME_ENTRY(RB_SIZETORECT),
    MSGNAME_ENTRY(RB_BEGINDRAG),
    MSGNAME_ENTRY(RB_ENDDRAG),
    MSGNAME_ENTRY(RB_DRAGMOVE),
    MSGNAME_ENTRY(RB_GETBARHEIGHT),
    MSGNAME_ENTRY(RB_GETBANDINFOW),
    MSGNAME_ENTRY(RB_GETBANDINFOA),
    MSGNAME_ENTRY(RB_MINIMIZEBAND),
    MSGNAME_ENTRY(RB_MAXIMIZEBAND),
    MSGNAME_ENTRY(RB_PRIV_RESIZE),
    MSGNAME_ENTRY(RB_GETBANDBORDERS),
    MSGNAME_ENTRY(RB_SHOWBAND),
    MSGNAME_ENTRY(RB_PRIV_DODELAYEDSTUFF),
    MSGNAME_ENTRY(RB_SETPALETTE),
    MSGNAME_ENTRY(RB_GETPALETTE),
    MSGNAME_ENTRY(RB_MOVEBAND),
    MSGNAME_ENTRY(RB_GETBANDMARGINS),
    MSGNAME_ENTRY(RB_PUSHCHEVRON),
};


//-----------------------------------------------------------------------------
// Tooltip Control Messages
MSGNAME rgMsgNameTTM[] = 
{
    MSGNAME_ENTRY(TTM_ACTIVATE),
    MSGNAME_ENTRY(TTM_SETDELAYTIME),
    MSGNAME_ENTRY(TTM_ADDTOOLA),
    MSGNAME_ENTRY(TTM_ADDTOOLW),
    MSGNAME_ENTRY(TTM_DELTOOLA),
    MSGNAME_ENTRY(TTM_DELTOOLW),
    MSGNAME_ENTRY(TTM_NEWTOOLRECTA),
    MSGNAME_ENTRY(TTM_NEWTOOLRECTW),
    MSGNAME_ENTRY(TTM_RELAYEVENT),
    MSGNAME_ENTRY(TTM_GETTOOLINFOA),
    MSGNAME_ENTRY(TTM_GETTOOLINFOW),
    MSGNAME_ENTRY(TTM_SETTOOLINFOA),
    MSGNAME_ENTRY(TTM_SETTOOLINFOW),
    MSGNAME_ENTRY(TTM_HITTESTA),
    MSGNAME_ENTRY(TTM_HITTESTW),
    MSGNAME_ENTRY(TTM_GETTEXTA),
    MSGNAME_ENTRY(TTM_GETTEXTW),
    MSGNAME_ENTRY(TTM_UPDATETIPTEXTA),
    MSGNAME_ENTRY(TTM_UPDATETIPTEXTW),
    MSGNAME_ENTRY(TTM_GETTOOLCOUNT),
    MSGNAME_ENTRY(TTM_ENUMTOOLSA),
    MSGNAME_ENTRY(TTM_ENUMTOOLSW),
    MSGNAME_ENTRY(TTM_GETCURRENTTOOLA),
    MSGNAME_ENTRY(TTM_GETCURRENTTOOLW),
    MSGNAME_ENTRY(TTM_WINDOWFROMPOINT),
    MSGNAME_ENTRY(TTM_TRACKACTIVATE),
    MSGNAME_ENTRY(TTM_TRACKPOSITION),
    MSGNAME_ENTRY(TTM_SETTIPBKCOLOR),
    MSGNAME_ENTRY(TTM_SETTIPTEXTCOLOR),
    MSGNAME_ENTRY(TTM_GETDELAYTIME),
    MSGNAME_ENTRY(TTM_GETTIPBKCOLOR),
    MSGNAME_ENTRY(TTM_GETTIPTEXTCOLOR),
    MSGNAME_ENTRY(TTM_SETMAXTIPWIDTH),
    MSGNAME_ENTRY(TTM_GETMAXTIPWIDTH),
    MSGNAME_ENTRY(TTM_SETMARGIN),
    MSGNAME_ENTRY(TTM_GETMARGIN),
    MSGNAME_ENTRY(TTM_POP),
    MSGNAME_ENTRY(TTM_UPDATE),
    MSGNAME_ENTRY(TTM_GETBUBBLESIZE),
    MSGNAME_ENTRY(TTM_ADJUSTRECT),
    MSGNAME_ENTRY(TTM_SETTITLEA),
    MSGNAME_ENTRY(TTM_SETTITLEW),
    MSGNAME_ENTRY(TTM_POPUP),
    MSGNAME_ENTRY(TTM_GETTITLE),
};


//-----------------------------------------------------------------------------
// Status Control Messages
MSGNAME rgMsgNameSB[] = 
{
    MSGNAME_ENTRY(SB_SETTEXTA),
    MSGNAME_ENTRY(SB_SETTEXTW),
    MSGNAME_ENTRY(SB_GETTEXTA),
    MSGNAME_ENTRY(SB_GETTEXTW),
    MSGNAME_ENTRY(SB_GETTEXTLENGTHA),
    MSGNAME_ENTRY(SB_GETTEXTLENGTHW),
    MSGNAME_ENTRY(SB_SETPARTS),
    MSGNAME_ENTRY(SB_SETBORDERS),
    MSGNAME_ENTRY(SB_GETPARTS),
    MSGNAME_ENTRY(SB_GETBORDERS),
    MSGNAME_ENTRY(SB_SETMINHEIGHT),
    MSGNAME_ENTRY(SB_SIMPLE),
    MSGNAME_ENTRY(SB_GETRECT),
    MSGNAME_ENTRY(SB_ISSIMPLE),
    MSGNAME_ENTRY(SB_SETICON),
    MSGNAME_ENTRY(SB_SETTIPTEXTA),
    MSGNAME_ENTRY(SB_SETTIPTEXTW),
    MSGNAME_ENTRY(SB_GETTIPTEXTA),
    MSGNAME_ENTRY(SB_GETTIPTEXTW),
    MSGNAME_ENTRY(SB_GETICON),
};


//-----------------------------------------------------------------------------
// ButtonListBox Control Messages ???
MSGNAME rgMsgNameBL[] = 
{
    MSGNAME_ENTRY(BL_ADDBUTTON),
    MSGNAME_ENTRY(BL_DELETEBUTTON),
    MSGNAME_ENTRY(BL_GETCARETINDEX),
    MSGNAME_ENTRY(BL_GETCOUNT),
    MSGNAME_ENTRY(BL_GETCURSEL),
    MSGNAME_ENTRY(BL_GETITEMDATA),
    MSGNAME_ENTRY(BL_GETITEMRECT),
    MSGNAME_ENTRY(BL_GETTEXT),
    MSGNAME_ENTRY(BL_GETTEXTLEN),
    MSGNAME_ENTRY(BL_GETTOPINDEX),
    MSGNAME_ENTRY(BL_INSERTBUTTON),
    MSGNAME_ENTRY(BL_RESETCONTENT),
    MSGNAME_ENTRY(BL_SETCARETINDEX),
    MSGNAME_ENTRY(BL_SETCURSEL),
    MSGNAME_ENTRY(BL_SETITEMDATA),
    MSGNAME_ENTRY(BL_SETTOPINDEX),
    MSGNAME_ENTRY(BL_MSGMAX),
};


//-----------------------------------------------------------------------------
// Trackbar Control Messages
MSGNAME rgMsgNameTBM[] = 
{
    MSGNAME_ENTRY(TBM_GETPOS),
    MSGNAME_ENTRY(TBM_GETRANGEMIN),
    MSGNAME_ENTRY(TBM_GETRANGEMAX),
    MSGNAME_ENTRY(TBM_GETTIC),
    MSGNAME_ENTRY(TBM_SETTIC),
    MSGNAME_ENTRY(TBM_SETPOS),
    MSGNAME_ENTRY(TBM_SETRANGE),
    MSGNAME_ENTRY(TBM_SETRANGEMIN),
    MSGNAME_ENTRY(TBM_SETRANGEMAX),
    MSGNAME_ENTRY(TBM_CLEARTICS),
    MSGNAME_ENTRY(TBM_SETSEL),
    MSGNAME_ENTRY(TBM_SETSELSTART),
    MSGNAME_ENTRY(TBM_SETSELEND),
    MSGNAME_ENTRY(TBM_GETPTICS),
    MSGNAME_ENTRY(TBM_GETTICPOS),
    MSGNAME_ENTRY(TBM_GETNUMTICS),
    MSGNAME_ENTRY(TBM_GETSELSTART),
    MSGNAME_ENTRY(TBM_GETSELEND),
    MSGNAME_ENTRY(TBM_CLEARSEL),
    MSGNAME_ENTRY(TBM_SETTICFREQ),
    MSGNAME_ENTRY(TBM_SETPAGESIZE),
    MSGNAME_ENTRY(TBM_GETPAGESIZE),
    MSGNAME_ENTRY(TBM_SETLINESIZE),
    MSGNAME_ENTRY(TBM_GETLINESIZE),
    MSGNAME_ENTRY(TBM_GETTHUMBRECT),
    MSGNAME_ENTRY(TBM_GETCHANNELRECT),
    MSGNAME_ENTRY(TBM_SETTHUMBLENGTH),
    MSGNAME_ENTRY(TBM_GETTHUMBLENGTH),
    MSGNAME_ENTRY(TBM_SETTOOLTIPS),
    MSGNAME_ENTRY(TBM_GETTOOLTIPS),
    MSGNAME_ENTRY(TBM_SETTIPSIDE),
    MSGNAME_ENTRY(TBM_SETBUDDY),
    MSGNAME_ENTRY(TBM_GETBUDDY),
};


//-----------------------------------------------------------------------------
// DragList Control Messages
MSGNAME rgMsgNameDL[] = 
{
    MSGNAME_ENTRY(DL_BEGINDRAG),
    MSGNAME_ENTRY(DL_DRAGGING),
    MSGNAME_ENTRY(DL_DROPPED),
    MSGNAME_ENTRY(DL_CANCELDRAG),
};


//-----------------------------------------------------------------------------
// UpDown Control Messages
MSGNAME rgMsgNameUDM[] = 
{
    MSGNAME_ENTRY(UDM_SETRANGE),
    MSGNAME_ENTRY(UDM_GETRANGE),
    MSGNAME_ENTRY(UDM_SETPOS),
    MSGNAME_ENTRY(UDM_GETPOS),
    MSGNAME_ENTRY(UDM_SETBUDDY),
    MSGNAME_ENTRY(UDM_GETBUDDY),
    MSGNAME_ENTRY(UDM_SETACCEL),
    MSGNAME_ENTRY(UDM_GETACCEL),
    MSGNAME_ENTRY(UDM_SETBASE),
    MSGNAME_ENTRY(UDM_GETBASE),
    MSGNAME_ENTRY(UDM_SETRANGE32),
    MSGNAME_ENTRY(UDM_GETRANGE32),
    MSGNAME_ENTRY(UDM_SETPOS32),
    MSGNAME_ENTRY(UDM_GETPOS32),
};


//-----------------------------------------------------------------------------
// Progress Control Messages
MSGNAME rgMsgNamePBM[] = 
{
    MSGNAME_ENTRY(PBM_SETRANGE),
    MSGNAME_ENTRY(PBM_SETPOS),
    MSGNAME_ENTRY(PBM_DELTAPOS),
    MSGNAME_ENTRY(PBM_SETSTEP),
    MSGNAME_ENTRY(PBM_STEPIT),
    MSGNAME_ENTRY(PBM_SETRANGE32),
    MSGNAME_ENTRY(PBM_GETRANGE),
    MSGNAME_ENTRY(PBM_GETPOS),
    MSGNAME_ENTRY(PBM_SETBARCOLOR),
    MSGNAME_ENTRY(PBM_SETMARQUEE),
};


//-----------------------------------------------------------------------------
// Hotkey Control Messages
MSGNAME rgMsgNameHKM[] = 
{
    MSGNAME_ENTRY(HKM_SETHOTKEY),
    MSGNAME_ENTRY(HKM_GETHOTKEY),
    MSGNAME_ENTRY(HKM_SETRULES),
};


//-----------------------------------------------------------------------------
// Listview Control Messages
MSGNAME rgMsgNameLVM[] = 
{
    MSGNAME_ENTRY(LVM_GETBKCOLOR),
    MSGNAME_ENTRY(LVM_SETBKCOLOR),
    MSGNAME_ENTRY(LVM_GETIMAGELIST),
    MSGNAME_ENTRY(LVM_SETIMAGELIST),
    MSGNAME_ENTRY(LVM_GETITEMCOUNT),
    MSGNAME_ENTRY(LVM_GETITEMA),
    MSGNAME_ENTRY(LVM_GETITEMW),
    MSGNAME_ENTRY(LVM_SETITEMA),
    MSGNAME_ENTRY(LVM_SETITEMW),
    MSGNAME_ENTRY(LVM_INSERTITEMA),
    MSGNAME_ENTRY(LVM_INSERTITEMW),
    MSGNAME_ENTRY(LVM_DELETEITEM),
    MSGNAME_ENTRY(LVM_DELETEALLITEMS),
    MSGNAME_ENTRY(LVM_GETCALLBACKMASK),
    MSGNAME_ENTRY(LVM_SETCALLBACKMASK),
    MSGNAME_ENTRY(LVM_GETNEXTITEM),
    MSGNAME_ENTRY(LVM_FINDITEMA),
    MSGNAME_ENTRY(LVM_FINDITEMW),
    MSGNAME_ENTRY(LVM_GETITEMRECT),
    MSGNAME_ENTRY(LVM_SETITEMPOSITION),
    MSGNAME_ENTRY(LVM_GETITEMPOSITION),
    MSGNAME_ENTRY(LVM_GETSTRINGWIDTHA),
    MSGNAME_ENTRY(LVM_GETSTRINGWIDTHW),
    MSGNAME_ENTRY(LVM_HITTEST),
    MSGNAME_ENTRY(LVM_ENSUREVISIBLE),
    MSGNAME_ENTRY(LVM_SCROLL),
    MSGNAME_ENTRY(LVM_REDRAWITEMS),
    MSGNAME_ENTRY(LVM_ARRANGE),
    MSGNAME_ENTRY(LVM_EDITLABELA),
    MSGNAME_ENTRY(LVM_EDITLABELW),
    MSGNAME_ENTRY(LVM_GETEDITCONTROL),
    MSGNAME_ENTRY(LVM_GETCOLUMNA),
    MSGNAME_ENTRY(LVM_GETCOLUMNW),
    MSGNAME_ENTRY(LVM_SETCOLUMNA),
    MSGNAME_ENTRY(LVM_SETCOLUMNW),
    MSGNAME_ENTRY(LVM_INSERTCOLUMNA),
    MSGNAME_ENTRY(LVM_INSERTCOLUMNW),
    MSGNAME_ENTRY(LVM_DELETECOLUMN),
    MSGNAME_ENTRY(LVM_GETCOLUMNWIDTH),
    MSGNAME_ENTRY(LVM_SETCOLUMNWIDTH),
    MSGNAME_ENTRY(LVM_GETHEADER),
    MSGNAME_ENTRY(LVM_CREATEDRAGIMAGE),
    MSGNAME_ENTRY(LVM_GETVIEWRECT),
    MSGNAME_ENTRY(LVM_GETTEXTCOLOR),
    MSGNAME_ENTRY(LVM_SETTEXTCOLOR),
    MSGNAME_ENTRY(LVM_GETTEXTBKCOLOR),
    MSGNAME_ENTRY(LVM_SETTEXTBKCOLOR),
    MSGNAME_ENTRY(LVM_GETTOPINDEX),
    MSGNAME_ENTRY(LVM_GETCOUNTPERPAGE),
    MSGNAME_ENTRY(LVM_GETORIGIN),
    MSGNAME_ENTRY(LVM_UPDATE),
    MSGNAME_ENTRY(LVM_SETITEMSTATE),
    MSGNAME_ENTRY(LVM_GETITEMSTATE),
    MSGNAME_ENTRY(LVM_GETITEMTEXTA),
    MSGNAME_ENTRY(LVM_GETITEMTEXTW),
    MSGNAME_ENTRY(LVM_SETITEMTEXTA),
    MSGNAME_ENTRY(LVM_SETITEMTEXTW),
    MSGNAME_ENTRY(LVM_SETITEMCOUNT),
    MSGNAME_ENTRY(LVM_SORTITEMS),
    MSGNAME_ENTRY(LVM_SETITEMPOSITION32),
    MSGNAME_ENTRY(LVM_GETSELECTEDCOUNT),
    MSGNAME_ENTRY(LVM_GETITEMSPACING),
    MSGNAME_ENTRY(LVM_GETISEARCHSTRINGA),
    MSGNAME_ENTRY(LVM_GETISEARCHSTRINGW),
    MSGNAME_ENTRY(LVM_SETICONSPACING),
    MSGNAME_ENTRY(LVM_SETEXTENDEDLISTVIEWSTYLE),
    MSGNAME_ENTRY(LVM_GETEXTENDEDLISTVIEWSTYLE),
    MSGNAME_ENTRY(LVM_GETSUBITEMRECT),
    MSGNAME_ENTRY(LVM_SUBITEMHITTEST),
    MSGNAME_ENTRY(LVM_SETCOLUMNORDERARRAY),
    MSGNAME_ENTRY(LVM_GETCOLUMNORDERARRAY),
    MSGNAME_ENTRY(LVM_SETHOTITEM),
    MSGNAME_ENTRY(LVM_GETHOTITEM),
    MSGNAME_ENTRY(LVM_SETHOTCURSOR),
    MSGNAME_ENTRY(LVM_GETHOTCURSOR),
    MSGNAME_ENTRY(LVM_APPROXIMATEVIEWRECT),
    MSGNAME_ENTRY(LVM_SETWORKAREAS),
    MSGNAME_ENTRY(LVM_GETWORKAREAS),
    MSGNAME_ENTRY(LVM_GETNUMBEROFWORKAREAS),
    MSGNAME_ENTRY(LVM_GETSELECTIONMARK),
    MSGNAME_ENTRY(LVM_SETSELECTIONMARK),
    MSGNAME_ENTRY(LVM_SETHOVERTIME),
    MSGNAME_ENTRY(LVM_GETHOVERTIME),
    MSGNAME_ENTRY(LVM_SETTOOLTIPS),
    MSGNAME_ENTRY(LVM_GETTOOLTIPS),
    MSGNAME_ENTRY(LVM_GETHOTLIGHTCOLOR),
    MSGNAME_ENTRY(LVM_SETHOTLIGHTCOLOR),
    MSGNAME_ENTRY(LVM_SORTITEMSEX),
    MSGNAME_ENTRY(LVM_SETBKIMAGEA),
    MSGNAME_ENTRY(LVM_SETBKIMAGEW),
    MSGNAME_ENTRY(LVM_GETBKIMAGEA),
    MSGNAME_ENTRY(LVM_GETBKIMAGEW),
    MSGNAME_ENTRY(LVM_SETSELECTEDCOLUMN),
    MSGNAME_ENTRY(LVM_SETTILEWIDTH),
    MSGNAME_ENTRY(LVM_SETVIEW),
    MSGNAME_ENTRY(LVM_GETVIEW),
    MSGNAME_ENTRY(LVM_INSERTGROUP),
    MSGNAME_ENTRY(LVM_SETGROUPINFO),
    MSGNAME_ENTRY(LVM_GETGROUPINFO),
    MSGNAME_ENTRY(LVM_REMOVEGROUP),
    MSGNAME_ENTRY(LVM_MOVEGROUP),
    MSGNAME_ENTRY(LVM_MOVEITEMTOGROUP),
    MSGNAME_ENTRY(LVM_SETGROUPMETRICS),
    MSGNAME_ENTRY(LVM_GETGROUPMETRICS),
    MSGNAME_ENTRY(LVM_ENABLEGROUPVIEW),
    MSGNAME_ENTRY(LVM_SORTGROUPS),
    MSGNAME_ENTRY(LVM_INSERTGROUPSORTED),
    MSGNAME_ENTRY(LVM_REMOVEALLGROUPS),
    MSGNAME_ENTRY(LVM_HASGROUP),
    MSGNAME_ENTRY(LVM_SETTILEVIEWINFO),
    MSGNAME_ENTRY(LVM_GETTILEVIEWINFO),
    MSGNAME_ENTRY(LVM_SETTILEINFO),
    MSGNAME_ENTRY(LVM_GETTILEINFO),
    MSGNAME_ENTRY(LVM_SETINSERTMARK),
    MSGNAME_ENTRY(LVM_GETINSERTMARK),
    MSGNAME_ENTRY(LVM_INSERTMARKHITTEST),
    MSGNAME_ENTRY(LVM_GETINSERTMARKRECT),
    MSGNAME_ENTRY(LVM_SETINSERTMARKCOLOR),
    MSGNAME_ENTRY(LVM_GETINSERTMARKCOLOR),
    MSGNAME_ENTRY(LVM_SETINFOTIP),
    MSGNAME_ENTRY(LVM_GETSELECTEDCOLUMN),
    MSGNAME_ENTRY(LVM_ISGROUPVIEWENABLED),
    MSGNAME_ENTRY(LVM_GETOUTLINECOLOR),
    MSGNAME_ENTRY(LVM_SETOUTLINECOLOR),
    MSGNAME_ENTRY(LVM_KEYBOARDSELECTED),
    MSGNAME_ENTRY(LVM_CANCELEDITLABEL),
    MSGNAME_ENTRY(LVM_MAPINDEXTOID),
    MSGNAME_ENTRY(LVM_MAPIDTOINDEX),
    MSGNAME_ENTRY(LVM_ISITEMVISIBLE),
    MSGNAME_ENTRY(LVM_SETLVRANGEOBJECT),
    MSGNAME_ENTRY(LVM_RESETEMPTYTEXT),
    MSGNAME_ENTRY(LVM_SETFROZENITEM),
    MSGNAME_ENTRY(LVM_GETFROZENITEM),
    MSGNAME_ENTRY(LVM_SETFROZENSLOT),
    MSGNAME_ENTRY(LVM_GETFROZENSLOT),
    MSGNAME_ENTRY(LVM_SETVIEWMARGINS),
    MSGNAME_ENTRY(LVM_GETVIEWMARGINS),
};


//-----------------------------------------------------------------------------
// Treeview Control Messages
MSGNAME rgMsgNameTVM[] = 
{
    MSGNAME_ENTRY(TV_FINDITEM),

    MSGNAME_ENTRY(TVM_INSERTITEMA),
    MSGNAME_ENTRY(TVM_INSERTITEMW),
    MSGNAME_ENTRY(TVM_DELETEITEM),
    MSGNAME_ENTRY(TVM_EXPAND),
    MSGNAME_ENTRY(TVM_GETITEMRECT),
    MSGNAME_ENTRY(TVM_GETCOUNT),
    MSGNAME_ENTRY(TVM_GETINDENT),
    MSGNAME_ENTRY(TVM_SETINDENT),
    MSGNAME_ENTRY(TVM_GETIMAGELIST),
    MSGNAME_ENTRY(TVM_SETIMAGELIST),
    MSGNAME_ENTRY(TVM_GETNEXTITEM),
    MSGNAME_ENTRY(TVM_SELECTITEM),
    MSGNAME_ENTRY(TVM_GETITEMA),
    MSGNAME_ENTRY(TVM_GETITEMW),
    MSGNAME_ENTRY(TVM_SETITEMA),
    MSGNAME_ENTRY(TVM_SETITEMW),
    MSGNAME_ENTRY(TVM_EDITLABELA),
    MSGNAME_ENTRY(TVM_EDITLABELW),
    MSGNAME_ENTRY(TVM_GETEDITCONTROL),
    MSGNAME_ENTRY(TVM_GETVISIBLECOUNT),
    MSGNAME_ENTRY(TVM_HITTEST),
    MSGNAME_ENTRY(TVM_CREATEDRAGIMAGE),
    MSGNAME_ENTRY(TVM_SORTCHILDREN),
    MSGNAME_ENTRY(TVM_ENSUREVISIBLE),
    MSGNAME_ENTRY(TVM_SORTCHILDRENCB),
    MSGNAME_ENTRY(TVM_ENDEDITLABELNOW),
    MSGNAME_ENTRY(TVM_GETISEARCHSTRINGA),
    MSGNAME_ENTRY(TVM_GETISEARCHSTRINGW),
    MSGNAME_ENTRY(TVM_SETTOOLTIPS),
    MSGNAME_ENTRY(TVM_GETTOOLTIPS),
    MSGNAME_ENTRY(TVM_SETINSERTMARK),
    MSGNAME_ENTRY(TVM_SETITEMHEIGHT),
    MSGNAME_ENTRY(TVM_GETITEMHEIGHT),
    MSGNAME_ENTRY(TVM_SETBKCOLOR),
    MSGNAME_ENTRY(TVM_SETTEXTCOLOR),
    MSGNAME_ENTRY(TVM_GETBKCOLOR),
    MSGNAME_ENTRY(TVM_GETTEXTCOLOR),
    MSGNAME_ENTRY(TVM_SETSCROLLTIME),
    MSGNAME_ENTRY(TVM_GETSCROLLTIME),
    MSGNAME_ENTRY(TVM_SETBORDER),
    MSGNAME_ENTRY(TVM_GETBORDER),
    MSGNAME_ENTRY(TVM_SETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TVM_GETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TVM_GETITEMSTATE),
    MSGNAME_ENTRY(TVM_SETLINECOLOR),
    MSGNAME_ENTRY(TVM_GETLINECOLOR),
    MSGNAME_ENTRY(TVM_MAPACCIDTOHTREEITEM),
    MSGNAME_ENTRY(TVM_MAPHTREEITEMTOACCID),
    MSGNAME_ENTRY(TVM_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TVM_GETEXTENDEDSTYLE),
};


//-----------------------------------------------------------------------------
// ComboBoxEx Control Messages
MSGNAME rgMsgNameCBEM[] = 
{
    MSGNAME_ENTRY(CBEM_INSERTITEMA),
    MSGNAME_ENTRY(CBEM_SETIMAGELIST),
    MSGNAME_ENTRY(CBEM_GETIMAGELIST),
    MSGNAME_ENTRY(CBEM_GETITEMA),
    MSGNAME_ENTRY(CBEM_SETITEMA),
    MSGNAME_ENTRY(CBEM_GETCOMBOCONTROL),
    MSGNAME_ENTRY(CBEM_GETEDITCONTROL),
    MSGNAME_ENTRY(CBEM_SETEXSTYLE),
    MSGNAME_ENTRY(CBEM_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(CBEM_GETEXSTYLE),
    MSGNAME_ENTRY(CBEM_GETEXTENDEDSTYLE),
    MSGNAME_ENTRY(CBEM_SETEXSTYLE),
    MSGNAME_ENTRY(CBEM_GETEXSTYLE),
    MSGNAME_ENTRY(CBEM_HASEDITCHANGED),
    MSGNAME_ENTRY(CBEM_INSERTITEMW),
    MSGNAME_ENTRY(CBEM_SETITEMW),
    MSGNAME_ENTRY(CBEM_GETITEMW),
};

//-----------------------------------------------------------------------------
// Tab Control Messages
MSGNAME rgMsgNameTCM[] = 
{
    MSGNAME_ENTRY(TCM_GETBKCOLOR),
    MSGNAME_ENTRY(TCM_SETBKCOLOR),
    MSGNAME_ENTRY(TCM_GETIMAGELIST),
    MSGNAME_ENTRY(TCM_SETIMAGELIST),
    MSGNAME_ENTRY(TCM_GETITEMCOUNT),
    MSGNAME_ENTRY(TCM_GETITEMA),
    MSGNAME_ENTRY(TCM_GETITEMW),
    MSGNAME_ENTRY(TCM_SETITEMA),
    MSGNAME_ENTRY(TCM_SETITEMW),
    MSGNAME_ENTRY(TCM_INSERTITEMA),
    MSGNAME_ENTRY(TCM_INSERTITEMW),
    MSGNAME_ENTRY(TCM_DELETEITEM),
    MSGNAME_ENTRY(TCM_DELETEALLITEMS),
    MSGNAME_ENTRY(TCM_GETITEMRECT),
    MSGNAME_ENTRY(TCM_GETCURSEL),
    MSGNAME_ENTRY(TCM_SETCURSEL),
    MSGNAME_ENTRY(TCM_HITTEST),
    MSGNAME_ENTRY(TCM_SETITEMEXTRA),
    MSGNAME_ENTRY(TCM_ADJUSTRECT),
    MSGNAME_ENTRY(TCM_SETITEMSIZE),
    MSGNAME_ENTRY(TCM_REMOVEIMAGE),
    MSGNAME_ENTRY(TCM_SETPADDING),
    MSGNAME_ENTRY(TCM_GETROWCOUNT),
    MSGNAME_ENTRY(TCM_GETTOOLTIPS),
    MSGNAME_ENTRY(TCM_SETTOOLTIPS),
    MSGNAME_ENTRY(TCM_GETCURFOCUS),
    MSGNAME_ENTRY(TCM_SETCURFOCUS),
    MSGNAME_ENTRY(TCM_SETMINTABWIDTH),
    MSGNAME_ENTRY(TCM_DESELECTALL),
    MSGNAME_ENTRY(TCM_HIGHLIGHTITEM),
    MSGNAME_ENTRY(TCM_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TCM_GETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TCM_GETOBJECT),
};


//-----------------------------------------------------------------------------
// Animate Control Messages
MSGNAME rgMsgNameACM[] = 
{
    MSGNAME_ENTRY(ACM_OPENA),
    MSGNAME_ENTRY(ACM_OPENW),
    MSGNAME_ENTRY(ACM_PLAY),
    MSGNAME_ENTRY(ACM_STOP),
};


//-----------------------------------------------------------------------------
// MonthCal Control Messages
MSGNAME rgMsgNameMCM[] = 
{
    MSGNAME_ENTRY(MCM_FIRST),
    MSGNAME_ENTRY(MCM_GETCURSEL),
    MSGNAME_ENTRY(MCM_SETCURSEL),
    MSGNAME_ENTRY(MCM_GETMAXSELCOUNT),
    MSGNAME_ENTRY(MCM_SETMAXSELCOUNT),
    MSGNAME_ENTRY(MCM_GETSELRANGE),
    MSGNAME_ENTRY(MCM_SETSELRANGE),
    MSGNAME_ENTRY(MCM_GETMONTHRANGE),
    MSGNAME_ENTRY(MCM_SETDAYSTATE),
    MSGNAME_ENTRY(MCM_GETMINREQRECT),
    MSGNAME_ENTRY(MCM_SETCOLOR),
    MSGNAME_ENTRY(MCM_GETCOLOR),
    MSGNAME_ENTRY(MCM_SETTODAY),
    MSGNAME_ENTRY(MCM_GETTODAY),
    MSGNAME_ENTRY(MCM_HITTEST),
    MSGNAME_ENTRY(MCM_SETFIRSTDAYOFWEEK),
    MSGNAME_ENTRY(MCM_GETFIRSTDAYOFWEEK),
    MSGNAME_ENTRY(MCM_GETRANGE),
    MSGNAME_ENTRY(MCM_SETRANGE),
    MSGNAME_ENTRY(MCM_GETMONTHDELTA),
    MSGNAME_ENTRY(MCM_SETMONTHDELTA),
    MSGNAME_ENTRY(MCM_GETMAXTODAYWIDTH),
};

//-----------------------------------------------------------------------------
// DateTimePicker Control Messages
MSGNAME rgMsgNameDTM[] = 
{
    MSGNAME_ENTRY(DTM_FIRST),
    MSGNAME_ENTRY(DTM_GETSYSTEMTIME),
    MSGNAME_ENTRY(DTM_SETSYSTEMTIME),
    MSGNAME_ENTRY(DTM_GETRANGE),
    MSGNAME_ENTRY(DTM_SETRANGE),
    MSGNAME_ENTRY(DTM_SETFORMATA),
    MSGNAME_ENTRY(DTM_SETFORMATW),
    MSGNAME_ENTRY(DTM_SETMCCOLOR),
    MSGNAME_ENTRY(DTM_GETMCCOLOR),
    MSGNAME_ENTRY(DTM_GETMONTHCAL),
    MSGNAME_ENTRY(DTM_SETMCFONT),
    MSGNAME_ENTRY(DTM_GETMCFONT),
};


//-----------------------------------------------------------------------------
// IP Address Control Messages
MSGNAME rgMsgNameIPM[] = 
{
    MSGNAME_ENTRY(IPM_CLEARADDRESS),
    MSGNAME_ENTRY(IPM_SETADDRESS),
    MSGNAME_ENTRY(IPM_GETADDRESS),
    MSGNAME_ENTRY(IPM_SETRANGE),
    MSGNAME_ENTRY(IPM_SETFOCUS),
    MSGNAME_ENTRY(IPM_ISBLANK),
};


//-----------------------------------------------------------------------------
// Pager Control Messages
MSGNAME rgMsgNamePGM[] = 
{
    MSGNAME_ENTRY(PGM_SETCHILD),
    MSGNAME_ENTRY(PGM_RECALCSIZE),
    MSGNAME_ENTRY(PGM_FORWARDMOUSE),
    MSGNAME_ENTRY(PGM_SETBKCOLOR),
    MSGNAME_ENTRY(PGM_GETBKCOLOR),
    MSGNAME_ENTRY(PGM_SETBORDER),
    MSGNAME_ENTRY(PGM_GETBORDER),
    MSGNAME_ENTRY(PGM_SETPOS),
    MSGNAME_ENTRY(PGM_GETPOS),
    MSGNAME_ENTRY(PGM_SETBUTTONSIZE),
    MSGNAME_ENTRY(PGM_GETBUTTONSIZE),
    MSGNAME_ENTRY(PGM_GETBUTTONSTATE),
    MSGNAME_ENTRY(PGM_SETSCROLLINFO),
};


//-----------------------------------------------------------------------------
// Button Control Messages
MSGNAME rgMsgNameBCM[] = 
{
    MSGNAME_ENTRY(BCM_GETIDEALSIZE),
    MSGNAME_ENTRY(BCM_SETIMAGELIST),
    MSGNAME_ENTRY(BCM_GETIMAGELIST),
    MSGNAME_ENTRY(BCM_SETTEXTMARGIN),
    MSGNAME_ENTRY(BCM_GETTEXTMARGIN),
};


//-----------------------------------------------------------------------------
// Edit Control Messages
MSGNAME rgMsgNameEM[] = 
{
    MSGNAME_ENTRY(EM_SETCUEBANNER),
    MSGNAME_ENTRY(EM_GETCUEBANNER),
    MSGNAME_ENTRY(EM_SHOWBALLOONTIP),
    MSGNAME_ENTRY(EM_HIDEBALLOONTIP),
};


//-----------------------------------------------------------------------------
// Combobox Control Messages
MSGNAME rgMsgNameCB[] = 
{
    MSGNAME_ENTRY(CB_SETMINVISIBLE),
    MSGNAME_ENTRY(CB_GETMINVISIBLE),
};


//-----------------------------------------------------------------------------
// Link Window Control Messages
MSGNAME rgMsgNameLM[] = 
{
    MSGNAME_ENTRY(LM_HITTEST),
    MSGNAME_ENTRY(LM_GETIDEALHEIGHT),
    MSGNAME_ENTRY(LM_SETITEM),
    MSGNAME_ENTRY(LM_GETITEM),
};


MSGMAP rgMsgMap[] = 
{
    { "ComCtl32",          "ComCtl32",       rgMsgNameCCM,  ARRAYSIZE(rgMsgNameCCM)  },
    { WC_HEADERA,          "Header",         rgMsgNameHDM,  ARRAYSIZE(rgMsgNameHDM)  },
    { TOOLBARCLASSNAMEA,   "Toolbar",        rgMsgNameTB,   ARRAYSIZE(rgMsgNameTB)   },
    { REBARCLASSNAMEA,     "Rebar",          rgMsgNameRB,   ARRAYSIZE(rgMsgNameRB)   },
    { TOOLTIPS_CLASSA,     "Tooltips",       rgMsgNameTTM,  ARRAYSIZE(rgMsgNameTTM)  },
    { STATUSCLASSNAMEA,    "Status",         rgMsgNameSB,   ARRAYSIZE(rgMsgNameSB)   },
    { BUTTONLISTBOX,       BUTTONLISTBOX,    rgMsgNameBL,   ARRAYSIZE(rgMsgNameBL)   },
    { TRACKBAR_CLASSA,     "TrackBar",       rgMsgNameTBM,  ARRAYSIZE(rgMsgNameTBM)  },
    { "DragList",          "Draglist",       rgMsgNameDL,   ARRAYSIZE(rgMsgNameDL)   },
    { UPDOWN_CLASSA,       "UpDown",         rgMsgNameUDM,  ARRAYSIZE(rgMsgNameUDM)  },
    { PROGRESS_CLASSA,     "Progress",       rgMsgNamePBM,  ARRAYSIZE(rgMsgNamePBM)  },
    { HOTKEY_CLASSA,       "Hotkey",         rgMsgNameHKM,  ARRAYSIZE(rgMsgNameHKM)  },
    { WC_LISTVIEWA,        "Listview",       rgMsgNameLVM,  ARRAYSIZE(rgMsgNameLVM)  },
    { WC_TREEVIEWA,        "Treeview",       rgMsgNameTVM,  ARRAYSIZE(rgMsgNameTVM)  },
    { WC_COMBOBOXEXA,      "ComboboxEx",     rgMsgNameCBEM, ARRAYSIZE(rgMsgNameCBEM) },
    { WC_TABCONTROLA,      "Tab",            rgMsgNameTCM,  ARRAYSIZE(rgMsgNameTCM)  },
    { ANIMATE_CLASSA,      "Animate",        rgMsgNameACM,  ARRAYSIZE(rgMsgNameACM)  },
    { MONTHCAL_CLASSA,     "MonthCal",       rgMsgNameMCM,  ARRAYSIZE(rgMsgNameMCM)  },
    { DATETIMEPICK_CLASSA, "DateTimePicker", rgMsgNameDTM,  ARRAYSIZE(rgMsgNameDTM)  },
    { WC_IPADDRESSA,       "IPAddress",      rgMsgNameIPM,  ARRAYSIZE(rgMsgNameIPM)  },
    { WC_PAGESCROLLERA,    "Pager",          rgMsgNamePGM,  ARRAYSIZE(rgMsgNamePGM)  },
    { WC_BUTTONA,          WC_BUTTONA,       rgMsgNameBCM,  ARRAYSIZE(rgMsgNameBCM)  },
    { WC_EDITA,            WC_EDITA,         rgMsgNameEM,   ARRAYSIZE(rgMsgNameEM)   },
    { WC_COMBOBOXA,        WC_COMBOBOXA,     rgMsgNameCB,   ARRAYSIZE(rgMsgNameCB)   },
    { "SysLink",           "SysLink",        rgMsgNameLM,   ARRAYSIZE(rgMsgNameLM)   },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\shlexts.c ===
/****************************** Module Header ******************************\
* Module Name: shlexts.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* This module contains user related debugging extensions.
*
* History:
* 10/28/97 created by cdturner (butchered from the userexts.dll)
\***************************************************************************/

#include <precomp.h>
#pragma hdrstop

#include <winver.h>
#include <shlwapi.h>


char * pszExtName = "SHLEXTS";

#include <stdexts.h>
#include <stdexts.c>

BOOL bShowFlagNames = TRUE;
#define NO_FLAG INVALID_HANDLE_VALUE // use this for non-meaningful entries.

LPSTR apszSFGAOFlags[] =
{
    "SFGAO_CANCOPY",        // 0x00000001L
    "SFGAO_CANMOVE",        // 0x00000002L
    "SFGAO_CANLINK",        // 0x00000004L
    NO_FLAG,
    "SFGAO_CANRENAME",      // 0x00000010L     // Objects can be renamed
    "SFGAO_CANDELETE",      // 0x00000020L     // Objects can be deleted
    "SFGAO_HASPROPSHEET",   // 0x00000040L     // Objects have property sheets
    NO_FLAG,
    "SFGAO_DROPTARGET",     // 0x00000100L     // Objects are drop target
    NO_FLAG,
    NO_FLAG,
    NO_FLAG,
    "SFGAO_LINK",           // 0x00010000L     // Shortcut (link)
    "SFGAO_SHARE",          // 0x00020000L     // shared
    "SFGAO_READONLY",       // 0x00040000L     // read-only
    "SFGAO_GHOSTED",        // 0x00080000L     // ghosted icon
    "SFGAO_NONENUMERATED",  // 0x00100000L     // is a non-enumerated object
    "SFGAO_NEWCONTENT",     // 0x00200000L     // should show bold in explorer tree
    NO_FLAG,
    NO_FLAG,
    "SFGAO_VALIDATE",       // 0x01000000L     // invalidate cached information
    "SFGAO_REMOVABLE",      // 0x02000000L     // is this removeable media?
    "SFGAO_COMPRESSED",     // 0x04000000L     // Object is compressed (use alt color)
    "SFGAO_BROWSABLE",      // 0x08000000L     // is in-place browsable
    "SFGAO_FILESYSANCESTOR",// 0x10000000L     // It contains file system folder
    "SFGAO_FOLDER",         // 0x20000000L     // It's a folder.
    "SFGAO_FILESYSTEM",     // 0x40000000L     // is a file system thing (file/folder/root)
    "SFGAO_HASSUBFOLDER",   // 0x80000000L     // Expandable in the map pane
    NULL
};

LPSTR apszSLDFFlags[] = 
{
   "SLDF_HAS_ID_LIST",      // = 0x0001,   // Shell link saved with ID list
   "SLDF_HAS_LINK_INFO",    // = 0x0002,   // Shell link saved with LinkInfo
   "SLDF_HAS_NAME",         // = 0x0004,
   "SLDF_HAS_RELPATH",      // = 0x0008,
   "SLDF_HAS_WORKINGDIR",   // = 0x0010,
   "SLDF_HAS_ARGS",         // = 0x0020,
   "SLDF_HAS_ICONLOCATION", // = 0x0040,
   "SLDF_UNICODE",          // = 0x0080,   // the strings are unicode (NT is comming!)
   "SLDF_FORCE_NO_LINKINFO",// = 0x0100,   // don't create a LINKINFO (make a dumb link)
   "SLDF_HAS_EXP_SZ"        // = 0x0200,   // the link contains expandable env strings
   "SLDF_RUN_IN_SEPARATE",  // = 0x0400,   // Run the 16-bit target exe in a separate VDM/WOW
   "SLDF_HAS_LOGO3ID",      // = 0x0800,   // this link is a special Logo3/MSICD link
   "SLDF_HAS_DARWINID",     // = 0x1000    // this link is a special Darwin link
   NULL
};

LPSTR apszFWFFlags[] =
{
    "FWF_AUTOARRANGE",          // =  0x0001,
    "FWF_ABBREVIATEDNAMES",     // =  0x0002,
    "FWF_SNAPTOGRID",           // =  0x0004,
    "FWF_OWNERDATA",            // =  0x0008,
    "FWF_BESTFITWINDOW",        // =  0x0010,
    "FWF_DESKTOP",              // =  0x0020,
    "FWF_SINGLESEL",            // =  0x0040,
    "FWF_NOSUBFOLDERS",         // =  0x0080,
    "FWF_TRANSPARENT",          // =  0x0100,
    "FWF_NOCLIENTEDGE",         // =  0x0200,
    "FWF_NOSCROLL",             // =  0x0400,
    "FWF_ALIGNLEFT",            // =  0x0800,
    "FWF_NOICONS",              // =  0x1000,
    "FWF_SINGLECLICKACTIVATE",  // = 0x8000  // TEMPORARY -- NO UI FOR THIS
    NULL
};

LPSTR apszICIFlags[] = 
{
    "ICIFLAG_LARGE",       // 0x0001
    "ICIFLAG_SMALL",       // 0x0002
    "ICIFLAG_BITMAP",      // 0x0004
    "ICIFLAG_ICON",        // 0x0008
    "ICIFLAG_INDEX",       // 0x0010
    "ICIFLAG_NAME",        // 0x0020
    "ICIFLAG_FLAGS",       // 0x0040
    "ICIFLAG_NOUSAGE",     // 0x0080
    NULL
};

LPSTR apszFDFlags[] =
{
    "FD_CLSID",            // = 0x0001,
    "FD_SIZEPOINT",        // = 0x0002,
    "FD_ATTRIBUTES",       // = 0x0004,
    "FD_CREATETIME",       // = 0x0008,
    "FD_ACCESSTIME",       // = 0x0010,
    "FD_WRITESTIME",       // = 0x0020,
    "FD_FILESIZE",         // = 0x0040,
    "FD_LINKUI",           // = 0x8000,       // 'link' UI is prefered
    NULL
};

LPSTR apszSHCNEFlags[] =
{
    "SHCNE_RENAMEITEM",         // 0x00000001L
    "SHCNE_CREATE",             // 0x00000002L
    "SHCNE_DELETE",             // 0x00000004L
    "SHCNE_MKDIR",              // 0x00000008L
    "SHCNE_RMDIR",              // 0x00000010L
    "SHCNE_MEDIAINSERTED",      // 0x00000020L
    "SHCNE_MEDIAREMOVED",       // 0x00000040L
    "SHCNE_DRIVEREMOVED",       // 0x00000080L
    "SHCNE_DRIVEADD",           // 0x00000100L
    "SHCNE_NETSHARE",           // 0x00000200L
    "SHCNE_NETUNSHARE",         // 0x00000400L
    "SHCNE_ATTRIBUTES",         // 0x00000800L
    "SHCNE_UPDATEDIR",          // 0x00001000L
    "SHCNE_UPDATEITEM",         // 0x00002000L
    "SHCNE_SERVERDISCONNECT",   // 0x00004000L
    "SHCNE_UPDATEIMAGE",        // 0x00008000L
    "SHCNE_DRIVEADDGUI",        // 0x00010000L
    "SHCNE_RENAMEFOLDER",       // 0x00020000L
    "SHCNE_FREESPACE",          // 0x00040000L
    NO_FLAG,
    NO_FLAG,
    NO_FLAG,
    "SHCNE_EXTENDED_EVENT",     // 0x04000000L
    "SHCNE_ASSOCCHANGED",       // 0x08000000L
    NULL
};

LPSTR apszSSFFlags[] =
{
    "SSF_SHOWALLOBJECTS",       // 0x0001
    "SSF_SHOWEXTENSIONS",       // 0x0002
    "SSF_WIN95UNUSED",          // 0x0004  // ;Internal - corresponding SHELLSTATE fields don't exist in SHELLFLAGSTATE
    "SSF_SHOWCOMPCOLOR",        // 0x0008
    "SSF_SORTCOLUMNS",          // 0x0010  // ;Internal - corresponding SHELLSTATE fields don't exist in SHELLFLAGSTATE
    "SSF_SHOWSYSFILES",         // 0x0020
    "SSF_DOUBLECLICKINWEBVIEW", // 0x0080
    "SSF_SHOWATTRIBCOL",        // 0x0100
    "SSF_DESKTOPHTML",          // 0x0200
    "SSF_WIN95CLASSIC",         // 0x0400
    "SSF_DONTPRETTYPATH",       // 0x0800
    "SSF_MAPNETDRVBUTTON",      // 0x1000
    "SSF_SHOWINFOTIP",          // 0x2000
    "SSF_HIDEICONS",            // 0x4000
    "SSF_NOCONFIRMRECYCLE",     // 0x8000
    "SSF_FILTER",               // 0x00010000  // ;Internal - corresponding SHELLSTATE fields don't exist in SHELLFLAGSTATE
    "SSF_WEBVIEW",              // 0x00020000  // ;Internal
    "SSF_SHOWSUPERHIDDEN",      // 0x00040000  // ;Internal
    "SSF_SEPPROCESS",           // 0x00080000  // ;Internal
    "SSF_NONETCRAWLING",        // 0x00100000  // ;Internal
    "SSF_STARTPANELON",         // 0x00200000  // ;Internal

    NULL
};

enum GF_FLAGS {
    GL_SFGAO = 0,
    GL_SLDF,
    GL_FWF,
    GL_ICI,
    GL_FD,
    GL_SHCNE,
    GL_SSF,
    GF_MAX,
};

struct _tagFlags
{
    LPSTR * apszFlags;
    LPSTR pszFlagsname;
} argFlag[GF_MAX] = 
{
    {apszSFGAOFlags,    "SFGAO"},
    {apszSLDFFlags,     "SLD"},
    {apszFWFFlags,      "FWF"},
    {apszICIFlags,      "ICIFLAG"},
    {apszFDFlags,       "FD"},
    {apszSHCNEFlags,    "SHCNE"},
    {apszSSFFlags,      "SSF"}
};

/************************************************************************\
* Procedure: GetFlags
*
* Description:
*
* Converts a 32bit set of flags into an appropriate string.
* pszBuf should be large enough to hold this string, no checks are done.
* pszBuf can be NULL, allowing use of a local static buffer but note that
* this is not reentrant.
* Output string has the form: "FLAG1 | FLAG2 ..." or "0"
*
* Returns: pointer to given or static buffer with string in it.
*
* 6/9/1995  Created SanfordS
* 11/5/1997 cdturner changed the aapszFlag type 
*
\************************************************************************/
LPSTR GetFlags(
    WORD    wType,
    DWORD   dwFlags,
    LPSTR   pszBuf,
    BOOL    fPrintZero)
{
    static char szT[512];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    LPSTR *apszFlags;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    if (!bShowFlagNames) {
        sprintf(pszBuf, "%x", dwFlags);
        return pszBuf;
    }

    *pszBuf = '\0';

    if (wType >= GF_MAX) {
        strcpy(pszBuf, "Invalid flag type.");
        return pszBuf;
    }

    apszFlags = argFlag[wType].apszFlags;

    for (i = 0; dwFlags; dwFlags >>= 1, i++) {
        if (!fNoMoreNames && apszFlags[i] == NULL) {
            fNoMoreNames = TRUE;
        }

        if (dwFlags & 1) {
            if (!fFirst) {
                strcat(pszBuf, " | ");
            } else {
                fFirst = FALSE;
            }

            if (fNoMoreNames || apszFlags[i] == NO_FLAG) {
                char ach[16];
                sprintf(ach, "0x%lx", 1 << i);
                strcat(pszBuf, ach);
            } else {
                strcat(pszBuf, apszFlags[i]);
            }
        }
    }

    if (fFirst && fPrintZero) {
        sprintf(pszBuf, "0");
    }

    return pszBuf;
}

/************************************************************************\
* Procedure: Iflags
*
* Description:
*
*     outputs the list of flags for the given flags type
*
* 11/5/1997 Created cdturner
*
\************************************************************************/
BOOL Iflags( DWORD dwOpts,
             LPSTR pszArgs )
{
    CHAR szBuffer[100];
    int iOffset = 0;
    int iFlags;
    LPDWORD pAddr;
    BOOL bAddr = FALSE;
    DWORD dwValue;
    LPSTR pszOut;
    
    if ( dwOpts & OFLAG(l))
    {
        // list all the struct names
        Print("Flags types known:\n");

        for ( iFlags = 0; iFlags < GF_MAX; iFlags ++ )
        {
            sprintf( szBuffer, "    %s\n", argFlag[iFlags].pszFlagsname);
            Print( szBuffer );
        }
        return TRUE;
    }

    // skip whitespace
    while ( *pszArgs == ' ' )
        pszArgs ++;

    // now grab the flagsname
    while ( pszArgs[iOffset] != ' ' && pszArgs[iOffset] != '\0' )
    {
        szBuffer[iOffset] = pszArgs[iOffset];
        iOffset ++;
    };

    // terminate the string
    szBuffer[iOffset] = 0;
    
    // find the flags value
    for ( iFlags = 0; iFlags < GF_MAX; iFlags ++ )
    {
        if ( lstrcmpA( szBuffer, argFlag[iFlags].pszFlagsname ) == 0 )
            break;
    }

    if ( iFlags >= GF_MAX )
    {
        Print( "unknown flagsname - ");
        Print( szBuffer );
        Print( "\n" );
        return TRUE;
    }

    // skip white space
    while ( pszArgs[iOffset] == ' ' )
        iOffset ++;

    if ( pszArgs[iOffset] == '*' )
    {
        bAddr = TRUE;
        iOffset ++;
    }
    
    pAddr = (LPDWORD) EvalExp( pszArgs + iOffset );

    if ( bAddr )
    {
        if ( !tryDword( &dwValue, pAddr ) )
        {
            Print( "unable to access memory at that location\n");
            return TRUE;
        }
    }
    else 
    {
        dwValue = PtrToUlong(pAddr);
    }
    
    pszOut = GetFlags( (WORD) iFlags, dwValue, NULL, TRUE ); 
    if ( pszOut )
    {
        sprintf( szBuffer, "Value = %8X, pAddr = %8X\n", dwValue, (DWORD_PTR)pAddr );
        Print( szBuffer );
        Print( pszOut );
        Print( "\n" );
    }
    
    return TRUE;
}

/************************************************************************\
* Procedure: Itest
*
* Description: Tests the basic stdexts macros and functions - a good check
*   on the debugger extensions in general before you waste time debuging
*   entensions.
*
* Returns: fSuccess
*
* 11/4/1997 Created cdturner
*
\************************************************************************/
BOOL Itest()
{
    Print("Print test!\n");
    SAFEWHILE(TRUE) 
    {
        Print("SAFEWHILE test...  Hit Ctrl-C NOW!\n");
    }
    return TRUE;
}



/************************************************************************\
* Procedure: Iver
*
* Description: Dumps versions of extensions and winsrv/win32k
*
* Returns: fSuccess
*
* 11/4/1997 Created cdturner
*
\************************************************************************/
BOOL Iver()
{
#if DEBUG
    Print("SHLEXTS version: Debug.\n");
#else
    Print("SHLEXTS version: Retail.\n");
#endif

    return TRUE;
}


/************************************************************************\
*
*   DumpVerboseFileInfo
*
*   Stolen from MSDN.
*
\************************************************************************/

typedef struct LANGANDCODEPAGE {
    WORD wLang;
    WORD wCP;
} LANGANDCODEPAGE;

void DumpVersionString(LPVOID pBlock, LANGANDCODEPAGE *lpTranslate, LPCSTR pszKey)
{
    char szBuf[128];
    LPSTR pszValue;
    DWORD cb;

    wsprintfA(szBuf, "\\StringFileInfo\\%04x%04x\\%s",
              lpTranslate->wLang, lpTranslate->wCP, pszKey);
    if (VerQueryValueA(pBlock, szBuf, (LPVOID*)&pszValue, &cb) &&
        lstrlenA(pszValue))         // lstrlen traps exceptions
    {
        Print(szBuf+16);            // skip over "\\StringFileInfo\\"
        Print(" = ");
        Print(pszValue);
        Print("\n");
    }
}

LPCSTR c_rgszVersionKeys[] =
{
    "CompanyName",
    "FileDescription",
    "InternalName",
    "OriginalFilename",
    "ProductName",
    "ProductVersion",
    "FileVersion",
    "LegalCopyright",
    "LegalTrademarks",
    "PrivateBuild",
    "SpecialBuild",
    "Comments",
    NULL,
};

void DumpVerboseFileInfo(LPVOID pBlock)
{
    LANGANDCODEPAGE *lpTranslate;
    DWORD cbTranslate;

    // Read the list of languages and code pages
    if (VerQueryValueA(pBlock, "\\VarFileInfo\\Translation",
                       (LPVOID*)&lpTranslate, &cbTranslate))
    {
        UINT i;
        for (i = 0; i < cbTranslate/sizeof(*lpTranslate) && !IsCtrlCHit(); i++)
        {
            LPCSTR *ppszVK;
            for (ppszVK  = c_rgszVersionKeys; *ppszVK && !IsCtrlCHit(); ppszVK++)
            {
                DumpVersionString(pBlock, &lpTranslate[i], *ppszVK);
            }
        }

    }
}

/************************************************************************\
* Procedure: Ifilever
*
* Description: Dumps versions of extensions and winsrv/win32k
*
* Returns: fSuccess
*
* 11/4/1997 Created cdturner
*
\************************************************************************/
BOOL Ifilever( DWORD dwOpts,
             LPSTR pszArgs )
{
    HINSTANCE hDll = NULL;
    DLLGETVERSIONPROC pGetVer = NULL;
    DWORD dwHandle;
    DWORD dwBlockLen;
    LPVOID pBlock = NULL;
    char szMessage[200];
    BOOL fSkipLoad = FALSE;
    
    
    if ( pszArgs == NULL || lstrlenA( pszArgs ) == 0 )
    {
        pszArgs = "Shell32.dll";    // default filename
    }

    if ( !dwOpts )
    {
        dwOpts = OFLAG(n);          // default flags
    }

    Print("filever ");
    Print(pszArgs);
    Print("\n");
            
    if ( dwOpts & OFLAG(d) )
    {
        hDll = LoadLibraryA(pszArgs);
        if ( hDll == NULL )
        {
            Print("LoadLibrary failed\n");
        }
        else
        {
            pGetVer = (DLLGETVERSIONPROC) GetProcAddress( hDll, "DllGetVersion");
            if ( pGetVer )
            {
                DLLVERSIONINFO rgVerInfo;

                rgVerInfo.cbSize = sizeof( rgVerInfo );

                pGetVer( &rgVerInfo );

                wsprintfA( szMessage, "DllGetVersion\n    Major = %d\n    Minor = %d\n    Build = %d\n",
                    rgVerInfo.dwMajorVersion, rgVerInfo.dwMinorVersion, rgVerInfo.dwBuildNumber );

                Print(szMessage );
            }
            FreeLibrary( hDll );
        }
    }

    if ( dwOpts & (OFLAG(n) | OFLAG(v)) )
    {
        // now test the normal version details...
        dwBlockLen = GetFileVersionInfoSizeA( pszArgs, &dwHandle );
        if ( dwBlockLen == 0 )
        {
            Print("GetFileVersionSize failed\n");
        }
        else
        {
            pBlock = LocalAlloc( LPTR, dwBlockLen );
            if ( pBlock )
            {
                if (GetFileVersionInfoA( pszArgs, dwHandle, dwBlockLen, pBlock ))
                {
                    VS_FIXEDFILEINFO * pFileInfo;
                    UINT uLen;

                    VerQueryValueA( pBlock, "\\", (LPVOID *) &pFileInfo, &uLen );
                    Print("GetFileVersionInfo\n");

                    wsprintfA( szMessage, "Version: %d.%d.%d.%d (0x%08x`%08x)\n",
                        HIWORD(pFileInfo->dwFileVersionMS),
                        LOWORD(pFileInfo->dwFileVersionMS),
                        HIWORD(pFileInfo->dwFileVersionLS),
                        LOWORD(pFileInfo->dwFileVersionLS),
                        pFileInfo->dwFileVersionMS,
                        pFileInfo->dwFileVersionLS);
                    Print( szMessage );
                }

                if (dwOpts & OFLAG(v))
                {
                    DumpVerboseFileInfo(pBlock);
                }
                LocalFree( pBlock );
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

TARGETNAME=shlexts
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\version.lib          \
           $(SDK_LIB_PATH)\psapi.lib            \
           $(SDK_LIB_PATH)\dbgeng.lib           \
           $(SHELL_LIB_PATH)\shell32p.lib       \
           $(SHELL_LIB_PATH)\shlwapip.lib       \
           $(CCSHELL_DIR)\lib\$(O)\shguid.lib   \
           $(CCSHELL_DIR)\lib\$(O)\shguidp.lib

LINKLIBS=..\cpp\$(O)\shlcpp.lib

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES= ..;$(WINDOWS_INC_PATH)

USE_NTDLL=1

SOURCES= \
        ..\shlexts.c    \
        ..\shlexts.rc

NTTARGETFILE0= \
        $(O)\shlexts.def

DLLDEF=$(O)\shlexts.def

UMTYPE=console

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\classfactory.h ===
/*****************************************************************************\
    FILE: classfactory.h

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CThemePreview_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\shlkdx.h ===
/****************************** Module Header ******************************\
* Module Name: shlkdx.h
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* A preprocessed version of this file is passed to structo.exe to build
*  the struct field name-offset tables.
*
* History:
* 11-04-1997 Cdturner Created
\***************************************************************************/
#ifndef _SHLKDX_
#define _SHLKDX_

#include "precomp.h"
#pragma hdrstop

#include "conapi.h"
#include <ntsdexts.h>
#define NOEXTAPI
#include <wdbgexts.h>

#endif /* _SHLKDX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\stackwlk.cpp ===
//-----------------------------------------------------------------------------
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
#include <dbgeng.h>
};

#define DEFAULT_STACK_FRAMES    25
#define OINK_THRESHOLD          4.0 


//-----------------------------------------------------------------------------
void StackPig(ULONG ulFrames)
{
    IDebugClient*  pDebugClient;
    IDebugControl* pDebugControl;

    if (SUCCEEDED(DebugCreate(__uuidof(IDebugClient), (void**)&pDebugClient)))
    {
        if (SUCCEEDED(pDebugClient->QueryInterface(__uuidof(IDebugControl), (void**)&pDebugControl)))
        {
            DEBUG_STACK_FRAME  rgdsf[DEFAULT_STACK_FRAMES];
            DEBUG_STACK_FRAME* pdsf = NULL;

            if ((ulFrames > ARRAYSIZE(rgdsf)))
            {
                // Try allocating a buffer to accomodate the frames requested.
                // Failing that fallback to the default size stack variable.
                pdsf = (DEBUG_STACK_FRAME *)LocalAlloc(LPTR, sizeof(DEBUG_STACK_FRAME)*ulFrames);
            }

            if (pdsf == NULL)
            {
                pdsf = rgdsf;
                if ((ulFrames == 0) || (ulFrames > ARRAYSIZE(rgdsf)))
                {
                    ulFrames = ARRAYSIZE(rgdsf);
                }
            }

            if (SUCCEEDED(pDebugControl->GetStackTrace(0, 0, 0, pdsf, ulFrames, &ulFrames))) 
            {
                double dResult = 0.0;

                // print the header
                Print("StackSize ");
                pDebugControl->OutputStackTrace(
                                DEBUG_OUTCTL_ALL_CLIENTS, 
                                pdsf, 
                                0, 
                                DEBUG_STACK_COLUMN_NAMES|DEBUG_STACK_FRAME_ADDRESSES);

                for (UINT i = 0; !IsCtrlCHit() && (i < ulFrames); i++)
                {
                    (dResult < 0.1) ? 
                        Print("          ") : 
                        Print("%s%4.1fK ", ((dResult >= OINK_THRESHOLD) ? "OINK" : "    "), dResult);
                    pDebugControl->OutputStackTrace(
                                    DEBUG_OUTCTL_ALL_CLIENTS, 
                                    &pdsf[i], 
                                    1, 
                                    DEBUG_STACK_FRAME_ADDRESSES);

                    // process' initial ebp is zero, prevent negative result
                    if ((i+1 == ulFrames) || (pdsf[i+1].FrameOffset == 0)) 
                    {
                        dResult = 0.0;
                        continue;
                    }
                    
                    dResult = (pdsf[i+1].FrameOffset - pdsf[i].FrameOffset)/1024.0;
                }
            }

            if (pdsf != rgdsf)
            {
                LocalFree(pdsf);
            }

            pDebugControl->Release();
        }

        pDebugClient->Release();
    }
}


//-----------------------------------------------------------------------------
extern "C" BOOL Istackpig(DWORD dwOpts, LPVOID pArg)
{
    StackPig(PtrToUlong(pArg)); 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\ntsd\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\shlexts\usercmds.cpp ===
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
#include <winuserp.h>
#include <wowuserp.h>
#include <psapi.h>
};

typedef struct _LARGE_UNICODE_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    void *Buffer;               // kernel-sized pointer
} LARGE_UNICODE_STRING, *PLARGE_UNICODE_STRING;

typedef struct tagWND : public WW
{
    tagWND* spwndNext;
    tagWND* spwndPrev;
    tagWND* spwndParent;
    tagWND* spwndChild;
    tagWND* spwndOwner;

    RECT    rcWindow;
    RECT    rcClient;
    WNDPROC lpfnWndProc;
    void*   pcls;
    HRGN    hrgnUpdate;         // kernel-sized pointer
    void*   ppropList;
    void*   pSBInfo;
    HMENU   spmenuSys;
    HMENU   spmenu;
    HRGN    hrgnClip;
    LARGE_UNICODE_STRING strName;
    int     cbWndExtra;
    void*   spwndLastActive;
    void*   hImc;               // kernel-sized pointer
    void*   dwUserData;         // kernel-sized pointer
    void*   pActCtx;
} WND, *PWND;

BOOL CALLBACK PropEnumProc(HWND hwnd, LPCSTR lpszString, HANDLE hData)
{
    if (IS_INTRESOURCE(lpszString))
    {
        Print("Prop 0x%04x = 0x%08x\n", lpszString, hData);
    }
    else
    {
        Print("Prop \"%s\" = 0x%08x\n", lpszString, hData);
    }
    return TRUE;
}

void DumpWindowBytes(HWND hwnd)
{
    PWND pwnd = (PWND)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if (pwnd)
    {
        Print("cbWndExtra=%d\n", pwnd->cbWndExtra);
        // USER tries to hide GetWindowLong from out-of-process apps
        // so we have to grovel it manually.

        LONG_PTR *rglp = (LONG_PTR*)(pwnd+1);

        for (int i = 0; i < pwnd->cbWndExtra; i += sizeof(LONG_PTR))
        {
            LONG_PTR lp = *(LONG_PTR*)((LPBYTE)(pwnd+1) + i);
            Print("%8d = 0x%p\n", i, lp);
        }
    }
    Print("UserData = 0x%p\n", pwnd->dwUserData);
}

void DumpMiscWindowInfo(HWND hwnd, char *szBuf)
{
    Print("\n"
          "GetClipboardOwner()      = 0x%p\n", GetClipboardOwner());
    Print("GetClipboardViewer()     = 0x%p\n", GetClipboardViewer());
    Print("GetOpenClipboardWindow() = 0x%p\n", GetOpenClipboardWindow());
    Print("GetActiveWindow()        = 0x%p\n", GetActiveWindow());
    Print("GetFocus()               = 0x%p\n", GetFocus());
    Print("GetCapture()             = 0x%p\n", GetCapture());
    Print("GetForegroundWindow()    = 0x%p\n", GetForegroundWindow());
    Print("GetWindowContextHelpId() = 0x%p\n", GetWindowContextHelpId(hwnd));
    Print("GetDesktopWindow()       = 0x%p\n", GetDesktopWindow());
    Print("GetLastActivePopup()     = 0x%p\n", GetLastActivePopup(hwnd));

    if (GetWindowModuleFileNameA(hwnd, szBuf, MAX_PATH))
    {
        Print("GetWindowModuleFileName()= %s\n", szBuf);
    }

    DWORD pid;
    if (GetWindowThreadProcessId(hwnd, &pid))
    {
        HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
        if (h)
        {
            if (GetModuleFileNameExA(h, NULL, szBuf, MAX_PATH))
            {
                Print("Process                  = %s\n", szBuf);
            }
            CloseHandle(h);
        }
    }

}

extern "C" BOOL Ihwnd(DWORD dwOpts,
                       LPVOID pArg )
{
    HWND hwnd = (HWND)pArg;
    char szBuf[MAX_PATH];
    RECT rc;

    if (hwnd == 0)
        hwnd = GetDesktopWindow();

    Print("Window 0x%08x ", hwnd);

    if (!IsWindow(hwnd))
    {
        Print("*** NOT A WINDOW HANDLE\n");
        return TRUE;
    }

    if (dwOpts & OFLAG(m))
    {
        DumpMiscWindowInfo(hwnd, szBuf);
        return TRUE;
    }

    GetWindowTextA(hwnd, szBuf, ARRAYSIZE(szBuf));
    Print("\"%s\" ", szBuf);

    GetClassNameA(hwnd, szBuf, ARRAYSIZE(szBuf));
    Print("(%s)", szBuf);

    if (IsWindowUnicode(hwnd)) {
        Print(" UNICODE\n");
    } else {
        Print(" ANSI\n");
    }

    if ( dwOpts & OFLAG(p) )
    {
        EnumPropsA(hwnd, PropEnumProc);
        Print("End of property list\n");
        return TRUE;
    }

    if ( dwOpts & OFLAG(b) )
    {
        DumpWindowBytes(hwnd);
        return TRUE;
    }

    Print("  N=0x%08x C=0x%08x P=0x%08x O=0x%08x\n",
          GetWindow(hwnd, GW_HWNDNEXT),
          GetWindow(hwnd, GW_CHILD),
          GetAncestor(hwnd, GA_PARENT),
          GetWindow(hwnd, GW_OWNER));

    GetWindowRect(hwnd, &rc);
    Print("  W=(%d,%d)-(%d,%d) %dx%d ",
          rc.left, rc.top,
          rc.right, rc.bottom,
          rc.right - rc.left,
          rc.bottom - rc.top);

    GetClientRect(hwnd, &rc);
    Print("  C=(%d,%d)-(%d,%d) %dx%d\n",
          rc.left, rc.top,
          rc.right, rc.bottom,
          rc.right - rc.left,
          rc.bottom - rc.top);

    DWORD dwPid = 0;
    DWORD dwTid = GetWindowThreadProcessId(hwnd, &dwPid);

    Print("  pid.tid=0x%x.0x%x hinst=0x%p ", dwPid, dwTid,
          GetWindowLongPtr(hwnd, GWLP_HINSTANCE));

    // Now the evil part: Getting the wndproc...
    PWND pwnd = (PWND)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if (pwnd)
    {
        Print("wp=0x%p", pwnd->lpfnWndProc);
    }
    Print("\n");

    Print("  style-0x%08x exstyle=0x%08x\n",
          GetWindowLong(hwnd, GWL_STYLE),
          GetWindowLong(hwnd, GWL_EXSTYLE));

    return TRUE;
}

/***********************************************************************/

extern "C" BOOL Ihmenu(DWORD dwOpts,
                       LPVOID pArg )
{
    HMENU hmenu = (HMENU)pArg;
    char szBuf[MAX_PATH];
    RECT rc;

    Print("Menu 0x%08x ", hmenu);

    if (!IsMenu(hmenu))
    {
        Print("*** NOT A MENU HANDLE\n");
        return TRUE;
    }

    UINT cItems = GetMenuItemCount(hmenu);
    Print("%d items\n", cItems);

    UINT uiPosDefault = GetMenuDefaultItem(hmenu, TRUE, GMDI_USEDISABLED);

    for (UINT ui = 0; !IsCtrlCHit() && ui < cItems; ui++)
    {
        MENUITEMINFOA mii = { 0 };
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA | MIIM_FTYPE | MIIM_ID | MIIM_STATE |
                    MIIM_STRING | MIIM_SUBMENU;
        mii.dwTypeData = szBuf;
        mii.cch = ARRAYSIZE(szBuf);
        if (GetMenuItemInfoA(hmenu, ui, TRUE, &mii))
        {
            Print("%2d: id=0x%04x ref=0x%p ", ui, mii.wID, mii.dwItemData);
            if (mii.fType & MFT_BITMAP)
            {
                Print("bitmap 0x%p ", mii.dwTypeData);
            }
            else if (mii.fType & MFT_OWNERDRAW)
            {
                Print("ownerdraw 0x%p ", mii.dwTypeData);
            }
            else if (mii.fType & MFT_SEPARATOR)
            {
                Print("separator ");
            }
            else
            {
                Print("string \"%s\" ", mii.dwTypeData);
            }

            if (mii.fType & MFT_MENUBARBREAK)
                Print("MFT_MENUBARBREAK ");

            if (mii.fType & MFT_MENUBREAK)
                Print("MFT_MENUBREAK ");

            if (mii.fType & MFT_RADIOCHECK)
                Print("MFT_RADIOCHECK ");

            if (mii.fType & MFT_RIGHTJUSTIFY)
                Print("MFT_RIGHTJUSTIFY ");

            if (mii.fType & MFT_RIGHTORDER)
                Print("MFT_RIGHTORDER ");

            if (mii.fState & MFS_CHECKED)
                Print("MFS_CHECKED ");

            if (mii.fState & MFS_DEFAULT)
                Print("MFS_DEFAULT ");

            if (mii.fState & MFS_DISABLED)
                Print("MFS_DISABLED ");

            if (mii.fState & MFS_GRAYED)
                Print("MFS_GRAYED ");

            if (mii.fState & MFS_HILITE)
                Print("MFS_HILITE ");

            if (mii.hSubMenu)
                Print("-> 0x%p ", mii.hSubMenu);

            Print("\n");
        }
    }


    return TRUE;
}

/***********************************************************************/

#include <pshpack1.h>

#define CC_BUTTON           0x80        /* Class codes */
#define CC_EDIT             0x81
#define CC_STATIC           0x82
#define CC_LISTBOX          0x83
#define CC_SCROLLBAR        0x84
#define CC_COMBOBOX         0x85

#define DS_DIALOGEX         0xFFFF0001

typedef struct DIALOGDIMEN {
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
} DIALOGDIMEN, *PDIALOGDIMEN;

typedef struct DLGFINISH {          /* Common dialog finish-up */
    WORD    cDlgItems;
    DIALOGDIMEN dd;
} DLGFINISH, *PDLGFINISH;

typedef struct DLG {
    DWORD   dwStyle;            // or DS_DIALOGEX if DIALOGEX
    DWORD   dwExStyle;
    DLGFINISH dlgfinish;
    WORD    wszMenuName[1];
    /*
     * wszMenuName[] -- wsz or 0x00FF followed by WORD ordinal
     * wszClassName[] -- wsz or 0x00FF followed by WORD ordinal (?)
     * wszTitle[] -- wsz
     * if dwStyle & DS_SETFONT
     *      WORD wPoint;                // point size
     *      wszFontName[] -- wsz
     * endif
     * followed by a packed array of DITs, each DWORD aligned
     */
} DLG, *PDLG;

typedef struct DLGEX {
    WORD    wDlgVer;                    /* Version number; always 0001 */
    WORD    wSignature;                 /* Always 0xFFFF */
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    DLGFINISH dlgfinish;
    /*
     * wszMenuName[] -- wsz or 0x00FF followed by WORD ordinal
     * wszClassName[] -- wsz or 0x00FF followed by WORD ordinal (?)
     * wszTitle[] -- wsz
     * if dwStyle & DS_SETFONT
     *      WORD wPoint;                // point size
     *      WORD wWeight;
     *      BYTE bItalic;
     *      BYTE bCharSet;
     *      wszFontName[] -- wsz
     * endif
     * followed by a packed array of DITEX'es, each DWORD aligned
     */
} DLGEX, *PDLGEX;

typedef struct DIT {                /* dialog item template */
    DWORD   dwStyle;
    DWORD   dwExStyle;
    DIALOGDIMEN dd;
    WORD    wID;
    /*
     * wszClassName[] -- wsz or 0xFFFF followed by WORD ordinal
     * wszTitle[] -- wsz
     * cbExtra -- word value
     */
} DIT, *PDIT;

typedef struct DITEX {
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    DIALOGDIMEN dd;
    DWORD   dwID;
    /*
     * wszClassName[] -- wsz or 0xFFFF followed by WORD ordinal
     * wszTitle[] -- wsz
     * cbExtra -- word value
     */
} DITEX, *PDITEX;

#include <poppack.h>

BOOL _MoveBlock(LPVOID pvDst, LPVOID pvSrc, DWORD cb)
{
    BOOL fSuccess = tryMoveBlock(pvDst, pvSrc, cb);
    if (fSuccess) return fSuccess;
    Print("Error reading %d bytes from %p\n", cb, pvSrc);
    return FALSE;
}

LPCSTR DlgGetClassName(WORD wClass)
{
    switch (wClass) {       /* Handle internal class types */
    case CC_BUTTON:     return "button";
    case CC_EDIT:       return "edit";
    case CC_STATIC:     return "static";
    case CC_LISTBOX:    return "listbox";
    case CC_SCROLLBAR:  return "scrollbar";
    case CC_COMBOBOX:   return "combobox";
    default:            return "<unknown>";
    }
}

typedef LPCSTR (*ORDINALRESOLVER)(WORD w);

LPBYTE DlgDumpString(LPCSTR pszField, LPBYTE pArg, ORDINALRESOLVER Resolve)
{
    WCHAR wch;

    Print("%s: ", pszField);

    if (!_MoveBlock(&wch, pArg, sizeof(wch))) return NULL;

    pArg += sizeof(wch);

    if (wch == 0xFF || wch == 0xFFFF)
    {
        if (!_MoveBlock(&wch, pArg, sizeof(wch))) return NULL;
        pArg += sizeof(wch);

        LPCSTR pszOrdinal;
        if (Resolve && (pszOrdinal = Resolve(wch)))
        {
            Print("%s\n", pszOrdinal);
        }
        else
        {
            Print("#0x%04x\n", wch);
        }
        return pArg;
    }

    Print("\"");
    while (wch) {
        Print("%c", wch); // truncate to ANSI, sorry
        if (IsCtrlCHit()) return NULL;

        if (!_MoveBlock(&wch, pArg, sizeof(wch))) return NULL;
        pArg += sizeof(wch);
    }
    Print("\"\n");
    return pArg;
}

LPBYTE DlgDwordAlign(LPBYTE pBase, LPBYTE pArg)
{
    SIZE_T diff = pArg - pBase;
    if (diff % 4) pArg += 4 - (diff % 4);
    return pArg;
}

void DumpDialogEx(LPBYTE pArg)
{
    DLGEX dlg;

    LPBYTE pBase = pArg;
    WORD w;

    if (!_MoveBlock(&dlg, pArg, sizeof(dlg))) return;

    Print("  wDlgVer = 0x%04x\n", dlg.wDlgVer);
    Print("  dwStyle = 0x%08x\n", dlg.dwStyle);
    Print("dwExStyle = 0x%08x\n", dlg.dwExStyle);
    Print(" dwHelpID = 0x%08x\n", dlg.dwHelpID);
    Print("  ( x, y) = (%3d, %3d)\n", dlg.dlgfinish.dd.x, dlg.dlgfinish.dd.y);
    Print("  (cx,cy) = (%3d, %3d)\n", dlg.dlgfinish.dd.cx, dlg.dlgfinish.dd.cy);

    pArg += FIELD_OFFSET(DLG, wszMenuName);

    pArg = DlgDumpString("Menu", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Class", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Title", pArg, NULL);
    if (!pArg) return;

    if (dlg.dwStyle & DS_SETFONT)
    {
        struct {
            WORD wPoint;
            WORD wWeight;
            BYTE bItalic;
            BYTE bCharSet;
        } ft;

        if (!_MoveBlock(&ft, pArg, sizeof(ft))) return;
        pArg += sizeof(ft);

        pArg = DlgDumpString("Font", pArg, NULL);
        if (!pArg) return;

        Print("  %dpt, weight=%d, italic=%d, charset=%d\n",
              ft.wPoint, ft.wWeight, ft.bItalic, ft.bCharSet);
    }

    // and then a packed array of DITEXs, DWORD-aligned

    Print("Number of controls: %d\n\n", dlg.dlgfinish.cDlgItems);

    for (int i = 0; !IsCtrlCHit() && i < dlg.dlgfinish.cDlgItems; i++)
    {
        pArg = DlgDwordAlign(pBase, pArg);

        DITEX dit;

        if (!_MoveBlock(&dit, pArg, sizeof(dit))) return;
        pArg += sizeof(dit);

        Print("Control %d (0x%04x):\n", dit.dwID, dit.dwID);
        Print("      dwStyle = 0x%08x\n", dit.dwStyle);
        Print("    dwExStyle = 0x%08x\n", dit.dwExStyle);
        Print("     dwHelpID = 0x%08x\n", dit.dwHelpID);
        Print("      ( x, y) = (%3d, %3d)\n", dit.dd.x, dit.dd.y);
        Print("      (cx,cy) = (%3d, %3d)\n", dit.dd.cx, dit.dd.cy);

        pArg = DlgDumpString("    Class", pArg, DlgGetClassName);
        if (!pArg) return;

        pArg = DlgDumpString("    Title", pArg, DlgGetClassName);
        if (!pArg) return;

        if (!_MoveBlock(&w, pArg, sizeof(w))) return;
        pArg += sizeof(w);
        pArg += w;
    }
}

void DumpDialog(LPBYTE pArg)
{
    DLG dlg;

    LPBYTE pBase = pArg;
    WORD w;

    if (!_MoveBlock(&dlg, pArg, sizeof(dlg))) return;

    Print("  dwStyle = 0x%08x\n", dlg.dwStyle);
    Print("dwExStyle = 0x%08x\n", dlg.dwExStyle);
    Print("  ( x, y) = (%3d, %3d)\n", dlg.dlgfinish.dd.x, dlg.dlgfinish.dd.y);
    Print("  (cx,cy) = (%3d, %3d)\n", dlg.dlgfinish.dd.cx, dlg.dlgfinish.dd.cy);

    pArg += FIELD_OFFSET(DLG, wszMenuName);

    pArg = DlgDumpString("Menu", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Class", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Title", pArg, NULL);
    if (!pArg) return;

    if (dlg.dwStyle & DS_SETFONT)
    {
        if (!_MoveBlock(&w, pArg, sizeof(w))) return;
        pArg += sizeof(WORD);

        pArg = DlgDumpString("Font", pArg, NULL);
        if (!pArg) return;

        Print("  Font size: %dpt\n", w);
    }

    // and then a packed array of DITs, DWORD-aligned

    Print("Number of controls: %d\n\n", dlg.dlgfinish.cDlgItems);

    for (int i = 0; !IsCtrlCHit() && i < dlg.dlgfinish.cDlgItems; i++)
    {
        pArg = DlgDwordAlign(pBase, pArg);

        DIT dit;

        if (!_MoveBlock(&dit, pArg, sizeof(dit))) return;
        pArg += sizeof(dit);

        Print("Control %d (0x%04x):\n", (short)dit.wID, dit.wID);
        Print("      dwStyle = 0x%08x\n", dit.dwStyle);
        Print("    dwExStyle = 0x%08x\n", dit.dwExStyle);
        Print("      ( x, y) = (%3d, %3d)\n", dit.dd.x, dit.dd.y);
        Print("      (cx,cy) = (%3d, %3d)\n", dit.dd.cx, dit.dd.cy);

        pArg = DlgDumpString("    Class", pArg, DlgGetClassName);
        if (!pArg) return;

        pArg = DlgDumpString("    Title", pArg, DlgGetClassName);
        if (!pArg) return;

        if (!_MoveBlock(&w, pArg, sizeof(w))) return;
        pArg += sizeof(w);
        pArg += w;
    }
}

extern "C" BOOL Idlgt(DWORD dwOpts,
                       LPVOID pArg )
{
    int cItems;
    PDLGFINISH pdlgfinish;

    DWORD dw;
    if (!_MoveBlock(&dw, pArg, sizeof(dw)))
    {
        return TRUE;
    }

    if (dw == DS_DIALOGEX)
    {
        DumpDialogEx((LPBYTE)pArg);
    }
    else
    {
        DumpDialog((LPBYTE)pArg);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\dllload.h ===
#ifndef _DLLLOAD_H_
#define _DLLLOAD_H_

#include <wininet.h>
#include <winineti.h>

#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* silence (!default) if sound not found */

BOOL WINAPI sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);

#endif // _DLLLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\debug.cpp ===
/*****************************************************************************\
    FILE: debug.cpp

    DESCRIPTION:
       Debug information.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "STARBUCK"
#define SZ_MODULE           "STARBUCK"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\classfactory.cpp ===
/*****************************************************************************\
    FILE: classfactory.cpp

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "classfactory.h"
#include "imagemenu.h"


/*****************************************************************************
 *
 *  CClassFactory
 *
 *
 *****************************************************************************/

class CClassFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CClassFactory(REFCLSID rclsid);
    ~CClassFactory(void);

    // Friend Functions
    friend HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *  IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CClassFactory::CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void **ppvObject)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppvObject)
    {
        if (!punkOuter)
        {
            if (IsEqualCLSID(m_rclsid, CLSID_CImageMenu))
            {
                hr = CImageMenu_CreateInstance(punkOuter, riid, ppvObject);
            }
            else
            {
                TCHAR szGuid[GUIDSTR_MAX];

                SHStringFromGUID(m_rclsid, szGuid, ARRAYSIZE(szGuid));
                AssertMsg(0, TEXT("CClassFactory::CreateInstance(%s) failed because we don't support that CLSID.  This is because someone made a registration bug."), szGuid);  // What are you looking for?
                hr = E_NOINTERFACE;
            }
        }
        else
        {   // Does anybody support aggregation any more?
            hr = ResultFromScode(CLASS_E_NOAGGREGATION);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  IClassFactory::LockServer
 *
 *  What a poor function.  Locking the server is identical to
 *  creating an object and not releasing it until you want to unlock
 *  the server.
 *
 *****************************************************************************/

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *  CClassFactory_Create
 *
 *****************************************************************************/

/****************************************************\
    Constructor
\****************************************************/
CClassFactory::CClassFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CClassFactory::~CClassFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CClassFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CClassFactory::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualCLSID(riid, IID_IUnknown) || IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_WMTHEME, "CClassFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CClassFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\dllload.cpp ===
/*****************************************************************************\
    FILE: dllload.cpp

    DESCRIPTION:
       This file will create stub functions that will just-in-time load a DLL
    and call an API.  This will delay loading functions that either take a long
    time to load or may not exist in certain install cases.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <wininet.h>
#include <guiddef.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 


/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (HIWORD(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wnsprintfA(szProcD, ARRAYSIZE(szProcD), "(ordinal %d)", LOWORD(pszProc));
    }
#endif // DEBUG
    // If it's already loaded, return.
    if (*ppfn) {
    return;
    }

    if (*phinst == NULL) {
#ifdef DEBUG
    TraceMsg(TF_WMTHEME, "DLLLOAD: Loading %s for the first time for %s", pszDLL, szProcD);
    
    if (g_dwBreakFlags & 0x00000080)
    {
        DebugBreak();
    }
#endif // DEBUG
    *phinst = LoadLibraryA(pszDLL);
    if (*phinst == NULL) {
        return;
    }
    }

#ifdef DEBUG
    TraceMsg(TF_WMTHEME, "DLLLOAD: GetProc'ing %s from %s for the first time", pszDLL, szProcD);
#endif // DEBUG
    *ppfn = GetProcAddress(*phinst, pszProc);
}

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    _GetProcFromDLL(phinst, pszDLL, ppfn, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_MAP_HRESULT(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, HRESULT, _fnpriv, _fn, _args, _nargs, E_FAIL)
#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)


#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, BOOL, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}


//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}



/**********************************************************************/
// --------- WINMM.DLL ---------------
HINSTANCE g_hinstWINMM = NULL;

DELAY_LOAD_BOOL(g_hinstWINMM, WINMM.DLL, sndPlaySoundW,
                 (LPCWSTR pszSound, UINT fuSound), 
                 (pszSound, fuSound));


/**********************************************************************/
#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\dllmain.cpp ===
/*****************************************************************************\
    FILE: dllmain.cpp

    DESCRIPTION:
       This file will take care of the DLL lifetime.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

extern HANDLE g_hLogFile;

/*****************************************************************************
 *
 *  Dynamic Globals.  There should be as few of these as possible.
 *
 *  All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;           // Global reference count
CRITICAL_SECTION g_csDll;   // The shared critical section


#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
#endif // DEBUG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_MsgListView, CMsgListView)
END_OBJECT_MAP()

/*****************************************************************************
 *
 *  DllAddRef / DllRelease
 *
 *  Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  DllGetClassObject
 *
 *  OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *  The artificial refcount inside DllGetClassObject helps to
 *  avoid the race condition described in DllCanUnloadNow.  It's
 *  not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
    if (0)//CLSID_MsgListView == rclsid)
    {
        hres = _Module.GetClassObject(rclsid, riid, ppvObj);
    }
    else
    {
        hres = CClassFactory_Create(rclsid, riid, ppvObj);
    }
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  OLE entry point.  Fail iff there are outstanding refs.
 *
 *  There is an unavoidable race condition between DllCanUnloadNow
 *  and the creation of a new IClassFactory:  Between the time we
 *  return from DllCanUnloadNow() and the caller inspects the value,
 *  another thread in the same process may decide to call
 *  DllGetClassObject, thus suddenly creating an object in this DLL
 *  when there previously was none.
 *
 *  It is the caller's responsibility to prepare for this possibility;
 *  there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    hres = g_cRef ? S_FALSE : S_OK;

    if (S_OK == hres)
    {
        hres = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    TraceMsg(TF_WMTHEME, "DllCanUnloadNow() returning hres=%#08lx. (S_OK means yes)", hres);

    LEAVECRITICAL;

    return hres;
}

/*
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
const LPCTSTR c_rgszClasses[] = {
//    g_cszPopServiceWndClass
};

//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))
*/

/*****************************************************************************
 *
 *  Entry32
 *
 *  DLL entry point.
 *
 *  BUGBUG -- On a thread detach, must check if the thread owns any
 *  global timeouts.  If so, we must transfer the timeout to another
 *  thread or something.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static s_hresOle = E_FAIL;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef DEBUG
            CcshellGetDebugFlags();
#endif

            InitializeCriticalSection(&g_csDll);

            g_hinst = hinst;
            DisableThreadLibraryCalls(hinst);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            DeleteCriticalSection(&g_csDll);
            if (INVALID_HANDLE_VALUE != g_hLogFile)
            {
                CloseHandle(g_hLogFile);
            }

            break;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\guids.cpp ===
/*****************************************************************************\
    FILE: guids.cpp

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#define INITGUID
#include "guids.h"

#include "priv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\makefile.inc ===
resource.rc : $(PROJECT_ROOT)\lib\$(O)\Theme.tlb $(SELFREGNAME)

$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\guids.h ===
/*****************************************************************************\
    FILE: guids.h

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 8/13/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif



#undef MIDL_DEFINE_GUID


// {8D029AEC-E412-4948-84B5-699A740946AE}
static const GUID CLSID_CImageMenu = { 0x8d029aec, 0xe412, 0x4948, { 0x84, 0xb5, 0x69, 0x9a, 0x74, 0x9, 0x46, 0xae } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\dllreg.cpp ===
/*****************************************************************************\
    FILE: dllreg.cpp

    DESCRIPTION:
        Register selfreg.inf, which exists in our resource.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#include <advpub.h>
#include <comcat.h>
#include <theme.h>       // For LIBID_Theme

extern CComModule _Module;

// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)



BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS) {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return fResult;
}



HRESULT MyRegTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];
#ifdef UNICODE
    WCHAR   *pwsz = szTmp; 
#else
    WCHAR   pwsz[MAX_PATH];
#endif

    // Load and register our type library.
    //
    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));
#ifndef UNICODE
    if (SHAnsiToUnicode(szTmp, pwsz, MAX_PATH)) 
#endif
    {
        hr = LoadTypeLib(pwsz, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library as we had some old junk that
            // was registered by a previous version of OleAut32, which is now causing
            // the current version to not work on NT...
            UnregisterTypeLibrary(&LIBID_Theme);
            hr = RegisterTypeLib(pTypeLib, pwsz, NULL);

            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "LoadTypeLib failed (%x)", hr);
        }
    } 
#ifndef UNICODE
    else {
        hr = E_FAIL;
    }
#endif

    return hr;
}



/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "NO_LONGER_USED", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            szIEPath[0] = 0;
            hr = pfnri(HINST_THISDLL, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall("DLL_RegInstall");

    //---- do this even if error occured ----
    MyRegTypeLib();
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // UnInstall the registry values
    hr = CallRegInstall("DLL_RegUnInstall");
    UnregisterTypeLibrary(&LIBID_Theme);

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\imagemenu.h ===
/*****************************************************************************\
    FILE: ImageMenu.h

    DESCRIPTION:
        This code will display a submenu on the context menus for imagines.
    This will allow the conversion and manipulation of images.

    BryanSt 8/9/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _IMAGEMENU_H
#define _IMAGEMENU_H

#include <shpriv.h>



HRESULT CImageMenu_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void **ppvObject);


class CImageMenu                : public IShellExtInit
                                , public IContextMenu
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellExtInit ***
    virtual STDMETHODIMP Initialize(IN LPCITEMIDLIST pidlFolder, IN IDataObject *pdtobj, IN HKEY hkeyProgID);

    // *** IContextMenu ***
    virtual STDMETHODIMP QueryContextMenu(IN HMENU hmenu, IN UINT indexMenu, IN UINT idCmdFirst, IN UINT idCmdLast, IN UINT uFlags);
    virtual STDMETHODIMP InvokeCommand(IN LPCMINVOKECOMMANDINFO pici);
    virtual STDMETHODIMP GetCommandString(IN UINT_PTR idCmd, IN UINT uType, IN UINT * pwReserved, IN LPSTR pszName, IN UINT cchMax);


private:
    CImageMenu(void);
    virtual ~CImageMenu(void);

    // Private Member Variables
    int                     m_cRef;

    LPTSTR                  m_pszFileList;
    UINT                    m_nFileCount;

    // Private Member Functions
    HRESULT _ConvertImage(IN HWND hwnd, IN UINT idc);

    friend HRESULT CImageMenu_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void **ppvObject);
};




#endif // _IMAGEMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\imagemenu.cpp ===
/*****************************************************************************\
    FILE: ImageMenu.cpp

    DESCRIPTION:
        This code will display a submenu on the context menus for imagines.
    This will allow the conversion and manipulation of images.

    BryanSt 8/9/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "imagemenu.h"




//===========================
// *** Structures ***
//===========================

struct VERBINFO
{
    UINT  idc;
    DWORD sfgao;
    LPCTSTR ptszCmd;
    LPCTSTR pszExt;
}
c_rgvi[] =
{
    {    IDC_IMAGEMENU_CONVERT_GIF,        0,         TEXT("ImageMenu_Convert_ToGIF"),   TEXT(".gif")},
    {    IDC_IMAGEMENU_CONVERT_JPEG,       0,         TEXT("ImageMenu_Convert_ToJPEG"),   TEXT(".jpeg")},
    {    IDC_IMAGEMENU_CONVERT_PNG,        0,         TEXT("ImageMenu_Convert_ToPNG"),   TEXT(".png")},
    {    IDC_IMAGEMENU_CONVERT_TIFF,       0,         TEXT("ImageMenu_Convert_ToTIFF"),   TEXT(".tiff")},
    {    IDC_IMAGEMENU_CONVERT_BMP,        0,         TEXT("ImageMenu_Convert_ToBMP"),   TEXT(".bmp")},
};



//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CImageMenu::_ConvertImage(IN HWND hwnd, IN UINT idc)
{
    LPTSTR pszCurrFile = m_pszFileList;
    UINT nFileCount = m_nFileCount;
    HRESULT hr = S_OK;
    LPTSTR pszErrorMessage = NULL;

    if (pszCurrFile)
    {
        while (SUCCEEDED(hr) && nFileCount--)
        {
            TCHAR szSource[MAX_PATH];
            TCHAR szDest[MAX_PATH];

            StrCpyN(szSource, pszCurrFile, ARRAYSIZE(szSource));
            StrCpyN(szDest, pszCurrFile, ARRAYSIZE(szDest));

            LPTSTR pszExtension = PathFindExtension(szDest);
            if (pszExtension)
            {
                LPCTSTR pszNewExt = NULL;

                // Replace the extension with the target type.
                switch (idc)
                {
                case IDC_IMAGEMENU_CONVERT_GIF:
                    pszNewExt = TEXT(".gif");
                    break;
                case IDC_IMAGEMENU_CONVERT_JPEG:
                    pszNewExt = TEXT(".jpeg");
                    break;
                case IDC_IMAGEMENU_CONVERT_PNG:
                    pszNewExt = TEXT(".png");
                    break;
                case IDC_IMAGEMENU_CONVERT_BMP:
                    pszNewExt = TEXT(".bmp");
                    break;
                case IDC_IMAGEMENU_CONVERT_TIFF:
                    pszNewExt = TEXT(".tiff");
                    break;
                }

                if (pszNewExt)
                {
                    StrCpy(pszExtension, pszNewExt);

                    hr = SHConvertGraphicsFile(szSource, szDest, SHCGF_REPLACEFILE);
                }
                else
                {
                    pszErrorMessage = TEXT("We don't support converting these types of files.");
                    hr = E_FAIL;
                }
            }
            else
            {
                pszErrorMessage = TEXT("Couldn't find the file extension.");
                hr = E_FAIL;
            }

            pszCurrFile += (lstrlen(pszCurrFile) + 1);
            if (!pszCurrFile[0])
            {
                // We are done.
                break;
            }
        }
    }
    else
    {
        pszErrorMessage = TEXT("Someone didn't set our pidl.");
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        ErrorMessageBox(hwnd, TEXT("Error"), IDS_ERROR_CONVERTIMAGEFAILED, hr, pszErrorMessage, 0);
    }

    return hr;
}

// Returns the submenu of the given menu and ID.  Returns NULL if there
// is no submenu
int _MergePopupMenus(HMENU hmDest, HMENU hmSource, int idCmdFirst, int idCmdLast)
{
    int i, idFinal = idCmdFirst;

    for (i = GetMenuItemCount(hmSource) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     // just in case

        if (EVAL(GetMenuItemInfo(hmSource, i, TRUE, &mii)))
        {
            HMENU hmDestSub = SHGetMenuFromID(hmDest, mii.wID);
            if (hmDestSub)
            {
                int idTemp = Shell_MergeMenus(hmDestSub, mii.hSubMenu, (UINT)0, idCmdFirst, idCmdLast, MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                if (idFinal < idTemp)
                    idFinal = idTemp;
            }
        }
    }

    return idFinal;
}


/*****************************************************************************\
    FUNCTION: AddToPopupMenu

    DESCRIPTION:
      Swiped from utils.c in RNAUI, in turn swiped from the    ;Internal
      shell.                            ;Internal
                                  ;Internal
      Takes a destination menu and a (menu id, submenu index) pair,
      and inserts the items from the (menu id, submenu index) at location
      imi in the destination menu, with a separator, returning the number
      of items added.  (imi = index to menu item)
  
      Returns the first the number of items added.
  
      hmenuDst        - destination menu
      idMenuToAdd        - menu resource identifier
      idSubMenuIndex    - submenu from menu resource to act as template
      indexMenu        - location at which menu items should be inserted
      idCmdFirst        - first available menu identifier
      idCmdLast       - first unavailable menu identifier
      uFlags            - flags for Shell_MergeMenus
\*****************************************************************************/
#define FLAGS_MENUMERGE                 (MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS)

UINT AddToPopupMenu(HMENU hmenuDst, UINT idMenuToAdd, UINT idSubMenuIndex, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT nLastItem = 0;

    HMENU hmenuSrc = LoadMenu(g_hinst, MAKEINTRESOURCE(idMenuToAdd));
    if (hmenuSrc)
    {
        nLastItem = Shell_MergeMenus(hmenuDst, GetSubMenu(hmenuSrc, idSubMenuIndex), indexMenu, idCmdFirst, idCmdLast, (uFlags | FLAGS_MENUMERGE));
        DestroyMenu(hmenuSrc);
    }

    return nLastItem;
}


UINT MergeInToPopupMenu(HMENU hmenuDst, UINT idMenuToMerge, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT nLastItem = 0;

    HMENU hmenuSrc = LoadMenu(g_hinst, MAKEINTRESOURCE(idMenuToMerge));
    if (hmenuSrc)
    {
        nLastItem = _MergePopupMenus(hmenuDst, hmenuSrc, idCmdFirst, idCmdLast);
        DestroyMenu(hmenuSrc);
    }

    return nLastItem;
}




//===========================
// *** IShellExtInit Interface ***
//===========================
HRESULT CImageMenu::Initialize(IN LPCITEMIDLIST pidlFolder, IN IDataObject *pdtobj, IN HKEY hkeyProgID)
{
    HRESULT hr = S_OK;

    if (pdtobj)
    {
        hr = DataObj_QueryFileList(pdtobj, &m_pszFileList, &m_nFileCount);
    }
    else
    {
        MessageBox(NULL, TEXT("IShellExtInit::Initialize() was called but no IDataObject was provided."), TEXT("Error"), MB_OK);
    }

    return hr;
}


//===========================
// *** IContextMenu Interface ***
//===========================
HRESULT CImageMenu::QueryContextMenu(IN HMENU hmenu, IN UINT indexMenu, IN UINT idCmdFirst, IN UINT idCmdLast, IN UINT uFlags)
{
    HRESULT hr = S_OK;
    BOOL fAddMenu = TRUE;

    if (m_pszFileList)
    {
        LPTSTR pszCurrFile = m_pszFileList;

        for (UINT nIndex = 0; SUCCEEDED(hr) && fAddMenu && (nIndex < m_nFileCount); nIndex++)
        {
            LPTSTR pszExtension = PathFindExtension(pszCurrFile);
            if (pszExtension)
            {
                for (int nExtIndex = 0; SUCCEEDED(hr) && (nExtIndex < ARRAYSIZE(c_rgvi)); nExtIndex++)
                {
                    if (StrCmpI(c_rgvi[nExtIndex].pszExt, pszExtension))
                    {
                        nExtIndex = ARRAYSIZE(c_rgvi);
                    }
                    else if (nExtIndex = ARRAYSIZE(c_rgvi) - 1)
                    {
                        fAddMenu = FALSE;
                        break;
                    }
                }
            }
            else
            {
                fAddMenu = FALSE;
                break;
            }

            pszCurrFile += (lstrlen(pszCurrFile) + 1);
            if (!pszCurrFile[0])
            {
                // We are done.
                break;
            }
        }
    }
    else
    {
        hr = E_FAIL;
        ErrorMessageBox(NULL, TEXT("Error"), IDS_ERROR_CONVERTIMAGEFAILED, hr, TEXT("Someone didn't set our pidl."), 0);
    }

    if (fAddMenu)
    {
        AddToPopupMenu(hmenu, IDM_IMAGEMENU, 0, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        if (SUCCEEDED(hr))
            hr = ResultFromShort(ARRAYSIZE(c_rgvi)+1);
    }

    return hr;
}


HRESULT CImageMenu::InvokeCommand(IN LPCMINVOKECOMMANDINFO pici)
{
    UINT idc;
    HRESULT hr = E_FAIL;

    if (pici->cbSize < sizeof(*pici))
        return E_INVALIDARG;

    if (HIWORD(pici->lpVerb))
    {
        int ivi;
        idc = (UINT)-1;
        for (ivi = 0; ivi < ARRAYSIZE(c_rgvi); ivi++)
        {
            TCHAR szVerb[MAX_PATH];

            SHAnsiToTChar(pici->lpVerb, szVerb, ARRAYSIZE(szVerb));
            if (!StrCmpI(c_rgvi[ivi].ptszCmd, szVerb))
            {
                // Yes, the command is equal to the verb str, so this is the one.
                idc = c_rgvi[ivi].idc;
                break;
            }
        }
    }
    else
        idc = LOWORD(pici->lpVerb);

    switch (idc)
    {
    case IDC_IMAGEMENU_CONVERT_GIF:
    case IDC_IMAGEMENU_CONVERT_JPEG:
    case IDC_IMAGEMENU_CONVERT_PNG:
    case IDC_IMAGEMENU_CONVERT_TIFF:
    case IDC_IMAGEMENU_CONVERT_BMP:
        hr = _ConvertImage(pici->hwnd, idc);
        break;

    default:
        ErrorMessageBox(pici->hwnd, TEXT("Error"), IDS_ERROR_MESSAGENUMBER, hr, NULL, 0);
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}


HRESULT CImageMenu::GetCommandString(IN UINT_PTR idCmd, IN UINT uType, IN UINT * pwReserved, IN LPSTR pszName, IN UINT cchMax)
{
    HRESULT hr = E_FAIL;
    BOOL fUnicode = FALSE;

    if (idCmd < ARRAYSIZE(c_rgvi))
    {
        switch (uType)
        {
/*
        case GCS_HELPTEXTW:
            fUnicode = TRUE;
            // Fall thru...
        case GCS_HELPTEXTA:
            GetHelpText:
            if (EVAL(cchMax))
            {
                BOOL fResult;
                pszName[0] = '\0';
                 
                if (fUnicode)
                    fResult = LoadStringW(HINST_THISDLL, IDS_ITEM_HELP((UINT)idCmd), (LPWSTR)pszName, cchMax);
                else
                    fResult = LoadStringA(HINST_THISDLL, IDS_ITEM_HELP((UINT)idCmd), pszName, cchMax);
                if (EVAL(fResult))
                    hr = S_OK;
                else
                    hr = E_INVALIDARG;
            }
            else
                hr = E_INVALIDARG;
        break;
*/
        case GCS_VALIDATEW:
        case GCS_VALIDATEA:
            hr = S_OK;
            break;

        case GCS_VERBW:
            fUnicode = TRUE;
            // Fall thru...
        case GCS_VERBA:
        {
            int ivi;
            for (ivi = 0; ivi < ARRAYSIZE(c_rgvi); ivi++)
            {
                if (c_rgvi[ivi].idc == idCmd)
                {
                    if (fUnicode)
                        SHTCharToUnicode(c_rgvi[ivi].ptszCmd, (LPWSTR)pszName, cchMax);
                    else
                        SHTCharToAnsi(c_rgvi[ivi].ptszCmd, pszName, cchMax);

                    hr = S_OK;
                    break;
                }
            }
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
        }
    }

    return hr;
}


//===========================
// *** IUnknown Interface ***
//===========================
ULONG CImageMenu::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CImageMenu::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CImageMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] =
    {
        QITABENT(CImageMenu, IShellExtInit),
        QITABENT(CImageMenu, IContextMenu),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}




//===========================
// *** Class Methods ***
//===========================
CImageMenu::CImageMenu() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_pszFileList = FALSE;
    m_nFileCount = 0;
}


CImageMenu::~CImageMenu()
{
    if (m_pszFileList)
    {
        DataObj_FreeList(m_pszFileList);
    }
}


HRESULT CImageMenu_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void **ppvObject)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObject)
    {
        CImageMenu * pThis = new CImageMenu();

        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObject);
            pThis->Release();
        }
        else
        {
            *ppvObject = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\priv.h ===
/*****************************************************************************\
    FILE: priv.h

    DESCRIPTION:
        This is the precompiled header for themeui.dll.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************\

      Global Includes
\*****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif // WINVER


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_DLL
#undef _ATL_DLL_IMPL
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache


#define POST_IE5_BETA
#include <w95wraps.h>

#include <windows.h>

#include <windowsx.h>

#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shellids.h>       // Help IDs
#include <shlwapi.h>
#include <shlwapip.h>

// HACKHACK: For the life of me, I can't get shlwapip.h to include the diffinitions of these.
//    I'm giving up and putting them inline.  __IOleAutomationTypes_INTERFACE_DEFINED__ and
//    __IOleCommandTarget_INTERFACE_DEFINED__ need to be defined, which requires oaidl.h,
//    which requires hlink.h which requires rpcndr.h to come in the right order.  Once I got that
//    far I found it still didn't work and a lot of more stuff is needed.  The problem
//    is that shlwapi (exdisp/dspsprt/expdsprt/cnctnpt) or ATL will provide impls for
//    IConnectionPoint & IConnectionPointContainer, but one will conflict with the other.
LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS * pdispparams);
LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);
LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP, DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);

#include <shellapi.h>

#include <shsemip.h>
#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <shdocvw.h>
#include <commdlg.h>
#include <shguidp.h>
#include <isguids.h>
#include <shdguid.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <msident.h>
#include <msxml.h>
#include <Theme.h>                  // For ITheme interfaces
#include <dispex.h>                 // IDispatchEx
#include <perhist.h>
#include <regapix.h>
#include <shsemip.h>


#include <help.h>
#include <krnlcmn.h>                // GetProcessDword

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
//#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>        // BUGBUG (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <ccstock.h>
#include <port32.h>

#include <commctrl.h>
#include <shpriv.h>
#include <Prsht.h>


// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

#include <dspsprt.h>
#include <cowsite.h>
#include <cobjsafe.h>
#include <objclsid.h>
#include <objwindow.h>
#include <autosecurity.h>

#include <guids.h>
#include <tmschema.h>
#include <uxtheme.h>
#include <uxthemep.h>

// Trace flags
#define TF_WMTHEME          0x00000100      // Themes


/*****************************************************************************\

 *
 *      Global Helper Macros/Typedefs
 *
\*****************************************************************************/

EXTERN_C HINSTANCE g_hinst;   // My instance handle
#define HINST_THISDLL g_hinst


#define WizardNext(hwnd, to)          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)to)

//
// we may not be part of the namespace on IE3/Win95
//
typedef BOOL (WINAPI *PFNILISEQUAL)(LPCITEMIDLIST, LPCITEMIDLIST);


STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define CALLWNDPROC WNDPROC


#include "idispids.h"

#define MAX_PAGES               100

/*****************************************************************************\
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *      WARNING! <shelldll\idlcomm.h> #define's various g_cf's, so we need
 *      to #undef them before we start partying on them again.
 *
\*****************************************************************************/



// Detect "." or ".." as invalid files
#define IS_VALID_FILE(str)        (!(('.' == str[0]) && (('\0' == str[1]) || (('.' == str[1]) && ('\0' == str[2])))))


/*****************************************************************************\
 *
 *      Global state management.
 *
 *      DLL reference count, DLL critical section.
 *
\*****************************************************************************/

void DllAddRef(void);
void DllRelease(void);


#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)

typedef void (*LISTPROC)(UINT flm, LPVOID pv);

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

/*****************************************************************************\
 *      Local Includes
\*****************************************************************************/


typedef unsigned __int64 QWORD, * LPQWORD;

void GetCfBufA(UINT cf, PSTR psz, int cch);

// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;


#define QW_MAC              0xFFFFFFFFFFFFFFFF

#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define MAX_EMAIL_ADDRESSS              MAX_URL_STRING
#define SZ_EMPTY                        TEXT("")



//  Features (This is where they are turned on and off)

// With this feature on, we demote the advanced appearances
// options into an "Advanced" subdialog.
#define FEATURE_DEMOTE_ADVANCED_APPEAROPTIONS





// String Constants
// Registry
#define SZ_WINDOWMETRICS        TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_APPLIEDDPI           TEXT("AppliedDPI")

// PropertyBag Propertyes
#define SZ_PBPROP_APPLY_THEMEFILE           TEXT("Theme_ApplySettings")         // When this is sent to a CThemeFile object, it will apply the settings that haven't been pulled out of it and placed in other Display Control Panel tabs.
#define SZ_PBPROP_THEME_FILTER              TEXT("ThemeFilter:")                // The filter values of what parts of themes to apply.
#define SZ_PBPROP_THEME_DISPLAYNAME         TEXT("Theme_DisplayName")           // Get the Theme display name for the currently selected item.


#define SIZE_THEME_FILTER_STR               (ARRAYSIZE(SZ_PBPROP_THEME_FILTER) - 1)


// Parsing Characters
#define CH_ADDRESS_SEPARATOR       L';'
#define CH_ADDRESS_QUOTES          L'"'
#define CH_EMAIL_START             L'<'
#define CH_EMAIL_END               L'>'
#define CH_EMAIL_AT                L'@'
#define CH_EMAIL_DOMAIN_SEPARATOR  L'.'
#define CH_HTML_ESCAPE             L'%'
#define CH_COMMA                   L','


#define COLLECTION_SIZE_UNINITIALIZED           -1




/*****************************************************************************\
 *      Local Includes
\*****************************************************************************/

#include "dllload.h"
#include "util.h"



/*****************************************************************************\
        Object Constructors
\*****************************************************************************/
HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\resource.h ===
/*****************************************************************************\
    FILE: resource.h

    DESCRIPTION:
        Header file for the resource file

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include <commctrl.h>


//  Features (This is where they are turned on and off)



/////////////////////////////////////////////////////////////////////
// String Resource IDs (0x2000 - 0x10000)
/////////////////////////////////////////////////////////////////////


// Error Strings
#define IDS_ERROR_MESSAGENUMBER                                     2000
#define IDS_ERROR_CONVERTIMAGEFAILED                                2001



// Install Strings  (4000 - 4999)




/////////////////////////////////////////////////////////////////////
// Dialogs  (1000 - 1100)
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
// Dialog Controls  (1101 - 2000)
/////////////////////////////////////////////////////////////////////










/////////////////////////////////////////////////////////////////////
// Wizard Pages  (401 - 500)
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
// Menu IDs (501 - 530)
/////////////////////////////////////////////////////////////////////
// appearance preview menu
#define IDM_IMAGEMENU                                   501

#define IDC_IMAGEMENU_MAX                               16          // This is the max we can put on the menu.  We can change this if needed

/////////////////////////////////////////////////////////////////////
// Menu Item IDs (531 - 600)
/////////////////////////////////////////////////////////////////////
#define IDC_IMAGEMENU_CONVERT_GIF                       0
#define IDC_IMAGEMENU_CONVERT_JPEG                      1
#define IDC_IMAGEMENU_CONVERT_PNG                       2
#define IDC_IMAGEMENU_CONVERT_TIFF                      3
#define IDC_IMAGEMENU_CONVERT_BMP                       4




/////////////////////////////////////////////////////////////////////
// Bitmap Resource IDs (601 - 700)
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
// Icons IDs (701 - 800)
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
// AVI Resource IDs (801 - 900)
/////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include <comdef.h>

#define DECL_CRTFREE
#include <crtfree.h>

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;


#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

//    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG






/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
#undef SysAllocStringA
BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;
}


HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocStringA(pszSource);
        if (pszSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


LPSTR AllocStringFromBStr(BSTR bstr)
{
    USES_CONVERSION;        // atlbase.h

    char *a = W2A((bstr ? bstr : L""));
    int len = 1 + lstrlenA(a);

    char *p = (char *)LocalAlloc(LPTR, len);
    if (p)
    {
        StrCpyA(p, a);
    }

    return p;
}


HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstr)
{
    STATSTG statStg = {0};
    HRESULT hr = pStream->Stat(&statStg, STATFLAG_NONAME);

    if (S_OK == hr)
    {
        DWORD cchSize = statStg.cbSize.LowPart;
        *pbstr = SysAllocStringLen(NULL, cchSize + 4);

        if (*pbstr)
        {
            LPSTR pszTemp = (LPSTR) LocalAlloc(LPTR, sizeof(pszTemp[0]) * (cchSize + 4));

            if (pszTemp)
            {
                ULONG cbRead;

                hr = pStream->Read(pszTemp, cchSize, &cbRead);
                pszTemp[cchSize] = 0;
                SHAnsiToUnicode(pszTemp, *pbstr, (cchSize + 1));

                LocalFree(pszTemp);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr) || cbRead == 0)
        {
            break;
        }
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
        {
            break;
        }
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));
 
    if (pcb && SUCCEEDED(hr))
        *pcb = cbTotal;

    return hr;
}


HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString)
{
    HRESULT hr = E_INVALIDARG;

    if (pvar)
    {
        pvar->bstrVal = SysAllocString(pwszString);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hr = S_OK;
        }
        else
        {
            pvar->vt = VT_EMPTY;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped)
{
    HRESULT hr = HrSysAllocString(bstrEscaped, pbstrUnEscaped);

    if (SUCCEEDED(hr))
    {
        // Find %xx and replace.
        LPWSTR pwszEscapedSequence = StrChrW(*pbstrUnEscaped, CH_HTML_ESCAPE);
        WCHAR wzEscaped[5] = L"0xXX";

        while (pwszEscapedSequence && (3 <= lstrlenW(pwszEscapedSequence)))
        {
            int nCharCode;

            wzEscaped[2] = pwszEscapedSequence[1];
            wzEscaped[3] = pwszEscapedSequence[2];
            StrToIntExW(wzEscaped, STIF_SUPPORT_HEX, &nCharCode);

            // Replace the '%' with the real char.
            pwszEscapedSequence[0] = (WCHAR) nCharCode;

            pwszEscapedSequence = CharNextW(pwszEscapedSequence);   // Skip pasted the replaced char.

            // Over write the 0xXX value.
            StrCpyW(pwszEscapedSequence, &pwszEscapedSequence[2]);

            // Next...
            pwszEscapedSequence = StrChrW(pwszEscapedSequence, CH_HTML_ESCAPE);
        }
    }

    return hr;
}



/*****************************************************************************\
    PARAMETERS:
        If fBoolean is TRUE, return "True" else "False".
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrValue)
    {
        LPCWSTR pwszValue;

        *pbstrValue = NULL;
        if (TRUE == fBoolean)
        {
            pwszValue = SZ_QUERYDATA_TRUE;
        }
        else
        {
            pwszValue = SZ_QUERYDATA_FALSE;
        }

        hr = HrSysAllocString(pwszValue, pbstrValue);
    }

    return hr;
}
\*****************************************************************************/



#define SZ_VALID_XML      L"<?xml"

/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_FAIL;
    
    // We don't even want to
    // bother passing it to the XML DOM because they throw exceptions.  These
    // are caught and handled but we still don't want this to happen.  We try
    // to get XML from the web server, but we get HTML instead if the web server
    // fails or the web proxy returns HTML if the site isn't found.
    if (!StrCmpNIW(SZ_VALID_XML, bstrXML, (ARRAYSIZE(SZ_VALID_XML) - 1)))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));

        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fIsSuccessful;

            // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
            //    This is not good but there isn't much we can do about it.  The problem is
            //    that web proxies give back HTML which fails to parse.
            hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_TRUE != fIsSuccessful)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            (*ppXMLDoc)->Release();
            *ppXMLDoc = NULL;
        }
    }

    return hr;
}


HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML)
{
    IStream * pStream;
    HRESULT hr = pXMLDoc->QueryInterface(IID_PPV_ARG(IStream, &pStream)); // check the return value

    if (S_OK == hr)
    {
        hr = BSTRFromStream(pStream, pbstrXML);
        pStream->Release();
    }

    return hr;
}


HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend)
{
    IXMLDOMNode * pXMLNodeRoot;
    HRESULT hr = pXMLElementRoot->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeRoot));

    if (EVAL(SUCCEEDED(hr)))
    {
        IXMLDOMNode * pXMLNodeToAppend;
        
        hr = pXMLElementToAppend->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeToAppend));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pXMLNodeRoot->appendChild(pXMLNodeToAppend, NULL);
            pXMLNodeToAppend->Release();
        }

        pXMLNodeRoot->Release();
    }

    return hr;
}


HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDOMDoc));

    if (SUCCEEDED(hr))
    {
        VARIANT xmlSource;

        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(pwzPath);

        if (xmlSource.bstrVal)
        {
            VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;

            hr = (*ppXMLDOMDoc)->load(xmlSource, &fIsSuccessful);
            if ((S_FALSE == hr) || (VARIANT_FALSE == fIsSuccessful))
            {
                // This happens when the file isn't a valid XML file.
                hr = E_FAIL;
            }

            VariantClear(&xmlSource);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppXMLDOMDoc);
        }
    }

    return hr;
}


HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue)
{
    BSTR bstrAttributeName = SysAllocString(pwszAttributeName);
    HRESULT hr = E_OUTOFMEMORY;

    *pbstrValue = NULL;
    if (bstrAttributeName)
    {
        IXMLDOMNamedNodeMap * pNodeAttributes;

        hr = pXMLNode->get_attributes(&pNodeAttributes);
        if (S_FALSE == hr)  hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNode * pTypeAttribute;

            hr = pNodeAttributes->getNamedItem(bstrAttributeName, &pTypeAttribute);
            if (S_FALSE == hr)  hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            if (SUCCEEDED(hr))
            {
                VARIANT varAtribValue = {0};

                hr = pTypeAttribute->get_nodeValue(&varAtribValue);
                if (S_FALSE == hr)  hr = E_FAIL;
                if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
                {
                    *pbstrValue = SysAllocString(varAtribValue.bstrVal);
                }

                VariantClear(&varAtribValue);
                pTypeAttribute->Release();
            }

            pNodeAttributes->Release();
        }

        SysFreeString(bstrAttributeName);
    }

    return hr;
}


HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElement));
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue)
{
    DOMNodeType nodeType = NODE_TEXT;
    HRESULT hr = pXMLNode->get_nodeType(&nodeType);

    *pbstrValue = NULL;

    if (S_FALSE == hr)  hr = E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (NODE_TEXT == nodeType)
        {
            VARIANT varAtribValue = {0};

            hr = pXMLNode->get_nodeValue(&varAtribValue);
            if (S_FALSE == hr)  hr = E_FAIL;
            if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
            {
                *pbstrValue = SysAllocString(varAtribValue.bstrVal);
            }

            VariantClear(&varAtribValue);
        }
        else
        {
            hr = pXMLNode->get_text(pbstrValue);
        }
    }

    return hr;
}


HRESULT XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue)
{
    IXMLDOMNode * pNodeType;
    HRESULT hr = XMLNode_GetChildTag(pXMLNode, bstrChildTag, &pNodeType);

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetTagText(pNodeType, pbstrValue);
        pNodeType->Release();
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean)
{
    BSTR bstr;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstr);

    if (SUCCEEDED(hr))
    {
        if (!StrCmpIW(bstr, L"on"))
        {
            *pfBoolean = TRUE;
        }
        else
        {
            *pfBoolean = FALSE;
        }

        SysFreeString(bstr);
    }

    return hr;
}


BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText)
{
    BOOL fIsChildTagTextEqual = FALSE;
    BSTR bstrChildText;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstrChildText);

    if (SUCCEEDED(hr))
    {
        // Is this <TYPE>email</TYPE>?
        if (!StrCmpIW(bstrChildText, bstrText))
        {
            // No, so keep looking.
            fIsChildTagTextEqual = TRUE;
        }

        SysFreeString(bstrChildText);
    }

    return fIsChildTagTextEqual;
}




/////////////////////////////////////////////////////////////////////
// Wininet Wrapping Helpers
/////////////////////////////////////////////////////////////////////
#define EMPTYSTR_FOR_NULL(str)      ((!str) ? TEXT("") : (str))

/*****************************************************************************\
    FUNCTION: InternetConnectWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 144ms - 250ms (Min: 2; Max: 1,667ms)
        To: rigel.cyberpass.net <San Diego, CA>: 717ms - 1006ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 2609ms - 14,012ms

    COMMON ERROR VALUES:
        These are the return values in these different cases:
    ERROR_INTERNET_NAME_NOT_RESOLVED: No Proxy & DNS Lookup failed.
    ERROR_INTERNET_CANNOT_CONNECT: Some Auth Proxies and Netscape's Web/Auth Proxy
    ERROR_INTERNET_NAME_NOT_RESOLVED: Web Proxy
    ERROR_INTERNET_TIMEOUT: Invalid or Web Proxy blocked IP Address
    ERROR_INTERNET_INCORRECT_PASSWORD: IIS & UNIX, UserName may not exist or password for the user may be incorrect on.
    ERROR_INTERNET_LOGIN_FAILURE: Too many Users on IIS.
    ERROR_INTERNET_INCORRECT_USER_NAME: I haven't seen it.
    ERROR_INTERNET_EXTENDED_ERROR: yahoo.com exists, but ftp.yahoo.com doesn't.
\*****************************************************************************/
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetConnect(hInternet, pszServerName, nServerPort, pszUserName, pszPassword, dwService, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetConnect(%#08lx, \"%ls\", \"%ls\", \"%ls\") returned %u. Time=%lums", hInternet, pszServerName, EMPTYSTR_FOR_NULL(pszUserName), EMPTYSTR_FOR_NULL(pszPassword), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        Destination not applicable. 677-907ms
\*****************************************************************************/
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetOpen(\"%ls\") returned %u. Time=%lums", pszAgent, dwError, DebugStopWatch()));

    return hr;
}


HRESULT InternetCloseHandleWrap(HINTERNET hInternet)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCloseHandle(hInternet))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetCloseHandle(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenUrlWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 29ms
        To: rigel.cyberpass.net <San Diego, CA>: ???????
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetOpenUrl(%#08lx, \"%ls\") returned %u. Time=%lums", hInternet, pszUrl, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phConnectionHandle = HttpOpenRequestA(hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferer, lpszAcceptTypes, dwFlags, dwContext);
    if (!*phConnectionHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMTHEME, "HttpOpenRequest(%#08lx, \"%ls\") returned %u. Time=%lums", *phConnectionHandle, lpszVerb, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!HttpSendRequestA(hRequest, lpszHeaders,  dwHeadersLength, lpOptional, dwOptionalLength))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CreateUrlCacheEntry(lpszUrlName, dwExpectedFileSize, lpszFileExtension, lpszFileName, dwReserved))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN LPWSTR lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CommitUrlCacheEntryW(lpszUrlName, lpszLocalFileName, ExpireTime, LastModifiedTime, CacheEntryType, lpHeaderInfo, dwHeaderSize, lpszFileExtension, lpszOriginalUrl))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMTHEME, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}



#define SIZE_COPY_BUFFER                    (32 * 1024)     // 32k

HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML)
{
    BYTE byteBuffer[SIZE_COPY_BUFFER];
    DWORD cbRead = SIZE_COPY_BUFFER;
    DWORD cchSize = 0;
    HRESULT hr = S_OK;

    *pbstrXML = NULL;
    while (SUCCEEDED(hr) && cbRead)
    {
        hr = InternetReadFileWrap(hInternetRead, byteBuffer, SIZEOF(byteBuffer), &cbRead);
        if (SUCCEEDED(hr) && cbRead)
        {
            BSTR bstrOld = *pbstrXML;
            BSTR bstrEnd;

            // The string may not be terminated.
            byteBuffer[cbRead] = 0;

            cchSize += ARRAYSIZE(byteBuffer);
            *pbstrXML = SysAllocStringLen(NULL, cchSize);
            if (*pbstrXML)
            {
                if (bstrOld)
                {
                    StrCpy(*pbstrXML, bstrOld);
                }
                else
                {
                    (*pbstrXML)[0] = 0;
                }

                bstrEnd = *pbstrXML + lstrlenW(*pbstrXML);

                SHAnsiToUnicode((LPCSTR) byteBuffer, bstrEnd, ARRAYSIZE(byteBuffer));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SysFreeString(bstrOld);
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hTemp = NULL;
    DWORD dwError = 0;

    if (!phFileHandle)
        phFileHandle = &hTemp;

    *phFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (hTemp)
        CloseHandle(hTemp);

    return hr;
}


HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT DeleteFileHrWrap(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!DeleteFileW(pszPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    HRESULT hr = S_OK;
    DWORD chGot = GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);

    // What else can indicate an error value?
    if (0 == chGot)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Registry Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwError = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    DWORD dwError = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegQueryValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN LPDWORD lpReserved, IN LPDWORD lpType, IN LPBYTE lpData, IN LPDWORD lpcbData)
{
    DWORD dwError = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData)
{
    DWORD dwError = RegSetValueEx(hKey, lpValueName, dwReserved, dwType, lpData, cbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName)
{
    DWORD dwError = RegEnumKey(hKey, dwIndex, lpName, cbName);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    DWORD dwError = RegEnumValue(hKey, dwIndex, lpValueName, lpcValueName, lpReserved, lpType, lpData, lpcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
{
    DWORD dwError = RegQueryInfoKey(hKey, lpClass, lpcClass, lpReserved, lpcSubKeys, lpcMaxSubKeyLen, 
            lpcMaxClassLen, lpcValues, lpcMaxValueNameLen, lpcMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr)
{
    TCHAR szValue[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szValue);
    HRESULT hr = HrRegQueryValueEx(hKey, lpValueName, 0, &dwType, (BYTE *)szValue, &cbSize);

    *pbstr = NULL;
    if (SUCCEEDED(hr))
    {
        hr = HrSysAllocStringW(szValue, pbstr);
    }

    return hr;
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData)
{
    DWORD dwError = SHSetValue(hkey, pszSubKey, pszValue, dwType, pvData, cbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszPath)
{
    DWORD cbSize = ((lstrlenW(pszPath) + 1) * sizeof(pszPath[0]));

    return  HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)pszPath, cbSize);
}


HRESULT HrRegDeleteValue(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName)
{
    HRESULT hr = S_OK;
    HKEY hKeySub = hKey;

    if (pszSubKey)
    {
        hr = HrRegOpenKeyEx(hKey, pszSubKey, 0, KEY_WRITE, &hKeySub);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwError = RegDeleteValue(hKeySub, pszValueName);

        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (hKeySub == hKey)
    {
        RegCloseKey(hKeySub);
    }

    return hr;
}


DWORD HrRegGetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwDefault)
{
    DWORD dwResult = dwDefault;
    DWORD cbSize = sizeof(dwResult);
    DWORD dwType;
    DWORD dwError = SHGetValue(hKey, szKey, szValue, &dwType, &dwResult, &cbSize);

    if ((ERROR_SUCCESS == dwError) ||
        ((REG_DWORD != dwType) && (REG_BINARY != dwType)))
    {
        return dwDefault;
    }

    return dwResult;
}





/////////////////////////////////////////////////////////////////////
// Palette Helpers
/////////////////////////////////////////////////////////////////////
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe;
    GetPaletteEntries(hpal, GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF), 1, &pe);
    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}


BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}





/////////////////////////////////////////////////////////////////////
// Other Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRewindStream(IStream * pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}



#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))





// PERFPERF 
// This routine used to copy 512 bytes at a time, but that had a major negative perf impact.
// I have measured a 2-3x speedup in copy times by increasing this buffer size to 16k.
// Yes, its a lot of stack, but it is memory well spent.                    -saml
#define STREAM_COPY_BUF_SIZE        16384
#define STREAM_PROGRESS_INTERVAL    (100*1024/STREAM_COPY_BUF_SIZE) // display progress after this many blocks

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi)
{
    BYTE buf[STREAM_COPY_BUF_SIZE];
    ULONG cbRead;
    HRESULT hres = NOERROR;
    int nSection = 0;         // How many buffer sizes have we copied?
    ULARGE_INTEGER uliNewCompleted;

    if (ppi)
    {
        uliNewCompleted.QuadPart = ppi->uliBytesCompleted.QuadPart;
    }

    while (cb.QuadPart)
    {
        if (ppi && ppi->ppd)
        {
            if (0 == (nSection % STREAM_PROGRESS_INTERVAL))
            {
                EVAL(SUCCEEDED(ppi->ppd->SetProgress64(uliNewCompleted.QuadPart, ppi->uliBytesTotal.QuadPart)));

                if (ppi->ppd->HasUserCancelled())
                {
                    hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
            }
        }

        hres = pstmFrom->Read(buf, min(cb.LowPart, SIZEOF(buf)), &cbRead);
        if (FAILED(hres) || (cbRead == 0))
        {
            //  sometimes we are just done.
            if (SUCCEEDED(hres))
                hres = S_OK;
            break;
        }


        if (ppi)
        {
            uliNewCompleted.QuadPart += (ULONGLONG) cbRead;
        }

        cb.QuadPart -= cbRead;

        hres = pstmTo->Write(buf, cbRead, &cbRead);
        if (FAILED(hres) || (cbRead == 0))
            break;

        nSection++;
    }

    return hres;
}

/*
// These are needed for COM/COM+ interop

void __stdcall
_com_raise_error(HRESULT hr, IErrorInfo* perrinfo) throw(_com_error)
{
        throw _com_error(hr, perrinfo);
}

void __stdcall
_com_issue_error(HRESULT hr) throw(_com_error)
{
        _com_raise_error(hr, NULL);
}

void __stdcall
_com_issue_errorex(HRESULT hr, IUnknown* punk, REFIID riid) throw(_com_error)
{
        IErrorInfo* perrinfo = NULL;
        if (punk == NULL) {
                goto exeunt;
        }
        ISupportErrorInfo* psei;
        if (FAILED(punk->QueryInterface(__uuidof(ISupportErrorInfo),
                           (void**)&psei))) {
                goto exeunt;
        }
        HRESULT hrSupportsErrorInfo;
        hrSupportsErrorInfo = psei->InterfaceSupportsErrorInfo(riid);
        psei->Release();
        if (hrSupportsErrorInfo != S_OK) {
                goto exeunt;
        }
        if (GetErrorInfo(0, &perrinfo) != S_OK) {
                perrinfo = NULL;
        }
exeunt:
        _com_raise_error(hr, perrinfo);
}
*/
// needed by smtpserv:

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

const char szDayOfWeekArray[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
const char szMonthOfYearArray[12][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" } ;

void GetDateString(char * szSentDateString, ULONG stringLen)
{
    // Sent Date
    SYSTEMTIME stSentTime;
    CHAR szMonth[10], szWeekDay[12] ; 

    GetSystemTime(&stSentTime);

    lstrcpynA(szWeekDay, szDayOfWeekArray[stSentTime.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    lstrcpynA(szMonth, szMonthOfYearArray[stSentTime.wMonth-1], ARRAYSIZE(szMonth)) ;

    wnsprintfA(szSentDateString, stringLen, "%s, %u %s %u %2d:%02d:%02d ", (LPSTR) szWeekDay, stSentTime.wDay, 
                                (LPSTR) szMonth, stSentTime.wYear, stSentTime.wHour, 
                                stSentTime.wMinute, stSentTime.wSecond) ;
}


/*****************************************************************************\
    PARAMETERS:
        RETURN: Win32 HRESULT (Not Script Safe).
            SUCCEEDED(hr) for OK and out params filled in.
            FAILED(hr) for all errors.
\*****************************************************************************/
HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData)
{
    HRESULT hr = E_FAIL;
    LPCWSTR pwszIterate = bstrURL;

    pwszIterate = StrChrW(pwszIterate, L'?');   // Advance to Query part of URL.
    while (pwszIterate && pwszIterate[0])
    {
        pwszIterate++;  // Start at first value
        
        LPCWSTR pwszEndOfValue = StrChrW(pwszIterate, L'=');
        if (!pwszEndOfValue)
            break;
        
        int cchValueSize = (INT)(UINT)(pwszEndOfValue - pwszIterate);
        if (0 == StrCmpNIW(pwszValue, pwszIterate, cchValueSize))
        {
            int cchSizeToCopy = cchSizeData;  // Copy rest of line by default.

            pwszIterate = StrChrW(pwszEndOfValue, L'&');
            if (pwszIterate)
            {
                cchSizeToCopy = (INT)(UINT)(pwszIterate - pwszEndOfValue);
            }

            // It matches, now get the Data.
            StrCpyNW(pwszData, (pwszEndOfValue + 1), cchSizeToCopy);
            hr = S_OK;
            break;
        }
        else
        {
            pwszIterate = StrChrW(pwszEndOfValue, L'&');
        }
    }

    return hr;
}



// BUGBUG: This makes this object ways safe.  When the MailApps security design is
//    complete, this needs to be removed for the permanate security solution.
HRESULT MarkObjectSafe(IUnknown * punk)
{
    HRESULT hr = S_OK;
    IObjectSafety * pos;

    hr = punk->QueryInterface(IID_PPV_ARG(IObjectSafety, &pos));
    if (SUCCEEDED(hr))
    {
        // BUGBUG: This makes this object ways safe.  When the MailApps security design is
        //    complete, this needs to be removed for the permanate solution.
        pos->SetInterfaceSafetyOptions(IID_IDispatch, (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA), 0);
        pos->Release();
    }

    return hr;
}


BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    ULARGE_INTEGER uiResult;

    uiResult.QuadPart = (ULONGLONG) ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);
    if (32 < uiResult.QuadPart)
    {
        uiResult.LowPart = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(uiResult.LowPart);
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (pszNextToken = StrStrI(pszNextToken, pszToken))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StrCatBuff(pszString, pszReplaceValue, cchSize);
        StrCatBuff(pszString, pszTempLastHalf, cchSize);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid)
{
    BOOL fIsEqual = FALSE;

    if (punk)
    {
        CLSID clsidPageID;
        HRESULT hr = IUnknown_GetClassID(punk, &clsidPageID);

        if (SUCCEEDED(hr) && IsEqualCLSID(clsidPageID, clsid))
        {
            fIsEqual = TRUE;
        }
    }

    return fIsEqual;
}


HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ppunkFound)
    {
        IEnumUnknown * pEnum;

        *ppunkFound = NULL;
        hr = punk->QueryInterface(IID_PPV_ARG(IEnumUnknown, &pEnum));
        if (SUCCEEDED(hr))
        {
            IUnknown * punkToTry;
            ULONG ulFetched;

            pEnum->Reset();

            hr = E_FAIL;
            while (SUCCEEDED(pEnum->Next(1, &punkToTry, &ulFetched)) &&
                (1 == ulFetched))
            {
                if (IUnknown_CompareCLSID(punkToTry, clsid))
                {
                    *ppunkFound = punkToTry;
                    hr = S_OK;
                    break;
                }

                punkToTry->Release();
            }

            pEnum->Release();
        }
    }

    return hr;
}


BYTE WINAPI MyStrToByte(LPCTSTR sz)
{
    BYTE l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
    {
        l = l*10 + (*sz++ - TEXT('0'));
    }

    return l;
}


COLORREF ConvertColor(LPTSTR pszColor)
{
    BYTE RGBTemp[3];
    LPTSTR pszTemp = pszColor;
    UINT i;

    if (!pszColor || !*pszColor)
    {
        return RGB(0,0,0);
    }

    for (i =0; i < 3; i++)
    {
        // Remove leading spaces
        while (*pszTemp == TEXT(' '))
        {
            pszTemp++;
        }

        // Set pszColor to the beginning of the number
        pszColor = pszTemp;

        // Find the end of the number and null terminate
        while ((*pszTemp) && (*pszTemp != TEXT(' ')))
        {
            pszTemp++;
        }

        if (*pszTemp != TEXT('\0'))
        {
            *pszTemp = TEXT('\0');
        }

        pszTemp++;
        RGBTemp[i] = MyStrToByte(pszColor);
    }

    return (RGB(RGBTemp[0], RGBTemp[1], RGBTemp[2]));
}



// Paremeters:
//  hwndOwner  -- owner window
//  idTemplate -- specifies template (e.g., "Can't open %2%s\n\n%1%s")
//  hr         -- specifies the HRESULT error code
//  pszParam   -- specifies the 2nd parameter to idTemplate
//  dwFlags    -- flags for MessageBox
UINT ErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate, HRESULT hr, LPCTSTR pszParam, UINT dwFlags)
{
    UINT idRet = IDCANCEL;
    TCHAR szErrNumString[MAX_PATH * 2];
    TCHAR szTemplate[MAX_PATH * 2];
    TCHAR szErrMsg[MAX_PATH * 2];

    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, szErrNumString, ARRAYSIZE(szErrNumString), NULL))
    {
        AssertMsg((NULL != pszParam), TEXT("We must get a valid error value from FormatMessage or a detailed message must be provided."));
        szErrNumString[0] = 0;

        wnsprintf(szErrNumString, ARRAYSIZE(szErrNumString), TEXT(" hr=%#08lx"), hr);
    }

    LoadString(HINST_THISDLL, idTemplate, szTemplate, ARRAYSIZE(szTemplate));
    if (pszParam)
    {
        wnsprintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, szErrNumString, pszParam);
    }
    else
    {
        wnsprintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, szErrNumString);
    }

    return MessageBox(hwndOwner, szErrMsg, pszTitle, (MB_OK | MB_ICONERROR));
}


BOOL IsOSNT(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return (VER_PLATFORM_WIN32_NT == osVerInfoA.dwPlatformId);
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return osVerInfoA.dwMajorVersion;
}


void LogStatus(LPCSTR pszMessage, ...)
{
    static int nLogOn = -1;
    va_list vaParamList;

    va_start(vaParamList, pszMessage);

    if (-1 == nLogOn)
    {
        nLogOn = 1;//(SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_LOGINFO, FALSE, FALSE) ? 1 : 0);
    }

    if (1 == nLogOn)
    {
        if (INVALID_HANDLE_VALUE == g_hLogFile)
        {
            TCHAR szPath[MAX_PATH];

            if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
            {
                PathAppend(szPath, TEXT("Theme.log"));
                g_hLogFile = CreateFile(szPath, (GENERIC_READ | GENERIC_WRITE), FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (INVALID_HANDLE_VALUE != g_hLogFile)
                {
                    CHAR szTimeDate[MAX_PATH];
                    FILETIME ftCurrent;
                    SYSTEMTIME stCurrent;
                    DWORD cbWritten;

                    GetLocalTime(&stCurrent);
                    SystemTimeToFileTime(&stCurrent, &ftCurrent);
                    SHFormatDateTimeA(&ftCurrent, NULL, szTimeDate, ARRAYSIZE(szTimeDate));

                    StrCatBuffA(szTimeDate, "\r\n", ARRAYSIZE(szTimeDate));
                    WriteFile(g_hLogFile, szTimeDate, lstrlenA(szTimeDate), &cbWritten, NULL);
                }

            }
        }

        if (INVALID_HANDLE_VALUE != g_hLogFile)
        {
            CHAR szMessage[4000];
            DWORD cbWritten;
            wvsprintfA(szMessage, pszMessage, vaParamList);
            WriteFile(g_hLogFile, szMessage, lstrlenA(szMessage), &cbWritten, NULL);
        }
    }

    va_end(vaParamList);
}


#define SzFromInt(sz, n)            (wsprintf((LPTSTR)sz, (LPTSTR)TEXT("%d"), n), (LPTSTR)sz)

int WritePrivateProfileInt(LPCTSTR szApp, LPCTSTR szKey, int nDefault, LPCTSTR pszFileName)
{
    CHAR sz[7];

    return WritePrivateProfileString(szApp, szKey, SzFromInt(sz, nDefault), pszFileName);
}


#define SZ_RESOURCEDIR              L"Resources"

HRESULT SHGetResourcePath(IN LPWSTR pszPath, IN DWORD cchSize)
{
    return SHGetFolderPath(NULL, CSIDL_RESOURCES_LOCALIZED | CSIDL_FLAG_CREATE, NULL, 0, pszPath);
}


#define SZ_RESOURCEDIR_TOKEN        TEXT("%ResourceDir%")
HRESULT ExpandResourceDir(IN LPWSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPCTSTR pszToken = StrStrW(pszPath, SZ_RESOURCEDIR_TOKEN);

    // Do we have stuff to replace?
    if (pszToken)
    {
        // Yes, so get the replacement value.
        WCHAR szResourceDir[MAX_PATH];

        hr = SHGetResourcePath(szResourceDir, ARRAYSIZE(szResourceDir));
        if (SUCCEEDED(hr))
        {
            hr = StrReplaceToken(SZ_RESOURCEDIR_TOKEN, szResourceDir, pszPath, cchSize);
        }
    }

    return hr;
}


STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName)
    {
        VARIANT va;

        va.vt = VT_UNKNOWN;
        va.punkVal = punk;

        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}


STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        hr = pPropertyPage->Read(pwzPropName, &va, NULL);
        if (SUCCEEDED(hr))
        {
            if ((VT_BYREF == va.vt) && va.byref)
            {
                CopyMemory(p, va.byref, cbSize);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        va.vt = VT_BYREF;
        va.byref = p;
        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}



HRESULT MyReleaseStgMedium( LPSTGMEDIUM pmedium )
{
    if( pmedium->pUnkForRelease )
    {
        pmedium->pUnkForRelease->Release( );
    }
    else
    {
        switch( pmedium->tymed )
        {
        case TYMED_HGLOBAL:
            GlobalFree( pmedium->hGlobal );
            break;

        case TYMED_ISTORAGE:
        case TYMED_ISTREAM:
            //
            // hack, the stream and storage overlap eachother in the union
            // so this works for both.
            //

            pmedium->pstm->Release( );
            break;

        default:
            //
            // Assert( 0 );        // unknown type
            // Not fullly implemented.

            MessageBeep( 0 );
                break;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: Gets a file list from an IDataObject.  Allocates
         ppszList to appropriate size and fills it with
         a null-terminated list of paths.  It is double-null
         terminated.

         If ppszList is NULL, then simply get the count of files.

         Call DataObj_FreeList to free the ppszList.

Returns: standard
         S_OK if the objects are inside a briefcase
         S_FALSE if not
Cond:    --
*/
HRESULT PUBLIC DataObj_QueryFileList(
    LPDATAOBJECT pdtobj,
    LPTSTR * ppszList,       // List of files (may be NULL)
    LPUINT puCount)         // Count of files
{
    HRESULT hres = ResultFromScode(E_FAIL);
    FORMATETC fmteHdrop = {(CLIPFORMAT)CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(puCount);

    // Or does it support hdrops?
    //
    hres = pdtobj->GetData(&fmteHdrop, &medium);
    if (SUCCEEDED(hres))
    {
        // Yup
        HDROP hdrop = (HDROP)medium.hGlobal;
        UINT cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);
        UINT cchSize = 0;
        UINT i;

        *puCount = cFiles;
        hres = ResultFromScode(S_FALSE);

        if (ppszList)
        {
            // Determine size we need to allocate
            for (i = 0; i < cFiles; i++)
            {
                cchSize += DragQueryFile(hdrop, i, NULL, 0) + 1;
            }
            cchSize++;      // for extra null

            *ppszList = (LPTSTR)LocalAlloc(LPTR, CbFromCch(cchSize));
            if (*ppszList)
            {
                LPTSTR psz = *ppszList;
                UINT cch;

                // Translate the hdrop into our file list format.
                // We know that they really are the same format,
                // but to maintain the abstraction layer, we
                // pretend we don't.
                for (i = 0; i < cFiles; i++)
                {
                    cch = DragQueryFile(hdrop, i, psz, cchSize) + 1;
                    psz += cch;
                    cchSize -= cch;
                }
                *psz = TEXT('\0');    // extra null
            }
            else
            {
                hres = ResultFromScode(E_OUTOFMEMORY);
            }
        }
        MyReleaseStgMedium(&medium);
        goto Leave;
    }

    // FEATURE: do we need to query for CF_TEXT?

Leave:
    return hres;
}


/*----------------------------------------------------------
Purpose: Frees a file list that was allocated by DataObj_QueryFileList.
Returns: --
Cond:    --
*/
void PUBLIC DataObj_FreeList(
    LPTSTR pszList)
{
    LocalFree(pszList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\starbuck\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "dllload.h"
#define HINST_THISDLL       g_hinst



// String Helpers
HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstrXML);
LPSTR AllocStringFromBStr(BSTR bstr);
HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);

#ifdef UNICODE
#define SysAllocStringT(pszString)    SysAllocString(pszString)
#else
extern BSTR SysAllocStringA(LPCSTR pszString);
#define SysAllocStringT(pszString)    SysAllocStringA(pszString)
#endif

HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData);
HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped);
HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize);


// XML Related Helpers
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML);
HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend);
HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc);
HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode);
HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);
HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean);
BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText);




// Wininet Helpers
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
HRESULT InternetCloseHandleWrap(HINTERNET hInternet);
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);
HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle);
HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength);
HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved);
HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN LPWSTR lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl);
HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML);


// File System Helpers
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle);
HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
HRESULT DeleteFileHrWrap(LPCWSTR pszPath);



// Registry Helpers
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
HRESULT HrRegQueryValueEx(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData);
HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName);
HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);

HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr);
HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszPath);
HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType, OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData);
HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData);
DWORD HrRegGetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwDefault);
HRESULT HrRegDeleteValue(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName);



// Palette Helpers
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb);
BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb);


// Theme Specific Helpers
HRESULT SHGetResourcePath(IN LPWSTR pszPath, IN DWORD cchSize);
HRESULT ExpandResourceDir(IN LPWSTR pszPath, IN DWORD cchSize);



// Other Helpers
HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
HRESULT MarkObjectSafe(IUnknown * punk);
BOOL _InitComCtl32();
HRESULT HrRewindStream(IStream * pstm);
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
COLORREF ConvertColor(LPTSTR pszColor);
BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid);
HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound);
UINT ErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate, HRESULT hr, LPCTSTR pszParam, UINT dwFlags);
BOOL IsOSNT(void);
DWORD GetOSVer(void);
void LogStatus(LPCSTR pszMessage, ...);
int WritePrivateProfileInt(LPCTSTR szApp, LPCTSTR szKey, int nDefault, LPCTSTR pszFileName);
STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN IUnknown * punk);
STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize);
STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN void * p);
HRESULT DataObj_QueryFileList(LPDATAOBJECT pdtobj, LPTSTR * ppszList, LPUINT puCount);
void DataObj_FreeList(LPTSTR pszList);



typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi);

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);




#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\test\test.cpp ===
#define STRICT
#define UNICODE
#include <windows.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <stdio.h>

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

HRESULT CoUnmarshalFromCmdLine(LPCTSTR pszCmdLine, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    pszCmdLine = StrStr(pszCmdLine, TEXT("/DataObject:"));
    if (pszCmdLine)
    {
        pszCmdLine += lstrlen(TEXT("/DataObject:"));

        char buf[255]; // big enough for standard marshall buffer (which is 68 bytes)
        for (ULONG cb = 0; *pszCmdLine && (cb < sizeof(buf)); cb++)
        {
            buf[cb] = (*pszCmdLine - 'A') + ((*(pszCmdLine + 1) - 'A') << 4);
            if (*(pszCmdLine + 1))
                pszCmdLine += 2;
            else
                break;  // odd # of chars in cmd line, error
        }

        // _asm { int 3 };

        if (cb < sizeof(buf))
        {
            IStream *pstm;
            hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
            if (SUCCEEDED(hr)) 
            {
                // fill the marshall stream
                const LARGE_INTEGER li = {0, 0};
                pstm->Write(buf, cb, NULL);

                // move back to start of stream
                pstm->Seek(li, STREAM_SEEK_SET, NULL);

                hr = CoUnmarshalInterface(pstm, riid, ppv);

                pstm->Release();
            }
        }
    }
    return hr;
}

void __cdecl main(void)
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    IDataObject *pdtobj;
    if (SUCCEEDED(CoUnmarshalFromCmdLine(GetCommandLine(), IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium;

        if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
        {
            TCHAR szPath[MAX_PATH];
            for (int i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, MAX_PATH); i++)
            {
                MessageBox(NULL, szPath, TEXT("File Name"), MB_OK);
            }
            ReleaseStgMedium(&medium);
        }

        pdtobj->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\types\makefile.inc ===
!CMDSWITCHES +i

$O\shell95.out: $(SHELL95)\shell32.dll
    $(TLVIEWER) $(SHELL95)\shell32.dll $@

$O\shellnt.out: $(SHELLNT)\shell32.dll
    $(TLVIEWER) $(SHELLNT)\shell32.dll $@

$O\shdocvw.out: $(SHDOCVW)\shdocvw.dll
    $(TLVIEWER) $(SHDOCVW)\shdocvw.dll $@

!CMDSWITCHES -i

$O\sh95err.out: $O\shell95.out shell32.ref
    $(TLDIFF) -s -f tldiff.ini $O\shell95.out shell32.ref > $@


$O\shnterr.out: $O\shellnt.out shell32.ref
    $(TLDIFF) -s -f tldiff.ini $O\shellnt.out shell32.ref > $@


$O\shdocer.out: $O\shdocvw.out shdocvw.ref
    $(TLDIFF) -s -f tldiff.ini $O\shdocvw.out shdocvw.ref > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\aciniupd\aciniupd.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  ACINIUPD.H
*     This module contains typedefs and defines required for
*     the ACINIUPD utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_GET_VALUE                             102
#define IDS_ERROR_UPDATE_VALUE                          103
#define IDS_ERROR_DEL_KEY                               104
#define IDS_ERROR_UPDATE_KEY                            105
#define IDS_ERROR_CHANGE_MODE                           106
#define IDS_HELP_USAGE1                                 110
#define IDS_HELP_USAGE2                                 111
#define IDS_HELP_USAGE3                                 112
#define IDS_HELP_USAGE4                                 113
#define IDS_HELP_USAGE5                                 114
#define IDS_HELP_USAGE6                                 115
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\aciniupd\aciniupd.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***************************************************************************
*
*  ACINIUPD.C
*
*  Utility to update INI files
*
*
****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <utilsub.h>
#include <string.h>

#include "aciniupd.h"
#include "tsappcmp.h"

#define WININI    L"win.ini"

/*
 * Global Data
 */
WCHAR file_name[MAX_IDS_LEN+1];        // ini file name
WCHAR section_name[MAX_IDS_LEN+1];     // section name
WCHAR key_name[MAX_IDS_LEN+1];         // key name
WCHAR new_string[MAX_IDS_LEN+1];       // new string
USHORT help_flag  = FALSE;             // User wants help
USHORT fEditValue = FALSE;             // Update the value associated with the key
USHORT fEditKey   = FALSE;             // Update the key name
USHORT fUserIni   = FALSE;             // Make change to the user's windows directory
USHORT fVerbose   = FALSE;             // Verbose mode for debugging

TOKMAP ptm[] = {
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {L"/e", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEditValue},
      {L"/k", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEditKey},
      {L"/u", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fUserIni},
      {L"/v", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fVerbose},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, file_name},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, section_name},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, key_name},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, new_string},
      {0, 0, 0, 0, 0}
};

/*
 * Local functions
 */
void Usage(BOOLEAN bError);
int UpdateValue(PWCHAR fileName, PWCHAR sectionName, PWCHAR keyName, PWCHAR newString);
int UpdateKey(PWCHAR fileName, PWCHAR sectionName, PWCHAR keyName, PWCHAR newString);

/******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( INT argc, CHAR **argv )
{
    WCHAR **argvW;
    WCHAR wcSrcPort[MAX_PATH], wcDestPort[MAX_PATH];
    ULONG ulSrcPort, ulDestPort, rc;
    BOOLEAN State, Changed = FALSE;
    int result = SUCCESS;
    BOOL InstallState;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {
            Usage(TRUE);
            return(FAILURE);
        } else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

    if (wcscmp( file_name, L"" ) == 0 ||
        wcscmp( section_name, L"" ) == 0 ||
        wcscmp( key_name, L"" ) == 0) {
       Usage( TRUE );
       return (FAILURE);
    }


    rc = 1;
#if 0
    State = CtxGetIniMapping();
    /*
     * Change the INI mapping mode if necessary
     */
    if (!State && fUserIni) {
       rc = CtxSetIniMapping( TRUE );
       Changed = TRUE;
    }
    else if (State && !fUserIni) {
       rc = CtxSetIniMapping( FALSE );
       Changed = TRUE;
    }
#else
    InstallState = TermsrvAppInstallMode();

    if( InstallState && fUserIni ) {
        rc = SetTermsrvAppInstallMode( FALSE );
        Changed = TRUE;
    } else if( !InstallState && !fUserIni ) {
        rc = SetTermsrvAppInstallMode( TRUE );
        Changed = TRUE;
    }

#endif // 0

    /*
     * Exit if failed to change user mode
     */
    if (!rc) {
       if (fVerbose) ErrorPrintf(IDS_ERROR_CHANGE_MODE, GetLastError());
       return (FAILURE);
    }

    if (fEditValue) {
       result = UpdateValue(file_name, section_name, key_name, new_string);
    }
    else if (fEditKey) {
       result = UpdateKey(file_name, section_name, key_name, new_string);
    }
    else {
       Usage(FALSE);
       result = FAILURE;
    }

    /*
     * Change back to the original mode if necessary. Assume it always successes.
     */
    if (Changed) {
//       rc = CtxSetIniMapping( State );
         rc = SetTermsrvAppInstallMode( InstallState );
    }

    return (result);
}  /* main */

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE6);
}  /* Usage() */

/******************************************************************************
*
* UpdateValue
*
*     Update the associated value for the key
*
* ENTRY:
*     PWCHAR   fileName
*        Ini file name
*     PWCHAR   sectionName
*        Section name
*     PWCHAR   keyName
*        Key name
*     pwchar   newString
*        New value
*
* EXIT:
*     FAILURE / SUCCESS
*
*******************************************************************************/

int UpdateValue( PWCHAR fileName,
                 PWCHAR sectionName,
                 PWCHAR keyName,
                 PWCHAR newString )
{
   BOOLEAN  isWinIni;
   WCHAR value[5];
   UINT result = 0;

   isWinIni = wcscmp( fileName, WININI ) == 0 ? TRUE : FALSE;

   /*
    * If change is made to win.ini, call WriteProfileString API
    */
   if (isWinIni) {
      result = WriteProfileString( sectionName,
                                   keyName,
                                   newString );
   }
   /*
    * Otherwise, call WritePrivateProfileString API
    */
   else {
      result = WritePrivateProfileString( sectionName,
                                          keyName,
                                          newString,
                                          fileName );
   }

   if (result == 0) {
      if (fVerbose)
      {
          StringDwordErrorPrintf(IDS_ERROR_UPDATE_VALUE, keyName, GetLastError());
      }
      return (FAILURE);
   }

   return (SUCCESS);
}  /* UpdateValue */

/******************************************************************************
*
* UpdateKey
*
*     Update the key name
*
* ENTRY:
*     PWCHAR   fileName
*        Ini file name
*     PWCHAR   sectionName
*        Section name
*     PWCHAR   keyName
*        Key name
*     PWCHAR   newString
*        New key name
*
* EXIT:
*     FAILURE / SUCCESS
*
*******************************************************************************/

int UpdateKey( PWCHAR fileName,
               PWCHAR sectionName,
               PWCHAR keyName,
               PWCHAR newString )
{
   BOOLEAN  isWinIni;
   PWCHAR value;
   UINT result;

   value = (WCHAR *)malloc( sizeof(WCHAR) * (MAX_IDS_LEN + 1) );
   if (value == NULL) {
      if (fVerbose) ErrorPrintf(IDS_ERROR_MALLOC);
      return (FAILURE);
   }

   __try
   {
       isWinIni = wcscmp( fileName, WININI ) == 0 ? TRUE : FALSE;
    
       /*
        * Get the value string
        */
       if (isWinIni) {
          result = GetProfileString( sectionName,
                                     keyName,
                                     L"",
                                     value,
                                     MAX_IDS_LEN+1 );
       }
       else {
          result = GetPrivateProfileString( sectionName,
                                            keyName,
                                            L"",
                                            value,
                                            MAX_IDS_LEN+1,
                                            fileName );
       }
    
       if (result == 0) {
          if (fVerbose)
          {
              StringErrorPrintf(IDS_ERROR_GET_VALUE, keyName);
          }
          return (FAILURE);
       }
    
       /*
        * Delete the old key
        */
       if (isWinIni) {
          result = WriteProfileString( sectionName, keyName, NULL );
       }
       else {
          result = WritePrivateProfileString( sectionName, keyName, NULL, fileName );
       }
    
       if (result == 0) {
          if (fVerbose)
          {
              StringDwordErrorPrintf(IDS_ERROR_DEL_KEY, keyName, GetLastError());
          }
          return (FAILURE);
       }
    
       /*
        * Add the new key
        */
       if (isWinIni) {
          result = WriteProfileString( sectionName, newString, value );
       }
       else {
          result = WritePrivateProfileString( sectionName, newString, value, fileName );
       }
    
       if (result == 0) {
          if (fVerbose)
          {
              StringDwordErrorPrintf(IDS_ERROR_UPDATE_KEY, keyName, GetLastError());
         }
          return (FAILURE);
       }
    
       return (SUCCESS);
   }

   __finally
   {
       free( value );
   }
}  /* UpdateKey */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\acregl\acregl.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  ACREGL.C
*
*  Application Compatibility Registry Lookup Helper Program
*
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop


// #include <winreg.h>

#define MAXLEN 512



// Options

   // The strip char option will strip the rightmost n instances
   // of the specified character from the output.  If the count
   // is omitted, then a single instance is removed.
   // 
   // Example: STRIPCHAR\3 will change 
   // C:\WINNT40\Profiles\All Users\Start Menu to
   // C:\WINNT40 
#define OPTION_STRIP_CHAR		L"STRIPCHAR"

   // The strip path option strips off the path.
   // 
   // Example: STRIPPATH will change 
   // C:\WINNT40\Profiles\All Users\Start Menu to
   // Start Menu
#define OPTION_STRIP_PATH		L"STRIPPATH"

   // The get path option gets the common paths
   // 
   // Example: GETPATHS will return
   // 
#define OPTION_GET_PATHS		L"GETPATHS"

   // Define the strings used for setting the user/common paths
#define COMMON_STARTUP                  L"COMMON_STARTUP"
#define COMMON_START_MENU               L"COMMON_START_MENU"
#define COMMON_PROGRAMS                 L"COMMON_PROGRAMS"
#define USER_START_MENU                 L"USER_START_MENU"
#define USER_STARTUP                    L"USER_STARTUP"
#define USER_PROGRAMS                   L"USER_PROGRAMS"
#define MY_DOCUMENTS                    L"MY_DOCUMENTS"
#define TEMPLATES                       L"TEMPLATES"
#define APP_DATA                        L"APP_DATA"


// Option Block. 
// Scan Options will populate
// this struct.

typedef struct 
{
	WCHAR stripChar;	        // Character to strip.
	int stripNthChar;		// Strip nth occurrence from the right.
	int stripPath;			// Strip path.
        int getPaths;                   // Get the common paths
} OptionBlock;


//
//  Strip quotes from argument if they exist, convert to unicode, and expand 
//  environment variables.
//

int ParseArg(CHAR *inarg, WCHAR *outarg)
{
   WCHAR T[MAXLEN+1], wcin[MAXLEN+1];
   int retval;

   // Convert to Ansi
   OEM2ANSIA(inarg, (USHORT)strlen(inarg));
   wsprintf(wcin, L"%S", inarg);

   if (wcin[0] == L'"')
      {
      wcscpy(T, &wcin[1]);
      if (T[wcslen(T)-1] == L'"')
         T[wcslen(T)-1] = UNICODE_NULL;
      else
         return(-1);  // Mismatched quotes
      }
   else
      wcscpy(T, wcin);

   retval = ExpandEnvironmentStrings(T, outarg, MAXLEN);
   if ((retval == 0) || (retval > MAXLEN))
      return(-1);
   
   return(retval);
}

//
// See comment above OPTION_STRIP_CHAR definition.
//

void StripChar(WCHAR *s, WCHAR c, int num)
{
    if(s)
    {
       WCHAR *p = s + wcslen(s) + 1;

       while ((num != 0) && (p != s))
       {
          p--;
          if (*p == c)
             num--;
       }

       *p = 0;
    }
}

// 
// Strips the path from the
// specified string.
//
void StripPath(WCHAR *s)
{

   WCHAR *p = wcsrchr(s, L'\\');

   if (p != 0)
      wcscpy(s, p+1);

}

//
// Populates option block.
//
int ScanOptions(WCHAR *optionString, OptionBlock* options)
{
	WCHAR *curOption;
	WCHAR temp[MAXLEN+1];

	// Clear out option block.
	memset(options, 0, sizeof(OptionBlock));

	// Trivial Reject.
	if (*optionString == 0)
		return 0;


	// Uppercase a copy of the option string.
	wcscpy(temp, optionString);
	_wcsupr(temp);

	// Look for strip char option.
	curOption = wcsstr(temp, OPTION_STRIP_CHAR);

	if (curOption != 0)
	{
		// Change current option so it points into the original
		// option, not the uppercased copy.
		
		curOption = (WCHAR*)((INT_PTR)optionString + ((INT_PTR)curOption  - (INT_PTR)temp));


		// Get parameters after strip specifier.
		// If there are not any then error.
		curOption += (sizeof(OPTION_STRIP_CHAR)/sizeof(WCHAR)) - 1;
		if (*curOption == UNICODE_NULL || *curOption == L' ')
			return 1;

		// Get the character to strip.
		options->stripChar = *curOption++;

		// Get the number of occurrrences.
		// If not specified then assume 1.
		if (*curOption == UNICODE_NULL || *curOption == L' ')
			options->stripNthChar = 1;
		else
			options->stripNthChar = _wtoi(curOption);
	}


	// Look for leaf option.
	curOption = wcsstr(temp, OPTION_STRIP_PATH);
	if (curOption != UNICODE_NULL)
		options->stripPath = 1;


	// Look get paths option
	curOption = wcsstr(temp, OPTION_GET_PATHS);
	if (curOption != UNICODE_NULL)
		options->getPaths = 1;

	return 0;

}

// 
// Outputs the common directories into the temp file
// Input: file (input) pointer to open handle for the batch file
// Returns: 0 - success
//          1 - failure
//
int GetPaths(FILE *file)
{
   WCHAR szPath[MAX_PATH+1];

   if(  !GetWindowsDirectory(szPath, MAX_PATH) ){
       return (1);
   }

   if (SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", COMMON_START_MENU, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_COMMON_STARTUP, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", COMMON_STARTUP, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", COMMON_PROGRAMS, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_STARTMENU, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", USER_START_MENU, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_STARTUP, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", USER_STARTUP, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", USER_PROGRAMS, szPath);
   } else {
      return(1);
   }

   // MY_DOCUMENTS should only be the last component of the path
   if (SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, szPath) == S_OK) {
      StripPath(szPath);
      fwprintf(file, L"SET %s=%s\n", MY_DOCUMENTS, szPath);
   } else {
      return(1);
   }

   // TEMPLATES should only be the last component of the path
   if (SHGetFolderPath(NULL, CSIDL_TEMPLATES, NULL, 0, szPath) == S_OK) {
      StripPath(szPath);
      fwprintf(file, L"SET %s=%s\n", TEMPLATES, szPath);
   } else {
      return(1);
   }

   // APP_DATA should only be the last component of the path
   if (SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szPath) == S_OK) {
      StripPath(szPath);
      fwprintf(file, L"SET %s=%s\n", APP_DATA, szPath);
   } else {
      return(1);
   }

   return(0);
}


int __cdecl main(INT argc, CHAR **argv)
{
   FILE *OutFP;
   WCHAR OutFN[MAXLEN+1];
   WCHAR EVName[MAXLEN+1];
   WCHAR KeyName[MAXLEN+1];
   WCHAR ValName[MAXLEN+1];
   WCHAR Temp[MAXLEN+1];
   WCHAR Opts[MAXLEN+1];
   struct HKEY__ *Hive;
   DWORD RetType, RetSize;
   HKEY TargetKey;
   LONG Ret;
	OptionBlock options;
   int  rc=0;

   //
   //  Process the command line arguments.  We expect:
   //
   //    acregl FileName EnvVarName KeyName ValueName Options
   //
   //  The program uses exit code 0 to indicate success or
   //  exit code 1 for failure.
   //

   if (argc != 6)
      return(1);

   setlocale(LC_ALL, ".OCP");

   if (ParseArg(argv[1], OutFN) <= 0)
      return(1);
   
   if (ParseArg(argv[2], EVName) <= 0)
      return(1);
   
   if (ParseArg(argv[3], Temp) <= 0)
      return(1);
   
   if (_wcsnicmp(L"HKLM\\", Temp, 5) == 0)
      Hive = HKEY_LOCAL_MACHINE;
   else if (_wcsnicmp(L"HKCU\\", Temp, 5) == 0)
      Hive = HKEY_CURRENT_USER;
   else
      return(1);
   wcscpy(KeyName,&Temp[5]);

   if (ParseArg(argv[4], ValName) < 0)  // Ok if 0 is returned
      return(1);
   
   if (ParseArg(argv[5], Opts) <= 0)
      return(1);

   if (ScanOptions(Opts, &options) != 0)
      return 1;

   // wprintf(L"OutFN   <%ws>\n",OutFN);
   // wprintf(L"EVName  <%ws>\n",EVName);
   // wprintf(L"KeyName <%ws>, Hive 0x%x\n",KeyName, Hive);
   // wprintf(L"ValName <%ws>\n",ValName);
   // wprintf(L"Opts    <%ws>\n",Opts);


   // If the GETPATHS option isn't specified, open the reg keys
   if (options.getPaths == 0) {

      //
      // Read the specified key and value from the registry.  The ANSI
      // registry functions are used because the command line arguments
      // are in ANSI and when we write the data out it also needs to be
      // in ANSI.
      //
   
      Ret = RegOpenKeyEx(Hive, KeyName, 0, KEY_READ, &TargetKey);
      if (Ret != ERROR_SUCCESS)
         return(1);
   
      RetSize = MAXLEN;
      Ret = RegQueryValueEx(TargetKey, ValName, 0, &RetType, (LPBYTE) &Temp, 
                            &RetSize);
      if (Ret != ERROR_SUCCESS)
         return(1);
      
      //Now we need to procedd DWORDs too
      if(RetType == REG_DWORD)
      {
          DWORD dwTmp = (DWORD)(*Temp);
          _itow((int)dwTmp,Temp,10);
      }
      RegCloseKey(TargetKey);
   }

   //
   //  Process Options
   // 

   //
   //  Write a SET statement to the specified file.  The file can be
   //  executed from a script which will set the indicated environment
   //  variable.  This is a round-about method, but there appears to be
   //  no easy method for setting environment variables in the parent's
   //  environment.
   //

   // wprintf(L"SET %s=%s\n",EVName,Temp);
   
   OutFP = _wfopen(OutFN, L"w");
   if (OutFP == NULL)
      return(1);

   if (options.stripNthChar != 0)
      StripChar(Temp, options.stripChar, options.stripNthChar);

   if (options.stripPath != 0)
      StripPath(Temp);

   if (options.getPaths != 0) {
      if (GetPaths(OutFP)) {
         rc = 1;
      }
   } else {
      fwprintf(OutFP, L"SET %s=%s\n", EVName, Temp);
   }

   fclose(OutFP);

   return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\acregl\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <shlobj.h>
#include <winsta.h>
#include <locale.h>
#include <utilsub.h>
#include <printfoa.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\tools\stubgen\stubgen.c ===
#include "windows.h"
#include "windowsx.h"
#include "shlwapi.h"
#include "commctrl.h"
#include "comctrlp.h"
#include <stdlib.h>
#include <stdio.h>

#define VERSION TEXT("0.00")
#define SIZEOF(x) sizeof(x)
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

typedef struct
{
    WORD wOrdinal;
    LPTSTR pFunction;
} EXPORTENTRY, * LPEXPORTENTRY;


//
// read a line, skipping leading and trailing white space and placing the output
// into the specified buffer.
//

LPTSTR _ReadLine(LPTSTR pSource, LPTSTR pBuffer, INT cchBuffer)
{
    //
    // skip leading white space
    //
    
    *pBuffer = TEXT('\0');

    while ( (*pSource == TEXT(' ')) ||
               (*pSource == TEXT('\t')) )
    {
        pSource++;
    }

    if ( !*pSource )
        return NULL;

    while ( (*pSource != TEXT('\r')) && 
              (*pSource != TEXT('\n')) && 
                (*pSource != TEXT('\0')) && 
                  (cchBuffer >= 1) )
    {   
        *pBuffer++ = *pSource++;
        cchBuffer--;
    }

    *pBuffer++ = TEXT('\0');

    while ( (*pSource == TEXT('\r')) ||
              (*pSource == TEXT('\n')) )
    {
        pSource++;
    }

    return pSource;
}


//
// Get string element, given an index into the buffer copy out the element
// that we want.
//

BOOL _GetStringElement(LPTSTR pString, INT index, BOOL fEntireLine, LPTSTR pBuffer, INT cchBuffer)
{
    for ( ; *pString && (index > 0) ; index-- )
    {
        while ( *pString != TEXT(',') && *pString != TEXT('\0') )
            pString++;

        if ( *pString == TEXT(',') )
            pString++;
    }

    if ( index )
        return FALSE;        

    while ( *pString == TEXT(' ') )
        pString++;

    while ( *pString && (cchBuffer > 1) )
    {
        if ( !fEntireLine && (*pString == TEXT(',')) )
            break;
            
        *pBuffer++ = *pString++;
        cchBuffer--;
    }

    *pBuffer = TEXT('\0');

    return TRUE;
}


//
// Get a stub function name given its module and function name.
//

static TCHAR szStubFunction[MAX_PATH];

LPTSTR _GetStubFunction(LPTSTR pModule, LPTSTR pFunction)
{
    wnsprintf(szStubFunction, ARRAYSIZE(szStubFunction), TEXT("_%s_%s"), pModule, pFunction);
    return szStubFunction;
}


//
// Generate stub
//
// This takes a line from the file and get the information we need from it.
//

BOOL _GenerateStub(LPTSTR pModule, LPTSTR pBuffer, HDPA hdpaFunctions, HDPA hdpaOrdinals)
{
    TCHAR szResultType[MAX_PATH];
    TCHAR szResult[MAX_PATH];
    TCHAR szFunction[MAX_PATH];
    TCHAR szArguments[MAX_PATH*2];
    LPTSTR pFunction;
    LPTSTR pOrdinal;
    INT iByName, iByOrdinal;
    LPEXPORTENTRY pExport;

    // get the fields, all are required

    if ( !_GetStringElement(pBuffer, 0, FALSE, szResultType, ARRAYSIZE(szResultType)) )
        return FALSE;

    if ( !_GetStringElement(pBuffer, 1, FALSE, szResult, ARRAYSIZE(szResult)) )
        return FALSE;

    if ( !_GetStringElement(pBuffer, 2, FALSE, szFunction, ARRAYSIZE(szFunction)) )
        return FALSE;

    if ( !_GetStringElement(pBuffer, 3, TRUE, szArguments, ARRAYSIZE(szArguments)) )
        return FALSE;

    // if the function name is bla@4 then it has an ordinal therefore we must attempt
    // to get the ordinal number.

    pOrdinal = StrChr(szFunction, TEXT('@'));
    if ( pOrdinal )
        *pOrdinal++ = TEXT('\0');

    // allocate an export, adding both the ordinals and the functions as required.
    // if pOrdinal != NULL then we assume that we should parse the int.

    pExport = LocalAlloc(LPTR, SIZEOF(EXPORTENTRY));
    if ( !pExport )
        return FALSE;    

    Str_SetPtr(&pFunction, szFunction);
    if ( !pFunction )
    {
        LocalFree(pExport);
        return FALSE;
    }

    pExport->wOrdinal = (WORD) StrToInt(pOrdinal ? pOrdinal:TEXT(""));
    pExport->pFunction = pFunction;

    iByOrdinal = iByName = DPA_AppendPtr(hdpaFunctions, pExport);
    
    if ( pOrdinal )
        iByOrdinal = DPA_AppendPtr(hdpaOrdinals, pExport);

    if ( (iByName == -1) || (iByOrdinal == -1) )
    {
        if ( iByName != -1 )
            DPA_DeletePtr(hdpaFunctions, iByName);

        LocalFree(pExport);
        Str_SetPtr(&pFunction, NULL);
        return FALSE;
    }

    // spew out the function name

    printf(TEXT("\n"));
    printf(TEXT("%s %s%s\n"), szResultType, _GetStubFunction(pModule, pFunction), szArguments);
    printf(TEXT("{\n"));

    if ( szResult[0] )
        printf(TEXT("   return %s;\n"), szResult);

    printf(TEXT("}\n"));
    
    return TRUE;
}


//
// "stubgen <stub list> <module>"
//
// The stub list is a text file that lists all the exports you want to generate
// stubs for, each stub is a simple function which returns a specified result.
//
// The format of the file is:
//
//    <result type>,<result>,<function>,<arguments>
//
// eg:
//
//    BOOL, FALSE, SHBrowseForContainer, (bla, bla, bla)
//
// Which generates a stub:
//
//    BOOL SHBrowseForContainer(bla, bla, bla)
//    {
//      return FALSE;
//    }
//

INT _SortNameCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    LPEXPORTENTRY pExport1 = (LPEXPORTENTRY)p1;
    LPEXPORTENTRY pExport2 = (LPEXPORTENTRY)p2;
    return StrCmpI(pExport1->pFunction, pExport2->pFunction);
}

INT _SortOrdinalCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    LPEXPORTENTRY pExport1 = (LPEXPORTENTRY)p1;
    LPEXPORTENTRY pExport2 = (LPEXPORTENTRY)p2;
    return pExport1->wOrdinal - pExport2->wOrdinal;
}

INT __cdecl main(INT cArgs, LPTSTR pArgs[])
{
    TCHAR szSource[MAX_PATH];
    TCHAR szModule[MAX_PATH];
    HANDLE hFile;
    LPTSTR pStubFile;
    DWORD dwSize, dwRead;
    HDPA hdpaFunctions;
    HDPA hdpaOrdinals;
    INT i;

    if ( cArgs < 2 )
    {
        printf(TEXT("stubgen: <src> <module>\n"));
        return -1;
    }

    StrCpy(szSource, pArgs[1]);
    StrCpy(szModule, pArgs[2]);


    //
    // load the source file into memory and then lets generate the stub table,
    // add a TCHAR to the file size to get it null terminated
    //

    hFile = CreateFile(szSource,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL, 
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
        return -1;

    dwSize = GetFileSize(hFile, NULL);
    pStubFile = LocalAlloc(LPTR, dwSize+SIZEOF(TCHAR));

    if ( !pStubFile ||
           !ReadFile(hFile, pStubFile, dwSize, &dwRead, NULL) ||
             dwRead != dwSize )
    {
        CloseHandle(hFile);
        return -1;
    }

    CloseHandle(hFile);    


    //
    // Create the DPA we will use for storing the function names
    //

    hdpaFunctions = DPA_Create(16);
    hdpaOrdinals = DPA_Create(16);

    if ( !hdpaFunctions || ! hdpaOrdinals )
        return -1;


    //
    // output header information
    // 

    for ( i = 3 ; i < cArgs ; i++ )
        printf(TEXT("#include \"%s\"\n"), pArgs[i]);

    printf(TEXT("#pragma hdrstop\n"));

    printf(TEXT("\n"));
    printf(TEXT("// Generate from %s by stubgen.exe\n"), szSource);
    printf(TEXT("// *** DO NOT EDIT THIS FILE ***\n\n"));


    //
    // now lets parse the file, trying to the function prototypes from it,
    // we skip all lines that start with a ';', '#' or '/' (as in //)
    //      

    while ( pStubFile )
    {
        TCHAR szBuffer[1024];

        pStubFile = _ReadLine(pStubFile, szBuffer, ARRAYSIZE(szBuffer));
        
        if ( pStubFile )
        {
            switch ( szBuffer[0] )
            {
                case TEXT('#'):
                case TEXT(';'):
                case TEXT('/'):
                    // comments are stripped
                    break;

                default:
                    _GenerateStub(szModule, szBuffer, hdpaFunctions, hdpaOrdinals);
                    break;
            }
        }
    }   

    
    //
    // if hdpaFunctions contains anything then we have generated a set of
    // stubs, so lets sort it and output that.
    //

    if ( DPA_GetPtrCount(hdpaFunctions) )
    {
        DPA_Sort(hdpaFunctions, _SortNameCB, 0);

        printf(TEXT("\n"));
        printf(TEXT("const INT g_c%sExportTable = %d;\n"), szModule, DPA_GetPtrCount(hdpaFunctions));
        printf(TEXT("const EXPORTTABLE g_%sExportTable[] =\n"), szModule);
        printf(TEXT("{\n"));

        for ( i = 0 ; i < DPA_GetPtrCount(hdpaFunctions); i++ )
        {
            LPEXPORTENTRY pExport = (LPEXPORTENTRY)DPA_GetPtr(hdpaFunctions, i);
            TCHAR szBuffer[MAX_PATH];

            StrCpy(szBuffer, pExport->pFunction);
#if UNICODE
            _wcslwr(szBuffer);
#else
            _strlwr(szBuffer);
#endif

            printf(TEXT("    \"%s\", (FARPROC)%s,\n"), szBuffer, _GetStubFunction(szModule, pExport->pFunction));
        }

        printf(TEXT("};\n"));
    }

    if ( DPA_GetPtrCount(hdpaOrdinals) )
    {
        DPA_Sort(hdpaFunctions, _SortOrdinalCB, 0);

        printf(TEXT("\n"));
        printf(TEXT("const INT g_c%sOrdinalTable = %d;\n"), szModule, DPA_GetPtrCount(hdpaOrdinals));
        printf(TEXT("const ORDINALTABLE g_%sOrdinalTable[] =\n"), szModule);
        printf(TEXT("{\n"));

        for ( i = 0 ; i < DPA_GetPtrCount(hdpaOrdinals); i++ )
        {
            LPEXPORTENTRY pExport = (LPEXPORTENTRY)DPA_GetPtr(hdpaOrdinals, i);
            printf(TEXT("    %d, (FARPROC)%s,\n"), pExport->wOrdinal, _GetStubFunction(szModule, pExport->pFunction));
        }

        printf(TEXT("};\n"));

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_INF             =obj\$(TARGET_DIRECTORY)
_ROOT            =..
_INSTALL         =$(_ROOT)\install
_INSTALL_TEMPLATE=$(_ROOT)\install\template
_LOGON           =$(_ROOT)\logon
_LOGON_TEMPLATE  =$(_ROOT)\logon\template
_UNINST          =$(_ROOT)\uninst


.SUFFIXES: .cmd .key

make_root:
    binplace -R $(_NTTREE) $(_ROOT)\CHKROOT.CMD
    binplace -R $(_NTTREE) $(_ROOT)\SETPATHS.CMD
    binplace -R $(_NTTREE) $(_ROOT)\END.CMD
    binplace -R $(_NTTREE) $(_ROOT)\ROOTDRV.CMD
    binplace -R $(_NTTREE) $(_ROOT)\USRLOGON.CMD
    binplace -R $(_NTTREE) $(_ROOT)\NOTSSID.INF


make_install:
    binplace -R $(_NTTREE) $(_INSTALL)\COFFICE8.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\COFC8INS.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\NETCOM40.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\OFFICE43.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\OFFICE43.KEY
    binplace -R $(_NTTREE) $(_INSTALL)\OFC43INS.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\OUTLK98.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\MSWORD97.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\MSEXCL97.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\SSUITE9.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\VISIO5.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\PWRBLDR6.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\EUDORA4.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\LNOTE4U.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\SSUITE95.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\FPAGE98.CMD

make_install_template:
    binplace -R $(_NTTREE) $(_INSTALL_TEMPLATE)\MSPROJ98.KEY
    binplace -R $(_NTTREE) $(_INSTALL_TEMPLATE)\COFFICE8.KEY
    binplace -R $(_NTTREE) $(_INSTALL_TEMPLATE)\PWRBLDR6.key
    binplace -R $(_NTTREE) $(_INSTALL_TEMPLATE)\EUDORA4.key


make_logon:
    binplace -R $(_NTTREE) $(_LOGON)\TSMKUDIR.CMD
    binplace -R $(_NTTREE) $(_LOGON)\TSMKUFIL.CMD
    binplace -R $(_NTTREE) $(_LOGON)\SS9USR.CMD
    binplace -R $(_NTTREE) $(_LOGON)\SS95USR.CMD
    binplace -R $(_NTTREE) $(_LOGON)\EUD4USR.CMD


make_logon_template:
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\OFC43USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\OFC43USR.KEY
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\WRD97USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\EXL97USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\COFC8USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\COM40USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\OLK98USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\PBLD6USR.CMD

make_uninst:
    binplace -R $(_NTTREE) $(_UNINST)\UCOFF8.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UExcl97.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UWord97.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UCom40.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UOFF43.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UOff97.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UProj98.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UOUTLK98.CMD
    binplace -R $(_NTTREE) $(_UNINST)\USS9.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UMSVS6.CMD
    binplace -R $(_NTTREE) $(_UNINST)\USS95.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UPBLD6.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UFPG98.CMD

make_install_pp: $(_INF)\MSPROJ98.CMD    \
                 $(_INF)\OFFICE97.CMD    \
                 $(_INF)\MSVS6.CMD       \
                 $(_INF)\LNOTE4U.KEY			

make_install_template_pp: $(_INF)\OFFICE97.KEY \
                          $(_INF)\MSVS6.KEY \
                          $(_INF)\OUTLK98.KEY \
                          $(_INF)\MSWORD97.KEY \
                          $(_INF)\MSEXCL97.KEY

make_logon_pp:


make_logon_template_pp: $(_INF)\OFC97USR.CMD    \
                        $(_INF)\PRJ98USR.CMD


make_appcmpt:  make_root                \
               make_install             \
               make_install_pp          \
               make_install_template    \
               make_install_template_pp \
               make_logon               \
               make_logon_pp            \
               make_logon_template      \
               make_logon_template_pp   \
               make_uninst


make_appcmpt_pp:  make_install_pp           \
                  make_install_template_pp  \
                  make_logon_pp             \
                  make_logon_template_pp


clean: make_appcmpt



{$(_INSTALL)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_INSTALL)\}.key{$(_INF)}.key:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_INSTALL_TEMPLATE)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_INSTALL_TEMPLATE)\}.key{$(_INF)}.key:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_LOGON)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_LOGON_TEMPLATE)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\acsr\acsr.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  ACSR.C
*
*  Application Compatibility Search and Replace Helper Program
*
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MAXLEN 512

char Temp[MAXLEN+1];
char Temp1[MAXLEN+1];
char Srch[MAXLEN+1];
char Repl[2*MAXLEN+2];
char *InFN;
char *OutFN;

//*------------------------------------------------------------*//
//* Local function prototypes                                  *//
//*------------------------------------------------------------*//
BOOL ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode );
void ReadLnkCommandFile(HANDLE hFile);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl main(INT argc, CHAR **argv)
{
   DWORD retval;
   int CurArg = 1;
   FILE *InFP;
   FILE *OutFP;
   int SrchLen, ReplLen;
   char *ptr, *Loc;
   HANDLE hFile;
   DWORD dwMaxLen = MAXLEN;
   DWORD dwLen;
   char* pTemp = Temp;
   BOOL fAlloc = FALSE;

   if (argc != 5)
      return(1);

    //
    //331012 Unbounded strcpy in termsrv\appcmpt\acsr\acsr.c
    //check for argv[] length and alloc if needed
    //
   dwLen = strlen(argv[CurArg]);
   if (dwLen > dwMaxLen) {
        dwMaxLen = dwLen;
        pTemp = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwMaxLen+1)*sizeof(char) );
        
        if (NULL == pTemp)
            return(1);
        fAlloc = TRUE;
   }
        
   if (argv[CurArg][0] == '"')
      {
      strcpy(pTemp, &argv[CurArg][1]);
      if (pTemp[strlen(pTemp)-1] == '"')
         pTemp[strlen(pTemp)-1] = 0;
      else
         return(1);
      }
   else
      strcpy(pTemp, argv[CurArg]);

   retval = ExpandEnvironmentStringsA(pTemp, Srch, dwMaxLen);
   if ((retval == 0) || (retval > dwMaxLen))
      return(1);
   
   SrchLen = strlen(Srch);
   if (SrchLen < 1)
      return(1);

   CurArg++;
    
    //
    //331012 Unbounded strcpy in termsrv\appcmpt\acsr\acsr.c
    //check for argv[] length and realloc if needed
    //
   dwLen = strlen(argv[CurArg]);
   
   if (dwLen > dwMaxLen) {
        
        dwMaxLen = dwLen;
        //
        //check if we allocated for pTemp above, if so, free it first
        //
        if (fAlloc) {
            HeapFree(GetProcessHeap(), 0, pTemp);
        }
        
        pTemp = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwMaxLen+1)*sizeof(char) );
        
        if (NULL == pTemp)
            return(1);
        fAlloc = TRUE;
   }

   if (argv[CurArg][0] == '"')
      {
      strcpy(pTemp, &argv[CurArg][1]);
      if (pTemp[strlen(pTemp)-1] == '"')
         pTemp[strlen(pTemp)-1] = 0;
      else
         return(1);
      }
   else
      strcpy(pTemp, argv[CurArg]);

   retval = ExpandEnvironmentStringsA(pTemp, Repl, dwMaxLen);
   if ((retval == 0) || (retval > dwMaxLen))
      return(1);
   
   ReplLen = strlen(Repl);
   if (ReplLen < 1)
      return(1);


   CurArg++;
   InFN = argv[CurArg];
   CurArg++;
   OutFN = argv[CurArg];
#ifdef ACSR_DEBUG
   printf("Srch  <%s>\n",Srch);
   printf("Repl  <%s>\n",Repl);
   printf("InFN  <%s>\n",InFN);
   printf("OutFN <%s>\n",OutFN);
#endif

   if (strstr(Repl,".lnk") || strstr(Repl, ".LNK")) {
      hFile = CreateFileA( Repl,
			  GENERIC_READ,
			  FILE_SHARE_READ,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL
			  );
      if (hFile != INVALID_HANDLE_VALUE) {
         ReadLnkCommandFile(hFile);
#ifdef ACSR_DEBUG
         printf("This is a .lnk file. Substitue with the real cmd %s\n", Repl);
#endif

      }

   }


   InFP = fopen(InFN, "r");
   if (InFP == NULL)
      return(1);

   OutFP = fopen(OutFN, "w");
   if (OutFP == NULL)
   {
       fclose(InFP);
       return(1);
   }

   while (1)
      {
      if (fgets(pTemp, MAXLEN, InFP) == NULL)
         break;

      ptr = pTemp;
      Temp1[0] = 0;  // Empty String

      while (1)
         {
         Loc = strstr(ptr, Srch);
         if (Loc == NULL)  // Search Term Not Found
            break;
         
         // Append part of string before search term
         Loc[0] = 0;
         if (strlen(Temp1) + strlen(ptr) < MAXLEN)
            strcat(Temp1, ptr);
         
         // Append Replacement term
         if (strlen(Temp1) + ReplLen < MAXLEN)
            strcat(Temp1, Repl);
         
         // Point to location past search term
         ptr = Loc + SrchLen;
         }
      
      // Append remainder of string
      strcat(Temp1, ptr);

      fputs(Temp1, OutFP);
      }

   fclose(InFP);
   fclose(OutFP);
   if (fAlloc) {
        HeapFree(GetProcessHeap(), 0, pTemp);
   }
   return(0);
}

//*-------------------------------------------------------------*//
//* ReadLinkCommandFile                                         *//
//*    This routine is to read a .lnk file and put the linked   *//
//*    file name and args to the Repl[] global variable         *//
//*    The logic to read the .lnk file is copied from           *//
//*    lnkdump.exe utility private\windows\shell\tools\lnkdump  *//
//* ------------------------------------------------------------*//

void  ReadLnkCommandFile(HANDLE hFile  //.lnk file handle
                         )
{
    CShellLink   csl;
    CShellLink * this = &csl;
    DWORD cbSize, cbTotal, cbToRead, dwBytesRead;
    SYSTEMTIME  st;
    LPSTR pTemp = NULL;
    CHAR szPath[ MAXLEN + 1];
    CHAR szArgs[ MAXLEN + 1];

    this->pidl = 0;
    this->pli = NULL;
    memset( this, 0, sizeof(CShellLink) );

    szPath[0] = 0;
    szArgs[0] = 0;

    // Now, read out data...

    if(!ReadFile( hFile, (LPVOID)&this->sld, sizeof(this->sld), &dwBytesRead, NULL )) {
        return;
    }


    // read all of the members

    if (this->sld.dwFlags & SLDF_HAS_ID_LIST) {
        // Read the size of the IDLIST
        cbSize = 0; // need to zero out to get HIWORD 0 'cause USHORT is only 2 bytes
        if(!ReadFile( hFile, (LPVOID)&cbSize, sizeof(USHORT), &dwBytesRead, NULL )) {
            return;
        }

        if (cbSize) {
            SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT);
        } else {
#ifdef ACSR_DEBUG
            printf( "Error readling PIDL out of link!\n" );
#endif
        }
    }


    if (this->sld.dwFlags & (SLDF_HAS_LINK_INFO)) {
        LPVOID pli;

        if(!ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL )) {
            return;
        }

        if (cbSize >= sizeof(cbSize)) {
            cbSize -= sizeof(cbSize);
            SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT);
        }

    }

    if (this->sld.dwFlags & SLDF_HAS_NAME) {
        if(!ReadString( hFile, &this->pszName, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }


    if (this->sld.dwFlags & SLDF_HAS_RELPATH) {
        if(!ReadString( hFile, &this->pszRelPath, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }


    if (this->sld.dwFlags & SLDF_HAS_WORKINGDIR) {
        if(!ReadString( hFile, &this->pszWorkingDir, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }

    if (this->sld.dwFlags & SLDF_HAS_ARGS) {
        if(!ReadString( hFile, &this->pszArgs, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }


    if (this->pszRelPath) {
        if (this->sld.dwFlags & SLDF_UNICODE) {


            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszRelPath,
                                 -1,
                                 szPath,
                                 256,
                                 NULL,
                                 NULL
                               );

        } else {
            strcpy(szPath, (LPSTR)this->pszRelPath);
        }
    }


    if (this->pszArgs) {
        if (this->sld.dwFlags & SLDF_UNICODE) {

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszArgs,
                                 -1,
                                 szArgs,
                                 256,
                                 NULL,
                                 NULL
                               );

        } else {
            strcpy(szArgs, (LPSTR)this->pszArgs);
        }
    }

    // Construct the command
    if(szPath) {

        strcpy(Repl, szPath);
        strcat(Repl, " ");
        strcat(Repl, szArgs);
    }

cleanup:
    if (this->pidl)
        LocalFree( (HLOCAL)this->pidl );

    if (this->pli)
        LocalFree( this->pli );

    if (this->pszName)
        HeapFree( GetProcessHeap(), 0, this->pszName );
    if (this->pszRelPath)
        HeapFree( GetProcessHeap(), 0, this->pszRelPath );
    if (this->pszWorkingDir)
        HeapFree( GetProcessHeap(), 0, this->pszWorkingDir );
    if (this->pszArgs)
        HeapFree( GetProcessHeap(), 0, this->pszArgs );
    if (this->pszIconLocation)
        HeapFree( GetProcessHeap(), 0, this->pszIconLocation );

}
//*------------------------------------------------------------*//
//* This routine is copied from lnkdump.exe utility            *//
//* (private\windows\shell\tools\lnkdump\lnkdump.c)            *//
//* It reads a string from an opened .lnk file                 *//
//* -----------------------------------------------------------*//

BOOL ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode )
{

    USHORT cch;
    DWORD  dwBytesRead;
    
    *lpVoid = NULL;

    if(!ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL )) {
        return FALSE;
    }

    if (bUnicode)
    {
        LPWSTR lpWStr = NULL;
        
        lpWStr = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (cch+1)*sizeof(WCHAR) );
        if (lpWStr) {
            if(!ReadFile( hFile, (LPVOID)lpWStr, cch*sizeof(WCHAR), &dwBytesRead, NULL )) {
                HeapFree( GetProcessHeap(), 0, lpWStr );
                return FALSE;
            }
            lpWStr[cch] = L'\0';
        }
        *(PDWORD_PTR)lpVoid = (DWORD_PTR)lpWStr;
    }
    else
    {
        LPSTR lpStr = NULL;
        
        lpStr = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (cch+1) );
        if (lpStr) {
            if(!ReadFile( hFile, (LPVOID)lpStr, cch, &dwBytesRead, NULL )) {
                HeapFree( GetProcessHeap(), 0, lpStr );
                return FALSE;
            }
            lpStr[cch] = '\0';
        }
        *(PDWORD_PTR)lpVoid = (DWORD_PTR)lpStr;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appcmpt\acsr\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_HTTP
#define NO_SHLWAPI_INTERNAL
#include <shlwapip.h>

#define FE_SB 1

#include <shlobjp.h>

#ifndef PLINKINFO
#define PLINKINFO LPVOID
#endif

#define EXP_SZ_LINK_SIG         0xA0000001
//#define NT_CONSOLE_PROPS_SIG    0xA0000002 // moved to shlobj.w
#define EXP_TRACKER_SIG         0xA0000003
//#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004 // moved to shlobj.w
#define EXP_DARWIN_ID_SIG       0xA0000006

#define EXP_HEADER DATABLOCK_HEADER
#define LPEXP_HEADER LPDATABLOCK_HEADER

// most expansion data structures go here
// those shared with other components (NT40 Console stuff)
// are in shlobj.w (private)
//

typedef struct {
    IShellLink          sl;
    IPersistStream      ps;
    IPersistFile        pf;
    IShellExtInit       si;
    IContextMenu2       cm;
    IDropTarget         dt;
#ifdef USE_DATA_OBJ
    IDataObj            dobj;
#endif
////IExtractIcon        xi;
#ifdef UNICODE
    IShellLinkA         slA;            // To support ANSI callers
#endif
#ifdef ENABLE_TRACK
    IShellLinkTracker   slt;        // Interface to CTracker object.
#endif
#ifdef WINNT
    IShellLinkDataList  sldl;
#endif

    UINT                cRef;

    BOOL                bDirty;         // something has changed
    LPTSTR              pszCurFile;     // current file from IPersistFile
    LPTSTR              pszRelSource;   // overrides pszCurFile in relative tracking

    IContextMenu        *pcmTarget;     // stuff for IContextMenu
    UINT                indexMenuSave;
    UINT                idCmdFirstSave;
    UINT                idCmdLastSave;
    UINT                uFlagsSave;

    BOOL                fDataAlreadyResolved;   // for data object

    // IDropTarget specific
    IDropTarget*        pdtSrc;         // IDropTarget of link source (unresolved)
    DWORD               grfKeyStateLast;

    // persistant data

    LPITEMIDLIST        pidl;           // may be NULL
    PLINKINFO           pli;            // may be NULL

    LPTSTR              pszName;        // title on short volumes
    LPTSTR              pszRelPath;
    LPTSTR              pszWorkingDir;
    LPTSTR              pszArgs;
    LPTSTR              pszIconLocation;

    LPDBLIST            pExtraData;     // extra data to preserve for future compatibility

#ifdef ENABLE_TRACK
    struct CTracker *   ptracker;
#endif

    SHELL_LINK_DATA     sld;
} CShellLink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\adddlg.cpp ===
#include "pch.h"
#include "AppSec.h"
#include "AddDlg.h"
#include "ListCtrl.h"
#include "resource.h"

extern HINSTANCE hInst;
extern HWND   g_hwndList;
extern LPWSTR g_aszLogonApps[];
extern LPWSTR g_aszDOSWinApps[];
extern WCHAR   g_szSystemRoot[MAX_PATH];
extern const int MAX_LOGON_APPS;
extern const int MAX_DOSWIN_APPS;
/*
 * Extern function prototypes.
 */
BOOL fnGetApplication( HWND hWnd, PWCHAR pszFile, ULONG cbFile, PWCHAR pszTitle );
BOOL bFileIsRemote( LPWSTR pName );
/*
 * Local function prototypes.
 */
BOOL AddApplicationToList( PWCHAR );
BOOL StartLearn(VOID);
BOOL StopLearn(VOID);
BOOL ClearLearnList(VOID);
BOOL display_app_list( HWND ListBoxHandle );
VOID ResolveName( WCHAR *appname, WCHAR *ResolvedName ) ; 

/******************************************************************************
 *
 *  AddDlgProc
 *
 *  Process messages for add button
 *
 *  EXIT:
 *    TRUE - if message was processed
 *
 *  DIALOG EXIT:
 *
 ******************************************************************************/

INT_PTR CALLBACK 
AddDlgProc(
    HWND    hdlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HWND hwndTrackList;
    static HWND hwndTrackButton;
    static BOOL bTracking=FALSE;
    WCHAR  szApp[MAX_PATH+1];
    WCHAR  szMsg[MAX_PATH+1];
    WCHAR  szTitle[MAX_PATH+1];
    WCHAR  szExpandedApp[MAX_PATH+1] ; 

    switch ( message ) {

        case WM_INITDIALOG:
            //  get handle to list box
            hwndTrackButton=GetDlgItem( hdlg, ID_TRACKING );
            if ( (!(hwndTrackList = GetDlgItem( hdlg, IDC_TRACK_LIST )))||
                (!InitList(hwndTrackList))) {
                LoadString( NULL, IDS_ERR_LB ,szMsg, MAX_PATH );
                LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                MessageBox( hdlg, szMsg, szTitle, MB_OK);
                EndDialog( hdlg, IDCANCEL );
                return TRUE;
            }
            return FALSE;

        case WM_HELP:
            {

                LPHELPINFO phi=(LPHELPINFO)lParam;
                if(phi->dwContextId){
                    WinHelp(hdlg,L"APPSEC",HELP_CONTEXT,phi->iCtrlId);
                }else{
                    //WinHelp(hdlg,L"APPSEC",HELP_CONTENTS,0);
                }
            }
            break;

        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pdis=(LPDRAWITEMSTRUCT)lParam;
            if(pdis->hwndItem==hwndTrackList){
                OnDrawItem(hwndTrackList,pdis);
            }
        }
        break;

        case WM_NOTIFY:
        {
            NMHDR* pnmhdr=(NMHDR*)lParam;
            if(pnmhdr->hwndFrom==hwndTrackList){

                NMLISTVIEW* pnmlv=(NMLISTVIEW*)pnmhdr;

                switch(pnmlv->hdr.code){

                case LVN_COLUMNCLICK:
                    SortItems(hwndTrackList,(WORD)pnmlv->iSubItem);
                    break;
                case LVN_DELETEITEM:
                    OnDeleteItem(hwndTrackList,pnmlv->iItem);
                    break;
                default:
                    break;
                }
            }
        }
        break;

        case WM_COMMAND :
            
            switch ( LOWORD(wParam) ) {

                case IDOK :
                    {
                        //Get item from edit box
                        szApp[0] = 0;
                        if ( GetDlgItemText( hdlg, IDC_ADD_PATH, szApp, MAX_PATH ) ) {
                            if ( lstrlen( szApp ) ) {
                                ExpandEnvironmentStrings(  (LPCTSTR) szApp , szExpandedApp , MAX_PATH+1 ); 
                                
                                if ( AddApplicationToList( szExpandedApp ) == FALSE ) {
                                    break;
                                }
                            }
                        }
                        //Get items from track list
                        int iItemCount=GetItemCount(hwndTrackList);
                        for(int i=0;i<iItemCount;i++)
                        {
                            if( GetItemText(hwndTrackList,i,szApp,MAX_PATH)!= -1 ) {
                                if ( lstrlen( szApp ) ) {
                                    ExpandEnvironmentStrings(  (LPCTSTR) szApp , szExpandedApp , MAX_PATH+1) ; 
                                                                        
                                    if ( AddApplicationToList( szExpandedApp ) == FALSE ) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if(bTracking){
                        StopLearn();
                        bTracking=FALSE;
                    }
                    EndDialog( hdlg, IDOK );
                    return TRUE;

                case IDCANCEL :
                    if(bTracking){
                        StopLearn();
                        bTracking=FALSE;
                    }
                    EndDialog( hdlg, IDCANCEL );
                    return TRUE;
        
                case ID_BROWSE :
                    GetDlgItemText( hdlg, IDC_ADD_PATH, szApp, MAX_PATH );
                    LoadString( NULL, IDS_BROWSE_TITLE ,szMsg, MAX_PATH );
                    if ( fnGetApplication( hdlg, szApp, MAX_PATH, szMsg ) == TRUE ) {
                        SetDlgItemText( hdlg, IDC_ADD_PATH, szApp );
                    }
                    return TRUE;
                
                case ID_TRACKING:

                    
                    if(bTracking){

                        
                        //Stop Tracking
                        bTracking=FALSE;
                        LoadString( hInst, IDS_START_TRACKING ,szMsg, MAX_PATH );
                        SetWindowText(hwndTrackButton,szMsg);
                        
                        // set the learn_enable bit to 0
            
                        if ( !StopLearn() )
                        {
                    
                            LoadString( NULL, IDS_ERR_LF, szMsg, MAX_PATH );
                            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                            MessageBox( hdlg, szMsg, szTitle, MB_OK);
                        }

                        //Get catched processes from registry and fill TrackList
                        
                        display_app_list(hwndTrackList);
                        if(GetItemCount(hwndTrackList)){
                            EnableWindow(hwndTrackList,TRUE);
                            AdjustColumns(hwndTrackList);
                        }else{
                            EnableWindow(hwndTrackList,FALSE);
                        }
                        ClearLearnList() ;  
            
                    }else{
                        
                        //Start Tracking
                        bTracking=TRUE;
                        LoadString( hInst, IDS_STOP_TRACKING ,szMsg, MAX_PATH );
                        SetWindowText(hwndTrackButton,szMsg);

                        // set learn_enable bit to 1
                        
                        if ( !StartLearn() )
                        {
                        
                            LoadString( NULL, IDS_ERR_LF, szMsg, MAX_PATH );
                            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                            MessageBox( hdlg, szMsg, szTitle, MB_OK);

                        }

                        ClearLearnList() ; 
                        
                    }
                    return TRUE;

                case ID_DELETE_SELECTED:
                    DeleteSelectedItems(hwndTrackList);
                    if(GetItemCount(hwndTrackList)){
                        EnableWindow(hwndTrackList,TRUE);
                    }else{
                        EnableWindow(hwndTrackList,FALSE);
                    }

                    return TRUE;

                default : 

                    break;
            }

            break;

        default :

            break;
    }

    // We didn't process this message
    return FALSE;
}


/******************************************************************************
 *
 *  AddApplicationToList
 *
 *  Process messages for add app button
 *
 *  EXIT:
 *
 ******************************************************************************/

BOOL
AddApplicationToList( PWCHAR pszApplication )
{
    LONG  i;
    WCHAR  szMsg[MAX_PATH+1];
    WCHAR  szMsgEx[MAX_PATH+32];
    WCHAR  szTitle[MAX_PATH+1];
    WCHAR  ResolvedAppName[MAX_PATH] ; 

    /*
     *  Get app type
     */

    /*
     *  Get volume type
     */

    /*

    if ( bFileIsRemote( pszApplication ) ) {
        LoadString( NULL, IDS_ERR_REMOTE ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_NW_ERR ,szTitle, MAX_PATH );            
        wsprintf( szMsgEx, szMsg, pszApplication );
        MessageBox( NULL, szMsgEx, szTitle, MB_OK );
        return( FALSE );
    }

    */

    ResolveName( 
        pszApplication,
        ResolvedAppName
    ) ;


    /*
     *  Is it part of LOGON or DOS/Win list?
     */
    WCHAR szTmp[MAX_PATH+1];

    for ( i=0; i<MAX_LOGON_APPS; i++ ) {
        wsprintf( szTmp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[i] );
        if ( !lstrcmpi( szTmp, pszApplication ) ) {
            return( TRUE );
        }
    }
    for ( i=0; i<MAX_DOSWIN_APPS; i++ ) {
        wsprintf( szTmp, L"%s\\%s", g_szSystemRoot, g_aszDOSWinApps[i] );
        if ( !lstrcmpi( szTmp, pszApplication ) ) {
            return( TRUE );
        }
    }
    
    /*
     *  Check for redundant string
     */
    if ( FindItem(g_hwndList, ResolvedAppName ) == -1 ) {

        /*
         *  Add this item to list
         */
        AddItemToList(g_hwndList, ResolvedAppName );
    }

    return( TRUE );
}

/*******************************************************************************
 *
 *  bFileIsRemote - NT helper function
 *
 * ENTRY:
 *    pName (input)
 *       path name
 *
 * EXIT:
 *    TRUE  - File is remote
 *    FALSE - File is local
 *
 ******************************************************************************/

BOOL
bFileIsRemote( LPWSTR pName )
{
    WCHAR Buffer[MAX_PATH];

    if ( !GetFullPathName( pName, MAX_PATH, Buffer, NULL ) )
        return FALSE;

    Buffer[3] = 0;

    if ( GetDriveType( Buffer ) == DRIVE_REMOTE )
        return TRUE;
    else
        return FALSE;

}  // end CheckForComDevice


//////////////////////////////////////////////////////////////////////////////////
//Tracking Procedures
//////////////////////////////////////////////////////////////////////////////////

/*++

Routine Description :

    This routine will set the LearnEnabled Flag in registry to 1 to 
    indicate the initiation of tracking mode.
    
Arguments :

    None.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     


BOOL StartLearn(VOID)
{

    
    HKEY TSkey ; 
    DWORD learn_enabled = 1 ; 
    DWORD size, disp ; 
    DWORD error_code ; 
    DWORD CurrentSessionId ; 


    if ( RegCreateKeyEx(
            HKEY_CURRENT_USER,
            LIST_REG_KEY, 
            0, 
            NULL,
            REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 
            NULL, 
            &TSkey, 
            &disp
            ) != ERROR_SUCCESS) {
        
        return FALSE;
        
    }
    
    // Get CurrentSessionId
    
    if ( ProcessIdToSessionId( 
            GetCurrentProcessId(), 
            &CurrentSessionId 
            ) == 0 ) {
        
        return FALSE ;
    }           
    

    // Set the LearnEnabled flag to CurrentSessionId
    
    size = sizeof(DWORD) ; 
            
    if ( RegSetValueEx(
            TSkey,
            L"LearnEnabled", 
            0, 
            REG_DWORD,
            (CONST BYTE *) &CurrentSessionId, 
            size
            ) != ERROR_SUCCESS ) {
        
        return FALSE ; 
    
    }
    
    RegCloseKey(TSkey) ; 
    return TRUE ; 


}

/*++

Routine Description :

    This routine will set the LearnEnabled Flag in registry to 0 to 
    indicate the completion of tracking mode.
    
Arguments :

    None.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     

BOOL StopLearn(VOID)
{

    HKEY TSkey ; 
    DWORD learn_enabled = -1 ; 
    LONG size ; 
    DWORD disp, error_code ; 
    
    
    if ( RegCreateKeyEx(
            HKEY_CURRENT_USER, 
            LIST_REG_KEY, 
            0, 
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL,
            &TSkey,
            &disp
            ) != ERROR_SUCCESS) {
        
        return FALSE;
        
    }

    // ReSet the LearnEnabled flag
    
    size = sizeof(DWORD) ; 
            
    if ( RegSetValueEx(
            TSkey,
            L"LearnEnabled",
            0,
            REG_DWORD,
            (CONST BYTE *) &learn_enabled, 
            size
            ) != ERROR_SUCCESS ) {
        
        return FALSE ; 
    
    }
    
    RegCloseKey(TSkey) ; 
    
    return TRUE ; 
    
}


/*++

Routine Description :

    This routine will clear the registry used in Tracking mode. 
    
Arguments :

    None.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     

BOOL ClearLearnList(VOID)
{

    HKEY list_key ; 
    DWORD learn_enabled = 0 ; 
    WCHAR buffer_sent[2] ; 
    
    DWORD error_code ; 

    if ( RegOpenKeyEx(
            HKEY_CURRENT_USER, 
            LIST_REG_KEY, 
            0, 
            KEY_ALL_ACCESS, 
            &list_key 
            ) != ERROR_SUCCESS)  {
        
        return FALSE;
        
    }
    
    buffer_sent[0] = L'\0' ;
    buffer_sent[1] = L'\0' ; 

    // Clear the ApplicationList
    
    if ( RegSetValueEx(
            list_key,
            L"ApplicationList", 
            0, 
            REG_MULTI_SZ,
            (CONST BYTE *) buffer_sent, 
            2 * sizeof(WCHAR) 
            ) != ERROR_SUCCESS ) {
        
        return FALSE;
        
    }
            
    RegCloseKey(list_key) ; 
    
    return TRUE ; 

}

/*++

Routine Description :

    This function will display the applications tracked in the
    tracking mode onto a dialog box.
        
Arguments :

    ListBoxHandle - handle to the ListBox used in Tracking mode.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     

BOOL display_app_list( HWND ListBoxHandle )

{
    BOOL status = FALSE ;
    
    ULONG size = 0; 
    WCHAR *buffer_sent ; 
    UINT i, j = 0 ; 
    HKEY list_key ; 
    DWORD error_code ; 

    
    /* First open the list_reg_key */
    
    if ( error_code=RegOpenKeyEx(
                        HKEY_CURRENT_USER, 
                        LIST_REG_KEY,
                        0, 
                        KEY_READ, 
                        &list_key 
                        ) != ERROR_SUCCESS) {
            return (status) ; 
    }
    
    /* First find out size of buffer to allocate */    
    
    if ( error_code=RegQueryValueEx(
                        list_key, 
                        L"ApplicationList", 
                        NULL, 
                        NULL,
                        (LPBYTE) NULL , 
                        &size
                        ) != ERROR_SUCCESS ) {

        RegCloseKey(list_key) ; 
        return (status) ; 
    }
    
    buffer_sent =  (WCHAR *)LocalAlloc(LPTR,size); 
    if(!buffer_sent) {

        RegCloseKey(list_key) ; 
        return (status) ; 
    }

    if ( error_code=RegQueryValueEx(
                        list_key, 
                        L"ApplicationList", 
                        NULL, 
                        NULL,
                        (LPBYTE) buffer_sent , 
                        &size
                        ) != ERROR_SUCCESS ) {

        RegCloseKey(list_key) ;
        LocalFree(buffer_sent);
        return(status) ; 
    }
    
    size=size/sizeof(WCHAR)-1;//get size in characters excluding terminating 0

    for(i=0 ; i < size ; i++ ) {
        
        if(wcslen(buffer_sent+i)){             
            AddItemToList(ListBoxHandle, buffer_sent+i ) ;          
        }
        
        i+=wcslen(buffer_sent+i);
        //now buffer_sent[i]==0
        //00- end of data
    } /* end of for loop */
    
    status = TRUE ; 
    
    RegCloseKey(list_key) ; 
    LocalFree(buffer_sent);

    return(status) ; 
   
} /* end of display_app_list */


/*++

Routine Description :

    This Routine checks if the application resides in a local drive 
    or a remote network share. If it is a remote share, the UNC path
    of the application is returned. 
    
Arguments :
    
    appname - name of the application

Return Value :

    The UNC path of the appname if it resides in a remote server share.
    The same appname if it resides in a local drive.
    
--*/     

VOID 
ResolveName(
    WCHAR *appname,
    WCHAR *ResolvedName
    )
    
{

    UINT i ; 
    INT length ; 
    WCHAR LocalName[3] ; 
    WCHAR RootPathName[4] ; 
    WCHAR RemoteName[MAX_PATH] ; 
    DWORD size = MAX_PATH ; 
    DWORD DriveType, error_status ; 
    
    memset(ResolvedName, 0, MAX_PATH * sizeof(WCHAR)) ; 
    
    // check if appname is a app in local drive or remote server share
   
    wcsncpy(RootPathName, appname, 3 ) ;
    RootPathName[3] = L'\0';
    
    DriveType = GetDriveType(RootPathName) ;

    if (DriveType == DRIVE_REMOTE) {
        
        // Use WNetGetConnection to get the name of the remote share
        
        wcsncpy(LocalName, appname, 2 ) ;
        LocalName[2] = L'\0' ; 

        error_status = WNetGetConnection (
                           LocalName,
                           RemoteName,
                           &size
                           ) ;     

        if (error_status != NO_ERROR) {
        
            wcscpy(ResolvedName,appname) ; 
            return ;
        }
        
        wcscpy( ResolvedName, RemoteName ) ;
        
        length = wcslen(ResolvedName) ;

        ResolvedName[length++] = L'\\' ; 
        
        for (i = 3 ; i <= wcslen(appname) ; i++ ) {
            ResolvedName[length++] = appname[i] ; 
        }
        
        ResolvedName[length] = L'\0' ; 
        
        return ; 
        

    } else {
    
        wcscpy(ResolvedName,appname) ; 
        return ;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\adddlg.h ===
INT_PTR CALLBACK
AddDlgProc(
    HWND    hdlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\appsec.h ===
#define LIST_REG_KEY L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"

#define LEARN_REG_KEY L"System\\CurrentControlSet\\Control\\Terminal Server\\AuthorizedApplications"

#define EVENT_NAME L"Global\\AppsecEvent"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\commdlg.cpp ===
/******************************************************************************
*
*   COMMDLG.C
*
*   Implements the common dialog functions.
*
*   Copyright Citrix Systems Inc. 1997
*
*   Author: Kurt Perry (kurtp) 22-Aug-1996
*
*   $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\APPSEC\VCS\COMMDLG.C  $
*  
*       Rev 2.0   28 Jul 1999 - dialog changed from "Save File" to "Open File",
                                                        some bugs fixed.

*   Rev 1.0   31 Jul 1997 09:09:46   butchd
*       
*  Initial revision.
*  
*******************************************************************************/

#include "pch.h"
#include "appsec.h"
#include "resource.h"
#include <commdlg.h>


/*
 *  Global vars
 */

extern HINSTANCE hInst;

/******************************************************************************
 *
 *  fnGetApplication
 *
 *  Implements the 
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 *****************************************************************************/

BOOL 
fnGetApplication( HWND hWnd, PWCHAR pszFile, ULONG cbFile, PWCHAR pszTitle )
{
    static WCHAR szDirName[MAX_PATH+1]={0};
    WCHAR szFilter[MAX_PATH+1];
        
    WCHAR chReplace;
    INT   i;
    ULONG cbString;

        //Separate file and dir names

    WCHAR *sep=wcsrchr(pszFile,L'\\');
        
    if(sep){
            *sep=0;
            wcscpy(szDirName,pszFile);
            wcscpy(pszFile,sep+1);
    }else{
            if(!wcslen(szDirName)){//initialize only 1st time; remember last dir
                   GetSystemDirectory( szDirName, MAX_PATH );
            }
    }

    cbString = LoadString( hInst, IDS_FILTERSTRING, szFilter, MAX_PATH );

    if (cbString == 0) {
       return FALSE;
    }

    chReplace = szFilter[cbString - 1];

    for ( i = 0; szFilter[i] != L'\0'; i++ ) {

        if ( szFilter[i] == chReplace ) {
            szFilter[i] = L'\0';
        }
    }
        
    OPENFILENAME ofn;

    ZeroMemory(&ofn,sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = pszFile;
    ofn.nMaxFile = cbFile;
    ofn.lpstrInitialDir = szDirName;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_FILEMUSTEXIST | OFN_NONETWORKBUTTON | OFN_PATHMUSTEXIST;
    ofn.lpstrTitle = pszTitle;

    if ( GetOpenFileName( &ofn ) ) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\appsec.cpp ===
/******************************************************************************
*
*   AppSec.c
*
*   This module contains code for the AppSec utility.
*   This utility is used to configure and maintain applications on
*   a WinFrame Internet server (used to secure the ActiveX client).
*
*   Copyright Citrix Systems Inc. 1997
*
*   Author: Kurt Perry (kurtp)
*
*   Date: 22-Aug-1996
*
*   $Log:   N:\nt\private\utils\citrix\winutils\appsec\VCS\appsec.c  $
*
*     Rev 1.8   Aug 11 2000  - alhen
*  bug 158727 GetBinaryType results aren't bitfields
*   ------------------------------------------------------------------------
*
*     Rev 1.7   June-July 1999 - added Tracking mode interface and dialogs
*
*   ------------------------------------------------------------------------
*
*     Rev 1.6   May 09 1998 15:31:18   tyl
*  bug 2475 - added loadwc.exe into preload
*
*     Rev 1.5   May 03 1998 21:17:06   tyl
*  bug 1852 - appsec now preloads couple more files some of which are non-binary
*  appsec doesn't check if the file is binary anymore
*
*     Rev 1.4   Apr 28 1998 09:29:26   tyl
*  bug 2134 - "Browse" is no longer hardcoded
*
*     Rev 1.2   Apr 13 1998 16:17:02   tyl
*   bug 1856 - appsec utility now pre-load the following applications in the edi
*   box when it is initially started: cmd.exe, subst.exe, xcopy.exe, net.exe,
*   regini.exe, systray.exe, and explorer.exe
*
*     Rev 1.1   29 Dec 1997 16:06:56   thanhl
*  Hydra merge
*
*     Rev 1.1   26 Sep 1997 19:03:50   butchd
*  Hydra registry name changes
*
*     Rev 1.0   31 Jul 1997 09:09:32   butchd
*  Initial revision.
*
*******************************************************************************/


/*
 *  Include files stuff
 */
#include "pch.h"
#include "resource.h"

#pragma hdrstop


#include "AppSec.h"
#include "ListCtrl.h"
#include "AddDlg.h"
#include <winsta.h>
#include <regapi.h>
#include "utildll.h"
#include <accctrl.h>
#include <aclapi.h>
/*
 * Local function prototypes.
 */
INT_PTR APIENTRY AppSecDlgProc(HWND hdlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
BOOL             AddApplicationToList( PWCHAR );
VOID             UpdateApplicationList( VOID );
LONG             ReadRegistry( VOID );
VOID             LoadInitApp(VOID);


/*
 *  Local vars
 */

HINSTANCE hInst;
INT    dxTaskman;
INT    dyTaskman;
INT    dxScreen;
INT    dyScreen;

DWORD  g_fEnabled = 0;
HWND   g_hwndDialog;
HWND   g_hwndList;

WCHAR   g_szTemp[MAX_PATH];
WCHAR   g_szApplication[MAX_PATH];

WCHAR   g_szFirstHiddenApp[MAX_PATH];
WCHAR   g_szSecondHiddenApp[MAX_PATH];
WCHAR   g_szThirdHiddenApp[MAX_PATH];
WCHAR   g_szFourthHiddenApp[MAX_PATH];

WCHAR   g_szSystemRoot[MAX_PATH];


/*
 *  DOS or Win16 binary filetypes
 *  DOSWIN_APP_FILETYPES (SCS_DOS_BINARY|SCS_PIF_BINARY|SCS_WOW_BINARY)
 */


/*
 *  Below is the list of default (necessary) applications
 */

/*
 *  This is a list of init apps.
 */

LPWSTR g_aszInitApps[] = {
   L"system32\\loadwc.exe",
   L"system32\\cmd.exe",
   L"system32\\subst.exe",
   L"system32\\xcopy.exe",
   L"system32\\net.exe",
   L"system32\\regini.exe",
   L"system32\\systray.exe",
   L"explorer.exe",
   L"system32\\attrib.exe",
   L"Application Compatibility Scripts\\ACRegL.exe",
   L"Application Compatibility Scripts\\ACsr.exe",
   L"system32\\ntsd.exe"
};

#define MAX_INIT_APPS (sizeof(g_aszInitApps)/sizeof(g_aszInitApps[0]))

/*
 *  NOTE: userinit.exe MUST be first in list!!!!
 *
 *  This is done to "hide" system programs from the user of this utility!
 */

LPWSTR g_aszLogonApps[] = {
    L"system32\\userinit.exe",
    L"system32\\wfshell.exe",
    L"system32\\chgcdm.exe",
    L"system32\\nddeagnt.exe",
};
extern const int MAX_LOGON_APPS=(sizeof(g_aszLogonApps)/sizeof(g_aszLogonApps[0]));

LPWSTR g_aszDOSWinApps[] = {
    L"system32\\command.com",
    L"system32\\dosx.exe",
    L"system32\\himem.sys",
    L"system32\\krnl386.exe",
    L"system32\\mscdexnt.exe",
    L"system32\\ntvdm.exe",
    L"system32\\nw16.exe",
    L"system32\\redir.exe",
    L"system32\\vwipxspx.exe",
    L"system32\\win.com",
    L"system32\\wowdeb.exe",
    L"system32\\wowexec.exe",
};
extern const int MAX_DOSWIN_APPS=(sizeof(g_aszDOSWinApps)/sizeof(g_aszDOSWinApps[0]));



/*** AppSecDlgProc -- Dialog Procedure for AppSec
 *
 *
 *
 * AppSecDlgProc(HWND hdlg, WORD wMSG, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhdlg                 - handle to dialog box.
 *                 WORD wMsg                  - message to be acted upon.
 *                 WPARAM wParam              - value specific to wMsg.
 *                 LPARAM lParam              - value specific to wMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR APIENTRY
AppSecDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    RECT   rc;
    POINT  pt;
    WPARAM idSelected;
    WCHAR  szMsg[MAX_PATH];
    WCHAR  szTitle[MAX_PATH];


    BOOL ClearLearnList(VOID) ;

    switch (wMsg) {

    case WM_INITDIALOG:

        //  locate dialog
        GetWindowRect(hwnd, &rc);
        dxTaskman = rc.right - rc.left;
        dyTaskman = rc.bottom - rc.top;
        dxScreen = GetSystemMetrics(SM_CXSCREEN);
        dyScreen = GetSystemMetrics(SM_CYSCREEN);

        pt.x = (dxScreen - dxTaskman) / 2;
        pt.y = (dyScreen - dyTaskman) / 2;

        //  on top!
        SetWindowPos(hwnd, HWND_NOTOPMOST, pt.x, pt.y, 0, 0,
           SWP_NOSIZE | SWP_NOACTIVATE);

        //  get handle to list box
        if ( (!(g_hwndList = GetDlgItem( hwnd, IDC_APP_LIST )))||
            (!InitList(g_hwndList))) {
            LoadString( NULL, IDS_ERR_LB ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
            MessageBox( hwnd, szMsg, szTitle, MB_OK);
            ExitProcess(0);
        }

        //  Get SystemRoot path
        GetEnvironmentVariable( L"SystemRoot", g_szSystemRoot, MAX_PATH );

        //  Generate hidden applications
        wsprintf( g_szFirstHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[0] );
        wsprintf( g_szSecondHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[1] );
        wsprintf( g_szThirdHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[2] );
        wsprintf( g_szFourthHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[3] );

        //  get registry data
        if ( ReadRegistry() == 0 ) {
            LoadInitApp();
            UpdateApplicationList();
        }
        AdjustColumns(g_hwndList);

        //  set radio button default state
        if ( g_fEnabled ) {
            SendDlgItemMessage( hwnd, IDC_SECURITY_ENABLED,  BM_SETCHECK, TRUE, 0 );
            SendDlgItemMessage( hwnd, IDC_SECURITY_DISABLED, BM_SETCHECK, FALSE, 0 );
        }
        else {
            SendDlgItemMessage( hwnd, IDC_SECURITY_ENABLED,  BM_SETCHECK, FALSE, 0 );
            SendDlgItemMessage( hwnd, IDC_SECURITY_DISABLED, BM_SETCHECK, TRUE, 0 );
        }

        return FALSE;

    case WM_HELP:
        {
            LPHELPINFO phi=(LPHELPINFO)lParam;
            if(phi->dwContextId){
                WinHelp(hwnd,L"APPSEC",HELP_CONTEXT,phi->iCtrlId);
            }else{
                WinHelp(hwnd,L"APPSEC",HELP_FINDER,0);
            }
        }
        break;

    case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pdis=(LPDRAWITEMSTRUCT)lParam;
            if(pdis->hwndItem==g_hwndList){
                OnDrawItem(g_hwndList,pdis);
            }
        }
        break;

    case WM_NOTIFY:
        {
            NMHDR* pnmhdr=(NMHDR*)lParam;
            if(pnmhdr->hwndFrom==g_hwndList){

                NMLISTVIEW* pnmlv=(NMLISTVIEW*)pnmhdr;

                switch(pnmlv->hdr.code){

                case LVN_COLUMNCLICK:
                    SortItems(g_hwndList,(WORD)pnmlv->iSubItem);
                    break;
                case LVN_DELETEITEM:
                    OnDeleteItem(g_hwndList,pnmlv->iItem);
                    break;
                default:
                    break;
                }
            }
        }
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDHELP :

            WinHelp(hwnd, L"appsec", HELP_CONTENTS, 0);
            break;

        case IDOK :

            PostQuitMessage(0);
            break;

        case IDC_SECURITY_ENABLED :

            /*
             *  Set enabled flag
             */
            g_fEnabled = 1;

            /*
             *  Update registry
             */
            UpdateApplicationList();

        // Show the WARNING Message Box

        LoadString( NULL, IDS_WARNING_TEXT ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_WARNING ,szTitle, MAX_PATH );
            MessageBox( NULL, szMsg, szTitle, MB_OK);

            break;

        case IDC_SECURITY_DISABLED :

            /*
             *  Clear enabled flag
             */
            g_fEnabled = 0;

            /*
             *  Update registry
             */
            UpdateApplicationList();

            break;

        case ID_ADD :

            /*
             *  Get application
             */
            DialogBox( hInst, MAKEINTRESOURCE(DLG_ADD), hwnd, AddDlgProc );

            /*
             *  Update list and registry
             */
            UpdateApplicationList();
            AdjustColumns(g_hwndList);
            break;

        case ID_DELETE :

            //  are items selected?
            if ( ((idSelected = GetSelectedItemCount( g_hwndList )) != -1) &&
                  (idSelected != 0) ) {

                //  ask first
                LoadString( NULL, IDS_REMOVE ,szMsg, MAX_PATH );
                LoadString( NULL, IDS_DELETE ,szTitle, MAX_PATH );
                if ( MessageBox(hwnd, szMsg, szTitle, MB_OKCANCEL) == IDOK ) {
                    DeleteSelectedItems(g_hwndList);
                }
                /*
                 *  Update list
                 */
                UpdateApplicationList();
            }
            break;
        }

        break;

    case WM_CLOSE:

        PostQuitMessage(0);
        break;

    default:

        return FALSE;

    }

    return TRUE;

    lParam;
}

/******************************************************************************
 *
 *  UpdateApplicationList
 *
 *  Update list and registry
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
UpdateApplicationList()
{
    ULONG i;
    ULONG  cbItem;
    ULONG  cbTotal = 0;
    LPWSTR  p;

    LPWSTR  pApplicationList = NULL;
    DWORD  Disp;
    HKEY   hkApp;
    DWORD  dwBinaryType;
    BOOL   fDOSWin = FALSE;

    /*
     *  Count bytes needed for LOGON Apps
     */
    for ( i=0; i<MAX_LOGON_APPS; i++ ) {
        wsprintf( g_szTemp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[i] );
        cbTotal += lstrlen( g_szTemp ) + 1;
    }

    /*
     *  Count bytes needed for DOS/Win
     */
    for ( i=0; i<MAX_DOSWIN_APPS; i++ ) {
        wsprintf( g_szTemp, L"%s\\%s", g_szSystemRoot, g_aszDOSWinApps[i] );
        cbTotal += lstrlen( g_szTemp ) + 1;
    }

    /*
     *  Count bytes needed for list box
     */
    for ( i=0; ; i++ ) {

        /*
         *  Get current index
         */

        if ( (cbItem = GetItemText( g_hwndList, i,NULL,0 )) == -1 ) {
            break;
        }

        /*
         *  Count these bytes
         */
        cbTotal += cbItem + 1;
    }


    /*
     *  Write to registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, AUTHORIZEDAPPS_REG_NAME, 0,
                       KEY_ALL_ACCESS, &hkApp ) != ERROR_SUCCESS ) {

        /*
         *  Create key, if that works then just write value, new entry
         */
        if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, AUTHORIZEDAPPS_REG_NAME, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &hkApp, &Disp ) != ERROR_SUCCESS ) {
            return;
        }

        // After creating the key, give READ access to EVERYONE

    }

    /*
     *  Allocate memory (extra null)
     */
    if ( (pApplicationList = (WCHAR *)LocalAlloc(0, (++cbTotal) * sizeof(WCHAR) )) !=NULL ) {

        /*
         *  Clear buffer
         */
        memset( pApplicationList, 0, cbTotal * sizeof(WCHAR));

        /*
         *  Add apps from list box
         */
        for ( i=0, cbTotal=1, p=pApplicationList; ; i++ ) {

            /*
             *  Get current index
             */
            if ( (cbItem = GetItemText( g_hwndList, i, p,MAX_PATH )) == -1 ) {
                break;
            }

            /*
             *  Get app type
             *  Bug 158727 Whistler.
             */
            if ( GetBinaryType( p, &dwBinaryType ) == TRUE )
            {
                if( dwBinaryType == SCS_DOS_BINARY ||
                    dwBinaryType == SCS_PIF_BINARY || 
                    dwBinaryType == SCS_WOW_BINARY )
                {
                    fDOSWin = TRUE;
                }
            }
            p += cbItem + 1;
            cbTotal += cbItem + 1;

        }
        /*
         *  Add LOGON apps
         */
        for ( i=0; i<MAX_LOGON_APPS; i++ ) {
            wsprintf( p, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[i] );
            cbItem = lstrlen( p );
            p += cbItem + 1;
            cbTotal += cbItem + 1;
        }

        /*
         *  Add DOS/Win apps if necessary
         */
        if ( fDOSWin ) {
            for ( i=0; i<MAX_DOSWIN_APPS; i++ ) {
                wsprintf( p, L"%s\\%s", g_szSystemRoot, g_aszDOSWinApps[i] );
                cbItem = lstrlen( p );
                p += cbItem + 1;
                cbTotal += cbItem + 1;
            }
        }

        /*
         *  Just write this value, the key has just been created
         */
        RegSetValueEx( hkApp, CTXAPPS_APPLICATIONLIST, 0, REG_MULTI_SZ,
                       (CONST BYTE *)pApplicationList, cbTotal * sizeof(WCHAR));

        /*
         *  Done with memory
         */
        LocalFree( pApplicationList );
    }

    /*
     *  Write enabled flag
     */
    RegSetValueEx( hkApp, CTXAPPS_ENABLED, 0, REG_DWORD,
               (BYTE *)&g_fEnabled, sizeof(DWORD) );

    /*
     *  Done with key
     */
    RegCloseKey( hkApp );
}


/******************************************************************************
 *
 *  LoadInitApp
 *
 *  Load the init apps into the list box
 *
 *  EXIT:
 *
 ******************************************************************************/
 VOID
 LoadInitApp(){
    WPARAM i;
    ULONG  cbItem;
    ULONG  cbTotal = 0;
    LPWSTR  p;

    // find the MAX length of InitApps
    for (i=0;i<MAX_INIT_APPS;i++) {
       cbItem = lstrlen(g_aszInitApps[i]);
       if (cbItem>cbTotal) {
          cbTotal = cbItem;
       }
    }

    // one  for the \ and one for the null
    cbTotal += 2 + lstrlen(g_szSystemRoot);

    /*
     *  Allocate memory (extra null)
     */
    if ( (p = (WCHAR *)LocalAlloc(0, (cbTotal) * sizeof(WCHAR) )) !=NULL ) {
        /*
         *  Add INIT apps
         */
        for ( i=0; i<MAX_INIT_APPS; i++ ) {
            wsprintf( p, L"%s\\%s", g_szSystemRoot, g_aszInitApps[i] );
            AddItemToList( g_hwndList, p );
        }

        /*
         *  Done with memory
         */
        LocalFree( p );
    }

 }


/******************************************************************************
 *
 *  ReadRegistry
 *
 *  Update list from registry
 *
 *  EXIT:
 *
 ******************************************************************************/

LONG
ReadRegistry()
{
    DWORD DataType;
    ULONG  InLength = 0;
    LPWSTR p;
    LPWSTR pApplicationList = NULL;
    HKEY  hkApp;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    /*
     *  Read from registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, AUTHORIZEDAPPS_REG_NAME, 0,
                       KEY_ALL_ACCESS, &hkApp ) != ERROR_SUCCESS ) {
        return( InLength );
    }

    /*
     *  Get size of MULTI_SZ strings
     */
    (void) RegQueryValueEx( hkApp, CTXAPPS_APPLICATIONLIST, NULL, &DataType,
                            NULL, &InLength );

    /*
     *  Entries?
     */
    if ( InLength ) {

        /*
         *  Allocate memory (extra null)
         */
        if ( (pApplicationList = (WCHAR *)LocalAlloc(0, (++InLength) * sizeof(WCHAR))) != NULL ) {

            /*
             *  Read in list
             */
            if ( RegQueryValueEx( hkApp, CTXAPPS_APPLICATIONLIST,
                                  NULL, &DataType, (BYTE *)pApplicationList,
                                  &InLength ) == ERROR_SUCCESS ) {

                /*
                 *  Walk it
                 */
                p = pApplicationList;
                while ( *p ) {

                    if ( (p[0] == '\0') && (p[1] == '\0') ) break ;

                    //  once we get to first LOGON app we are done adding to window
                    // we shud not display the LOGON apps to the listbox

                    if ( !lstrcmpi( p, g_szFirstHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    if ( !lstrcmpi( p, g_szSecondHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    if ( !lstrcmpi( p, g_szThirdHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    if ( !lstrcmpi( p, g_szFourthHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    //  add to listbox

                    AddItemToList(g_hwndList,p);
                    //  next
                    p += lstrlen(p) + 1;
                }
            }

            /*
             *  Done with list
             */
            LocalFree( pApplicationList );
        }
    }

    /*
     *  Get enable key
     */
    if ( RegQueryValueEx( hkApp, CTXAPPS_ENABLED, NULL, &ValueType,
                  (LPBYTE) &g_fEnabled, &ValueSize ) != ERROR_SUCCESS ) {
    g_fEnabled = 0;
    }

    /*
     *  Done with key
     */
    RegCloseKey( hkApp );

    return( InLength );
}


/*** Main --         Program entry point (was WinMain).
 *
 *
 *
 * Main(int argc, char *argv[], char *envp[])
 *
 * ENTRY -         int argc                - argument count.
 *                        char *argv[]        - argument list.
 *                        char *envp[]        - environment.
 *
 * EXIT  -           TRUE if success, FALSE if not.
 * SYNOPSIS -  Parses command line, for position to place dialog box, if no
 *                                position (came from ctl/esc) then center on screen.
 *                                Also make sure only one instance of taskman.
 *
 * WARNINGS -
 * EFFECTS  -
 */
#ifdef _DEBUG
#include <crtdbg.h>
#endif _DEBUG

INT _cdecl main(
   INT argc,
   CHAR *argv[],
   CHAR *envp[])
{
    MSG msg;
    WCHAR szTitle[MAX_PATH];
    WCHAR szMsg[MAX_PATH];
    HANDLE AppsecEventHandle ;
    DWORD error_code ;

#ifdef _DEBUG
    //detecting memory leaks
    // Get current flag
    int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
    // Turn on leak-checking bit
    tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
    // Set flag to the new value
    _CrtSetDbgFlag( tmpFlag );

#endif _DEBUG

    AppsecEventHandle = CreateEvent(NULL, TRUE, FALSE, EVENT_NAME ) ;

    if (AppsecEventHandle == NULL)
    {
        error_code = GetLastError() ;
    }

    error_code = GetLastError() ;

    if (error_code == ERROR_ALREADY_EXISTS)
    {
        LoadString( NULL, IDS_ERR_INSTANCE ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        CloseHandle(AppsecEventHandle) ;

        ExitProcess(0) ;
    }



    // SetEvent(AppsecEventHandle) ;

    // WaitForSingleObject(AppsecEventHandle, INFINITE) ;

    //  get instance handle
    hInst = GetModuleHandle(NULL);

    // FALSE/TRUE params in the following means check for
    // local admin / domain admin respectively
    if( ( TestUserForAdmin( FALSE ) != TRUE )  &&
        ( TestUserForAdmin( TRUE ) != TRUE ) )
    {
        LoadString( NULL, IDS_ERR_ADMIN, szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR, szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION );

        return( FALSE );
    }

    //  create us
    g_hwndDialog = CreateDialog(hInst, MAKEINTRESOURCE(DLG_MAIN_TITLE), NULL,
         (DLGPROC)AppSecDlgProc);

    //  bug us?
    if (g_hwndDialog == NULL)
        return 0;


    //  show us
    ShowWindow(g_hwndDialog, SW_NORMAL);


    HACCEL hAccel=LoadAccelerators(hInst,MAKEINTRESOURCE(IDR_ACCELERATORS));

    //  process input
    while (GetMessage(&msg, (HWND)NULL, (UINT)0, (UINT)0)) {
        if (!TranslateAccelerator(g_hwndDialog,hAccel,&msg)){
            //if (!IsDialogMessage(g_hwndDialog, &msg)) {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            //}
        }
    }

    DestroyWindow(g_hwndDialog);

    ResetEvent(AppsecEventHandle) ;
    CloseHandle(AppsecEventHandle) ;

    //ExitProcess(0) ;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_ROOT            =.


make_root:
    binplace -R $(_NTTREE) $(_ROOT)\APPSEC.HLP
    binplace -R $(_NTTREE) $(_ROOT)\APPSEC.CNT

clean: make_root
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\listctrl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ListCtrl.h

Abstract:

	Header for ListCtrl.cpp

Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 26-July-1999

Revision History:

--*/

#pragma once

/*++
class CItemData:
	pointer to object of this class 
	located in lParam member of LVITEM structure 
	for each item.
--*/
class CItemData
{
private:
	static const LPWSTR	m_wszNull;//empty string

	LPWSTR	m_wszText;//Full file name.
	int		m_sep;//index of '\\' character separating file name and path.
	int		m_iImage;//Image index.
public:
	CItemData(LPCWSTR wszText);
	~CItemData();
	operator LPWSTR()
	{ 
		if(m_sep){
			m_wszText[m_sep]='\\';
		}
		return m_wszText;
	}
	LPWSTR Name()
	{
		if(m_sep){
			return m_wszText+m_sep+1;
		}else{
			return m_wszText;
		}
	}
	LPWSTR Path()
	{
		if(m_sep){
			m_wszText[m_sep]=0;
			return m_wszText;
		}else{
			return m_wszNull;
		}
	}
	void SetImage(int ind)
	{
		m_iImage=(ind==-1)?0:ind;
	}
	int GetImage()
	{
		return m_iImage;
	}

};


BOOL
InitList(
	HWND hwndList);

BOOL
AddItemToList(
	HWND hwndList,
	LPCWSTR pwszText);

int
GetItemText(
	HWND hwndList,
	int iItem,
	LPWSTR pwszText,
	int cchTextMax);

void
DeleteSelectedItems(
	HWND hwndList);

int
GetSelectedItemCount(
	HWND hwndList);

int
GetItemCount(
	HWND hwndList);

int
FindItem(
	HWND hwndList,
	LPCWSTR pwszText);

void
OnDeleteItem(
	HWND hwndList,
	int iItem);

CItemData*
GetItemData(
	HWND hwndList,
	int iItem);

void
SortItems(
	HWND hwndList,
	WORD wSubItem);

void
OnDrawItem(
	HWND hwndList,
	LPDRAWITEMSTRUCT pdis);

void 
AdjustColumns(
	HWND hwndList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\pch.h ===
#pragma once

#ifdef MYCMP

#include <windows.h>
#include <stierr.h>
#include <stdio.h>
#include <lm.h>

#else
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>

#endif MYCMP

#include <commctrl.h>
#include <shellapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\listctrl.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ListCtrl.cpp

Abstract:

    Functions working with Owner Draw List Control.
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 26-July-1999

Environment:


Revision History:


--*/


#include "pch.h"
#include "ListCtrl.h"
#include "resource.h"


extern HINSTANCE hInst;


//////////////////////////////////////////////////////////////////////
//Class CItemData
//////////////////////////////////////////////////////////////////////
const LPWSTR CItemData::m_wszNull=L"";

/*++

Routine Description :

        Constructor - initializes object.
        
Arguments :

        IN LPCWSTR wszText - Full name of application file.
        
Return Value :

        none
                
--*/
CItemData::CItemData(LPCWSTR wszText)
        :m_wszText(NULL),m_sep(0)
{

        if(wszText){
                int size=wcslen(wszText);
                m_wszText=new WCHAR[size+1];

                if(!m_wszText) {
                    ExitProcess(1);
                }

                wcscpy(m_wszText,wszText);
                m_sep=size-1;
                while((m_sep)&&(wszText[m_sep]!='\\')){
                        m_sep--;
                }
        }
        else
                m_wszText=m_wszNull;
}

/*++

Routine Description :

        Destructor - deletes allocated buffer.
        
Arguments :

        none
        
Return Value :

        none
                
--*/
CItemData::~CItemData()
{
        if((m_wszText)&&(m_wszText!=m_wszNull)){
                delete[] m_wszText;
        }
}

//////////////////////////////////////////////////////////////////////
//List Control functions
//////////////////////////////////////////////////////////////////////


/*++

Routine Description :

        This routine adds Image List and columns "Name" and "Path" to List Control.
        
Arguments :

        IN HWND hwndListList - Control Handle.
        
Return Value :

        TRUE is successful.
        FALSE otherwise.
                
--*/


BOOL
InitList(
        HWND hwndList)
{

        HIMAGELIST hImageList=ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                GetSystemMetrics(SM_CYSMICON),ILC_MASK,1,1);
        if(!hImageList)
                return FALSE;
        HICON hIcon=LoadIcon(hInst,MAKEINTRESOURCE(IDI_APP));
        if (!hIcon) {
           return FALSE;
        }
        int ind=ImageList_AddIcon(hImageList,hIcon);
        DeleteObject(hIcon);
        ListView_SetImageList(hwndList,hImageList,LVSIL_SMALL);


        
        //Create Columns
        LVCOLUMN lvc;
        lvc.mask=LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.fmt=LVCFMT_LEFT;
        lvc.cx=150;
        lvc.iSubItem=0;
        lvc.iImage=0;
        lvc.iOrder=0;
        lvc.cchTextMax=0;
        lvc.pszText=L"Name";
        if(ListView_InsertColumn(hwndList,0,&lvc)==-1){
                return FALSE;
        }
        
        RECT Rect;
        GetClientRect(hwndList,&Rect);
        lvc.cx=Rect.right-150;
        lvc.iSubItem=1;
        lvc.iOrder=1;
        lvc.pszText=L"Path";
        if(ListView_InsertColumn(hwndList,1,&lvc)==-1){
                return FALSE;
        }
        return TRUE;
}


/*++

Routine Description :

        This routine adds Item (file) to List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN LPCWSTR pwszText - Text for the Item (full path and file name)
        
Return Value :

        TRUE is successful.
        FALSE otherwise.
                
--*/
BOOL
AddItemToList(
        HWND hwndList,
        LPCWSTR pwszText)
{
        

        CItemData* pid=new CItemData(pwszText);

        if (pid == NULL) {
           return FALSE;
        }

        //get file icon
        SHFILEINFO shfi;
        ZeroMemory(&shfi,sizeof( SHFILEINFO ));
        SHGetFileInfo( pwszText, 0, &shfi, sizeof( SHFILEINFO ),
               SHGFI_ICON | SHGFI_SMALLICON  );
        

        //insert item
        LVITEM lvi;
        ZeroMemory(&lvi,sizeof(LVITEM));
        lvi.mask=LVIF_PARAM|LVIF_TEXT;
    lvi.iItem=(int) SendMessage(hwndList,LVM_GETITEMCOUNT,(WPARAM)0,(LPARAM)0);
        lvi.iSubItem=0;
        lvi.pszText=pid->Name();
    lvi.lParam=(LPARAM)pid;
        
        //set icon for item
        if(shfi.hIcon){
                HIMAGELIST hImageList=(HIMAGELIST)SendMessage(hwndList,LVM_GETIMAGELIST,
                        (WPARAM)LVSIL_SMALL,(LPARAM)0);
                pid->SetImage(ImageList_AddIcon(hImageList,shfi.hIcon));
                DestroyIcon(shfi.hIcon);
        }else{
                pid->SetImage(0);
        }

        if(SendMessage(hwndList,LVM_INSERTITEM,(WPARAM)0,(LPARAM)&lvi)==-1){
                delete pid;
                return FALSE;
        }

        lvi.iSubItem=1;
        lvi.pszText=pid->Path();
        SendMessage(hwndList,LVM_SETITEMTEXT,(WPARAM)lvi.iItem,(LPARAM)&lvi);

        return TRUE;    
}

/*++

Routine Description :

        This routine returns full path for item.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iItem - Iten ID
        OUT LPWSTR pwszText - buffer (can be NULL)
                if not NULL it must be at least cchTextMax+1 characters long
        IN int cchTextMax - buffer size (in characters)
        
Return Value :

        Number of characters in item text.
        -1 if error.
                
--*/

int
GetItemText(
        HWND hwndList,
        int iItem,
        LPWSTR pwszText,
        int cchTextMax)
{
        //if pwszText=NULL then retreive length of string
        
        CItemData* pid=GetItemData(hwndList,iItem);
        if(!pid){
                return -1;
        }
        if(pwszText){
                wcsncpy(pwszText,LPWSTR(*pid),cchTextMax);
                pwszText[cchTextMax]=0;
        }
        return wcslen(LPWSTR(*pid));
        
}

/*++

Routine Description :

        This routine deletes all selected items in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.

        
Return Value :

        none
                
--*/
void
DeleteSelectedItems(
        HWND hwndList)
{
        //get image list
        HIMAGELIST hImageList=(HIMAGELIST)SendMessage(hwndList,LVM_GETIMAGELIST,
                                        (WPARAM)LVSIL_SMALL,(LPARAM)0);

        int iItems=(int) SendMessage(hwndList,LVM_GETITEMCOUNT,(WPARAM)0,(LPARAM)0);
        UINT uiState=0;
        int i=0;
        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_STATE | LVIF_IMAGE;
        lvi.stateMask = LVIS_SELECTED;

        while(i<iItems){
                lvi.iItem = i;
                SendMessage( hwndList,LVM_GETITEM, (WPARAM)0,(LPARAM)&lvi );
                if(lvi.state&LVIS_SELECTED){

                        //delete item
                        SendMessage(hwndList,LVM_DELETEITEM,(WPARAM)i,(LPARAM)0);
                        
                        iItems--; //decrease item count

                        //delete icon from list
                        //it will change some icon indexes
                        if(lvi.iImage){
                                if(ImageList_Remove(hImageList,lvi.iImage)){
                                        //decrement icon indexes of all items down the list
                                        //(items may be sorted in any order)
                                        int iDeletedImage=lvi.iImage;
                                        lvi.mask=LVIF_IMAGE;
                                        for(int j=0;j<iItems;j++)
                                        {
                                                
                                                lvi.iItem=j;
                                                SendMessage( hwndList,LVM_GETITEM, (WPARAM)0,(LPARAM)&lvi );
                                                if(lvi.iImage>iDeletedImage)
                                                        lvi.iImage--;
                                                SendMessage( hwndList,LVM_SETITEM, (WPARAM)0,(LPARAM)&lvi );
                                        }
                                        lvi.mask=LVIF_STATE | LVIF_IMAGE;//restore mask
                                }
                                
                        }

                }else{
                        i++;
                }
        }

}

/*++

Routine Description :

        This routine returns number of selected items in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.

        
Return Value :

        number of selected items
                
--*/
int
GetSelectedItemCount(
        HWND hwndList)
{
        return (int) SendMessage( hwndList, LVM_GETSELECTEDCOUNT, (WPARAM) 0, (LPARAM) 0 );
}

/*++

Routine Description :

        This routine returns number of items in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.

        
Return Value :

        number of items
                
--*/
int
GetItemCount(
        HWND hwndList)
{
        return (int) SendMessage( hwndList, LVM_GETITEMCOUNT, (WPARAM) 0, (LPARAM) 0 );
}

/*++

Routine Description :

        This routine finds item with specific text in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN LPCWSTR pwszText - text of the item
        
Return Value :

        ID of found item
        -1 if item is ont found
                
--*/

int
FindItem(
        HWND hwndList,
        LPCWSTR pwszText)
{
        //Get item count
        int iItems=(int) SendMessage(hwndList,LVM_GETITEMCOUNT,(WPARAM)0,(LPARAM)0);

        for(int i=0;i<iItems;i++){
                CItemData* pid=GetItemData(hwndList,i);
                if((pid)&&(!lstrcmpi(pwszText,LPWSTR(*pid)))){
                        return i;
                }
        }

        return -1;
}

/*++

Routine Description :

        This routine deletes item data object wthen the item is going to be deleted.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iItem - item to delete
        
Return Value :

        none
                
--*/
void
OnDeleteItem(
        HWND hwndList,
        int iItem)
{
        CItemData* pid=GetItemData(hwndList,iItem);
        if(pid){
                delete pid;
        }
}

/*++

Routine Description :

        Get CItemData object corresponding to the item.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iItem - item index
        
Return Value :

        pointer ot CItemData object
        NULL - if error
                
--*/
CItemData*
GetItemData(
        HWND hwndList,
        int iItem)
{
        LVITEM lvi;
        ZeroMemory(&lvi,sizeof(lvi));
        lvi.mask=LVIF_PARAM;
        lvi.iItem=iItem;
        if(SendMessage(hwndList,LVM_GETITEM,(WPARAM)0,(LPARAM)&lvi)){
                return (CItemData*)lvi.lParam;
        }else{
                return NULL;
        }
}

/*++

Routine Description :

        This routine compares two items.
        
Arguments :

        LPARAM lParam1 - First item.
        LPARAM lParam2 - Second item
        LPARAM lParamSort - parameters
        
Return Value :

        none
                
--*/
int CALLBACK
CompareFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort)
{
        CItemData* pid1=(CItemData*)lParam1;
        CItemData* pid2=(CItemData*)lParam2;
        
        WORD wSubItem=LOWORD(lParamSort);
        WORD wDirection=HIWORD(lParamSort);

        if(wSubItem){
                if(wDirection){
                        return lstrcmpi(pid1->Path(),pid2->Path());
                }else{
                        return -lstrcmpi(pid1->Path(),pid2->Path());
                }
        }else{
                if(wDirection){
                        return lstrcmpi(pid1->Name(),pid2->Name());
                }else{
                        return -lstrcmpi(pid1->Name(),pid2->Name());
                }
        }
}

/*++

Routine Description :

        This routine sorts items.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iSubItem - subitem to sort
        
Return Value :

        none
                
--*/

#define DIRECTION_ASC   0x10000
#define DIRECTION_DESC  0

void
SortItems(
        HWND hwndList,
        WORD wSubItem)
{
        static DWORD fNameSortDirection=DIRECTION_DESC;
        static DWORD fPathSortDirection=DIRECTION_DESC;
        
        WPARAM ParamSort;

        //change direction
        if(wSubItem){
                if(fPathSortDirection){
                        fPathSortDirection=DIRECTION_DESC;
                }else{
                        fPathSortDirection=DIRECTION_ASC;
                }
                ParamSort=fPathSortDirection;
        }else{
                if(fNameSortDirection){
                        fNameSortDirection=DIRECTION_DESC;
                }else{
                        fNameSortDirection=DIRECTION_ASC;
                }
                ParamSort=fNameSortDirection;
        }

        ParamSort+=wSubItem;    
                        
        SendMessage(hwndList,LVM_SORTITEMS,(WPARAM)ParamSort,(LPARAM)CompareFunc);      
}





//////////////////////////////////////////////////////////////////////////////////////
//Message Handlers
//////////////////////////////////////////////////////////////////////////////////////

/*++

Routine Description :

        This routine draws item.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN LPDRAWITEMSTRUCT lpdis
        
Return Value :

        none
                
--*/
void
OnDrawItem(
        HWND hwndList,
        LPDRAWITEMSTRUCT lpdis)
{
    if (lpdis->itemID == -1) {
        return ;
    }
        SetROP2(lpdis->hDC, R2_COPYPEN);

    switch (lpdis->itemAction) {

        case ODA_SELECT:
                        //TRACE("######  SELECTED   #####");
        case ODA_DRAWENTIRE:
                {
                        
                        int     iBkColor,iTxtColor;
                                
                        // Determine the colors
                        if (lpdis->itemState & ODS_SELECTED){
                                iBkColor=COLOR_HIGHLIGHT;
                                iTxtColor=COLOR_HIGHLIGHTTEXT;
                        }else{
                                iBkColor=COLOR_WINDOW;
                                iTxtColor=COLOR_WINDOWTEXT;
                        }
                        
                        //get item data
                        CItemData* pid=GetItemData(hwndList,lpdis->itemID);
                        if(!pid){
                                return;
                        }
                        
                        //Draw Image.
                        // Erase the background
                        HBRUSH hOldBrush=(HBRUSH)SelectObject(lpdis->hDC,
                                CreateSolidBrush( GetSysColor(iBkColor)));
                        PatBlt( lpdis->hDC,
                                        lpdis->rcItem.left,
                                        lpdis->rcItem.top,
                                        lpdis->rcItem.right-lpdis->rcItem.left,
                                        lpdis->rcItem.bottom-lpdis->rcItem.top,
                                        PATCOPY);
                        //Select old brush and delete new one!!!
                        if(hOldBrush)
                        {
                            HBRUSH hTempBrush = (HBRUSH)SelectObject(lpdis->hDC,hOldBrush);
                            if(hTempBrush)
                            {
                                DeleteObject(hTempBrush);
                            }
                        }
                        //get image list
                        HIMAGELIST hImageList=(HIMAGELIST)SendMessage(hwndList,LVM_GETIMAGELIST,
                                        (WPARAM)LVSIL_SMALL,(LPARAM)0);
                        // Draw Image
                        
                        if(SendMessage(hwndList,LVM_GETCOLUMNWIDTH,(WPARAM)0,(LPARAM)0)>
                                (GetSystemMetrics(SM_CXSMICON)+2)){
                                ImageList_Draw(
                                                hImageList,
                                                pid->GetImage(),
                                                lpdis->hDC,
                                                lpdis->rcItem.left+2,
                                                lpdis->rcItem.top,
                                                ILD_TRANSPARENT);
                        }
                        
                        /*
                        LOGFONT lf;
                        HFONT hOldFont=(HFONT)GetCurrentObject(lpdis->hDC,OBJ_FONT);
                        GetObject(hOldFont,sizeof(LOGFONT),&lf);
                        lf.lfHeight=lpdis->rcItem.bottom-lpdis->rcItem.top;
                        HFONT hNewFont=CreateFontIndirect(&lf);
                        SelectObject(lpdis->hDC,hNewFont);
                        */
                        SetTextColor(lpdis->hDC,GetSysColor(iTxtColor));

                        int width=0;
                        RECT CellRect;
                        int nColumns=2;//we have 2 columns
            for(int i=0;i<nColumns;i++)
                        {
                                if(i==0)//for first column we have icon
                                        CellRect.left=lpdis->rcItem.left+GetSystemMetrics(SM_CXSMICON)+4;
                                else
                                        CellRect.left=lpdis->rcItem.left+width+2;
                                CellRect.top=lpdis->rcItem.top;
                                width+=(int) SendMessage(hwndList,LVM_GETCOLUMNWIDTH,(WPARAM)i,(LPARAM)0);
                                CellRect.right=lpdis->rcItem.left+width;
                                CellRect.bottom=lpdis->rcItem.bottom;
                                if(i==0){
                                        DrawText(lpdis->hDC,pid->Name(),-1,&CellRect,DT_VCENTER|DT_END_ELLIPSIS);
                                }else{
                                        DrawText(lpdis->hDC,pid->Path(),-1,&CellRect,DT_VCENTER|DT_END_ELLIPSIS);
                                }
                        }
                        
                        /*
                        SelectObject(lpdis->hDC,hOldFont);
                        DeleteObject(hNewFont);
                        */
                        // Draw the Focus rectangle
                        /*
                        if (lpdis->itemState & ODS_FOCUS){
                                DrawFocusRect(lpdis->hDC,&lpdis->rcItem);
                        }
                        */
            break;
                }

        case ODA_FOCUS:
                        //TRACE("######  FOCUSED   #####");
            /*
             * Do not process focus changes. The focus caret
             * (outline rectangle) indicates the selection.
             * The Which one? (IDOK) button indicates the final
             * selection.
             */

            break;
                default:
                        break;
    }

}

void
AdjustColumns(
        HWND hwndList)
{
        SendMessage(hwndList,LVM_SETCOLUMNWIDTH,(WPARAM)0,(LPARAM)LVSCW_AUTOSIZE_USEHEADER);
        SendMessage(hwndList,LVM_SETCOLUMNWIDTH,(WPARAM)1,(LPARAM)LVSCW_AUTOSIZE_USEHEADER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\dll\appsecdll.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :   
    
    appsecdll.c
    
Abstract :

    Exports a function CreateProcessNotify - this function decides whether
    the new process can be created.
    
Revision History :

    Sep 2000 - added support for Short File Names; PowerUsers not affected by AppSec - SriramSa    
    
Author :

    Sriram Sampath (SriramSa) June 1999
    
--*/        


#include "pch.h"
#pragma hdrstop

#include "appsecdll.h"

BOOL APIENTRY 
DllMain (
    HANDLE hInst, 
    DWORD ul_reason, 
    LPVOID lpReserved
    )
    
{

    switch (ul_reason) {
    
        case DLL_PROCESS_ATTACH : 

            // Disable Thread Lib calls - performance optimisation
            
            DisableThreadLibraryCalls (hInst);
            break ; 
            
        case DLL_PROCESS_DETACH :
        
            break ;
            
    } // end of switch
    
    return 1 ;

    UNREFERENCED_PARAMETER(hInst) ;
    UNREFERENCED_PARAMETER(lpReserved) ;

}

/*++

Routine Description :

    This routine determines if a process can be created based on whether
    it is a system process and if the user is an admin or not.
    
Arguments :

    lpApplicationName - process name
    Reason - the reason this CreateProcessNotify is called  

Return Value :

    STATUS_SUCCESS if the process can be created ; 
    STATUS_ACCESS_DEINIED if the process cannot be created.
    
--*/     

NTSTATUS 
CreateProcessNotify ( 
    LPCWSTR lpApplicationName,
    ULONG Reason 
    ) 
    
{
    
    INT         size ; 
    HKEY        TSkey, list_key, learn_key ;
    WCHAR       g_szSystemRoot[MAX_PATH] ;
    WCHAR       CurrentProcessName[MAX_PATH] ;
    WCHAR       LongApplicationName[MAX_PATH] ; 
    WCHAR       CorrectAppName[MAX_PATH] ; 
    WCHAR       ResolvedAppName[MAX_PATH] ;  
    BOOL        is_taskman = FALSE , is_system = FALSE ; 
    BOOL        check_flag = FALSE, taskman_flag = FALSE, add_status ; 
    BOOL        IsAppSecEnabled = TRUE ; 
    DWORD       is_enabled = 0, learn_enabled = 0, PowerUserEnabled = 0; 
    DWORD       dw, disp, error_code, CurrentSessionId, RetValue, dwTimeOut = 1000; 
    
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS    Status, QueryStatus;
        
    BOOL        IsMember, IsAnAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID        AdminSid = FALSE ;
    
    if ( Reason != APPCERT_IMAGE_OK_TO_RUN ) {
        return STATUS_SUCCESS ;
    }

    // First Check if the fEnabled key to see if Security is Enabled
    // This is done by checking the fEnabled key in the Registry

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, 
            APPS_REGKEY,
            0, 
            KEY_READ, 
            &TSkey
            ) != ERROR_SUCCESS ) {

        return STATUS_SUCCESS ; 
        
    }
    
    size = sizeof(DWORD) ; 

    if ( RegQueryValueEx(
            TSkey,
            FENABLED_KEY, 
            NULL, 
            NULL,
            (LPBYTE) &is_enabled, 
            &size
            ) != ERROR_SUCCESS ) {
        
        goto error_cleanup ; 
        
    }
    
    if (is_enabled == 0) {
        
        // Security is not Enabled

        IsAppSecEnabled = FALSE ;     
        
    }

    // Check if the PowerUsers key in the registry is Enabled or not
    if ( RegQueryValueEx(
        TSkey,
        POWER_USERS_KEY, 
        NULL, 
        NULL,
        (LPBYTE) &PowerUserEnabled, 
        &size
        ) != ERROR_SUCCESS ) {

        PowerUserEnabled = 0;
    }
    
    //
    // Check if the process which is trying to launch the new process is a system process. 
    // This is done by querying the Token information of the current process and 
    // comparing it's LUID with the LUID of a Process running under system context.
    //

    Status = NtOpenProcessToken( 
                NtCurrentProcess(),
                TOKEN_QUERY,
                &TokenHandle 
                );
                                         
    if ( !NT_SUCCESS(Status) ) {
            is_system = TRUE ; 
    }

    if ( ! is_system ) {

        QueryStatus = NtQueryInformationToken( 
                          TokenHandle, 
                          TokenStatistics, 
                          &TokenInformation,
                          sizeof(TokenInformation), 
                          &ReturnLength 
                          );
                      
        if ( !NT_SUCCESS(QueryStatus) ) {
            goto error_cleanup ; 
        }
                          

        NtClose(TokenHandle);

        RtlCopyLuid(
            &CurrentLUID,
            &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId)
            );

        //
        // If the process is running in System context, 
        // we allow it to be created without further check
        // The only exception to this is, we do not allow WinLogon to launch TaskManager 
        // unless it is in the authorized list
        //
                    
        if ( RtlEqualLuid(
                &CurrentLUID, 
                &SystemLUID
                ) ) {
                
            is_system = TRUE ;

        }

    }
            
    // Check if Task Manager is spawned by a System Process

    if (is_system) {

        GetEnvironmentVariable( L"SystemRoot", g_szSystemRoot, MAX_PATH ) ;
        swprintf(CurrentProcessName, L"%s\\System32\\taskmgr.exe", g_szSystemRoot ) ; 

        if ( _wcsicmp( CurrentProcessName, lpApplicationName ) != 0 ) {
               
            goto error_cleanup ;

        } 

    }
        
    //
    // if not a system Process check if the user is a Administrator 
    // This is done by comparing the SID of the current user to that of an Admin
    //

    if ( NT_SUCCESS(
            RtlAllocateAndInitializeSid(
                &SystemSidAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdminSid
                ) 
            ) ) {
            
        if ( CheckTokenMembership( 
                 NULL,
                 AdminSid,
                 &IsAnAdmin
                 ) == 0 )   {
                
            goto error_cleanup ; 
            
        }       
          
        RtlFreeSid(AdminSid);
        
    }

    //
    // If the user is an Admin, see if we are in the Tracking mode
    // We are in Tracking mode if the LearnEnabled Flag in Registry contains the Current Session ID 
    //
        
    if (IsAnAdmin == TRUE ) {

        // Check the LearnEnabled flag to see if Tracking mode 
            
        if ( RegOpenKeyEx(
                HKEY_CURRENT_USER, 
                LIST_REGKEY,
                0, 
                KEY_READ, 
                &learn_key
                ) != ERROR_SUCCESS ) {
               
            goto error_cleanup ;     
        
        }
            
        if ( RegQueryValueEx(
                learn_key,
                LEARN_ENABLED_KEY, 
                NULL, 
                NULL,
                (LPBYTE) &learn_enabled, 
                &size
                ) != ERROR_SUCCESS ) {
            
        
            RegCloseKey(learn_key) ;
            goto error_cleanup ;  
        
        }
            
        RegCloseKey(learn_key) ; 
            
        if (learn_enabled == -1) {
              
            // Tracking is not enabled 
                
            goto error_cleanup ; 
                
        } else {
            
            // Tracking is enabled
            // now get current session and see if it is the same as
            // the one in which tracking is enabled
                   
            // Get CurrentSessionId
    
            if ( ProcessIdToSessionId( 
                    GetCurrentProcessId(), 
                    &CurrentSessionId 
                    ) == 0 ) {

                goto error_cleanup ; 
            }    
                
            if (learn_enabled != CurrentSessionId) {

                // dont add to the list of tracked applications
                    
                goto error_cleanup ;    
            }       
                
            // Tracking phase is enabled - build the list 
            // add this process name to the AppList registry
              
            // Create the Mutex for Synchronization when adding to list
            
            g_hMutex = CreateMutex(
                           NULL, 
                           FALSE,
                           MUTEX_NAME
                           ) ; 
    
            if (g_hMutex == NULL) {
                goto error_cleanup ; 
            }
    
            // Wait to Enter the Critical Section - wait for a max of 1 minute
  
            dw = WaitForSingleObject(g_hMutex, dwTimeOut) ; 
                
            if (dw == WAIT_OBJECT_0) {
                
                //
                // Create the Registry Key which will hold the applications tracked 
                // during tracking period
                //

                if ( RegCreateKeyEx(
                        HKEY_CURRENT_USER, 
                        LIST_REGKEY,
                        0, 
                        NULL, 
                        REG_OPTION_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL, 
                        &list_key, 
                        &disp
                        ) != ERROR_SUCCESS) {

                    ReleaseMutex(g_hMutex) ; 
                    CloseHandle(g_hMutex) ; 
                    goto error_cleanup ; 
       
               }
                    
               // Add this application name to the list in registry 
                
               add_status = add_to_list (
                                list_key, 
                                lpApplicationName 
                                ) ; 
                
            } // Done adding to the list
                
            ReleaseMutex(g_hMutex) ; 
                
            // Out of the Critical Section

            CloseHandle(g_hMutex) ;
            RegCloseKey(list_key) ; 
            goto error_cleanup ; 
                    
        } // ending of Tracking phase
        
    } // User is an admin 
        
    // Check if user is a PowerUser
    if ((PowerUserEnabled == 1) && (IsPowerUser())) {
        goto error_cleanup ; 
    }

    // User is not an admin - also it is not a system process 

    // Check if AppSec is enabled - if yes check the authorized list of apps

    if (IsAppSecEnabled == FALSE) {
    
        // AppSec is not enabled - so no need to check the authorized list of apps

        goto error_cleanup ;

    }
        
    // The filename may be in a short form - first convert it into the long form

    RetValue = GetLongPathNameW( (LPCWSTR) lpApplicationName, LongApplicationName, MAX_PATH) ;  
    if (RetValue == 0) {
        // error - so use the original app name, not the long one
        wcscpy(CorrectAppName, lpApplicationName) ; 
    } else { 
        wcscpy(CorrectAppName, LongApplicationName) ; 
    }
    //
    // Resolve Application name - if may reside in a remote server and share
    // 
        
    ResolveName(
        CorrectAppName,
        ResolvedAppName
        ); 
                              
    // Read the AuthorizedApplications List and compare with current Appname 
        
    check_flag = check_list( 
                    TSkey, 
                    ResolvedAppName
                    ) ;
        
    RegCloseKey(TSkey) ;

    //
    // If the current AppName is not in authorized list return ACCESS_DENIED 
        
    if (check_flag == FALSE) {
       
        return STATUS_ACCESS_DENIED ; 
            
    } else {

        return STATUS_SUCCESS ;

    }
    
    //
    // Error cleanup code
    // Close the Registry Key where we store authorized apps and return SUCCESS
    //

    error_cleanup :
    
        RegCloseKey(TSkey) ; 
        return STATUS_SUCCESS; 
    
} // end of CreateProcessNotify 


/*++

Routine Description :

    This routine checks if a process name is in a specified list 
    of authorised applications in the registry.
    
Arguments :
    
    hkey - The handle to the registry key which has the list of 
    authorised applications.
           
    appname - name of the process               

Return Value :

    TRUE if process is in the list of authorised applications.
    FALSE otherwise.
    
--*/     

BOOL 
check_list( 
    HKEY hkey,
    LPWSTR appname 
    )
    

{
    WCHAR   c ; 
    INT     i, j = 0 ; 
    DWORD   error_code ; 
    DWORD   RetValue ; 
    LONG    value,size = 0 ; 
    BOOL    found = FALSE ;
    WCHAR   *buffer_sent, *app ; 
    WCHAR   LongAppName[MAX_PATH] ; 
    WCHAR   AppToCompare[MAX_PATH] ; 

    // First find out size of buffer to allocate 
    // This buffer will hold the authorized list of apps
    
    if ( RegQueryValueEx(
            hkey, 
            AUTHORIZED_APPS_LIST_KEY,
            NULL, 
            NULL,
            (LPBYTE) NULL,
            &size
            ) != ERROR_SUCCESS ) {

        return TRUE ; 
    }
    
    buffer_sent = (WCHAR *) malloc ( size * sizeof(WCHAR)) ; 
    
    if (buffer_sent == NULL) {
        return TRUE ;
    }
    
    app = (WCHAR *) malloc ( size * sizeof(WCHAR)) ;     
    
    if (app == NULL) {
        free(buffer_sent) ; 
        return TRUE ;
    }
    
    memset(buffer_sent, 0, size * sizeof(WCHAR) ) ; 
    memset(app, 0, size * sizeof(WCHAR) ) ; 

    // Get the List of Authorized applications from the Registry 
    
    if ( RegQueryValueEx(
            hkey, 
            AUTHORIZED_APPS_LIST_KEY, 
            NULL, 
            NULL,
            (LPBYTE) buffer_sent,
            &size
            ) != ERROR_SUCCESS ) {

        free(buffer_sent) ;
        free(app) ; 
        return TRUE ; 
    }
    
    // check if the process is present in the Authorized List
    
    for(i=0 ; i <= size-1 ; i++ ) {

        // check for end of list
        
        if ( (buffer_sent[i] == L'\0') &&
                (buffer_sent[i+1] == L'\0') ) {
             
            break ; 
        }
        
        while ( buffer_sent[i] != L'\0' ) {
        
            app[j++] = buffer_sent[i++] ;
            
        }
                
        app[j++] = L'\0' ; 
        // The filename may be in a short form - first convert it into the long form
        RetValue = GetLongPathNameW( (LPCWSTR) app, LongAppName, MAX_PATH) ;  
        if (RetValue == 0) {
            // GetLongPathNameW failed for an app in the authorized list
            // maybe the file in the authorized list doesn't exist anymore
            wcscpy( AppToCompare, app) ; 
        } else { 
            wcscpy(AppToCompare, LongAppName) ; 
        }

        // Compare if this app is the one that is being queried now

        if ( _wcsicmp(appname, AppToCompare) == 0 ) {
        
            // this process is present in the Authorized List
            found = TRUE ; 
            break ; 
        }
        
        j = 0 ; 
        
    } // end of for loop 
    
    free(buffer_sent) ;
    free(app) ; 
    
    return(found) ; 
   
} // end of function 


/*++

Routine Description :

    This routine appends a process name to a list maintained in 
    Registry Key - used in Tracking mode.
    
Arguments :
    
    hkey - The handle to the registry key which has the list of 
           applications tracked.
           
    appname - name of the process               

Return Value :

    TRUE if process is appended successfully.
    FALSE otherwise.
    
--*/     

BOOL
add_to_list(
    HKEY hkey,
    LPCWSTR appname 
    )
    
{
    
    WCHAR   c ; 
    INT     i, j = 0 ; 
    UINT    k ; 
    DWORD   error_code ; 
    BOOL    status = FALSE ; 
    LONG    value, size = 0, new_size ; 
    WCHAR   *buffer_got, *buffer_sent ; 

    // First find out size of buffer to allocate 
    // This buffer will hold the applications which are tracked 
    
    if ( RegQueryValueEx(
            hkey, 
            TRACK_LIST_KEY, 
            NULL, 
            NULL,
            (LPBYTE) NULL,
            &size
            ) != ERROR_SUCCESS ) {
            
        return (status) ; 
    }

    buffer_got = (WCHAR *) malloc ( size * sizeof(WCHAR)) ; 
    if (buffer_got == NULL) {
        return (status);
    }
    
    memset(buffer_got, 0, size * sizeof(WCHAR) ) ;
    // Get the present list of tracked processes in buffer_got 
    
    if ( RegQueryValueEx(
            hkey, 
            TRACK_LIST_KEY,
            NULL,
            NULL,
            (LPBYTE) buffer_got,
            &size
            ) != ERROR_SUCCESS ) {
            
        free(buffer_got) ; 
        return (status) ; 
    }
    
    // Append the present process to the track list 
    // Prepare buffer to hold it
    // Size of new buffer will be the sum of the old buffer size
    // and the size of the new application + one byte for the terminating NULL char (in bytes)
    //
    
    new_size = size + (wcslen(appname) + 1) * sizeof(WCHAR) ; 
    
    buffer_sent = (WCHAR *) malloc (new_size) ; 
    
    if (buffer_sent == NULL) {
        free(buffer_got) ;
        return (status);
    }
    
    memset( buffer_sent, 0, new_size ) ; 
    
    // check if this is the FIRST entry
    // If so size will be 2 - corresponding to 2 NULL chars in a empty list
    
    if ( size == 2 ) {
    
        // this is the first entry 
        
        wcscpy(buffer_sent,appname) ;
        j = wcslen(buffer_sent) ; 
        j++ ; 
        buffer_sent[j] = L'\0' ;
        
    } else {
    
        // size > 2 - append this process to the end of track list  
    
        for(i=0 ; i <= size-1 ; i++ ) {

            if ( (buffer_got[i] == L'\0') && 
                    (buffer_got[i+1] == L'\0') ) {
             
                break ; 
           
            }
                
            buffer_sent[j++] = buffer_got[i] ;               
        
        } // end of for loop 
    
        buffer_sent[j++] = L'\0' ; 
    
        for(k=0 ; k <= wcslen(appname) - 1 ; k++) {
        
            buffer_sent[j++] = (WCHAR) appname[k] ;
            
        }
         
        buffer_sent[j++] = L'\0' ;  
        buffer_sent[j] = L'\0' ;
    
    } // size > 2 
    
    // write the new track list into registry
    
    if ( RegSetValueEx(
            hkey, 
            L"ApplicationList",
            0,
            REG_MULTI_SZ,
            (CONST BYTE *) buffer_sent,
            (j+1) * sizeof(WCHAR) 
            ) != ERROR_SUCCESS ) {
            
        // Free all the buffers which were allocated

        free(buffer_got) ;
        free(buffer_sent) ; 
        return (status) ; 

    }
    
    status = TRUE ; 
    
    // Free the buffers allocated 

    free(buffer_got) ;
    free(buffer_sent) ; 
    
    return(status) ; 
   
} // end of function 


/*++

Routine Description :

    This Routine checks if the application resides in a local drive 
    or a remote network share. If it is a remote share, the UNC path
    of the application is returned.
    
Arguments :
    
    appname - name of the application

Return Value :

    The UNC path of the appname if it resides in a remote server share.
    The same appname if it resides in a local drive.
    
--*/     

VOID 
ResolveName(
    LPCWSTR appname,
    WCHAR *ResolvedName
    )
    
{

    UINT i ; 
    INT length ; 
    WCHAR LocalName[3] ; 
    WCHAR RootPathName[4] ; 
    WCHAR RemoteName[MAX_PATH] ; 
    DWORD size = MAX_PATH ; 
    DWORD DriveType, error_status ; 
    
    //
    // ResolvedName will hold the name of the UNC path of the appname if it is in 
    // a remote server and share

    memset(ResolvedName, 0, MAX_PATH * sizeof(WCHAR)) ; 
    
    // check if appname is a app in local drive or remote server share
   
    // Parse the first 3 chars in appname to get the root directory of the drive 
    // where it resides

    wcsncpy(RootPathName, appname, 3 ) ;
    RootPathName[3] = L'\0';
    
    // Find the type of the Drive where the app is 

    DriveType = GetDriveType(RootPathName) ;

    if (DriveType == DRIVE_REMOTE) {
        
        // Use WNetGetConnection to get the name of the remote share
        
        // Parse the first two chars of the appname to get the local drive 
        // which is mapped onto the remote server and share

        wcsncpy(LocalName, appname, 2 ) ;
        LocalName[2] = L'\0' ; 

        error_status = WNetGetConnection (
                           LocalName,
                           RemoteName,
                           &size
                           ) ;     

        if (error_status != NO_ERROR) {
        
            wcscpy(ResolvedName,appname) ; 
            return ;
        }
        
        //
        // Prepare ResolvedName - it will contain the Remote Server and Share name 
        // followed by a \ and then the appname
        //

        wcscpy( ResolvedName, RemoteName ) ;
        
        length = wcslen(ResolvedName) ;

        ResolvedName[length++] = L'\\' ; 
        
        for (i = 3 ; i <= wcslen(appname) ; i++ ) {
            ResolvedName[length++] = appname[i] ; 
        }
        
        ResolvedName[length] = L'\0' ; 
        
        return ; 
        

    } else {
    
        // This application is in local drive and not in a remote server and share
        // Just send the appname back to the calling function

        wcscpy(ResolvedName,appname) ; 
        return ;
        
    }
    
}

/*++

Routine Description - This function checks if the present User belongs to the 
group of PowerUser. 

Arguments - none

Return Value - TRUE is the User belongs to the Group of PowerUser
               FALSE if not.

--*/

BOOL 
IsPowerUser(VOID)
{
    BOOL IsMember, IsAnPower;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID PowerSid;

    if (RtlAllocateAndInitializeSid(
            &SystemSidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_POWER_USERS,
            0, 0, 0, 0, 0, 0,
            &PowerSid
            ) != STATUS_SUCCESS) { 
        
        IsAnPower = FALSE;
    } else { 
	
        if (!CheckTokenMembership(
                NULL,
                PowerSid,
                &IsMember)) { 
            IsAnPower = FALSE;
        } else { 
            IsAnPower = IsMember;
        }
        RtlFreeSid(PowerSid);
    }
    return IsAnPower;

}// end of function IsPowerUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\dll\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\dll\appsecdll.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :   
    
    appsecdll.h
    
Abstract :

    Defines the MACROS used in appsecdll.c  
    
Author :

    Sriram (t-srisam) June 1999
    
--*/        

#define APPCERT_IMAGE_OK_TO_RUN     1    
#define APPCERT_CREATION_ALLOWED    2    
#define APPCERT_CREATION_DENIED     3    

#define FENABLED_KEY                L"fEnabled"
#define LEARN_ENABLED_KEY           L"LearnEnabled"
#define AUTHORIZED_APPS_LIST_KEY    L"ApplicationList" 
#define TRACK_LIST_KEY              L"ApplicationList"
#define POWER_USERS_KEY             L"PowerUsers"

#define APPS_REGKEY                 L"System\\CurrentControlSet\\Control\\Terminal Server\\AuthorizedApplications"
#define LIST_REGKEY                 L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"

NTSTATUS    CreateProcessNotify ( LPCWSTR lpApplicationName,ULONG Reason ) ;
BOOL        check_list( HKEY hkey , LPWSTR appname ) ; 
BOOL        add_to_list( HKEY hkey, LPCWSTR appname ) ; 
VOID        ResolveName ( LPCWSTR appname, WCHAR *ResolvedName ) ; 
BOOL        IsPowerUser(VOID); 

HANDLE g_hMutex = NULL ; 

LPCTSTR MUTEX_NAME = L"Global\\CPN_mutex" ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\setup\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppSec.rc
//


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\appsec\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppSec.rc
//
#define IDC_TRACK_LIST                  1000
#define ID_DELETE                       1002
#define ID_DELETE_SELECTED              1003
#define ID_TRACKING                     1004
#define IDC_APP_LIST                    1005
#define ID_ADD                          1006
#define IDC_SECURITY					1007
#define IDC_SECURITY_ENABLED			1008
#define IDC_SECURITY_DISABLED			1009
#define IDC_ADD_PATH					1010
#define ID_BROWSE						1011
#define DLG_MAIN_TITLE					100
#define DLG_ADD							101
#define IDS_FILTERSTRING				900
#define IDS_ERR_LB			            901
#define IDS_ERROR						902
#define IDS_REMOVE						903
#define IDS_DELETE						904
#define IDS_ERR_EXE						905
#define IDS_FILE_ERR					906
#define IDS_ERR_REMOTE					907
#define IDS_NW_ERR						908
#define IDS_ERR_ADMIN					909
#define IDS_SEC_ERROR					910
#define IDS_ADD							911
#define IDS_ADD_CONFIRM					912
#define IDS_ERR_LF 						913
#define IDS_ERR_INSTANCE				914
#define IDS_BROWSE_TITLE				915
#define IDS_START_TRACKING              916
#define IDS_STOP_TRACKING               917
#define IDS_WARNING                     918
#define IDS_WARNING_TEXT                919

#define IDI_APP                         601

#define IDR_ACCELERATORS                103

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2acls\c2aclres.h ===
#define IDC_STATIC                  -1
#define IDS_GENERIC_CAPTION         20001
#define IDS_DLL_NAME                20002
#define IDS_UNABLE_READ             20003    
#define IDS_REGISTRY_ACL_INF        20004
#define IDS_IS                      20005
#define IDS_IS_NOT                  20006
#define IDS_NTFS                    20007
#define IDS_HPFS                    20008
#define IDS_FAT                     20009
#define IDS_NTFS_ACL_INF            20010
#define IDS_REG_ACLS_COMPLY         21001
#define IDS_REG_ACLS_NOT_COMPLY     21002
#define IDS_REG_ACLS_CONFIRM        21003
#define IDS_REG_ACLS_QUERY_SET      21004
#define IDS_REG_ACLS_CAPTION        21005
#define IDS_REG_DISPLAY_FORMAT      21006
#define IDS_NTFS_ACLS_COMPLY        22001
#define IDS_NTFS_ACLS_NOT_COMPLY    22002
#define IDS_NTFS_ACLS_CONFIRM       22003
#define IDS_NTFS_ACLS_QUERY_SET     22004
#define IDS_NTFS_ACLS_CAPTION       22005
#define IDS_NTFS_ACLS_NOT_NTFS      22006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\setup\setup.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :

    setup.h

Abstract :

    Defines the macros used in setup.c
    
Author :

    Sriram (t-srisam) July 1999

--*/

#define APPCERTDLLS_REG_NAME L"System\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls"

#define AUTHORIZEDAPPS_REG_NAME L"System\\CurrentControlSet\\Control\\Terminal Server\\AuthorizedApplications"

#define APPSECDLL_VAL L"AppSecDll" 

#define HELP_MSG_SIZE                       800
                                               
#define IDS_ERROR                           900
#define IDS_ERROR_TEXT                      901
#define IDS_FILE_ALREADY_EXISTS             902
#define IDS_FILE_NOT_FOUND                  903

#define IDS_SUCCESS                         904
#define IDS_SUCCESS_TEXT                    905
#define IDS_REG_ERROR                       906
#define IDS_APPFILE_NOT_FOUND               907
#define IDS_WARNING                         908
#define IDS_HELP_MESSAGE                    909
#define IDS_HELP_TITLE                      910
#define IDS_WARNING_TITLE                   911
#define IDS_ARGUMENT_ERROR                  912
#define IDS_APPS_WARNING                    913
#define IDS_ERROR_LOAD                      914

#define MAX_FILE_APPS                       100
#define AUTHORIZED_APPS_KEY                 L"ApplicationList"
#define FENABLED_KEY                        L"fEnabled"

VOID AddEveryoneToRegKey( WCHAR *RegPath ) ;
BOOL LoadInitApps( HKEY, BOOL, CHAR *) ;
VOID ResolveName ( LPCWSTR appname, WCHAR *ResolvedName ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\arevfix\arevfix.asm ===
;Copyright (c) 1998 - 1999 Microsoft Corporation
page 85,132
;*****************************************************************************
;
;  yielddos.asm
;        DOS TSR to yield when too many get time request float by
;
;  Copyright Citrix Systems Inc. 1993
;
;
;*****************************************************************************


TEXT   segment public  'CODE'

   assume CS:TEXT,DS:TEXT,ES:TEXT,SS:Nothing

   .286p

        ORG     100h
main    proc    far
        jmp     init
main    endp

;**************************************************************************
;   Int21Hook
;
;   Function: Int 21 Handler for yielddos
;
;**************************************************************************
Int21Hook       proc far

        ; move current cmd to previous cmd
        push    ax
        mov     ah,cs:CurrCmd
        mov     cs:PrevCmd,ah
        pop     ax

        ; save current cmd
        mov     cs:CurrCmd,ah

        ; is request get time?
        cmp     ah,2ch
        jne     short NotMine

        ; move current time to previous time
        push    ax
        mov     ax,cs:CurrHourMin
        mov     cs:PrevHourMin,ax
        mov     ax,cs:CurrSec
        mov     cs:PrevSec,ax
        pop     ax

        ; get the current time
        pushf
        call    dword ptr cs:[OldInt21]
        pushf

        ; save the current time
        push    dx
        and     dl,0f0h                 ; look for changes within 16/100 sec
        mov     cs:CurrHourMin,cx
        mov     cs:CurrSec,dx
        pop     dx

        ; was the previous cmd Get Time?
        cmp     cs:PrevCmd,2ch
        jne     short NoYield


        ; are the times the same?
        push    ax
        mov     ax,cs:CurrHourMin
        cmp     ax,cs:PrevHourMin
        pop     ax
        jne     short NoYield
        push    ax
        mov     ax,cs:CurrSec
        cmp     ax,cs:PrevSec
        pop     ax
        jne     short NoYield

        ; yielding if time the same and command repeated
        push    ax
        push    cx
        mov     cx, cs:YieldCount
kbdJ:
        mov     ax,1680h
        int     2fh
        dec     cx
        jnz     kbdJ

        pop     cx
        pop     ax

NoYield:
        popf
        retf    2

NotMine:                                ; send to previous Int 21 handler
        jmp     dword ptr cs:[OldInt21]


Int21Hook       endp


;**************************************************************************
;   Int33Hook
;
;   Function: Int 33 Handler for yielddos
;
;**************************************************************************
Int33Hook       proc far

        ; is request get button status and mouse position
        cmp     ax,0003h
        jne     short NotMine33

        ; get the mouse information
        pushf
        call    dword ptr cs:[OldInt33]
        pushf

        ; Count Int33 func 0003
        inc     cs:Int33Func3

        push    ax
        push    cx
        mov     cx, cs:YieldCount
mouseJ:
        mov     ax,1680h
        int     2fh
        dec     cx
        jnz     mouseJ

        pop     cx
        pop     ax

        popf
        retf    2

NotMine33:                              ; send to previous Int 21 handler
        jmp     dword ptr cs:[OldInt33]


Int33Hook       endp

OldInt21    dd   0              ; Old int 21 handler
OldInt33    dd   0              ; Old int 33 handler
Int33Func3  dw   0              ; Int33Func3 count
CurrCmd     db   0              ; Current Int 21
PrevCmd     db   0              ; Old Int 21
CurrHourMin dw   0              ; Current Hour/minutes
CurrSec     dw   0              ; Current Sec/100th Sec
PrevHourMin dw   0              ; Previous Hour/minutes
PrevSec     dw   0              ; Previous Sec/100th Sec
YieldCount  dw   20             ; Yeild Loop Counter

ORG $ + 15
;*
;* End of resident code and data
;*
ResidentMark label  byte

;*
;* Start of init code and data
;*
init:
        ; save regs
        push    ax
        push    bx
        push    cx
        push    dx
        push    si

        ; command line arg?
        mov     cl, byte ptr ds:[80h]
        cmp     cl, 0
        je      no_arg

        ; set up pointer and counter
        mov     si, 81h
        xor     bx, bx
        jmp     short getfirst

getnum:
        dec     cl
        jz      done

getfirst:
        lodsb
        sub     al, "0"
        jb      not_int
        cmp     al, 9
        ja      not_int

        cbw
        xchg    ax, bx 
        mov     dx, 10  
        mul     dx     
        add     bx, ax

        jmp     getnum

not_int:
        cmp     bx, 0
        je      getnum

done:
        cmp     bx, 0
        je      no_arg
        mov     YieldCount, bx

no_arg:
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax

        ; Hook Interrupt 21
        call    HookInt21

        ; Hook Interrupt 33
        call    HookInt33

StayRes:

        ; Free the environment
        xor     ax, ax
        xchg    ax, word ptr ds:[2ch]           ; get env from PSP
        or      ax, ax
        jz      short skipenv
        push    es
        mov     es, ax
        mov     ah, 49h
        int     21h
        pop     es
skipenv:

        ; Keep program running to catch Int 21 Func 3D requests
        mov     ax, 3100h
        mov     dx, offset ResidentMark
        shr     dx,4
        int     21h

;*****************************************************************************
;*  HookInt21
;*
;*  Function: Hook Interrupt 21 for yielddos
;*
;*  Notes:
;*        Saves the Old Int 21 handler for restoring and calling
;*****************************************************************************
HookInt21       proc    near
        push    es
        push    bx
        push    dx

        mov     ax,3521h                ; get int 21 value
        int     21h
        mov     word ptr [OldInt21],bx
        mov     word ptr [OldInt21]+2,es

        mov     ax,ds
        mov     es,ax
        mov     ax,2521h
        mov     dx, offset Int21Hook
        int     21h

        pop     dx
        pop     bx
        pop     es
        ret
HookInt21       endp

;*****************************************************************************
;*  HookInt33
;*
;*  Function: Hook Interrupt 33 for yielddos
;*
;*  Notes:
;*        Saves the Old Int 33 handler for restoring and calling
;*****************************************************************************
HookInt33       proc    near
        push    es
        push    bx
        push    dx

        mov     ax,3533h                ; get int 21 value
        int     21h
        mov     word ptr [OldInt33],bx
        mov     word ptr [OldInt33]+2,es

        mov     ax,ds
        mov     es,ax
        mov     ax,2533h
        mov     dx, offset Int33Hook
        int     21h

        pop     dx
        pop     bx
        pop     es
        ret
HookInt33       endp

;*
;* Init DATA
;* messages and temporary storage discarded after init
;*

TEXT   ends

end   main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2acls\aclfuncs.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    aclfuncs.c

Abstract:

    This module contians the functions to process the items from the files
    containing the ACL entries for registry keys and files

Author:

    Bob Watson (a-robw) Dec-94

Revision History:

--*/
#ifdef TEST_MODE
#undef TEST_MODE
#endif
//#define TEST_MODE 1

#include <windows.h>
#include <stdio.h>
#include <c2inc.h>
#include <c2dll.h>
#include <c2utils.h>
#include "c2acls.h"
#include "c2aclres.h"
#include "strings.h"

#define FILE_ENTRY  1
#define DIR_ENTRY   2

// internal flag
#define FILE_PATH_SUBDIRS   8

#define NTFS_NOT_STANDARD   0x00000000
#define NTFS_FULL_CONTROL   0x00010001
#define NTFS_CHANGE         0x00010002
#define NTFS_ADD_READ       0x00010003
#define NTFS_READ           0x00010004
#define NTFS_ADD            0x00010005
#define NTFS_LIST           0x00010006
#define NTFS_NO_ACCESS      0x00010007
#define NTFS_NONE           0x00000008
#define NTFS_ALL            0x00000009

#define NTFS_FILE_ALL_ACCESS    (FILE_ALL_ACCESS)
#define NTFS_FILE_CHANGE        (FILE_GENERIC_READ | FILE_GENERIC_WRITE | \
                                 FILE_GENERIC_EXECUTE | DELETE)
#define NTFS_FILE_ADD_READ      (FILE_GENERIC_READ | FILE_GENERIC_WRITE | \
                                 FILE_GENERIC_EXECUTE)
#define NTFS_FILE_READ          (FILE_GENERIC_READ | FILE_GENERIC_EXECUTE)
#define NTFS_FILE_ADD           (FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE)
#define NTFS_FILE_LIST          (FILE_GENERIC_READ | FILE_GENERIC_EXECUTE)
#define NTFS_FILE_NO_ACCESS     (FILE_ALL_ACCESS) /* access denied ace */

#define NTFS_DIR_ALL_ACCESS     (GENERIC_ALL)
#define NTFS_DIR_CHANGE         (GENERIC_READ | GENERIC_WRITE | \
                                GENERIC_EXECUTE | DELETE)
#define NTFS_DIR_ADD_READ       (GENERIC_READ | GENERIC_EXECUTE)
#define NTFS_DIR_READ           (GENERIC_READ | GENERIC_EXECUTE)
#define NTFS_DIR_ADD            (GENERIC_WRITE | GENERIC_EXECUTE)
#define NTFS_DIR_LIST           (GENERIC_READ | GENERIC_EXECUTE)
#define NTFS_DIR_NO_ACCESS      (GENERIC_ALL) /* access denied ace */

#define NTFS_DIR_DIR_FLAGS  (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)
#define NTFS_DIR_FILE_FLAGS (CONTAINER_INHERIT_ACE)
#define NTFS_FILE_FILE_FLAGS    0x00

typedef struct _ACCESS_DECODE {
    LPTSTR  szString;
    DWORD   dwMask;
} ACCESS_DECODE, *PACCESS_DECODE;

#ifdef TEST_MODE
LONG
DumpAclData (
    IN  LPCTSTR                szFileName,
    IN PSECURITY_DESCRIPTOR    psdFile
);
#endif

static ACCESS_DECODE adRegistryDecodeList[] = {
    // specific access
    {TEXT("QV"), (DWORD)KEY_QUERY_VALUE},
    {TEXT("SV"), (DWORD)KEY_SET_VALUE},
    {TEXT("CS"), (DWORD)KEY_CREATE_SUB_KEY},
    {TEXT("ES"), (DWORD)KEY_ENUMERATE_SUB_KEYS},
    {TEXT("NT"), (DWORD)KEY_NOTIFY},
    {TEXT("CL"), (DWORD)KEY_CREATE_LINK},
    // standard rights
    {TEXT("DE"), (DWORD)DELETE},
    {TEXT("RC"), (DWORD)READ_CONTROL},
    {TEXT("WD"), (DWORD)WRITE_DAC},
    {TEXT("WO"), (DWORD)WRITE_OWNER},
    // predefined groups
    {TEXT("NONE"), (DWORD)0},
    {TEXT("FULL"), (DWORD)KEY_ALL_ACCESS},
    {TEXT("READ"), (DWORD)KEY_READ},
    // terminating entry
    {NULL, (DWORD)0}
};

static ACCESS_DECODE adNtfsDecodeList[] = {
    // predefined "combination" access keywords
    {TEXT("FullControl"), (DWORD)NTFS_FULL_CONTROL},
    {TEXT("Change"), (DWORD)NTFS_CHANGE},
    {TEXT("AddRead"), (DWORD)NTFS_ADD_READ},
    {TEXT("Read"), (DWORD)NTFS_READ},
    {TEXT("Add"), (DWORD)NTFS_ADD},
    {TEXT("List"), (DWORD)NTFS_LIST},
    {TEXT("NoAccess"), (DWORD)NTFS_NO_ACCESS},
    // predefined single ACE entries
    {TEXT("NONE"), (DWORD)NTFS_NONE},
    {TEXT("ALL"), (DWORD)NTFS_ALL},
    // terminating entry
    {NULL, (DWORD)0}
};

static
BOOL
DotOrDotDotDir (
    IN  LPCTSTR   szFileName
)
/*++

Routine Description:

    examines the filename in the parameter list to see if it is one
    of the default subdirectories (e.g. the . or the .. dirs). This
    routine assumes that the argument is a filename only. (i.e. NO
    PATH!)

Arguments:

    Filename to compare

Return Value:

    TRUE if filename is either the . or the .. dir
    FALSE if it is any other string

--*/
{
    if (szFileName != NULL) {     // check for null parameter
        if (lstrcmp(szFileName, cszDot) == 0) {
            return TRUE; // it's the . dir
        } else if (lstrcmp(szFileName, cszDotDot) == 0) {
            return TRUE; // it's the .. dir
        } else {
            return FALSE; // it's neither
        }
    } else {
        return FALSE; // null filename, so not a . or .. dir
    }
}

static
BOOL
IsDirectory (
    IN  LPCTSTR szFilePath
)
{
    DWORD   dwAttrib;

    dwAttrib = QuietGetFileAttributes (szFilePath);

    if (dwAttrib != 0xFFFFFFFF) {
        return ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY);
    } else {
        return FALSE;
    }
}

static
ACCESS_MASK
ReadNtfsPermissionString (
    IN  LPCTSTR szPerms,
    IN  BOOL    bDirectory
)
{
    LPCTSTR szThisChar;
    ACCESS_MASK amReturn = 0;

    for (szThisChar = szPerms; *szThisChar != 0; szThisChar++) {
        switch (*szThisChar) {
            case TEXT('R'):
            case TEXT('r'):
                amReturn |= (bDirectory ? GENERIC_READ : FILE_GENERIC_READ);
                break;

            case TEXT('W'):
            case TEXT('w'):
                amReturn |= (bDirectory ? GENERIC_WRITE : FILE_GENERIC_WRITE);
                break;

            case TEXT('X'):
            case TEXT('x'):
                amReturn |= (bDirectory ? GENERIC_EXECUTE : FILE_GENERIC_EXECUTE);
                break;

            case TEXT('D'):
            case TEXT('d'):
                amReturn |= DELETE;
                break;

            case TEXT('P'):
            case TEXT('p'):
                amReturn |= WRITE_DAC;
                break;

            case TEXT('O'):
            case TEXT('o'):
                amReturn |= WRITE_OWNER;
                break;

            default:
                // no change if unrecognized
                break;
        }
    }
    return amReturn;
}

HKEY
GetRootKey (
    IN  LPCTSTR szKeyPath
)
{
    TCHAR   szLocalPath[MAX_PATH];
    LPTSTR  szEndOfRoot;

    lstrcpy (szLocalPath, szKeyPath);
    szEndOfRoot = _tcschr(szLocalPath, cBackslash);
    if (szEndOfRoot != NULL) {
    	*szEndOfRoot = 0;	// null terminate here and use just the chars to the left
        if (lstrcmpi(szLocalPath, cszLocalMachine) == 0) {
            return HKEY_LOCAL_MACHINE;
        } else if (lstrcmpi(szLocalPath, cszClassesRoot) == 0) {
            return HKEY_CLASSES_ROOT;
        } else if (lstrcmpi(szLocalPath, cszCurrentUser) == 0) {
            return HKEY_CURRENT_USER;
        } else if (lstrcmpi(szLocalPath, cszUsers) == 0) {
            return HKEY_USERS;
        } else {
            return NULL;
        }
    } else {
        return NULL;
    }
}

LPCTSTR
GetKeyPath (
    IN  LPCTSTR szKeyPath,
    OUT LPBOOL  pbDoSubKeys
)
{
    static  TCHAR   szLocalPath[MAX_PATH];
    LPTSTR  szEndOfRoot;
    BOOL    bReturn = FALSE;

    szEndOfRoot = _tcschr(szKeyPath, cBackslash);
    if (szEndOfRoot != NULL) {
        // path found
        szEndOfRoot++;  // go to first char after '\'
        // save in local static buffer
        lstrcpy (szLocalPath, szEndOfRoot);
        // now see if this is a recursive key
        szEndOfRoot = _tcschr(szLocalPath, cAsterisk);
        if (szEndOfRoot != NULL) {
            // then this is a recursive path
            bReturn = TRUE;
            szEndOfRoot--;  // go back to backslash
            *szEndOfRoot = 0; // and terminate there
        }
        if (pbDoSubKeys != NULL) {
            *pbDoSubKeys = bReturn;
        }
        return szLocalPath;
    } else {
        // unable to find correct syntax so just return entire string
        if (pbDoSubKeys != NULL) {
            *pbDoSubKeys = FALSE;
        }
        return szKeyPath; // or beginning of path after ROOT key
    }
}

LPCTSTR
GetFilePathFromHeader (
    IN  LPCTSTR szHeaderPath,
    OUT LPDWORD pdwFlags
)
{
    static  TCHAR   szLocalPath[MAX_PATH];
    TCHAR   szLocalWorkPath[MAX_PATH];
    LPTSTR  szEndOfPath;
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   dwReturn = FILE_PATH_NORMAL;

    lstrcpy (szLocalWorkPath, szHeaderPath);
    szEndOfPath = _tcsrchr(szLocalWorkPath, cBang);
    if (szEndOfPath != NULL) {
        // wild card found so remember this and truncate
        szEndOfPath--;  // go to first char before *
        *szEndOfPath = 0; // and terminate there
        dwReturn = FILE_PATH_ALL; // remember to do sub-dirs
    } else {
        // check for wildcard path syntax characters
        szEndOfPath =  _tcschr (szLocalWorkPath, cAsterisk);
        if (szEndOfPath == NULL) {
            // check for  the other wild card char
            szEndOfPath =  _tcschr (szLocalWorkPath, cAsterisk);
        }
        if (szEndOfPath != NULL) {
            // keep the path intact but set the flag
            dwReturn = FILE_PATH_WILD;
        }
        // no wildcard, so assume the path is in the valid syntax
    }
    dwLastError = GetExpandedFileName(
        szLocalWorkPath,
        sizeof(szLocalPath)/sizeof(TCHAR),
        szLocalPath,
        NULL);

    if (dwLastError != ERROR_SUCCESS) {
        SetLastError (dwLastError); // record error
        szLocalPath[0] = 0;          // and clear buffer
    }

    if (pdwFlags != NULL) {
        *pdwFlags = dwReturn; // update the sub dir flag
    }

    return (LPCTSTR)&szLocalPath[0];
}

static
DWORD
DecodeRegAccessEntry (
    IN  LPCTSTR  szAccessEntry
)
{
    PACCESS_DECODE  pEnt;

    for (pEnt = &adRegistryDecodeList[0];
         pEnt->szString != NULL;
         pEnt++) {
        if (lstrcmpi (szAccessEntry, pEnt->szString) == 0) {
            return pEnt->dwMask;
        }
    }
    return 0;   // no entry found
}

static
DWORD
DecodeNtfsAccessEntry (
    IN  LPCTSTR  szAccessEntry
)
{
    PACCESS_DECODE  pEnt;

    for (pEnt = &adNtfsDecodeList[0];
         pEnt->szString != NULL;
         pEnt++) {
        if (lstrcmpi (szAccessEntry, pEnt->szString) == 0) {
            return pEnt->dwMask;
        }
    }
    return NTFS_NOT_STANDARD;   // no entry found
}

static
BOOL
FillAce (
    IN  PACCESS_ALLOWED_ACE paaAce,
    IN  ACCESS_MASK         amAccess,
    IN  BYTE                Type,
    IN  BYTE                Flags,
    IN  PSID                pSid
)
{
    paaAce->Header.AceType = Type;
    paaAce->Header.AceFlags = Flags;
    paaAce->Mask = amAccess;
    CopySid (
        (DWORD)(paaAce->Header.AceSize - (sizeof (ACCESS_ALLOWED_ACE) - sizeof(DWORD))),
        (PSID)(&paaAce->SidStart),
        pSid);
    paaAce->Header.AceSize = (WORD)(GetLengthSid(pSid) +
        (sizeof (ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    return TRUE;
}

static
BOOL
MakeAccessDeniedAce (
    IN  PACCESS_DENIED_ACE  padAce,
    IN  ACCESS_MASK         amAccess,
    IN  BYTE                Flags,
    IN  PSID                pSid
)
{
    padAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    padAce->Header.AceFlags = Flags;
    padAce->Mask = amAccess;
    CopySid (
        (DWORD)(padAce->Header.AceSize - (sizeof (ACCESS_ALLOWED_ACE) - sizeof(DWORD))),
        (PSID)(&padAce->SidStart),
        pSid);
    padAce->Header.AceSize = (WORD)(GetLengthSid(pSid) +
        (sizeof (ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    return TRUE;
}

static
LONG
MakeAceFromRegEntry (
    IN  LPCTSTR  szAccessList,
    IN  PSID    psidUser,
    IN  OUT PACCESS_ALLOWED_ACE pAce
)
/*++

Routine Description:

    interprets the access string list and returns the corresponding
    access mask

Arguments:

    list of access strings to include:


--*/
{
    DWORD    dwIndex = 1;
    LPCTSTR  szItem;

    // see if this is an "inherit" ACE or not

    if (lstrcmpi ((LPTSTR)GetItemFromIniEntry(szAccessList, dwIndex),
            cszInherit) == 0) {
        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE;
        dwIndex++; // go to next entry
    } else {
        pAce->Header.AceFlags = 0;
    }

    // walk down the list to set bits as they are defined.
    szItem = GetItemFromIniEntry (szAccessList, dwIndex);
    while (lstrlen(szItem) > 0) {
        pAce->Mask |= DecodeRegAccessEntry(szItem);
        dwIndex++;
        szItem = (LPTSTR)GetItemFromIniEntry (szAccessList, dwIndex);
    }

    // now to add the sid and set the ace size

    CopySid (
        (DWORD)(pAce->Header.AceSize - sizeof(ACE_HEADER) - sizeof (ACCESS_MASK)),
        (PSID)(&pAce->SidStart),
        psidUser);

    pAce->Header.AceSize = (WORD)GetLengthSid(psidUser) +
                                sizeof(ACE_HEADER) +
                                sizeof(ACCESS_MASK);

    return ERROR_SUCCESS;
}

LONG
MakeAclFromRegSection (
    IN  LPTSTR  mszSection,
    OUT PACL    pAcl
)
/*++

Routine Description:

    interprets the section string as a list of ACE information in the form
    of:
            DOMAIN\ACCOUNT = Access information
    and adds the ACE information to the initialized ACL passed in

Arguments:

    mszSection  msz Buffer of ACE information
    pAcl        pointer to intialized ACL buffer

Return Value:

    WIN32 Error status of function

--*/
{
    LPTSTR  szThisEntry;
    TCHAR   szDomain[MAX_PATH];
    DWORD   dwSidBuffSize;
    DWORD   dwDomainSize;
    SID_NAME_USE    snu;
    PSID    psidAccount = NULL;
    PACCESS_ALLOWED_ACE pAce = NULL;
    LONG    lStatus;

    for (szThisEntry = mszSection;
        *szThisEntry != 0;
        szThisEntry += lstrlen(szThisEntry)+1) {
        psidAccount = GLOBAL_ALLOC (SMALL_BUFFER_SIZE);
        pAce = GLOBAL_ALLOC (MAX_PATH); // this should be plenty big
        if ((psidAccount != NULL) && (pAce != NULL)){
            dwSidBuffSize = SMALL_BUFFER_SIZE;
            dwDomainSize = sizeof(szDomain) / sizeof(TCHAR);
            if (LookupAccountName (
                NULL,       // look up on local machine
                GetKeyFromIniEntry(szThisEntry),
                psidAccount,
                &dwSidBuffSize,
                szDomain,
                &dwDomainSize,
                &snu)) {

                // account found so make an ACE with it
                pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
                pAce->Header.AceFlags = 0;
                pAce->Header.AceSize = MAX_PATH; // initial buffer size
                pAce->Mask = 0; // the mask will be added in the next fn.
                pAce->SidStart = 0; // the sid will be added in the next fn.

                lStatus = MakeAceFromRegEntry (
                    szThisEntry,
                    psidAccount,
                    pAce);

                AddAce (
                    pAcl,
                    ACL_REVISION,
                    MAXDWORD,       // append this ACE to the end of the list
                    (LPVOID)pAce,
                    (DWORD)pAce->Header.AceSize);
            } else {
                // unable to look up name
            }
        } else {
            // unable to allocate SID buffer
        }
        GLOBAL_FREE_IF_ALLOC (psidAccount);
        GLOBAL_FREE_IF_ALLOC (pAce);
    } // end of entry loop
    return ERROR_SUCCESS;
}

static
BOOL
MakeDirAce (
    IN  PACCESS_ALLOWED_ACE pAce,
    IN  PSID    pSid,
    IN  DWORD   dwAccessValue
)
{
    BOOL    bAddAce = TRUE;
    ACCESS_MASK     amAce = 0;
    BYTE            bType = ACCESS_ALLOWED_ACE_TYPE;

    switch (dwAccessValue) {
        case NTFS_FULL_CONTROL:
            amAce = NTFS_DIR_ALL_ACCESS;
            break;

        case NTFS_CHANGE:
            amAce = NTFS_DIR_CHANGE;
            break;

        case NTFS_ADD_READ:
            amAce = NTFS_DIR_ADD_READ;
            break;

        case NTFS_READ:
            amAce = NTFS_DIR_READ;
            break;

        case NTFS_ADD:
            bAddAce = FALSE;
            break;

        case NTFS_LIST:
            bAddAce = FALSE;
            break;

        case NTFS_NO_ACCESS:
            amAce = NTFS_DIR_NO_ACCESS;
            bType = ACCESS_DENIED_ACE_TYPE;
            break;

        default:
            bAddAce = FALSE;
            break;
    }

    if (bAddAce) {
        bAddAce = FillAce (
            pAce,
            amAce,
            bType,
            NTFS_DIR_DIR_FLAGS,
            pSid);
    }

    return bAddAce;
}

static
BOOL
MakeFileAce (
    IN  PACCESS_ALLOWED_ACE pAce,
    IN  PSID    pSid,
    IN  DWORD   dwAccessValue,
    IN  BOOL    bDirectory
)
{
    BOOL    bAddAce = TRUE;
    ACCESS_MASK     amAce = 0;
    BYTE            bType = ACCESS_ALLOWED_ACE_TYPE;

    switch (dwAccessValue) {
        case NTFS_FULL_CONTROL:
            amAce = NTFS_FILE_ALL_ACCESS;
            break;

        case NTFS_CHANGE:
            amAce = NTFS_FILE_CHANGE;
            break;

        case NTFS_ADD_READ:
            if (bDirectory) {
                amAce = NTFS_FILE_ADD_READ;
            } else {
                bAddAce = FALSE;    // not allowed for files
            }
            break;

        case NTFS_READ:
            amAce = NTFS_FILE_READ;
            break;

        case NTFS_ADD:
            amAce = NTFS_FILE_ADD;
            break;

        case NTFS_LIST:
            amAce = NTFS_FILE_LIST;
            break;

        case NTFS_NO_ACCESS:
            amAce = NTFS_FILE_NO_ACCESS;
            bType = ACCESS_DENIED_ACE_TYPE;
            break;

        default:
            bAddAce = FALSE;
            break;
    }

    if (bAddAce) {
        bAddAce = FillAce (
            pAce,
            amAce,
            bType,
            (BYTE)(bDirectory ? NTFS_DIR_FILE_FLAGS : NTFS_FILE_FILE_FLAGS),
            pSid);
    }

    return bAddAce;
}

static
LONG
InterpretNtfsAccessEntry (
    IN  LPCTSTR szThisEntry,
    IN  BOOL    bDirectory,
    IN  PSID    psidAccount,
    OUT PACL    pAcl
)
{
    LONG    lStatus = ERROR_SUCCESS;
    LPCTSTR szAccessString;
    DWORD   dwAccessValue;
    BOOL    bCombinationEntry;      // true if access string makes 2 ace's
    PACCESS_ALLOWED_ACE  pAce;
    ACCESS_MASK amAce;
    BYTE    bAceType;
    BYTE    bAceFlags;
    DWORD   dwAllowedEntries;
    DWORD   dwThisEntry = 1;

    szAccessString = GetItemFromIniEntry (szThisEntry, dwThisEntry);
    dwAccessValue = DecodeNtfsAccessEntry (szAccessString);
    bCombinationEntry = (BOOL)(HIWORD(dwAccessValue) == 1);

    if (bCombinationEntry) {
        // this is a combination entry so if this is a directory
        // we'll make 2 ACE's one for dir access and one to be inherited
        // for file access. If this is a file, then only the file access
        // ace will be created.
        if (bDirectory) {
            // make the directory access ACE for the directory entry
            pAce = (PACCESS_ALLOWED_ACE)GLOBAL_ALLOC(MAX_PATH);
            if (pAce != NULL) {
                if (MakeDirAce (pAce, psidAccount, dwAccessValue)) {
                    // then add ace to acl
                    AddAce (
                        pAcl,
                        ACL_REVISION,
                        MAXDWORD,
                        (LPVOID)pAce,
                        (DWORD)pAce->Header.AceSize);
                }
            }
            GLOBAL_FREE_IF_ALLOC (pAce);    // free this one
        }
        // create the File Access entry
        pAce = (PACCESS_ALLOWED_ACE)GLOBAL_ALLOC(MAX_PATH);
        if (pAce != NULL) {
            if (MakeFileAce (pAce, psidAccount, dwAccessValue, bDirectory)) {
                // then add ace to acl
                AddAce (
                    pAcl,
                    ACL_REVISION,
                    MAXDWORD,
                    (LPVOID)pAce,
                    (DWORD)pAce->Header.AceSize);
            }
        }
        GLOBAL_FREE_IF_ALLOC (pAce);    // free this one
    } else {
        // specific permissions have been specified so process them
        // this is the first entry in the list so it's either the "dir"
        // entry of a directory or a File entry.

        dwAllowedEntries = (bDirectory ? 2 : 1);
        while (dwThisEntry <= dwAllowedEntries) {
            if (lstrlen(szAccessString) > 0) {
                bAceFlags = (bDirectory ? (dwThisEntry == DIR_ENTRY ?
                    NTFS_DIR_DIR_FLAGS : NTFS_DIR_FILE_FLAGS) : NTFS_FILE_FILE_FLAGS);
                bAceType = ACCESS_ALLOWED_ACE_TYPE;
                switch (dwAccessValue) {
                    case NTFS_NONE:
                        amAce = (bDirectory ? NTFS_DIR_NO_ACCESS : NTFS_FILE_NO_ACCESS);
                        bAceType = ACCESS_DENIED_ACE_TYPE;
                        break;

                    case NTFS_ALL:
                        amAce = (bDirectory ? NTFS_DIR_NO_ACCESS : NTFS_FILE_ALL_ACCESS);
                        break;

                    default:
                        amAce = ReadNtfsPermissionString (szAccessString, bDirectory);
                        break;
                }
                pAce = (PACCESS_ALLOWED_ACE)GLOBAL_ALLOC(MAX_PATH);
                if (pAce != NULL) {
                    FillAce (
                        pAce,
                        amAce,
                        bAceType,
                        bAceFlags,
                        psidAccount);

                    AddAce (
                        pAcl,
                        ACL_REVISION,
                        MAXDWORD,
                        (LPVOID)pAce,
                        (DWORD)pAce->Header.AceSize);
                }
                GLOBAL_FREE_IF_ALLOC (pAce);
            }
            if (++dwThisEntry <= dwAllowedEntries)  {
                // get next entry from string
                szAccessString = GetItemFromIniEntry (szThisEntry, dwThisEntry);
            }
        }
    }
    return lStatus;
}

LONG
MakeAclFromNtfsSection (
    IN  LPTSTR  mszSection,
    IN  BOOL    bDirectory, // true if this is for a directory
    OUT PACL    pAcl
)
/*++

Routine Description:

    interprets the section string as a list of ACE information in the form
    of:
            DOMAIN\ACCOUNT = Access information
    and adds the ACE information to the initialized ACL passed in

Arguments:

    mszSection  msz Buffer of ACE information
    pAcl        pointer to intialized ACL buffer

Return Value:

    WIN32 Error status of function

--*/
{
    LPTSTR  szThisEntry;
    TCHAR   szDomain[MAX_PATH];
    DWORD   dwSidBuffSize;
    DWORD   dwDomainSize;
    SID_NAME_USE    snu;
    PSID    psidAccount = NULL;
    LONG    lStatus;

    for (szThisEntry = mszSection;
        *szThisEntry != 0;
        szThisEntry += lstrlen(szThisEntry)+1) {
        psidAccount = GLOBAL_ALLOC (SMALL_BUFFER_SIZE);
        if (psidAccount != NULL) {
            dwSidBuffSize = SMALL_BUFFER_SIZE;
            dwDomainSize = sizeof(szDomain) / sizeof(TCHAR);
            if (LookupAccountName (
                NULL,       // look up on local machine
                GetKeyFromIniEntry(szThisEntry),
                psidAccount,
                &dwSidBuffSize,
                szDomain,
                &dwDomainSize,
                &snu)) {

                lStatus = InterpretNtfsAccessEntry (
                    szThisEntry,
                    bDirectory,
                    psidAccount,
                    pAcl);

            } else {
                // unable to look up name
            }
        } else {
            // unable to allocate SID buffer
        }
        GLOBAL_FREE_IF_ALLOC (psidAccount);
    } // end of entry loop
    return ERROR_SUCCESS;
}

LONG
SetRegistryKeySecurity (
    IN  HKEY                    hkeyRootKey,
    IN  LPCTSTR                 szKeyPath,
    IN  BOOL                    bDoSubKeys,
    IN  PSECURITY_DESCRIPTOR    psdSecurity
)
/*++

Routine Description:

    opens the key in "KeyPath" and set's the key's security. If the
    "bDoSubKeys" flag is set, then all sub keys are set to the same
    security using this routine recursively.

Return Value:

    WIN32 status value of function

--*/
{
    LONG    lStatus;
    HKEY    hkeyThisKey;
    DWORD   dwKeyIndex;
    DWORD   dwSubKeyLen;
    TCHAR   szSubKeyName[MAX_PATH];
    FILETIME    FileTime;

    lStatus = RegOpenKeyEx (
        hkeyRootKey,
        szKeyPath,
        0L,
        KEY_ALL_ACCESS,
        &hkeyThisKey);

    if (lStatus == ERROR_SUCCESS) {
        _tprintf (GetStringResource (GetDllInstance(), IDS_REG_DISPLAY_FORMAT),
                szKeyPath);
        lStatus = RegSetKeySecurity (
            hkeyThisKey,
            DACL_SECURITY_INFORMATION,
            psdSecurity);

        if (bDoSubKeys) {
            dwKeyIndex = 0;
            dwSubKeyLen = sizeof(szSubKeyName) / sizeof(TCHAR);

            while (RegEnumKeyEx (
                hkeyThisKey,
                dwKeyIndex,
                szSubKeyName,
                &dwSubKeyLen,
                NULL,
                NULL,   // don't care about the class
                NULL,   // no class buffer
                &FileTime) == ERROR_SUCCESS) {
                // subkey found so set subkey security
                lStatus = SetRegistryKeySecurity (
                    hkeyThisKey,
                    szSubKeyName,
                    bDoSubKeys,
                    psdSecurity);
                // set variables for next call
                dwKeyIndex++;
                dwSubKeyLen = sizeof(szSubKeyName) / sizeof(TCHAR);
            }
        }
        RegCloseKey (hkeyThisKey);
    } else {
        // unable to open key so return ERROR
    }
    return lStatus;
}

LONG
SetNtfsFileSecurity (
    IN  LPCTSTR szPath,
    IN  DWORD   dwFlags,
    IN  PSECURITY_DESCRIPTOR     pSdDir,
    IN  PSECURITY_DESCRIPTOR     pSdFile
)
{
    LONG            lReturn = ERROR_SUCCESS;
    LONG            lStatus = ERROR_SUCCESS;
    WIN32_FIND_DATA fdThisFile;
    HANDLE          hFileSearch;
    BOOL            bFileFound = FALSE;
    DWORD           dwFlagsToPass;
    LPTSTR          szWildPath;
    TCHAR	    szWildFilePath[MAX_PATH];
    LPTSTR          szWildFileName;

    if ((dwFlags & FILE_PATH_NORMAL) == FILE_PATH_NORMAL) {
        // then just set the security on this path
        if (FileExists(szPath)) {
            if (IsDirectory(szPath)) {
                // then apply directory SD
#ifdef TEST_MODE
                _tprintf (TEXT("\n_DIR: %s"), szPath);
                DumpAclData (szPath, pSdDir);
                lReturn = ERROR_SUCCESS;
#else
                if (!SetFileSecurity(szPath, DACL_SECURITY_INFORMATION, pSdDir)) {
                    lReturn = GetLastError();
                }
#endif
            } else {
                // it's not a dir so apply file SD
#ifdef TEST_MODE
                _tprintf (TEXT("\nFILE: %s"), szPath);
                DumpAclData (szPath, pSdFile);
                lReturn = ERROR_SUCCESS;
#else
                if (!SetFileSecurity(szPath, DACL_SECURITY_INFORMATION, pSdFile)) {
                    lReturn = GetLastError();
                }
#endif
            }
        } else {
#ifdef TEST_MODE
            _tprintf (TEXT("\n_ERR: %s"), szPath);
#endif
            lReturn = ERROR_FILE_NOT_FOUND;
        }
    } else if ((dwFlags & FILE_PATH_WILD) == FILE_PATH_WILD) {
        // the path is (presumably) a wild-card path spec so walk the list
        // of matching files
        // make a local copy of the path preceeding the wildcard chars
        // to build local paths with
        lstrcpy (szWildFilePath, szPath);
        szWildFileName = _tcsrchr(szWildFilePath, cBackslash);	// find last backslash char
        if (szWildFileName == NULL) {
            // no backslash found so add one to the end of the path string
            lstrcat (szWildFilePath, cszBackslash);
            szWildFileName = szWildFilePath + lstrlen(szWildFilePath);
        } else {
            // backslash found so move pointer past it.
            szWildFileName++;
        }
        hFileSearch = FindFirstFile (szPath, &fdThisFile);
        if (hFileSearch != INVALID_HANDLE_VALUE) bFileFound = TRUE;
        while (bFileFound) {
            if (fdThisFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (!DotOrDotDotDir (fdThisFile.cFileName)) {
                    // then if this is dir, do see if we should do all the sub dirs
                    if ((dwFlags & FILE_PATH_SUBDIRS) == FILE_PATH_SUBDIRS) {
                        dwFlagsToPass = FILE_PATH_ALL;
                    } else {
                        dwFlagsToPass = 0;	// do not do in this case
                    }
                } else {
                    // this is a . or a .. dir so ignore
                    dwFlagsToPass = 0;
                }
            } else {
               	// just a file so process as a normal file
                dwFlagsToPass = FILE_PATH_NORMAL;
            }
            if (dwFlagsToPass != 0) {
                // make into a full path string
                lstrcpy (szWildFileName, fdThisFile.cFileName);
                // set the file security of this and any other files
                lStatus = SetNtfsFileSecurity (szWildFilePath, dwFlagsToPass,
                    pSdDir, pSdFile);
                if (lStatus != ERROR_SUCCESS) {
                    // save last "non-success" error for return
                    lReturn = lStatus;
                }
            }
            bFileFound = FindNextFile (hFileSearch, &fdThisFile);
        }
        FindClose (hFileSearch);
    } else if ((dwFlags & FILE_PATH_ALL) == FILE_PATH_ALL) {
        // set the security of this path
        lStatus = SetNtfsFileSecurity (szPath, FILE_PATH_NORMAL,
            pSdDir, pSdFile);
        if (IsDirectory(szPath)) {
            // make a wild card path an pass it do all the files and sub-dirs
            // of this path
            szWildPath = (LPTSTR)GLOBAL_ALLOC(MAX_PATH_BYTES);
            if (szWildPath != NULL) {
                lstrcpy (szWildPath, szPath);
                if (szWildPath[lstrlen(szWildPath)-1] != cBackslash) {
                    lstrcat (szWildPath, cszBackslash);
                }
                lstrcat (szWildPath, cszStarDotStar); // make wild
                // call this routine with both WILD and ALL flags set
                // so all files and sub-dirs will get set.
                lStatus = SetNtfsFileSecurity (szWildPath,
                    (FILE_PATH_WILD | FILE_PATH_SUBDIRS),
                    pSdDir, pSdFile);
                lReturn = lStatus;
            } else {
                lReturn = ERROR_OUTOFMEMORY;
            }
            GLOBAL_FREE_IF_ALLOC (szWildPath);
        } else {
            // path not a dir so just skip the wildcard stuff
        }
    } else {
        // unrecognized flag
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\appsec\setup\setup.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :

    setup.c    

Abstract :

    Setup program for the AppSec tool.
    Setup the Registry keys and gives Read Permission for 'Everyone' to these keys. 
    Also copies the AppSec.dll file to the %SystemRoot%\system32 directory

Revision history : 

    09.02.2000 - Adding support for command line arguments - taking a text file containing
    Authorized Applications and a integer for Enabling Appsec - SriramSa 
    
Returns :

    TRUE if success
    FALSE if failed
    
Author :

    Sriram (t-srisam) July 1999

--*/

#include "pch.h"
#pragma hdrstop

#include "setup.h"
#include "aclapi.h"
#include <accctrl.h>

WCHAR   g_szSystemRoot[MAX_PATH] ;

INT _cdecl main ( INT argc, CHAR *argv[] )
{

    DWORD   Disp, size, error_code ;
    HKEY    AppCertKey, AppsKey ; 
    WCHAR   *AppSecDllPath = L"%SystemRoot%\\system32\\appsec.dll" ;
    WCHAR   *OldFileName = L".\\appsec.dll" ;
    WCHAR   NewFileName[MAX_PATH] ;

    WCHAR   HelpMessage[HELP_MSG_SIZE]; 
    WCHAR   szTitle[MAX_PATH];
    WCHAR   szMsg[MAX_PATH];
    CHAR    FileName[MAX_PATH] ;
    INT     IsEnabled = 0;  // by default AppSec is disabled initially
    BOOL    IsInitialFile = FALSE; // assume no initial file was provided
    BOOL    status, IsNoGUI = FALSE ; 

    // Process the command line arguments
    if (argc > 1) {
        IsInitialFile = TRUE ; 
        strcpy(FileName, argv[1]) ;
        if (argc > 2) {
            IsEnabled = atoi(argv[2]) ; 
        }
        // Check if user does not want any GUI
        if ((argc > 3) && (_stricmp(argv[3], "/N") == 0)) {
            IsNoGUI = TRUE ; 
        }
    }

    // Display Help Message if asked for
    if (strcmp(FileName,"/?") == 0) {
        LoadString( NULL, IDS_HELP_MESSAGE ,HelpMessage, HELP_MSG_SIZE );
        LoadString( NULL, IDS_HELP_TITLE ,szTitle, MAX_PATH );
        MessageBox( NULL, HelpMessage, szTitle, MB_OK);
        return TRUE ; 
    }

    // Check the second argument
    if ((IsEnabled != 0) && (IsEnabled != 1)) {
        LoadString( NULL, IDS_ARGUMENT_ERROR, szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR, szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        return TRUE ; 
    }

    // Display warning message regarding authorized apps already in the Registry
    if (IsNoGUI == FALSE) {
        LoadString( NULL, IDS_WARNING, szMsg, MAX_PATH );
        LoadString( NULL, IDS_WARNING_TITLE ,szTitle, MAX_PATH );
        if ( MessageBox( NULL, szMsg, szTitle, MB_OKCANCEL) == IDCANCEL ) { 
            return TRUE ;
        }
    }

    // Create the AppCertDlls Key 

    if (RegCreateKeyEx( 
          HKEY_LOCAL_MACHINE, 
          APPCERTDLLS_REG_NAME, 
          0,                  
          NULL,
          REG_OPTION_NON_VOLATILE, 
          KEY_ALL_ACCESS,
          NULL, 
          &AppCertKey, 
          &Disp 
          ) != ERROR_SUCCESS ) {
          
        LoadString( NULL, IDS_REG_ERROR ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        return FALSE ;
    
    }

    // After creating the key, give READ access to EVERYONE

    AddEveryoneToRegKey( APPCERTDLLS_REG_NAME ) ;

    // Set the AppSecDll value to the path of the AppSec.dll

    size = wcslen(AppSecDllPath) ; 

    RegSetValueEx(
        AppCertKey,
        APPSECDLL_VAL, 
        0, 
        REG_EXPAND_SZ,
        (CONST BYTE *)AppSecDllPath,
        (size + 1) * sizeof(WCHAR)
        ) ;


    // Create the AuthorizedApplications Key and give Read access to Evereone 

    if (RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            AUTHORIZEDAPPS_REG_NAME,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &AppsKey,
            &Disp
            ) != ERROR_SUCCESS ) {
            
        LoadString( NULL, IDS_REG_ERROR ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        RegCloseKey(AppCertKey) ; 
        return FALSE ;
    }

    // After creating the key, give READ access to EVERYONE

    AddEveryoneToRegKey( AUTHORIZEDAPPS_REG_NAME ) ;

    RegCloseKey(AppCertKey) ;
    GetEnvironmentVariable( L"SystemRoot", g_szSystemRoot, MAX_PATH ) ; 

    // Load the initial set of authorized apps into the Registry

    status = LoadInitApps( AppsKey, IsInitialFile, FileName) ; 
    if (status == FALSE) {
        LoadString( NULL, IDS_APPS_WARNING, szMsg, MAX_PATH );
        LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
    }

    // Set the fEnabled key now

    RegSetValueEx(
        AppsKey, 
        FENABLED_KEY,
        0,
        REG_DWORD,
        (BYTE *) &IsEnabled,
        sizeof(DWORD) );

    RegCloseKey(AppsKey) ;

    // Copy the appsec.dll file to %SystemRoot%\system32 directory

    swprintf(NewFileName, L"%s\\system32\\appsec.dll", g_szSystemRoot ) ;

    if ( CopyFile(
            OldFileName,
            NewFileName,
            TRUE 
            ) == 0 ) {

        error_code = GetLastError() ; 

        // If AppSec.dll already exists in Target Directory, print appropriate Message
        
        if (error_code == ERROR_FILE_EXISTS) {
            if (IsNoGUI == FALSE) {
                LoadString( NULL, IDS_FILE_ALREADY_EXISTS ,szMsg, MAX_PATH );
                LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                MessageBox( NULL, szMsg, szTitle, MB_OK);
            }
            return FALSE ;
        } 

        // If AppSec.dll does not exist in the current directory, print appropriate Message

        if (error_code == ERROR_FILE_NOT_FOUND) {
            LoadString( NULL, IDS_FILE_NOT_FOUND ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
            MessageBox( NULL, szMsg, szTitle, MB_OK); 
            return FALSE ;

        }

        LoadString( NULL, IDS_ERROR_TEXT ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);

        return FALSE ;  
    }
 
    // File was copied successfully - Installation was successful 
    if (IsNoGUI == FALSE) {
        LoadString( NULL, IDS_SUCCESS_TEXT ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_SUCCESS ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
    }

    return TRUE ; 

}

/*++

The following two functions are used to change the permissions of the 
relevant Regsitry Keys, to give READ access to everyone, to take
care of Guest users.

--*/

BOOL
AddSidToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL            fReturn = FALSE;
    DWORD           dwRet;
    EXPLICIT_ACCESS ExpAccess;
    PACL            pOldDacl = NULL, pNewDacl = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    //
    //  pSid cannot be NULL.
    //

    if (pSid == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    //  Get the objects security descriptor and current DACL.
    //

    dwRet = GetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                &pOldDacl,
                NULL,
                &pSecDesc
                );

    if (dwRet != ERROR_SUCCESS) {
        return(FALSE);
    }

    //
    //  Initialize an EXPLICIT_ACCESS structure for the new ACE.
    //

    ZeroMemory(&ExpAccess, sizeof(EXPLICIT_ACCESS));
    ExpAccess.grfAccessPermissions = dwNewAccess;
    ExpAccess.grfAccessMode = AccessMode;
    ExpAccess.grfInheritance = dwInheritance;
    ExpAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExpAccess.Trustee.ptstrName = (PTSTR)pSid;

    //
    //  Merge the new ACE into the existing DACL.
    //

    dwRet = SetEntriesInAcl(
                1,
                &ExpAccess,
                pOldDacl,
                &pNewDacl
                );

    if (dwRet != ERROR_SUCCESS) {
        goto ErrorCleanup;
    }

    //
    //  Set the new security for the object.
    //

    dwRet = SetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                pNewDacl,
                NULL
                );

    if (dwRet != ERROR_SUCCESS) {
        goto ErrorCleanup;
    }

    fReturn = TRUE;

ErrorCleanup:
    if (pNewDacl != NULL) {
        LocalFree(pNewDacl);
    }

    if (pSecDesc != NULL) {
        LocalFree(pSecDesc);
    }

    return(fReturn);
}


VOID
AddEveryoneToRegKey(
    WCHAR *RegPath
    )
{
    HKEY hKey;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SepWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    LONG status ; 

    status = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegPath,
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if (status != ERROR_SUCCESS) {
        return ; 
    }

    AllocateAndInitializeSid(
        &SepWorldAuthority,
        1,
        SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pSid
        );

    AddSidToObjectsSecurityDescriptor(
        hKey,
        SE_REGISTRY_KEY,
        pSid,
        KEY_READ,
        GRANT_ACCESS,
        CONTAINER_INHERIT_ACE
        );

    LocalFree(pSid);
    RegCloseKey(hKey);
}

/*++

Routine Description : 
    This function loads a initial set of authorized applications to the registry.
    
Arguments : 
    AppsecKey - Key to the registry entry where authorized applications are stored
    IsInitialFile - Was a initial file given as command line argument to load applications
                    other than the default ones
    FileName - Name of the file given as command line argument
    
Return Value :         
    A BOOL indicating if the desired task succeeded or not.

--*/        

BOOL LoadInitApps( 
        HKEY AppsecKey, 
        BOOL IsInitialFile, 
        CHAR *FileName
        ) 
{ 

    FILE    *fp ; 
    INT     MaxInitApps ; 
    WCHAR   *BufferWritten ; 
    INT     BufferLength = 0 ; 
    WCHAR   AppsInFile[MAX_FILE_APPS][MAX_PATH] ;
    CHAR    FileRead[MAX_PATH] ;         
    INT     size, count = 0, NumOfApps = 0 ;
    INT     i, j, k ; 
    BOOL    IsFileExist = TRUE ; 
    WCHAR   InitApps[MAX_FILE_APPS][MAX_PATH]; 
    WCHAR   szMsg[MAX_PATH], szTitle[MAX_PATH]; 
    WCHAR   ResolvedAppName[MAX_PATH];
    DWORD   RetValue; 

    //  Below is the list of default (necessary) applications
    LPWSTR DefaultInitApps[] = {
        L"system32\\loadwc.exe",
        L"system32\\cmd.exe",
        L"system32\\subst.exe",
        L"system32\\xcopy.exe",
        L"system32\\net.exe",
        L"system32\\regini.exe",
        L"system32\\systray.exe",
        L"explorer.exe",
        L"system32\\attrib.exe",
        L"Application Compatibility Scripts\\ACRegL.exe",
        L"Application Compatibility Scripts\\ACsr.exe",
        L"system32\\ntsd.exe",
        L"system32\\userinit.exe",
        L"system32\\wfshell.exe",
        L"system32\\chgcdm.exe",
        L"system32\\nddeagnt.exe",

    };


    MaxInitApps = sizeof(DefaultInitApps)/sizeof(DefaultInitApps[0]) ; 
    
    // Prefix the default apps with %SystemRoot% 
    for (i = 0; i < MaxInitApps; i++) {
        swprintf(InitApps[i], L"%ws\\%ws", g_szSystemRoot, DefaultInitApps[i]);
    }

    // Calculate the size of buffer to allocate to hold initial apps
    for (i = 0; i < MaxInitApps; i++) {
        BufferLength += wcslen(InitApps[i]) ; 
    }

    BufferLength += MaxInitApps ; // for the terminating NULLS
    
    if (IsInitialFile == FALSE) {
        BufferLength += 1 ; //last terminating NULL in REG_MULTI_SZ
    } else { 
        // A initial file was given to us 
        fp = fopen(FileName, "r") ;
        if (fp == NULL) {
            // Display a Message Box saying Unable to open the file
            // Just load the default apps and return
            LoadString( NULL, IDS_APPFILE_NOT_FOUND ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
            MessageBox( NULL, szMsg, szTitle, MB_OK);
            IsFileExist = FALSE ; 
        } else { 
            // build the array AppsInFile after UNICODE conversion
            while( fgets( FileRead, MAX_PATH, fp) != NULL ) { 
                FileRead[strlen(FileRead)- 1] = '\0' ;
                // Convert from Short to Long name
                if ( GetLongPathNameA((LPCSTR)FileRead, FileRead, MAX_PATH) == 0 ) { 
                    // GetLongPathName returns error
                    // some problem with the app listed in the file
                    // Terminate further handling of apps in the file
                    LoadString( NULL, IDS_ERROR_LOAD, szMsg, MAX_PATH );
                    LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
                    MessageBox( NULL, szMsg, szTitle, MB_OK);
                    break;
                }
                // Convert to UNICODE format
                // Get the size of the buffer required first
                size = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        FileRead,
                        -1,
                        NULL,
                        0) ;
                if (size  > MAX_PATH) {
                    // Something is wrong in the list of apps in the File 
                    // Terminate further handling of apps in the file
                    LoadString( NULL, IDS_ERROR_LOAD, szMsg, MAX_PATH );
                    LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
                    MessageBox( NULL, szMsg, szTitle, MB_OK);
                    break; 
                } else {
                    MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        FileRead,
                        -1,
                        AppsInFile[count],
                        MAX_PATH) ;
                    count++ ; 
                }
            }
            fclose(fp) ; 
            NumOfApps = count ; 
            
            // Now any of these apps may be in remote Server and Share - so resolve them into UNC names
            // Copy the resolved names back into the same buffer

            for(i = 0; i < NumOfApps; i++) { 
                ResolveName((LPCWSTR)AppsInFile[i], ResolvedAppName) ; 
                wcscpy(AppsInFile[i], ResolvedAppName); 
            }

            // Continue calculation of BufferLength
            for (i = 0; i < NumOfApps; i++) {
                BufferLength += wcslen(AppsInFile[i]) ; 
            }
            BufferLength += NumOfApps ; // for the Terminating NULLs in REG_MULTI_SZ
            BufferLength += 1 ; // for the last NULL char in REG_MULTI_SZ 
        }
    }
    
    BufferWritten = (WCHAR *) malloc (BufferLength * sizeof(WCHAR)) ; 
    if (BufferWritten == NULL) {
        return FALSE ; 
    }
    memset(BufferWritten, 0, BufferLength * sizeof(WCHAR)) ; 

    // Build the LPWSTR BufferWritten with Initial Default Apps
    j = 0 ; 
    for (i = 0; i < MaxInitApps; i++) {
        for(k = 0 ; k < (int) wcslen(InitApps[i]); k++) {
            BufferWritten[j++] = InitApps[i][k]; 
        }
        BufferWritten[j++] = L'\0' ;
    }
    if (IsInitialFile && IsFileExist ) {
        for (i = 0; i < NumOfApps; i++) {
            for(k = 0 ; k < (int) wcslen(AppsInFile[i]); k++) {
                BufferWritten[j++] = AppsInFile[i][k]; 
            }
            BufferWritten[j++] = L'\0' ;
        }
    }
    BufferWritten[j] = L'\0' ; // Last NULL char in REG_MULTI_SZ

    // Write this Buffer into the Registry Key
    
    if ( RegSetValueEx(
            AppsecKey, 
            AUTHORIZED_APPS_KEY,
            0,
            REG_MULTI_SZ,
            (CONST BYTE *) BufferWritten,
            (j+1) * sizeof(WCHAR) 
            ) != ERROR_SUCCESS ) {
            
        // Free all the buffers which were allocated
        free(BufferWritten) ;
        return FALSE ;
    }

    free(BufferWritten) ; 
    return TRUE ;

}// end of function LoadInitApps

/*++

Routine Description :

    This Routine checks if the application resides in a local drive 
    or a remote network share. If it is a remote share, the UNC path
    of the application is returned.
    
Arguments :
    
    appname - name of the application

Return Value :

    The UNC path of the appname if it resides in a remote server share.
    The same appname if it resides in a local drive.
    
--*/     

VOID 
ResolveName(
    LPCWSTR appname,
    WCHAR *ResolvedName
    )
    
{

    UINT i ; 
    INT length ; 
    WCHAR LocalName[3] ; 
    WCHAR RootPathName[4] ; 
    WCHAR RemoteName[MAX_PATH] ; 
    DWORD size = MAX_PATH ; 
    DWORD DriveType, error_status ; 
    
    //
    // ResolvedName will hold the name of the UNC path of the appname if it is in 
    // a remote server and share

    memset(ResolvedName, 0, MAX_PATH * sizeof(WCHAR)) ; 
    
    // check if appname is a app in local drive or remote server share
   
    // Parse the first 3 chars in appname to get the root directory of the drive 
    // where it resides

    wcsncpy(RootPathName, appname, 3 ) ;
    RootPathName[3] = L'\0';
    
    // Find the type of the Drive where the app is 

    DriveType = GetDriveType(RootPathName) ;

    if (DriveType == DRIVE_REMOTE) {
        
        // Use WNetGetConnection to get the name of the remote share
        
        // Parse the first two chars of the appname to get the local drive 
        // which is mapped onto the remote server and share

        wcsncpy(LocalName, appname, 2 ) ;
        LocalName[2] = L'\0' ; 

        error_status = WNetGetConnection (
                           LocalName,
                           RemoteName,
                           &size
                           ) ;     

        if (error_status != NO_ERROR) {
        
            wcscpy(ResolvedName,appname) ; 
            return ;
        }

        //
        // Prepare ResolvedName - it will contain the Remote Server and Share name 
        // followed by a \ and then the appname
        //

        wcscpy( ResolvedName, RemoteName ) ;
        
        length = wcslen(ResolvedName) ;

        ResolvedName[length++] = L'\\' ; 
        
        for (i = 3 ; i <= wcslen(appname) ; i++ ) {
            ResolvedName[length++] = appname[i] ; 
        }
        
        ResolvedName[length] = L'\0' ; 
        return ; 
        

    } else {
    
        // This application is in local drive and not in a remote server and share
        // Just send the appname back to the calling function

        wcscpy(ResolvedName,appname) ; 
        return ;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\aboutbox.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    AboutBox.H

Abstract:

    define the exported routines, datatypes and constants of the 
    AboutBox.C module

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#ifndef _ABOUTBOX_H_
#define _ABOUTBOX_H_
BOOL CALLBACK
AboutBoxDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);
#endif // _ABOUTBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2acls\c2regacl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    c2RegAcl.c

Abstract:

    Registry ACL processing and display functions

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include <strings.h>
#include "c2acls.h"
#include "c2aclres.h"


// define action codes here. They are only meaningful in the
// context of this module.

#define AC_REG_ACLS_MAKE_C2     1
#define AC_REG_ACLS_MAKE_NOTC2  2

#define SECURE    C2DLL_C2

static
LONG
ProcessRegistryInf (
    IN  LPCTSTR  szInfFileName
)
/*++

Routine Description:

    Read the Registry INF file and update the registry key security


Return Value:

    WIN32 status of function

--*/
{
    LONG    lReturn;
    LONG    lStatus;

    LPTSTR  mszRegKeyList;
    DWORD   dwKeyListSize;
    DWORD   dwReturnSize;

    LPTSTR  szThisKey;
    TCHAR   mszThisSection[SMALL_BUFFER_SIZE];

    LPCTSTR szRegKey;
    BOOL    bDoSubKeys;
    PACL    paclKey;
    SECURITY_DESCRIPTOR sdKey;

    if (FileExists(szInfFileName)) {
        // file found, so continue
        dwReturnSize =  0;
        dwKeyListSize = 0;
        mszRegKeyList = NULL;
        do {
            // allocate buffer to hold key list
            dwKeyListSize += MAX_PATH * 1024;    // add room for 1K keys

            // free any previous allocations
            GLOBAL_FREE_IF_ALLOC (mszRegKeyList);

            mszRegKeyList = (LPTSTR)GLOBAL_ALLOC(dwKeyListSize * sizeof(TCHAR));

            // read the keys to process (i.e. get a list of the section
            // headers in the .ini file.

            dwReturnSize = GetPrivateProfileString (
                NULL,   // list all sections
                NULL,   // not used
                cmszEmptyString,    // empty string for default,
                mszRegKeyList,
                dwKeyListSize,      // buffer size in characters
                szInfFileName);     // file name

        } while (dwReturnSize == (dwKeyListSize -2)); // this value indicates truncation

        if (dwReturnSize != 0) {
            // process all keys in list
            for (szThisKey = mszRegKeyList;
                    *szThisKey != 0;
                    szThisKey += lstrlen(szThisKey)+1) {

                // read in all the ACEs for this key
                dwReturnSize = GetPrivateProfileSection (
                    szThisKey,
                    mszThisSection,
                    SMALL_BUFFER_SIZE,
                    szInfFileName);

                if (dwReturnSize != 0) {
                    paclKey = (PACL)GLOBAL_ALLOC(SMALL_BUFFER_SIZE);
                    if (paclKey != NULL) {
                        InitializeSecurityDescriptor (&sdKey,
                            SECURITY_DESCRIPTOR_REVISION);
                        if (InitializeAcl(paclKey, SMALL_BUFFER_SIZE, ACL_REVISION)) {
                            // make ACL from section
                            lStatus = MakeAclFromRegSection (
                                mszThisSection,
                                paclKey);

                            // add ACL to Security Descriptor
                            if (SetSecurityDescriptorDacl (
                                &sdKey,
                                TRUE,
                                paclKey,
                                FALSE)) {

                                // DACL built now update key

                                szRegKey = GetKeyPath (szThisKey, &bDoSubKeys);

                                lStatus = SetRegistryKeySecurity (
                                    GetRootKey(szThisKey),
                                    szRegKey,
                                    bDoSubKeys,
                                    &sdKey);
                            } else {
                                // unable to set securityDesc.
                            }
                        } else {
                            // unable to initialize ACL
                        }
                        GLOBAL_FREE_IF_ALLOC (paclKey);
                    } else {
                        // unable to allocate ACL buffer
                    }
                } else {
                    // no entries found in this section
                }
            } // end while scanning list of sections
        } else {
            // no section list returned
        }
        GLOBAL_FREE_IF_ALLOC (mszRegKeyList);
    } else {
        lReturn = ERROR_FILE_NOT_FOUND;
    }
    return lReturn;
}

LONG
C2QueryRegistryAcls (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

    For the moment, the registry is not read and compared so no status
    is returned.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // return message based on flag for now
        pC2Data->lC2Compliance = C2DLL_UNKNOWN;
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), IDS_UNABLE_READ));
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2SetRegistryAcls (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    TCHAR       szInfFileName[MAX_PATH];

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        switch (pC2Data->lActionCode ) {
            case AC_REG_ACLS_MAKE_C2:
                if (DisplayDllMessageBox(
                    pC2Data->hWnd,
                    IDS_REG_ACLS_CONFIRM,
                    IDS_REG_ACLS_CAPTION,
                    MBOKCANCEL_QUESTION) == IDOK) {

                    SET_WAIT_CURSOR;
                    
                    if (GetFilePath(
                        GetStringResource(GetDllInstance(), IDS_REGISTRY_ACL_INF),
                        szInfFileName)) {
                        if (ProcessRegistryInf(szInfFileName) == ERROR_SUCCESS) {
                            pC2Data->lC2Compliance = SECURE;
                            lstrcpy (pC2Data->szStatusName,
                                GetStringResource(GetDllInstance(), IDS_REG_ACLS_COMPLY));
                        } else {
                            // unable to set acl security
                        } 
                    } else {
                        // unable to get acl file path
                    }
                    SET_ARROW_CURSOR;
                } else {
                    // user opted not to set acls
                }
                break;

            default:
                // no change;
                break;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayRegistryAcls (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    if (pC2Data->lC2Compliance == SECURE) {
        DisplayDllMessageBox (
            pC2Data->hWnd,
            IDS_REG_ACLS_COMPLY,
            IDS_REG_ACLS_CAPTION,
            MBOK_INFO);
    } else {
        if (DisplayDllMessageBox (
            pC2Data->hWnd,
            IDS_REG_ACLS_QUERY_SET,
            IDS_REG_ACLS_CAPTION,
            MBOKCANCEL_QUESTION) == IDOK) {
            pC2Data->lActionCode = AC_REG_ACLS_MAKE_C2;
            pC2Data->lActionValue = 0; // not used
        } else {
            pC2Data->lActionCode = 0;   // no action
            pC2Data->lActionValue = 0;  // not used
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\c2config.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    C2Config.c

Abstract:

    Provides a GUI interface for configuring a C2 secure system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <stdio.h>
#include    "c2config.h"
#include    "resource.h"
#include    "c2utils.h"
#include    "mainwnd.h"
#include    "titlewnd.h"
#include    "splash.h"

// variable definition

static  WORD    wHelpContextId = IDH_CONTENTS;
static  TCHAR   szHelpFileName[MAX_PATH];

BOOL
SetHelpFileName (
    IN  LPCTSTR szPathName
)
{
    if (FileExists(szPathName)) {
        lstrcpy (szHelpFileName, szPathName);
        return TRUE;
    } else {
        szHelpFileName[0] = 0;
        return FALSE;
    }
}

LPCTSTR
GetHelpFileName (
)
{
    return (LPCTSTR)&szHelpFileName[0];
}

VOID
SetHelpContextId (
    WORD    wId
)
{
    wHelpContextId = wId;
    return;
}

WORD
GetHelpContextId (
)
{
    return wHelpContextId;
}

int
DisplayMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
)
/*++

Routine Description:

    Displays a message box displaying text from the resource file, as
        opposed to literal strings.

Arguments:

    IN  HWND    hWnd            window handle to parent window
    IN  UINT    nMessageId      String Resource ID of message text to display
    IN  UINT    nTitleId        String Resource ID of title text to display
    IN  UINT    nStyle          MB style bits (see MessageBox function)

Return Value:

    ID of button pressed to exit message box

--*/
{
    LPTSTR      szMessageText = NULL;
    LPTSTR      szTitleText = NULL;
    HINSTANCE   hInst;
    int         nReturn;

    hInst = GET_INSTANCE(hWnd);

    szMessageText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);
    szTitleText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);

    if ((szMessageText != NULL) &&
        (szTitleText != NULL)) {
        LoadString (hInst,
            ((nTitleId != 0) ? nTitleId : IDS_APP_NAME),
            szTitleText,
            SMALL_BUFFER_SIZE -1);

        LoadString (hInst,
            nMessageId,
            szMessageText,
            SMALL_BUFFER_SIZE - 1);

        nReturn = MessageBox (
            hWnd,
            szMessageText,
            szTitleText,
            nStyle);
    } else {
        nReturn = IDCANCEL;
    }

    GLOBAL_FREE_IF_ALLOC (szMessageText);
    GLOBAL_FREE_IF_ALLOC (szTitleText);

    return nReturn;
}

BOOL
UpdateSystemMenu (
    IN  HWND    hWnd   // window handle
)
/*++

Routine Description:

    modifies the system menu by:
        Removing the "Restore", "Size", "Minimize" and "Maximize" entries

Arguments:

    IN  HWND    hWnd
        window handle of window containing the system menu to modify


Return Value:

    TRUE if successfully made changes, otherwise
    FALSE if error occurred

--*/
{
    return TRUE;
}

BOOL
ShowAppHelpContents (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Generic routine to call WinHelp engine for displaying application
        help table of contents

Arguments:

    IN  HWND    hWnd
        window handle of calling window

Return Value:

    TRUE if help called successfully

--*/
{
    TCHAR   szFullHelpPath[MAX_PATH];

    GetFilePath (GetStringResource(GET_INSTANCE(hWnd), IDS_HELP_FILENAME),
        szFullHelpPath);

    return WinHelp (hWnd,
        szFullHelpPath,        
        HELP_CONTENTS,
        (DWORD)0);        
}

BOOL
ShowAppHelp (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Generic routine to call WinHelp engine for displaying application
        help. wContext parameter is used for context.

Arguments:

    IN  HWND    hWnd
        window handle of calling window

Return Value:

    TRUE if help called successfully

--*/
{
    return WinHelp (hWnd,
        GetHelpFileName(),
        HELP_CONTEXT,
        (DWORD)GetHelpContextId());
}

BOOL
QuitAppHelp (
    IN  HWND    hWnd
)
{
    return WinHelp (hWnd,
        GetHelpFileName(),
        HELP_QUIT,
        (DWORD)0);
}

static
LRESULT
NYIMsgBox (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Displays error message box for features that have not been implemented.
        in DEBUG builds, this is a message box, in RELEASE builds, this is
        only a beep.

Arguments:

    hWnd    Window handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
#ifdef  DBG
    DisplayMessageBox (
        hWnd,
        IDS_NIY,
        IDS_APP_ERROR,
        MBOK_EXCLAIM);
#else
    MessageBeep (BEEP_EXCLAMATION);
#endif
    return ERROR_SUCCESS;
}

int APIENTRY
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR     szCmdLine,
    IN  int       nCmdShow
)
/*++

Routine Description:

    Program entry point for LoadAccount application. Initializes Windows
        data structures and begins windows message processing loop.

Arguments:

    Standard WinMain arguments

ReturnValue:

    0 if unable to initialize correctly, or
    wParam from WM_QUIT message if messages processed

--*/
{
    HWND        hWnd; // Main window handle.
    HWND        hPrevWnd;   // previously openend app main window
	MSG         msg;
    HACCEL      hAccel;

    // look for previously opened instances of the application before 
    // getting carried away
    hPrevWnd = FindWindow (
        GetStringResource(hInstance, IDS_APP_WINDOW_CLASS),
        GetStringResource (hInstance, IDS_APP_TITLE));

    if (hPrevWnd != NULL) {
        // another instance of the application is already running so
        // activate it and set focus to it, then discard this one
        SetForegroundWindow (hPrevWnd);
        // restore to window if it's an Icon
        if (IsIconic (hPrevWnd)) {
            ShowWindow (hPrevWnd, SW_RESTORE);
        }
        return ERROR_ALREADY_EXISTS;
    } else {
        // there are no previous instances so register the window classes
        // and continue creating and starting this app.
        if (!RegisterMainWindowClass(hInstance)) {
            return ERROR_CANNOT_MAKE; // initialization failed
	    }
        if (!RegisterTitleWindowClass(hInstance)) {
            return ERROR_CANNOT_MAKE; // initialization failed
	    }
        if (!RegisterSplashWindowClass(hInstance)) {
            return ERROR_CANNOT_MAKE; // initialization failed
	    }

        hWnd = CreateMainWindow (hInstance);

        if (hWnd != NULL) {

            hAccel = LoadAccelerators (hInstance, MAKEINTRESOURCE (IDA_C2CONFIG));

	        // Acquire and dispatch messages until a
            //  WM_QUIT message is received. 

	        while (GetMessage(&msg, // message structure
	            NULL,   // handle of window receiving the message
	            0,      // lowest message to examine
	            0))    // highest message to examine
            {
                // process this message
                if (!TranslateAccelerator(hWnd, hAccel, &msg)) {
                    TranslateMessage(&msg);// Translates virtual key codes
                    DispatchMessage(&msg); // Dispatches message to window
                }
            }
	        return (msg.wParam); // Returns the value from PostQuitMessage
        } else {
            return (ERROR_CAN_NOT_COMPLETE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2acls\c2acls.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    C2ACLS.H

Abstract:

    define the exported routines, datatypes and constants of the 
    C2ACLS DLL

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94


--*/
#ifndef _C2FUNCS_H_
#define _C2FUNCS_H_

// FilePath interprtation flags

#define FILE_PATH_NORMAL    1   // do the specified file ONLY
#define FILE_PATH_ALL       2   // do the specified [Dir] path and all files and sub dirs
#define FILE_PATH_WILD      4   // process the wildcard path syntax


// dllinit.c functions
HINSTANCE
GetDllInstance (
    VOID
);

int
DisplayDllMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
);

// public aclfuncs.c functions

HKEY
GetRootKey (
    IN  LPCTSTR szKeyPath
);

LPCTSTR
GetKeyPath (
    IN  LPCTSTR szKeyPath,
    OUT LPBOOL  pbDoSubKeys
);

LPCTSTR
GetFilePathFromHeader (
    IN  LPCTSTR szHeaderPath,
    OUT LPDWORD pdwFlags
);

LONG
MakeAclFromRegSection (
    IN  LPTSTR  mszSection,
    OUT PACL    pAcl
);

LONG
MakeAclFromNtfsSection (
    IN  LPTSTR  mszSection,
    IN  BOOL    bDirectory, 
    OUT PACL    pAcl
);

LONG
SetRegistryKeySecurity (
    IN  HKEY                    hkeyRootKey,
    IN  LPCTSTR                 szKeyPath,
    IN  BOOL                    bDoSubKeys,
    IN  PSECURITY_DESCRIPTOR    psdSecurity
);

LONG
SetNtfsFileSecurity (
    IN  LPCTSTR szPath,
    IN  DWORD   dwFlags,
    IN  PSECURITY_DESCRIPTOR     pSdDir,
    IN  PSECURITY_DESCRIPTOR     pSdFile
);

#endif // _C2FUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2acls\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    the Stadard C2 function dll

Author:

    Bob Watson (a-robw) Dec-94      

Revision History:

--*/

#include <windows.h>
#include <c2inc.h>
#include <c2dll.h>
#include "c2acls.h"
#include "c2aclres.h"

static HANDLE ThisDLLHandle = NULL;

int
DisplayDllMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
)
/*++

Routine Description:

    Displays a message box displaying text from the DLL's resource file, as
        opposed to literal strings.

Arguments:

    IN  HWND    hWnd            window handle to parent window
    IN  UINT    nMessageId      String Resource ID of message text to display
    IN  UINT    nTitleId        String Resource ID of title text to display
    IN  UINT    nStyle          MB style bits (see MessageBox function)

Return Value:

    ID of button pressed to exit message box

--*/
{
    LPTSTR      szMessageText = NULL;
    LPTSTR      szTitleText = NULL;
    HINSTANCE   hInst;
    int         nReturn;

    hInst = GetDllInstance();

    szMessageText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);
    szTitleText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);

    if ((szMessageText != NULL) &&
        (szTitleText != NULL)) {
        LoadString (hInst,
            ((nTitleId != 0) ? nTitleId : IDS_DLL_NAME),
            szTitleText,
            SMALL_BUFFER_SIZE -1);

        LoadString (hInst,
            nMessageId,
            szMessageText,
            SMALL_BUFFER_SIZE - 1);

        nReturn = MessageBox (
            hWnd,
            szMessageText,
            szTitleText,
            nStyle);
    } else {
        nReturn = IDCANCEL;
    }

    GLOBAL_FREE_IF_ALLOC (szMessageText);
    GLOBAL_FREE_IF_ALLOC (szTitleText);

    return nReturn;
}

HINSTANCE   
GetDllInstance (
)
{
    return (HINSTANCE)ThisDLLHandle;
}

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {
        case DLL_PROCESS_ATTACH:

            ThisDLLHandle = DLLHandle;
            break;

        case DLL_PROCESS_DETACH:
            break ;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

            break;
    }

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\c2config.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    C2Config.H

Abstract:


Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _C2CONFIG_H_
#define _C2CONFIG_H_

#include <c2inc.h>

// title bar dimensions
#define     TITLE_BAR_MIN_X 320

#define HELP_HOT_KEY   0x0B0B  // whotkey id for f1 help
#define SPLASH_TIMER   1       // timer ID for splash window displah
//
//  Global Functions
//
BOOL
ShowAppHelpContents (
    IN  HWND    hWnd
);

BOOL
ShowAppHelp (
    IN  HWND    hWnd
);

BOOL
QuitAppHelp (
    IN  HWND    hWnd
);

int
DisplayMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
);

BOOL
SetHelpFileName (
    IN  LPCTSTR szPathName
);

LPCTSTR
GetHelpFileName (
);

VOID
SetHelpContextId (
    WORD    wId
);

WORD
GetHelpContextId (
);


#endif // _C2CONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2acls\c2ntfacl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    c2NtfAcl.c

Abstract:

    NTFS File and Directory Security processing and display functions

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include <strings.h>
#include "c2acls.h"
#include "c2aclres.h"


// define action codes here. They are only meaningful in the
// context of this module.

#define AC_NTFS_ACLS_MAKE_C2     1
#define AC_NTFS_ACLS_MAKE_NOTC2  2

#define SECURE    C2DLL_C2

#define FS_UNKNOWN  0x00000000
#define FS_FAT      0x00000001
#define FS_NTFS     0x00000002
#define FS_HPFS     0x00000004

static
DWORD
GetSystemDriveFileSystem (
)
{
    TCHAR   szSystemDir[MAX_PATH];
    TCHAR   szVolumeName[MAX_PATH];
    TCHAR   szFileSystemName[MAX_PATH];
    DWORD   dwVolumeSerialNumber;
    DWORD   dwMaxComponentLength;
    DWORD   dwFileSystemFlags;

    DWORD   dwReturn = FS_UNKNOWN;

    if (GetSystemDirectory (szSystemDir, (sizeof(szSystemDir)/sizeof(TCHAR))) > 0) {
        // truncate path and just keep drive letter, colon & backslash
        szSystemDir[3] = 0;
        if (GetDriveType(szSystemDir) == DRIVE_FIXED) {
            // only check fixed disk volumes
            if (GetVolumeInformation(szSystemDir,
                szVolumeName,
                sizeof(szVolumeName) / sizeof(TCHAR),
                &dwVolumeSerialNumber,
                &dwMaxComponentLength,
                &dwFileSystemFlags,
                szFileSystemName,
                sizeof(szFileSystemName) / sizeof(TCHAR))) {
                // volume information returned so see if it's NOT NTFS..

                if (lstrcmpi(szFileSystemName,
                    GetStringResource (GetDllInstance(), IDS_NTFS)) == 0) {
                    dwReturn = FS_NTFS;
                } else if (lstrcmpi(szFileSystemName,
                    GetStringResource (GetDllInstance(), IDS_FAT)) == 0) {
                    dwReturn = FS_FAT;
                } else if (lstrcmpi(szFileSystemName,
                    GetStringResource (GetDllInstance(), IDS_HPFS)) == 0) {
                    dwReturn = FS_HPFS;
                } else {
                    //return Unknown
                }
            } else {
                // unable to read volume information
            }
        } else {
            // unable to get drive type
        }
    } else {
        // unable to look up system dir
    }
    return dwReturn;
}

//static
LONG
ProcessNtfsInf (
    IN  LPCTSTR  szInfFileName
)
/*++

Routine Description:

    Read the NTFS security INF file and update the registry key security


Return Value:

    WIN32 status of function

--*/
{

    LONG    lReturn;
    LONG    lStatus;

    DWORD   dwReturnSize;
    DWORD   dwPathListSize;
    LPTSTR  mszPathList;
    LPTSTR  szThisPath;
    LPCTSTR szFilePath;

    TCHAR   mszThisSection[SMALL_BUFFER_SIZE];

    DWORD   dwDirFlags;

    PACL    paclFile;
    PACL    paclDir;

    SECURITY_DESCRIPTOR sdFile;
    SECURITY_DESCRIPTOR sdDir;

    if (FileExists(szInfFileName)) {
        // file found, so continue
        dwReturnSize =  0;
        dwPathListSize = 0;
        mszPathList = NULL;
        do {
            // allocate buffer to hold key list
            dwPathListSize += MAX_PATH * 1024;    // add room for 1K keys

            // free any previous allocations
            GLOBAL_FREE_IF_ALLOC (mszPathList);

            mszPathList = (LPTSTR)GLOBAL_ALLOC(dwPathListSize * sizeof(TCHAR));

            // read the keys to process (i.e. get a list of the section
            // headers in the .ini file.

            dwReturnSize = GetPrivateProfileString (
                NULL,   // list all sections
                NULL,   // not used
                cmszEmptyString,    // empty string for default,
                mszPathList,
                dwPathListSize,      // buffer size in characters
                szInfFileName);     // file name

        } while (dwReturnSize == (dwPathListSize -2)); // this value indicates truncation

        if (dwReturnSize != 0) {
            // process all file paths in list
            for (szThisPath = mszPathList;
                    *szThisPath != 0;
                    szThisPath += lstrlen(szThisPath)+1) {

                // read in all the ACEs for this key
                dwReturnSize = GetPrivateProfileSection (
                    szThisPath,
                    mszThisSection,
                    SMALL_BUFFER_SIZE,
                    szInfFileName);

                if (dwReturnSize != 0) {
                    // make 2 security Descriptors, one to be assigned 
                    // to files (containing access for just the file)
                    // and one for directories that have access for 
                    // directories themselves as well as the sub-items
                    // (files and dirs)
                    paclFile = (PACL)GLOBAL_ALLOC(SMALL_BUFFER_SIZE);
                    paclDir = (PACL)GLOBAL_ALLOC(SMALL_BUFFER_SIZE);
                    if ((paclFile != NULL) && (paclDir != NULL)){
                        InitializeSecurityDescriptor (&sdFile,
                            SECURITY_DESCRIPTOR_REVISION);
                        InitializeSecurityDescriptor (&sdDir,
                            SECURITY_DESCRIPTOR_REVISION);
                        if (InitializeAcl(paclFile, SMALL_BUFFER_SIZE, ACL_REVISION) &&
                            InitializeAcl(paclDir, SMALL_BUFFER_SIZE, ACL_REVISION)) {
                            // make ACL from section
                            szFilePath = GetFilePathFromHeader (
                                szThisPath, &dwDirFlags);

                            lStatus = MakeAclFromNtfsSection (
                                mszThisSection,
                                TRUE,
                                paclDir);

                            // add ACL to Security Descriptor
                            SetSecurityDescriptorDacl (
                                &sdDir,
                                TRUE,
                                paclDir,
                                FALSE);

                            lStatus = MakeAclFromNtfsSection (
                                mszThisSection,
                                FALSE,
                                paclFile);

                            // add ACL to Security Descriptor
                            SetSecurityDescriptorDacl (
                                &sdFile,
                                TRUE,
                                paclFile,
                                FALSE);

                            // DACL built now update key

                            lStatus = SetNtfsFileSecurity (
                                szFilePath,
                                dwDirFlags,
                                &sdDir,
                                &sdFile);
                        } else {
                            // unable to initialize ACL
                        }
                        GLOBAL_FREE_IF_ALLOC (paclFile);
                        GLOBAL_FREE_IF_ALLOC (paclDir);
                    } else {
                        // unable to allocate ACL buffer
                    }
                } else {
                    // no entries found in this section
                }
            } // end while scanning list of sections
        } else {
            // no section list returned
        }
        GLOBAL_FREE_IF_ALLOC (mszPathList);
    } else {
        lReturn = ERROR_FILE_NOT_FOUND;
    }
    return lReturn;
}

LONG
C2QueryNtfsFiles (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

    For the moment, the registry is not read and compared so no status
    is returned.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // return message based on flag for now
        pC2Data->lC2Compliance = C2DLL_UNKNOWN;
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), IDS_UNABLE_READ));
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2SetNtfsFiles (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    TCHAR       szInfFileName[MAX_PATH];

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        switch (pC2Data->lActionCode ) {
            case AC_NTFS_ACLS_MAKE_C2:
                if (DisplayDllMessageBox(
                    pC2Data->hWnd,
                    IDS_NTFS_ACLS_CONFIRM,
                    IDS_NTFS_ACLS_CAPTION,
                    MBOKCANCEL_QUESTION) == IDOK) {

                    SET_WAIT_CURSOR;
                    
                    if (GetFilePath(
                        GetStringResource(GetDllInstance(), IDS_NTFS_ACL_INF),
                        szInfFileName)) {
                        if (ProcessNtfsInf(szInfFileName) == ERROR_SUCCESS) {
                            pC2Data->lC2Compliance = SECURE;
                            lstrcpy (pC2Data->szStatusName,
                                GetStringResource(GetDllInstance(), IDS_NTFS_ACLS_COMPLY));
                        } else {
                            // unable to set acl security
                        } 
                    } else {
                        // unable to get acl file path
                    }
                    SET_ARROW_CURSOR;
                } else {
                    // user opted not to set acls
                }
                break;

            default:
                // no change;
                break;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayNtfsFiles (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    if (GetSystemDriveFileSystem() == FS_NTFS) {
        if (pC2Data->lC2Compliance == SECURE) {
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_NTFS_ACLS_COMPLY,
                IDS_NTFS_ACLS_CAPTION,
                MBOK_INFO);
        } else {
            if (DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_NTFS_ACLS_QUERY_SET,
                IDS_NTFS_ACLS_CAPTION,
                MBOKCANCEL_QUESTION) == IDOK) {
                pC2Data->lActionCode = AC_NTFS_ACLS_MAKE_C2;
                pC2Data->lActionValue = 0; // not used
            } else {
                pC2Data->lActionCode = 0;   // no action
                pC2Data->lActionValue = 0;  // not used
            }
        }
    } else {
        DisplayDllMessageBox (
            pC2Data->hWnd,
            IDS_NTFS_ACLS_NOT_NTFS,
            IDS_NTFS_ACLS_CAPTION,
            MBOK_EXCLAIM);
        pC2Data->lActionCode = 0;   // no action
        pC2Data->lActionValue = 0;  // not used
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\rebootex.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    RebootEx.H

Abstract:

    define the exported routines, datatypes and constants of the 
    rebootex.C module

Author:

    Bob Watson (a-robw)

Revision History:

    26 Dec 94


--*/
#ifndef _REBOOTEX_H_
#define _REBOOTEX_H_
BOOL CALLBACK
RebootExitDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);
#endif // _REBOOTEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\listwnd.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ListWnd.H

Abstract:
    
    Global functions and constants used by the application's list window

Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _LISTWND_H_
#define _LISTWND_H_

#include "c2dll.h"

// Data structures used by list box 

#define  MAX_ITEMNAME_LEN     64
#define  MAX_STATUSTEXT_LEN   64
#define  MAX_DISPLAY_LINE_LEN 260

typedef  struct   _C2LB_DATA {
    DWORD       dwSize;
    C2DLL_DATA  dllData;
    PC2DLL_FUNC pQueryFn;
    PC2DLL_FUNC pDisplayFn;
    PC2DLL_FUNC pSetFn;
    BOOL        bRebootWhenChanged;
    TCHAR       szDisplayString[MAX_DISPLAY_LINE_LEN];
} C2LB_DATA, *PC2LB_DATA;

// External Windows messages

#define  LB_GET_C2_STATUS  (WM_USER + 201)
//       wParam =    ID of item to get, -1 for current selection
//       lParam =    pointer to C2LB_DATA structure to fill
//
//       returns: TRUE if Currently C2 compliant or
//                FALSE if not C2 compliant
//
#define  LB_SET_C2_STATUS  (WM_USER + 202)
//
//       wParam =    ID of item to set, -1 for current selection
//       lParam =    pointer to C2LB_DATA structure to apply
//
//       returns: TRUE if status is updated successfully
//                FALSE if an error occured
//
#define  LB_ADD_C2_ITEM    (WM_USER + 203)
//
//       wParam =   Index in list box where item should be inserted,
//                   -1 = at end of list
//       lParam = pointer to C2LB_DATA structure to add
//
//       returns: TRUE if status is updated successfully
//                FALSE if an error occured
//
#define  LB_DISPLAY_C2_ITEM_UI  (WM_USER + 204)
//
//       wParam =   Index in list box of item to show dlg box for
//                   -1 = current selection
//       lParam = pointer to C2LB_DATA structure to add
//
//       returns: TRUE if status is updated successfully
//                FALSE if an error occured
//
#define  LB_SET_MIN_WIDTH  (WM_USER + 205)
//
//       wParam     (not used, must be 0)   
//
//       lParam = new minimum width of list window,
//                  the list window will not be allowed to be smaller than
//                  the predefined minumum.
//
//       returns: TRUE if status is updated successfully
//                FALSE if an error occured
//
#define  LB_DRAWITEM        (WM_USER + 206)
//
//       See the description of WM_DRAWITEM for the parameters of this
//       message
//
//       returns: TRUE if the item is drawn
//                FALSE if an error occured
//
// --
//
//  Global functions
//
LRESULT CALLBACK
ListWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
);

LRESULT
ListWnd_WM_GETMINMAXINFO  (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
);

BOOL
ListWndFillMeasureItemStruct (
    LPMEASUREITEMSTRUCT     lpItem
);

HWND
CreateListWindow (
    IN  HINSTANCE   hInstance,
    IN  HWND        hParentWnd,
    IN  INT         nChildId
);


#endif  // _LISTWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\rebootex.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Reboot.c

Abstract:

    reboot exit dialog procedure for C2 Configuration Manager

Author:

    Bob Watson (a-robw)

Revision History:

    26 Dec 94


--*/
#include    <windows.h>
#include    <stdlib.h>
#include    "c2config.h"
#include    "c2utils.h"
#include    "resource.h"
//


BOOL CALLBACK
RebootExitDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam      
)
/*++

Routine Description:

    Window procedure for Reboot Exit Dialog

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    switch (message) {
        case WM_INITDIALOG:
            // set focus to the about box button
            SetFocus (GetDlgItem (hDlg, IDC_REBOOT));
            CenterWindow (hDlg, GetParent(hDlg));

            // return FALSE because the focus was "manually" set
            return FALSE;

        case WM_COMMAND:    // control notification messages
            switch (GET_CONTROL_ID(wParam)) { //dispatch based on control ID
                case IDC_REBOOT:
                    switch (GET_NOTIFY_MSG(wParam, lParam)) {
                        case BN_CLICKED:
                            EnableAllPriv();
                            ExitWindowsEx (EWX_SHUTDOWN | EWX_FORCE | EWX_REBOOT, 0L);
                            EndDialog (hDlg, IDOK);
                            return TRUE;

                        default:
                            // let DefDlgProc process other notifications
                            return FALSE;
                    }

                case IDC_DO_NOT_REBOOT:
                    switch (GET_NOTIFY_MSG(wParam, lParam)) {
                        case BN_CLICKED:
                            EndDialog (hDlg, IDOK);
                            return TRUE;

                        default:
                            // let DefDlgProc process other notifications
                            return FALSE;
                    }
                    
                default:
                   // let DefDlgProc process other controls
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\resource.h ===
#define IDC_STATIC                  -1
#define IDD_SPLASH                  100
#define IDD_EDIT                    200
#define IDD_LIST                    300
#define IDD_COMBO                   400
#define IDD_STATUS                  500
#define IDD_ABOUT                   600
#define IDD_REBOOT_EXIT             700
#define IDC_FIELD_NAME              1001
#define IDC_EDIT_BOX                1002
#define IDC_EXPLAIN                 1003
#define IDC_HELP_BUTTON             1004
#define IDC_COMBO_BOX               1005
#define IDC_STATUS_TEXT             1006
#define IDC_ABOUT_ICON              1007
#define IDC_LIST                    1008
#define IDC_TITLE                   1009
#define IDC_REBOOT                  1010
#define IDC_DO_NOT_REBOOT           1011
#define IDC_REBOOT_ICON             1012
#define IDH_CONTENTS                5000
#define IDB_SPLASH                  9000
#define IDB_CHECK                   9010
#define IDB_X                       9020
#define IDB_NOT_SECURE              9030
#define IDB_SECURE                  9040
#define IDB_C2_SECURE               9050
#define IDB_SECURE_MASK             9060
#define IDB_NOT_SECURE_MASK         9070
#define IDB_UNKNOWN                 9080
#define IDB_UNKNOWN_MASK            9090
#define IDM_C2CONFIG_MENU           10000
#define IDM_MENU_FILE               10010
#define IDM_FILE_EXIT               10011
#define IDM_MENU_VIEW               10020
#define IDM_VIEW_PRIOR              10021
#define IDM_VIEW_NEXT               10022
#define IDM_VIEW_REFRESH            10023
#define IDM_MENU_HELP               10030
#define IDM_HELP_CONTENTS           10031
#define IDM_HELP_ITEM               10032
#define IDM_HELP_ABOUT              10033
#define IDA_C2CONFIG                15000
#define IDS_APP_TITLE               20001
#define IDS_APP_WARNING             20002
#define IDS_APP_ERROR               20003
#define IDS_NIY                     20004
#define IDS_SETTING_SYS_TO_C2       20005
#define IDS_TITLE_BAR_STRING        20006
//#define IDS_TEST_MESSAGE            20007
#define IDS_NOMORE_NONC2            20008
#define IDS_YES_C2                  20009
#define IDS_YES_SECURE              20010
#define IDS_NO_C2                   20011
#define IDS_ABOUT_BOX_TITLE         20012
#define IDS_UNABLE_READ_CONFIG      28001
#define IDS_ERROR_NO_INF            28002
#define IDS_ERROR_NO_ITEMS          28003
#define IDS_ERROR_OPEN_DLL          28004
#define IDS_ERROR_FIND_PROC         28005
#define IDS_ERROR_NO_PRIV           28006
#define IDS_DO_NOT_LOCALIZE         29000
#define IDS_APP_NAME                29001
#define IDS_APP_WINDOW_CLASS        29002
#define IDS_HELP_FILENAME           29003
#define IDS_LISTBOX_CLASS           29004
#define IDS_C2_ITEM_INF             29005
#define IDS_APP_TITLE_CLASS         29006
#define IDS_LINE_FORMAT             29007
#define IDS_C2ITEM_SECTION          29008
#define IDS_APP_SPLASH_CLASS        29009
#define IDS_SPLASH_EVENT            29010
#define IDI_APPICON                 32000
#define IDI_REBOOT                  32100
#define IDD_OTHER_ITEMS             800
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\listwnd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    listwnd.c

Abstract:

    Window procedure for C2Config list window.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <tchar.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    "c2config.h"
#include    "resource.h"
#include    "c2utils.h"
#include    "listwnd.h"
#include    "titlewnd.h"

#define _OWNERDRAW_LIST_BOX 1

#define _USE_ICON_DISPLAY

#ifdef  _WRITE_DEBUG_MESSAGES
#undef  _WRITE_DEBUG_MESSAGES
#endif

#ifdef _WRITE_DEBUG_MESSAGES
#define LISTWND_DEBUG_OUT(x)    OutputDebugString(x)
#define LISTWND_DEBUG_STATUS(x) OutputDebugStatus(x)
#else
#define LISTWND_DEBUG_OUT(x)    
#define LISTWND_DEBUG_STATUS(x) 
#endif

#ifdef _OWNERDRAW_LIST_BOX
#define     LIST_WINDOW_STYLE (DWORD)(WS_CHILD | WS_VISIBLE | WS_VSCROLL | \
                                      WS_HSCROLL | LBS_OWNERDRAWFIXED | \
                                      LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | \
                                      LBS_USETABSTOPS | LBS_WANTKEYBOARDINPUT)
#else
#define     LIST_WINDOW_STYLE (DWORD)(WS_CHILD | WS_VISIBLE | WS_VSCROLL | \
                                      WS_HSCROLL | LBS_HASSTRINGS | \
                                      LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | \
                                      LBS_USETABSTOPS | LBS_WANTKEYBOARDINPUT)
#endif

#define     LIST_WINDOW_MIN_X 480

// font description
#define     LB_FONT_FACE    (TEXT("Helv"))                                    
#define     LB_FONT_HEIGHT  12
#define     LB_FONT_WIDTH   0
#define     LB_ITEM_HEIGHT  14                                    


typedef union _TEXT_EXTENT {
    DWORD   dwExtent;
    union {
        WORD    wWidth;
        WORD    wHeight;
    };
} TEXT_EXTENT, *PTEXT_EXTENT;


static WNDPROC  DefListProc = NULL;
static LONG     lMaxItemLen = 0;        // length in pixels of longest item
static HFONT    hFontListBox = NULL;    // list box display font

#ifdef _WRITE_DEBUG_MESSAGES
static
VOID
OutputDebugStatus (
    LPDRAWITEMSTRUCT    pData
)
{
    TCHAR   szBuffer[260];
    LPCTSTR szString;
    BOOL    bUseComma;

    switch (pData->CtlType) {
        case ODT_BUTTON:
            szString = TEXT("Button");  break;

        case ODT_COMBOBOX:
            szString = TEXT("Combo Box");  break;

        case ODT_LISTBOX:
            szString = TEXT("List Box");  break;

        case ODT_MENU:
            szString = TEXT("Menu");  break;

        default:
            szString = TEXT("Unknown");  break;
    }
    _stprintf (szBuffer, TEXT("\n(%.3d) Control is: %s"),
        pData->itemID, szString);
    LISTWND_DEBUG_OUT(szBuffer);

    lstrcpy (szBuffer, TEXT("\tAction flags set are: "));
    bUseComma = FALSE;
    if (pData->itemAction & ODA_DRAWENTIRE) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("DRAWENTIRE"));
    }
    if (pData->itemAction & ODA_FOCUS) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("FOCUS"));
    }
    if (pData->itemAction & ODA_SELECT) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("SELECT"));
    }
    OutputDebugString (szBuffer);

    lstrcpy (szBuffer, TEXT("\tState flags set are: "));
    bUseComma = FALSE;
    if (pData->itemState & ODS_SELECTED) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("SELECTED"));
    }
    if (pData->itemState & ODS_GRAYED) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("GRAYED"));
    }
    if (pData->itemState & ODS_DISABLED) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("DISABLED"));
    }
    if (pData->itemState & ODS_CHECKED) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("CHECKED"));
    }
    if (pData->itemState & ODS_FOCUS) {
        if (bUseComma) {
            lstrcat (szBuffer, TEXT(", "));
        } else {
            bUseComma = TRUE;
        }
        lstrcat (szBuffer, TEXT("FOCUS"));
    }
    OutputDebugString (szBuffer);
}
#endif //_WRITE_DEBUG_MESSAGES

static
BOOL
SetMaxItemLen (
    IN  HWND    hWnd,
    IN  LPCTSTR szItemString
)
{
    HDC         hListWndDc;
    TEXT_EXTENT teText;
    LONG        lNumTabStops;
    LPINT       pnTabStopArray;

    hListWndDc = GetDC (hWnd);
    SelectObject (hListWndDc, hFontListBox);
    lNumTabStops = GetTitleDlgTabs(&pnTabStopArray);
    teText.dwExtent = 0;
    teText.dwExtent = GetTabbedTextExtent (hListWndDc,
        szItemString, lstrlen(szItemString),
        (int)lNumTabStops, pnTabStopArray);
    if ((LONG)teText.wWidth > lMaxItemLen) lMaxItemLen = (LONG)teText.wWidth;
    ReleaseDC (hWnd, hListWndDc);
    return TRUE;
}

static
BOOL
ListWndSetTabStops (
    IN	HWND hWnd         // window handle
)
{
    LPINT   pnTabStopArray;
    LONG    lThisTab;
    LONG    lNumTabStops;
    LONG    lConversion;

    // set tab stops in dialog

    lConversion = (LONG)LOWORD(GetDialogBaseUnits());

    lNumTabStops = GetTitleDlgTabs(&pnTabStopArray);

    for (lThisTab = 0; lThisTab < lNumTabStops; lThisTab++) {
        // convert pixels returned by function to dialog units
        // used by LB_ function
        pnTabStopArray[lThisTab] = (pnTabStopArray[lThisTab] * 4) / lConversion;
    }

    return (BOOL)SendMessage  (hWnd, LB_SETTABSTOPS,
        (WPARAM)lNumTabStops, (LPARAM)pnTabStopArray);
}

// Local Windows messages
LRESULT
ListWnd_WM_GETMINMAXINFO  (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
)
/*++

Routine Description:

    called before the main window has been resized. Queries the child windows
      for any size limitations

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{

   LPMINMAXINFO   pmmWnd;
   RECT           rItem;

   pmmWnd = (LPMINMAXINFO)lParam;

   if (pmmWnd != NULL) {
      pmmWnd->ptMinTrackSize.x = __max (LIST_WINDOW_MIN_X, lMaxItemLen);

      SendMessage (hWnd, LB_GETITEMRECT, 0, (LPARAM)&rItem);

      pmmWnd->ptMinTrackSize.y = (rItem.bottom - rItem.top) * 2;
   }

   return ERROR_SUCCESS;
}

static
LRESULT
ListWnd_LB_SET_C2_STATUS (
   IN HWND  hWnd,
   IN WPARAM   wParam,  // item id
   IN LPARAM   lParam   // action code (0 = use action code from data block)
)
{
    PC2LB_DATA  pItemData;
    TCHAR       szBuff[1024];
    LONG        lCurSel;
    LONG        lLbItemCt;
    UINT        nC2Msg;

    if (wParam == LB_ERR) {
        lCurSel = SendMessage (hWnd, LB_GETCURSEL, 0, 0);
    } else {
        lCurSel = wParam;
    }
    if (lCurSel != LB_ERR) {
        // get item's data block
        pItemData = (PC2LB_DATA)SendMessage (hWnd, LB_GETITEMDATA,
            (WPARAM)lCurSel, 0);

        if (pItemData != NULL) {
            // call set function to perform action defined in
            // action code variable or arg if one is passed

            if (lParam != 0) {
                pItemData->dllData.lActionCode = lParam;
            }

            if (((*pItemData->pSetFn)((LPARAM)&pItemData->dllData)) == ERROR_SUCCESS) {
                // item has been set so update the display text
                nC2Msg =
#ifndef _USE_ICON_DISPLAY
                  pItemData->dllData.lC2Compliance == C2DLL_C2 ? IDS_YES_C2 :
                  pItemData->dllData.lC2Compliance == C2DLL_SECURE ? IDS_YES_SECURE :
#endif
                  IDS_NO_C2;
                _stprintf (szBuff,
                    GetStringResource (GET_INSTANCE(hWnd), IDS_LINE_FORMAT),
                    GetStringResource (GET_INSTANCE(hWnd), nC2Msg),
                    pItemData->dllData.szItemName,
                    pItemData->dllData.szStatusName);
                lLbItemCt = SendMessage (hWnd, LB_DELETESTRING,
                    (WPARAM)lCurSel, 0);
                if (lLbItemCt-1 < lCurSel) {
                    // this is the bottom of the list so set the value to "append"
                    lCurSel = -1;
                }
                lstrcpy (pItemData->szDisplayString,  szBuff);
#ifdef _OWNERDRAW_LIST_BOX
                // for owner draw store data structure
                lCurSel = SendMessage (hWnd, LB_INSERTSTRING,
                    (WPARAM)lCurSel, (LPARAM)pItemData);
#else
                // for "regular" store string then data as item data
                lCurSel = SendMessage (hWnd, LB_INSERTSTRING,
                    (WPARAM)lCurSel, (LPARAM)szBuff);
                SendMessage (hWnd, LB_SETITEMDATA, (WPARAM)lCurSel, (LPARAM)pItemData);
#endif
                SetMaxItemLen (hWnd, szBuff);   // update length
                SendMessage (hWnd, LB_SETCURSEL, (WPARAM)lCurSel, 0);
            }
            // reset the action code
            pItemData->dllData.lActionCode = 0;
            return TRUE;
        } else {
            // unable to get a valid data block for this item
            return FALSE;
        }
    } else {
        // unable to get a selection ID from the list box
        return FALSE;
    }
}

static
LRESULT
ListWnd_LB_DISPLAY_C2_ITEM_UI (
   IN HWND  hWnd,
   IN WPARAM   wParam,  // id of item to query
   IN LPARAM   lParam   // not used
)
{
    PC2LB_DATA  pItemData;
    LONG    lCurSel;

    if (wParam == LB_ERR) {
        lCurSel = SendMessage (hWnd, LB_GETCURSEL, 0, 0);
    } else {
        lCurSel = wParam;
    }
    if (lCurSel != LB_ERR) {
        // get item's data block
        pItemData = (PC2LB_DATA)SendMessage (hWnd, LB_GETITEMDATA,
            (WPARAM)lCurSel, 0);

        if (pItemData != NULL) {
            if (((*pItemData->pDisplayFn)((LPARAM)&pItemData->dllData)) == ERROR_SUCCESS) {
                // return action code so caller knows how to process next action
                return pItemData->dllData.lActionCode;
            }
        } else {
            // unable to get valid data block from list box item
            return 0;
        }
    } else {
        // unable to get valid list box item
        return 0;
    }
}

static
LRESULT
ListWnd_LB_SET_MIN_WIDTH (
   IN HWND  hWnd,
   IN WPARAM   wParam,  // not used
   IN LPARAM   lParam   // new value
)
{
    lMaxItemLen = (LONG)lParam;
    return TRUE;
}

static
LRESULT
ListWnd_LB_GET_C2_STATUS (
   IN HWND  hWnd,
   IN WPARAM   wParam,  // id of item to query
   IN LPARAM   lParam   // not used
)
{
    PC2LB_DATA  pItemData;
    TCHAR       szBuff[1024];
    LONG        lCurSel;
    LONG        lLbItemCt;
    UINT        nC2Msg;

    if (wParam == LB_ERR) {
        lCurSel = SendMessage (hWnd, LB_GETCURSEL, 0, 0);
    } else {
        lCurSel = wParam;
    }

    if (lCurSel != LB_ERR) {
        // get item data from list box entry
        pItemData = (PC2LB_DATA)SendMessage (hWnd, LB_GETITEMDATA,
            (WPARAM)lCurSel, 0);
        if (pItemData != NULL) {
            if (((*pItemData->pQueryFn)((LPARAM)&pItemData->dllData)) == ERROR_SUCCESS) {
                // item has been queryed so update the display text
                nC2Msg =
#ifndef _USE_ICON_DISPLAY
                  pItemData->dllData.lC2Compliance == C2DLL_C2 ? IDS_YES_C2 :
                  pItemData->dllData.lC2Compliance == C2DLL_SECURE ? IDS_YES_SECURE :
#endif
                  IDS_NO_C2;
                _stprintf (szBuff,
                    GetStringResource (GET_INSTANCE(hWnd), IDS_LINE_FORMAT),
                    GetStringResource (GET_INSTANCE(hWnd), nC2Msg),
                    pItemData->dllData.szItemName,
                    pItemData->dllData.szStatusName);
                lstrcpy (pItemData->szDisplayString, szBuff);
#ifdef _OWNERDRAW_LIST_BOX
                // invalidate list box to redraw
                // ideally this would just invalidate the item rect.
                InvalidateRect (hWnd, NULL, TRUE);
#else
                lLbItemCt = SendMessage (hWnd, LB_DELETESTRING,
                    (WPARAM)lCurSel, 0);
                if (lLbItemCt-1 < lCurSel) {
                    // this is the bottom of the list so set the value to "append"
                    lCurSel = -1;
                }
                lCurSel = SendMessage (hWnd, LB_INSERTSTRING,
                    (WPARAM)lCurSel, (LPARAM)szBuff);
                SendMessage (hWnd, LB_SETITEMDATA, (WPARAM)lCurSel, (LPARAM)pItemData);
#endif
                SetMaxItemLen (hWnd, szBuff);   // update length
                SendMessage (hWnd, LB_SETCURSEL, (WPARAM)lCurSel, 0);
            }
            return TRUE;
        } else {
            // unable to get valid item data
            return FALSE;
        }
    } else {
        // unable to locate listbox item
        return FALSE;
    }
}

static
LRESULT
ListWnd_LB_ADD_C2_ITEM (
   IN HWND  hWnd,
   IN WPARAM   wParam,
   IN LPARAM   lParam
)
{
    PC2LB_DATA  pData;
    PC2LB_DATA  pItemData;
    LONG        lIndex;
    UINT        nC2Msg;
    LRESULT     lReturn;

    TCHAR szBuff[1024];

    pData = (PC2LB_DATA)lParam;

    if (pData != NULL) {
        if ((pData->dllData.szItemName != NULL) &&
            (pData->dllData.szStatusName != NULL)) {
            nC2Msg =
#ifndef _USE_ICON_DISPLAY
               pData->dllData.lC2Compliance == C2DLL_C2 ? IDS_YES_C2 :
               pData->dllData.lC2Compliance == C2DLL_SECURE ? IDS_YES_SECURE :
#endif
               IDS_NO_C2;
            _stprintf (szBuff,
                GetStringResource (GET_INSTANCE(hWnd), IDS_LINE_FORMAT),
                GetStringResource (GET_INSTANCE(hWnd), nC2Msg),
                pData->dllData.szItemName,
                pData->dllData.szStatusName);
            lstrcpy (pData->szDisplayString, szBuff);
            pItemData = GLOBAL_ALLOC (sizeof(C2LB_DATA));
            if (pItemData != NULL) {
                *pItemData = *pData;
                // make sure action code is set to 0 as an intial value
                pItemData->dllData.lActionCode = 0;
#ifdef _OWNERDRAW_LIST_BOX
                // add data structure to list box
                lIndex = SendMessage (hWnd, LB_INSERTSTRING, wParam,
                    (LPARAM)pItemData);
                if (lIndex != LB_ERR) {
                    SetMaxItemLen (hWnd, szBuff);
                    lReturn = (LRESULT)TRUE;
                } else {
                    // item not added so free memory
                    GLOBAL_FREE_IF_ALLOC (pItemData);
                    lReturn = (LRESULT)FALSE;
                }
#else
                // add string to list box
                lIndex = SendMessage (hWnd, LB_INSERTSTRING, wParam,
                    (LPARAM)szBuff);
                if (lIndex != LB_ERR) {
                    // string was added ok, get the string length as displayed
                    SetMaxItemLen (hWnd, szBuff);
                    SendMessage (hWnd, LB_SETITEMDATA,
                        (WPARAM)lIndex, (LPARAM)pItemData);
                    lReturn = (LRESULT)TRUE;
                } else {
                    // unable to add item to list box
                    GLOBAL_FREE_IF_ALLOC (pItemData);
                    lReturn = (LRESULT)FALSE;
                }
#endif
            } else {
                // unable to allocate data buffer for this item
                lReturn = (LRESULT)FALSE;
            }
        } else {
            // empty strings were passed in data buffer
            lReturn = (LRESULT)FALSE;
        }
    } else {
        // null pointer was passed to function.
        lReturn = (LRESULT)FALSE;
    }
    return lReturn;
}

static
LRESULT
ListWnd_LB_DRAWITEM (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    LPDRAWITEMSTRUCT    pDrawItemInfo;
    PC2LB_DATA          pItemData;
    COLORREF            crBackColor;
    COLORREF            crTextColor;
    HPEN                hRectPen = NULL;
    HBRUSH              hRectBrush = NULL;
    LOGBRUSH            lbRect;
    int                 nTabs;
    LPINT               lpTabStopArray;
    RECT                rClient;
    RECT                rDraw;
    int                 nSavedDc;
    int                 nIdBitmap;
    int                 nIdMask;
    HBITMAP             hMask;
    HBITMAP             hBitmap;
    HDC                 hBmDc;
    BITMAP              bmBmInfo;


    if (lParam == 0) return FALSE;  // no item data to process

    // get pointer to data structure
    pDrawItemInfo = (LPDRAWITEMSTRUCT)lParam;

    LISTWND_DEBUG_STATUS(pDrawItemInfo);

    if (pDrawItemInfo->CtlType != ODT_LISTBOX) {
        // don't know where this came from, but we don't want it
        return FALSE;
    }

    nSavedDc = SaveDC (pDrawItemInfo->hDC);
    
    // Check the state field to determine the appearance
    // of the text, background, etc.

    if (((pDrawItemInfo->itemState & ODS_SELECTED) == ODS_SELECTED) ||
         ((pDrawItemInfo->itemState & ODS_FOCUS) == ODS_FOCUS)) {
        // get selected background color
        crBackColor = GetSysColor (COLOR_HIGHLIGHT);
        crTextColor = GetSysColor (COLOR_HIGHLIGHTTEXT);
    } else {
        // get un-selected background color
        crBackColor = GetSysColor (COLOR_WINDOW);
        crTextColor = GetSysColor (COLOR_MENUTEXT);
    }

    // create background rectangle brush
    lbRect.lbStyle = BS_SOLID;
    lbRect.lbHatch = 0; // not used
    lbRect.lbColor = crBackColor;
    hRectBrush = CreateBrushIndirect (&lbRect);

    // create a solid pen
    hRectPen = CreatePen (
        PS_SOLID,
        0,
        crBackColor);

    // draw background rectangle
    SelectObject (pDrawItemInfo->hDC, hRectPen);
    SelectObject (pDrawItemInfo->hDC, hRectBrush);
    Rectangle (pDrawItemInfo->hDC,
        pDrawItemInfo->rcItem.left,
        pDrawItemInfo->rcItem.top,
        pDrawItemInfo->rcItem.right,
        pDrawItemInfo->rcItem.bottom);

    // draw message text

    pItemData = (PC2LB_DATA)pDrawItemInfo->itemData;

    if (pItemData == NULL) {
        // no app data to put into list box item
        return FALSE;
    } else {
        // set text font and text & background color
        SetTextColor (pDrawItemInfo->hDC, crTextColor);
        SetBkColor (pDrawItemInfo->hDC, crBackColor);
        SetBkMode (pDrawItemInfo->hDC, TRANSPARENT); 

        SelectObject (pDrawItemInfo->hDC, hFontListBox);
        nTabs = GetTitleDlgTabs (&lpTabStopArray);
        // draw text
        TabbedTextOut (
            pDrawItemInfo->hDC,
            pDrawItemInfo->rcItem.left,  // starting X coord of text
            pDrawItemInfo->rcItem.top,  // starting Y coord of text
            pItemData->szDisplayString, // tabbed text to display
            lstrlen (pItemData->szDisplayString),
            nTabs,
            lpTabStopArray,
            0);
        // draw icon finally
        // select the icon based on the current state of the item
        
        switch (pItemData->dllData.lC2Compliance) {
            case C2DLL_UNKNOWN:
                nIdBitmap = IDB_UNKNOWN;
                nIdMask = IDB_UNKNOWN_MASK;
                break;

            case C2DLL_C2:
                nIdBitmap = IDB_C2_SECURE;
                nIdMask = IDB_SECURE_MASK;
                break;

            case C2DLL_SECURE:
                nIdBitmap = IDB_SECURE;
                nIdMask = IDB_SECURE_MASK;
                break;

            case C2DLL_NOT_SECURE:
                nIdBitmap = IDB_NOT_SECURE;
                nIdMask = IDB_NOT_SECURE_MASK;
                break;

            default:
                nIdBitmap = 0;              break;
        }

        if (nIdBitmap != 0) {
            hBitmap = LoadBitmap (
                GET_INSTANCE (hWnd),
                MAKEINTRESOURCE ((WORD)nIdBitmap));
            hMask = LoadBitmap (
                GET_INSTANCE (hWnd),
                MAKEINTRESOURCE ((WORD)nIdMask));
            if ((hBitmap != NULL) && (hMask != NULL)) {
                hBmDc = CreateCompatibleDC (pDrawItemInfo->hDC);
                if (hBmDc != NULL) {
                    SelectObject (hBmDc, hBitmap);
                    GetObject (hBitmap, sizeof(BITMAP), &bmBmInfo);
                    MaskBlt (pDrawItemInfo->hDC,
                        pDrawItemInfo->rcItem.left,
                        pDrawItemInfo->rcItem.top,
                        bmBmInfo.bmWidth,
                        bmBmInfo.bmHeight,
                        hBmDc,
                        0, 0,
                        hMask,
                        0,0,
                        MAKEROP4(SRCCOPY,SRCAND));
                    DeleteDC (hBmDc);
                } // else  compatible DC not created
                if (hBitmap != NULL) DeleteObject (hBitmap);
                if (hMask != NULL) DeleteObject (hMask);
            } // else bitmap not loaded
        } // else no bitmap selected.
    }

    if (hRectBrush != NULL) DeleteObject (hRectBrush);
    if (hRectPen != NULL) DeleteObject (hRectPen);

    RestoreDC (pDrawItemInfo->hDC, nSavedDc);

    return (LRESULT)TRUE;
}

static
LRESULT
ListWnd_LB_RESETCONTENT (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    LONG    lItemCount, lIndex;
    LPVOID  pData;

    lItemCount = SendMessage (hWnd, LB_GETCOUNT, 0, 0);

    // free item data

    for (lIndex = 0; lIndex < lItemCount; lIndex++) {
        pData = (LPVOID)SendMessage (hWnd, LB_GETITEMDATA, (WPARAM)lIndex, 0);
        GLOBAL_FREE_IF_ALLOC (pData);
    }

    // reset max string length
    lMaxItemLen = 0;

    // now let the listbox function reset the list box

    return (DefListProc(hWnd, LB_RESETCONTENT, wParam, lParam));
}

static
LRESULT
ListWnd_WM_COMMAND (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dispatch control messages

Arguments:

    IN  HWND hDlg,           window handle of the dialog box

    IN  WPARAM  wParam       WIN32: HIWORD = notification code,
                                    LOWORD = ID of control
                             WIN16: ID of control

    IN  LPARAM  lParam       WIN32: hWnd of Control
                             WIN16: HIWORD = notification code,
                                    LOWORD = hWnd of control


Return Value:

    TRUE if message processed by this or a subordinate routine
    FALSE if message not processed

--*/
{
    WORD    wNotifyMsg;
    HWND    hCtrlWnd;

    wNotifyMsg  = GET_NOTIFY_MSG (wParam, lParam);
    hCtrlWnd    = GET_COMMAND_WND (lParam);

    return (DefListProc(hWnd, WM_COMMAND, wParam, lParam));
}

static
LRESULT
ListWnd_WM_CHAR (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
{
    switch ((TCHAR)wParam) {
        case VK_RETURN:
        case VK_SPACE:
            // treat the space and the enter key as mouse double-clicks
            PostMessage (GetParent(hWnd), WM_COMMAND,
                MAKEWPARAM((WORD)GetWindowLong(hWnd, GWL_ID), (WORD)LBN_DBLCLK),
                (LPARAM)hWnd);
            return ERROR_SUCCESS;

        default:
            return DefListProc (hWnd, WM_CHAR, wParam, lParam);
    }
}

static
LRESULT
ListWnd_WM_CLOSE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    prepares the application for exiting.

Arguments:

    hWnd        window handle of List window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    // release list item attribute structures
    SendMessage (hWnd, LB_RESETCONTENT, 0, 0);

    // free list box logical font
    if (hFontListBox != NULL) DeleteObject (hFontListBox);

    // and toss the window
    DestroyWindow (hWnd);
    return ERROR_SUCCESS;
}

static
LRESULT
ListWnd_WM_NCDESTROY (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    This routine processes the WM_NCDESTROY message to free any application
        or List window memory.

Arguments:

    hWnd        window handle of List window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    return ERROR_SUCCESS;
}

//
//  GLOBAL functions
//
LRESULT CALLBACK
ListWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for restkeys application.

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    0   or
    value returned by DefListProc

--*/
{
    switch (message) {
        case LB_GET_C2_STATUS:
            return ListWnd_LB_GET_C2_STATUS (hWnd, wParam, lParam);

        case LB_SET_C2_STATUS:
            return ListWnd_LB_SET_C2_STATUS (hWnd, wParam, lParam);

        case LB_ADD_C2_ITEM:
            return ListWnd_LB_ADD_C2_ITEM (hWnd, wParam, lParam);

        case LB_DISPLAY_C2_ITEM_UI:
            return ListWnd_LB_DISPLAY_C2_ITEM_UI (hWnd, wParam, lParam);

        case LB_SET_MIN_WIDTH:
            return ListWnd_LB_SET_MIN_WIDTH (hWnd, wParam, lParam);

        case LB_RESETCONTENT:
            return ListWnd_LB_RESETCONTENT (hWnd, wParam, lParam);

        case LB_DRAWITEM:
            return ListWnd_LB_DRAWITEM (hWnd, wParam, lParam);

        case WM_GETMINMAXINFO:
            return ListWnd_WM_GETMINMAXINFO (hWnd, wParam, lParam);

        case WM_COMMAND:
            return ListWnd_WM_COMMAND (hWnd, wParam, lParam);

        case WM_CHAR:
            return ListWnd_WM_CHAR (hWnd, wParam, lParam);

        case WM_ENDSESSION:
            return ListWnd_WM_CLOSE (hWnd, FALSE, lParam);

        case WM_CLOSE:
            return ListWnd_WM_CLOSE (hWnd, TRUE, lParam);

        case WM_NCDESTROY:
            return ListWnd_WM_NCDESTROY (hWnd, wParam, lParam);

	    default:          // Passes it on if unproccessed
		    return (DefListProc(hWnd, message, wParam, lParam));
    }
}

BOOL
ListWndFillMeasureItemStruct (
    LPMEASUREITEMSTRUCT     lpItem
)
{
    lpItem->CtlType = ODT_LISTBOX;
    lpItem->CtlID = IDC_LIST;
    lpItem->itemHeight = LB_ITEM_HEIGHT;
    return TRUE;
}

HWND
CreateListWindow (
   IN  HINSTANCE  hInstance,
   IN  HWND       hParentWnd,
   IN  INT        nChildId
)
{
    HWND        hWnd;   // return value
    RECT        rParentClient;
    LOGFONT lfListBox;  // list box display font description

    GetClientRect (hParentWnd, &rParentClient);

    // Create a List window for this application instance.

    hWnd = CreateWindowEx(
        0L,                 // make this window normal so debugger isn't covered
	    GetStringResource (hInstance, IDS_LISTBOX_CLASS), // See RegisterClass() call.
	    NULL,                           // Text for window title bar.
	    LIST_WINDOW_STYLE,   // Window style.
	    rParentClient.left,
 	    rParentClient.top,
        rParentClient.right,
	    rParentClient.bottom,
	    hParentWnd,
	    (HMENU)nChildId,    // Child Window ID
	    hInstance,	         // This instance owns this window.
	    NULL                // not used
    );

    if (hWnd != NULL) {
        // subclass list box proc
        DefListProc = (WNDPROC)GetWindowLong(hWnd, GWL_WNDPROC);
        SetWindowLong (hWnd, GWL_WNDPROC, (LONG)ListWndProc);
        // set tabstops
        ListWndSetTabStops (hWnd);

        // create a font to draw list box text with

        memset (&lfListBox, 0, sizeof(lfListBox));

        lfListBox.lfHeight = LB_FONT_HEIGHT;
        lfListBox.lfWidth = LB_FONT_WIDTH;
        lstrcpy (lfListBox.lfFaceName, LB_FONT_FACE); 

        hFontListBox = CreateFontIndirect (&lfListBox);
    }

    // If window could not be created, return "failure"

    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\mainwnd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mainwnd.c

Abstract:

    Main Window procedure for C2Config UI.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <tchar.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <string.h>
#include    <shellapi.h>
#include    "c2config.h"
#include    "resource.h"
#include    "c2utils.h"
#include    "strings.h"
#include    "mainwnd.h"
#include    "listwnd.h"
#include    "titlewnd.h"
#include    "rebootex.h"
#include    "splash.h"

typedef struct _THREAD_PARAM {
    HWND    hWndOwner;
    HWND    hWndSplash;
} THREAD_PARAM, *PTHREAD_PARAM;

static  THREAD_PARAM    tpThread;

// key state variable
static BOOL bSystemMode = FALSE;
static BOOL bShowRebootDlg = FALSE;

// forward reference
static
LRESULT
MainWnd_IDC_LIST_SELCHANGE (
    IN  HWND    hWndOwner,
    IN  WPARAM  wCtrlId,
    IN  HWND    hCtrlWnd
);


static
BOOL
GetDllData (
    IN  HWND        hWnd,
    IN  LPCTSTR     szItem,
    IN  LPCTSTR     szInfo,
    OUT PC2LB_DATA  pData
)
{
    HMODULE hDll;
    LONG    lRebootFlag;
    TCHAR   szDllName[MAX_PATH];
    TCHAR   szErrorMsg[MAX_PATH * 2];

    // try to get the DLL's module handle. If it's been opened
    // already, then this will succeed, if not it will fail and
    // the library will be opened in the next call.

    lstrcpy (szDllName, GetItemFromIniEntry(szInfo, INF_DLL_NAME));
    hDll = GetModuleHandle (szDllName);

    if (hDll == NULL) {
         // then this DLL hasn't been loaded yet, so load it
        hDll = LoadLibrary (szDllName);
    }

    // one way or another, the DLL should have been found or loaded.

    if (hDll != NULL) {
        // get function addresses from dll now.

        if ((pData->pQueryFn = (PC2DLL_FUNC) GetProcAddressT (hDll,
            GetItemFromIniEntry(szInfo, INF_QUERY_FN))) == NULL) {
            _stprintf (szErrorMsg,
                GetStringResource (GET_INSTANCE(hWnd), IDS_ERROR_FIND_PROC),
                GetItemFromIniEntry(szInfo, INF_QUERY_FN),
                szDllName);
            MessageBox (
                hWnd,
                szErrorMsg,
                GetStringResource (GET_INSTANCE(hWnd), IDS_APP_ERROR),
                MBOKCANCEL_EXCLAIM);
            return FALSE;
        }

        if ((pData->pDisplayFn = (PC2DLL_FUNC) GetProcAddressT (hDll,
            GetItemFromIniEntry(szInfo, INF_DISPLAY_FN))) == NULL) {
            _stprintf (szErrorMsg,
                GetStringResource (GET_INSTANCE(hWnd), IDS_ERROR_FIND_PROC),
                GetItemFromIniEntry(szInfo, INF_DISPLAY_FN),
                szDllName);
            MessageBox (
                hWnd,
                szErrorMsg,
                GetStringResource (GET_INSTANCE(hWnd), IDS_APP_ERROR),
                MBOKCANCEL_EXCLAIM);
            return FALSE;
        }

        if ((pData->pSetFn = (PC2DLL_FUNC) GetProcAddressT (hDll,
            GetItemFromIniEntry(szInfo, INF_SET_FN))) == NULL) {
            _stprintf (szErrorMsg,
                GetStringResource (GET_INSTANCE(hWnd), IDS_ERROR_FIND_PROC),
                GetItemFromIniEntry(szInfo, INF_SET_FN),
                szDllName);
            MessageBox (
                hWnd,
                szErrorMsg,
                GetStringResource (GET_INSTANCE(hWnd), IDS_APP_ERROR),
                MBOKCANCEL_EXCLAIM);
            return FALSE;
        }

        lRebootFlag = _tcstol(GetItemFromIniEntry(szInfo, INF_REBOOT_FLAG),
            NULL, 10);
        pData->bRebootWhenChanged = (lRebootFlag != 0 ? TRUE : FALSE);

        GetFilePath (GetItemFromIniEntry (szInfo, INF_HELP_FILE_NAME),
            pData->dllData.szHelpFileName);

        pData->dllData.ulHelpContext = _tcstoul (
            GetItemFromIniEntry (szInfo, INF_HELP_CONTEXT), NULL, 10);

        return TRUE;
    } else {
        _stprintf (szErrorMsg,
            GetStringResource (GET_INSTANCE(hWnd), IDS_ERROR_OPEN_DLL),
            szDllName,
            szItem);
        MessageBox (
            hWnd,
            szErrorMsg,
            GetStringResource (GET_INSTANCE(hWnd), IDS_APP_ERROR),
            MBOKCANCEL_EXCLAIM);
        return FALSE;
    }
}

static
LONG
MainWnd_RefreshList (
    IN  HWND    hWnd
)
{
    LONG    lCount;
    LONG    lIndex;
    LONG    lCurSel;

    HWND    hWndList;

    hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);

    lCurSel = SendMessage (hWndList, LB_GETCURSEL, 0, 0);

    // reset text length, since we're going to update all window items
    SendMessage (hWndList, LB_SET_MIN_WIDTH, 0, 0);

    // update all items
    lCount = SendMessage (hWndList, LB_GETCOUNT, 0, 0);
    for (lIndex = 0; lIndex < lCount; lIndex++) {
        SendMessage (hWndList, LB_GET_C2_STATUS, (WPARAM)lIndex, 0);
    }
    
    // set selection in case it moved
    SendMessage (hWndList, LB_SETCURSEL, (WPARAM)lCurSel, 0);

    return ERROR_SUCCESS;
}

static
LONG
MainWnd_FindNextNonC2Item (
    IN  HWND    hWnd,
    IN  INT     nDirectionKey
)
{
    INT nLimit;
    INT nStart;
    INT nStep;
    INT nItem;

    HWND    hWndList;

    PC2LB_DATA   pData;

    hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);
    nStart = SendMessage (hWndList, LB_GETCURSEL, 0, 0);

    if (nDirectionKey == VK_DOWN) {
        nStep = 1;
        nLimit = SendMessage (hWndList, LB_GETCOUNT, 0, 0);
        nStart += 1;
    } else { // up
        nStep = -1;
        nLimit = -1;
        nStart -= 1;
    }

    for (nItem = nStart; nItem != nLimit; nItem += nStep) {
        SendMessage (hWndList, LB_GET_C2_STATUS,
            (WPARAM)nItem, 0);
        pData = (PC2LB_DATA)SendMessage (hWndList, LB_GETITEMDATA,
            (WPARAM)nItem, 0);
        if (pData != NULL) {
            if (pData->dllData.lC2Compliance == C2DLL_NOT_SECURE) break;
        } else {
            break;
        }
    }

    if (nItem == nLimit) {
        DisplayMessageBox (
            hWnd,
            IDS_NOMORE_NONC2,
            IDS_APP_TITLE,
            MBOK_INFO);
    } else {
        // set selection
        SendMessage (hWndList, LB_SETCURSEL, (WPARAM)nItem, 0);
        // make status appear
        PostMessage (hWndList, WM_CHAR, (WPARAM)TEXT('\r'), 0);
    }

    return ERROR_SUCCESS;
}

static
LRESULT
MainWndInitListItems (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // hWnd of splash window
)
/*++

Routine Description:

   Loads List box with items from the C2CONFIG.INF file

Arguments:

    hWnd        window handle to main window (the one being created)
    wParam      not used
    lParam      hWnd of splash window

Return Value:

    TRUE if memory allocation was successful, and
        window creation can continue
    FALSE if an error occurs and window creation should stop

--*/
{
    HWND     hWndList;
    HWND     hSplash;
    LONG     lCount;
    LONG     lIndex;
    TCHAR    szBuff[SMALL_BUFFER_SIZE];
    TCHAR    szInfFileName[MAX_PATH];
    TCHAR    mszItems[MEDIUM_BUFFER_SIZE];
    LPTSTR   szThisItem;
    DWORD    dwTrialCount = 100;

    DWORD   dwReturn;

    C2LB_DATA   c2lbData;

MWLL_GetListWindow:

    hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);

    if (IsWindow(hWndList)) {
        // get dlg window ID.
        hSplash = (HWND)lParam;

        SendMessage (hWndList, LB_RESETCONTENT, 0, 0);   // clear the List Box

        // get Full path to INF file containing c2security items

        if (GetInfPath (hWnd, IDS_C2_ITEM_INF, szInfFileName)) {
            // INF file found so read the item section and process
            // each entry
            lCount = 0;
            szThisItem = (LPTSTR)GetStringResource (GET_INSTANCE(hWnd), IDS_C2ITEM_SECTION);
            dwReturn = GetPrivateProfileString (
                szThisItem,
                NULL, // return all keys,
                cmszEmptyString,
                mszItems,
                MEDIUM_BUFFER_SIZE,
                szInfFileName);

            if (dwReturn > 0) {
                // one or more items was returned so look each one up
                // and load it into the list box.
                for (szThisItem = mszItems;
                    *szThisItem != 0;
                    szThisItem += (lstrlen(szThisItem)+ 1)) {
                    // for each item in the list,
                    // look up the information and save it

                    dwReturn = GetPrivateProfileString (
                        GetStringResource (GET_INSTANCE(hWnd), IDS_C2ITEM_SECTION),
                        szThisItem,
                        cszEmptyString,
                        szBuff,
                        SMALL_BUFFER_SIZE,
                        szInfFileName);

                    if (dwReturn > 0) {
                        c2lbData.dwSize = sizeof(C2LB_DATA);

                        // open DLL and find processing routines for this item
                        if (GetDllData (hWnd, szThisItem, szBuff, &c2lbData)) {
                            // initialize args used by DLL function
                            c2lbData.dllData.lActionCode = 0;
                            c2lbData.dllData.hWnd = hWnd;
                            c2lbData.dllData.lC2Compliance = C2DLL_NOT_SECURE;
                            _stprintf (c2lbData.dllData.szItemName, TEXT("%.64s"), szThisItem);
                            _stprintf (szBuff, TEXT("Hex Value (0x%.4x)"), lCount);
                            lstrcpy (c2lbData.dllData.szStatusName, szBuff);
                            // add this item to the list
                            SendMessage (hWndList, LB_ADD_C2_ITEM,
                                (WPARAM)-1, (LPARAM)&c2lbData);
                            lCount++;
                        } else {
                            // an error occured, but was handled in the
                            // GetDllData function so no further action
                            // is required.
                        }
                    }
                }
            } else {
            	// unable to read INF file
            	dwReturn = GetLastError();
            }

            if (lCount > 0) {
                // update all items
                lCount = SendMessage (hWndList, LB_GETCOUNT, 0, 0);
                for (lIndex = 0; lIndex < lCount; lIndex++) {
                    SendMessage (hWndList, LB_GET_C2_STATUS, (WPARAM)lIndex, 0);
                }
                SendMessage (hWndList, LB_SETCURSEL, 0, 0);
                // initialize help context
                MainWnd_IDC_LIST_SELCHANGE (hWnd, IDC_LIST, hWndList);
                
                // tell splash it's OK to disappear
                if (IsWindow(hSplash)) {
                    PostMessage (hSplash, SWM_INIT_COMPLETE, 0, 0);
                }
            } else {
                // no security items loaded so display message and
                // exit
                DisplayMessageBox (hWnd,
                    IDS_ERROR_NO_ITEMS,
                    IDS_APP_ERROR,
                    MBOK_EXCLAIM);

                PostMessage (hWnd, WM_CLOSE, 0, 0);
            }
        } else {
            // unable to fine inf file so display error message
            DisplayMessageBox (
                hWnd,
                IDS_ERROR_NO_INF,
                IDS_APP_ERROR,
                MBOK_EXCLAIM);

            // and terminate application
            PostMessage (hWnd, WM_CLOSE, 0, 0);
        }
    } else {
        // list window has not been created yet, so sleep for 100 mSec
        // and try again
        Sleep (100);
        if (--dwTrialCount) goto MWLL_GetListWindow;
    }

    return ERROR_SUCCESS;
}

static
DWORD
MainWndInitThreadProc (
    IN  LPVOID lParam
)
/*++

Routine Description:

    Displays the splash window and initializes the application data

Arguments:

    IN  LPVOID  lParam

Return Value:

    ERROR_SUCCESS

--*/
{
    PTHREAD_PARAM   ptpThread;

    if (lParam != NULL) {
        ptpThread = (PTHREAD_PARAM)lParam;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    
    // start list box initialization (regardless of how the splash window
    // creation turned out

    MainWndInitListItems(ptpThread->hWndOwner, 0,
        (LPARAM)ptpThread->hWndSplash);

    // post message to close splash window

    PostMessage (ptpThread->hWndSplash, SWM_INIT_COMPLETE, 0, 0);

    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_NCCREATE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    allocate the application data

Arguments:

    hWnd        window handle to main window (the one being created)
    wParam      not used
    lParam      not used

Return Value:

    TRUE if memory allocation was successful, and
        window creation can continue
    FALSE if an error occurs and window creation should stop

--*/
{
    return (LRESULT)TRUE;
}

static
LRESULT
MainWnd_WM_CREATE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:



Arguments:

    hWnd        window handle to main window (the one being created)
    wParam      not used
    lParam      not used

Return Value:

    TRUE if memory allocation was successful, and
        window creation can continue
    FALSE if an error occurs and window creation should stop

--*/
{
    if (!EnableSecurityPriv()) {
        DisplayMessageBox (
            hWnd,
            IDS_ERROR_NO_PRIV,
            IDS_APP_ERROR,
            MBOK_EXCLAIM);
        PostMessage (hWnd, WM_CLOSE, 0, 0);
    }

    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_MAIN_WINDOW (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // Not used
    IN  LPARAM lParam      // Not used
)
/*++

Routine Description:

   Loads List box with items from the C2CONFIG.INF file

Arguments:

    hWnd        window handle to main window (the one being created)
    wParam      not used
    lParam      not used

Return Value:

    TRUE if memory allocation was successful, and
        window creation can continue
    FALSE if an error occurs and window creation should stop

--*/
{
    HWND    hWndList;

    // now that all is initialized show the main window
    ShowWindow (hWnd, SW_SHOWNORMAL);
    SetWindowPos (hWnd, NULL, 0, 0, -1,
        MAINWND_Y_DEFAULT, SWP_NOMOVE | SWP_NOZORDER);

    hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);

    SetActiveWindow (hWnd);

    UpdateWindow(hWnd);         // Sends WM_PAINT message

    SetFocus(hWndList);

    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_IDC_LIST_SELCHANGE (
    IN  HWND    hWndOwner,
    IN  WPARAM  wCtrlId,
    IN  HWND    hCtrlWnd
)
{
    int         nCurSel;
    PC2LB_DATA  pLBData;

    nCurSel = SendMessage (hCtrlWnd, LB_GETCURSEL, 0, 0);

    if (nCurSel != LB_ERR) {
        pLBData = (PC2LB_DATA)SendMessage (hCtrlWnd, LB_GETITEMDATA,
            (WPARAM)nCurSel, 0);
        if (pLBData != NULL) {
            SetHelpFileName (pLBData->dllData.szHelpFileName);
            SetHelpContextId (LOWORD(pLBData->dllData.ulHelpContext));
        }
    }
    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_IDC_LIST_DBLCLK (
    IN  HWND    hWnd,
    IN  HWND    hCtrlWnd
)
{
    LONG    lSelection;
    PC2LB_DATA    pc2lbData;
    LONG    lResult;

    lSelection = SendMessage (hCtrlWnd, LB_GETCURSEL, 0, 0);

    // show UI for current selection
    lResult = SendMessage (hCtrlWnd, LB_DISPLAY_C2_ITEM_UI,
        (WPARAM)lSelection, 0);

    if (lResult != 0) {
        if (SendMessage (hCtrlWnd, LB_SET_C2_STATUS,
            (WPARAM)lSelection, (LPARAM)lResult)) {
            // the desired action was taken, so see if
            // this change requires the system to be rebooted in order
            // to take effect
            if (!bShowRebootDlg) {
                // if the flag is already set, then there's no point to
                // doing this
                pc2lbData = (PC2LB_DATA)SendMessage (hCtrlWnd, LB_GETITEMDATA,
                    (WPARAM)lSelection, 0);
                if (pc2lbData != NULL) {
                    bShowRebootDlg = pc2lbData->bRebootWhenChanged;
                }
            }
        }
    }

    SetFocus (hCtrlWnd);

    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_IDC_LIST_COMMAND (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    WORD    wNotifyMsg;
    HWND    hCtrlWnd;

    wNotifyMsg  = GET_NOTIFY_MSG (wParam, lParam);
    hCtrlWnd    = GET_COMMAND_WND (lParam);

   switch (wNotifyMsg) {
      case LBN_SELCHANGE:
        return MainWnd_IDC_LIST_SELCHANGE (hWnd, wParam, hCtrlWnd);

      case LBN_DBLCLK:
        return MainWnd_IDC_LIST_DBLCLK (hWnd, hCtrlWnd);

      default:
         return DefWindowProc (hWnd, WM_COMMAND, wParam, lParam);
   }
}

static
LRESULT
MainWnd_WM_COMMAND (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dispatch control messages

Arguments:

    IN  HWND hDlg,           window handle of the dialog box

    IN  WPARAM  wParam       WIN32: HIWORD = notification code,
                                    LOWORD = ID of control
                             WIN16: ID of control

    IN  LPARAM  lParam       WIN32: hWnd of Control
                             WIN16: HIWORD = notification code,
                                    LOWORD = hWnd of control


Return Value:

    TRUE if message processed by this or a subordinate routine
    FALSE if message not processed

--*/
{
    WORD    wNotifyMsg;
    HWND    hCtrlWnd;

    wNotifyMsg  = GET_NOTIFY_MSG (wParam, lParam);
    hCtrlWnd    = GET_COMMAND_WND (lParam);

    switch (GET_CONTROL_ID(wParam)) {
        case IDC_LIST:
            // process messages from the list box
            return MainWnd_IDC_LIST_COMMAND (hWnd, wParam, lParam);

        case IDM_FILE_EXIT:
            PostMessage (hWnd, WM_CLOSE, 0, 0);
            return ERROR_SUCCESS;

        case IDM_VIEW_PRIOR:
            return MainWnd_FindNextNonC2Item (hWnd, VK_UP);

        case IDM_VIEW_NEXT:
            return MainWnd_FindNextNonC2Item (hWnd, VK_DOWN);

        case IDM_VIEW_REFRESH:
            return MainWnd_RefreshList (hWnd);

        case IDM_HELP_CONTENTS:
            ShowAppHelpContents (hWnd);
            return ERROR_SUCCESS;

        case IDM_HELP_ITEM:
            ShowAppHelp (hWnd);
            return ERROR_SUCCESS;

        case IDM_HELP_ABOUT:
            ShellAbout (hWnd,
                GetStringResource (GET_INSTANCE(hWnd), IDS_ABOUT_BOX_TITLE),
                GetStringResource (GET_INSTANCE(hWnd), IDS_APP_TITLE),
                LoadIcon(GET_INSTANCE(hWnd), MAKEINTRESOURCE (IDI_APPICON)));

            return ERROR_SUCCESS;

        default:
		    return (DefWindowProc(hWnd, WM_COMMAND, wParam, lParam));
    }
}

static
LRESULT
MainWnd_WM_ACTIVATEAPP (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    enables and disables the F1 hot key to be active only
        when the app is active (i.e. has focus)


Arguments:

    IN  HWND    hWnd
        window handle

    IN  WPARAM  wParam
        TRUE when app is being activated
        FALSE when app is being deactivated

    IN  LPARAM  lParam
        Thread getting focus (if wParam = FALSE)

Return Value:

    ERROR_SUCCESS

--*/
{
    HWND    hWndList;

    if ((BOOL)wParam) {
        // getting focus so enable hot key
        RegisterHotKey (
            hWnd,
            HELP_HOT_KEY,
            0,
            VK_F1);
        // set focus to list window
        hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);
        SetFocus (hWndList);
    } else {
        UnregisterHotKey (
            hWnd,
            HELP_HOT_KEY);
    }


    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_HOTKEY (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    processes hot key messages to call help when f1 is pressed

Arguments:

    IN  HWND    hWnd
        window handle

    IN  WPARAM  wParam
        id of hotkey pressed

    IN  LPARAM  lParam
        Not Used

Return Value:

    ERROR_SUCCESS

--*/
{
    switch ((int)wParam) {
        case HELP_HOT_KEY:
            ShowAppHelp (hWnd);
            return ERROR_SUCCESS;

        default:
            return DefWindowProc (hWnd, WM_HOTKEY, wParam, lParam);
    }
}

static
LRESULT
MainWnd_WM_SIZE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
)
/*++

Routine Description:

    called after the main window has been resized. Resizes child windows.

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
   RECT  rMainClient;
   HWND  hWndList = NULL;
   HWND  hWndTitle = NULL;

   GetClientRect (hWnd, &rMainClient);

    hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);
    hWndTitle = GET_HWND (hWnd, MAIN_WL_TITLE_WINDOW);

    if (IsWindow (hWndList)) {
        // update title box size
        SetWindowPos (hWndTitle, NULL,
            rMainClient.left,
            rMainClient.top,
            rMainClient.right,
            GetTitleBarHeight(),
            SWP_NOZORDER);
        // fit list window under title bar
        rMainClient.top += GetTitleBarHeight();
        rMainClient.bottom -= GetTitleBarHeight();
        SetWindowPos (hWndList, NULL,
            rMainClient.left, rMainClient.top,
            rMainClient.right, rMainClient.bottom,
            SWP_NOZORDER);
    }

   return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_GETMINMAXINFO  (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
)
/*++

Routine Description:

    called before the main window has been resized. Queries the child windows
      for any size limitations

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{

   HWND  hWndList = NULL;
   HWND  hWndTitle = NULL;
   MINMAXINFO  mmList;
   MINMAXINFO  mmTitle;
   LPMINMAXINFO   pmmMain;

   RECT  rDesktop;

   pmmMain = (LPMINMAXINFO)lParam;

   if (pmmMain != NULL) {

      memset (&mmList, 0, sizeof(MINMAXINFO));
      memset (&mmTitle, 0, sizeof(MINMAXINFO));

      GetClientRect (GetDesktopWindow(),&rDesktop);

      // set min/max info for just the main window and it's contents

      pmmMain->ptMaxSize.x = rDesktop.right;
      pmmMain->ptMaxSize.y = rDesktop.bottom;

      pmmMain->ptMaxPosition.x = rDesktop.left;
      pmmMain->ptMaxPosition.y = rDesktop.top;

      pmmMain->ptMaxTrackSize = pmmMain->ptMaxSize;

      pmmMain->ptMinTrackSize.x = GetSystemMetrics (SM_CXFRAME) * 2 + 0;
      pmmMain->ptMinTrackSize.y = GetSystemMetrics (SM_CYFRAME) * 2 +
                                 GetSystemMetrics (SM_CYCAPTION) * 2;

      //
      // get minimum sizes allowed by child windows
      //
      hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);
      hWndTitle = GET_HWND (hWnd, MAIN_WL_TITLE_WINDOW);

      if (hWndList != NULL) ListWnd_WM_GETMINMAXINFO (hWndList,
         wParam, (LPARAM)&mmList);
      if (hWndTitle != NULL)  TitleWnd_WM_GETMINMAXINFO (hWndTitle,
         wParam, (LPARAM)&mmTitle);

      // add in minimums from child windows

      // this isn't working as expected, the returned size still
      // clips the text.

      pmmMain->ptMinTrackSize.x += mmList.ptMinTrackSize.x +
                                 mmTitle.ptMinTrackSize.x;
      pmmMain->ptMinTrackSize.y += mmList.ptMinTrackSize.y +
                                 mmTitle.ptMinTrackSize.y;
   }

   return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_KEY_MESSAGE (
    IN  HWND    hWnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    HWND    hWndList;
    int nVirtKey;

    nVirtKey = (int)wParam;
    hWndList = GET_HWND (hWnd, MAIN_WL_LIST_WINDOW);

    if (IsWindow(hWndList)) {
        if (message != WM_CHAR) {
            if (nVirtKey == VK_MENU) {
                if (message == WM_KEYDOWN) {
                    bSystemMode = TRUE;
                } else if (message == WM_KEYUP) {
                    bSystemMode = FALSE;
                }
            }

            if (!bSystemMode) {
                switch ((int)wParam) {
                    case VK_RETURN:
                    case VK_UP:
                    case VK_DOWN:
                    case VK_RIGHT:
                    case VK_LEFT:
                    case VK_PRIOR:
                    case VK_NEXT:
                    case VK_HOME:
                    case VK_END:
                        // send these to the list box window
                        PostMessage (hWndList, message, wParam, lParam);
                        return ERROR_SUCCESS;

                    default:
                        return DefWindowProc (hWnd, message, wParam, lParam);
                }
            } else {
                return DefWindowProc (hWnd, message, wParam, lParam);
            }
        } else {
            return DefWindowProc (hWnd, message, wParam, lParam);
        }
    } else {
        return DefWindowProc (hWnd, message, wParam, lParam);
    }
}
          
static
LRESULT
MainWnd_WM_MEASUREITEM (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    processes owner draw messages from child windows. These
        are just passed back to the child window to keep
        all the child window code in the same module

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    LPMEASUREITEMSTRUCT     pMeasureItemInfo;

    pMeasureItemInfo = (LPMEASUREITEMSTRUCT)lParam;

    // dispatch message back to the original control
    switch (pMeasureItemInfo->CtlID) {
        case IDC_LIST:
            ListWndFillMeasureItemStruct (pMeasureItemInfo);
            return ERROR_SUCCESS;

        default:
            return DefWindowProc (hWnd, WM_DRAWITEM, wParam, lParam);
    }
}
          
static
LRESULT
MainWnd_WM_DRAWITEM (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    processes owner draw messages from child windows. These
        are just passed back to the child window to keep
        all the child window code in the same module

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    LPDRAWITEMSTRUCT  pDrawItemInfo;

    pDrawItemInfo = (LPDRAWITEMSTRUCT)lParam;

    // dispatch message back to the original control
    switch (pDrawItemInfo->CtlID) {
        case IDC_LIST:
            SendMessage (pDrawItemInfo->hwndItem, LB_DRAWITEM, wParam, lParam);
            return ERROR_SUCCESS;

        default:
            return DefWindowProc (hWnd, WM_DRAWITEM, wParam, lParam);
    }
}

static
LRESULT
MainWnd_WM_CLOSE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    prepares the application for exiting.

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    QuitAppHelp (hWnd);

    if (bShowRebootDlg) {
        DialogBox (
            GET_INSTANCE(hWnd),
            MAKEINTRESOURCE (IDD_REBOOT_EXIT),
            hWnd,
            RebootExitDlgProc);
    }

    DestroyWindow (hWnd);
    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_NCDESTROY (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    This routine processes the WM_NCDESTROY message to free any application
        or main window memory.

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    return ERROR_SUCCESS;
}

//
//  GLOBAL functions
//
LRESULT CALLBACK
MainWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for restkeys application.

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    0   or
    value returned by DefWindowProc

--*/
{
    switch (message) {
        case WM_NCCREATE:
            return MainWnd_WM_NCCREATE (hWnd, wParam, lParam);

        case WM_CREATE:
            return MainWnd_WM_CREATE (hWnd, wParam, lParam);

        case MAINWND_SHOW_MAIN_WINDOW:
            return MainWnd_SHOW_MAIN_WINDOW (hWnd, wParam, lParam);

        case WM_COMMAND:
            return MainWnd_WM_COMMAND (hWnd, wParam, lParam);

        case WM_ACTIVATEAPP:
            return MainWnd_WM_ACTIVATEAPP (hWnd, wParam, lParam);

        case WM_HOTKEY:
            return MainWnd_WM_HOTKEY (hWnd, wParam, lParam);

        case UM_SHOW_CONTEXT_HELP:
            ShowAppHelp (hWnd);
            return ERROR_SUCCESS;

        case WM_GETMINMAXINFO:
            return MainWnd_WM_GETMINMAXINFO (hWnd, wParam, lParam);

        case WM_SIZE:
            return MainWnd_WM_SIZE (hWnd, wParam, lParam);

        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
            return MainWnd_KEY_MESSAGE (hWnd, message, wParam, lParam);

        case WM_MEASUREITEM:
            return MainWnd_WM_MEASUREITEM (hWnd, wParam, lParam);

        case WM_DRAWITEM:
            return MainWnd_WM_DRAWITEM (hWnd, wParam, lParam);

        case WM_ENDSESSION:
            return MainWnd_WM_CLOSE (hWnd, FALSE, lParam);

        case WM_CLOSE:
            return MainWnd_WM_CLOSE (hWnd, TRUE, lParam);

        case WM_NCDESTROY:
            PostQuitMessage(ERROR_SUCCESS);
            return MainWnd_WM_NCDESTROY (hWnd, wParam, lParam);

	    default:          // Passes it on if unproccessed
		    return (DefWindowProc(hWnd, message, wParam, lParam));
    }
}

BOOL
RegisterMainWindowClass (
    IN  HINSTANCE   hInstance
)
/*++

Routine Description:

    Registers the main window class for this application

Arguments:

    hInstance   application instance handle

Return Value:

    Return value of RegisterClass function

--*/
{
    WNDCLASS    wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;   // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = MAIN_WW_SIZE;           // Num per-window extra data bytes.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE (IDI_APPICON)); // Icon  from .RC
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);     // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);        // Default color
    wc.lpszMenuName  = MAKEINTRESOURCE (IDM_C2CONFIG_MENU);  // Menu name from .RC
    wc.lpszClassName = GetStringResource(hInstance, IDS_APP_WINDOW_CLASS); // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL)RegisterClass(&wc);
}

HWND
CreateMainWindow (
    IN  HINSTANCE   hInstance
)
{
    HWND        hWnd;   // return value
    HWND        hWndTitle; // title bar window
    HWND        hWndList;  // list box window
    RECT        rClient;    // main window client rectangle
    DWORD       ThreadID;

    // Create a main window for this application instance.

    hWnd = CreateWindowEx(
        0L,                 // make this window normal so debugger isn't covered
	    GetStringResource (hInstance, IDS_APP_WINDOW_CLASS), // See RegisterClass() call.
	    GetStringResource (hInstance, IDS_APP_TITLE), // Text for window title bar.
	    (DWORD)(WS_OVERLAPPEDWINDOW),   // Window style.
	    CW_USEDEFAULT,
	    CW_USEDEFAULT,
        MAINWND_X_DEFAULT,
	    MAINWND_Y_DEFAULT,
	    (HWND)NULL,		    // Overlapped windows have no parent.
	    (HMENU)NULL,        // use class menu
	    hInstance,	        // This instance owns this window.
	    NULL                // not used
    );

    // If window could not be created, return "failure"
    if (hWnd != NULL) {
        ShowWindow(hWnd, SW_HIDE);// Hide the main window until after splash
        // set window loc
        CenterWindow (hWnd, GetDesktopWindow());
        // create title bar window
        hWndTitle = CreateTitleWindow (hInstance, hWnd, IDC_TITLE);
        if (hWndTitle != NULL) {
            SET_HWND (hWnd, MAIN_WL_TITLE_WINDOW, hWndTitle);
            // create list box window
            hWndList = CreateListWindow (hInstance, hWnd, IDC_LIST);
            if (hWndList != NULL) {
                // save the list box window handle
                SET_HWND (hWnd, MAIN_WL_LIST_WINDOW, hWndList);
                // fit list window under title bar
                GetClientRect (hWnd, &rClient);
                rClient.top += GetTitleBarHeight()+1;
                rClient.bottom -= GetTitleBarHeight();
                SetWindowPos (hWndList, NULL,
                    rClient.left, rClient.top,
                    rClient.right, rClient.bottom,
                    SWP_NOZORDER);
                SetWindowText (hWnd, GetStringResource (hInstance, IDS_APP_TITLE));

                // display splash window
                tpThread.hWndSplash = CreateSplashWindow (
                    GET_INSTANCE(hWnd), hWnd, IDD_SPLASH);
                tpThread.hWndOwner = hWnd;
    
                CreateThread (NULL, 0, MainWndInitThreadProc,
                    (LPVOID)&tpThread, 0, &ThreadID);
            } else {
                // unable to create child window so bail out here
                DestroyWindow (hWnd);
                hWnd = NULL;
            }
        } else {
            // unable to create child window so bail out here
            DestroyWindow (hWnd);
            hWnd = NULL;
        }
    }
    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\splash.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    splash.c

Abstract:

    Window procedure for C2Config splash title window

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <tchar.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    "c2config.h"
#include    "resource.h"
#include    "c2utils.h"
#include    "mainwnd.h"
#include    "splash.h"

#define     SPLASH_WINDOW_STYLE (DWORD)(WS_POPUP | WS_VISIBLE)
#define     SPLASH_TIMEOUT      5000    //milliseconds

// local windows messages
#define SWM_CHECK_COMPLETE    (WM_USER + 201)

static  HBITMAP hSplashBmp = NULL;
static  BITMAP  bmSplashInfo = {0L, 0L, 0L, 0L, 0, 0, NULL};
static  UINT    nSplashTimer = 0;

static  BOOL    bDisplayComplete;
static  BOOL    bInitComplete;

static
LRESULT
SplashWnd_WM_NCCREATE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    initializes data and structures prior to window creation

Arguments:

    hWnd        window handle of List window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    hSplashBmp = LoadBitmap (GET_INSTANCE(hWnd), MAKEINTRESOURCE(IDB_SPLASH));
    if (hSplashBmp != NULL) {
        GetObject (hSplashBmp, sizeof(bmSplashInfo), (LPVOID)&bmSplashInfo);

        bDisplayComplete = FALSE;
        bInitComplete = FALSE;

        return (LRESULT)TRUE;   // initialized successfully
    } else {
        return (LRESULT)FALSE;  // unable to load splash bmp
    }
}

static
LRESULT
SplashWnd_WM_CREATE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    initializes the window after creation

Arguments:

    hWnd        window handle of List window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    // size window to contain bitmap
#if 1   // for debugging this is 0 to keep it from covering the debugger
    SetWindowPos (hWnd, HWND_TOPMOST, 0, 0,
        bmSplashInfo.bmWidth,       // bitmap width
        bmSplashInfo.bmHeight,      // bitmap + height
        SWP_NOMOVE);    // size and change Z-ORDER
#else 
    SetWindowPos (hWnd, NULL, 0, 0,
        bmSplashInfo.bmWidth,       // bitmap width
        bmSplashInfo.bmHeight,      // bitmap + height
        SWP_NOMOVE | SWP_NOZORDER);    // size only
#endif

    // now position window in the desktop
    CenterWindow (hWnd, GetDesktopWindow());

    InvalidateRect (hWnd, NULL, TRUE);  // and draw the bitmap

    // Start the display timer

    nSplashTimer = SetTimer (hWnd, SPLASH_TIMER, SPLASH_TIMEOUT, NULL);

    if (nSplashTimer == 0) {
        // no timer was created so post the timer expired message now
        PostMessage (hWnd, SWM_DISPLAY_COMPLETE, 0, 0);
    }

    return ERROR_SUCCESS;
}

static
LRESULT
SplashWnd_WM_PAINT (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PAINTSTRUCT ps;
    HDC         hDcBitmap;
    RECT        rClient;

    GetClientRect (hWnd, &rClient);
    BeginPaint (hWnd, &ps);

    hDcBitmap = CreateCompatibleDC (ps.hdc);

    SelectObject (hDcBitmap, hSplashBmp);

    BitBlt (ps.hdc, 0, 0, rClient.right, rClient.bottom,
        hDcBitmap, 0, 0, SRCCOPY);

    DeleteDC (hDcBitmap);

    EndPaint (hWnd, &ps);

    return ERROR_SUCCESS;
}

static
LRESULT
SplashWnd_SWM_DISPLAY_COMPLETE (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    sent to indicate the expiration of the display timeout

--*/
{
    bDisplayComplete = TRUE;
    PostMessage (hWnd, SWM_CHECK_COMPLETE, 0, 0);
    return ERROR_SUCCESS;
}

static
LRESULT
SplashWnd_SWM_INIT_COMPLETE (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Sent to indicate that all data has been initialized

--*/
{
    bInitComplete = TRUE;
    PostMessage (hWnd, SWM_CHECK_COMPLETE, 0, 0);
    return ERROR_SUCCESS;
}

static
LRESULT
SplashWnd_SWM_CHECK_COMPLETE (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    if (bInitComplete && bDisplayComplete) {
        PostMessage (hWnd, WM_CLOSE, 0, 0); // end window
    }
    return ERROR_SUCCESS;
}

static
LRESULT
SplashWnd_WM_CLOSE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    prepares the application for exiting.

Arguments:

    hWnd        window handle of List window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    // display initialized window
    SendMessage (GetParent(hWnd), MAINWND_SHOW_MAIN_WINDOW, 0, 0);

    // then destroy this window
    DestroyWindow (hWnd);

    return ERROR_SUCCESS;
}

static
LRESULT
SplashWnd_WM_NCDESTROY (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    This routine processes the WM_NCDESTROY message to free any application
        or List window memory.

Arguments:

    hWnd        window handle of List window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    // discard the bitmap
    if (hSplashBmp != NULL) DeleteObject (hSplashBmp);
    
    return ERROR_SUCCESS;
}

//
//  GLOBAL functions
//
LRESULT CALLBACK
SplashWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for restkeys application.

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    0   or
    value returned by DefListProc

--*/
{
    switch (message) {
        case WM_NCCREATE:
            return SplashWnd_WM_NCCREATE (hWnd, wParam, lParam);

        case WM_CREATE:
            return SplashWnd_WM_CREATE (hWnd, wParam, lParam);

        case WM_PAINT:
            return SplashWnd_WM_PAINT (hWnd, TRUE, lParam);

        case WM_TIMER:
            // dispose of timer
            KillTimer (hWnd, nSplashTimer);
            // indicate display has timed out
            PostMessage (hWnd, SWM_DISPLAY_COMPLETE, 0, 0);
            return ERROR_SUCCESS;

        case SWM_DISPLAY_COMPLETE:
            return SplashWnd_SWM_DISPLAY_COMPLETE (hWnd, wParam, lParam);

        case SWM_INIT_COMPLETE:
            return SplashWnd_SWM_INIT_COMPLETE (hWnd, wParam, lParam);

        case SWM_CHECK_COMPLETE:
            return SplashWnd_SWM_CHECK_COMPLETE (hWnd, wParam, lParam);

        case WM_ENDSESSION:
            return SplashWnd_WM_CLOSE (hWnd, FALSE, lParam);

        case WM_CLOSE:
            return SplashWnd_WM_CLOSE (hWnd, TRUE, lParam);

        case WM_NCDESTROY:
            return SplashWnd_WM_NCDESTROY (hWnd, wParam, lParam);

	    default:          // Passes it on if unproccessed
		    return (DefWindowProc(hWnd, message, wParam, lParam));
    }
}

BOOL
RegisterSplashWindowClass (
    IN  HINSTANCE   hInstance
)
/*++

Routine Description:

    Registers the main window class for this application

Arguments:

    hInstance   application instance handle

Return Value:

    Return value of RegisterClass function

--*/
{
    WNDCLASS    wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)SplashWndProc; // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = 0;                      // No extra data bytes.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = NULL;                   // No Icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);     // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);        // Default color
    wc.lpszMenuName  = NULL;                   // Menu name from .RC
    wc.lpszClassName = GetStringResource(hInstance, IDS_APP_SPLASH_CLASS); // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL)RegisterClass(&wc);
}

HWND
CreateSplashWindow (
   IN  HINSTANCE  hInstance,
   IN  HWND       hParentWnd,
   IN  INT        nChildId
)
{
    HWND    hWndReturn = NULL;
    DWORD   dwLastError = 0;

    // Create a List window for this application instance.
    hWndReturn = CreateWindowEx(
        0L,                 // make this window normal so debugger isn't covered
        GetStringResource (hInstance, IDS_APP_SPLASH_CLASS), // See RegisterClass() call.
	    TEXT("C2Config_SplashWindow"),   // Text for window title bar.
        SPLASH_WINDOW_STYLE,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        hParentWnd,			// no parent
        (HMENU)NULL,        // no menu
        hInstance,	        // This instance owns this window.
        NULL                // not used
    );
    if (hWndReturn == NULL) {
        dwLastError = GetLastError();
    }
    return hWndReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\mainwnd.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    MainWnd.H

Abstract:
    
    Global functions and constants used by the Main Application Window

Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _MAINWND_H_
#define _MAINWND_H_
//
//  Main Window Constants
//
//      default window size
//
#define MAINWND_X_DEFAULT   480
#define MAINWND_Y_DEFAULT   320

// main window longword offsets in bytes
//
#define MAIN_WL_TITLE_WINDOW  0
#define MAIN_WL_LIST_WINDOW   4
#define MAIN_WW_SIZE          8

// DLL information from INF file
//
#define INF_DLL_NAME        1
#define INF_QUERY_FN        2
#define INF_SET_FN          3
#define INF_DISPLAY_FN      4
#define INF_REBOOT_FLAG     5
#define INF_HELP_FILE_NAME  6
#define INF_HELP_CONTEXT    7

// External Windows messages
#define  MAINWND_SHOW_MAIN_WINDOW    (WM_USER + 201)
//
//
//  Global functions
//
LRESULT CALLBACK
MainWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
);

BOOL
RegisterMainWindowClass (
    IN  HINSTANCE   hInstance
);

HWND
CreateMainWindow (
    IN  HINSTANCE   hInstance
);


#endif  // _MAINWND_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\c2funcres.h ===
TEMPORARY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\titlewnd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Titlewnd.c

Abstract:

    Window procedure for C2Config title window.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <stdio.h>
#include    "c2config.h"
#include    "resource.h"
#include    "c2utils.h"

#define     TITLE_WINDOW_STYLE (DWORD)(WS_CHILD | WS_VISIBLE)

// title text positioning

#define     TITLE_BAR_TEXT_INDENT   4
#define     TITLE_BAR_TEXT_Y        0
#define     TITLE_BAR_SHADING_WIDTH 2
#define     TITLE_BAR_FEATURE_TAB   24
#define     TITLE_BAR_STATUS_TAB    180
#define     TITLE_BAR_LINE_WIDTH    1

#define     NUM_TABS_IN_ARRAY   2
static  INT     nTabArray[NUM_TABS_IN_ARRAY] = {
    TITLE_BAR_FEATURE_TAB,
    TITLE_BAR_STATUS_TAB};

static  INT     nListTabArray[NUM_TABS_IN_ARRAY+1] = {
    0+TITLE_BAR_TEXT_INDENT,
    TITLE_BAR_FEATURE_TAB+TITLE_BAR_TEXT_INDENT,
    TITLE_BAR_STATUS_TAB+TITLE_BAR_TEXT_INDENT};

static  INT     nListDeviceTabArray[NUM_TABS_IN_ARRAY+1];

static  INT     nReturnTabArray[NUM_TABS_IN_ARRAY+1];

static  HPEN    hDarkPen = NULL;    // title bar shadow
static  HPEN    hLightPen = NULL;   // title bar highlight
static  HPEN    hBlackPen = NULL;   // window border

static  LONG    lTitleBar_Y = 0;


static
LRESULT
TitleWnd_WM_NCCREATE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    allocate the application data

Arguments:

    hWnd        window handle to Title window (the one being created)
    wParam      not used
    lParam      not used

Return Value:

    TRUE if memory allocation was successful, and
        window creation can continue
    FALSE if an error occurs and window creation should stop

--*/
{
    // this is the color of the button highlight
    hLightPen = CreatePen (PS_SOLID, 0, RGB (255,255,255));

    // this is the color used to draw the title bar shadow
    hDarkPen = CreatePen (PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));

    // this is the color used to draw the window border line
    hBlackPen = CreatePen (PS_SOLID, 0, RGB(0,0,0));

    // define the title bar height to be the same height as that of menu bar
    lTitleBar_Y = GetSystemMetrics(SM_CYMENU);

    return (LRESULT)TRUE;
}

static
LRESULT
TitleWnd_WM_CREATE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:



Arguments:

    hWnd        window handle to Title window (the one being created)
    wParam      not used
    lParam      not used

Return Value:

    TRUE if memory allocation was successful, and
        window creation can continue
    FALSE if an error occurs and window creation should stop

--*/
{
    return ERROR_SUCCESS;
}

LRESULT
TitleWnd_WM_GETMINMAXINFO  (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
)
/*++

Routine Description:

    called before the main window has been resized. Queries the child windows
      for any size limitations

Arguments:

    hWnd        window handle of main window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{

   LPMINMAXINFO   pmmWnd;

   pmmWnd = (LPMINMAXINFO)lParam;

   if (pmmWnd != NULL) {
      pmmWnd->ptMinTrackSize.x = 0;

      pmmWnd->ptMinTrackSize.y = lTitleBar_Y;
   }

   return ERROR_SUCCESS;
}

static
LRESULT
TitleWnd_WM_PAINT (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
{
    PAINTSTRUCT ps;
    LPCTSTR     szTitleString;
    RECT        rClient, rShade;
    COLORREF    crBackColor;
    COLORREF    crTextColor;
    LONG        lTabStop;

    szTitleString = GetStringResource (GET_INSTANCE(hWnd), IDS_TITLE_BAR_STRING),
    crBackColor = (COLORREF)GetSysColor (COLOR_BTNFACE);
    crTextColor = (COLORREF)GetSysColor (COLOR_BTNTEXT);

    BeginPaint (hWnd, &ps);

    SetMapMode (ps.hdc, MM_TEXT);
    SetBkColor (ps.hdc, crBackColor);
    SetBkMode  (ps.hdc, TRANSPARENT);
    SetTextColor (ps.hdc, crTextColor);

    TabbedTextOut (
        ps.hdc,
        TITLE_BAR_TEXT_INDENT,
        TITLE_BAR_TEXT_Y,
        szTitleString,
        lstrlen(szTitleString),
        NUM_TABS_IN_ARRAY,
        &nTabArray[0],
        TITLE_BAR_TEXT_INDENT);

    // draw shadow lines

    GetClientRect (hWnd, &rClient);

    for (lTabStop = 0; lTabStop <= NUM_TABS_IN_ARRAY; lTabStop++) {
        rShade = rClient;
#if __DRAW_BUTTON_SEPARATORS
        if (lTabStop < NUM_TABS_IN_ARRAY) {
            rShade.right = rShade.left + nTabArray[lTabStop];
        }
        if (lTabStop != 0) {
            rShade.left = nTabArray[lTabStop-1];
        }

        DrawRaisedShading (&rShade, &ps, TITLE_BAR_SHADING_WIDTH, hLightPen, hDarkPen);
#else   // draw thin line separators
        if (lTabStop < NUM_TABS_IN_ARRAY){
            rShade.left = nTabArray[lTabStop];
            rShade.right =  rShade.left+TITLE_BAR_LINE_WIDTH;
            // top & bottom are the same as the client window
            DrawSeparatorLine (&rShade, &ps, hDarkPen);
        }
#endif
    }
    
    // draw bottom window line
    SelectObject (ps.hdc, hBlackPen);
    MoveToEx (ps.hdc, rClient.left, rClient.bottom-1, NULL);
    LineTo (ps.hdc, rClient.right, rClient.bottom-1);

    EndPaint (hWnd, &ps);

    return ERROR_SUCCESS;
}

static
LRESULT
TitleWnd_WM_CLOSE (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    prepares the application for exiting.

Arguments:

    hWnd        window handle of Title window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    DestroyWindow (hWnd);
    return ERROR_SUCCESS;
}

static
LRESULT
TitleWnd_WM_NCDESTROY (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    This routine processes the WM_NCDESTROY message to free any application
        or Title window memory.

Arguments:

    hWnd        window handle of Title window
    wParam,     not used
    lParam      not used

Return Value:

    ERROR_SUCCESS

--*/
{
    DeleteObject (hLightPen);
    DeleteObject (hDarkPen);
    DeleteObject (hBlackPen);
    return ERROR_SUCCESS;
}

//
//  GLOBAL functions
//
LONG
GetTitleDlgTabs (
    IN OUT  LPINT   *ppTabArray
)
{
    if (ppTabArray == NULL) {
        // no pointer so bail
        return 0;
    } else {
        // make a copy of the real array and return it
        memcpy (nReturnTabArray, nListTabArray,
            (sizeof(INT) * (NUM_TABS_IN_ARRAY+1)));
        *ppTabArray = &nReturnTabArray[0];
        return NUM_TABS_IN_ARRAY+1;
    }
}
LONG
GetTitleDeviceTabs (
    IN OUT  LPINT   *ppTabArray
)
{
    LONG    lDlgBaseUnits;
    WORD    wBaseUnitX;
    WORD    wBaseUnitY;
    LONG    lTab;

    lDlgBaseUnits = GetDialogBaseUnits();
    wBaseUnitX = LOWORD(lDlgBaseUnits);
    wBaseUnitY = HIWORD(lDlgBaseUnits);

    if (ppTabArray == NULL) {
        // no pointer so bail
        return 0;
    } else {
        if (*ppTabArray == NULL) {
            // address of a null pointer so exit
            return 0;
        } else {
            // update the device tab list array
            for (lTab = 0; lTab <= NUM_TABS_IN_ARRAY; lTab++) {
                nListDeviceTabArray[lTab] =
                    (nListTabArray[lTab] * (INT)wBaseUnitX) / 4;
            }
            // make a copy of the real array and return it
            memcpy (nReturnTabArray, nListDeviceTabArray,
                (sizeof(INT) * (NUM_TABS_IN_ARRAY+1)));
            *ppTabArray = &nReturnTabArray[0];
            return NUM_TABS_IN_ARRAY+1;
        }
    }
}

LONG
GetTitleBarHeight (
)
{
    return lTitleBar_Y;
}

LRESULT CALLBACK
TitleWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for restkeys application.

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    0   or
    value returned by DefWindowProc

--*/
{
    switch (message) {
        case WM_NCCREATE:
            return TitleWnd_WM_NCCREATE (hWnd, wParam, lParam);

        case WM_CREATE:
            return TitleWnd_WM_CREATE (hWnd, wParam, lParam);

        case WM_GETMINMAXINFO:
            return TitleWnd_WM_GETMINMAXINFO (hWnd, wParam, lParam);

        case WM_PAINT:
            return TitleWnd_WM_PAINT (hWnd, wParam, lParam);

        case WM_ENDSESSION:
            return TitleWnd_WM_CLOSE (hWnd, FALSE, lParam);

        case WM_CLOSE:
            return TitleWnd_WM_CLOSE (hWnd, TRUE, lParam);

        case WM_NCDESTROY:
            return TitleWnd_WM_NCDESTROY (hWnd, wParam, lParam);

	    default:          // Passes it on if unproccessed
		    return (DefWindowProc(hWnd, message, wParam, lParam));
    }
}

HWND
CreateTitleWindow (
   IN  HINSTANCE  hInstance,
   IN  HWND       hParentWnd,
   IN  INT        nChildId
)
{
    HWND        hWnd;   // return value
    RECT        rParentClient;

    GetClientRect (hParentWnd, &rParentClient);

    // Create a Title window for this application instance.

    hWnd = CreateWindowEx(
        0L,                 // make this window normal so debugger isn't covered
	    GetStringResource(hInstance, IDS_APP_TITLE_CLASS), // See RegisterClass() call.
	    NULL,                           // Text for window title bar.
	    TITLE_WINDOW_STYLE,   // Window style.
	    rParentClient.left,
	    rParentClient.top,
        rParentClient.right,
        lTitleBar_Y,
	    hParentWnd,
	    (HMENU)nChildId,    // Child Window ID
	    hInstance,	         // This instance owns this window.
	    NULL                // not used
    );

    // If window could not be created, return "failure"

    return hWnd;
}

BOOL
RegisterTitleWindowClass (
    IN  HINSTANCE   hInstance
)
/*++

Routine Description:

    Registers the title bar window class for this application

Arguments:

    hInstance   application instance handle

Return Value:

    Return value of RegisterClass function

--*/
{
    WNDCLASS    wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)TitleWndProc;  // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = 0;                      // no extra data bytes.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = NULL;                   // No Icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);     // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);        // Default color
    wc.lpszMenuName  = NULL;                    // No MEnu
    wc.lpszClassName = GetStringResource(hInstance, IDS_APP_TITLE_CLASS); // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL)RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\splash.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Splash.H

Abstract:

    define the exported routines, datatypes and constants of the 
    splash.C module

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#ifndef _SPLASH_H_
#define _SPLASH_H_

// splash windows messages

#define SWM_DISPLAY_COMPLETE  (WM_USER + 101)
#define SWM_INIT_COMPLETE     (WM_USER + 102)

BOOL
RegisterSplashWindowClass (
    IN  HINSTANCE   hInstance
);

HWND
CreateSplashWindow (
   IN  HINSTANCE  hInstance,
   IN  HWND       hParentWnd,
   IN  INT        nChildId
);

LRESULT CALLBACK
SplashWndProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);
#endif // _SPLASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\audtfail.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    audtfail.C

Abstract:

    functions used to set the Crash on audit Fail paramter 
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_AUDITFAIL_NOCHANGE       0
#define AC_AUDITFAIL_SET_CRASH      1
#define AC_AUDITFAIL_SET_NOCRASH    2

#define SECURE             C2DLL_SECURE


static
BOOL
SetAuditFailSetting (
    DWORD   dwNewValue
)
{
    HKEY    hKeyLsa = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_LSA_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeyLsa);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so set value
        lStatus = RegSetValueEx (
            hKeyLsa,
            GetStringResource (GetDllInstance(), IDS_AUDIT_FAIL_VALUE),
            0L,
            REG_DWORD,
            (CONST LPBYTE)&dwNewValue,
            sizeof(DWORD));

        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeyLsa);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
BOOL
GetAuditFailSetting (
)
{
    HKEY    hKeyLsa = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwValue = 0;
    DWORD   dwValueSize = sizeof(DWORD);
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_LSA_KEY),
        0L,
        KEY_READ,
        &hKeyLsa);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check value
        lStatus = RegQueryValueEx (
            hKeyLsa,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_AUDIT_FAIL_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType == REG_DWORD) {
                // check value. The "C2" value is 1, any
                // other value is NOT C2
                if (dwValue == 1) {
                    bReturn = TRUE;
                } else {
                    bReturn = FALSE;
                }
                SetLastError (ERROR_SUCCESS);
            } else {
                // wrong data type returned
                bReturn = FALSE;
                SetLastError (ERROR_CANTREAD);
            }
        } else {
            // no value present
            bReturn = FALSE;
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeyLsa);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

BOOL CALLBACK
C2AuditFailDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Audit Failure dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;
            // get Audit failure settings

            CheckDlgButton (hDlg, IDC_HALT_WHEN_LOG_FULL,
                (GetAuditFailSetting() ? CHECKED : UNCHECKED));

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        if (IsDlgButtonChecked (hDlg, IDC_HALT_WHEN_LOG_FULL) == CHECKED) {
                            *lpdwNewValue = TRUE;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else {
                            *lpdwNewValue = FALSE;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckDlgButton (hDlg, IDC_HALT_WHEN_LOG_FULL, CHECKED);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryCrashAuditFail (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting = 0;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        if (GetAuditFailSetting()) {
            pC2Data->lC2Compliance = SECURE;
            nMsgString = IDS_AUDIT_FAIL_CRASH;
        } else {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_AUDIT_FAIL_NO_CRASH;
        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgString));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetCrashAuditFail (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action valie = the new value of the wrap setting
        if (pC2Data->lActionCode != AC_AUDITFAIL_NOCHANGE) {
            nMsgString = 0;
            if (pC2Data->lActionCode == AC_AUDITFAIL_SET_CRASH) {
                if (SetAuditFailSetting (1)) {
                    pC2Data->lC2Compliance = SECURE;
                    nMsgString = IDS_AUDIT_FAIL_CRASH;
                } else {
                    DisplayDllMessageBox (
                        pC2Data->hWnd,
                        IDS_AUDIT_ERROR_NO_SET,
                        IDS_AUDIT_CAPTION,
                        MBOK_EXCLAIM);
                }
            } else if (pC2Data->lActionCode == AC_AUDITFAIL_SET_NOCRASH) {
                if (SetAuditFailSetting (0)) {
                    pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                    nMsgString = IDS_AUDIT_FAIL_NO_CRASH;
                } else {
                    DisplayDllMessageBox (
                        pC2Data->hWnd,
                        IDS_AUDIT_ERROR_NO_SET,
                        IDS_AUDIT_CAPTION,
                        MBOK_EXCLAIM);
                }
            }
            if (nMsgString != 0) {
                // update status string if set was successful
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), nMsgString));
            }
        }
        // update action values
        pC2Data->lActionCode = 0;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayCrashAuditFail (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    DWORD       dwNewValue;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_AUDIT_FAIL),
            pC2Data->hWnd,
            C2AuditFailDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            pC2Data->lActionValue = 0;
            if (dwNewValue) {
                pC2Data->lActionCode = AC_AUDITFAIL_SET_CRASH;
            } else {
                pC2Data->lActionCode = AC_AUDITFAIL_SET_NOCRASH;
            }
        } else {
            // no action
            pC2Data->lActionCode = AC_AUDITFAIL_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\allocdrv.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    allocdrv.c

Abstract:

    functions used to set the allocate drives on logon feature
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

   4 July 95

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_ALLOC_DRIVES_NOCHANGE    0
#define AC_ALLOC_DRIVES_CHANGE      1
#define AC_ALLOC_FLOPPY_DRIVE       1
#define AC_ALLOC_CDROM_DRIVE        2
#define AC_ALLOC_BOTH_DRIVE_TYPES   3

#define SECURE             C2DLL_SECURE


static
BOOL
SetAllocateDriveSetting (
    DWORD   dwNewValue
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;
    TCHAR   szNewValue[2] = {0,0};

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        if (dwNewValue & AC_ALLOC_FLOPPY_DRIVE) {
            szNewValue[0] = TEXT('1');
        } else {
            szNewValue[0] = TEXT('0');
        }
        // key opened OK so set value
        lStatus = RegSetValueEx (
            hKeyWinlogon,
            GetStringResource (GetDllInstance(), IDS_ALLOCATE_FLOPPIES_VALUE),
            0L,
            REG_SZ,
            (CONST LPBYTE)&szNewValue,
            sizeof(szNewValue));

        if (lStatus == ERROR_SUCCESS) {
            if (dwNewValue & AC_ALLOC_CDROM_DRIVE) {
                szNewValue[0] = TEXT('1');
            } else {
                szNewValue[0] = TEXT('0');
            }
            lStatus = RegSetValueEx (
                hKeyWinlogon,
                GetStringResource (GetDllInstance(), IDS_ALLOCATE_CDROMS_VALUE),
                0L,
                REG_SZ,
                (CONST LPBYTE)&szNewValue,
                sizeof(szNewValue));
        }

        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
DWORD
GetAllocateDriveSetting (
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    TCHAR   szValue[MAX_PATH];
    DWORD   dwValueSize = sizeof(szValue);
    DWORD   dwValue = 0;
    DWORD   dwReturn = 0;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_READ,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check values
        lStatus = RegQueryValueEx (
            hKeyWinlogon,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_ALLOCATE_FLOPPIES_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)&szValue,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType == REG_SZ) {
                // check value. The "secure" value is 1, any
                // other value is NOT secure
                if (szValue[0] == TEXT('1')) {
                    dwReturn |= AC_ALLOC_FLOPPY_DRIVE;
                }
                SetLastError (ERROR_SUCCESS);
            } else {
                // wrong data type returned
                SetLastError (ERROR_CANTREAD);
            }
            // key opened OK so check values
            lStatus = RegQueryValueEx (
                hKeyWinlogon,
                (LPTSTR)GetStringResource (GetDllInstance(), IDS_ALLOCATE_CDROMS_VALUE),
                (LPDWORD)NULL,
                &dwType,
                (LPBYTE)&szValue,
                &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
                // value read successfully so check it out
                if (dwType == REG_SZ) {
                    // check value. The "secure" value is 1, any
                    // other value is NOT secure
                    if (szValue[0] == TEXT('1')) {
                        dwReturn |= AC_ALLOC_CDROM_DRIVE;
                    }
                    SetLastError (ERROR_SUCCESS);
                } else {
                    // wrong data type returned
                    SetLastError (ERROR_CANTREAD);
                }
            } else {
                // no value present
                SetLastError (ERROR_CANTREAD);
            }
        } else {
            // no value present
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        dwReturn = 0;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return dwReturn;
}

BOOL CALLBACK
C2AllocateDrivesDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog procedure for Allocate removable drives dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;
            // get Audit failure settings

            CheckDlgButton (hDlg, IDC_ALLOCATE_FLOPPY,
                (GetAllocateDriveSetting() & AC_ALLOC_FLOPPY_DRIVE ? CHECKED : UNCHECKED));

            CheckDlgButton (hDlg, IDC_ALLOCATE_CDROM,
                (GetAllocateDriveSetting() & AC_ALLOC_CDROM_DRIVE ? CHECKED : UNCHECKED));

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;  // clear value, then set as each check box is read
                        if (IsDlgButtonChecked (hDlg, IDC_ALLOCATE_FLOPPY) == CHECKED) {
                            *lpdwNewValue |= AC_ALLOC_FLOPPY_DRIVE;
                        }
                        if (IsDlgButtonChecked (hDlg, IDC_ALLOCATE_CDROM) == CHECKED) {
                            *lpdwNewValue |= AC_ALLOC_CDROM_DRIVE;
                        }
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckDlgButton (hDlg, IDC_ALLOCATE_FLOPPY, CHECKED);
                        CheckDlgButton (hDlg, IDC_ALLOCATE_CDROM, CHECKED);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryAllocateDrives (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting = 0;
    UINT         nMsgString;
    DWORD       dwSettings;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        dwSettings = GetAllocateDriveSetting();
        if (dwSettings == AC_ALLOC_BOTH_DRIVE_TYPES) {
            pC2Data->lC2Compliance = SECURE;
            nMsgString = IDS_ALLOCATE_BOTH_DRIVES_MSG;
        } else if (dwSettings & AC_ALLOC_CDROM_DRIVE) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_ALLOCATE_CDROM_DRIVE_MSG;
        } else if (dwSettings & AC_ALLOC_FLOPPY_DRIVE) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_ALLOCATE_FLOPPY_DRIVE_MSG;
        } else {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_ALLOCATE_NO_DRIVES_MSG;
        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgString));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetAllocateDrives (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action value = the new value of the allocate flags
        if (pC2Data->lActionCode != AC_ALLOC_DRIVES_NOCHANGE) {
            nMsgString = 0;
            if (!SetAllocateDriveSetting (pC2Data->lActionValue)) {
                DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_AUDIT_ERROR_NO_SET,
                    IDS_AUDIT_CAPTION,
                    MBOK_EXCLAIM);
            } else {
                // get new status & strings
                C2QueryAllocateDrives (lParam);
            }
        }
        // update action values
        pC2Data->lActionCode = AC_ALLOC_DRIVES_NOCHANGE;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayAllocateDrives (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    DWORD       dwNewValue;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_ALLOC_DRIVES),
            pC2Data->hWnd,
            C2AllocateDrivesDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            pC2Data->lActionCode = AC_ALLOC_DRIVES_CHANGE;
            pC2Data->lActionValue = dwNewValue;
        } else {
            // no action
            pC2Data->lActionCode = AC_ALLOC_DRIVES_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\titlewnd.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    TitleWnd.H

Abstract:
    
    Global functions and constants used by the application's list window

Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _TITLEWND_H_
#define _TITLEWND_H_

//
//  Global functions
//
LONG
GetTitleDlgTabs (
    IN OUT  LPINT   *ppTabArray // pointer to get address of tab array
);

LONG
GetTitleDeviceTabs (
    IN OUT  LPINT   *ppTabArray // pointer to get address of tab array
);

LONG
GetTitleBarHeight (
    VOID
);

LRESULT CALLBACK
TitleWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
);
 
LRESULT
TitleWnd_WM_GETMINMAXINFO  (
    IN	HWND hWnd,         // window handle
    IN	WPARAM wParam,     // additional information
    IN   LPARAM lParam      // additional information
);

BOOL
RegisterTitleWindowClass (
    IN  HINSTANCE   hInstance
);


HWND
CreateTitleWindow (
    IN  HINSTANCE   hInstance,
    IN  HWND        hParentWnd,
    IN  INT         nChildId

);



#endif  // _TITLEWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2config\verify.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Verify.C

Abstract:

    functions to validate the prerequisites of a secure system are
    present in the system.

Author:

    Bob Watson (a-robw)

Revision History:

    24 Nov 1994    Written

--*/
#include <windows.h>
#include "c2config.h"
#include "resource.h"
#include "strings.h"

#define NUM_BUFS    4





DWORD
C2VerifyPrerequisites (
    IN  DWORD   dwFlags
)
/*

    IN  DWORD   dwFlags

        C2V_DEBUG = 0x8000000   forces all functions to return error

*/
{
    DWORD dwReturn;

    dwReturn = 0;

    dwReturn |= C2_VerifyNTFS(dwFlags);
    dwReturn |= C2_VerifyNoDos(dwFlags);
    dwReturn |= C2_VerifyNoNetwork(dwFlags);

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\c2funcs.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    C2DLL.H

Abstract:

    define the exported routines, datatypes and constants of the 
    C2FUNCS DLL

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94


--*/
#ifndef _C2FUNCS_H_
#define _C2FUNCS_H_


#ifdef _UNICODE

#typedef    NEWCPLINFO     WNEWCPLINFO 

#else

typedef struct _NEWCPLINFO {      // ncpli  
        DWORD dwSize;
        DWORD dwFlags;
        DWORD dwHelpContext;
        LONG  lData;
        HICON hIcon;
        WCHAR  szName[32];
        WCHAR  szInfo[64];
        WCHAR  szHelpFile[128];
} WNEWCPLINFO;

#endif

HINSTANCE
GetDllInstance (
    VOID
);

int
DisplayDllMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
);


#endif // _C2FUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\c2funres.h ===
#ifndef C2FUNRES_H
#define C2FUNRES_H

#define IDC_STATIC                  -1
#define IDC_LIST_BOX                101
#define IDC_TEXT                    102
#define IDC_OVERWRITE_AS_NEEDED     103
#define IDC_OVERWRITE_OLDER         104
#define IDC_DO_NOT_OVERWRITE        105
#define IDC_DAYS                    106
#define IDC_C2                      107
#define IDC_HALT_WHEN_LOG_FULL      109
#define IDC_LOGON_CAPTION           110
#define IDC_LOGON_MESSAGE           111
#define IDC_NO_LOGON_MESSAGE        112
#define IDC_LOGON_CAPTION_TITLE     114
#define IDC_LOGON_MESSAGE_TITLE     115
#define IDC_HIDE_LAST_USER          116
#define IDC_HIDE_SHUTDOWN_BUTTON    117
#define IDC_ALLOW_BLANK_PASSWORD    118
#define IDC_MIN_PASSWORD_LENGTH     119
#define IDC_PASSWORD_LENGTH_EDIT    120
#define IDC_DISABLE_GUEST_ACCOUNT   121

#ifdef IDC_HELP
#undef IDC_HELP
#endif
// martin - shuts-up compiler warning - IDC_HELP is def'ed in winuser.h

#define IDC_HELP                    122
#define IDC_ADMIN_ASSIGN_DRIVES     123
#define IDC_ALLOCATE_FLOPPY         124
#define IDC_ALLOCATE_CDROM          125
#define IDD_LIST_DLG                1000
#define IDD_SECLOG_WRAP             1100
#define IDD_AUDIT_FAIL              1200
#define IDD_LOGON_MESSAGE           1300
#define IDD_LAST_USER               1400
#define IDD_SHUTDOWN_BUTTON         1500
#define IDD_PASSWORD_LENGTH         1600
#define IDD_GUEST_ACCOUNT           1700
#define IDD_DRIVES_AND_PRINTERS     1800
#define IDD_ALLOC_DRIVES            1900
#define IDS_GENERIC_COMPLY          20001
#define IDS_GENERIC_NOT_COMPLY      20002
#define IDS_GENERIC_MB_MESSAGE      20003
#define IDS_GENERIC_CAPTION         20004
#define IDS_IS                      20005
#define IDS_IS_NOT                  20006
#define IDS_DLL_NAME                20007
#define IDS_UNABLE_READ             20008
#define IDS_NTFS                    20101
#define IDS_FS_LIST_TEXT_FORMAT     20102
#define IDS_ERR_LIST_TEXT_FORMAT    20103
#define IDS_NOT_C2_MESSAGE_FORMAT   20104
#define IDS_C2_MESSAGE_FORMAT       20105
#define IDS_SET_FS_MESSAGE          20106
#define IDS_FS_CAPTION              20107
#define IDS_C2_DISPLAY_MESSAGE      20108
#define IDS_FS_DLG_TEXT             20109
#define IDS_AUTOCHEK_CMD            20110
#define IDS_AUTOCONV_CMD            20111
#define IDS_FS_LAST_CHANCE          20112
#define IDS_SESSION_MANAGER_KEY     20113
#define IDS_BOOT_EXECUTE_VALUE      20114
#define IDS_FS_CONVERT_FORMAT       20115
#define IDS_NOT_C2_MESSAGE_FORMAT_1 20116
#define IDS_IO_SYS                  20201
#define IDS_MSDOS_SYS               20202
#define IDS_PCDOS_SYS               20203
#define IDS_BOOT_LOADER             20204
#define IDS_TIMEOUT                 20205
#define IDS_BOOT_INI_PATH           20206
#define IDS_DOS_ON_SYSTEM           20207
#define IDS_TIMEOUT_NOT_ZERO        20208
#define IDS_OS_OK                   20209
#define IDS_OS_DLG_TEXT             20210
#define IDS_OS_CAPTION              20211
#define IDS_USE_CONTROL_PANEL       20212
#define IDS_CURRENT_SYS_NOT_DEFAULT 20213
#define IDS_BOOT_LOADER_SECTION     20214
#define IDS_DEFAULT_KEY             20215
#define IDS_BOOT_INI_FILENAME       20216
#define IDS_OP_SYSTEMS_SECTION      20217
#define IDS_OS_DELETE_DOS_FILES     20218
#define IDS_OS_ZERO_BOOT_TIMEOUT    20219
#define IDS_OS_RISC_BOOT_TIMEOUT    20220
#define IDS_OS2SS_FILE              20301
#define IDS_OS2_ON_SYSTEM           20302
#define IDS_OS2_NOT_ON_SYSTEM       20303
#define IDS_DELETE_OS2              20304
#define IDS_OS2_CAPTION             20305
#define IDS_OS2_DISPLAY_MESSAGE     20306
#define IDS_NEW_OS2SS_FILE          20307
#define IDS_OS2_FILE                20308
#define IDS_NEW_OS2_FILE            20309
#define IDS_OS2_ERROR_MOVING        20310
#define IDS_OS2_CONFIRM             20311
#define IDS_POSIX_FILE              20401
#define IDS_POSIX_ON_SYSTEM         20402
#define IDS_POSIX_NOT_ON_SYSTEM     20403
#define IDS_DELETE_POSIX            20404
#define IDS_POSIX_CAPTION           20405
#define IDS_POSIX_DISPLAY_MESSAGE   20406
#define IDS_NEW_POSIX_FILE          20407
#define IDS_POSIX_ERROR_MOVING      20408
#define IDS_POSIX_CONFIRM           20409
#define IDS_SECLOG_WRAP_KEY         20501
#define IDS_SECLOG_WRAP_VALUE       20502
#define IDS_SECLOG_IS_C2            20503
#define IDS_SECLOG_WRAPS_AS_NEEDED  20504
#define IDS_SECLOG_OVERWRITE_OLD    20505
#define IDS_SECLOG_DAYS_ERROR       20506
#define IDS_SECLOG_CAPTION          20507
#define IDS_SECLOG_ERROR_NO_SET     20508
#define IDS_LSA_KEY                 20601
#define IDS_AUDIT_FAIL_VALUE        20602
#define IDS_AUDIT_FAIL_CRASH        20603
#define IDS_AUDIT_FAIL_NO_CRASH     20604
#define IDS_AUDIT_ERROR_NO_SET      20605
#define IDS_AUDIT_CAPTION           20606
#define IDS_AUDIT_ERROR_NO_GET      20607
#define IDS_WINLOGON_KEY            20701
#define IDS_LOGON_CAPTION_VALUE     20702
#define IDS_LOGON_MESSAGE_VALUE     20703
#define IDS_LOGON_MESSAGE_DEFINED   20704
#define IDS_LOGON_MESSAGE_NOT_DEF   20705
#define IDS_LOGON_MESSAGE_C2_BTN    20706
#define IDS_LOGON_MESSAGE_NO_TEXT   20707
#define IDS_LOGON_MESSAGE_CAPTION   20708
#define IDS_LOGON_MESSAGE_ERROR_SET 20709
#define IDS_LAST_USER_VALUE         20801
#define IDS_1                       20802
#define IDS_0                       20803
#define IDS_LAST_USER_HIDDEN        20804
#define IDS_LAST_USER_DISPLAYED     20805
#define IDS_LAST_USER_ERROR_NO_GET  20806
#define IDS_LAST_USER_CAPTION       20807
#define IDS_LAST_USER_ERROR_NO_SET  20808
#define IDS_SHUTDOWN_BTN_VALUE      20901
#define IDS_SHUTDOWN_BTN_HIDDEN     20902
#define IDS_SHUTDOWN_BTN_DISPLAYED  20903
#define IDS_SHUTDOWN_ERROR_NOT_SET  20904
#define IDS_SHUTDOWN_CAPTION        20905
#define IDS_PASSWORD_NOT_BLANK      21001
#define IDS_PASSWORD_CAN_BE_BLANK   21002
#define IDS_PASSWORD_INVALID_LEN    21003
#define IDS_PASSWORD_CAPTION        21004
#define IDS_PASSWORD_ERROR_NO_SET   21005
#define IDS_GUEST_ACCOUNT_ENABLED   21101
#define IDS_GUEST_ACCOUNT_DISABLED  21102
#define IDS_GUEST_ACCOUNT_NOT_FOUND 21103
#define IDS_GUEST_ACCOUNT_CAPTION   21104
#define IDS_SOFTWARE_KEY            21201
#define IDS_NETWORK_SERVICE_ID_KEY  21202
#define IDS_NETWORK_SERVICE_FOUND   21203    
#define IDS_NETWORK_SERVICE_NOT_FOUND 21204
#define IDS_NETWORK_SHOW_NCPA       21205
#define IDS_NETWORK_CAPTION         21206
#define IDS_NCPA_DLL                21207
#define IDS_NCPA_CPL_APPLET         21208
#define IDS_NCPA_NETWORK_APPLET     21209
#define IDS_NETWORK_ERROR_LOAD_DLL  21210
#define IDS_NETWORK_ERROR_FIND_CPL  21211
#define IDS_NETWORK_ERROR_INIT_CPL  21212
#define IDS_PROTECTION_MODE_VALUE   21301
#define IDS_ONLY_ADMINS_ASSIGN_DRIVE 21302
#define IDS_ANYONE_CAN_ASSIGN_DRIVE 21303
#define IDS_DRIVES_AND_PRINTERS_CAPTION 21304
#define IDS_DRIVES_AND_PRINTERS_NOT_SET 21305
#define IDS_ALLOCATE_FLOPPIES_VALUE 21401
#define IDS_ALLOCATE_CDROMS_VALUE   21402
#define IDS_ALLOCATE_NO_DRIVES_MSG  21403
#define IDS_ALLOCATE_FLOPPY_DRIVE_MSG 21404
#define IDS_ALLOCATE_CDROM_DRIVE_MSG 21405
#define IDS_ALLOCATE_BOTH_DRIVES_MSG 21406
#define IDD_OTHER_ITEMS             2000
#define IDS_MAKE_C2_COMPLIANT		21500
#define IDS_IS_C2_COMPLIANT			21501
#define IDS_IS_NOT_C2_COMPLIANT		21502

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\lastuser.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lastuser.C

Abstract:

    functions used to set the last username display function
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_LASTUSER_NOCHANGE    0
#define AC_LASTUSER_UPDATE      1

#define SECURE    C2DLL_SECURE

static
BOOL
SetLastUserDisplay (
    DWORD   dwNewValue
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;
    UINT    nNewData;
    LPCTSTR szNewString;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so set value
        nNewData = (dwNewValue ? IDS_1 : IDS_0);
        szNewString = GetStringResource (GetDllInstance(), nNewData);
        lStatus = RegSetValueEx (
            hKeyWinlogon,
            GetStringResource (GetDllInstance(), IDS_LAST_USER_VALUE),
            0L,
            REG_SZ,
            (CONST LPBYTE)szNewString,
            (lstrlen (szNewString) + 1) * sizeof(TCHAR));

        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeyWinlogon);
        SetLastError (lStatus);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
BOOL
GetLastUserDisplay (
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    BOOL    bReturn = FALSE;
    TCHAR   szValue[MAX_PATH];
    DWORD   dwValueSize = MAX_PATH * sizeof(TCHAR);

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_READ,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check value
        lStatus = RegQueryValueEx (
            hKeyWinlogon,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_LAST_USER_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)szValue,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType == REG_SZ) {
                // check value. The "C2" value is "1", any
                // other value is NOT C2
                if (lstrcmp(szValue, GetStringResource(GetDllInstance(), IDS_1)) == 0) {
                    bReturn = TRUE;
                } else {
                    bReturn = FALSE;
                }
                SetLastError (ERROR_SUCCESS);
            } else {
                // wrong data type returned
                bReturn = FALSE;
                SetLastError (ERROR_CANTREAD);
            }
        } else {
            // no value present
            bReturn = FALSE;
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

BOOL CALLBACK
C2LastUserDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Last User Display dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;
            // get Audit failure settings


            CheckDlgButton (hDlg, IDC_HIDE_LAST_USER,
                (GetLastUserDisplay() ? CHECKED : UNCHECKED));

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        if (IsDlgButtonChecked (hDlg, IDC_HIDE_LAST_USER) == CHECKED) {
                            *lpdwNewValue = TRUE;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else {
                            *lpdwNewValue = FALSE;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckDlgButton (hDlg, IDC_HIDE_LAST_USER, CHECKED);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryLastUser (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting = 0;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        if (GetLastUserDisplay()) {
            pC2Data->lC2Compliance = SECURE;
            nMsgString = IDS_LAST_USER_HIDDEN;
        } else {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_LAST_USER_DISPLAYED;
        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgString));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetLastUser (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action valie = the new value of the wrap setting
        if (pC2Data->lActionCode != AC_LASTUSER_NOCHANGE) {
            nMsgString = 0;
            if (pC2Data->lActionCode == AC_LASTUSER_UPDATE) {
                if (pC2Data->lActionValue) {
                    if (SetLastUserDisplay (TRUE)) {
                        pC2Data->lC2Compliance = SECURE;
                        nMsgString = IDS_LAST_USER_HIDDEN;
                    } else {
                        DisplayDllMessageBox (
                            pC2Data->hWnd,
                            IDS_LAST_USER_ERROR_NO_SET,
                            IDS_LAST_USER_CAPTION,
                            MBOK_EXCLAIM);
                    }
                } else {
                    if (SetLastUserDisplay (FALSE)) {
                        pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                        nMsgString = IDS_LAST_USER_DISPLAYED;
                    } else {
                        DisplayDllMessageBox (
                            pC2Data->hWnd,
                            IDS_LAST_USER_ERROR_NO_SET,
                            IDS_LAST_USER_CAPTION,
                            MBOK_EXCLAIM);
                    }
                }
            }
            if (nMsgString != 0) {
                // update status string if set was successful
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), nMsgString));
            }
        }
        // update action values
        pC2Data->lActionCode = 0;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayLastUser (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    DWORD       dwNewValue;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_LAST_USER),
            pC2Data->hWnd,
            C2LastUserDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            pC2Data->lActionValue = dwNewValue;
            pC2Data->lActionCode = AC_LASTUSER_UPDATE;
        } else {
            // no action
            pC2Data->lActionCode = AC_LASTUSER_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\drvsnprt.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    drvsnprt.C

Abstract:

    functions used to set the Drive Letter and Printer Assignment
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    3 Jul 95

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_DRIVES_AND_PRINTER_NOCHANGE       0
#define AC_DRIVES_AND_PRINTER_SET_ADMIN      1
#define AC_DRIVES_AND_PRINTER_SET_ANYONE     2

#define SECURE             C2DLL_SECURE


static
BOOL
SetDrivesAndPrinterSetting (
    DWORD   dwNewValue
)
{
    HKEY    hKeySM = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_SESSION_MANAGER_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeySM);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so set value
        lStatus = RegSetValueEx (
            hKeySM,
            GetStringResource (GetDllInstance(), IDS_PROTECTION_MODE_VALUE),
            0L,
            REG_DWORD,
            (CONST LPBYTE)&dwNewValue,
            sizeof(DWORD));

        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeySM);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
BOOL
GetDrivesAndPrinterSetting (
)
{
    HKEY    hKeySM = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwValue = 0;
    DWORD   dwValueSize = sizeof(DWORD);
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_SESSION_MANAGER_KEY),
        0L,
        KEY_READ,
        &hKeySM);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check value
        lStatus = RegQueryValueEx (
            hKeySM,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_PROTECTION_MODE_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType == REG_DWORD) {
                // check value. The "C2" value is 1, any
                // other value is NOT C2
                if (dwValue == 1) {
                    bReturn = TRUE;
                } else {
                    bReturn = FALSE;
                }
                SetLastError (ERROR_SUCCESS);
            } else {
                // wrong data type returned
                bReturn = FALSE;
                SetLastError (ERROR_CANTREAD);
            }
        } else {
            // no value present
            bReturn = FALSE;
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeySM);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

BOOL CALLBACK
C2DrivesAndPrinterDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Drives and Printer assignment dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;
            // get Audit failure settings

            CheckDlgButton (hDlg, IDC_ADMIN_ASSIGN_DRIVES,
                (GetDrivesAndPrinterSetting() ? CHECKED : UNCHECKED));

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        if (IsDlgButtonChecked (hDlg, IDC_ADMIN_ASSIGN_DRIVES) == CHECKED) {
                            *lpdwNewValue = TRUE;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else {
                            *lpdwNewValue = FALSE;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckDlgButton (hDlg, IDC_ADMIN_ASSIGN_DRIVES, CHECKED);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryAssignDrivesAndPrinter (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if only the Admin can assign drives and printer
        on the system. For C2 compliance,

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting = 0;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        if (GetDrivesAndPrinterSetting()) {
            pC2Data->lC2Compliance = SECURE;
            nMsgString = IDS_ONLY_ADMINS_ASSIGN_DRIVE;
        } else {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_ANYONE_CAN_ASSIGN_DRIVE;
        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgString));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetAssignDrivesAndPrinter (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action valie = the new value of the wrap setting
        if (pC2Data->lActionCode != AC_DRIVES_AND_PRINTER_NOCHANGE) {
            nMsgString = 0;
            if (pC2Data->lActionCode == AC_DRIVES_AND_PRINTER_SET_ADMIN) {
                if (SetDrivesAndPrinterSetting (1)) {
                    pC2Data->lC2Compliance = SECURE;
                    nMsgString = IDS_ONLY_ADMINS_ASSIGN_DRIVE;
                } else {
                    DisplayDllMessageBox (
                        pC2Data->hWnd,
                        IDS_AUDIT_ERROR_NO_SET,
                        IDS_AUDIT_CAPTION,
                        MBOK_EXCLAIM);
                }
            } else if (pC2Data->lActionCode == AC_DRIVES_AND_PRINTER_SET_ANYONE) {
                if (SetDrivesAndPrinterSetting (0)) {
                    pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                    nMsgString = IDS_ANYONE_CAN_ASSIGN_DRIVE;
                } else {
                    DisplayDllMessageBox (
                        pC2Data->hWnd,
                        IDS_AUDIT_ERROR_NO_SET,
                        IDS_AUDIT_CAPTION,
                        MBOK_EXCLAIM);
                }
            }
            if (nMsgString != 0) {
                // update status string if set was successful
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), nMsgString));
            }
        }
        // update action values
        pC2Data->lActionCode = 0;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayAssignDrivesAndPrinter (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    DWORD       dwNewValue;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_DRIVES_AND_PRINTERS),
            pC2Data->hWnd,
            C2DrivesAndPrinterDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            pC2Data->lActionValue = 0;
            if (dwNewValue) {
                pC2Data->lActionCode = AC_DRIVES_AND_PRINTER_SET_ADMIN;
            } else {
                pC2Data->lActionCode = AC_DRIVES_AND_PRINTER_SET_ANYONE;
            }
        } else {
            // no action
            pC2Data->lActionCode = AC_DRIVES_AND_PRINTER_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\generic.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Generic.c

Abstract:

    generic function to used as a filler for unimplemented functions or
    a template for new functions
   
Revision History:

    23 Dec 94 Created

--*/
#include <windows.h>    // standard Windows includes
#include <tchar.h>      // for UNICODE/ANSI compatiblity
#include <stdio.h>      // text formatting & display functions
#include <c2dll.h>      // DLL interface definitions

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_GENERIC_MAKE_C2     1
#define AC_GENERIC_MAKE_NOTC2  2

// use this line for security items not required by the C2 doc
#define SECURE    C2DLL_SECURE      
// use this line for security items required by the C2 doc
// #define SECURE    C2DLL_C2

LONG
C2QueryGeneric (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

    INPUTS:
        lActionCode     = 0
        lActionValue    = 0
        hWnd            = window handle to main app window
        lC2Compliance   = C2DLL_NOT_SECURE;
        szItemName      = ItemName as read from C2CONFIG.INF file
        szStatusName    = Empty String (all null chars) on first
                            call, previous status on all subsequent
                            calls
    OUTPUTS:
        lActionCode     =  (not used)
        lActionValue    =  (not used)
        hWnd            =  (not changed)
        lC2Compliance   = Current compliance value
        szItemName      =  (not changed)
        szStatusName    = string describing current status of this
                            item
    
ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // return message based on flag for now
        if (pC2Data->lC2Compliance == SECURE) {
            lstrcpy (pC2Data->szStatusName, TEXT("C2 Compliant"));
        } else {
            lstrcpy (pC2Data->szStatusName, TEXT("NOT C2 Compliant"));
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetGeneric (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

    INPUTS:
        lActionCode     = code describing action to take in order to
                            perform task selected by user. 
                            0 == no change or no action
        lActionValue    = value to be used, if necessary, if the 
                            lActionCode is not 0
        hWnd            =  (not changed)
        lC2Compliance   =  (not changed)
        szItemName      =  (not changed)
        szStatusName    =  (not changed)

    OUTPUTS:
        lActionCode     = set to 0
        lActionValue    = set to 0
        hWnd            =  (not changed)
        lC2Compliance   = set to the current state (as a result of
                            the change)
        szItemName      =  (not changed)
        szStatusName    = set to the current state (as a result of
                            the change)

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        // detect action to take based on action code value
        pC2Data = (PC2DLL_DATA)lParam;
        switch (pC2Data->lActionCode ) {
            case AC_GENERIC_MAKE_C2:
                // update data fields to show new state
                pC2Data->lC2Compliance = SECURE;
                lstrcpy (pC2Data->szStatusName, TEXT("C2 Compliant"));
                break;

            case AC_GENERIC_MAKE_NOTC2:
                // update data fields to show new state
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                lstrcpy (pC2Data->szStatusName, TEXT("NOT C2 Compliant"));
                break;

            default:
                // no change;
                break;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    
    return ERROR_SUCCESS;
}

LONG
C2DisplayGeneric (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.
      
Arguments:

    Pointer to the Dll data block passed as an LPARAM.

    INPUTS:
        lActionCode     = 0
        lActionValue    = 0
        hWnd            = the window handle of the main app. window
        lC2Compliance   = the current compliance value as returned by
                            the last GetStatusFunction call.
        szItemName      = the name string for this item as read from
                            the C2CONFIG.INF file
        szStatusName    = the string describing the current status of
                            this item as returned by the last call to
                            the GetStatusFunction.

    OUTPUTS:
        lActionCode     = code describing action to take in order to
                            perform task selected by user. 
                            0 == no change or no action
        lActionValue    = value to be used, if necessary, if the 
                            lActionCode is not 0
        hWnd            =  (not changed)
        lC2Compliance   =  (not changed)
        szItemName      =  (not changed)
        szStatusName    =  (not changed)

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    TCHAR       szMessage[MAX_PATH];
    INT         nMbResult;
    INT         nMbOptions;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    // configure UI for display
    _stprintf (szMessage, GetStringResource (GetDllInstance(), IDS_MAKE_C2_COMPLIANT), 
        pC2Data->szItemName,
        pC2Data->szStatusName,
        (pC2Data->lC2Compliance == SECURE ? GetStringResource (GetDllInstance(), IDS_IS_C2_COMPLIANT) : GetStringResource (GetDllInstance(), IDS_IS_NOT_C2_COMPLIANT)));

    // configure MessageBox button configuration and defaults
    nMbOptions = MB_ICONQUESTION | MB_YESNO | MB_TASKMODAL;
    if (pC2Data->lC2Compliance == SECURE ) nMbOptions |= MB_DEFBUTTON2;

    // display UI
    nMbResult = MessageBox (
        pC2Data->hWnd,
        szMessage,
        "C2 Configuration -- Generic",
        nMbOptions);

    // set action code for subsequent processing here.

    if (nMbResult == IDYES){
        pC2Data->lActionCode = AC_GENERIC_MAKE_C2;
    } else if (nMbResult == IDNO) {
        pC2Data->lActionCode = AC_GENERIC_MAKE_NOTC2;
    } else {
        pC2Data->lActionCode = 0;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    the Stadard C2 function dll

Author:

    Bob Watson (a-robw) Dec-94      

Revision History:

--*/

#include <windows.h>
#include <c2inc.h>
#include <c2dll.h>
#include "c2funcs.h"
#include "c2funres.h"

static HANDLE ThisDLLHandle = NULL;

int
DisplayDllMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
)
/*++

Routine Description:

    Displays a message box displaying text from the DLL's resource file, as
        opposed to literal strings.

Arguments:

    IN  HWND    hWnd            window handle to parent window
    IN  UINT    nMessageId      String Resource ID of message text to display
    IN  UINT    nTitleId        String Resource ID of title text to display
    IN  UINT    nStyle          MB style bits (see MessageBox function)

Return Value:

    ID of button pressed to exit message box

--*/
{
    LPTSTR      szMessageText = NULL;
    LPTSTR      szTitleText = NULL;
    HINSTANCE   hInst;
    int         nReturn;

    hInst = GetDllInstance();

    szMessageText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);
    szTitleText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);

    if ((szMessageText != NULL) &&
        (szTitleText != NULL)) {
        LoadString (hInst,
            ((nTitleId != 0) ? nTitleId : IDS_DLL_NAME),
            szTitleText,
            SMALL_BUFFER_SIZE -1);

        LoadString (hInst,
            nMessageId,
            szMessageText,
            SMALL_BUFFER_SIZE - 1);

        nReturn = MessageBox (
            hWnd,
            szMessageText,
            szTitleText,
            nStyle);
    } else {
        nReturn = IDCANCEL;
    }

    GLOBAL_FREE_IF_ALLOC (szMessageText);
    GLOBAL_FREE_IF_ALLOC (szTitleText);

    return nReturn;
}

HINSTANCE   
GetDllInstance (
)
{
    return (HINSTANCE)ThisDLLHandle;
}

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {
        case DLL_PROCESS_ATTACH:

            ThisDLLHandle = DLLHandle;
            break;

        case DLL_PROCESS_DETACH:
            break ;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

            break;
    }

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\guestact.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    guestact.c

Abstract:

    functions to enable/disable the guest account

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// define action codes here. They are only meaningful in the
// context of this module.
#define AC_GUEST_ACCT_NOCHANGE  0
#define AC_GUEST_ACCT_UPDATE    1

// Account states
#define GUEST_ACCT_NOT_FOUND  0
#define GUEST_ACCT_ENABLED    1
#define GUEST_ACCT_DISABLED   2

static  WCHAR   szGuest[] = L"Guest";
#define GUEST_STRLEN        5

#define SECURE    C2DLL_C2

static
LONG
IsGuestAccountEnabled(
)
{
    SAM_HANDLE  hsamObject;
    SAM_HANDLE  hsamDomain;
    PSID        psidDomain;

    SAM_ENUMERATE_HANDLE hSamEnum;
    PSAM_RID_ENUMERATION pRidEnum;

    PVOID   pvEnumBuffer;
    ULONG   ulEnumCount;
    ULONG   i;

    LONG    lReturn = GUEST_ACCT_NOT_FOUND;
    int     nCompare;

    ULONG   lTotalAvailable, lTotalReturned, lReturnedEntryCount;
    NTSTATUS    ntstat;
    LPVOID      pBuffer;
    PDOMAIN_DISPLAY_USER pdduData;
    PDOMAIN_DISPLAY_USER pdduThisUser;

    SET_WAIT_CURSOR;

    // connect to SAM on this machine
    ntstat = SamConnect((PUNICODE_STRING)NULL, &hsamObject,
       SAM_SERVER_ALL_ACCESS, (POBJECT_ATTRIBUTES)NULL);

    if (ntstat == STATUS_SUCCESS) {
        // Ask SAM for the domains on this server.

        hSamEnum = 0;
        ntstat = SamEnumerateDomainsInSamServer(
            hsamObject,
            &hSamEnum,
            &pvEnumBuffer,
            1024,
            &ulEnumCount);

        if ((ntstat == STATUS_SUCCESS) || (ntstat == STATUS_MORE_ENTRIES)) {
            // look up only the first entry
            pRidEnum = (PSAM_RID_ENUMERATION) pvEnumBuffer;

            // get SID of domain
            ntstat = SamLookupDomainInSamServer (
                hsamObject,
                &pRidEnum->Name,
                &psidDomain);

            if (ntstat == STATUS_SUCCESS) {
                // open handle to this domain
                ntstat = SamOpenDomain (
                    hsamObject,
                    DOMAIN_EXECUTE,
                    psidDomain,
                    &hsamDomain);

                if (ntstat == STATUS_SUCCESS) {
                    // get password policy for this domain
                    pBuffer = NULL;
                    ntstat = SamQueryDisplayInformation (
                        hsamDomain,
                        DomainDisplayUser,
                        0, 100, 32768,
                        &lTotalAvailable,
                        &lTotalReturned,
                        &lReturnedEntryCount,
                        (PVOID *)&pBuffer);

                    if (ntstat == STATUS_SUCCESS) {
                        pdduData = (PDOMAIN_DISPLAY_USER)pBuffer;
                        for (i=0; i<lReturnedEntryCount; i++) {
                            pdduThisUser = &pdduData[i];
                            nCompare = CompareStringW (
                                GetUserDefaultLCID(),
                                (NORM_IGNORECASE | SORT_STRINGSORT),
                                szGuest,
                                GUEST_STRLEN,
                                pdduThisUser->LogonName.Buffer,
                                (pdduThisUser->LogonName.Length / sizeof(WCHAR)));

                            if (nCompare == 2) {
                                // guest account found
                                if ((pdduThisUser->AccountControl & USER_ACCOUNT_DISABLED) ==
                                    USER_ACCOUNT_DISABLED) {
                                    lReturn = GUEST_ACCT_DISABLED;
                                } else {
                                    lReturn = GUEST_ACCT_ENABLED;
                                }
                                break;  // bail out since the guest acct was found
                            }
                        }
                        ntstat = SamFreeMemory (pBuffer);
                    }
                    // close handle
                    SamCloseHandle (hsamDomain);
                }
            }
            SamFreeMemory(pvEnumBuffer);
        }
        SamCloseHandle (hsamObject);
    }
    SetLastError (RtlNtStatusToDosError(ntstat));
    SET_ARROW_CURSOR;
    return lReturn;
}

static
BOOL
EnableGuestAccount (
    BOOL    bEnable    // TRUE = enable, FALSE = disable
)
{
    SAM_HANDLE  hsamObject;
    SAM_HANDLE  hsamDomain;
    SAM_HANDLE  hsamUser;
    PSID        psidDomain;

    SAM_ENUMERATE_HANDLE hSamEnum;
    PSAM_RID_ENUMERATION pRidEnum;

    PVOID   pvEnumBuffer;
    ULONG   ulEnumCount;
    ULONG   i;

    BOOL    bReturn = FALSE;
    BOOL    bAccount;
    int     nCompare;

    ULONG   lTotalAvailable, lTotalReturned, lReturnedEntryCount;
    NTSTATUS    ntstat;
    LPVOID      pBuffer;
    PDOMAIN_DISPLAY_USER pdduData;
    PDOMAIN_DISPLAY_USER pdduThisUser;
    PUSER_CONTROL_INFORMATION   puciData;

    SET_WAIT_CURSOR;

    // connect to SAM on this machine
    ntstat = SamConnect((PUNICODE_STRING)NULL, &hsamObject,
       SAM_SERVER_ALL_ACCESS, (POBJECT_ATTRIBUTES)NULL);

    if (ntstat == STATUS_SUCCESS) {
        // Ask SAM for the domains on this server.

        hSamEnum = 0;
        ntstat = SamEnumerateDomainsInSamServer(
            hsamObject,
            &hSamEnum,
            &pvEnumBuffer,
            1024,
            &ulEnumCount);

        if ((ntstat == STATUS_SUCCESS) || (ntstat == STATUS_MORE_ENTRIES)) {
            // look up only the first entry
            pRidEnum = (PSAM_RID_ENUMERATION) pvEnumBuffer;

            // get SID of domain
            ntstat = SamLookupDomainInSamServer (
                hsamObject,
                &pRidEnum->Name,
                &psidDomain);

            if (ntstat == STATUS_SUCCESS) {
                // open handle to this domain
                ntstat = SamOpenDomain (
                    hsamObject,
                    DOMAIN_EXECUTE,
                    psidDomain,
                    &hsamDomain);

                if (ntstat == STATUS_SUCCESS) {
                    // get password policy for this domain
                    pBuffer = NULL;
                    ntstat = SamQueryDisplayInformation (
                        hsamDomain,
                        DomainDisplayUser,
                        0, 100, 32768,
                        &lTotalAvailable,
                        &lTotalReturned,
                        &lReturnedEntryCount,
                        (PVOID *)&pBuffer);

                    if (ntstat == STATUS_SUCCESS) {
                        pdduData = (PDOMAIN_DISPLAY_USER)pBuffer;
                        for (i=0; i<lReturnedEntryCount; i++) {
                            pdduThisUser = &pdduData[i];
                            nCompare = CompareStringW (
                                GetUserDefaultLCID(),
                                (NORM_IGNORECASE | SORT_STRINGSORT),
                                szGuest,
                                GUEST_STRLEN,
                                pdduThisUser->LogonName.Buffer,
                                (pdduThisUser->LogonName.Length / sizeof(WCHAR)));

                            if (nCompare == 2) {
                                // guest account found
                                bAccount = !((pdduThisUser->AccountControl & USER_ACCOUNT_DISABLED) ==
                                    USER_ACCOUNT_DISABLED);
                                if (bAccount == bEnable) {
                                    // account is already in the desired 
                                    // state so bail out here
                                    bReturn = TRUE;                            
                                    break;
                                } else {
                                    // account needs to be updated so open 
                                    // the user data
                                    ntstat = SamOpenUser (
                                        hsamDomain,
                                        USER_ALL_ACCESS,
                                        pdduThisUser->Rid,
                                        &hsamUser);
                                    if (ntstat == STATUS_SUCCESS) {
                                        ntstat = SamQueryInformationUser (
                                            hsamUser,
                                            UserControlInformation,
                                            (PVOID *)&puciData);
                                        if (ntstat == STATUS_SUCCESS) {
                                            // enable/disable account
                                            if (bEnable) {
                                                // clear disable bit
                                                puciData->UserAccountControl &=
                                                    ~USER_ACCOUNT_DISABLED;
                                            } else {
                                                // set disable bit
                                                puciData->UserAccountControl |=
                                                    USER_ACCOUNT_DISABLED;
                                            }
                                            // update value
                                            ntstat = SamSetInformationUser (
                                                hsamUser,
                                                UserControlInformation,
                                                (PVOID)puciData);
                                            if (ntstat == STATUS_SUCCESS) {
                                                bReturn = TRUE;
                                            }
                                            SamFreeMemory (puciData);
                                        }
                                        SamCloseHandle (hsamUser);
                                    }
                                }
                                break;  // bail out since the guest acct was found
                            }
                        }
                        ntstat = SamFreeMemory (pBuffer);
                    }
                    // close handle
                    SamCloseHandle (hsamDomain);
                }
            }
            SamFreeMemory(pvEnumBuffer);
        }
        SamCloseHandle (hsamObject);
    }
    SetLastError (RtlNtStatusToDosError(ntstat));

    SET_ARROW_CURSOR;

    return bReturn;
}

BOOL CALLBACK
C2GuestAccountDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Guest Account enable/disable

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  PULONG   plNewState;   // save address of caller's data

    switch (message) {
        case WM_INITDIALOG:
            // save pointer
            plNewState = (PULONG)lParam;

            CheckDlgButton (hDlg, IDC_DISABLE_GUEST_ACCOUNT,
                (*plNewState == GUEST_ACCT_DISABLED ? CHECKED : UNCHECKED));

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        if (IsDlgButtonChecked(hDlg, IDC_DISABLE_GUEST_ACCOUNT) == CHECKED) {
                            *plNewState = GUEST_ACCT_DISABLED;
                        } else {
                            *plNewState = GUEST_ACCT_ENABLED;
                        }
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckDlgButton (hDlg, IDC_DISABLE_GUEST_ACCOUNT,
                            CHECKED);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryGuestAccount (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    LONG        lGuestAccount;
    UINT        nMsgId;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        lGuestAccount = IsGuestAccountEnabled();
        switch (lGuestAccount) {
            case GUEST_ACCT_ENABLED:
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                nMsgId = IDS_GUEST_ACCOUNT_ENABLED;
                break;

            case GUEST_ACCT_DISABLED:
                pC2Data->lC2Compliance = SECURE;
                nMsgId = IDS_GUEST_ACCOUNT_DISABLED;
                break;

            case GUEST_ACCT_NOT_FOUND:
            default:
                pC2Data->lC2Compliance = SECURE;
                nMsgId = IDS_GUEST_ACCOUNT_NOT_FOUND;
                break;

        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgId));
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2SetGuestAccount (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    BOOL        bGuestAccount = 0;
    UINT        nMsgId;    

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (pC2Data->lActionCode == AC_GUEST_ACCT_UPDATE) {
            if (EnableGuestAccount(
                (pC2Data->lActionValue == GUEST_ACCT_ENABLED ? TRUE : FALSE))) {
                switch (pC2Data->lActionValue) {
                    case GUEST_ACCT_ENABLED:
                        pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                        nMsgId = IDS_GUEST_ACCOUNT_ENABLED;
                        break;

                    case GUEST_ACCT_DISABLED:
                        pC2Data->lC2Compliance = SECURE;
                        nMsgId = IDS_GUEST_ACCOUNT_DISABLED;
                        break;

                    case GUEST_ACCT_NOT_FOUND:
                    default:
                        pC2Data->lC2Compliance = SECURE;
                        nMsgId = IDS_GUEST_ACCOUNT_NOT_FOUND;
                        break;

                }
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), nMsgId));
            }

            pC2Data->lActionCode = 0;
            pC2Data->lActionValue = 0;
        }
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2DisplayGuestAccount (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    LONG        lNewValue = 0;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        lNewValue = IsGuestAccountEnabled();
        if (lNewValue != GUEST_ACCT_NOT_FOUND) {
            // the guest account was found on the system so
            // show enable/disable dialog box
            if (DialogBoxParam (
                GetDllInstance(),
                MAKEINTRESOURCE (IDD_GUEST_ACCOUNT),
                pC2Data->hWnd,
                C2GuestAccountDlgProc,
                (LPARAM)&lNewValue) == IDOK) {
                pC2Data->lActionValue = lNewValue;
                pC2Data->lActionCode = AC_GUEST_ACCT_UPDATE;
            } else {
                // no action
                pC2Data->lActionCode = AC_GUEST_ACCT_NOCHANGE;
            }
        } else {
            // no guest account found on the system so show message box
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_GUEST_ACCOUNT_NOT_FOUND,
                IDS_GUEST_ACCOUNT_CAPTION,
                MBOK_INFO);
            pC2Data->lActionCode = AC_GUEST_ACCT_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\fschecks.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    fschecks.c

Abstract:

    function to check file systems installed on local disks
    for C2FUNCS.DLL

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

#define  AC_NO_CHANGE   0
#define  AC_UPDATE_FS   1

#define  SECURE      C2DLL_C2

static
BOOL
IsDriveSetToConvert (
    IN  TCHAR   cDrive
)
/*++

Routine Description:

    checks to see if the specified drive is set to be converted
        to NTFS already by checking the session manager key for
        an existing entry.

--*/
{
    LONG    lStatus;
    DWORD   dwDataType;
    DWORD   dwBufferBytes;
    HKEY    hkeySessionManager;
    TCHAR   mszBootExecuteString[SMALL_BUFFER_SIZE];
    BOOL    bReturn;
    TCHAR   szThisDriveCommand[MAX_PATH];
    LPTSTR  szThisCommand;
    TCHAR   szDriveLetter[4];
    
    lStatus = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_SESSION_MANAGER_KEY),
        0L,
        KEY_READ,
        &hkeySessionManager);

    if (lStatus == ERROR_SUCCESS) {
        // registry key opened successfully
        dwBufferBytes = sizeof(mszBootExecuteString);
        memset (mszBootExecuteString, 0, dwBufferBytes);
        lStatus = RegQueryValueEx (
            hkeySessionManager,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_BOOT_EXECUTE_VALUE),
            NULL,
            &dwDataType,
            (LPBYTE)mszBootExecuteString,
            &dwBufferBytes);
        if (lStatus == ERROR_SUCCESS) {
            // load list box with volumes that are not using NTFS
            // initialize the root dir string
            szDriveLetter[0] = cDrive;
            szDriveLetter[1] = 0;
            _stprintf (szThisDriveCommand,
                GetStringResource (GetDllInstance(), IDS_AUTOCONV_CMD),
                szDriveLetter);
            bReturn = FALSE;        // assume false until found
            for (szThisCommand = mszBootExecuteString;
                *szThisCommand != 0;
                szThisCommand += lstrlen(szThisCommand) + 1) {
                if (lstrcmpi (szThisCommand, szThisDriveCommand) == 0) {
                    bReturn = TRUE;
                    break; //out of for loop
                }
            }
        } else {
            // unable to read key so assume the drive is not specified
            bReturn = FALSE;
        }
        RegCloseKey (hkeySessionManager);
    }
    return bReturn;
}

BOOL CALLBACK
C2FileSysDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for FileSystem List Box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD     lpdwParam;

    TCHAR       szRootDir[4];
    TCHAR       szVolumeName[MAX_PATH];
    TCHAR       szFileSystemName[MAX_PATH];

    DWORD       dwVolumeSerialNumber;
    DWORD       dwMaxComponentLength;
    DWORD       dwFileSystemFlags;
    TCHAR       szItemText[MAX_PATH];
    ULONG       ulDriveBitMask;
    ULONG       ulDriveIndex;
    LONG        lIndex;
    LONG        lListBoxItems;
    BOOL        bConvert;

    switch (message) {
        case WM_INITDIALOG:
            lpdwParam = (LPDWORD)lParam;

            // set the dialog box caption and static text
            SetDlgItemText (hDlg, IDC_TEXT,
                GetStringResource (GetDllInstance(), IDS_FS_DLG_TEXT));
            SetWindowText (hDlg,
                GetStringResource (GetDllInstance(), IDS_FS_CAPTION));

            // load list box with volumes that are not using NTFS
            // initialize the root dir string
            szRootDir[0] = TEXT(' ');
            szRootDir[1] = TEXT(':');
            szRootDir[2] = TEXT('\\');
            szRootDir[3] = 0;

            for (szRootDir[0] = TEXT('A');szRootDir[0] <= TEXT('Z'); szRootDir[0]++) {
                // check each drive in the alphabet
                if (GetDriveType(szRootDir) == DRIVE_FIXED) {
                    // only check fixed disk volumes
                    if (GetVolumeInformation(szRootDir,
                        szVolumeName, MAX_PATH,
                        &dwVolumeSerialNumber,
                        &dwMaxComponentLength,
                        &dwFileSystemFlags,
                        szFileSystemName, MAX_PATH)) {
                        // volume information returned so see if it's NOT NTFS..

                        if (lstrcmpi(szFileSystemName,
                            GetStringResource (GetDllInstance(), IDS_NTFS)) != 0) {
                            // it's not currently NTFS, but is it set to be converted?
                            bConvert = IsDriveSetToConvert (szRootDir[0]);
                            _stprintf (szItemText,
                                GetStringResource (GetDllInstance(),
                                    (bConvert ? IDS_FS_CONVERT_FORMAT : IDS_FS_LIST_TEXT_FORMAT)),
                                szRootDir,
                                (bConvert ? GetStringResource (GetDllInstance(), IDS_NTFS) : szFileSystemName));
                            lIndex = SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                                LB_INSERTSTRING, (WPARAM)-1, (LPARAM)szItemText);
                            if (lIndex != LB_ERR) {
                                // drive added to list so store the bit
                                // that identifies the drive
                                ulDriveIndex = (LONG)(szRootDir[0] - TEXT('A'));
                                ulDriveBitMask = 1 << ulDriveIndex;
                                SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                                    LB_SETITEMDATA, (WPARAM)lIndex, (LPARAM)ulDriveBitMask);
                                // if this drive is set to be converted then select it
                                SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                                    LB_SETSEL, (WPARAM)bConvert, (LPARAM)lIndex);
                            }
                        }
                    } else {
                        _stprintf (szItemText,
                            GetStringResource (GetDllInstance(), IDS_ERR_LIST_TEXT_FORMAT),
                            szRootDir);
                        SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_ADDSTRING,
                            0, (LPARAM)szItemText);
                    }
                } else {
                    // not a fixed drive so ignore
                }
            } // end FOR each drive in the alphabet

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        // build a the bitmask of selected drives
                        ulDriveBitMask = 0L; // clear bitmap field

                        lListBoxItems = SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                            LB_GETCOUNT, 0, 0);

                        for (lIndex = 0; lIndex < lListBoxItems; lIndex++) {
                            if (SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                                LB_GETSEL, (WPARAM)lIndex, 0) > 0) {
                                // then this disk is selected so get it's id
                                // and add it to the bit map
                                ulDriveIndex = SendDlgItemMessage (hDlg,
                                    IDC_LIST_BOX, LB_GETITEMDATA,
                                    (WPARAM)lIndex, 0);
                                ulDriveBitMask |= ulDriveIndex;
                            }
                        }
                        *lpdwParam = (DWORD)ulDriveBitMask;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        *lpdwParam = 0L;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // select all entries in the list box
                        SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                            LB_SETSEL, TRUE, (LPARAM)-1);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryFileSystems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Checks file systems installed on all local volumes.
        For C2 compliance, All volumes must use the NTFS file system.

Arguments:

    pointer to C2DLL data block passed as LPARAM

ReturnValue:

    ERROR_SUCCESS if function completes successfully
    WIN32 error if not

    This function sets the C2Compliant flag as appropriate and
    sets the text of the status string for this item.

--*/
{
    PC2DLL_DATA pC2Data;
    LONG        lFatVolumeCount;
    TCHAR       szRootDir[4];
    TCHAR       szVolumeName[MAX_PATH];
    TCHAR       szFileSystemName[MAX_PATH];
    DWORD       dwVolumeSerialNumber;
    DWORD       dwMaxComponentLength;
    DWORD       dwFileSystemFlags;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;

        SET_WAIT_CURSOR;

        // initialize the FAT file system volume counter
        lFatVolumeCount = 0;

        // initialize the root dir string
        szRootDir[0] = TEXT(' ');
        szRootDir[1] = TEXT(':');
        szRootDir[2] = TEXT('\\');
        szRootDir[3] = 0;

        for (szRootDir[0] = TEXT('A');szRootDir[0] <= TEXT('Z'); szRootDir[0]++) {
            // check each drive in the alphabet
            if (GetDriveType(szRootDir) == DRIVE_FIXED) {
                // only check fixed disk volumes
                if (GetVolumeInformation(szRootDir,
                    szVolumeName, MAX_PATH,
                    &dwVolumeSerialNumber,
                    &dwMaxComponentLength,
                    &dwFileSystemFlags,
                    szFileSystemName, MAX_PATH)) {
                    // volume information returned so see if it's NOT NTFS..

                    if (lstrcmp(szFileSystemName,
                        GetStringResource (GetDllInstance(), IDS_NTFS)) != 0) {
                        lFatVolumeCount++;
                    }
                } else {
                    // unable to read the volume information so assume the
                    // worst
                    lFatVolumeCount++;
                }
            } else {
                // not a fixed drive so ignore
            }
        } // end FOR each drive in the alphabet

        // see how things turned out
        if (lFatVolumeCount > 0) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            _stprintf (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(),
                    (lFatVolumeCount == 1 ? IDS_NOT_C2_MESSAGE_FORMAT_1 : IDS_NOT_C2_MESSAGE_FORMAT)),
                lFatVolumeCount);
        } else {
            pC2Data->lC2Compliance = SECURE;
            _stprintf (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_C2_MESSAGE_FORMAT));
        }

        SET_ARROW_CURSOR;

    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetFileSystems (
    IN  LPARAM   lParam
)
{
    PC2DLL_DATA pC2Data;

    DWORD       dwDriveFlag;
    TCHAR       szDriveLetter[4];
    TCHAR       szNewCmdBuffer[512];
    LPTSTR      szNewCmd;
    DWORD       dwNewCmdSize = 0;
    LONG        lStatus = ERROR_SUCCESS;
    HKEY        hkeySessionManager;
    BOOL        bUpdateRegistry = FALSE;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;

        if (pC2Data->lActionCode == AC_UPDATE_FS) {
            // display "last change" message
            
            if (pC2Data->lActionValue != 0) {
                // display warning message if 1 or more drives
                // are set to be converted
                if (DisplayDllMessageBox (pC2Data->hWnd,
                    IDS_FS_LAST_CHANCE,
                    IDS_FS_CAPTION,
                    MBOKCANCEL_QUESTION) == IDOK) {
                    bUpdateRegistry = TRUE;
                } else {
                    bUpdateRegistry = FALSE;
                }
            } else {
                // no drives are set to be converted so the 
                // update will be to remove the conversion commands
                // from the registry. Since this is reverting the
                // system back to it's original state, no message is
                // necessary.
                bUpdateRegistry = TRUE;
            }

            if (bUpdateRegistry) {
                szDriveLetter[1] = 0;
                memset (szNewCmdBuffer, 0, sizeof(szNewCmdBuffer));
                szNewCmd = szNewCmdBuffer;

                // initialize with prefix command

                lstrcpy (szNewCmd,
                    GetStringResource (GetDllInstance(), IDS_AUTOCHEK_CMD));

                szNewCmd += lstrlen(szNewCmd);
                *szNewCmd++ = 0;

                // loop through all possible DOS drive Letters until
                // there are no more in the ActionValue mask to convert
                // or the end of the DOS Drive alphabet is reached.
                //  
                // The drive flag bits correspond to each possible drive
                // letter. e.g. bit 0 (0x00000001) = A:, 
                //  bit 2 (0x00000002) = B:, etc.
                //
                for (dwDriveFlag = 1, szDriveLetter[0] = TEXT('A');
                    ((dwDriveFlag <= (DWORD)pC2Data->lActionValue) && (szDriveLetter[0] <= TEXT('Z')));
                    dwDriveFlag <<= 1, szDriveLetter[0]++) {
                    if ((dwDriveFlag & pC2Data->lActionValue) == dwDriveFlag) {
                        _stprintf (szNewCmd,
                            GetStringResource (GetDllInstance(), IDS_AUTOCONV_CMD),
                            szDriveLetter);
                        // terminate string and point to next
                        // string in MSZ buffer
	                    szNewCmd += lstrlen(szNewCmd);
  	                    *szNewCmd++ = 0;
   	                }
                } // end for each possible Drive Letter

                *szNewCmd++ = 0; // terminate MSZ buffer
                dwNewCmdSize = (DWORD)((LPBYTE)szNewCmd) -
                    (DWORD)((LPBYTE)&szNewCmdBuffer[0]);

                // write new registry value so drives will be converted
                // when system restarts

                lStatus = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GetStringResource (GetDllInstance(), IDS_SESSION_MANAGER_KEY),
                    0L,
                    KEY_WRITE,
                    &hkeySessionManager);

                if (lStatus == ERROR_SUCCESS) {
                    // registry key opened successfully
                    lStatus = RegSetValueEx (
                        hkeySessionManager,
                        GetStringResource (GetDllInstance(), IDS_BOOT_EXECUTE_VALUE),
                        0L,
                        REG_MULTI_SZ,
                        (LPBYTE)&szNewCmdBuffer[0],
                        dwNewCmdSize);
                    RegCloseKey (hkeySessionManager);
                } // end if Session Manager Key opened
            } // end if user really wants to do this
        } // end if user has clicked "OK" on display dialog

        pC2Data->lActionCode = AC_NO_CHANGE;
        pC2Data->lActionValue = 0;

    } else {
        lStatus = ERROR_BAD_ARGUMENTS;
    } // end if data structure found/not found

    return lStatus;
}

LONG
C2DisplayFileSystems (
    IN  LPARAM   lParam
)
{
    PC2DLL_DATA pC2Data;
    DWORD       dwDriveBitMask;

    int nDlgBoxReturn;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // check the C2 Compliance flag to see if the list box or
        // message box should be displayed
        if (pC2Data->lC2Compliance == SECURE) {
            // all volumes are OK so just pop a message box
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_C2_DISPLAY_MESSAGE,
                IDS_FS_CAPTION,
                MBOK_INFO);
            pC2Data->lActionCode = AC_NO_CHANGE;
        } else {
            //one or more volumes are not NTFS so display the list box
            // listing the ones that arent.
            nDlgBoxReturn = DialogBoxParam (
                GetDllInstance(),
                MAKEINTRESOURCE (IDD_LIST_DLG),
                pC2Data->hWnd,
                C2FileSysDlgProc,
                (LPARAM)&dwDriveBitMask);
            if (nDlgBoxReturn == IDOK) {
                pC2Data->lActionCode = AC_UPDATE_FS;
                pC2Data->lActionValue = dwDriveBitMask;
            } else {
                pC2Data->lActionCode = AC_NO_CHANGE;
                pC2Data->lActionValue = 0;
            }
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\logonmsg.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    logonmsg.C

Abstract:

    functions used to set the logon message and caption bar text
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_LOGONMSG_NOCHANGE        0
#define AC_LOGONMSG_UPDATE          1

// struct used by set function
#define MAX_CAPTION_LENGTH          127
#define MAX_MESSAGE_LENGTH          2047

typedef struct _LOGON_MSG_UPDATE {
    TCHAR   szCaption[MAX_CAPTION_LENGTH+1];
    TCHAR   szMessage[MAX_MESSAGE_LENGTH+1];
} LMU_DATA, *PLMU_DATA;

#define  SECURE   C2DLL_SECURE

static
VOID
EnableEditControls (
    HWND    hDlg,
    BOOL    bNewState
)
{
    EnableWindow (GetDlgItem (hDlg, IDC_LOGON_CAPTION_TITLE), bNewState);
    InvalidateRect (GetDlgItem (hDlg, IDC_LOGON_CAPTION_TITLE), NULL, TRUE);
    EnableWindow (GetDlgItem (hDlg, IDC_LOGON_CAPTION), bNewState);
    InvalidateRect (GetDlgItem (hDlg, IDC_LOGON_CAPTION), NULL, TRUE);
    EnableWindow (GetDlgItem (hDlg, IDC_LOGON_MESSAGE_TITLE), bNewState);
    InvalidateRect (GetDlgItem (hDlg, IDC_LOGON_MESSAGE_TITLE), NULL, TRUE);
    EnableWindow (GetDlgItem (hDlg, IDC_LOGON_MESSAGE), bNewState);
    InvalidateRect (GetDlgItem (hDlg, IDC_LOGON_MESSAGE), NULL, TRUE);
}

static
BOOL
SetLogonMessage (
    PLMU_DATA   pLogonMsg
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so set caption value
        lStatus = RegSetValueEx (
            hKeyWinlogon,
            GetStringResource (GetDllInstance(), IDS_LOGON_CAPTION_VALUE),
            0L,
            REG_SZ,
            (CONST LPBYTE)pLogonMsg->szCaption,
            (lstrlen(pLogonMsg->szCaption) + 1) * sizeof(TCHAR));

        if (lStatus == ERROR_SUCCESS) {
            // value set OK so set message value
            lStatus = RegSetValueEx (
                hKeyWinlogon,
                GetStringResource (GetDllInstance(), IDS_LOGON_MESSAGE_VALUE),
                0L,
                REG_SZ,
                (CONST LPBYTE)pLogonMsg->szMessage,
                (lstrlen(pLogonMsg->szMessage) + 1) * sizeof(TCHAR));

            if (lStatus == ERROR_SUCCESS) {
                bReturn = TRUE;
            } else {
                bReturn = FALSE;
            }
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
BOOL
GetLogonMessage (
    PLMU_DATA   pLogonMsg
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwValue = 0;
    DWORD   dwValueSize = sizeof(DWORD);
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    // clear the buffers

    pLogonMsg->szCaption[0] = 0;
    pLogonMsg->szMessage[0] = 0;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_READ,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check value
        dwValueSize = MAX_CAPTION_LENGTH * sizeof(TCHAR);
        lStatus = RegQueryValueEx (
            hKeyWinlogon,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_LOGON_CAPTION_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)pLogonMsg->szCaption,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType != REG_SZ) {
                // not a string so set string buffer to an empty string
                pLogonMsg->szCaption[0] = 0;
            }

            // get message text
            dwValueSize = MAX_MESSAGE_LENGTH * sizeof(TCHAR);
            lStatus = RegQueryValueEx (
                hKeyWinlogon,
                (LPTSTR)GetStringResource (GetDllInstance(), IDS_LOGON_MESSAGE_VALUE),
                (LPDWORD)NULL,
                &dwType,
                (LPBYTE)pLogonMsg->szMessage,
                &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
                // value read successfully so check it out
                if (dwType != REG_SZ) {
                    // not a string so set string buffer to an empty string
                    pLogonMsg->szMessage[0] = 0;
                }
                bReturn = TRUE;
            } else {
                bReturn = FALSE;
                SetLastError (ERROR_CANTREAD);
            }

        } else {
            // no value present
            bReturn = FALSE;
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

BOOL CALLBACK
C2LogonMsgDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Audit Failure dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  PLMU_DATA   plmuData;   // save address of caller's data block
    DWORD   dwLogSetting = 0;
    int     nState;
    LONG    lCaptionLen;
    LONG    lMessageLen;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            plmuData = (PLMU_DATA)lParam;

            if ((lstrlen(plmuData->szCaption) > 0) &&
                (lstrlen(plmuData->szMessage) > 0)) {
                // then there's text so load edit fields and uncheck button
                SetDlgItemText (hDlg, IDC_LOGON_CAPTION, plmuData->szCaption);
                SetDlgItemText (hDlg, IDC_LOGON_MESSAGE, plmuData->szMessage);
                CheckDlgButton (hDlg, IDC_NO_LOGON_MESSAGE, UNCHECKED);
            }  else {
                // there's no text so check button
                CheckDlgButton (hDlg, IDC_NO_LOGON_MESSAGE, CHECKED);
                // disable edit windows
                EnableEditControls (hDlg, DISABLED);
            }
            // set text limits on edit boxes
            SendDlgItemMessage (hDlg, IDC_LOGON_CAPTION, EM_LIMITTEXT,
                (WPARAM)MAX_CAPTION_LENGTH, 0);
            SendDlgItemMessage (hDlg, IDC_LOGON_MESSAGE, EM_LIMITTEXT,
                (WPARAM)MAX_MESSAGE_LENGTH, 0);

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        if (IsDlgButtonChecked (hDlg, IDC_NO_LOGON_MESSAGE) == CHECKED) {
                            // delete message text
                            plmuData->szCaption[0] = 0;
                            plmuData->szMessage[0] = 0;

                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else {
                            // get the message text from the edit controls
                            GetDlgItemText (hDlg, IDC_LOGON_CAPTION,
                                plmuData->szCaption, MAX_CAPTION_LENGTH);
                            GetDlgItemText (hDlg, IDC_LOGON_MESSAGE,
                                plmuData->szMessage, MAX_MESSAGE_LENGTH);

                            // make sure there's data in them!

                            if ((lstrlen(plmuData->szCaption) > 0) &&
                                (lstrlen(plmuData->szMessage) > 0)) {
                                // then there's text so exit
                                EndDialog (hDlg, (int)LOWORD(wParam));
                            } else {
                                // they've selected they want to have a
                                // message, but haven't entered any text
                                // so display the message
                                DisplayDllMessageBox (hDlg,
                                    IDS_LOGON_MESSAGE_NO_TEXT,
                                    IDS_LOGON_MESSAGE_CAPTION,
                                    MBOK_INFO);
                                if (lstrlen(plmuData->szCaption) == 0) {
                                    SetFocus (GetDlgItem (hDlg, IDC_LOGON_CAPTION));
                                } else {
                                    SetFocus (GetDlgItem (hDlg, IDC_LOGON_MESSAGE));
                                }
                            }
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        nState = ENABLED;
                        CheckDlgButton (hDlg, IDC_NO_LOGON_MESSAGE, UNCHECKED);
                        
                        // en/disable edit windows
                        EnableEditControls (hDlg, nState);

                        // if there is no text in both of the edit fields 
                        // then  display information message
                        
                        lCaptionLen = SendDlgItemMessage (hDlg, IDC_LOGON_CAPTION,
                            WM_GETTEXTLENGTH, 0, 0);
                        lMessageLen = SendDlgItemMessage (hDlg, IDC_LOGON_MESSAGE,
                            WM_GETTEXTLENGTH, 0, 0);
                        
                        if ((lCaptionLen == 0) || (lMessageLen == 0)) {
                            DisplayDllMessageBox (hDlg,
                                IDS_LOGON_MESSAGE_C2_BTN,
                                IDS_LOGON_MESSAGE_CAPTION,
                                MBOK_INFO);
                        }
                        // un-check the no message button

                        // set focus to the first empty window
                        if (lCaptionLen == 0) {
                            SetFocus (GetDlgItem (hDlg, IDC_LOGON_CAPTION));
                        } else if (lMessageLen == 0) {
                            SetFocus (GetDlgItem (hDlg, IDC_LOGON_MESSAGE));
                        } else {
                            // if both have text, then goto the caption field
                            SetFocus (GetDlgItem (hDlg, IDC_LOGON_CAPTION));
                        }

                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_NO_LOGON_MESSAGE:
                    if (IsDlgButtonChecked (hDlg, IDC_NO_LOGON_MESSAGE) == CHECKED) {
                        // currently checked so uncheck
                        nState = ENABLED;
                        CheckDlgButton (hDlg, IDC_NO_LOGON_MESSAGE, UNCHECKED);
                    } else {
                        // currently checked so check;
                        nState = DISABLED;
                        CheckDlgButton (hDlg, IDC_NO_LOGON_MESSAGE, CHECKED);
                    }

                    // en/disable edit windows
                    EnableEditControls (hDlg,  nState);

                    return TRUE;

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryLogonMessage (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if there is a logon message
        on the system. For C2 compliance, a logon message must be
        defined on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;
    LMU_DATA     lmuData;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        if (GetLogonMessage (&lmuData)) {
            if ((lstrlen(lmuData.szCaption) > 0) &&
                (lstrlen(lmuData.szMessage) > 0)) {
                // if there's a message defined then this is OK
                pC2Data->lC2Compliance = SECURE;   // this is good
                nMsgString = IDS_LOGON_MESSAGE_DEFINED;
            } else {
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;   // this is not good
                nMsgString = IDS_LOGON_MESSAGE_NOT_DEF;
            }
        } else {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;   // this is not good
            nMsgString = IDS_UNABLE_READ;
        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgString));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetLogonMessage (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;
    PLMU_DATA    plmuData;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action value = the address of the data block used to update
        if (pC2Data->lActionCode == AC_LOGONMSG_UPDATE) {
            plmuData = (PLMU_DATA)pC2Data->lActionValue;
            if (SetLogonMessage (plmuData)) {
                if ((lstrlen(plmuData->szCaption) > 0) &&
                    (lstrlen(plmuData->szMessage) > 0)) {
                    // if there's a message defined then this is OK
                    pC2Data->lC2Compliance = SECURE;   // this is good
                    nMsgString = IDS_LOGON_MESSAGE_DEFINED;
                } else {
                    pC2Data->lC2Compliance = C2DLL_NOT_SECURE;   // this is not good
                    nMsgString = IDS_LOGON_MESSAGE_NOT_DEF;
                }
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), nMsgString));
            } else {
                DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_LOGON_MESSAGE_ERROR_SET,
                    IDS_LOGON_MESSAGE_CAPTION,
                    MBOK_EXCLAIM);
            }
        }
        // update action values
        pC2Data->lActionCode = 0;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayLogonMessage (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    static      LMU_DATA    lmuData;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // load the current message strings
        GetLogonMessage (&lmuData);
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_LOGON_MESSAGE),
            pC2Data->hWnd,
            C2LogonMsgDlgProc,
            (LPARAM)&lmuData) == IDOK) {
            pC2Data->lActionCode = AC_LOGONMSG_UPDATE;
            pC2Data->lActionValue = (LONG)&lmuData;
        } else {
            // no action
            pC2Data->lActionCode = AC_LOGONMSG_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\oschecks.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    OSChecks.C

Abstract:

    functions to used to determine the Operating System(s) installed
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include <strings.h>
#include "c2funcs.h"
#include "c2funres.h"

// define action codes here. They are only meaningful in the
// context of this module.

#define  AC_NO_CHANGE      0
#define  AC_UPDATE         1
//
// for the action value, these are bits in a bit-mask used to
// describe the action to take in the SET procedure
//
#define  AV_DELETE_DOS     1
#define  AV_SET_TIMEOUT    2
#define  AV_SET_DEFAULT    4

#define  SECURE   C2DLL_C2
//
//      define local macros
// 
#define MALLOC(size)            (PVOID)LocalAlloc(LPTR,size)
#define FREE(block)             {LocalFree(block); block = NULL;}
//
//      Unicode Specific macros
//
#if _UNICODE
#define DriveLetterToArcPath(a) DriveLetterToArcPathW(a)

#else   // not unicode
#define DriveLetterToArcPath(a) DriveLetterToArcPathA(a)

#endif
//
// Leave as array because some code uses sizeof(ArcNameDirectory)
//
WCHAR ArcNameDirectory[] = L"\\ArcName";
BOOL  bTargetsDefined = FALSE;
PWSTR DosDeviceTargets[24];
//
//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

static
BOOL
IsIntelProcessor()
{
    SYSTEM_INFO si;

    memset (&si, 0, sizeof(si));

    GetSystemInfo(&si);

    if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

static
VOID
DnConcatenatePaths(
    IN OUT PWSTR Path1,
    IN     PWSTR Path2,
    IN     DWORD BufferSizeBytes
    )
{
    BOOL NeedBackslash = TRUE;
    DWORD l = lstrlenW(Path1);
    DWORD BufferSizeChars;

    BufferSizeChars = (BufferSizeBytes >= sizeof(WCHAR))
                    ? ((BufferSizeBytes/sizeof(WCHAR))-1)   // leave room for nul
                    : 0;

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == L'\\')) {

        NeedBackslash = FALSE;
    }

    if(*Path2 == L'\\') {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcatW(Path1,L"\\");
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(l+lstrlenW(Path2) < BufferSizeChars) {
        lstrcatW(Path1,Path2);
    }
}

static
PWSTR
DupString(
    IN PWSTR String
    )
{
    PWSTR p;

    p = MALLOC((lstrlenW(String)+1)*sizeof(WCHAR));
    lstrcpyW(p,String);
    return(p);
}

static
VOID
InitDriveNameTranslations(
    VOID
    )
{
    WCHAR DriveName[3];
    WCHAR Drive;
    WCHAR DriveRoot[4];
    WCHAR Buffer[512];

    DriveName[1] = L':';
    DriveName[2] = 0;

    DriveRoot[0] = L' ';
    DriveRoot[1] = L':';
    DriveRoot[2] = L'\\';
    DriveRoot[3] = 0;
    //
    // Calculate NT names for all local hard disks C-Z.
    //
    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

        DosDeviceTargets[Drive-L'C'] = NULL;

        DriveRoot[0] = Drive;
        if(GetDriveTypeW(DriveRoot) == DRIVE_FIXED) {

            DriveName[0] = Drive;

            // BUGBUG: this could be a mem leak...

            if(QueryDosDeviceW(DriveName,Buffer,(sizeof(Buffer)/sizeof(WCHAR)))) {
                DosDeviceTargets[Drive-L'C'] = DupString(Buffer);
            }
        }
    }
}

static
PWSTR
DriveLetterToArcPathW(
    IN WCHAR DriveLetter
    )
{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOL RestartScan;
    DWORD Context;
    BOOL MoreEntries;
    PWSTR ArcName;
    UCHAR Buffer[1024];
    POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;
    PWSTR ArcPath;
    PWSTR NtPath;

    NtPath = DosDeviceTargets[towupper(DriveLetter) - L'C'];
    if(!NtPath) {
        return(NULL);
    }

    //
    // Assume failure.
    //
    ArcPath = NULL;

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = NtOpenDirectoryObject(&DirectoryHandle,DIRECTORY_QUERY,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = NtQueryDirectoryObject(
                        (HANDLE)DirectoryHandle,
                        (PVOID)&Buffer[0],
                        (ULONG)sizeof(Buffer),
                        (BOOLEAN)TRUE,           // return single entry
                        (BOOLEAN)RestartScan,
                        (PULONG)&Context,
                        (PULONG)NULL            // return length
                        );

            if(NT_SUCCESS(Status)) {

                _wcslwr(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= (sizeof(L"SymbolicLink") - sizeof(WCHAR)))
                && !_wcsnicmp(DirInfo->TypeName.Buffer,L"SymbolicLink",12))
                {
                    ArcName = MALLOC(DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR));

                    wcscpy(ArcName,ArcNameDirectory);
                    DnConcatenatePaths(ArcName,DirInfo->Name.Buffer,(DWORD)(-1));

                    //
                    // We have the entire arc name in ArcName.  Now open it as a symbolic link.
                    //
                    INIT_OBJA(&Obja,&UnicodeString,ArcName);

                    Status = NtOpenSymbolicLinkObject(
                                &ObjectHandle,
                                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                &Obja
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Finally, query the object to get the link target.
                        //
                        UnicodeString.Buffer = (PWSTR)Buffer;
                        UnicodeString.Length = 0;
                        UnicodeString.MaximumLength = sizeof(Buffer);

                        Status = NtQuerySymbolicLinkObject(
                                    ObjectHandle,
                                    &UnicodeString,
                                    NULL
                                    );

                        if(NT_SUCCESS(Status)) {

                            //
                            // nul-terminate the returned string
                            //
                            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

                            if(!_wcsicmp(UnicodeString.Buffer,NtPath)) {

                                ArcPath = ArcName
                                        + (sizeof(ArcNameDirectory)/sizeof(WCHAR));
                            }
                        }

                        NtClose(ObjectHandle);
                    }

                    if(!ArcPath) {
                        FREE(ArcName);
                    }
                }

            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries && !ArcPath);

        NtClose(DirectoryHandle);
    }

    //
    // ArcPath points into thje middle of a buffer.
    // The caller needs to be able to free it, so place it in its
    // own buffer here.
    //
    if(ArcPath) {
        ArcPath = DupString(ArcPath);
        FREE(ArcName);
    }

    return(ArcPath);
}

static
WCHAR
ArcPathToDriveLetter(
    IN PWSTR ArcPath
    )
{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    WCHAR DriveLetter;
    WCHAR drive;
    PWSTR arcPath;

    //
    // Assume failure
    //
    DriveLetter = 0;

    arcPath = MALLOC(((wcslen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(ArcNameDirectory));
    wcscpy(arcPath,ArcNameDirectory);
    wcscat(arcPath,L"\\");
    wcscat(arcPath,ArcPath);

    INIT_OBJA(&Obja,&UnicodeString,arcPath);

    Status = NtOpenSymbolicLinkObject(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {

        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject(
                    ObjectHandle,
                    &UnicodeString,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {

            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

            for(drive=L'C'; drive<=L'Z'; drive++) {

                if(DosDeviceTargets[drive-L'C']
                && !_wcsicmp(UnicodeString.Buffer,DosDeviceTargets[drive-L'C']))
                {
                    DriveLetter = drive;
                    break;
                }
            }
        }

        NtClose(ObjectHandle);
    }

    FREE(arcPath);

    return(DriveLetter);
}

static
BOOL
IsBootIniTimeoutZero (
)
{
    TCHAR   szTimeOut[MAX_PATH];
    LONG    lRetLen;
    LONG    lTimeOut;

    lRetLen = GetPrivateProfileString (
        GetStringResource (GetDllInstance(), IDS_BOOT_LOADER_SECTION),
        GetStringResource (GetDllInstance(), IDS_TIMEOUT),
        cmszEmptyString,
        szTimeOut,
        MAX_PATH,
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_PATH));

    if (lRetLen > 0) {
        lTimeOut = _tcstol (szTimeOut, NULL, 10);
        // note that 0 is returned if the string cannot be translated!
        if (lTimeOut > 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    } else {
        // no time out string found
        return FALSE;
    }
}

static
LPSTR
DriveLetterToArcPathA (
    IN  CHAR    DriveLetter
)
{
    WCHAR   wDriveLetter;
    PWSTR   wszArcPath;
    LPSTR   szArcPath;
    int     nRetLen;

    wDriveLetter = (WCHAR)DriveLetter;

    wszArcPath = DriveLetterToArcPathW(wDriveLetter);
    if (wszArcPath != NULL) {
        // convert back to ASCII
        nRetLen = lstrlenW(wszArcPath);
        szArcPath = MALLOC (nRetLen+1);
        if (szArcPath != NULL) {
            wcstombs (szArcPath, wszArcPath, nRetLen);
        }
    } else {
        szArcPath = NULL;
    }
    return szArcPath;
}

static
LONG
GetArcWindowsPath (
    OUT LPTSTR  szArcPath,      // buffer to write path to 
    IN  DWORD   dwChars         // buffer length in chars
)
{
    TCHAR   szDosWindowsDir[MAX_PATH];
    LPTSTR  szArcWindowsDrive;
    DWORD   dwBufReqd;

    if (szArcPath != NULL) {
        if (GetWindowsDirectory(szDosWindowsDir, MAX_PATH) > 0) {
            // convert Dos path to Arc Path
            szArcWindowsDrive = DriveLetterToArcPath(szDosWindowsDir[0]);
            if (szArcWindowsDrive != NULL)  {
                // make sure there's room in the buffer
                dwBufReqd = lstrlen(szArcWindowsDrive) +
                    lstrlen(&szDosWindowsDir[2]);
                if (dwBufReqd < dwChars) {
                    // theres room so copy and
                    // make full path
                    lstrcpy (szArcPath, szArcWindowsDrive);
                    lstrcat (szArcPath, &szDosWindowsDir[2]);
                } else {
                    // insufficient room so return 0
                    dwBufReqd = 0;
                    *szArcPath = 0;
                }
                // release memory allocated by conversion
                FREE (szArcWindowsDrive);
            } else {
                // unable to convert drive to arc path so return 0
                dwBufReqd = 0;
                *szArcPath = 0;
            }
        } else {
            // unable to get current windows dir so return 0
            dwBufReqd = 0;
            *szArcPath = 0;
        }
    } else {
        // empty or null buffer passed so just return 0 len
        dwBufReqd = 0;
    }
    return (LONG)dwBufReqd;
}

static
BOOL
IsCurrentSystemDefault (
)
{
    TCHAR   szArcWindowsDir[MAX_PATH*2];
    TCHAR   szArcDefaultDir[MAX_PATH];
    LONG    lStatus;
    BOOL    bReturn;

    if (GetArcWindowsPath(szArcWindowsDir, MAX_PATH*2) > 0) {
        // get boot.ini default from [Boot Loader] section
        lStatus = GetPrivateProfileString (
            GetStringResource (GetDllInstance(), IDS_BOOT_LOADER_SECTION),
            GetStringResource (GetDllInstance(), IDS_DEFAULT_KEY),
            cszEmptyString,
            &szArcDefaultDir[0],
            MAX_PATH,
            GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME));
        if (lStatus > 0) {
            if (lstrcmpi (szArcDefaultDir, szArcWindowsDir) == 0) {
                // default is current system
                bReturn = TRUE;
            } else {
                // default is not current system
                bReturn = FALSE;
            }
        }
    } else { 
        //unable to get windows dir
        bReturn = FALSE;
    }
    return bReturn;
}

static
BOOL
ZeroFileByName (
    IN  LPCTSTR  szFileName
)
{
    DWORD   dwOldAttrib = 0;
    DWORD   dwNewAttrib = 0;
    HANDLE  hFile;
    BOOL    bReturn = FALSE;

    if (FileExists (szFileName)) {
        // save the original attributes for later
        dwOldAttrib = GetFileAttributes (szFileName);
    
        // set file attributes on file to allow modification
        SetFileAttributes (szFileName, FILE_ATTRIBUTE_NORMAL);
    
        // make sure it went OK
        dwNewAttrib = GetFileAttributes (szFileName);

        if (dwNewAttrib  == FILE_ATTRIBUTE_NORMAL) {
            hFile = CreateFile (
                szFileName,
                GENERIC_WRITE,
                0L,     // no sharing while this is done
                NULL,   // no security
                TRUNCATE_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle (hFile);
                bReturn = TRUE;     
            }

            // reset the attributes

            SetFileAttributes (szFileName, dwOldAttrib);
        }
    } else {
        // file doesn't exist so it's already 0'd
        bReturn = TRUE; 
    }
    return bReturn;
}

static
BOOL
DeleteDosFiles (
)
{
    BOOL bReturn;

    bReturn = ZeroFileByName (
        GetStringResource(GetDllInstance(), IDS_IO_SYS));
    
    if (bReturn) {
        bReturn = ZeroFileByName (
            GetStringResource(GetDllInstance(), IDS_MSDOS_SYS));
    }

    if (bReturn) {
        bReturn = ZeroFileByName (
            GetStringResource(GetDllInstance(), IDS_PCDOS_SYS));

    }

    return bReturn;
}

static
BOOL
SetBootIniTimeoutToZero (
)
{
    BOOL    bReturn = TRUE;
    DWORD   dwNewBootIniAttrib = 0;
    DWORD   dwOrigBootIniAttrib = 0;

    // save the original attributes for later
    dwOrigBootIniAttrib = GetFileAttributes (
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME));
    
    // set file attributes on Boot.INI file
    SetFileAttributes (
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME),
        FILE_ATTRIBUTE_NORMAL);
    
    // make sure it went OK
    dwNewBootIniAttrib = GetFileAttributes (
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME));

    if (dwNewBootIniAttrib  == FILE_ATTRIBUTE_NORMAL) {
        bReturn = WritePrivateProfileString (
            GetStringResource (GetDllInstance(), IDS_BOOT_LOADER_SECTION),
            GetStringResource (GetDllInstance(), IDS_TIMEOUT),
            GetStringResource (GetDllInstance(), IDS_0),
            GetStringResource (GetDllInstance(), IDS_BOOT_INI_PATH));
        
        // reset file attributes on Boot.INI file
        SetFileAttributes (
            GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME),
            dwOrigBootIniAttrib);
        return bReturn;
    } else {
        return FALSE;
    }
}

static
BOOL
SetBootDefaultToCurrentSystem (
)
{
    TCHAR   szArcSystemPath[MAX_PATH*2];
    BOOL    bReturn = TRUE;
    DWORD   dwNewBootIniAttrib = 0;
    DWORD   dwOrigBootIniAttrib = 0;

    // save the original attributes for later
    dwOrigBootIniAttrib = GetFileAttributes (
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME));
    
    // set file attributes on Boot.INI file
    SetFileAttributes (
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME),
        FILE_ATTRIBUTE_NORMAL);
    
    // make sure it went OK
    dwNewBootIniAttrib = GetFileAttributes (
        GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME));

    if (dwNewBootIniAttrib  == FILE_ATTRIBUTE_NORMAL) {
        // file set OK so continue and get new path for ini
        if (GetArcWindowsPath(szArcSystemPath, MAX_PATH*2) > 0) {
            bReturn = WritePrivateProfileString (
                GetStringResource (GetDllInstance(), IDS_BOOT_LOADER_SECTION),
                GetStringResource (GetDllInstance(), IDS_DEFAULT_KEY),
                szArcSystemPath,
                GetStringResource (GetDllInstance(), IDS_BOOT_INI_PATH));
            
            // reset file attributes on Boot.INI file
            SetFileAttributes (
                GetStringResource (GetDllInstance(), IDS_BOOT_INI_FILENAME),
                dwOrigBootIniAttrib);
        }
        return bReturn;
    } else {
        return FALSE;
    }
}

static
BOOL
IsDosOnSystem (
)
{
    BOOL    bFileFound;
    LPCTSTR szFileToCheck;

    szFileToCheck = GetStringResource(GetDllInstance(), IDS_IO_SYS);
    bFileFound = FileExists(szFileToCheck);
    if (bFileFound) {
        // check to see if it's really there
        if (GetFileSizeFromPath(szFileToCheck) == 0) {
            // just a name so reset flag
            bFileFound = FALSE;
        }
    }

    if (!bFileFound) {
        szFileToCheck = GetStringResource(GetDllInstance(), IDS_MSDOS_SYS);
        bFileFound = FileExists(szFileToCheck);
        if (bFileFound) {
            // check to see if it's really there
            if (GetFileSizeFromPath(szFileToCheck) == 0) {
                // just a name so reset flag
                bFileFound = FALSE;
            }
        }
    }
    
    if (!bFileFound) {
        szFileToCheck = GetStringResource(GetDllInstance(), IDS_PCDOS_SYS);
        bFileFound = FileExists(szFileToCheck);
        if (bFileFound) {
            // check to see if it's really there
            if (GetFileSizeFromPath(szFileToCheck) == 0) {
                // just a name so reset flag
                bFileFound = FALSE;
            }
        }
    }

    return bFileFound;
    
}

BOOL CALLBACK
C2OpSysDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	 IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam      
)
/*++

Routine Description:

    Window procedure for Operating System List Box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/ 
{
    LONG        lItemCount = 0;
    static     LPDWORD  lpdwActionMask;
    DWORD      dwAction;
    LONG       lIndex;
    LONG       lItems;
 
    switch (message) {
        case WM_INITDIALOG:
            // bail out here if an invalid param was passed
            if (lParam == 0) {
               EndDialog (hDlg, IDCANCEL);
               return FALSE;
            }
            // save pointer to param
            lpdwActionMask = (LPDWORD)lParam;

            // set the dialog box caption and static text
            SetDlgItemText (hDlg, IDC_TEXT,
                GetStringResource (GetDllInstance(), IDS_OS_DLG_TEXT));
            SetWindowText (hDlg,
                GetStringResource (GetDllInstance(), IDS_OS_CAPTION));

            // load list box with characteristics that are not C2
            if (IsDosOnSystem()) {
               lIndex = SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                     LB_ADDSTRING, 0,
                    (LPARAM)GetStringResource (GetDllInstance(), IDS_DOS_ON_SYSTEM));
               if (lIndex != LB_ERR) {
                  lItemCount++;
                  SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_SETITEMDATA,
                     (WPARAM)lIndex, (LPARAM)AV_DELETE_DOS);
               }
            }
                
            if (!IsBootIniTimeoutZero()) {
               lIndex = SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                  LB_ADDSTRING, 0,
                    (LPARAM)GetStringResource (GetDllInstance(), IDS_TIMEOUT_NOT_ZERO));
               if (lIndex != LB_ERR) {
                  lItemCount++;
                  SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_SETITEMDATA,
                     (WPARAM)lIndex, (LPARAM)AV_SET_TIMEOUT);
               }
            }

            // check for current system defined as default
            if (!IsCurrentSystemDefault()) {
               lIndex = SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_ADDSTRING, 0,
                    (LPARAM)GetStringResource (GetDllInstance(), IDS_CURRENT_SYS_NOT_DEFAULT));
               if (lIndex != LB_ERR) {
                  lItemCount++;
                  SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_SETITEMDATA,
                     (WPARAM)lIndex, (LPARAM)AV_SET_DEFAULT);
               }
            }

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // select all entries in the list box
                        SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                            LB_SETSEL, TRUE, (LPARAM)-1);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDOK:
                  dwAction = 0;
                  // scan through list box to see which Items are to be
                  // changed (if any)
                  lItems = SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_GETCOUNT,
                     0, 0);
                  for (lIndex = 0; lIndex < lItems; lIndex++) {
                     // if item is selected, then "or" it's value to the mask
                     // i.e. set it's bit
                     if (SendDlgItemMessage (hDlg, IDC_LIST_BOX, LB_GETSEL, (WPARAM)lIndex, 0) != 0) {
                        dwAction |= (DWORD) SendDlgItemMessage (hDlg, IDC_LIST_BOX,
                           LB_GETITEMDATA, (WPARAM)lIndex, 0);
                     }
                  }

                  // update action value with flag bits
                  *lpdwActionMask = dwAction;
 
                  // fall through to next case
                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryOpSystems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the operating system(s) installed
        on the system. For C2 compliance, ONLY Windows NT is
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        SET_WAIT_CURSOR;

        if (!bTargetsDefined) {
            InitDriveNameTranslations();
            bTargetsDefined = TRUE;
        }

        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        // check for DOS files found on system
        if (IsDosOnSystem()) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_DOS_ON_SYSTEM));
        }

        // check for boot.ini timeout > 0
        if (pC2Data->lC2Compliance == SECURE) {
            if (!IsBootIniTimeoutZero()) {
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), IDS_TIMEOUT_NOT_ZERO));
            }
        }
        
        // check for current system defined as default
        if (pC2Data->lC2Compliance == SECURE) {
            if (!IsCurrentSystemDefault()) {
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), IDS_CURRENT_SYS_NOT_DEFAULT));
            }
        }

        if (pC2Data->lC2Compliance == SECURE) {
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_OS_OK));
        }
        SET_ARROW_CURSOR;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetOpSystems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
   PC2DLL_DATA  pC2Data;

   if (lParam != 0) {
      pC2Data = (PC2DLL_DATA)lParam;
      if ((pC2Data->lActionCode == AC_UPDATE) && (pC2Data->lActionValue != 0)) {
         SET_WAIT_CURSOR;

         if (pC2Data->lActionValue & AV_DELETE_DOS) {
            if (DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_OS_DELETE_DOS_FILES,
                IDS_OS_CAPTION,
                MBOKCANCEL_EXCLAIM | MB_DEFBUTTON2) == IDOK) {
                DeleteDosFiles();
            }
         }
         if (pC2Data->lActionValue & AV_SET_TIMEOUT) {
            if (IsIntelProcessor()) {
                if (DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_OS_ZERO_BOOT_TIMEOUT,
                    IDS_OS_CAPTION,
                    MBOKCANCEL_EXCLAIM | MB_DEFBUTTON2) == IDOK) {
                    SetBootIniTimeoutToZero();
                }
            } else {
                DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_OS_RISC_BOOT_TIMEOUT,
                    IDS_OS_CAPTION,
                    MBOK_EXCLAIM);
            }
         }
         if (pC2Data->lActionValue & AV_SET_DEFAULT) {
            SetBootDefaultToCurrentSystem ();
         }

         // now check to see what happened

         pC2Data->lC2Compliance = SECURE;   // assume true for now
         // check for DOS files found on system
         if (IsDosOnSystem()) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            lstrcpy (pC2Data->szStatusName,
                  GetStringResource (GetDllInstance(), IDS_DOS_ON_SYSTEM));
         }

         // check for boot.ini timeout > 0
         if (pC2Data->lC2Compliance == SECURE) {
            if (!IsBootIniTimeoutZero()) {
                  pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                  lstrcpy (pC2Data->szStatusName,
                     GetStringResource (GetDllInstance(), IDS_TIMEOUT_NOT_ZERO));
            }
         }
      
         // check for current system defined as default
         if (pC2Data->lC2Compliance == SECURE) {
            if (!IsCurrentSystemDefault()) {
                  pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                  lstrcpy (pC2Data->szStatusName,
                     GetStringResource (GetDllInstance(), IDS_CURRENT_SYS_NOT_DEFAULT));
            }
         }

         if (pC2Data->lC2Compliance == SECURE) {
            lstrcpy (pC2Data->szStatusName,
                  GetStringResource (GetDllInstance(), IDS_OS_OK));
         }
         SET_ARROW_CURSOR;
      }

      pC2Data->lActionCode = 0;
   
   } else {
      return ERROR_BAD_ARGUMENTS;
   }

   return ERROR_SUCCESS;
}

LONG
C2DisplayOpSystems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.
      
Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    INT         nDlgBoxReturn;
    LONG        lDlgBoxParam;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // check the C2 Compliance flag to see if the list box or
        // message box should be displayed
        if (pC2Data->lC2Compliance == SECURE) {
            // all volumes are OK so just pop a message box
            lDlgBoxParam = 0;
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_OS_OK,
                IDS_OS_CAPTION,
                MBOK_INFO);
            pC2Data->lActionCode = 0;
            pC2Data->lActionValue = 0;
         } else {                
            //one or more volumes are not NTFS so display the list box
            // listing the ones that arent.
            nDlgBoxReturn = DialogBoxParam (
                GetDllInstance(),
                MAKEINTRESOURCE (IDD_LIST_DLG),
                pC2Data->hWnd,
                C2OpSysDlgProc,
                (LPARAM)&lDlgBoxParam);
            if (nDlgBoxReturn == IDOK) {
                pC2Data->lActionCode = 1;
                pC2Data->lActionValue = lDlgBoxParam;
            } else {
                pC2Data->lActionCode = 0;
                pC2Data->lActionValue = 0;
            }                         
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\os2ss.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    OS2SS.C

Abstract:

    functions to used to determine if the OS/2 subsystem is present
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// define action codes here. They are only meaningful in the
// context of this module.

#define  SECURE      C2DLL_C2

static
BOOL
IsOs2OnSystem (
)
{
    BOOL    bFileFound;
    LPCTSTR szFileToCheck;
    TCHAR   szOs2Path[MAX_PATH];

    SET_WAIT_CURSOR;

    // check for OS2SS.EXE

    szFileToCheck = GetStringResource(GetDllInstance(), IDS_OS2SS_FILE);
    GetExpandedFileName (
        (LPTSTR)szFileToCheck,
        MAX_PATH,
        szOs2Path,
        NULL);

    bFileFound = FileExists(szOs2Path);
    if (bFileFound) {
        // check to see if it's really there
        if (GetFileSizeFromPath(szOs2Path) == 0) {
            // just a name so reset flag
            bFileFound = FALSE;
        }
    }
    
    if (!bFileFound) {
        // check for OS2.EXE

        szFileToCheck = GetStringResource(GetDllInstance(), IDS_OS2_FILE);
        GetExpandedFileName (
            (LPTSTR)szFileToCheck,
            MAX_PATH,
            szOs2Path,
            NULL);

        bFileFound = FileExists(szOs2Path);
        if (bFileFound) {
            // check to see if it's really there
            if (GetFileSizeFromPath(szOs2Path) == 0) {
                // just a name so reset flag
                bFileFound = FALSE;
            }
        }
    }

    SET_ARROW_CURSOR;

    return bFileFound;
}

LONG
C2QueryOs2ss (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be 
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        // check for DOS files found on system
        if (IsOs2OnSystem()) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_OS2_ON_SYSTEM));
        }
        
        if (pC2Data->lC2Compliance == SECURE) {
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_OS2_NOT_ON_SYSTEM));
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetOs2ss (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    LPCTSTR     szFileToCheck;
    TCHAR       szOldPath[MAX_PATH];
    TCHAR       szNewPath[MAX_PATH];
    int         nMbReturn = 0;
    BOOL        bReturn;
    BOOL        bDisplayMessageBox = TRUE;
    LONG        lReturn = ERROR_SUCCESS;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (pC2Data->lActionCode == 1) {
            while (bDisplayMessageBox) {
                nMbReturn = DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_OS2_CONFIRM,
                    IDS_OS2_CAPTION,
                    MBOKCANCEL_EXCLAIM |
/* WinVer >= 4.0 only
                    MB_HELP |
*/
                    MB_DEFBUTTON2);

                switch (nMbReturn) {
                    case IDOK:
                        SET_WAIT_CURSOR;
                        szFileToCheck = GetStringResource(
                            GetDllInstance(), IDS_OS2SS_FILE);
                        GetExpandedFileName (
                            (LPTSTR)szFileToCheck,
                            MAX_PATH,
                            szOldPath,
                            NULL);

                        if (FileExists (szOldPath)) {
                            szFileToCheck = GetStringResource(
                                GetDllInstance(), IDS_NEW_OS2SS_FILE);
                            GetExpandedFileName (
                                (LPTSTR)szFileToCheck,
                                MAX_PATH,
                                szNewPath,
                                NULL);
            
                            bReturn = DeleteFile (szOldPath);
                        } else {
                            // if the file does not exist, then that's ok too.
                            bReturn = TRUE; 
                        }

                        if (bReturn) {
                            // then all went OK so change the other file now

                            szFileToCheck = GetStringResource(
                                GetDllInstance(), IDS_OS2_FILE);
                            GetExpandedFileName (
                                (LPTSTR)szFileToCheck,
                                MAX_PATH,
                                szOldPath,
                                NULL);

                            if (FileExists (szOldPath)) {
                                szFileToCheck = GetStringResource(
                                    GetDllInstance(), IDS_NEW_OS2_FILE);
                                GetExpandedFileName (
                                    (LPTSTR)szFileToCheck,
                                    MAX_PATH,
                                    szNewPath,
                                    NULL);
            
                                bReturn = DeleteFile (szOldPath);
                            } else {
                                // if the file does not exist, then that's ok too.
                                bReturn = TRUE; 
                            }
                        }
                        if (bReturn) {
                            // then all files have been renamed so update message
                            pC2Data->lC2Compliance = SECURE;
                            lstrcpy (pC2Data->szStatusName,
                                GetStringResource (GetDllInstance(),
                                    IDS_OS2_NOT_ON_SYSTEM));
                            lReturn = ERROR_SUCCESS;
                        } else {
                            DisplayDllMessageBox (
                                pC2Data->hWnd,
                                IDS_OS2_ERROR_MOVING,
                                IDS_OS2_CAPTION,
                                MBOK_EXCLAIM);
                            lReturn = ERROR_CAN_NOT_COMPLETE;
                        }
                        SET_ARROW_CURSOR;
                        bDisplayMessageBox = FALSE;
                        break;

                    case IDCANCEL:
                        bDisplayMessageBox = FALSE;
                        break;
/* WinVer >= 4.00 only
                    case IDHELP:
                        PostMessage (pC2Data->hWnd, UM_SHOW_CONTEXT_HELP, 0, 0);
                        break;
*/

                }
                pC2Data->lActionCode = 0;
            } // end while Show Message Box
        }
     } else {
        lReturn = ERROR_BAD_ARGUMENTS;
    }
    return lReturn;
}

LONG
C2DisplayOs2ss (
    IN  LPARAM   lParam
)
/*++                             

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.
      
Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // check the C2 Compliance flag to see if the list box or
        // message box should be displayed
        if (pC2Data->lC2Compliance == SECURE) {
            // all volumes are OK so just pop a message box
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_OS2_NOT_ON_SYSTEM,
                IDS_OS2_CAPTION,
                MBOK_INFO);
            pC2Data->lActionCode = 0;
        } else {
            if (DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_OS2_DISPLAY_MESSAGE,
                IDS_OS2_CAPTION,
                MBOKCANCEL_EXCLAIM) == IDOK) {
                pC2Data->lActionCode = 1;
            } else {
                pC2Data->lActionCode = 0;
            }
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\posix.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    posix.C

Abstract:

    functions to used to determine if the OS/2 subsystem is present
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// define action codes here. They are only meaningful in the
// context of this module.

#define SECURE C2DLL_C2

static
BOOL
IsPosixOnSystem (
)
{
    BOOL    bFileFound;
    LPCTSTR szFileToCheck;
    TCHAR   szPosixPath[MAX_PATH];

    SET_WAIT_CURSOR;

    szFileToCheck = GetStringResource(GetDllInstance(), IDS_POSIX_FILE);
    GetExpandedFileName (
        (LPTSTR)szFileToCheck,
        MAX_PATH,
        szPosixPath,
        NULL);

    bFileFound = FileExists(szPosixPath);
    if (bFileFound) {
        // check to see if it's really there
        if (GetFileSizeFromPath(szPosixPath) == 0) {
            // just a name so reset flag
            bFileFound = FALSE;
        }
    }

    SET_ARROW_CURSOR;

    return bFileFound;
}

LONG
C2QueryPosix (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be 
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{   
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        // check for DOS files found on system
        if (IsPosixOnSystem()) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_POSIX_ON_SYSTEM));
        }
        
        if (pC2Data->lC2Compliance == SECURE) {
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_POSIX_NOT_ON_SYSTEM));
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetPosix (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    LPCTSTR     szFileToCheck;
    TCHAR       szOldPath[MAX_PATH];
    TCHAR       szNewPath[MAX_PATH];
    BOOL        bReturn;
    LONG        lReturn = ERROR_SUCCESS;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (pC2Data->lActionCode == 1) {
            if (DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_POSIX_CONFIRM,
                IDS_POSIX_CAPTION,
                MBOKCANCEL_EXCLAIM | MB_DEFBUTTON2) == IDOK) {

                SET_WAIT_CURSOR;
                szFileToCheck = GetStringResource(
                    GetDllInstance(), IDS_POSIX_FILE);
                GetExpandedFileName (
                    (LPTSTR)szFileToCheck,
                    MAX_PATH,
                    szOldPath,
                    NULL);

                if (FileExists (szOldPath)) {
                    szFileToCheck = GetStringResource(
                        GetDllInstance(), IDS_NEW_POSIX_FILE);
                    GetExpandedFileName (
                        (LPTSTR)szFileToCheck,
                        MAX_PATH,
                        szNewPath,
                        NULL);
            
                    bReturn = DeleteFile (szOldPath);
                } else {
                    // if the file does not exist, then that's ok too.
                    bReturn = TRUE; 
                }

                SET_ARROW_CURSOR;

                if (bReturn) {
                    // then all files have been renamed so update message
                    pC2Data->lC2Compliance = SECURE;
                    lstrcpy (pC2Data->szStatusName,
                        GetStringResource (GetDllInstance(),
                            IDS_POSIX_NOT_ON_SYSTEM));
                    return ERROR_SUCCESS;
                } else {
                    DisplayDllMessageBox (
                        pC2Data->hWnd,
                        IDS_POSIX_ERROR_MOVING,
                        IDS_POSIX_CAPTION,
                        MBOK_EXCLAIM);
                    return ERROR_CAN_NOT_COMPLETE;
                }
            }
            pC2Data->lActionCode = 0;
        }
     } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2DisplayPosix (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.
      
Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // check the C2 Compliance flag to see if the list box or
        // message box should be displayed
        if (pC2Data->lC2Compliance == SECURE) {
            // all volumes are OK so just pop a message box
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_POSIX_NOT_ON_SYSTEM,
                IDS_POSIX_CAPTION,
                MBOK_INFO);
            pC2Data->lActionCode = 0;
        } else {
            if (DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_POSIX_DISPLAY_MESSAGE,
                IDS_POSIX_CAPTION,
                MBOKCANCEL_EXCLAIM) == IDOK) {
                pC2Data->lActionCode = 1;
            } else {
                pC2Data->lActionCode = 0;
            }
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\other.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Other.c

Abstract:

    Displays a dialog box of items that are required but not detectable
    from the program

Revision History:

    23 Dec 94 Created

--*/
#include <windows.h>    // standard Windows includes
#include <tchar.h>      // for UNICODE/ANSI compatiblity
#include <stdio.h>      // text formatting & display functions
#include <c2dll.h>      // DLL interface definitions
#include "c2funcs.h"    // local functions & definitions
#include "c2funres.h"   // local resources
#include "c2utils.h"    // local utilities

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_OTHER_NO_ACTION   0
#define AC_OTHER_MAKE_C2     1
#define AC_OTHER_MAKE_NOTC2  2

// use this line for security items not required by the C2 doc
//#define SECURE    C2DLL_SECURE      
// use this line for security items required by the C2 doc
#define SECURE    C2DLL_C2

BOOL CALLBACK
C2OtherItemsDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog procedure for Other Security Items dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;
            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;  // clear value
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryOtherItems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

    INPUTS:
        lActionCode     = 0
        lActionValue    = 0
        hWnd            = window handle to main app window
        lC2Compliance   = C2DLL_NOT_SECURE;
        szItemName      = ItemName as read from C2CONFIG.INF file
        szStatusName    = Empty String (all null chars) on first
                            call, previous status on all subsequent
                            calls
    OUTPUTS:
        lActionCode     =  (not used)
        lActionValue    =  (not used)
        hWnd            =  (not changed)
        lC2Compliance   = Current compliance value
        szItemName      =  (not changed)
        szStatusName    = string describing current status of this
                            item
    
ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = C2DLL_UNKNOWN;
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(),IDS_UNABLE_READ));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetOtherItems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

    INPUTS:
        lActionCode     = code describing action to take in order to
                            perform task selected by user. 
                            0 == no change or no action
        lActionValue    = value to be used, if necessary, if the 
                            lActionCode is not 0
        hWnd            =  (not changed)
        lC2Compliance   =  (not changed)
        szItemName      =  (not changed)
        szStatusName    =  (not changed)

    OUTPUTS:
        lActionCode     = set to 0
        lActionValue    = set to 0
        hWnd            =  (not changed)
        lC2Compliance   = set to the current state (as a result of
                            the change)
        szItemName      =  (not changed)
        szStatusName    = set to the current state (as a result of
                            the change)

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    
    if (lParam != 0) {
        // detect action to take based on action code value
        pC2Data = (PC2DLL_DATA)lParam;
        // this function NEVER changes anything
        pC2Data->lC2Compliance = C2DLL_UNKNOWN;
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(),IDS_UNABLE_READ));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    
    return ERROR_SUCCESS;
}

LONG
C2DisplayOtherItems (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.
      
Arguments:

    Pointer to the Dll data block passed as an LPARAM.

    INPUTS:
        lActionCode     = 0
        lActionValue    = 0
        hWnd            = the window handle of the main app. window
        lC2Compliance   = the current compliance value as returned by
                            the last GetStatusFunction call.
        szItemName      = the name string for this item as read from
                            the C2CONFIG.INF file
        szStatusName    = the string describing the current status of
                            this item as returned by the last call to
                            the GetStatusFunction.

    OUTPUTS:
        lActionCode     = code describing action to take in order to
                            perform task selected by user. 
                            0 == no change or no action
        lActionValue    = value to be used, if necessary, if the 
                            lActionCode is not 0
        hWnd            =  (not changed)
        lC2Compliance   =  (not changed)
        szItemName      =  (not changed)
        szStatusName    =  (not changed)

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    TCHAR       szMessage[MAX_PATH];
    INT         nMbResult;
    INT         nMbOptions;
    DWORD       dwNewValue = 0;
    
    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_OTHER_ITEMS),
            pC2Data->hWnd,
            C2OtherItemsDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            // this dialog does not change anything.
            pC2Data->lActionCode = AC_OTHER_NO_ACTION;
        } else {
            // no action
            pC2Data->lActionCode = AC_OTHER_NO_ACTION;
        }
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\networks.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   Networks.c

Abstract:

    functions that detect the presence of network services

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <tchar.h>
#include <cpl.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// define action codes here. They are only meaningful in the
// context of this module.
#define AC_NO_CHANGE    0
#define AC_SHOW_NCPA    1

static WCHAR    wszNetwork[]   = L"Network";

#define SECURE    C2DLL_C2

static
BOOL
NetworkServicesFound (
)
{
    HKEY    hkeySoftware;
    HKEY    hkeyLevel1;
    HKEY    hkeyLevel2;
    HKEY    hkeyNetId;

    DWORD   dwSwIndex;
    DWORD   dwLevel1Index;

    LONG    lStatus;
    LONG    lBufLen;
    LONG    lLevel1BufLen;

    TCHAR   szSoftwareKeyNameBuffer [MAX_PATH];
    TCHAR   szLevel1KeyNameBuffer [MAX_PATH];

    BOOL    bReturn = FALSE;

    // open top key under root to begin search

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_SOFTWARE_KEY),
        0L,
        KEY_READ,
        &hkeySoftware);

    if (lStatus == ERROR_SUCCESS) {
        //
        //  if top key opened, then search each sub-key under it for
        //  network service entries
        //
        dwSwIndex = 0;
        lBufLen = MAX_PATH;
        while (RegEnumKeyEx(hkeySoftware,
                dwSwIndex,
                szSoftwareKeyNameBuffer,
                &lBufLen,
                NULL,
                NULL,
                NULL,
                NULL) == ERROR_SUCCESS) {
            // try to open this key
            lStatus = RegOpenKeyEx (
                hkeySoftware,
                szSoftwareKeyNameBuffer,
                0L,
                KEY_READ,
                &hkeyLevel1);
            if (lStatus == ERROR_SUCCESS) {
                // now enumerate the sub keys to this key and look for
                // network services
                dwLevel1Index = 0;
                lLevel1BufLen = MAX_PATH;
                while (RegEnumKeyEx(hkeyLevel1,
                        dwLevel1Index,
                        szLevel1KeyNameBuffer,
                        &lLevel1BufLen,
                        NULL,
                        NULL,
                        NULL,
                        NULL) == ERROR_SUCCESS) {
                    // try to open this key
                    lStatus = RegOpenKeyEx (
                        hkeyLevel1,
                        szLevel1KeyNameBuffer,
                        0L,
                        KEY_READ,
                        &hkeyLevel2);
                    if (lStatus == ERROR_SUCCESS) {
                        // now enumerate the sub keys to this key and look for
                        // network services
                        // if that worked, then try to open the "Find" key
                        lStatus = RegOpenKeyEx (
                            hkeyLevel2,
                            GetStringResource (GetDllInstance(), IDS_NETWORK_SERVICE_ID_KEY),
                            0L,
                            KEY_READ,
                            &hkeyNetId);
                        if (lStatus == ERROR_SUCCESS){
                            // network service of some kind found
                            bReturn = TRUE;
                            RegCloseKey (hkeyNetId);
                            break;
                        } // end if network service ID key opened
                        RegCloseKey (hkeyLevel2);
                    } // end if Level 2 key opened
                    dwLevel1Index++;
                    lLevel1BufLen = MAX_PATH;
                } // end while enum level1 sub keys (level 2 keys)
                RegCloseKey (hkeyLevel1);
            } // end if Level 1 key opened
            if (bReturn) break;
            dwSwIndex++;
            lBufLen = MAX_PATH;
        } // end while enum Software subkeys (level 1 keys)
        RegCloseKey (hkeySoftware);
        SetLastError (ERROR_SUCCESS);
    } else { // end if software key opened
        SetLastError (lStatus);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

LONG
C2QueryNetworkServices (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    UINT        nMsgId = 0;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (NetworkServicesFound()) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgId = IDS_NETWORK_SERVICE_FOUND;
        } else {
            pC2Data->lC2Compliance = SECURE;
            nMsgId = IDS_NETWORK_SERVICE_NOT_FOUND;
        }
        _stprintf (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgId));
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2SetNetworkServices (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
#define MAX_CPL_DLGS    4
    PC2DLL_DATA pC2Data;
    HINSTANCE   hNcpaDll;
    APPLET_PROC CPlApplet;
    LONG        lNcpaResult;
    LONG        lDlgCount;
    LONG        lDlgId;
    LONG        lNetworksDlgId;
    UINT        nMsgId;
    WNEWCPLINFO  ncpaDlgInfo[MAX_CPL_DLGS];

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (pC2Data->lActionCode == AC_SHOW_NCPA) {
            SET_WAIT_CURSOR;
            // load NCPA DLL
            hNcpaDll = LoadLibrary (
                GetStringResource (GetDllInstance(), IDS_NCPA_DLL));
            if (hNcpaDll != NULL) {
                // look up Control Panel function
                CPlApplet = (APPLET_PROC)GetProcAddressT ((HMODULE)hNcpaDll,
                    GetStringResource (GetDllInstance(), IDS_NCPA_CPL_APPLET));
                if (CPlApplet != NULL) {
                    // init control panel applet
                    if ((*CPlApplet)(pC2Data->hWnd, CPL_INIT, 0, 0) != 0) {
                        lDlgCount = (*CPlApplet)(pC2Data->hWnd, CPL_GETCOUNT, 0, 0);
                        if (lDlgCount > MAX_CPL_DLGS) lDlgCount = MAX_CPL_DLGS; // set limit
                        for (lDlgId = 0; lDlgId < lDlgCount; lDlgId++) {
                            (*CPlApplet)(pC2Data->hWnd, CPL_NEWINQUIRE,
                                lDlgId, (LONG)&ncpaDlgInfo[lDlgId]);
                            if (lstrcmpW (ncpaDlgInfo[lDlgId].szName,
                                wszNetwork) == 0) {
                                lNetworksDlgId = lDlgId;
                            }
                        }
                        // call Network dialog
                        SET_ARROW_CURSOR;
                        lNcpaResult = (*CPlApplet)(pC2Data->hWnd, CPL_DBLCLK,
                            lNetworksDlgId, ncpaDlgInfo[lNetworksDlgId].lData);
                        SET_WAIT_CURSOR;
                        // update networking status

                        if (NetworkServicesFound()) {
                            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                            nMsgId = IDS_NETWORK_SERVICE_FOUND;
                        } else {
                            pC2Data->lC2Compliance = SECURE;
                            nMsgId = IDS_NETWORK_SERVICE_NOT_FOUND;
                        }
                        _stprintf (pC2Data->szStatusName,
                            GetStringResource (GetDllInstance(), nMsgId));

                        // close control panel dialogs and applet
                        for (lDlgId = 1; lDlgId <= lDlgCount; lDlgId++) {
                            (*CPlApplet)(pC2Data->hWnd, CPL_STOP,
                                lDlgId, (LONG)&ncpaDlgInfo[lDlgId-1]);
                        }
                        (*CPlApplet)(pC2Data->hWnd, CPL_EXIT, 0, 0);
                    } else {
                        // Applet could not initialize
                        DisplayDllMessageBox (
                            pC2Data->hWnd,
                            IDS_NETWORK_ERROR_INIT_CPL,
                            IDS_NETWORK_CAPTION,
                            MBOK_EXCLAIM);
                    }
                } else {
                    // unable to find control panel entry point
                    DisplayDllMessageBox (
                        pC2Data->hWnd,
                        IDS_NETWORK_ERROR_FIND_CPL,
                        IDS_NETWORK_CAPTION,
                        MBOK_EXCLAIM);
                }
                // free DLL
                FreeLibrary (hNcpaDll);
            } else {
                // unable to load DLL
                DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_NETWORK_ERROR_LOAD_DLL,
                    IDS_NETWORK_CAPTION,
                    MBOK_EXCLAIM);
            }
            SET_ARROW_CURSOR;
        }
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}

LONG
C2DisplayNetworkServices (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (NetworkServicesFound()) {
            if (DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_NETWORK_SHOW_NCPA,
                IDS_NETWORK_CAPTION,
                MBOKCANCEL_QUESTION) == IDOK){
                pC2Data->lActionCode = AC_SHOW_NCPA;
            } else {
                pC2Data->lActionCode = AC_NO_CHANGE;
            }
        } else {
            DisplayDllMessageBox (
                pC2Data->hWnd,
                IDS_NETWORK_SERVICE_NOT_FOUND,
                IDS_NETWORK_CAPTION,
                MBOK_INFO);
            pC2Data->lActionCode = AC_NO_CHANGE;
        }
        return ERROR_SUCCESS;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\seclog.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    SecLog.C

Abstract:

    functions used to set the Security Log size settings
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants
#define DAYS_NUM_LENGTH 3
#define SECONDS_PER_DAY 86400

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_SECLOG_NOCHANGE  0
#define AC_SECLOG_NEWVALUE  1

#define SECURE C2DLL_C2

static
BOOL
SetSecurityLogWrapSetting (
    DWORD   dwNewValue
)
{
    HKEY    hKeySecLog = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_SECLOG_WRAP_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeySecLog);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so set value
        lStatus = RegSetValueEx (
            hKeySecLog,
            GetStringResource (GetDllInstance(), IDS_SECLOG_WRAP_VALUE),
            0L,
            REG_DWORD,
            (CONST LPBYTE)&dwNewValue,
            sizeof(DWORD));

        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeySecLog);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
DWORD
GetSecurityLogWrapSetting (
)
{
    HKEY    hKeySecLog = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwValue = 0;
    DWORD   dwValueSize = sizeof(DWORD);

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_SECLOG_WRAP_KEY),
        0L,
        KEY_READ,
        &hKeySecLog);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check value
        lStatus = RegQueryValueEx (
            hKeySecLog,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_SECLOG_WRAP_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType == REG_DWORD) {
                // check value. The "C2" value is 0xFFFFFFFF, any
                // other value is NOT C2
                SetLastError (ERROR_SUCCESS);
            } else {
                // wrong data type returned
                dwValue = 0;
                SetLastError (ERROR_CANTREAD);
            }
        } else {
            dwValue = 0;
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeySecLog);
    } else {
        dwValue = 0;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return dwValue;
}

BOOL CALLBACK
C2SecLogDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Security Log dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;
    int     nButton;
    DWORD   dwDays;
    TCHAR   szDays[DAYS_NUM_LENGTH+1];

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;

            // get Security Log Wrap setting
            dwLogSetting = GetSecurityLogWrapSetting();
            if (dwLogSetting == 0xFFFFFFFF) {
                // the log does not wrap, that is the C2 value
                nButton = IDC_DO_NOT_OVERWRITE;
                EnableWindow (GetDlgItem(hDlg, IDC_DAYS), FALSE);
            } else if (dwLogSetting == 0) {
                // the security log will overwrite events as needed
                nButton = IDC_OVERWRITE_AS_NEEDED;
                EnableWindow (GetDlgItem(hDlg, IDC_DAYS), FALSE);
            } else {
                // the security log will overwrite events older than x days
                nButton = IDC_OVERWRITE_OLDER;
                // (log setting is returned in seconds, so they must be converted
                // to integer days.
                dwDays = dwLogSetting / SECONDS_PER_DAY;
                _stprintf (szDays, TEXT("%3d"), dwDays);
                EnableWindow (GetDlgItem(hDlg, IDC_DAYS), TRUE);
                SetDlgItemText (hDlg, IDC_DAYS, szDays);
                SendDlgItemMessage (hDlg, IDC_DAYS, EM_LIMITTEXT,
                    (WPARAM)DAYS_NUM_LENGTH, 0);
            }

            CheckRadioButton (hDlg,
                IDC_OVERWRITE_AS_NEEDED,
                IDC_DO_NOT_OVERWRITE,
                nButton);

            SendDlgItemMessage (hDlg, IDC_DAYS, EM_LIMITTEXT,
                (WPARAM)DAYS_NUM_LENGTH, 0);

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        if (IsDlgButtonChecked (hDlg, IDC_OVERWRITE_AS_NEEDED) == CHECKED) {
                            *lpdwNewValue = 0;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else if (IsDlgButtonChecked (hDlg, IDC_DO_NOT_OVERWRITE) == CHECKED) {
                            *lpdwNewValue = 0xFFFFFFFF;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else if (IsDlgButtonChecked (hDlg, IDC_OVERWRITE_OLDER) == CHECKED) {
                            GetDlgItemText (hDlg, IDC_DAYS, szDays, DAYS_NUM_LENGTH);
                            dwDays = _tcstol (szDays, NULL, 0);
                            if (dwDays == 0) {
                                MessageBeep (MB_ICONEXCLAMATION);
                                DisplayDllMessageBox (
                                    hDlg,
                                    IDS_SECLOG_DAYS_ERROR,
                                    IDS_SECLOG_CAPTION,
                                    MBOK_EXCLAIM);
                                SendDlgItemMessage (hDlg, IDC_DAYS, EM_SETSEL,
                                    (WPARAM)0, (LPARAM)-1);
                                SetFocus (GetDlgItem (hDlg, IDC_DAYS));
                            } else {
                                *lpdwNewValue = dwDays * SECONDS_PER_DAY;
                                EndDialog (hDlg, (int)LOWORD(wParam));
                            }
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckRadioButton (hDlg,
                            IDC_OVERWRITE_AS_NEEDED,
                            IDC_DO_NOT_OVERWRITE,
                            IDC_DO_NOT_OVERWRITE);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_OVERWRITE_AS_NEEDED:
                case IDC_OVERWRITE_OLDER:
                case IDC_DO_NOT_OVERWRITE:
                    CheckRadioButton (hDlg,
                        IDC_OVERWRITE_AS_NEEDED,
                        IDC_DO_NOT_OVERWRITE,
                        LOWORD (wParam));
                    if (LOWORD(wParam) == IDC_OVERWRITE_OLDER) {
                        EnableWindow (GetDlgItem(hDlg, IDC_DAYS), TRUE);
                    } else {
                        EnableWindow (GetDlgItem(hDlg, IDC_DAYS), FALSE);
                    }
                    return TRUE;

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QuerySecLogWrap (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting = 0;
    DWORD        dwDays;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        // check for correct Security Log Wrap setting
        dwLogSetting = GetSecurityLogWrapSetting();
        if (dwLogSetting == 0xFFFFFFFF) {
            // the log does not wrap, that is the C2 value
            pC2Data->lC2Compliance = SECURE;
            lstrcpy (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_SECLOG_IS_C2));
        } else if (dwLogSetting == 0) {
            if (GetLastError() == ERROR_SUCCESS) {
                // the security log will overwrite events as needed
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), IDS_SECLOG_WRAPS_AS_NEEDED));
            } else {
                // an error occured while reading the value
                pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), IDS_UNABLE_READ));
            }
        } else {
            // the security log will overwrite events older than x days
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            // (log setting is returned in seconds, so they must be converted
            // to integer days.
            dwDays = dwLogSetting / SECONDS_PER_DAY;
            _stprintf (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_SECLOG_OVERWRITE_OLD),
                dwDays);
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetSecLogWrap (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting;
    DWORD        dwDays;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action valie = the new value of the wrap setting
        if (pC2Data->lActionCode == AC_SECLOG_NEWVALUE) {
            if (SetSecurityLogWrapSetting((DWORD)pC2Data->lActionValue)) {
                // set new settings
                dwLogSetting = GetSecurityLogWrapSetting();
                if (dwLogSetting == 0xFFFFFFFF) {
                    // the log does not wrap, that is the C2 value
                    pC2Data->lC2Compliance = SECURE;
                    lstrcpy (pC2Data->szStatusName,
                        GetStringResource (GetDllInstance(), IDS_SECLOG_IS_C2));
                } else if (dwLogSetting == 0) {
                    // the security log will overwrite events as needed
                    pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                    lstrcpy (pC2Data->szStatusName,
                        GetStringResource (GetDllInstance(), IDS_SECLOG_WRAPS_AS_NEEDED));
                } else {
                    // the security log will overwrite events older than x days
                    pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                    // (log setting is returned in seconds, so they must be converted
                    // to integer days.
                    dwDays = dwLogSetting / SECONDS_PER_DAY;
                    _stprintf (pC2Data->szStatusName,
                        GetStringResource (GetDllInstance(), IDS_SECLOG_OVERWRITE_OLD),
                        dwDays);
                }
            } else {
                DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_SECLOG_ERROR_NO_SET,
                    IDS_SECLOG_CAPTION,
                    MBOK_EXCLAIM);
            }
        }
        // update action values
        pC2Data->lActionCode = 0;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplaySecLogWrap (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    DWORD       dwNewValue;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_SECLOG_WRAP),
            pC2Data->hWnd,
            C2SecLogDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            pC2Data->lActionValue = (LONG)dwNewValue;
            pC2Data->lActionCode = AC_SECLOG_NEWVALUE;
        } else {
            // no action
            pC2Data->lActionCode = AC_SECLOG_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\shutdown.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    shutdown.C

Abstract:

    functions used to enable/disable the shutdown button in the logon screen
    on the current system.

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// local constants

// define action codes here. They are only meaningful in the
// context of this module.

#define AC_SHUTDOWN_BTN_NOCHANGE    0
#define AC_SHUTDOWN_BTN_UPDATE      1

#define SECURE    C2DLL_SECURE

static
BOOL
SetShutDownButton (
    DWORD   dwNewValue
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bReturn = FALSE;
    UINT    nNewData;
    LPCTSTR szNewString;

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_SET_VALUE,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so set value
        nNewData = (dwNewValue ? IDS_1 : IDS_0);
        szNewString = GetStringResource (GetDllInstance(), nNewData);
        lStatus = RegSetValueEx (
            hKeyWinlogon,
            GetStringResource (GetDllInstance(), IDS_SHUTDOWN_BTN_VALUE),
            0L,
            REG_SZ,
            (CONST LPBYTE)szNewString,
            (lstrlen (szNewString) + 1) * sizeof(TCHAR));

        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

static
BOOL
GetShutDownButton (
)
{
    HKEY    hKeyWinlogon = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    BOOL    bReturn = FALSE;
    TCHAR   szValue[MAX_PATH];
    DWORD   dwValueSize = MAX_PATH * sizeof(TCHAR);

    SET_WAIT_CURSOR;

    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        GetStringResource (GetDllInstance(), IDS_WINLOGON_KEY),
        0L,
        KEY_READ,
        &hKeyWinlogon);

    if (lStatus == ERROR_SUCCESS) {
        // key opened OK so check value
        lStatus = RegQueryValueEx (
            hKeyWinlogon,
            (LPTSTR)GetStringResource (GetDllInstance(), IDS_SHUTDOWN_BTN_VALUE),
            (LPDWORD)NULL,
            &dwType,
            (LPBYTE)szValue,
            &dwValueSize);

        if (lStatus == ERROR_SUCCESS) {
            // value read successfully so check it out
            if (dwType == REG_SZ) {
                // if the button is visible, then this value is 1
                if (lstrcmp(szValue, GetStringResource(GetDllInstance(), IDS_1)) == 0) {
                    bReturn = TRUE;
                } else {
                    bReturn = FALSE;
                }
                SetLastError (ERROR_SUCCESS);
            } else {
                // wrong data type returned
                bReturn = FALSE;
                SetLastError (ERROR_CANTREAD);
            }
        } else {
            // no value present
            bReturn = FALSE;
            SetLastError (ERROR_CANTREAD);
        }
        RegCloseKey (hKeyWinlogon);
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_BADKEY);
    }

    SET_ARROW_CURSOR;

    return bReturn;
}

BOOL CALLBACK
C2ShutDownButtonDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Last User Display dialog box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  LPDWORD   lpdwNewValue;
    DWORD   dwLogSetting = 0;

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            lpdwNewValue = (LPDWORD)lParam;

            // get Shutdown button state for check box
            CheckDlgButton (hDlg, IDC_HIDE_SHUTDOWN_BUTTON,
                (GetShutDownButton() ? UNCHECKED : CHECKED));

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        if (IsDlgButtonChecked (hDlg, IDC_HIDE_SHUTDOWN_BUTTON) == CHECKED) {
                            *lpdwNewValue = FALSE; // hide the button
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else {
                            *lpdwNewValue = TRUE; // show the button
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        *lpdwNewValue = 0;
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        CheckDlgButton (hDlg, IDC_HIDE_SHUTDOWN_BUTTON, CHECKED);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryShutDownButton (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out if the OS/2 subsystem is installed
        on the system. For C2 compliance, OS/2 must not be
        allowed on the system.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    DWORD        dwLogSetting = 0;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        pC2Data->lC2Compliance = SECURE;   // assume true for now
        if (!GetShutDownButton()) {
            // shutdown button is not displayed on the logon dialog
            pC2Data->lC2Compliance = SECURE;
            nMsgString = IDS_SHUTDOWN_BTN_HIDDEN;
        } else {
            // shutdown button is displayed on the logon dialog
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            nMsgString = IDS_SHUTDOWN_BTN_DISPLAYED;
        }
        lstrcpy (pC2Data->szStatusName,
            GetStringResource (GetDllInstance(), nMsgString));
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2SetShutDownButton (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA  pC2Data;
    UINT         nMsgString;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        // action valie = the new value of the wrap setting
        if (pC2Data->lActionCode != AC_SHUTDOWN_BTN_NOCHANGE) {
            nMsgString = 0;
            if (pC2Data->lActionCode == AC_SHUTDOWN_BTN_UPDATE) {
                if (pC2Data->lActionValue) {
                    if (SetShutDownButton (TRUE)) {
                        pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                        nMsgString = IDS_SHUTDOWN_BTN_DISPLAYED;
                    } else {
                        DisplayDllMessageBox (
                            pC2Data->hWnd,
                            IDS_SHUTDOWN_ERROR_NOT_SET,
                            IDS_SHUTDOWN_CAPTION,
                            MBOK_EXCLAIM);
                    }
                } else {
                    if (SetShutDownButton (FALSE)) {
                        pC2Data->lC2Compliance = SECURE;
                        nMsgString = IDS_SHUTDOWN_BTN_HIDDEN;
                    } else {
                        DisplayDllMessageBox (
                            pC2Data->hWnd,
                            IDS_SHUTDOWN_ERROR_NOT_SET,
                            IDS_SHUTDOWN_CAPTION,
                            MBOK_EXCLAIM);
                    }
                }
            }
            if (nMsgString != 0) {
                // update status string if set was successful
                lstrcpy (pC2Data->szStatusName,
                    GetStringResource (GetDllInstance(), nMsgString));
            }
        }
        // update action values
        pC2Data->lActionCode = 0;
        pC2Data->lActionValue = 0;
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayShutDownButton (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    DWORD       dwNewValue;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_SHUTDOWN_BUTTON),
            pC2Data->hWnd,
            C2ShutDownButtonDlgProc,
            (LPARAM)&dwNewValue) == IDOK) {
            pC2Data->lActionValue = dwNewValue;
            pC2Data->lActionCode = AC_SHUTDOWN_BTN_UPDATE;
        } else {
            // no action
            pC2Data->lActionCode = AC_SHUTDOWN_BTN_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}









=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\c2funcs\password.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    password.c

Abstract:

    functions to display & set the password policy for this workstation

Author:

    Bob Watson (a-robw)

Revision History:

    23 Dec 94

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <c2dll.h>
#include <c2inc.h>
#include <c2utils.h>
#include "c2funcs.h"
#include "c2funres.h"

// define action codes here. They are only meaningful in the
// context of this module.
#define AC_PW_LENGTH_NOCHANGE    0
#define AC_PW_LENGTH_UPDATE      1

#define SECURE C2DLL_C2

static
LONG
GetWorkstationMinPasswordLength (
)
{
    SAM_HANDLE  hsamObject;
    SAM_HANDLE  hsamDomain;
    PSID        psidDomain;

    SAM_ENUMERATE_HANDLE hSamEnum;
    PSAM_RID_ENUMERATION pRidEnum;

    PVOID   pvEnumBuffer;
    ULONG   ulEnumCount;

    LONG    lRetPwLen = -1; // init to error value

    NTSTATUS    ntstat;
    PDOMAIN_PASSWORD_INFORMATION pdpiData;

    SET_WAIT_CURSOR;
    // connect to SAM on this machine
    ntstat = SamConnect((PUNICODE_STRING)NULL, &hsamObject,
       SAM_SERVER_ALL_ACCESS, (POBJECT_ATTRIBUTES)NULL);
    if (ntstat == STATUS_SUCCESS) {
        // Ask SAM for the domains on this server.

        hSamEnum = 0;
        ntstat = SamEnumerateDomainsInSamServer(
            hsamObject,
            &hSamEnum,
            &pvEnumBuffer,
            1024,
            &ulEnumCount);

        if ((ntstat == STATUS_SUCCESS) || (ntstat == STATUS_MORE_ENTRIES)) {
            // look up only the first entry
            pRidEnum = (PSAM_RID_ENUMERATION) pvEnumBuffer;

            // get SID of domain 
            ntstat = SamLookupDomainInSamServer (
                hsamObject,
                &pRidEnum->Name,
                &psidDomain);

            if (ntstat == STATUS_SUCCESS) {
                // open handle to this domain
                ntstat = SamOpenDomain (
                    hsamObject,
                    DOMAIN_EXECUTE,
                    psidDomain,
                    &hsamDomain);

                if (ntstat == STATUS_SUCCESS) {
                    // get password policy for this domain
                    pdpiData = NULL;
                    ntstat = SamQueryInformationDomain (
                        hsamDomain,
                        DomainPasswordInformation,
                        (PVOID *)&pdpiData);

                    if (ntstat == STATUS_SUCCESS) {
                        // evaluate password length here
                        lRetPwLen = (LONG)pdpiData->MinPasswordLength;
                        ntstat = SamFreeMemory (pdpiData);
                    }
                    // close handle
                    SamCloseHandle (hsamDomain);
                }
            }
            SamFreeMemory(pvEnumBuffer);
        }
        SamCloseHandle (hsamObject);
    } else {
        lRetPwLen = -1;
    }
    SetLastError (RtlNtStatusToDosError(ntstat));
    SET_ARROW_CURSOR;
    return lRetPwLen;
}

static
BOOL
SetWorkstationMinPasswordLength (
    LONG    lMinLength
)
{
    SAM_HANDLE  hsamObject;
    SAM_HANDLE  hsamDomain;
    PSID        psidDomain;

    SAM_ENUMERATE_HANDLE hSamEnum;
    PSAM_RID_ENUMERATION pRidEnum;
                                                              
    PVOID   pvEnumBuffer;
    ULONG   ulEnumCount;
    BOOL    bReturn = FALSE; // assume error until everything works

    NTSTATUS    ntstat;
    PDOMAIN_PASSWORD_INFORMATION pdpiData;

    SET_WAIT_CURSOR;

    // connect to SAM on this machine
    if (EnableSecurityPriv()) {
        ntstat = SamConnect((PUNICODE_STRING)NULL, &hsamObject,
        STANDARD_RIGHTS_WRITE | SAM_SERVER_ALL_ACCESS,
        (POBJECT_ATTRIBUTES)NULL);
        if (ntstat == STATUS_SUCCESS) {
            // Ask SAM for the domains on this server.

            hSamEnum = 0;
            ntstat = SamEnumerateDomainsInSamServer(
                hsamObject,
                &hSamEnum,
                &pvEnumBuffer,
                1024,
                &ulEnumCount);

            if ((ntstat == STATUS_SUCCESS) || (ntstat == STATUS_MORE_ENTRIES)) {
                // look up only the first entry
                pRidEnum = (PSAM_RID_ENUMERATION) pvEnumBuffer;

                // get SID of domain 
                ntstat = SamLookupDomainInSamServer (
                    hsamObject,
                    &pRidEnum->Name,
                    &psidDomain);

                if (ntstat == STATUS_SUCCESS) {
                    // open handle to this domain
                    ntstat = SamOpenDomain (
                        hsamObject,
                        STANDARD_RIGHTS_WRITE               |
                           DOMAIN_READ_PASSWORD_PARAMETERS  |
                           DOMAIN_LIST_ACCOUNTS             |
                           DOMAIN_LOOKUP                    |
                           DOMAIN_WRITE_PASSWORD_PARAMS,
                        psidDomain,
                        &hsamDomain);

                    if (ntstat == STATUS_SUCCESS) {
                        // get password policy for this domain
                        pdpiData = NULL;
                        ntstat = SamQueryInformationDomain (
                            hsamDomain,
                            DomainPasswordInformation,
                            (PVOID *)&pdpiData);

                        if (ntstat == STATUS_SUCCESS) {
                            // evaluate password length here
                            lMinLength &= 0x000000FF;   // make it reallly short
                            pdpiData->MinPasswordLength = (USHORT)lMinLength;
            
                            ntstat =  SamSetInformationDomain (
                                hsamDomain,
                                DomainPasswordInformation,
                                (PVOID)pdpiData);
                        
                            if (ntstat == STATUS_SUCCESS) {
                                bReturn = TRUE;
                            }

                            ntstat = SamFreeMemory (pdpiData);
                        }
                        // close handle
                        SamCloseHandle (hsamDomain);
                    }
                }
                SamFreeMemory(pvEnumBuffer);
            }
            SamCloseHandle (hsamObject);
        }
        SetLastError (RtlNtStatusToDosError(ntstat));
    }

    SET_ARROW_CURSOR;
    
    return bReturn;
}

BOOL CALLBACK
C2PasswordLengthDlgProc(
    IN  HWND hDlg,           // window handle of the dialog box
	IN  UINT message,        // type of message
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Window procedure for Password Length Dialog Box

Arguments:

    Standard DlgProc arguments

ReturnValue:

    TRUE    the message was handled by this routine
    FALSE   DefDialogProc should handle the message

--*/
{
    static  PLONG   plNewLength;   // save address of caller's data block
    DWORD   dwLogSetting = 0;
    int     nButton;
    int     nState;
    LONG    lPasswordLength;
    TCHAR   szPasswordLength[4];

    switch (message) {
        case WM_INITDIALOG:
            // save the pointer to the new value
            plNewLength = (PLONG)lParam;

            // set the correct radio button
            lPasswordLength = GetWorkstationMinPasswordLength();

            if (lPasswordLength > 0) {
                nButton = IDC_MIN_PASSWORD_LENGTH;
                EnableWindow (GetDlgItem(hDlg, IDC_PASSWORD_LENGTH_EDIT), TRUE);
                _stprintf (szPasswordLength, TEXT("%2d"), lPasswordLength);
                SetDlgItemText (hDlg, IDC_PASSWORD_LENGTH_EDIT, szPasswordLength);
            } else {
                nButton = IDC_ALLOW_BLANK_PASSWORD;
                EnableWindow (GetDlgItem(hDlg, IDC_PASSWORD_LENGTH_EDIT), FALSE);
            }

            CheckRadioButton (hDlg,
                IDC_ALLOW_BLANK_PASSWORD,
                IDC_MIN_PASSWORD_LENGTH,
                nButton);

            // set text limits on edit boxes
            SendDlgItemMessage (hDlg, IDC_PASSWORD_LENGTH_EDIT, EM_LIMITTEXT,
                (WPARAM)2, 0);

            SetFocus (GetDlgItem (hDlg, IDOK)); // set focus to OK Button
            return FALSE; // we don't want Windows to set the focus

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDOK:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        if (IsDlgButtonChecked (hDlg, IDC_ALLOW_BLANK_PASSWORD) == CHECKED) {
                            *plNewLength = 0;
                            EndDialog (hDlg, (int)LOWORD(wParam));
                        } else {
                            GetDlgItemText (hDlg, IDC_PASSWORD_LENGTH_EDIT,
                                szPasswordLength, 4);
                            lPasswordLength = _tcstol(szPasswordLength, NULL, 10);

                            // make sure it's a valid length

                            if ((lPasswordLength > 0) && (lPasswordLength <= 14)) {
                                *plNewLength = lPasswordLength;
                                // then there's text so exit
                                EndDialog (hDlg, (int)LOWORD(wParam));
                            } else {
                                // an incorrect entry is in the edit box so display message
                                MessageBeep (MB_ICONASTERISK);
                                DisplayDllMessageBox (hDlg,
                                    IDS_PASSWORD_INVALID_LEN,
                                    IDS_PASSWORD_CAPTION,
                                    MBOK_INFO);
                                SetFocus (GetDlgItem (hDlg, IDC_PASSWORD_LENGTH_EDIT));
                            }
                        }
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDCANCEL:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        // exit and return button that caused exit
                        EndDialog (hDlg, (int)LOWORD(wParam));
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_C2:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        nState = ENABLED;
                        CheckRadioButton (hDlg,
                            IDC_ALLOW_BLANK_PASSWORD,
                            IDC_MIN_PASSWORD_LENGTH,
                            IDC_MIN_PASSWORD_LENGTH);
                        
                        // en/disable edit windows
                        EnableWindow (GetDlgItem(hDlg,
                            IDC_PASSWORD_LENGTH_EDIT), TRUE);

                        // if there is no text in both of the edit fields 
                        // then  display information message
                        
                        lPasswordLength = SendDlgItemMessage (hDlg, IDC_PASSWORD_LENGTH_EDIT,
                            WM_GETTEXTLENGTH, 0, 0);
                        if (lPasswordLength == 0) {
                            // no value so use 6 for starters
                            SetDlgItemText (hDlg, IDC_PASSWORD_LENGTH_EDIT,
                                TEXT("6")); 
                            SetFocus (GetDlgItem (hDlg, IDC_PASSWORD_LENGTH_EDIT));
                        }

                        return TRUE;
                    } else {
                        return FALSE;
                    }

                case IDC_ALLOW_BLANK_PASSWORD:
                case IDC_MIN_PASSWORD_LENGTH:
                    // check correct button
                    CheckRadioButton (hDlg,
                        IDC_ALLOW_BLANK_PASSWORD,
                        IDC_MIN_PASSWORD_LENGTH,
                        LOWORD(wParam));
                    // enable or disable the edit window
                    if (LOWORD(wParam) == IDC_MIN_PASSWORD_LENGTH) {
                        nState = ENABLED;
                    } else {
                        nState = DISABLED;
                    }

                    EnableWindow (GetDlgItem(hDlg,
                          IDC_PASSWORD_LENGTH_EDIT), nState);

                    return TRUE;

                case IDC_HELP:
                    PostMessage (GetParent(hDlg), UM_SHOW_CONTEXT_HELP, 0, 0);
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
	        return (FALSE); // Didn't process the message
    }
}

LONG
C2QueryPasswordLength (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to find out the current state of this configuration
        item. This function reads the current state of the item and
        sets the C2 Compliance flag and the Status string to reflect
        the current value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    LONG        lPasswordLength;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        lPasswordLength = GetWorkstationMinPasswordLength();
        if (lPasswordLength > 0) {
            pC2Data->lC2Compliance = SECURE;
            _stprintf (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_PASSWORD_NOT_BLANK),
                lPasswordLength);
        } else if (lPasswordLength == 0) {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            _stprintf (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_PASSWORD_CAN_BE_BLANK));
        } else {
            pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
            _stprintf (pC2Data->szStatusName,
                GetStringResource (GetDllInstance(), IDS_UNABLE_READ));
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }
    return ERROR_SUCCESS;
}

LONG
C2SetPasswordLength (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to change the current state of this configuration
        item based on an action code passed in the DLL data block. If
        this function successfully sets the state of the configuration
        item, then the C2 Compliance flag and the Status string to reflect
        the new value of the configuration item.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    LONG        lPasswordLength = 0;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (pC2Data->lActionCode == AC_PW_LENGTH_UPDATE) {
            if (SetWorkstationMinPasswordLength (pC2Data->lActionValue)) {
                lPasswordLength = pC2Data->lActionValue;
                if (lPasswordLength > 0) {
                    pC2Data->lC2Compliance = SECURE;
                    _stprintf (pC2Data->szStatusName,
                        GetStringResource (GetDllInstance(), IDS_PASSWORD_NOT_BLANK),
                        lPasswordLength);
                } else {
                    pC2Data->lC2Compliance = C2DLL_NOT_SECURE;
                    _stprintf (pC2Data->szStatusName,
                        GetStringResource (GetDllInstance(), IDS_PASSWORD_CAN_BE_BLANK));
                }
            } else {
                DisplayDllMessageBox (
                    pC2Data->hWnd,
                    IDS_PASSWORD_ERROR_NO_SET,
                    IDS_PASSWORD_CAPTION,
                    MBOK_EXCLAIM);
            }
            pC2Data->lActionCode = 0;
            pC2Data->lActionValue = 0;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}

LONG
C2DisplayPasswordLength (
    IN  LPARAM   lParam
)
/*++

Routine Description:

    Function called to display more information on the configuration
        item and provide the user with the option to change the current
        setting  (if appropriate). If the User "OK's" out of the UI,
        then the action code field in the DLL data block is set to the
        appropriate (and configuration item-specific) action code so the
        "Set" function can be called to perform the desired action. If
        the user Cancels out of the UI, then the Action code field is
        set to 0 (no action) and no action is performed.

Arguments:

    Pointer to the Dll data block passed as an LPARAM.

ReturnValue:

    ERROR_SUCCESS if the function succeeds otherwise a
    WIN32 error is returned if an error occurs

--*/
{
    PC2DLL_DATA pC2Data;
    LONG        lNewValue = 0;

    if (lParam != 0) {
        pC2Data = (PC2DLL_DATA)lParam;
        if (DialogBoxParam (
            GetDllInstance(),
            MAKEINTRESOURCE (IDD_PASSWORD_LENGTH),
            pC2Data->hWnd,
            C2PasswordLengthDlgProc,
            (LPARAM)&lNewValue) == IDOK) {
            pC2Data->lActionValue = lNewValue;
            pC2Data->lActionCode = AC_PW_LENGTH_UPDATE;
        } else {
            // no action
            pC2Data->lActionCode = AC_PW_LENGTH_NOCHANGE;
        }
    } else {
        return ERROR_BAD_ARGUMENTS;
    }

    return ERROR_SUCCESS;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\inc\c2dll.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    C2DLL.H

Abstract:
    
    definitions used by C2 Configuration & Query DLL's

Author:

    Bob Watson (a-robw)

Revision History:

    12 Dec 94

--*/
#ifndef _C2DLL_H_
#define _C2DLL_H_

// Data structures used by dll

typedef LONG (C2DLL_FUNC) (LPARAM);
typedef LONG (* PC2DLL_FUNC) (LPARAM);

#define  MAX_ITEMNAME_LEN     64
#define  MAX_STATUSTEXT_LEN   64

typedef  struct   _C2DLL_DATA {
   LONG  lActionCode;       // DLL specific id of action function is to perform
   LONG  lActionValue;      // DLL specific value to use with action code
   HWND  hWnd;              // owning window handle (for instance & dlg info)
   LONG  lC2Compliance;     // See Compliance values below
   TCHAR szItemName[MAX_ITEMNAME_LEN + 1];      // name of security item
   TCHAR szStatusName[MAX_STATUSTEXT_LEN + 1];  // status string of item
   TCHAR szHelpFileName[MAX_PATH];      // name of help file containing help topic
   ULONG ulHelpContext;     // help context ID for this item
} C2DLL_DATA, *PC2DLL_DATA;

// lC2Compliance values
#define C2DLL_UNKNOWN            0
#define C2DLL_C2                 1
#define C2DLL_SECURE             2
#define C2DLL_NOT_SECURE         3

#define UM_SHOW_CONTEXT_HELP    (WM_USER+222)

#endif // _C2DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\common\strings.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    strings.c

Abstract:

    String Constant definitions & initializations

Author:

    Bob Watson (a-robw)

Revision History:

    24 Aug 1994    Written

--*/
#include <windows.h>
// string definitions
//
//

//
// character strings
//
LPCTSTR cszBackslash = TEXT("\\");
LPCTSTR cszDoubleQuote = TEXT("\"");
LPCTSTR cmszEmptyString = TEXT ("\0\0");
LPCTSTR cszEmptyString = TEXT ("\0");
LPCTSTR cszSpace = TEXT(" ");
LPCTSTR cszKeySeparator = TEXT(" = ");

LPCTSTR cszDot = TEXT(".");
LPCTSTR cszDotDot = TEXT("..");
LPCTSTR cszStarDotStar = TEXT("*.*");

LPCTSTR cszLocalMachine = TEXT("HKEY_LOCAL_MACHINE");
LPCTSTR cszClassesRoot = TEXT("HKEY_CLASSES_ROOT");
LPCTSTR cszCurrentUser = TEXT("HKEY_CURRENT_USER");
LPCTSTR cszUsers = TEXT("HKEY_USERS");
LPCTSTR cszInherit = TEXT("INHERIT");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\inc\c2inc.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    C2Inc.H

Abstract:


Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _C2INC_H_
#define _C2INC_H_

#include    <tchar.h>

//  WIN32 Constant Definitions
//
#define BEEP_EXCLAMATION    MB_ICONEXCLAMATION
#define OF_SEARCH           0

#define MAX_PATH_BYTES      (MAX_PATH * sizeof(TCHAR))

#define SMALL_BUFFER_SIZE   1023
#define SMALL_BUFFER_BYTES  ((SMALL_BUFFER_SIZE + 1) * sizeof (TCHAR))

#define MEDIUM_BUFFER_SIZE  4095
#define MEDIUM_BUFFER_BYTES ((MEDIUM_BUFFER_SIZE + 1) * sizeof (TCHAR))

#define LARGE_BUFFER_SIZE   65535
#define LARGE_BUFFER_BYTES  ((LARGE_BUFFER_SIZE + 1) * sizeof (TCHAR))

// define dialog box button states
#define     ENABLED         TRUE
#define     DISABLED        FALSE

#define     CHECKED         1
#define     UNCHECKED       0    

// define Mailbox buttons
#define MBOK_EXCLAIM            (MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOK_INFO               (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_EXCLAIM      (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOKCANCEL_INFO         (MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_QUESTION     (MB_OKCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNO_QUESTION        (MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_QUESTION  (MB_YESNOCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_EXCLAIM   (MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)

// other constants
#define MAX_USERNAME            15
#define MAX_DOMAINNAME          15
#define MAX_ORGNAME             255
#define MAX_PRODUCT_NAME_LENGTH 32

//
//  WIN32 Version of common macros
//
#define GLOBAL_ALLOC(s)		GlobalAlloc(GPTR,s)
#define GLOBAL_FREE_IF_ALLOC(p)	(p != NULL ? GlobalFree(p) : 0)

#define GET_CONTROL_ID(w)   (LOWORD(w))
#define GET_NOTIFY_MSG(w,l) (HIWORD(w))
#define GET_COMMAND_WND(l)  ((HWND)(l))
#define GET_INSTANCE(h)     ((HINSTANCE)GetWindowLong(h, GWL_HINSTANCE))
#define SAVE_HWND(w,o,v)    SetWindowLong (w,o,(LONG)v)
#define GET_HWND(w,o)       (HWND)GetWindowLong (w,o)
#define SET_HWND(w,o,v)     SetWindowLong (w,o, (DWORD)v)
#define SET_INFO(w,o,p)     (LPVOID)SetWindowLong (w,o,(LONG)p)
#define GET_INFO(w,o)       (LPVOID)GetWindowLong (w,o)
#define SEND_WM_COMMAND(w,c,n,cw)  SendMessage (w, WM_COMMAND, MAKEWPARAM(c,n), (LPARAM)cw)
#define POST_WM_COMMAND(w,c,n,cw)  PostMessage (w, WM_COMMAND, MAKEWPARAM(c,n), (LPARAM)cw)
#define GetMyLastError		GetLastError	
#define CLEAR_FIRST_FOUR_BYTES(x)   *(DWORD *)(x) = 0L
#define SET_WAIT_CURSOR     (SetCursor(LoadCursor(NULL, IDC_WAIT)))
#define SET_ARROW_CURSOR    (SetCursor(LoadCursor(NULL, IDC_ARROW)))

#endif  // _C2INC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\common\c2utils.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Utils.C

Abstract:

    a collection of utility functions used by other routines.

Author:

    Bob Watson (a-robw)

Revision History:

    24 Aug 1994    Written

--*/
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <sys\stat.h>
#include "c2inc.h"
#include "c2utils.h"
#include "strings.h"

#define NUM_BUFS    4

//
//  local "helper" functions
//

static
BOOL
MediaPresent (
    IN  LPCTSTR szPath,
    IN  BOOL    bPresentAndValid
)
/*++

Routine Description:

    determines if the specified path is present and available

Arguments:

    IN  LPCTSTR szPath
        path to examine (Must be a DOS path)

Return Value:

    TRUE:   path is available
    FALSE:  unable to find/open path

--*/
{
    BOOL    bMediaPresent = FALSE;
    TCHAR   szDev[8];
    DWORD   dwBytes = 0;
    DWORD   dwAttrib;
    DWORD   dwLastError = ERROR_SUCCESS;
    UINT    nErrorMode;

    if (!IsUncPath(szPath)) {
        // build device name string
        szDev[0] = szPath[0];
        szDev[1] = cColon;
        szDev[2] = cBackslash;
        szDev[3] = 0;

        // disable windows error message popup
        nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

        dwAttrib = QuietGetFileAttributes (szDev);
        if ((dwAttrib != 0xFFFFFFFF) && ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {
            // if the root dir is a dir, then it must be present and formatted
    	    bMediaPresent = TRUE;
        } else {
            // otherwise see if it's present and not formatted or not present
            dwLastError = GetMyLastError();
            if (dwLastError == ERROR_NOT_READY) {
                // then no disk in drive
        	    bMediaPresent = FALSE;
            } else if ((dwLastError == ERROR_FILE_NOT_FOUND) ||
                (dwLastError == ERROR_UNRECOGNIZED_MEDIA)) {
                // then and UNFORMATTED disk is in drive
                if (bPresentAndValid) {
                    // this isn't good enough if it's supposed to be formatted
                    bMediaPresent = FALSE;
                } else {
                    // we're just looking for a disk so this is OK
                    bMediaPresent = TRUE;
                }
            }
        }

        SetErrorMode (nErrorMode);  // restore old error mode
    } else {
        // assume UNC path devices are present
        bMediaPresent = TRUE;
    }
    return bMediaPresent;
}

//
//  Global functions
//
DWORD
QuietGetFileAttributes (
    IN  LPCTSTR lpszFileName
)
/*++

Routine Description:

    Reads the attributes of the path in lpzsFileName without triggering
        any Windows error dialog if there's an OS error (e.g. drive not
        ready)

Arguments:

    IN  LPCTSTR lpszFileName
        path to retrieve attributes from

Return Value:

    file attributes DWORD returned from GetFileAttributes or
        0xFFFFFFFF if unable to open path.

--*/
{
    DWORD   dwReturn;
    UINT    nErrorMode;
    unsigned    uAttrib;    // used in WIN 16 builds only

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
#ifdef  WIN32
    dwReturn = GetFileAttributes (lpszFileName);
    uAttrib = 0;  // to prevent unused var error in WIN32 build
#else // WIN16

    if (_dos_getfileattr (lpszFileName, &uAttrib) == 0) {
        dwReturn = uAttrib;
    } else {
        dwReturn = 0xFFFFFFFF;
        SetLastError (ERROR_FILE_NOT_FOUND);
    }
#endif
    SetErrorMode (nErrorMode);  // restore old error mode
    return dwReturn;
}

BOOL
EnableSecurityPriv (
)
{
    HANDLE hToken;
    LUID SeSecurityNameValue;
    TOKEN_PRIVILEGES tkp;

    /* Retrieve a handle of the access token. */

    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
        return FALSE;
    }

    /*
     * Enable the SE_SECURITY_NAME privilege
     */

    if (!LookupPrivilegeValue((LPCTSTR) NULL,
            SE_SECURITY_NAME,
            &SeSecurityNameValue)) {
        return FALSE;
    }
        
    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = SeSecurityNameValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES) NULL,
        (PDWORD) NULL);

    if (GetLastError() != ERROR_SUCCESS) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
EnableAllPriv (
)
/*++


Routine Description:

    This routine enables all privileges in the token.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE Token;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState;
    BOOL Result;

    Token = NULL;
    NewState = NULL;

    Result = OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                            &Token
                            );
    if (Result) {
        ReturnLength = 4096;
        NewState = malloc( ReturnLength );
        Result = (BOOL)(NewState != NULL);
        if (Result) {
            Result = GetTokenInformation( Token,            // TokenHandle
                                        TokenPrivileges,  // TokenInformationClass
                                        NewState,         // TokenInformation
                                        ReturnLength,     // TokenInformationLength
                                        &ReturnLength     // ReturnLength
                                        );

            if (Result) {
                //
                // Set the state settings so that all privileges are enabled...
                //

                if (NewState->PrivilegeCount > 0) {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++ ) {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,          // TokenHandle
                                                FALSE,          // DisableAllPrivileges
                                                NewState,       // NewState (OPTIONAL)
                                                ReturnLength,   // BufferLength
                                                NULL,           // PreviousState (OPTIONAL)
                                                &ReturnLength   // ReturnLength
                                            );
            }
        } 
    }

    if (NewState != NULL) {
        free( NewState );
    }

    if (Token != NULL) {
        CloseHandle( Token );
    }

    return( Result );
}

#ifdef _UNICODE
FARPROC
GetProcAddressW (
    IN  HMODULE hModule,
    IN  LPCWSTR lpwszProc
)
{
    LPSTR   szProc;
    LONG    lProcLen;
    LONG    lAnsiLen;
    FARPROC lpReturn;

    lProcLen = lstrlen(lpwszProc);
    szProc = GLOBAL_ALLOC (lProcLen + 1);

    if (szProc != NULL) {
        lAnsiLen = wcstombs (szProc, lpwszProc, lProcLen);
        if (lAnsiLen == lProcLen) {
            lpReturn = GetProcAddress (
                hModule,
                szProc);
        } else {
            lpReturn = NULL;
        }
        // free allocated string buffer
        GLOBAL_FREE_IF_ALLOC (szProc);
    } else {
        lpReturn = NULL;
    }
    return lpReturn;
}
#endif

#ifdef _UNICODE
HFILE
OpenFileW(
    LPCTSTR     lpwszFile,
    LPWOFSTRUCT lpWOpenBuff,
    UINT        fuMode
)
{
    LPSTR       szFileName;
    OFSTRUCT    ofStruct;
    HFILE       hReturn;
    LONG        lFileNameLen;
    LONG        lAnsiNameLen;
    
    // check arguments
    if ((lpwszFile == NULL) || (lpWOpenBuff == NULL)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        hReturn = HFILE_ERROR;
    } else {
        lFileNameLen = lstrlen(lpwszFile);
        szFileName = GLOBAL_ALLOC (lFileNameLen + 1);
        if (szFileName != NULL) {
            lAnsiNameLen = wcstombs (szFileName, lpwszFile, lFileNameLen);
            if (lAnsiNameLen == lFileNameLen) {
                hReturn = OpenFile (
                    szFileName,
                    &ofStruct,
                    fuMode);

                if (hReturn != HFILE_ERROR){
                    lpWOpenBuff->cBytes = ofStruct.cBytes;
                    lpWOpenBuff->fFixedDisk = ofStruct.fFixedDisk;
                    lpWOpenBuff->nErrCode = ofStruct.nErrCode;
                    lpWOpenBuff->Reserved1 = ofStruct.Reserved1;
                    lpWOpenBuff->Reserved2 = ofStruct.Reserved2;
                    lAnsiNameLen = strlen (ofStruct.szPathName);
                    mbstowcs (lpWOpenBuff->szPathName,
                        ofStruct.szPathName, lAnsiNameLen);
                }
            }
            GLOBAL_FREE_IF_ALLOC (szFileName);
        } else {
            SetLastError (ERROR_OUTOFMEMORY);
            hReturn = HFILE_ERROR;
        }
    }
    return hReturn;
}
#endif

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
)
/*++

Routine Description:

    Trims leading and trailing spaces from szString argument, modifying
        the buffer passed in

Arguments:

    IN  OUT LPTSTR  szString
        buffer to process

Return Value:

    TRUE if string was modified
    FALSE if not

--*/
{
    LPTSTR  szSource;
    LPTSTR  szDest;
    LPTSTR  szLast;
    BOOL    bChars;

    szLast = szSource = szDest = szString;
    bChars = FALSE;

    while (*szSource != 0) {
        // skip leading non-space chars
        if (*szSource > cSpace) {
            szLast = szDest;
            bChars = TRUE;
        }
        if (bChars) {
            // remember last non-space character
            // copy source to destination & increment both
            *szDest++ = *szSource++;
        } else {
            szSource++;
        }
    }

    if (bChars) {
        *++szLast = 0; // terminate after last non-space char
    } else {
        // string was all spaces so return an empty (0-len) string
        *szString = 0;
    }

    return (szLast != szSource);
}

BOOL
IsUncPath (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    examines path as a string looking for "tell-tale" double
        backslash indicating the machine name syntax of a UNC path

Arguments:

    IN  LPCTSTR szPath
        path to examine

Return Value:

    TRUE if \\ found at start of string
    FALSE if not

--*/
{
    LPTSTR  szPtChar;

    szPtChar = (LPTSTR)szPath;
    if (*szPtChar == cBackslash) {
        if (*++szPtChar == cBackslash) {
            return TRUE;
        }
    }
    return FALSE;
}

LPTSTR
GetFileNameFromPath (
    IN  LPCTSTR szPath
)
{
    LPTSTR  szLastBs;
    LPTSTR  szThisChar;

    szLastBs = (LPTSTR)szPath;

    for (szThisChar = (LPTSTR)szPath;  *szThisChar != 0; szThisChar++) {
        if (*szThisChar == cBackslash) {
            szLastBs = szThisChar;
        }
    }
    if (*szLastBs == cBackslash) {
        szLastBs++;
    }
    return szLastBs;
}

BOOL
CenterWindow (
   HWND hwndChild,
   HWND hwndParent
)
/*++

Routine Description:

    Centers the child window in the Parent window

Arguments:

   HWND hwndChild,
        handle of child window to center

   HWND hwndParent
        handle of parent window to center child window in

ReturnValue:

    Return value of SetWindowPos

--*/
{
	RECT    rChild, rParent;
	LONG    wChild, hChild, wParent, hParent;
	LONG    wScreen, hScreen, xNew, yNew;
	HDC     hdc;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the display limits
	hdc = GetDC (hwndChild);
	wScreen = GetDeviceCaps (hdc, HORZRES);
	hScreen = GetDeviceCaps (hdc, VERTRES);
	ReleaseDC (hwndChild, hdc);

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < 0) {
		xNew = 0;
	} else if ((xNew+wChild) > wScreen) {
		xNew = wScreen - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < 0) {
		yNew = 0;
	} else if ((yNew+hChild) > hScreen) {
		yNew = hScreen - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL,
		(int)xNew, (int)yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

UINT
GetDriveTypeFromDosPath (
    IN  LPCTSTR  szDosPath
)
/*++

Routine Description:

    Strips the filename and path from the path in the argument and returns
        the drive type as returned by the GetDriveType Win32 API fn.

Arguments:

    IN  LPCTSTR  szDosPath
        dos path in the format: <Drive>:\path... This format is NOT checked
        by the function!

Return Value:

    DRIVE TYPE value returned by the GetDriveType API.

--*/
{
#ifdef WIN32
    TCHAR   szRootDir[4];

    szRootDir[0] = szDosPath[0];
    szRootDir[1] = cColon;
    szRootDir[2] = cBackslash;
    szRootDir[3] = 0;
#else // win16 version isn't as robust
	int		szRootDir;  	// not really an SZ, but it keeps the call compatible
	TCHAR	szLocalPath[4];

	szLocalPath[0] = szDosPath[0];
	szLocalPath[1] = 0;

	_strupr(szLocalPath);
	szRootDir = szLocalPath[0] - cA;
#endif

    return (GetDriveType(szRootDir));
}

LPCTSTR
GetItemFromIniEntry (
    IN  LPCTSTR  szEntry,
    IN  DWORD   dwItem

)
/*++

Routine Description:

    returns nth item from comma separated list returned from
        inf file. leaves (double)quoted strings intact.

Arguments:

    IN  LPCTSTR szEntry
        entry string returned from INF file

    IN  DWORD   dwItem
        1-based index indicating which item to return. (i.e. 1= first item
        in list, 2= second, etc.)


Return Value:

    pointer to buffer containing desired entry in string. Note, this
        routine may only be called 4 times before the string
        buffer is re-used. (i.e. don't use this function more than
        4 times in single function call!!)

--*/
{
    static  TCHAR   szReturnBuffer[4][MAX_PATH];
    static  LONG    dwBuff;
    LPTSTR  szSource, szDest;
    DWORD   dwThisItem;

    dwBuff = ++dwBuff % 4; // wrap buffer index

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuffer[dwBuff][0];

    // clear previous contents
    memset (szDest, 0, (MAX_PATH * sizeof(TCHAR)));

    // go past ini key
    while ((*szSource != cEqual) && (*szSource != 0)) szSource++;
    if (*szSource == 0){
        // no equals found so start at beginning
        // presumably this is just the "value"
        szSource = (LPTSTR)szEntry;
    } else {
        szSource++;
    }
    dwThisItem = 1;
    while (dwThisItem < dwItem) {
        if (*szSource != 0) {
            while ((*szSource != cComma) && (*szSource != 0)) {
                if (*szSource == cDoubleQuote) {
                    // if this is a quote, then go to the close quote
                    szSource++;
                    while ((*szSource != cDoubleQuote) && (*szSource != 0)) szSource++;
                }
                if (*szSource != 0) szSource++;
            }
        }
        dwThisItem++;
        if (*szSource != 0) szSource++;
    }
    // copy this entry to the return buffer
    if (*szSource != 0) {
        while ((*szSource != cComma) && (*szSource != 0)) {
            if (*szSource == cDoubleQuote) {
                // if this is a quote, then go to the close quote
                // don't copy quotes!
                szSource++;
                while ((*szSource != cDoubleQuote) && (*szSource != 0)) {
                    *szDest++ = *szSource++;
                }
                if (*szSource != 0) szSource++;
            } else {
                *szDest++ = *szSource++;
            }
        }
        *szDest = 0;
    }

    // remove any leading and/or trailing spaces

    TrimSpaces (&szReturnBuffer[dwBuff][0]);

    return &szReturnBuffer[dwBuff][0];
}

LPCTSTR
GetStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
)
/*++

Routine Description:

    look up string resource and return string

Arguments:

    IN  UINT    nId
        Resource ID of string to look up

Return Value:

    pointer to string referenced by ID in arg list

--*/
{
    static  TCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static  DWORD   dwIndex;
    LPTSTR  szBuffer;
    DWORD   dwLength;

    HANDLE  hMod;

    if (hInstance != NULL) {
        hMod = hInstance;
    } else {
        hMod = GetModuleHandle(NULL);
    }

    dwIndex++;
    dwIndex %= NUM_BUFS;
    szBuffer = &szBufArray[dwIndex][0];

    // clear previous contents
    memset (szBuffer, 0, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    dwLength = LoadString (
        hMod,
        nId,
        szBuffer,
        SMALL_BUFFER_SIZE);

    return (LPCTSTR)szBuffer;
}

LPCTSTR
GetQuotedStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
)
/*++

Routine Description:

    look up string resource and return string inside double quotes

Arguments:

    IN  HANDLE  hInstance
        handle to application instance

    IN  UINT    nId
        Resource ID of string to look up

Return Value:

    pointer to string referenced by ID in arg list

--*/
{
    static  TCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static  DWORD   dwIndex;
    LPTSTR  szBuffer;
    DWORD   dwLength;

    HANDLE  hMod;

    if (hInstance != NULL) {
        hMod = hInstance;
    } else {
        hMod = GetModuleHandle(NULL);
    }

    dwIndex++;
    dwIndex %= NUM_BUFS;
    szBuffer = &szBufArray[dwIndex][0];

    // clear previous contents
    memset (szBuffer, 0, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    szBuffer[0] = cSpace;
    szBuffer[1] = cSpace;
    szBuffer[2] = cDoubleQuote;

    dwLength = LoadString (
        hMod,
        nId,
        &szBuffer[3],
        SMALL_BUFFER_SIZE);

    lstrcat(szBuffer, cszDoubleQuote);

    return (LPCTSTR)szBuffer;
}

LPCTSTR
EnquoteString (
    IN  LPCTSTR szInString
)
/*++

Routine Description:

    return the input string wrapped in double quotes

Arguments:

    IN  LPCTSTR szInString

Return Value:

    pointer to string buffer containing a copy of szInString enclosed
        in double quotes

--*/
{
    static  TCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static  DWORD   dwIndex;
    LPTSTR  szBuffer;

    dwIndex++;
    dwIndex %= NUM_BUFS;
    szBuffer = &szBufArray[dwIndex][0];

    // clear previous contents
    memset (szBuffer, 0, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    szBuffer[0] = cSpace;
    szBuffer[1] = cSpace;
    szBuffer[2] = cDoubleQuote;
    lstrcpy (&szBuffer[3], szInString);
    lstrcat (szBuffer, cszDoubleQuote);

    return (LPCTSTR)szBuffer;
}

LONG
GetExpandedFileName (
    IN  LPTSTR   szInFileName,
    IN  DWORD    dwMaxExpandedSize,
    OUT LPTSTR   szExpandedFileName,
    OUT LPTSTR   *pFileNamePart
)
/*++

Routine Description:

    expands any environment variables in InFileName, then gets the
    fully qualified pathname of the result and returns that in the
    buffer provided by the caller

Arguments:

    IN  LPTSTR   szInFileName            input file string to expand
    IN  DWORD    dwMaxExpandedSize       size of output Buffer
    OUT LPTSTR   szExpandedFileName      buffer to recieve expanded name
    OUT LPTSTR   *pFileNamePart          pointer to filename in output buffer

ReturnValue:

    WIN32 error status of procedure

--*/
{
    LPTSTR  szEnvBuffer;

    LPTSTR  szPathReturn;

    LONG    lStatus;
    DWORD   dwSize;

    // validate arguments

    if ((szInFileName != NULL) &&
        (dwMaxExpandedSize != 0)) {

#ifdef WIN32

        // allocate working buffers

        szEnvBuffer = (LPTSTR)GLOBAL_ALLOC (((dwMaxExpandedSize + 1) * sizeof(TCHAR)));

        if (szEnvBuffer != NULL) {

            // expand env. strings if any

            dwSize = ExpandEnvironmentStrings (
                szInFileName,
                szEnvBuffer,
                (GlobalSize(szEnvBuffer) / sizeof(TCHAR)));

            if (dwSize != 0) {
                // get full pathname
                CLEAR_FIRST_FOUR_BYTES(szExpandedFileName);
                if (GetFullPathName (
                    szEnvBuffer,
                    dwMaxExpandedSize,
                    szExpandedFileName,
                    &szPathReturn) > 0) {
                    if (pFileNamePart != NULL) {
                    	*pFileNamePart = szPathReturn;
                    }
                    lStatus = ERROR_SUCCESS;
                } else {
                    // unable to get full path name
                    lStatus = ERROR_BAD_PATHNAME;
                }

            } else {
                // error expanding env strings
                lStatus = GetMyLastError();
            }
        } else {
            lStatus == ERROR_OUTOFMEMORY;
        }

        GLOBAL_FREE_IF_ALLOC (szEnvBuffer);
#else // if WIN16
		strncpy (szExpandedFileName, szInFileName, (size_t)dwMaxExpandedSize);
		lStatus = ERROR_SUCCESS;
		// unreferenced vars in WIN 16 mode
		dwSize = dwSize;
		szEnvBuffer = szEnvBuffer;
		szPathReturn = szPathReturn;
#endif
    } else {
        lStatus = ERROR_INVALID_PARAMETER;  // bad argument
    }

    return lStatus;
}

LONG
CreateDirectoryFromPath (
    IN  LPCTSTR                 szPath,
    IN  LPSECURITY_ATTRIBUTES   lpSA
)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  LPSECURITY_ATTRIBUTES   lpSA
        pointer to security attributes argument used by CreateDirectory


Return Value:

    TRUE    (non-zero) if directory(ies) created
    FALSE   if error (GetMyLastError to find out why)

--*/
{
    LPTSTR   szLocalPath;
    LPTSTR   szEnd;
    LONG     lReturn = 0L;

    szLocalPath = (LPTSTR)GLOBAL_ALLOC (MAX_PATH_BYTES);

    if (szLocalPath == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return 0;
    } else {
        // so far so good...
        SetLastError (ERROR_SUCCESS); // initialize error value to SUCCESS
    }

    GetExpandedFileName (
        (LPTSTR)szPath,
        MAX_PATH,
        szLocalPath,
        NULL);

    szEnd = &szLocalPath[3];

    if (*szEnd != 0) {
        // then there are sub dirs to create
        while (*szEnd != 0) {
            // go to next backslash
            while ((*szEnd != cBackslash) && (*szEnd != 0)) szEnd++;
            if (*szEnd == cBackslash) {
                // terminate path here and create directory
                *szEnd = 0;
                if (!CreateDirectory (szLocalPath, lpSA)) {
                    // see what the error was and "adjust" it if necessary
                    if (GetMyLastError() == ERROR_ALREADY_EXISTS) {
                        // this is OK
                        SetLastError (ERROR_SUCCESS);
                    } else {
                        lReturn = 0;
                    }
                } else {
                    // directory created successfully so update count
                    lReturn++;
                }
                // replace backslash and go to next dir
                *szEnd++ = cBackslash;
            }
        }
        // create last dir in path now
        if (!CreateDirectory (szLocalPath, lpSA)) {
            // see what the error was and "adjust" it if necessary
            if (GetMyLastError() == ERROR_ALREADY_EXISTS) {
                // this is OK
                SetLastError (ERROR_SUCCESS);
                lReturn++;
            } else {
                lReturn = 0;
            }
        } else {
            // directory created successfully
            lReturn++;
        }
    } else {
        // else this is a root dir only so return success.
        lReturn = 1;
    }
    GLOBAL_FREE_IF_ALLOC (szLocalPath);
    return lReturn;
}

BOOL
FileExists (
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    returns TRUE if the file in the path argument exists (NOTE: that
        the file is not actually opened to save time, rather the
        directory entry is read in order to determine existence)

Arguments:

    szPath  pointer to filename to look up

Return Value:

    TRUE if file exists
    FALSE if file not found

--*/
{
    BOOL    bMediaPresent;
    UINT    nDriveType;
    DWORD   dwAttr;

    nDriveType = GetDriveTypeFromDosPath((LPTSTR)szPath);
    if ((nDriveType == DRIVE_REMOVABLE) || (nDriveType == DRIVE_CDROM)) {
        // see if a formatted drive is really there
        bMediaPresent = MediaPresent(szPath, TRUE);
    } else {
        // if drive is not removable, then assume it's there
        bMediaPresent = TRUE;
    }

    // try to get inforation on the file
    dwAttr = QuietGetFileAttributes ((LPTSTR)szPath);
    if (dwAttr == 0xFFFFFFFF) {
        // unable to obtain attributes, so assume it's not there
        // or we can't access it
        return FALSE;
    } else {
        // found, so close it and return TRUE
        return TRUE;
    }
}

LPCTSTR
GetKeyFromIniEntry (
    IN  LPCTSTR  szEntry
)
/*++

Routine Description:



Arguments:


Return Value:

--*/
{
    static  TCHAR   szReturnBuffer[MAX_PATH];
    LPTSTR  szSource, szDest;

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuffer[0];

    // clear previous contents
    memset (szDest, 0, (MAX_PATH * sizeof(TCHAR)));

    *szDest = 0;

    if (*szSource != 0) {
        while ((*szSource != cEqual) && (*szSource != 0)) {
            *szDest++ = *szSource++;
        }
        *szDest = 0;
    }

    TrimSpaces(szReturnBuffer);
    return szReturnBuffer;
}

DWORD
StripQuotes (
    IN  OUT LPSTR   szBuff
)
/*++

Routine Description:

    removes all double quote characters (") from the string in the argument.
    this function modifies the contents of the buffer passed in the argument
    list.

Arguments:

    IN  OUT LPSTR   szBuff
        string to removed quote characters from

Return Value:

    length of new string in characters

--*/
{
    LPSTR   szSrcChar;
    LPSTR   szDestChar;

    DWORD   dwCharCount;

    szSrcChar = szBuff;
    szDestChar = szBuff;
    dwCharCount = 0;

    while (*szSrcChar != '\0') {
        if (*szSrcChar != '\"') {
            *szDestChar = *szSrcChar;
            szDestChar++;
            dwCharCount++;
        }
        szSrcChar++;
    }
    *szDestChar = '\0';

    return dwCharCount;
}

BOOL
GetFilePath (
    IN  LPCTSTR  szFileName,
    OUT LPTSTR  szPathBuffer
)
/*++

Routine Description:

    Scans for the file specified in the argument list.
        The OpenFile function looks in the following directories in
        the following order for the INF.

        1   The current directory.

        2   The Windows directory (the directory containing WIN.COM),
        whose path the GetWindowsDirectory function retrieves.

        3   The Windows system directory (the directory containing
        such system files as GDI.EXE), whose path the GetSystemDirectory
        function retrieves.

        4   The directory containing the executable file for the
        current task; the GetModuleFileName function obtains the
        path of this directory.

        5   The directories listed in the PATH environment variable.

        6   The list of directories mapped in a network.

Arguments:

    szFileName      base filename of file to find
    szPathBuffer    buffer that application inf file path is written to.

Return Value:

    TRUE if a file path is written to szPathBuffer
    FALSE if no file is found and szPathBuffer is empty

--*/
{
    TOFSTRUCT   ofFile;
    HFILE       hFile;

    hFile = OpenFileT (
        szFileName,
        &ofFile,
        OF_SEARCH);

    if (hFile != HFILE_ERROR) {
        // file found (and opened!) successfully
        lstrcpy (szPathBuffer, ofFile.szPathName);
        _lclose(hFile); // close file handle for now.
        return TRUE;
    } else {
        *szPathBuffer = 0;
        return FALSE;
    }
}

BOOL
GetInfPath (
    IN  HWND    hWnd,
    IN  UINT    nFileNameId,
    OUT LPTSTR  szPathBuffer
)
/*++

Routine Description:

    Scans for the INF file described by the string resource ID in the arg
        list. The OpenFile function looks in the following directories in
        the following order for the INF.

        1   The current directory.

        2   The Windows directory (the directory containing WIN.COM),
        whose path the GetWindowsDirectory function retrieves.

        3   The Windows system directory (the directory containing
        such system files as GDI.EXE), whose path the GetSystemDirectory
        function retrieves.

        4   The directory containing the executable file for the
        current task; the GetModuleFileName function obtains the
        path of this directory.

        5   The directories listed in the PATH environment variable.

        6   The list of directories mapped in a network.

Arguments:

    hWnd            Window handle of application main window
    nFileNameId     ID of string resource containing filename to locate
    szPathBuffer    buffer that application inf file path is written to.

Return Value:

    TRUE if a file path is written to szPathBuffer
    FALSE if no file is found and szPathBuffer is empty

--*/
{
    return GetFilePath(
        GetStringResource (GET_INSTANCE(hWnd), nFileNameId),
        szPathBuffer);
}

BOOL
DrawRaisedShading (
    IN  LPRECT  prShadeWnd,
    IN  LPPAINTSTRUCT   ps,
    IN  LONG    lDepth,
    IN  HPEN    hpenHighlight,
    IN  HPEN    hpenShadow
)
{
    LONG    lLineDepth;
    RECT    rWnd;       // local window rectangle dimensions

    rWnd = *prShadeWnd; // make local copy of rectangle

    // adjust rectangle to fit within client area
    rWnd.right -= 1;
    rWnd.bottom -= 1;

    if ((lDepth > 0) &&
        (lDepth < (rWnd.bottom / 2)) &&
        (lDepth < (rWnd.right / 2))) {

        // draw shading line
        for (lLineDepth = 0; lLineDepth < lDepth; lLineDepth++) {
            // start at bottom left corner and draw highlight
            SelectObject (ps->hdc, hpenHighlight);
            MoveToEx    (ps->hdc, rWnd.left, rWnd.bottom, NULL);
            LineTo      (ps->hdc, rWnd.left, rWnd.top);
            LineTo      (ps->hdc, rWnd.right, rWnd.top);

            // draw shadow lines
            SelectObject (ps->hdc, hpenShadow);
            LineTo      (ps->hdc, rWnd.right, rWnd.bottom);
            LineTo      (ps->hdc, rWnd.left-1, rWnd.bottom);

            // shrink rectangle for next iteration
            rWnd.top += 1;
            rWnd.left += 1;
            if (rWnd.left < rWnd.right) rWnd.right -= 1;
            if (rWnd.top < rWnd.bottom) rWnd.bottom -= 1;
        }

        return TRUE;
    } else {
        // depth is bigger than window
        return FALSE;
    }
}

BOOL
DrawSeparatorLine (
    IN  LPRECT  lprLine,
    IN  LPPAINTSTRUCT   ps,
    IN  HPEN    hpenLine
)
{
    SelectObject (ps->hdc, hpenLine);
    return Rectangle (ps->hdc,
            lprLine->left,
            lprLine->top,
            lprLine->right,
            lprLine->bottom);
}

DWORD
GetFileSizeFromPath (
    LPCTSTR szPath
)
/*++

Routine Description:

    returns the size of the file specified in szPath (if it exists)
        (up to 4 GB)

        returns 0 byte size if:
            the file could not be found
            the file is 0 bytes long

Arguments:

    szPath  path and name of file to query

Return Value:
    see description

--*/
{
    HANDLE  hFile;
    DWORD   dwSize, dwHiSize;

    if (FileExists(szPath)) {
        hFile = CreateFile(szPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            dwSize = GetFileSize (hFile, &dwHiSize);
            if (dwSize == 0xFFFFFFFF) {
                // an error so return 0
                dwSize = 0;
            } else if (dwHiSize > 0) {
                // file is > 4GB so return Max Int
                dwSize = 0xFFFFFFFF;
            } else {
                // file size was returned and <= 4GB so return size
            }
            CloseHandle (hFile);
            return dwSize;
        } else {
            return 0; // unable to open file
        }
    } else {
        return 0; // file not found
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\change\change.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  CHANGE.C
*     This module is the CHANGE utility code.
*
*
*************************************************************************/


#include <windows.h>
#include <winnt.h>
#include <stdio.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winsta.h>
#include <regapi.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <printfoa.h>
#include <locale.h>


#include "change.h"

/*-----------------------------------------------------------------------
-- Supported commands (now obtained from registry)
------------------------------------------------------------------------*/
PPROGRAMCALL pProgList = NULL;

/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );


/*************************************************************************
*
*  main
*     Main function and entry point of the text-based CHANGE menu utility.
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( INT argc,
      CHAR **argv )
{
    PWCHAR        arg, *argvW;
    PPROGRAMCALL  pProg, pProgramCall = NULL;
    int           len, j, status = FAILURE;
    LONG    regstatus;
    CHAR    unused;

    setlocale(LC_ALL, ".OCP");

    /*
     * Obtain the supported CHANGE commands from registry.
     */
    if ( (regstatus =
            RegQueryUtilityCommandList( UTILITY_REG_NAME_CHANGE, &pProgList ))
            != ERROR_SUCCESS ) {

        ErrorPrintf(IDS_ERROR_REGISTRY_FAILURE, UTILITY_NAME, regstatus);
        goto exit;
    }

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto exit;
    }

    /*
     * Check for valid utility name and execute.
     */
    if ( argc > 1 && *(argvW[1]) ) {

        len = wcslen(arg = argvW[1]);
        for ( pProg = pProgList->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( (len >= pProg->CommandLen) &&
                 !_wcsnicmp( arg, pProg->Command, len ) ) {

                pProgramCall = pProg;
                break;
            }
        }

        if ( pProgramCall ) {

                if ( ExecProgram(pProgramCall, argc - 2, &argvW[2]) )
                goto exit;

        } else if ( ((arg[0] == L'-') || (arg[0] == L'/')) &&
                    (arg[1] == L'?') ) {

            /*
             * Help requested.
             */
            Usage(FALSE);
            status = SUCCESS;
            goto exit;

        } else {

            /*
             * Bad command line.
             */
            Usage(TRUE);
            goto exit;
        }

    } else {

        /*
         * Nothing on command line.
         */
        Usage(TRUE);
        goto exit;
    }

exit:
    if ( pProgList )
        RegFreeUtilityCommandList(pProgList);   // let's be tidy

    return(status);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    ProgramUsage(UTILITY_NAME, pProgList, bError);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\inc\helpctx.h ===
#define IDH_CONTENTS                1000
#define IDH_LIST_BOX_DISPLAY        1001
#define IDH_MENU_BAR_ITEMS          1002
#define IDH_C2_OVERVIEW             1003
#define IDH_FILE_SYSTEMS            2001
#define IDH_OS_CONFIGURATION        2002
#define IDH_OS2_SUBSYSTEM           2003
#define IDH_POSIX_SUBSYSTEM         2004
#define IDH_SECURITY_LOG            2005
#define IDH_HALT_ON_AUDIT_FAILURE   2006
#define IDH_DISPLAY_LOGON_MESSAGE   2007
#define IDH_LAST_USERNAME_DISPLAY   2008
#define IDH_SHUTDOWN_BUTTON         2009
#define IDH_PASSWORD_LENGTH         2010
#define IDH_GUEST_ACCOUNT           2011
#define IDH_NETWORKING              2012
#define IDH_FILE_SYSTEM_DIALOG      2013
#define IDH_OPERATING_SYSTEM_DIALOG 2014
#define IDH_SECURITY_LOG_DIALOG     2015
#define IDH_AUDIT_FAILURE_DIALOG    2016
#define IDH_LOGON_MESSAGE_DIALOG    2017
#define IDH_LAST_USERNAME_DIALOG    2018
#define IDH_SHUTDOWN_BUTTON_DIALOG  2019
#define IDH_PASSWORD_LENGTH_DIALOG  2020
#define IDH_GUEST_ACCOUNT_DIALOG    2021
#define IDH_DRIVE_LETTER_AND_PRINT  2022
#define IDH_ALLOCATE_DRIVES         2023
#define IDH_DRIVES_AND_PRINTERS_DIALOG 2024
#define IDH_ALLOCATE_REMOVABLE_DRIVES_DIALOG 2025
#define IDH_OTHER_SECURITY_ITEMS    2027
#define IDH_REGISTRY_SECURITY       3001
#define IDH_FILE_SYSTEM_SECURITY    3002

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\change\change.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  CHANGE.H
*
*   This module contains typedefs and defines required for the CHANGE utility
*   menu.
*
******************************************************************************/

/*
 * Usage string definitions.
 */
#define UTILITY_NAME    L"CHANGE"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_REGISTRY_FAILURE                      102
#define IDS_ERROR_NOT_TS								103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\inc\strings.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    global strings declarations and definitions

Author:

    Bob Watson (a-robw)

Revision History:

    23 Aug 94

--*/
#ifndef _STRINGS_H_
#define _STRINGS_H_

//
// character strings
//
extern LPCTSTR cszBackslash;
extern LPCTSTR cszDoubleQuote;
extern LPCTSTR cmszEmptyString;
extern LPCTSTR cszEmptyString;
extern LPCTSTR cszSpace;
extern LPCTSTR cszKeySeparator;

extern LPCTSTR cszDot;
extern LPCTSTR cszDotDot;
extern LPCTSTR cszStarDotStar;

extern LPCTSTR cszLocalMachine;
extern LPCTSTR cszClassesRoot;
extern LPCTSTR cszCurrentUser;
extern LPCTSTR cszUsers;
extern LPCTSTR cszInherit;

// character defines

#define cBackslash  (TEXT('\\'))
#define cColon      (TEXT(':'))
#define cEqual      (TEXT('='))
#define cComma      (TEXT(','))
#define cDoubleQuote (TEXT('\"'))
#define cCompressChar (TEXT('_'))
#define cSemiColon  (TEXT(';'))
#define cPound      (TEXT('#'))
#define cOne        (TEXT('1'))
#define cSpace      (TEXT(' '))
#define cPeriod     (TEXT('.'))
#define cAsterisk   (TEXT('*'))
#define cAtSign     (TEXT('@'))
#define cLeftBracket (TEXT('['))
#define cSlash      (TEXT('/'))
#define cHyphen     (TEXT('-'))
#define cQuestionMark (TEXT('?'))
#define cBang       (TEXT('!'))
#define cA			(TEXT('A'))
#define cC          (TEXT('C'))
#define cH          (TEXT('H'))
#define ch          (TEXT('h'))
#define cZ          (TEXT('Z'))


#endif //_STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\c2config\inc\c2utils.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    definitions of utility functions.

Author:

    Bob Watson (a-robw)

Revision History:

    23 nov 94

--*/
#ifndef _UTILS_H_
#define _UTILS_H_

#ifdef _UNICODE
typedef struct _WOFSTRUCT {
    BYTE    cBytes;
    BYTE    fFixedDisk;
    WORD    nErrCode;
    WORD    Reserved1;
    WORD    Reserved2;
    WCHAR   szPathName[OFS_MAXPATHNAME];
} WOFSTRUCT, *LPWOFSTRUCT;

typedef WOFSTRUCT   TOFSTRUCT, *LPTOFSTRUCT;
#else
typedef OFSTRUCT    TOFSTRUCT, *LPTOFSTRUCT;
#endif

#ifdef	_UNICODE
#define GetProcAddressT GetProcAddressW
#define OpenFileT       OpenFileW

// wide character function prototypes

FARPROC
GetProcAddressW (
    IN  HMODULE hModule,
    IN  LPCWSTR lpwszProc
);

HFILE
OpenFileW(
    LPCTSTR     lpwszFile,
    LPWOFSTRUCT lpWOpenBuff,
    UINT        fuMode
);
#else   // if _UNICODE not defined
#define GetProcAddressT GetProcAddress
#define OpenFileT       OpenFile

#endif



//
//  utility routines
//
DWORD
QuietGetFileAttributes (
    IN  LPCTSTR lpszFileName
);

BOOL
EnableSecurityPriv (
    VOID
);

BOOL
EnableAllPriv (
    VOID
);

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
);

BOOL
IsUncPath (
    IN  LPCTSTR  szPath
);

LPTSTR
GetFileNameFromPath (
    IN  LPCTSTR szPath
);

BOOL
CenterWindow (
   HWND hwndChild,
   HWND hwndParent
);

UINT
GetDriveTypeFromDosPath (
    IN  LPCTSTR  szDosPath
);

LPCTSTR
GetItemFromIniEntry (
    IN  LPCTSTR  szEntry,
    IN  DWORD   dwItem

);

LPCTSTR
GetStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
);

LPCTSTR
GetQuotedStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
);

LPCTSTR
EnquoteString (
    IN  LPCTSTR szInString
);

LONG
GetExpandedFileName (
    IN  LPTSTR   szInFileName,
    IN  DWORD    dwMaxExpandedSize,
    OUT LPTSTR   szExpandedFileName,
    OUT LPTSTR   *pFileNamePart
);

LONG
CreateDirectoryFromPath (
    IN  LPCTSTR                 szPath,
    IN  LPSECURITY_ATTRIBUTES   lpSA
);

BOOL
FileExists (
    IN  LPCTSTR szPath
);

LPCTSTR
GetKeyFromIniEntry (
    IN  LPCTSTR  szEntry
);

DWORD
StripQuotes (
    IN  OUT LPSTR   szBuff
);

BOOL
GetInfPath (
    IN  HWND    hWnd,
    IN  UINT    nFileNameId,
    OUT LPTSTR  szPathBuffer
);

BOOL
GetFilePath (
    IN  LPCTSTR  szFileName,
    OUT LPTSTR  szPathBuffer
);

BOOL
DrawRaisedShading (
    IN  LPRECT  prShadeRect,
    IN  LPPAINTSTRUCT   ps,
    IN  LONG    lDepth,
    IN  HPEN    hpenHighlight,
    IN  HPEN    hpenShadow
);

BOOL
DrawSeparatorLine (
    IN  LPRECT  lprLine,
    IN  LPPAINTSTRUCT   ps,
    IN  HPEN    hpenLine
);

DWORD
GetFileSizeFromPath (
    LPCTSTR szPath
);
#endif //_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chgport\chgport.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  CHGPORT.H
*     This module contains typedefs and defines required for
*     the CHGPORT utility.
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Structure for com port name mappings
 */
typedef struct _COMNAME {
   PWCHAR com_pwcNTName;        /* pointer to NT name of device */
   PWCHAR com_pwcDOSName;       /* pointer to DOS name of device */
   struct _COMNAME *com_pnext;  /* next entry in list */
} COMNAME, *PCOMNAME;

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_GETTING_COMPORTS                      102
#define IDS_ERROR_DEL_PORT_MAPPING                      103
#define IDS_ERROR_CREATE_PORT_MAPPING                   104
#define IDS_ERROR_PORT_MAPPING_EXISTS                   105
#define IDS_ERROR_NO_SERIAL_PORTS                       106
#define IDS_HELP_USAGE1                                 107
#define IDS_HELP_USAGE2                                 108
#define IDS_HELP_USAGE3                                 109
#define IDS_HELP_USAGE4                                 110
#define IDS_HELP_USAGE5                                 111
#define IDS_ERROR_NOT_TS	                            112
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chgusr\precomp.h ===
#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>

#include <ntddmou.h>
#include <tsappcmp.h>
#include <printfoa.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cnvrtuc\cmdline.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
* CMDLINE.C
*
* Command line parser for WinFrame User Configuration conversion utility.
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
*
* Author: Bruce Fortune
*
* $Log:   U:\NT\PRIVATE\UTILS\citrix\cnvrtuc\VCS\cmdline.c  $
*
*     Rev 1.5   May 04 1998 18:04:00   bills
*  Fixes for MS bug #2109, OEM->ANSI conversion and moving strings to the rc file.
*
*     Rev 1.4   03 Nov 1997 18:23:54   scottn
*  MultiUser-->Terminal Server
*
*     Rev 1.3   22 Aug 1997 14:48:36   scottn
*  Change WinFrame to Windows NT MultiUser
*
*     Rev 1.2   Jun 26 1997 18:17:24   billm
*  move to WF40 tree
*
*     Rev 1.1   23 Jun 1997 16:17:22   butchd
*  update
*
*     Rev 1.0   15 Feb 1997 09:51:48   brucef
*  Initial revision.
*
*************************************************************************/

/*
 *  Includes
 */

#undef UNICODE
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
// #include <citrix\cxstatus.h>
#include <winsta.h>
#include <icadd.h>
#include <icaapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <utilsub.h>

#include "resource.h"
#include <printfoa.h>

#if MAX_COMPUTERNAME_LENGTH > DOMAIN_LENGTH
#define _COMPUTERNAME_LENGTH MAX_COMPUTER_NAME_LENGTH
#else
#define _COMPUTERNAME_LENGTH DOMAIN_LENGTH
#endif

/*
 *  Global variables
 */
ULONG fHelp = FALSE;
extern ULONG fAll;
extern WCHAR UserName[ USERNAME_LENGTH + 1 ];
extern WCHAR DomainName[ _COMPUTERNAME_LENGTH + 1 ];

/*
 *  Command line parsing strucutre
 */
TOKMAP ptm[] =
{
   {L"/DOMAIN",
       TMFLAG_REQUIRED,
       TMFORM_STRING,
       DOMAIN_LENGTH,
       &DomainName },
   {L"/USER",
       TMFLAG_OPTIONAL,
       TMFORM_STRING,
       USERNAME_LENGTH,
       &UserName },
   {L"/ALL",
       TMFLAG_OPTIONAL,
       TMFORM_BOOLEAN,
       sizeof(ULONG),
       &fAll },
   {L"/?",
       TMFLAG_OPTIONAL,
       TMFORM_BOOLEAN,
       sizeof(ULONG),
       &fHelp },
   {0, 0, 0, 0, 0 }
};


void Print( int nResourceID, ... );

BOOLEAN
ProcessCommandLine(
    int argc,
    char *argv[]
    )
{
    WCHAR  *CmdLine;
    WCHAR **argvW;
    NTSTATUS rc;
    LONG Error;
    int i;

    /*
     * We can't use argv[] because its always ANSI, regardless of UNICODE
     */
    CmdLine = GetCommandLineW();

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if( argvW == NULL )
        return( FALSE );

    argvW[0] = wcstok(CmdLine, L" ");
    for(i=1; i < argc; i++){
        argvW[i] = wcstok(0, L" ");
                OEM2ANSIW(argvW[i], wcslen(argvW[i]));
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine( argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY );

    /*
     *  Check for error from ParseCommandLine
     */
    if ( fHelp ||
         rc ||
         DomainName[0] == L'\0' ||
         (fAll && UserName[0] != L'\0') ||
         (!fAll && UserName[0] == L'\0') ) {
        Print(IDS_NEWLINE);
        Print(IDS_USAGE1, argv[0] );
        Print(IDS_NEWLINE);
        Print(IDS_USAGE2,  argv[0] );
        Print(IDS_USAGE3);
        Print(IDS_USAGE4);
        Print(IDS_USAGE5);
        Print(IDS_USAGE6);
        Print(IDS_USAGE7);
        Print(IDS_NEWLINE);
        Print(IDS_USAGE8);
        Print(IDS_USAGE9);
        Print(IDS_NEWLINE);
        return(FALSE );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chglogon\chglogon.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/***********************************************************************
*
*   CHGLOGON.H
*
*   This module contains typedefs and defines required for
*   the CHGLOGON utility.
*
*  
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_WINSTATIONS_DISABLED                        107
#define IDS_WINSTATIONS_ENABLED                         108
#define IDS_ACCESS_DENIED                               109
#define IDS_ERROR_NOT_TS								110

#define IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_1     111     // deny connections is set to 1
#define IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_0     112     // deny connections is set to 0

/*
 *  Winlogon defines
 */

#define APPLICATION_NAME                    TEXT("Winlogon")
#define WINSTATIONS_DISABLED                TEXT("WinStationsDisabled")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chglogon\chglogon.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*   CHGLOGON.C
*
*   This module contains code for the CHGLOGON utility.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <locale.h>
#include <printfoa.h>

#include "chglogon.h"

/*
 * Global Data
 */
USHORT   help_flag = FALSE;             // User wants help
USHORT   fQuery    = FALSE;             // query winstations
USHORT   fEnable   = FALSE;             // enable winstations
USHORT   fDisable  = FALSE;             // disable winstations

TOKMAP ptm[] = {
      {L"/q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/query",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/enable",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEnable},
      {L"/disable", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDisable},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage(BOOLEAN bError);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR **argvW;
    ULONG rc;
    INT   i;
    PPOLICY_TS_MACHINE   Ppolicy;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag && !(rc & PARSE_FLAG_NO_PARMS) ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
    *   Check if Group policy has thrown the big switch, if so, inform and refuse any changes
    */

    Ppolicy = LocalAlloc( LPTR, sizeof(POLICY_TS_MACHINE) ); 
    if (Ppolicy == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    RegGetMachinePolicy( Ppolicy );
    if ( Ppolicy->fPolicyDenyTSConnections )
    {
        if (Ppolicy->fDenyTSConnections)
        {
            ErrorPrintf(IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_1 );
        }
        else
        {
            ErrorPrintf(IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_0 );
        }
        LocalFree( Ppolicy );
        Ppolicy = NULL;
        return( FAILURE );
    }

    if (Ppolicy != NULL) {
        LocalFree( Ppolicy );
        Ppolicy = NULL;
    }

    /*
     *  Enable or disable
     */
    if ( fDisable ) {
        rc = WriteProfileString( APPLICATION_NAME, WINSTATIONS_DISABLED, TEXT("1") );
    }
    else if ( fEnable ) {
        rc = WriteProfileString( APPLICATION_NAME, WINSTATIONS_DISABLED, TEXT("0") );
    }

    /*
     *  Query or error ?
     */
    if ( !fQuery && (rc != 1) ) {
        ErrorPrintf(IDS_ACCESS_DENIED);
    }
    else if ( GetProfileInt( APPLICATION_NAME, WINSTATIONS_DISABLED, 0 ) == 0 ) {
        ErrorPrintf(IDS_WINSTATIONS_ENABLED);
    }
    else {
        ErrorPrintf(IDS_WINSTATIONS_DISABLED);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE5);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chgport\chgport.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  CHGPORT.C
*
*  Change serial port mapping.
*
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <printfoa.h>
#include <locale.h>

#include "chgport.h"

/*
 * Global Data
 */
WCHAR user_string[MAX_IDS_LEN+1];       // parsed user input
USHORT help_flag = FALSE;               // User wants help
USHORT fDelete   = FALSE;               // delete mapped port
USHORT fquery = FALSE;        // query the mapped ports
PCOMNAME pValidNames = NULL;            // list of valid com names in registry

TOKMAP ptm[] = {
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, user_string},
      {L"/d", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDelete},
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {L"/QUERY", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fquery},
      {L"/Q", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fquery},
      {0, 0, 0, 0, 0}
};


/*
 * Constants
 */
#define DOSDEVICE_STRING    L"\\DosDevices"

/*
 * Local function prototypes.
 */
void Usage(BOOLEAN bError);
BOOL DeleteMappedPort(PWCHAR user_string);
BOOL GetPorts(PWCHAR user_string,
              PWCHAR pwcSrcPort,
              PWCHAR pwcDestPort,
              ULONG ulbufsize);
BOOL MapPorts(PWCHAR pwcSrcPort,
              PWCHAR pwcDestPort);
void ListSerialPorts();
BOOL IsSerialDevice(PWCHAR pwcName);
ULONG GetNTObjectName(PWCHAR pwcDOSdev,
                      PWCHAR pwcNTObjName,
                      ULONG ulbufsize);
ULONG AddComName(PCOMNAME *pComList,
                 PWCHAR pwcNTName,
                 PWCHAR pwcDOSName);
void DelComName(PCOMNAME pEntry);
PCOMNAME FindComName(PCOMNAME pComList,
                     PWCHAR pwcName);

BOOL IsVDMdeviceName(PWCHAR pwcName);

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR **argvW;
    WCHAR wcSrcPort[MAX_PATH], wcDestPort[MAX_PATH];
    ULONG ulSrcPort, ulDestPort, rc;
    INT   i;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

            if ( !help_flag ) {

                Usage(TRUE);
                return(FAILURE);

            } else {

                Usage(FALSE);
                return(SUCCESS);
            }
    }

        //If we are not Running under Terminal Server, Return Error

        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return (FAILURE);
        }

    if (fDelete) {
            DeleteMappedPort(user_string);
    } else if (*user_string) {
             GetPorts(user_string, wcSrcPort, wcDestPort, MAX_PATH);
             MapPorts(wcSrcPort, wcDestPort);
    } else {                 // query the mapped ports
        ListSerialPorts();
    }

    // Free up the list of valid port names
    if (pValidNames) {
        PCOMNAME pEntry, pPrev;

        pEntry = pValidNames;
        while (pEntry) {
            pPrev = pEntry;
            pEntry = pEntry->com_pnext;
            DelComName(pPrev);
        }
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE5);

}  /* Usage() */


/*******************************************************************************
 *
 *  DeleteMappedPort
 *
 *  This routine deletes the specified mapped port
 *
 *
 *  ENTRY:
 *     PWCHAR pwcport (In): Pointer to port mapping to delete
 *
 *  EXIT:
 *     TRUE: port was deleted
 *     FALSE: error deleting port
 *
 ******************************************************************************/

BOOL DeleteMappedPort(PWCHAR pwcport)
{
    ULONG rc;
    PWCHAR pwch;
    WCHAR  wcbuff[MAX_PATH];

    // Check if this a serial device and if it is, remove it
    if (!GetNTObjectName(pwcport, wcbuff, sizeof(wcbuff)/sizeof(WCHAR)) &&
        IsSerialDevice(wcbuff)) {

            if (DefineDosDevice(DDD_REMOVE_DEFINITION,
                                pwcport,
                                NULL)) {
                return(TRUE);
            } else {
                rc = GetLastError();
            }
    } else {
            rc = ERROR_FILE_NOT_FOUND;
    }

    StringDwordErrorPrintf(IDS_ERROR_DEL_PORT_MAPPING, pwcport, rc);

    return(FALSE);
}


/*******************************************************************************
 *
 *  GetPorts
 *
 *  This routine converts the string to the source and destination ports
 *
 *
 *  ENTRY:
 *     PWCHAR pwcstring (In): Pointer to user string
 *     PWCHAR pwcSrcPort (Out): Pointer to return source port
 *     PWCHAR pwcSrcPort (Out): Pointer to return destination port
 *     ULONG  ulbufsize (In): Size of return buffers
 *
 *  EXIT:
 *     TRUE: string converted to source and destination ports
 *     FALSE: error
 *
 ******************************************************************************/

BOOL GetPorts(PWCHAR pwcstring, PWCHAR pwcSrcPort, PWCHAR pwcDestPort,
              ULONG ulbufsize)
{
    PWCHAR pwch;
    ULONG  ulcnt;
    BOOL   fSawEqual = FALSE;

    pwch = pwcstring;

    // find next non alphanumeric character
    for (ulcnt = 0; pwch[ulcnt] && iswalnum(pwch[ulcnt]); ulcnt++) {
    }

    // Get the source port
    if (pwch[ulcnt] && (ulcnt < ulbufsize)) {
        wcsncpy(pwcSrcPort, pwch, ulcnt);
    } else {
        return(FALSE);
    }
    pwcSrcPort[ulcnt] = L'\0';

    pwch += ulcnt;

    // get to destination port
    while (*pwch && !iswalnum(*pwch)) {
        if (*pwch == L'=') {
            fSawEqual = TRUE;
        }
        pwch++;
    }

    // If the syntax is OK and there's room in the buffer, copy the dest. port
    if (*pwch && fSawEqual && (wcslen(pwch) < ulbufsize)) {
        wcscpy(pwcDestPort, pwch);
    } else {
        return(FALSE);
    }

    // remove the : if they entered comn:
    if (pwch = wcsrchr(pwcSrcPort, L':')) {
        *pwch = L'\0';
    }
    if (pwch = wcsrchr(pwcDestPort, L':')) {
        *pwch = L'\0';
    }

    return(TRUE);
}


/*******************************************************************************
 *
 *  MapPorts
 *
 *  This routine maps the source port number to the destination port.
 *
 *
 *  ENTRY:
 *     PWCHAR pwcSrcPort (In): Source port
 *     PWCHAR pwcDestPort (In): Destination port
 *
 *  EXIT:
 *     TRUE: port was mapped
 *     FALSE: error mapping port
 *
 ******************************************************************************/

BOOL MapPorts(PWCHAR pwcSrcPort, PWCHAR pwcDestPort)
{
    ULONG rc = ERROR_FILE_NOT_FOUND;
    WCHAR wcdest[MAX_PATH], wcsrc[MAX_PATH];
    PWCHAR pFixedPort = NULL;

    // Get the NT name of the destination and make sure it's a serial device
    if (!GetNTObjectName(pwcDestPort, wcdest, sizeof(wcdest)/sizeof(WCHAR)) &&
        IsSerialDevice(wcdest)) {

        // see if this mapping already exists
        if (!GetNTObjectName(pwcSrcPort, wcsrc, sizeof(wcsrc)/sizeof(WCHAR)) &&
                !_wcsicmp(wcdest, wcsrc)) {
            ErrorPrintf(IDS_ERROR_PORT_MAPPING_EXISTS,
                         pwcSrcPort,
                         pwcDestPort);
            return(FALSE);
        }

        if (DefineDosDevice(DDD_RAW_TARGET_PATH,
                            pwcSrcPort,
                            wcdest)) {
            return(TRUE);
        } else {
            rc = GetLastError();
        }
    }

    StringDwordErrorPrintf(IDS_ERROR_CREATE_PORT_MAPPING, pwcSrcPort, rc);

    return(FALSE);
}


/*******************************************************************************
 *
 *  GetNTObjectName
 *
 *  This routine returns the NT object name for a DOS device.
 *
 *  ENTRY:
 *      PWCHAR pwcDOSdev (In): pointer to DOS device name
 *      PWCHAR pwcNTObjName (Out): pointer for NT object name
 *      ULONG ulbufsize (In): size (in wide chars) of object name buffer
 *
 *  EXIT:
 *      Success:
 *          returns 0
 *      Failure:
 *          returns error code
 *
 ******************************************************************************/

ULONG GetNTObjectName(PWCHAR pwcDOSdev, PWCHAR pwcNTObjName, ULONG ulbufsize)
{
    WCHAR wcbuff[MAX_PATH];
    PWCHAR pwch;

    // Make a copy of the name passed in
    wcscpy(wcbuff, pwcDOSdev);

    // Strip off any trailing colon (comn:)
    if (pwch = wcsrchr(wcbuff, L':')) {
        *pwch = L'\0';
    }

    if (QueryDosDevice(pwcDOSdev, pwcNTObjName, ulbufsize)) {
        return(0);
    } else {
        return(GetLastError());
    }
}


/*******************************************************************************
 *
 *  ListSerialPorts
 *
 *  This routine lists all of the mapped ports.
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 ******************************************************************************/

void ListSerialPorts(void)
{
    ULONG ulcnt, rc;
//    WCHAR DeviceNames[4096];
    WCHAR TargetPath[4096];
    PWCH  pwch;
    PCOMNAME pComList = NULL;
    PCOMNAME pEntry, pPrev;

    DWORD dwBufferSize = 2048;
    WCHAR *DeviceNames = malloc(dwBufferSize);

    if (!DeviceNames)     {

        ErrorPrintf(IDS_ERROR_MALLOC);
        return;
    }


    //
    // Get all of the defined DOS devices
    //

    //
    // QueryDosDevice function returns success even if buffer is too small!
    // Lets get around it
    //

    SetLastError(0);
    while (!QueryDosDevice( NULL,
                         DeviceNames,
                         dwBufferSize/sizeof(WCHAR)) ||
            GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            SetLastError(0);
            free(DeviceNames);
            dwBufferSize *= 2;

            DeviceNames = malloc(dwBufferSize);

            if (!DeviceNames)
            {
                ErrorPrintf(IDS_ERROR_MALLOC);
                return;
            }

        }
        else
        {
            ErrorPrintf(IDS_ERROR_GETTING_COMPORTS, GetLastError());
        }
    }

    pwch = DeviceNames;

    // Go through each DOS device and get it's NT object name, then check if
    // it's a serial device, and if so display it
    while (*pwch) {
        rc = GetNTObjectName(pwch,
                             TargetPath,
                             sizeof(TargetPath)/sizeof(WCHAR));
        if (rc) {
            ErrorPrintf(IDS_ERROR_GETTING_COMPORTS, rc);
        } else if (IsSerialDevice(TargetPath)) {
            AddComName(&pComList, TargetPath, pwch);
        }

        pwch += wcslen(pwch) + 1;
    }

    if (pComList) {
        // print out the entries
        pEntry = pComList;
        while (pEntry) {
            wprintf(L"%s = %s\n", pEntry->com_pwcDOSName, pEntry->com_pwcNTName);
            pPrev = pEntry;
            pEntry = pEntry->com_pnext;
            DelComName(pPrev);
        }
    } else {
        ErrorPrintf(IDS_ERROR_NO_SERIAL_PORTS);
    }

    free(DeviceNames);

}


/*******************************************************************************
 *
 *  IsSerialDevice
 *
 *  This routine checks if the NT file name is a serial device
 *
 *
 *  ENTRY:
 *     PWCHAR pwcName (In): Pointer to name to check
 *
 *  EXIT:
 *     TRUE: Is a serial device
 *     FALSE: Not a serial device
 *
 ******************************************************************************/

BOOL IsSerialDevice(PWCHAR pwcName)
{
    NTSTATUS Status;
    HANDLE   Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION FileFSDevInfo;
    OBJECT_ATTRIBUTES ObjFile;
    UNICODE_STRING  UniFile;
    WCHAR           wcbuff[MAX_PATH];
    WCHAR           wcvalue[MAX_PATH];
    PWCHAR          pwch;
    HKEY            hKey;
    ULONG           ulType, ulSize, ulcnt, ulValSize;
    BOOL            fIsSerial = FALSE;

    
    if (IsVDMdeviceName(pwcName)) {
        return FALSE;
    }

    RtlInitUnicodeString(&UniFile, pwcName);

    InitializeObjectAttributes(&ObjFile,
                               &UniFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Open the device
    //
    Status = NtOpenFile(&Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &ObjFile,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryVolumeInformationFile(Handle,
                                              &IoStatusBlock,
                                              &FileFSDevInfo,
                                              sizeof(FileFSDevInfo),
                                              FileFsDeviceInformation);

        // Check if this is actually a serial device or not
        if (NT_SUCCESS(Status) &&
            (FileFSDevInfo.DeviceType == FILE_DEVICE_SERIAL_PORT)) {
            fIsSerial = TRUE;
        }

        // Close the file handle
        NtClose(Handle);

    } else {
        // If we couldn't open the device, look for the name in the registry

#ifdef DEBUG
        wprintf(L"Error opening: %s, error = %x\n", pwcName, Status);
#endif

        // strip off the leading \device
        pwch = wcschr(pwcName+2, L'\\');
        if (pwch != NULL)
        {
            pwch++;


            // If we haven't built the list of valid names from the registry,
            // build it.
            if (pValidNames == NULL) {
                // Open the serialcomm entry in the registry
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         L"Hardware\\DeviceMap\\SerialComm",
                                         0,
                                         KEY_READ,
                                         &hKey) == ERROR_SUCCESS) {

                    ulValSize = ulSize = MAX_PATH;
                    ulcnt = 0;

                    // Put all of the valid entries into the valid names list
                    while (!RegEnumValue (hKey, ulcnt++, wcvalue, &ulValSize,
                                          NULL, &ulType, (LPBYTE) wcbuff, &ulSize))
                    {
                        if (ulType != REG_SZ)
                            continue;

                        AddComName(&pValidNames, wcvalue, wcbuff);

                        ulValSize = ulSize = MAX_PATH;
                    }

                    RegCloseKey(hKey);
                }
            }

            // look for the name in the list of valid com names
            if (FindComName(pValidNames, pwch)) {
                fIsSerial = TRUE;
            }
        }
    }

    return(fIsSerial);
}


/*****************************************************************************
 *
 *  AddComName
 *
 *  This routines adds a new node onto the specified com port names.
 *
 * ENTRY:
 *   PCOMNAME *pComList (In) - Pointer to list to add entry to
 *   PWCHAR pwcNTName (In)  - NT name of device
 *   PWCHAR pwcDOSName (In) - DOW name of device
 *
 * EXIT:
 *   SUCCESS:
 *      return ERROR_SUCCESS
 *   FAILURE:
 *      returns error code
 *
 ****************************************************************************/

ULONG AddComName(PCOMNAME *pComList,
                 PWCHAR pwcNTName,
                 PWCHAR pwcDOSName)
{
    PCOMNAME pnext, pprev, pnew;
    LONG rc = ERROR_SUCCESS;

    if (pnew = malloc(sizeof(COMNAME))) {

        // clear out the new entry
        memset(pnew, 0, sizeof(COMNAME));

        // Allocate and initialize the NT name
        if (pnew->com_pwcNTName =
                malloc((wcslen(pwcNTName) + 1)*sizeof(WCHAR))) {
            wcscpy(pnew->com_pwcNTName, pwcNTName);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        // Allocate and initialize the DOS name
        if ((rc == ERROR_SUCCESS) && (pnew->com_pwcDOSName =
                malloc((wcslen(pwcDOSName) + 1)*sizeof(WCHAR)))) {
            wcscpy(pnew->com_pwcDOSName, pwcDOSName);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    // If we allocate everything OK, add the node into the list
    if (rc == ERROR_SUCCESS) {
        pprev = NULL;
        pnext = *pComList;

        // Insert the entry into the list in ascending order
        while (pnext &&
               ((rc = _wcsicmp(pwcDOSName, pnext->com_pwcDOSName)) > 0)) {
            pprev = pnext;
            pnext = pnext->com_pnext;
        }

        // just return if this name is already in the list
        if (pnext && (rc == 0)) {
            return(ERROR_SUCCESS);
        }

        // Insert this entry into the list
        pnew->com_pnext = pnext;

        // If this is going to the front of the list, update list pointer
        if (pprev == NULL) {
            *pComList = pnew;
        } else {
            pprev->com_pnext = pnew;
        }

    } else if (pnew) {

        // Didn't allocate everything, release the memory we got
        DelComName(pnew);
    }

    return(rc);
}


/*****************************************************************************
 *
 *  DelComName
 *
 *  This routines frees up the memory allocated to a com name node.
 *
 * ENTRY:
 *   PCOMNAME pEntry (In)  - Node to delete
 *
 * EXIT:
 *   NONE
 *
 ****************************************************************************/

void DelComName(PCOMNAME pEntry)
{
    if (pEntry) {
        if (pEntry->com_pwcNTName) {
            free(pEntry->com_pwcNTName);
        }
        if (pEntry->com_pwcDOSName) {
            free(pEntry->com_pwcDOSName);
        }
        free(pEntry);
    }
}


/*****************************************************************************
 *
 *  FindComName
 *
 *  This routines searches for the specified name in the com port list.
 *
 * ENTRY:
 *   PCOMNAME pComList (In) - List to search
 *   PWCHAR   pwcName (In)  - Name to search for
 *
 * EXIT:
 *   SUCCESS:
 *      returns pointer to node containing the specified name
 *   FAILURE:
 *      returns NULL (name not found)
 *
 ****************************************************************************/

PCOMNAME FindComName(PCOMNAME pComList,
                     PWCHAR pwcName)
{
    PCOMNAME pcom;

    pcom = pComList;
    while (pcom) {
        //Check if the name matches either the NT or DOS device name
        if (!_wcsicmp(pwcName, pcom->com_pwcDOSName) ||
            !_wcsicmp(pwcName, pcom->com_pwcNTName)) {
               return(pcom);
        }
        pcom = pcom->com_pnext;
    }
    return(NULL);
}

BOOL IsVDMdeviceName(PWCHAR pwcName) 
{
    UINT  index;
    UINT  vdmlength = wcslen(L"VDM"); 

    for (index = 0; (index+vdmlength-1) < wcslen(pwcName); index++) {
        if (_wcsnicmp(&pwcName[index], L"VDM", vdmlength) == 0) {
            return TRUE;
        }
    }

    return FALSE;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chgusr\chgusr.h ===
/***********************************************************************
*
*  CHGUSR.H
*     This module contains typedefs and defines required for
*     the CHGUSR utility.
*
*  Copyright Citrix Systems Inc. 1995
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*************************************************************************/


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Function prototypes
 */

LPWSTR
GetErrorString(
    DWORD   Error
);


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_EXECUTE                                     107
#define IDS_INSTALL                                     108
#define IDS_ERROR_ADMIN_ONLY                            109
#define IDS_READY_INSTALL                               110
#define IDS_READY_EXECUTE                               111
#define IDS_ERROR_INI_MAPPING_FAILED                    112
#define IDS_ERROR_NOT_TS				                113
#define IDS_ERROR_REMOTE_ADMIN                          114
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\chgusr\chgusr.c ===
/******************************************************************************
*
*  CHGUSR.C
*
*  Text utility to change INI file mapping settings
*
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*
*******************************************************************************/

#include "precomp.h"

#include <ntddkbd.h>
#include <winsta.h>
#include <syslib.h>
#include <assert.h>

#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "chgusr.h"
#include "winbasep.h"
#include "regapi.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

WCHAR Arg1[MAX_IDS_LEN+1];

int On_flag      = FALSE;
int Off_flag     = FALSE;
int Query_flag   = FALSE;
int Help_flag    = FALSE;
int Install_flag = FALSE;
int Execute_flag = FALSE;


TOKMAPW ptm[] = {
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN,  Arg1},
      {L"/INIMAPPING:ON", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &On_flag},
      {L"/INIMAPPING:OFF", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Off_flag},
      {L"/QUERY", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Query_flag},
      {L"/Q", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Query_flag},
      {L"/INSTALL", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Install_flag},
      {L"/EXECUTE", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Execute_flag},
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Help_flag},
      {0, 0, 0, 0, 0}
};

BOOL IsRemoteAdminMode( );

BOOL
TestUserForAdmin( VOID );

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
   WCHAR **argvW;
   ULONG rc;
   int i;
   BOOL Result;
   BOOL State;
   HANDLE hWin;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( Help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !Help_flag ) {
            // International
            ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
            ErrorPrintf(IDS_HELP_USAGE1);
            ErrorPrintf(IDS_HELP_USAGE2);
            ErrorPrintf(IDS_HELP_USAGE3);
            ErrorPrintf(IDS_HELP_USAGE4);
            ErrorPrintf(IDS_HELP_USAGE5);
            return(FAILURE);

        } else {
            Message(IDS_HELP_USAGE1);
            Message(IDS_HELP_USAGE2);
            Message(IDS_HELP_USAGE3);
            Message(IDS_HELP_USAGE4);
            Message(IDS_HELP_USAGE5);
            return(SUCCESS);
        }
    }

        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    if( Query_flag ) {

        // Show the current state
        State = TermsrvAppInstallMode();
        if( !State ) {
            Message(IDS_EXECUTE);
        }
        else {
            Message(IDS_INSTALL);
        }

        if( IsRemoteAdminMode( ) )
        {
            Message( IDS_ERROR_REMOTE_ADMIN );
        }

        return( !State + 100 );  // Exit code 100 == INSTALL Mode
                                 // Exit Code 101 == EXECUTE Mode
    } 


    /*
     *  Set the modes necessary to install applications
     */
    if ( Install_flag ) {
        On_flag = FALSE;
        Off_flag = TRUE;
    }

    /*
     *  Set the modes necessary to run applications
     */
    if ( Execute_flag ) {
        On_flag = TRUE;
        Off_flag = FALSE;
    }


    // Default to Execute mode
    State = TRUE;

    if( On_flag || Off_flag ) {

        if( IsRemoteAdminMode( ) ) {

            Message( IDS_ERROR_REMOTE_ADMIN );

            return SUCCESS;
        }

        if( Off_flag ) {

            /*
             * We only allow admins to turn off execute mode
             */
            if( !TestUserForAdmin() ) {
                ErrorPrintf(IDS_ERROR_ADMIN_ONLY);
                return(FAILURE);
            }

            State = FALSE;
        }

        rc = SetTermsrvAppInstallMode( (BOOL)(!State) );
        if( !rc ) {
            // Use function to map error message to string
            ErrorPrintf(IDS_ERROR_INI_MAPPING_FAILED,GetLastError());
            return(!rc);
        } else {
            if ( Off_flag ) 
                Message(IDS_READY_INSTALL);
            if ( On_flag ) 
                Message(IDS_READY_EXECUTE);
        }
    }
    else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        return(FAILURE);
    }

    if( IsRemoteAdminMode( ) )
    {
        Message( IDS_ERROR_REMOTE_ADMIN );
    }

    return( !rc );
}

BOOL IsRemoteAdminMode( )
{
    HKEY hKey;
    
    DWORD dwData = 0;

    BOOL fMode = FALSE;

	DWORD dwSize = sizeof( DWORD );


    DBGPRINT( ( "CHGUSR : IsRemoteAdminMode\n" ) );
    
    

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                      REG_CONTROL_TSERVER, 
                      0,
                      KEY_READ ,
                      &hKey ) != ERROR_SUCCESS )
    {
        DBGPRINT( ( "CHGUSR : IsRemoteAdminMode -- RegOpenEx unable to open key\n" ) );

        return FALSE;
	}
	
	
    if( RegQueryValueEx( hKey ,
                         TEXT( "TSAppCompat" ) ,
                         NULL ,
                         NULL , 
                         ( LPBYTE )&dwData , 
                         &dwSize ) != ERROR_SUCCESS )
    {
        DBGPRINT( ( "CHGUSR : IsRemoteAdminMode -- RegQueryValueEx failed\n" ) );

        fMode = FALSE; // for application server
    }
    else
    {
        // dwData = 0 fMode = TRUE remote admin mode
        // dwData = 1 fMode = FALSE app server mode

        fMode = !( BOOL )dwData;
        
    }

    RegCloseKey( hKey );

    return fMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\cnvrtuc\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#define IDS_ERR_GET_PDC					100
#define IDS_ERR_CONNECT_REG				101
#define IDS_ERR_OPEN_KEY			    102
#define IDS_ERR_ENUM_KEY				103
#define IDS_CONVERTING					104
#define IDS_ERR_QUERY_CONFIG			105
#define IDS_ERR_SET_CONFIG				106
#define IDS_COMPLETE					107
#define IDS_ERR_QUERY_CONFIG2			108
#define IDS_ERR_USER_NOT_FOUND			109
#define IDS_NEWLINE						110
#define IDS_USAGE1						111
#define IDS_USAGE2						112
#define IDS_USAGE3						113
#define IDS_USAGE4						114
#define IDS_USAGE5						115
#define IDS_USAGE6						116
#define IDS_USAGE7						117
#define IDS_USAGE8						118
#define IDS_USAGE9						119
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\connect\tscon.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSCON.C
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>

#include "tscon.h"
#include "printfoa.h"

HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WINSTATIONNAME Source;
WINSTATIONNAME Destination;
WCHAR Password[ PASSWORD_LENGTH + 1 ];
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_SOURCE,       TMFLAG_REQUIRED, TMFORM_S_STRING,
                            WINSTATIONNAME_LENGTH,  Source},

  /* { TOKEN_SERVER,      TMFLAG_OPTIONAL, TMFORM_STRING,
                            MAX_IDS_LEN, ServerName}, */

   {TOKEN_DESTINATION,  TMFLAG_OPTIONAL, TMFORM_X_STRING,
                            WINSTATIONNAME_LENGTH, Destination},

   {TOKEN_PASSWORD,     TMFLAG_OPTIONAL, TMFORM_X_STRING,
                            PASSWORD_LENGTH, Password},

   {TOKEN_HELP,         TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );


/*************************************************************************
*
*  main
*     Main function and entry point of the TSCON utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    BOOLEAN bCurrent = FALSE;
    int   rc, i;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG SourceId, DestId;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*