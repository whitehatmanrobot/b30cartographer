 MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable+glyphTableLength));
            if (status != Ok)
                return status;
            c++;
        }
    }
    return status;
}

static
GpStatus ReadLegacyCmap4(
    BYTE           *glyphTable,
    INT             glyphTableLength,
    IntMap<UINT16> *cmap,
    UINT            codePage
)
{
    GpStatus status = Ok;
    // Flip the entire glyph table - it's all 16 bit words

    FlipWords(glyphTable, glyphTableLength/2);


    // Extract tables pointers and control variables from header

    Cmap4header *header = (Cmap4header*) glyphTable;

    UINT16 segCount = header->segCountX2 / 2;

    UINT16 *endCount      = (UINT16*) (header+1);
    UINT16 *startCount    = endCount      + segCount + 1;
    UINT16 *idDelta       = startCount    + segCount;
    UINT16 *idRangeOffset = idDelta       + segCount;
    UINT16 *glyphIdArray  = idRangeOffset + segCount;


    // Loop through the segments mapping glyphs

    INT i,p,c;

    for (i=0; i<segCount; i++)
    {
        INT start = startCount[i];

        // The search algorithm defined in the TrueType font file
        // specification for format 4 says 'You search for the first endcode
        // that is greater than or equal to the character code you want to
        // map'. A side effect of this is that we need to ignore codepoints
        // from the StartCount up to and including the EndCount of the
        // previous segment. Although you might not expect the StartCount of
        // a sgement to be less than the EndCount of the previous segment,
        // it does happen (Arial Unicode MS), presumably to help in the
        // arithmetic of the lookup.

        if (i  &&  start < endCount[i-1])
        {
            start = endCount[i-1] + 1;
        }

        p = HIBYTE(start);     // First page in segment
        c = LOBYTE(start);     // First character in page

        while (p < endCount[i] >> 8)
        {
            while (c<256)
            {
                WCHAR wch[2];
                WORD  mb = (WORD) (c<<8) + (WORD) p;
                INT cb = p ? 2 : 1;

                if (MultiByteToWideChar(codePage, 0, &((LPSTR)&mb)[2-cb], cb, &wch[0], 2))
                {
                    status = cmap->Insert(wch[0], MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable+glyphTableLength));
                    if (status != Ok)
                        return status;
                }

                c++;
            }
            c = 0;
            p++;
        }

        // Last page in segment

        while (c <= (endCount[i] & 255))
        {
            WCHAR wch[2];
            WORD  mb = (WORD) (c<<8) + (WORD) p;
            INT cb = p ? 2 : 1;

            if (MultiByteToWideChar(codePage, 0, &((LPSTR)&mb)[2-cb], cb, &wch[0], 2))
            {
               status = cmap->Insert(wch[0], MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable+glyphTableLength));
               if (status != Ok)
                   return status;
            }
            c++;
        }
    }
    return status;
}







////    ReadCmap12
//
//      Builds a cmap IntMap from a type 12 cmap


struct Cmap12header {
    UINT16  format0;
    UINT16  format1;
    UINT32  length;
    UINT32  language;
    UINT32  groupCount;
};

struct Cmap12group {
    UINT32  startCharCode;
    UINT32  endCharCode;
    UINT32  startGlyphCode;
};


static
GpStatus ReadCmap12(
    BYTE           *glyphTable,
    UINT            glyphTableLength,
    IntMap<UINT16> *cmap
)
{
    GpStatus status = Ok;
    UNALIGNED Cmap12header *header = (UNALIGNED Cmap12header*) glyphTable;

    FlipWords(header, 2);
    FlipDWords(&header->length, 3);

    ASSERT(header->format0 == 12);
    ASSERT(header->length <= glyphTableLength);
    ASSERT(header->groupCount*sizeof(Cmap12group)+sizeof(header) <= header->length);

    UNALIGNED Cmap12group *group = (UNALIGNED Cmap12group*)(header+1);

    FlipDWords(&group->startCharCode, 3*header->groupCount);


    // Iterate through groups filling in cmap table

    UINT  i, j;

    for (i=0; i < header->groupCount; i++) {

        for (j  = group[i].startCharCode;
             j <= group[i].endCharCode;
             j++)
        {
            status = cmap->Insert(j, group[i].startGlyphCode + j - group[i].startCharCode);
            if (status != Ok)
                return status;
        }
    }
    return status;
}


static
GpStatus ReadLegacyCmap12(
    BYTE           *glyphTable,
    UINT            glyphTableLength,
    IntMap<UINT16> *cmap,
    UINT            codePage
)
{
    GpStatus status = Ok;
    Cmap12header *header = (Cmap12header*) glyphTable;

    FlipWords(header, 2);
    FlipDWords(&header->length, 3);

    ASSERT(header->format0 == 12);
    ASSERT(header->length <= glyphTableLength);
    ASSERT(header->groupCount*sizeof(Cmap12group)+sizeof(header) <= header->length);

    UNALIGNED Cmap12group *group = (UNALIGNED Cmap12group*)(header+1);

    FlipDWords(&group->startCharCode, 3*header->groupCount);


    // Iterate through groups filling in cmap table

    UINT  i, j;

    for (i=0; i < header->groupCount; i++) {

        for (j  = group[i].startCharCode;
             j <= group[i].endCharCode;
             j++)
        {
            WCHAR wch[2];
            WORD  mb = (WORD) j;
            INT cb = LOBYTE(mb) ? 2 : 1;

            if (MultiByteToWideChar(codePage, 0, &((LPSTR)&mb)[2-cb], cb, &wch[0], 2))
            {
                status = cmap->Insert(wch[0], group[i].startGlyphCode + j - group[i].startCharCode);
                if (status != Ok)
                    return status;
            }
        }
    }
    return status;
}



#define BE_UINT16(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )

typedef struct _subHeader
{
    UINT16  firstCode;
    UINT16  entryCount;
    INT16   idDelta;
    UINT16  idRangeOffset;
} subHeader;

static
GpStatus ReadCmap2(
    BYTE           *glyphTable,
    UINT            glyphTableLength,
    IntMap<UINT16> *cmap,
    UINT            codePage
)
{
    GpStatus status = Ok;
    UINT16    *pui16SubHeaderKeys = (UINT16 *)((PBYTE)glyphTable + 6);
    subHeader *pSubHeaderArray    = (subHeader *)(pui16SubHeaderKeys + 256);

    UINT16     ii , jj;


// Process single-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        UINT16 entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        UINT16 *pui16GlyphArray;
        UINT16 hGlyph;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj != 0 ) continue;

        CurrentSubHeader = pSubHeaderArray;

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (UINT16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);


        hGlyph = (UINT16)BE_UINT16(&pui16GlyphArray[ii-firstCode]);

        if( hGlyph == 0 ) continue;

        status = cmap->Insert(ii, hGlyph);
        if (status != Ok)
            return status;
    }

    // Process double-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        UINT16 entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        UINT16 *pui16GlyphArray;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj == 0 ) continue;

        CurrentSubHeader = (subHeader *)((PBYTE)pSubHeaderArray + jj);

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (UINT16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);


        for( jj = firstCode ; jj < firstCode + entryCount ; jj++ )
        {
            UINT16 hGlyph;

            hGlyph = (UINT16)(BE_UINT16(&pui16GlyphArray[jj-firstCode]));

            if( hGlyph == 0 ) continue;

            WCHAR wch[2];
            WORD  mb = (WORD) (jj<<8) + (WORD) ii;

            if (MultiByteToWideChar(codePage, 0, (LPSTR) &mb, 2, &wch[0], 2))
            {
                status = cmap->Insert(wch[0], hGlyph + idDelta);
                if (status != Ok)
                    return status;
            }
        }
    }
    return status;
}


////    ReadCmap
//
//      Scans the font cmap table page by page filling in all except missing
//      glyphs in the cmap table.


struct cmapHeader {
    UINT16 version;
    UINT16 encodingCount;
};

struct subtableEntry {
    UINT16 platform;
    UINT16 encoding;
    UINT32 offset;
};


GpStatus ReadCmap(
    BYTE           *cmapTable,
    INT             cmapLength,
    IntMap<UINT16> *cmap,
    BOOL *          bSymbol
)
{
    GpStatus status = Ok;
    // Scan the cmap tables looking for symbol, Unicode or UCS-4 encodings

    BYTE  *glyphTable = NULL;

    // Glyph table types in priority - always choose a higher type over a
    // lower one.

    enum {
        unknown  = 0,
        symbol   = 1,    // up to 2^8  characters ay U+F000
        shiftjis = 2,    // up to 2^16 characters
        gb       = 3,    // up to 2^16 characters
        big5     = 4,    // up to 2^16 characters
        wansung  = 5,    // up to 2^16 characters
        unicode  = 6,    // up to 2^16 characters
        ucs4     = 7     // up to 2^32 characters
    } glyphTableType = unknown;

    cmapHeader *header = (cmapHeader*) cmapTable;
    subtableEntry *subtable = (subtableEntry *) (header+1);

    FlipWords(&header->version, 2);

    UINT acp = GetACP();

    for (INT i=0; i<header->encodingCount; i++)
    {
        FlipWords(&subtable->platform, 2);
        FlipDWords(&subtable->offset, 1);

        // TRACE(FONT, ("Platform %d, Encoding %d, Offset %ld", subtable->platform, subtable->encoding, subtable->offset);

        if (    subtable->platform == 3
            &&  subtable->encoding == 0
            &&  glyphTableType < symbol)
        {
            glyphTableType = symbol;
            glyphTable = cmapTable + subtable->offset;
            *bSymbol = TRUE;
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 1
                 &&  glyphTableType < unicode)
        {
            glyphTableType = unicode;
            glyphTable = cmapTable + subtable->offset;
            *bSymbol = FALSE;
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 2
                 &&  glyphTableType < shiftjis)
        {
            if (Globals::IsNt || acp == 932)
            {
                glyphTableType = shiftjis;
                glyphTable = cmapTable + subtable->offset;
                acp = 932;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 3
                 &&  glyphTableType < gb)
        {
            if (Globals::IsNt || acp == 936)
            {
                glyphTableType = gb;
                glyphTable = cmapTable + subtable->offset;
                acp = 936;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 4
                 &&  glyphTableType < big5)
        {
            if (Globals::IsNt || acp == 950)
            {
                glyphTableType = big5;
                glyphTable = cmapTable + subtable->offset;
                acp = 950;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 5
                 &&  glyphTableType < wansung)
        {
            if (Globals::IsNt || acp == 949)
            {
                glyphTableType = wansung;
                glyphTable = cmapTable + subtable->offset;
                acp = 949;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 10
                 &&  glyphTableType < ucs4)
        {
            glyphTableType = ucs4;
            glyphTable = cmapTable + subtable->offset;
            *bSymbol = FALSE;
        }

        subtable++;
    }


    #if DBG
        // const char* sTableType[4] = {"unknown", "symbol", "Unicode", "UCS-4"};
        //TRACE(FONT, ("Using %s character to glyph index mapping table", sTableType[glyphTableType]));
    #endif

    // Process format 4 or 12 tables.

    INT glyphTableLength;

    switch(glyphTableType)
    {
        case unknown:
            break;
        case symbol:
        case unicode:
        case ucs4:

            glyphTableLength = cmapLength - (INT)(glyphTable - cmapTable);

            if (*(UINT16*)glyphTable == 0x400)
                status = ReadCmap4(glyphTable, glyphTableLength, cmap);
            else if (*(UINT16*)glyphTable == 0xC00)
                status = ReadCmap12(glyphTable, glyphTableLength, cmap);
            break;
        case shiftjis:
        case gb:
        case big5:
        case wansung:
            glyphTableLength = cmapLength - (INT)(glyphTable - cmapTable);

            UINT16 testIt = *(UINT16*) glyphTable;

            if (testIt == 0x400)
                status = ReadLegacyCmap4(glyphTable, glyphTableLength, cmap, acp);
            else if (testIt == 0xC00)
                status = ReadLegacyCmap12(glyphTable, glyphTableLength, cmap, acp);
            else if (testIt == 0x200)
                status = ReadCmap2(glyphTable, glyphTableLength, cmap, acp);
            break;
    }

    return status;
}























/* Old code





////    Internal structures
//
//      Unicode lookup table
//



////    GetFontDesc - Get font type and CMAP description if present
//
//      Checks the OS/2 table to see if it is a Truetype font and whether
//      it uses a hardcoded font page.
//
//      Loads the fonts cmap table, fixes USHORTs for Intel bytesex
//      and fills in the pointers in the FONTCMAPDESC structure.
//
//      returns *piOS2Charset
//                  +ve  - Fixed font page charset
//                  -1   - Truetype big font with Unicode CMAP
//                  -2   - Not a Truetype font
//                  -3   - Truetype font with no useable CMAP


HRESULT GetFontDesc(
    HDC            hdc,          // In  hdc
    int           *piOS2Charset, // Out Charset from OS/2 table or -ve font type
    FONTCMAPDESC **ppfcd) {      // Out CMAP description for Truetype fonts only

    int             iFontDataLength;
    int             iNumEncodings;
    int             i;
    USHORT         *pusEncoding;
    ULONG           ulGlyphTableOffset;
    int             iGlyphTableType;        // 0 - Symbol, 1 - Unicode, 2 - UTF-16
    ULONG           ulGlyphTableLength;
    USHORT         *pusGlyphTable;
    HRESULT         hr;
    BYTE            bOS2Slice[4];  // fsSelection and usFirstCharIndex


    *ppfcd = NULL;

    if (GetFontData(hdc, '2/SO', 0x3E, &bOS2Slice, 4) != 4) {

        // It's not a TrueType font

        *piOS2Charset = -2;     // Not TrueType
        return S_OK;
    }


    //
    // Gutmoan Monatova font (mantm.ttf) is an old hebrew ttf font
    // that maps some glyphs into the U+0x00XX area and
    // hence the usFirstCharIndex 0x00XX.
    //
    if (    (    bOS2Slice[2] >= 0xF0
             ||  bOS2Slice[2] == 0x00)
        &&  bOS2Slice[0]) {

        // First character at or above U+F000 or < 256
        // It's a symbol font with a Windows hardcoded charset

        *piOS2Charset = bOS2Slice[0];

    } else {

        *piOS2Charset = -1;     // Truetype big font
    }


    // Load and inspect the CMAP

    iFontDataLength = GetFontData(hdc, 'pamc', 0, NULL, 0);
    if (iFontDataLength <= 0) {
        TRACE(FONT, ("Couldn\'t find CMAP table"));

        *piOS2Charset = -3;     // Unusable CMAP
        return S_OK;
    }


    hr = USPALLOC(iFontDataLength+sizeof(FONTCMAPDESC), (void **) ppfcd);
    if (FAILED(hr)) {
        TRACEMSG(("Assertion failure - Not enough memory to load font CMAP data"));

        *piOS2Charset = -3;     // Unusable CMAP
        return S_OK;;
    }

    (*ppfcd)->pbFontCmapData = (BYTE*)((*ppfcd)+1);  // Font cmap data directly follows cmap description
    (*ppfcd)->iFontCmapLen   = iFontDataLength;      // For validation in MapGlyph


    if ((INT)GetFontData(hdc, 'pamc', 0, (*ppfcd)->pbFontCmapData, iFontDataLength) < iFontDataLength) {
        USPFREE((*ppfcd));
        TRACEMSG(("Assertion failure: GetFontData couldn't load font CMAP data"));

        *piOS2Charset = -3;     // Unusable CMAP
        return S_OK;;
    }


    TRACE(FONT, ("Font cmap data loaded - length %d bytes at %-8.8x", iFontDataLength, (*ppfcd)->pbFontCmapData));


    // Scan the encoding tables

    FlipWords(&((PUSHORT)(*ppfcd)->pbFontCmapData)[1], 1);
    iNumEncodings = ((PUSHORT)(*ppfcd)->pbFontCmapData)[1];
    pusEncoding = &((PUSHORT)(*ppfcd)->pbFontCmapData)[2];

    TRACE(FONT, ("iNumEncodings %d, pusEncoding %-8.8x", iNumEncodings, pusEncoding));


    // Scan for and record offset of symbol, unicode or UTF-16 encoding table -
    // Priority is UTF-16, Unicode, Symbol.
    // When there are many of the same type, takes the first of the highest
    // priority type.

    ulGlyphTableOffset = 0;
    iGlyphTableType    = 0;  // Symbol 1, Unicode 2, UTF-16 3.

    for (i=0; i<iNumEncodings; i++) {

        FlipWords(pusEncoding, 2);
        FlipDWords((PULONG)&pusEncoding[2], 1);

        TRACE(FONT, ("Platform %d, Encoding %d, Offset %ld", pusEncoding[0], pusEncoding[1], ((PULONG)pusEncoding)[1]));

        if (pusEncoding[0] == 3 && pusEncoding[1] == 0) {
            if (iGlyphTableType < 1) {
                // Record symbol encoding offset
                ulGlyphTableOffset = ((PULONG)pusEncoding)[1];
                iGlyphTableType = 1;
            }
        } else if (pusEncoding[0] == 3 && pusEncoding[1] == 1) {
            if (iGlyphTableType < 2) {
                // Record unicode encoding offset
                ulGlyphTableOffset = ((PULONG)pusEncoding)[1];
                iGlyphTableType   = 2;
            }
        } else if (pusEncoding[0] == 3 && pusEncoding[1] == 10) {
            if (iGlyphTableType < 3) {
                // Record unicode encoding offset
                ulGlyphTableOffset = ((PULONG)pusEncoding)[1];
                iGlyphTableType = 3;
            }
        }

        pusEncoding += 4;   // Advance 4 words to next encoding
    }


    if (!ulGlyphTableOffset) {
        TRACE(FONT, ("Font includes no suitable character to glyph index mapping table"));
        USPFREE(*ppfcd);

        *piOS2Charset = -3; // Unusable CMAP
        return S_OK;
    }

    #if DBG
        const char* sTableType[4] = {"erroneous", "symbol", "Unicode", "UTF-16"};
        TRACE(FONT, ("Using %s character to glyph index mapping table", sTableType[iGlyphTableType]));
    #endif


    // Check format of encoding table

    pusGlyphTable = (PUSHORT)&(*ppfcd)->pbFontCmapData[ulGlyphTableOffset];

    FlipWords(pusGlyphTable, 1);    // Table format
    switch (*pusGlyphTable) {

        case 4:
            // Note - don't get the length from pusGlyphTable[1], although it is
            // documented as the length. pusGlyphTable[1] is limited to 16 bits but
            // the glyph table may be longer than 64k.
            // Treat the length as the entire remainder of the CMAP, including
            // any other subtable types.

            ulGlyphTableLength = iFontDataLength - ulGlyphTableOffset;

            // Flip remainder of format 4 glyph index table (luckily it is entirely USHORTs)
            FlipWords((PUSHORT)&pusGlyphTable[2], (ulGlyphTableLength-4)/2);

            // Fill in (*ppfcd) members

            (*ppfcd)->iType            = 4;
            (*ppfcd)->usSegCount       = pusGlyphTable[3] / 2;
            (*ppfcd)->pusEndCount      = &pusGlyphTable[7];
            (*ppfcd)->pusStartCount    = &(*ppfcd)->pusEndCount     [(*ppfcd)->usSegCount+1];
            (*ppfcd)->pusIdDelta       = &(*ppfcd)->pusStartCount   [(*ppfcd)->usSegCount];
            (*ppfcd)->pusIdRangeOffset = &(*ppfcd)->pusIdDelta      [(*ppfcd)->usSegCount];
            (*ppfcd)->pusGlyphIdArray  = &(*ppfcd)->pusIdRangeOffset[(*ppfcd)->usSegCount];

            TRACE(FONT, ("Format 4 glyph table at %-8.8x length %d containing", pusGlyphTable, ulGlyphTableLength));
            TRACE(FONT, ("  usSegCount %d", (*ppfcd)->usSegCount));
            TRACE(FONT, ("  pusEndCount %-8.8x", (*ppfcd)->pusEndCount));
            TRACE(FONT, ("  pusStartCount %-8.8x", (*ppfcd)->pusStartCount));
            TRACE(FONT, ("  pusIdDelta %-8.8x", (*ppfcd)->pusIdDelta));
            TRACE(FONT, ("  pusIdRangeOffset %-8.8x", (*ppfcd)->pusIdRangeOffset));
            TRACE(FONT, ("  pusGlyphIdArray %-8.8x:s", (*ppfcd)->pusGlyphIdArray));

            #if DBG
                if (debug & TRACE_FONT) {
                    char lbuf[200];
                    char *plb;

                    for (i=0; i<32; i++) {
                        if (i%8 == 0) {
                            plb = lbuf + wsprintfA(lbuf, "    %-2.2x: ", i);
                        }
                        plb += wsprintfA(plb, "%-4.4x ", (*ppfcd)->pusGlyphIdArray[i]);
                        if (i%8 == 7) {
                            TRACEMSG((lbuf));
                        }
                    }
                    if (i%8) {
                        TRACEMSG((lbuf));
                    }
                }
            #endif
            break;


        case 12:

            // Get length from format 12 header

            FlipDWords(((PULONG)pusGlyphTable)+1, 1);
            ulGlyphTableLength = ((PULONG)pusGlyphTable)[1];

            ASSERT(ulGlyphTableLength <= iFontDataLength - ulGlyphTableOffset);
            if (ulGlyphTableLength > iFontDataLength - ulGlyphTableOffset) {
                ulGlyphTableLength = iFontDataLength - ulGlyphTableOffset;
            }

            // Remainder of table is DWORDS, flip them.

            FlipDWords(((PULONG)pusGlyphTable)+2, ulGlyphTableLength/4 -2);

            // Fill in (*ppfcd) members

            (*ppfcd)->iType   = 12;
            (*ppfcd)->nGroups = ((PULONG)pusGlyphTable)[3];
            (*ppfcd)->pcg     = (CMAP12GROUP*)&((PULONG)pusGlyphTable)[4];

            TRACE(FONT, ("Format 12 glyph table at %-8.8x length %d nGroups %i",
                         pusGlyphTable, ulGlyphTableLength, (*ppfcd)->nGroups));
            break;

        default:
            TRACEMSG(("Assertion failure: Unrecognised glyph table format %d, expecting 4 or 12", *pusGlyphTable));
            USPFREE((*ppfcd));
            *piOS2Charset = -3; // Unusable CMap
            return S_OK;
    }



    return S_OK;
}












////    GetCmapFontPagesPresent
//
//      fills in a bitmap of pages present.
//
//      The caller should pass back the font cmap descriptor
//      to LoadCmapTable, and then free it.


BOOL GetCmapFontPagesPresent(
    HDC           hdc,
    BYTE         *pbmPages,
    FONTCMAPDESC *pfcd) {

    int  i;
    int  j;
    int  p; // Unicode page
    int  c; // Character index into page
    int  iStartCount;


    ASSERT(    pfcd->iType == 4
           ||  pfcd->iType == 12);

    switch (pfcd->iType) {

        case 4:
            // Iterate through the segments flagging unicode pages present

            for (i=0; i<pfcd->usSegCount; i++) {

                iStartCount = pfcd->pusStartCount[i];

                // The search algorithm defined in the TrueType font file
                // specification for format 4 says 'You search for the first endcode
                // that is greater than or equal to the character code you want to
                // map'. A side effect of this is that we need to ignore codepoints
                // from the StartCount up to and including the EndCount of the
                // previous segment. Although you might not expect the StartCount of
                // a sgement to be less than the EndCount of the previous segment,
                // it does happen (Arial Unicode MS), presumably to help in the
                // arithmetic of the lookup.

                if (i  &&  iStartCount < pfcd->pusEndCount[i-1]) {
                    iStartCount = pfcd->pusEndCount[i-1] + 1;
                }

                // For each page in this segment, check it doesn't entirely map to 'missing'

                p = HIBYTE(iStartCount);     // First page in segment
                c = LOBYTE(iStartCount);     // First character in page
                TRACE(FONT, ("Segment %d starts at page %x char %x", i, p, c));

                // Scan all but last page
                while (p < HIBYTE(pfcd->pusEndCount[i])) {
                    while (c<256 && !MapGlyph(p, c, i, pfcd)) {
                        c++;
                    }
                    if (c<256) { // This page is used
                        pbmPages[p/8] |= 1<<p%8;
                    }
                    p++;
                    c=0;
                }

                // Check last page of segment
                TRACE(FONT, ("Last page of segment %d at page %x char %x", i, p, c));
                while (c <= LOBYTE(pfcd->pusEndCount[i]) && !MapGlyph(p, c, i, pfcd)) {
                    c++;
                }
                if (c <= LOBYTE(pfcd->pusEndCount[i])) { // This page is used
                    pbmPages[p/8] |= 1<<p%8;
                }
            }
            break;


        case 12:

            // Iterate through groups flagging Unicode pages and surrogate
            // ranges present.


            for (i=0; i<pfcd->nGroups; i++) {

                for (j  = pfcd->pcg[i].iStartCharCode>>8;
                     j <= pfcd->pcg[i].iEndCharCode>>8;
                     j++) {

                    pbmPages[j/8] |= 1<<j%8;
                }
            }

            pbmPages[0xd8/8] = 0xff;   // Mark entire surrogate range as present

            break;
    }

    return TRUE;
}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\bidianalysis.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Header file for BiDiAnalysis.cpp
*
* Revision History:
*
*   02/25/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

#ifndef _BIDI_ANALYSIS_HPP
#define _BIDI_ANALYSIS_HPP
#ifdef __cplusplus
extern "C" {
#endif

#define ODD(x) ((x) & 1)


// Implementation of a Bidirectionl embedding stack

class GpBiDiStack
{
private:
    UINT64 m_Stack;
    BYTE   m_CurrentStackLevel;
    
public:
    GpBiDiStack() {m_CurrentStackLevel = 0;}
    BOOL   Init (UINT64 initialStack);
    BOOL   Push(BOOL pushToGreaterEven);
    BOOL   Pop();
    BYTE   GetStackBottom() {return GetMinimumLevel(m_Stack);}
    BYTE   GetCurrentLevel() {return m_CurrentStackLevel;}
    UINT64 GetData() {return m_Stack;}
private:
    BYTE   GetMaximumLevel(UINT64 stack);
    BYTE   GetMinimumLevel(UINT64 stack);
    BYTE   GreaterEven(BYTE level) {return ODD(level) ? (BYTE)(level + 1) : (BYTE)(level + 2);}
    BYTE   GreaterOdd(BYTE level) {return ODD(level) ? (BYTE)(level + 2) : (BYTE)(level + 1);}
};


// Bidirectional character classification
// Be careful about order as it is used for indexing.


extern "C" const GpCharacterClass s_aDirClassFromCharClass[];

/////   BidiAnalysisFlags
//
//      BidiParagraphDirectionRightToLeft: Right to left paragraph. Paragraph
//          direction defaults to left-to-right.
//          Ignored if BidiContinueAnalysis flag also set.
//
//      BidiParagraphDirectionAsFirstStrong: Paragragraph direction determined
//          by scanning for the first strongly directed character. If no
//          strongly directed characters are found, defaults to setting of
//          BidiParagraphDirectioRightToLeft flag.
//          Ignored if BidiContinueAnalysis flag also set.
//
//      BidiPreviousStrongIsArabic: Parse numbers as if the paragraph
//          were preceeded by an Arabic letter.
//          Ignored if BidiContinueAnalysis flag also set.
//
//      BidiContinueAnalysis: This analysis is a continuation. The 'state'
//          parameter to UnicodeBidiAnalysis provides the state at the
//          end of the previously analysed block.
//          This flag causes the BidiParagraphDirectioRightToLeft,
//          BidiParagraphDirectionAsFirstStrong, and
//          BidiPreviousStrongIsArabic flags to be ignored: there value is
//          obtained from the state structure.
//
//      BidiBufferNotComplete: Indicates that the buffer passed may not
//          end on a paragraph boundary, and that futher calls to
//          UnicodeBidiAnalysis will be made to pass subsequent buffers and
//          thereby resolve trailing neutral characters. If the
//          BidiBufferNotComplete flag is set, the 'state' and
//          'lengthAnalyzed' parameters must be supplied to
//          UnicodeBidiAnalyze.
//
//



enum BidiAnalysisFlags 
{
    BidiParagraphDirectioRightToLeft      = 0x01,
    BidiParagraphDirectionAsFirstStrong   = 0x02,
    BidiPreviousStrongIsArabic            = 0x04,
    BidiContinueAnalysis                  = 0x08,
    BidiBufferNotComplete                 = 0x10
};

struct BidiAnalysisState 
{
    UINT64    LevelsStack;
    UINT64    OverrideStatus;
    BYTE      LastFinalCharacterType;
    BYTE      LastNumericCharacterType;
    INT       StackOverflow;
};

/////   UnicodeBidiAnalyze
//
//      lengthAnalyzed: (optional) returns the number of characters that were
//          unambiguously resolved. This value may be less than the string
//          less if the BidiBufferNotComplete flag was passed, and for example
//          if the input string terminated on neutral (non-directed)
//          characters.
//          The lengthAnalyzed output parameter must be passed if the
//          BidiBufferNotComplete flag has been set.
//          If the BidiBufferNotComplete flag is not set, the whole string will
//          always be analyzed.

Status WINGDIPAPI UnicodeBidiAnalyze(
    const WCHAR       *string,
    INT                stringLength,
    BidiAnalysisFlags  flags,
    BidiAnalysisState *state,
    BYTE              *levels,
    INT               *lengthAnalyzed
    );
#ifdef __cplusplus
}
#endif
#endif // _BIDI_ANALYSIS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\digitsubstitution.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Header file for DigitSubstitution.cpp
*
* Revision History:
*
*   05/30/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

extern enum ItemScript;

#define IsDBCSCodePage(acp)  ((acp) == 932 || \
                              (acp) == 936 || \
                              (acp) == 949 || \
                              (acp) == 950 )


const ItemScript GetDigitSubstitutionsScript(GpStringDigitSubstitute substitute, LANGID language);
LANGID GetUserLanguageID();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\builtline.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Full text imager implementation
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
*   06/12/2000 Worachai Chaoweeraprasit (wchao)
*       Trimming, querying and ellipsis
*
\**************************************************************************/



#include "precomp.hpp"


/////   BuiltLine
//
//      Creates a built line using LIne Services


BuiltLine::BuiltLine (
    ols             *lineServicesOwner,         // [IN] Line Services context
    INT             stringIndex,                // [IN] string start index
    LSCP            lineServicesStartIndex,     // [IN] Line Services string start index
    StringTrimming  trimming,                   // [IN] how to end the line
    BuiltLine       *previousLine,              // [IN] previous line
    BOOL            forceEllipsis               // [IN] enforce trim ellipsis?
)
:   LsLine                      (NULL),
    LsContext                   (NULL),
    LsStartIndex                (lineServicesStartIndex),
    StartIndex                  (stringIndex),
    LsCharacterCount            (0),
    CharacterCount              (0),
    Ascent                      (0),
    Descent                     (0),
    LineLength                  (0),
    BreakRecord                 (NULL),
    BreakRecordCount            (0),
    LeftOrTopMargin             (0),
    RightOrBottomMargin         (0),
    MaxSublineCount             (0),
    Trimming                    (StringTrimmingNone),
    AlignmentOffset             (0),
    EllipsisPointOffset         (0),
    LeftOrTopGlyphEdge          (0),
    LastVisibleRun              (NULL),
    DisplayPlacements           (NULL),
    DisplayBaselineAdjust       (0),
    Status                      (GenericError)
{
    Imager = lineServicesOwner->GetImager();

    LsContext = lineServicesOwner->GetLsContext();

    // Get useful formatting options

    Imager->BuildRunsUpToAndIncluding(lineServicesStartIndex);

    const GpStringFormat *format = SpanRider<const GpStringFormat*>(&Imager->FormatVector)[stringIndex];

    REAL idealEm = Imager->SizeVector.GetDefault() * Imager->WorldToIdeal;

    INT  formatFlags;

    if (format)
    {
        LeftOrTopMargin     = GpRound(idealEm * format->GetLeadingMargin());
        RightOrBottomMargin = GpRound(idealEm * format->GetTrailingMargin());
        formatFlags         = format->GetFormatFlags();
    }
    else
    {
        LeftOrTopMargin     = GpRound(idealEm * DefaultMargin);
        RightOrBottomMargin = GpRound(idealEm * DefaultMargin);
        formatFlags         = DefaultFormatFlags;
    }


    // Establish overall layour rectangle line length including margins

    INT lineLengthLimit = GpRound(Imager->LineLengthLimit * Imager->WorldToIdeal);


    // Determine formatting width limit

    INT formattingWidth;

    if (   lineLengthLimit <= 0
        || (   formatFlags & StringFormatFlagsNoWrap
            && trimming == StringTrimmingNone))
    {
        formattingWidth = INFINITE_LINELIMIT; // Effectively unlimited.
    }
    else
    {
        formattingWidth = lineLengthLimit - (LeftOrTopMargin + RightOrBottomMargin);
        //TERSE(("Width: %x\n", width));

        if (formattingWidth <= 0)
        {
            // What to do?
            formattingWidth = 0;
        }
    }


    //  Create the line

    Status = CreateLine (
                stringIndex,
                formattingWidth,
                trimming,
                formatFlags,
                forceEllipsis,
                previousLine
             );

    if (Status != Ok)
    {
        return;
    }

    ASSERT(   CharacterCount <= 0
           || StartIndex + CharacterCount >= Imager->Length
           || (Imager->String[StartIndex + CharacterCount - 1] & 0xFC00) != 0xD800
           || (Imager->String[StartIndex + CharacterCount] & 0xFC00) != 0xDC00);


    INT lineLengthPlusMargins = LineLength + LeftOrTopMargin + RightOrBottomMargin;


    // Establish alignment offset

    StringAlignment physicalAlignment = StringAlignmentNear;  // After appying RTL effect

    if (format)
    {
        physicalAlignment = format->GetPhysicalAlignment();
    }


    // Apply physical alignment generating AlignmentOffset - the distance
    // from the origin of the formatting rectangle to the leading end of the
    // line.

    if (physicalAlignment != StringAlignmentNear)
    {
        if (lineLengthLimit > 0)
        {
            // Align within rectangle
            AlignmentOffset = lineLengthLimit - lineLengthPlusMargins;
        }
        else
        {
            // Align around origin
            AlignmentOffset = -lineLengthPlusMargins;
        }

        if (physicalAlignment == StringAlignmentCenter)
        {
            AlignmentOffset /= 2;
        }
    }

    // Record line edges before adjusting AlignmentOffset for RTL.

    LeftOrTopGlyphEdge = AlignmentOffset + LeftOrTopMargin;


    // AlignmentOffset is currently the offset from the origin of the
    // formatting rectangle to the left end of the whole line, including
    // margins.

    // The offset needs to be adjusted over the margin. Additionally
    // for an RTL paragraph the offset is to the right end.

    if (    formatFlags & StringFormatFlagsDirectionVertical
        ||  !(formatFlags & StringFormatFlagsDirectionRightToLeft))
    {
        AlignmentOffset += LeftOrTopMargin;
    }
    else
    {
        AlignmentOffset += LineLength + LeftOrTopMargin;
    }

    Status = Ok;
}




/////   CreateLine
//
//      All stuffs concerning text in a line should be here instead of in the
//      BuiltLine's constructor. The idea is to separate the text line from
//      line decorations like margins or alignment.
//

GpStatus BuiltLine::CreateLine (
    INT             stringIndex,            // [IN] string start position
    INT             lineLengthLimit,        // [IN] line length limit (excluding margins)
    StringTrimming  trimming,               // [IN] string trimming
    INT             formatFlags,            // [IN] format flags
    BOOL            forceEllipsis,          // [IN] enforce trim ellipsis?
    BuiltLine       *previousLine           // [IN] previous line
)
{
    INT formattingWidth = lineLengthLimit;

    if (trimming == StringTrimmingEllipsisPath)
    {
        //  Built the whole paragraph up in one line, so we know how to shrink it
        //  to fit in the line limit boundary.

        formattingWidth = INFINITE_LINELIMIT;
    }


    GpStatus    status;
    LSLINFO     lineInfo;
    BREAKREC    brkRecords[MAX_BREAKRECORD];
    DWORD       brkCount;


    status = CreateLineCore (
        formattingWidth,
        trimming,
        previousLine,
        MAX_BREAKRECORD,
        brkRecords,
        &brkCount,
        &lineInfo
    );

    if (status != Ok)
    {
        return status;
    }


    //  Trimming requested is not always the trimming done.
    //  We record the trimming being done for the line.

    switch (trimming)
    {
        case StringTrimmingWord :
        case StringTrimmingCharacter :
        {
            if (lineInfo.endr != endrEndPara)
            {
                Trimming = trimming;
            }
            break;
        }

        case StringTrimmingEllipsisWord :
        case StringTrimmingEllipsisCharacter:
        {
            if (   forceEllipsis
                || lineInfo.endr != endrEndPara)
            {
                GpStatus status = RecreateLineEllipsis (
                    stringIndex,
                    lineLengthLimit,
                    trimming,
                    formatFlags,
                    &lineInfo,
                    previousLine,
                    &Trimming,
                    &lineInfo
                );

                if (status != Ok)
                {
                    return status;
                }
            }
            break;
        }
    }

    if(   Trimming != StringTrimmingNone
       && Trimming != StringTrimmingEllipsisPath)
    {
        //  By definition, trimming at the end would mean the text continues
        //  thus, no traling spaces to be displayed (410525).
        
        formatFlags &= ~StringFormatFlagsMeasureTrailingSpaces;
    }

    if (   brkCount > 0
        && lineInfo.endr != endrEndPara
        && Trimming == StringTrimmingNone)
    {

        //  No need to cache break records for the last line
        //  of paragraph as it's supposed to be balance. This
        //  including lines with trimming as we know such line
        //  spans to the nearest paragraph mark.


        BreakRecord = new BREAKREC [brkCount];

        if (!BreakRecord)
        {
            return OutOfMemory;
        }

        BreakRecordCount = brkCount;
        GpMemcpy (BreakRecord, brkRecords, sizeof(BREAKREC) * brkCount);
    }


    Ascent      = lineInfo.dvpAscent;
    Descent     = lineInfo.dvpDescent;

    if (lineInfo.dvpMultiLineHeight == dvHeightIgnore)
    {
        // Paragraph is empty. We have to work out the line spacing ourselves.

        const GpFontFamily *family = SpanRider<const GpFontFamily *>(&Imager->FamilyVector)
                                     [stringIndex];
        INT                 style  = SpanRider<INT>(&Imager->StyleVector)
                                     [stringIndex];
        REAL                emSize = SpanRider<REAL>(&Imager->SizeVector)
                                     [stringIndex];
        const GpFontFace   *face   = family->GetFace(style);

        if (!face)
        {
            return FontStyleNotFound;
        }

        REAL fontToIdeal = (emSize / face->GetDesignEmHeight()) * Imager->WorldToIdeal;

        LineSpacing = GpRound(float(   face->GetDesignLineSpacing()
                                    *  fontToIdeal));;
    }
    else
    {
        LineSpacing = lineInfo.dvpMultiLineHeight;
    }


    CheckUpdateLineLength (formatFlags & StringFormatFlagsMeasureTrailingSpaces);

    CheckUpdateCharacterCount(
        stringIndex,
        lineInfo.cpLim
    );

    return Ok;
}




GpStatus BuiltLine::CreateLineCore (
    INT             formattingWidth,        // [IN] formatting boundary
    StringTrimming  trimming,               // [IN] trimming type
    BuiltLine       *previousLine,          // [IN] previous line
    UINT            maxBrkCount,            // [IN] maximum number of break records
    BREAKREC        *brkRecords,            // [OUT] break records
    DWORD           *brkCount,              // [OUT] break record count
    LSLINFO         *lineInfo               // [OUT] line information
)
{
    //  Line ends with line break opportunity?

    Imager->TruncateLine =    trimming == StringTrimmingCharacter
                           || trimming == StringTrimmingEllipsisCharacter;


    LSERR lserror = LsCreateLine(
        LsContext,
        LsStartIndex,
        formattingWidth,
        (previousLine ? previousLine->GetBreakRecord() : NULL),
        (previousLine ? previousLine->GetBreakRecordCount() : 0),
        maxBrkCount,
        brkRecords,
        brkCount,
        lineInfo,
        &LsLine
    );

    if (lserror != lserrNone)
    {
        TERSE (("line creation fails - lserror: %d\n", lserror));
        return GenericError;
    }

    MaxSublineCount  = lineInfo->nDepthFormatLineMax;
    LsCharacterCount = lineInfo->cpLim - LsStartIndex;

    return Ok;
}




GpStatus BuiltLine::RecreateLineEllipsis (
    INT             stringIndex,            // [IN] line start index
    INT             lineLengthLimit,        // [IN] line length limit
    StringTrimming  trimmingRequested,      // [IN] kind of trimming requested
    INT             formatFlags,            // [IN] format flags
    LSLINFO         *lineInfoOriginal,      // [IN] original line's properties
    BuiltLine       *previousLine,          // [IN] previous line
    StringTrimming  *trimmingDone,          // [OUT] kind of trimming implemented
    LSLINFO         *lineInfoNew            // [OUT] new line properties
)
{
    StringTrimming  trimming = trimmingRequested;

    ASSERT (   trimming == StringTrimmingEllipsisWord
            || trimming == StringTrimmingEllipsisCharacter);


    GpStatus status = Ok;

    const EllipsisInfo *ellipsis = Imager->GetEllipsisInfo();

    if (!ellipsis)
    {
        return OutOfMemory;
    }

    if (ellipsis->Width > lineLengthLimit / 2)
    {
        switch (trimming)
        {
            case StringTrimmingEllipsisWord :
                trimming = StringTrimmingWord;
                break;

            case StringTrimmingEllipsisCharacter :
                trimming = StringTrimmingCharacter;
                break;
        }
    }
    else
    {
        LsDestroyLine(LsContext, LsLine);

        BREAKREC    brkRecords[MAX_BREAKRECORD];
        DWORD       brkCount;

        status = CreateLineCore (
            lineLengthLimit - ellipsis->Width,
            trimming,
            previousLine,
            MAX_BREAKRECORD,
            brkRecords,
            &brkCount,
            lineInfoNew
        );

        if (status != Ok)
        {
            return status;
        }

        CheckUpdateCharacterCount(
            stringIndex,
            lineInfoNew->cpLim
        );
        

        //  By definition, trimming at the end would mean the text continues
        //  thus, no traling spaces to be displayed (410525).

        CheckUpdateLineLength (0);

        //  Append ellipsis at the end,
        //  we need to increase the line length by ellipsis size.

        EllipsisPointOffset = LineLength;
        LineLength += ellipsis->Width;
    }

    //  what we've done.

    *trimmingDone = trimming;

    return status;
}




GpStatus BuiltLine::TrimText (
    INT         stringOffset,           // [IN] string offset from line start
    INT         stringLength,           // [IN] string length
    INT         size,                   // [IN] string size in ideal unit
    INT         sizeLimit,              // [IN] maximum possible string size
    LSQSUBINFO  *sublines,              // [IN] LS sublines
    INT         maxSublineCount,        // [IN] valid subline count
    INT         ellipsisLength,         // [IN] character length of ellipsis string
    INT         *trimmedLength,         // [IN/OUT] number of character being trimmed out
    BOOL        leadingTrim             // [IN] TRUE - trim from the first character onward
)
{
    ASSERT (sublines && trimmedLength);

    GpStatus status = Ok;

    INT length = stringOffset;
    INT trimmed = 0;
    INT delta = 0;      // the difference because of snapping

    if (leadingTrim)
    {
        while (   trimmed < stringLength
               && (   size > sizeLimit
                   || trimmed < ellipsisLength))
        {
            trimmed++;
            length++;

            status = CalculateStringSize (
                length,
                sublines,
                maxSublineCount,
                SnapForward,
                &size,
                &delta
            );

            if (status != Ok)
            {
                return status;
            }

            size = LineLength - size;

            length  += delta;
            trimmed += delta;
        }
    }
    else
    {
        length += stringLength;

        while (   trimmed < stringLength
               && (   size > sizeLimit
                   || trimmed < ellipsisLength))
        {
            trimmed++;
            length--;

            status = CalculateStringSize (
                length,
                sublines,
                maxSublineCount,
                SnapBackward,
                &size,
                &delta
            );

            if (status != Ok)
            {
                return status;
            }

            length  += delta;
            trimmed += abs(delta);
        }
        
        if (Imager->GetFormatHotkeyPrefix() != HotkeyPrefixNone)
        {
            //  If we process hotkey, we cant leave 0xffff visible but orphaned
            //  outside the trimmed text, though it may appear to be a standalone 
            //  cluster now. Because clusters may change after replacing ellipsis 
            //  chars to hidden out some text.
            //
            //  When this trimmed text is eventually be hidden out. For LS, that
            //  means we're asking them to split the 0xffff apart from its hotkey 
            //  character. When that happens, in most cases, we are intentionally
            //  breaking a cluster. (wchao, #366190)

            const WCHAR *string = &Imager->String[StartIndex + stringOffset];
            
            while (   trimmed < stringLength
                   && string[stringLength - trimmed - 1] == WCH_IGNORABLE)
            {
                trimmed++;
            }
        }
    }

    *trimmedLength += trimmed;  // Note: this is an in/out param !
    return status;
}




/////   Path ellipsis
//
//      Scan through the whole line finding the character range to be omitted by ellipsis.
//      Since the presence of ellipsis affects bidi layout, we eventually need to update
//      the character backing store with ellipsis. Note that cp won't change, the rest of
//      the omitted text will only be hidden out.
//

GpStatus BuiltLine::UpdateContentWithPathEllipsis (
    EllipsisInfo    *ellipsis,          // [IN] ellipsis info
    INT             lineLengthLimit,    // [IN] line length limit including margins
    BOOL            *contentChanged     // [IN/OUT] content changed?
)
{
    //  exclude margins

    lineLengthLimit -= (LeftOrTopMargin + RightOrBottomMargin);


    if (lineLengthLimit <= ellipsis->Width)
    {
        //  do nothing, the line has no room to fill any text

        return Ok;
    }


    GpStatus status = Ok;

    INT fixedOffset;

    for (fixedOffset = CharacterCount - 1; fixedOffset > 0; fixedOffset--)
    {
        if (Imager->String[StartIndex + fixedOffset] == '\\')
        {
            break;
        }
    }


    if (LineLength > lineLengthLimit)
    {
        ASSERT (MaxSublineCount > 0);

        AutoArray<LSQSUBINFO> sublines(new LSQSUBINFO [MaxSublineCount]);

        if (!sublines)
        {
            return OutOfMemory;
        }


        INT fixedSize       = 0;
        INT variedSize      = 0;

        status = CalculateStringSize (
            fixedOffset,
            sublines.Get(),
            MaxSublineCount,
            SnapNone,   // need not snap, we know it's bounded
            &variedSize
        );

        if (status != Ok)
        {
            return status;
        }

        fixedSize = LineLength - variedSize;
        INT remaining = lineLengthLimit - fixedSize - ellipsis->Width;

        INT ellipsisLength = ellipsis->GlyphCount;
        INT trimmed = 0;


        if (remaining <= 0)
        {
            //  Fixed text is longer than the line limit
            //
            //  Reduce the back half of fixed text so it fits within the back half of the line
            //  before start reducing remaining text. The idea is to place ellipsis half way
            //  in the line regardless how the final text may eventually look like.

            INT delta = 0;

            fixedOffset = CharacterCount / 2;

            status = CalculateStringSize (
                fixedOffset,
                sublines.Get(),
                MaxSublineCount,
                SnapForward,
                &variedSize,
                &delta
            );

            if (status != Ok)
            {
                return status;
            }

            fixedOffset += delta;
            fixedSize = LineLength - variedSize;

            INT halfLineLengthLimit = (lineLengthLimit - ellipsis->Width) / 2;

            status = TrimText (
                fixedOffset,
                CharacterCount - fixedOffset,
                fixedSize,
                halfLineLengthLimit,
                sublines.Get(),
                MaxSublineCount,
                ellipsisLength,
                &trimmed,
                TRUE    // leading characters off!
            );

            if (status != Ok)
            {
                return status;
            }

            //  Now move fixed offse to the right place and
            //  recalculate remaining space

            fixedOffset += trimmed;
            remaining = lineLengthLimit - halfLineLengthLimit - ellipsis->Width;
        }


        //  Fit the rest into the remaining space

        ASSERT(remaining > 0);

        status = TrimText (
            0,
            fixedOffset - trimmed,
            variedSize,
            remaining,
            sublines.Get(),
            MaxSublineCount,
            ellipsisLength,
            &trimmed
        );

        if (status != Ok)
        {
            return status;
        }

        if (   trimmed <= fixedOffset
            && trimmed >= ellipsisLength)
        {
            //  Place ellipsis in front of fixed text

            for (INT i = ellipsisLength; i > 0; i--)
            {
                Imager->String[StartIndex + fixedOffset - i] = ellipsis->String[ellipsisLength - i];
                *contentChanged = TRUE;
            }

            //  Hide the rest

            if (trimmed > ellipsisLength)
            {
                //  Place dot up to the first character being trimmed,
                //  the idea is to have the whole trimmed text becomes
                //  a series of neutral characters

                for (INT i = fixedOffset - ellipsisLength - 1; i >= fixedOffset - trimmed; i--)
                {
                    Imager->String[StartIndex + i] = '.';
                }

                if (   Imager->GetFormatHotkeyPrefix() != HotkeyPrefixNone
                    && StartIndex > 0 
                    && fixedOffset - trimmed == 0)
                {
                    //  If the line is trimmed up to the first character, check
                    //  if the last characters of the previous line are hotkey
                    //  0xffff. If so, eat them up as well. 
                    //
                    //  The reason is that we should never leave 0xffff visible
                    //  but orphaned. We'll be rebuilding the line after we're done
                    //  hiding out part of text and that orphaned 0xffff will cause
                    //  LS to break the cluster in FetchRun (wchao, #360699).
                    
                    INT backing = StartIndex;
                    while (   backing > 0
                           && Imager->String[backing - 1] == WCH_IGNORABLE)
                    {
                        backing--;
                        trimmed++;
                    }
                }

                status = Imager->VisibilityVector.SetSpan(
                    StartIndex + fixedOffset - trimmed,
                    trimmed - ellipsisLength,
                    VisibilityHide
                );
                if (status != Ok)
                    return status;

                *contentChanged = TRUE;

                Trimming = StringTrimmingEllipsisPath;
            }
        }
    }

    return status;
}




GpStatus BuiltLine::CheckUpdateLineLength (
    BOOL    trailingSpacesIncluded, // [IN] including trailing spaces?
    BOOL    forceUpdate             // [IN] (optional) force updating?
)
{
    GpStatus status = Ok;

    if (   forceUpdate
        || !LineLength)
    {
        status = CalculateLineLength (
            trailingSpacesIncluded,
            &LineLength
        );
    }
    return status;
}




GpStatus BuiltLine::CheckUpdateCharacterCount(
    INT             stringIndex,                // [IN] line start string index
    LSCP            lineLimitIndex,             // [IN] Line Services line limit index
    BOOL            forceUpdate                 // [IN] (optional) force updating?
)
{
    GpStatus status = Ok;

    if (   forceUpdate
        || !CharacterCount)
    {
        status = CalculateCharacterCount (
            stringIndex,
            lineLimitIndex,
            &CharacterCount
        );
    }
    return status;
}





/////   GetUntrimmedCharacterCount
//
//      Because of trimming, the number of character built in the line
//      is not the same as the length of the span housing that line.
//      Span is good for indexing, so its length is untrimmed.
//

INT BuiltLine::GetUntrimmedCharacterCount (
    INT     stringOffset,           // [IN] line start string position
    INT     *lsLineStringLength     // [OUT] line span length in Line Services index
)
{
    INT length = GetDisplayableCharacterCount();

    if (lsLineStringLength)
    {
        *lsLineStringLength = GetLsDisplayableCharacterCount();
    }

    if (   IsTrimmed()
        && !IsEOP(Imager->String[stringOffset + length - 1]))
    {
        length += stringOffset;

        while (   length < Imager->Length
               && Imager->String[length] != WCH_LF)
        {
            length++;
        }

        if (length < Imager->Length)
        {
            length++;
        }

        if (lsLineStringLength)
        {
            *lsLineStringLength = Imager->LineServicesStringPosition(length)
                                  - LsStartIndex;
        }

        length -= stringOffset;
    }
    return length;
}








GpStatus BuiltLine::CalculateCharacterCount(
    INT             stringIndex,                // [IN] line start string index
    LSCP            lineLimitIndex,             // [IN] Line Services line limit index
    INT             *characterCount             // [OUT] (optional) updated character count
) const
{
    ASSERT (characterCount);

    LSCP lineServicesEndIndex = lineLimitIndex;

    SpanRider<PLSRUN> runRider(&Imager->RunVector);
    runRider.SetPosition(lineServicesEndIndex);

    while (   lineServicesEndIndex > LsStartIndex
           && (  !runRider.GetCurrentElement()
               || runRider.GetCurrentElement()->RunType != lsrun::RunText) )
    {
        if (runRider.GetCurrentElement())
        {
            runRider.SetPosition(runRider.GetCurrentSpanStart() - 1);
        }
        else
        {
            runRider.SetPosition(lineServicesEndIndex - 1);
        }

        lineServicesEndIndex = runRider.GetCurrentSpanStart();
        runRider.SetPosition(lineServicesEndIndex);
    }

    if (lineServicesEndIndex == lineLimitIndex)
    {
        *characterCount = lineServicesEndIndex - runRider.GetCurrentSpanStart() +
                          runRider.GetCurrentElement()->ImagerStringOffset -
                          stringIndex;
    }
    else
    {
        *characterCount = runRider.GetCurrentElement()->ImagerStringOffset +
                          runRider.GetUniformLength() -
                          stringIndex;
    }
    return Ok;
}




GpStatus BuiltLine::CalculateLineLength (
    BOOL    trailingSpacesIncluded,     // [IN] including trailing spaces?
    INT     *lineLength                 // [OUT] (optional) updated line length
) const
{
    ASSERT (lineLength);

    LONG    unused;
    LONG    startMainText;
    LONG    startTrailing;
    LONG    lineEnd;

    if (LsQueryLineDup(
            LsLine,
            &unused,            // !! offset to autonumbering text,
            &unused,            //    not used for now
            &startMainText,
            &startTrailing,
            &lineEnd
        ) != lserrNone)
    {
        ASSERT(FALSE);
        return GenericError;
    }

    if (trailingSpacesIncluded)
    {
        *lineLength = lineEnd - startMainText;
    }
    else
    {
        *lineLength = startTrailing - startMainText;
    }
    return Ok;
}





/////   Logical glyph placement
//
//
//      RecordDisplayPlacements
//
//          Called back from FullTextImager::DrawGlyphs for recording
//          processed glyph advance width per logical cluster. Logical
//          glyph placement is cached in BuiltLine and used by screen
//          selection region.
//
//
//      CheckDisplayPlacements
//
//          Cache logical glyph placements for the whole line during
//          screen selection region calculation. Query uses this info
//          to determine selection boundaries that match the actual display.
//


GpStatus BuiltLine::CheckDisplayPlacements() const
{
    if (!DisplayPlacements)
    {
        if (   Imager->Graphics
            && !Imager->GetMetaFileRecordingFlag())
        {

            //  Consult the rendering engine about the actual glyph logical
            //  placements only when not within the metafile recording.
            //  If the target device is metafile (no matter what playback
            //  mechanism it will be), we just return nominal placements.


            Imager->CurrentBuiltLine = this;
            Imager->RecordDisplayPlacementsOnly = TRUE;

            // Origin passed to draw must have correct X offset for leading and
            // trailing run detection to work.

            POINT origin;
            LogicalToXY (
                0,
                0,  // Would be linePointOffset + baselineOffset for drawing, not needed here.
                (INT*)&origin.x,
                (INT*)&origin.y
            );
            GpStatus status = Draw(&origin);

            Imager->RecordDisplayPlacementsOnly = FALSE;
            Imager->CurrentBuiltLine = NULL;


            if (status != Ok)
            {
                return status;
            }
        }

        if (!DisplayPlacements)
        {
            //  In a valid state but noone care to initialize it,
            //  this means we know we dont need it.

            DisplayPlacements = (INT *)PINVALID;
        }
    }
    return Ok;
}




/////   RecordDisplayPlacements
//
//      Called per each plsrun within the line, this function caches
//      the accumulated logical advance width of each character forming
//      a glyph cluster. The width cached is in text flow direction
//      so it's negative if the run flows in the opposite direction of
//      the paragraph direction.
//
//
//          string:             c1 c2 c3   c4
//                               \ | /   /   \
//          glyphs:              g1 g2   g4  g5
//                               |  |    |   |
//          glyphAdvances:       5  4    3   3
//
//          logicalAdvances:    3  3  3    6
//
//          what we cache:      3  6  9    15
//
//
//      Note: the accumulative advance we cache is not per line, it's per run.
//      It means the value of the last item of the cache array is not the total
//      size of the whole line, but the total size of only the last run of that line.


GpStatus BuiltLine::RecordDisplayPlacements(
    const GpTextItem    *textItem,              // [IN] text item
    UINT                stringOffset,           // [IN] string offset
    UINT                stringLength,           // [IN] string length
    GMAP                *glyphMap,              // [IN] character to glyph map
    const INT           *glyphAdvances,         // [IN] glyph advance widths in ideal unit
    INT                 glyphCount,             // [IN] glyph count
    INT                 originAdjust            // [IN] leading origin adjustment
) const
{
    ASSERT (stringLength > 0 && DisplayPlacements != PINVALID);

    if (!DisplayPlacements)
    {
        DisplayPlacements = new INT [CharacterCount];

        if (!DisplayPlacements)
        {
            DisplayPlacements = (INT *)PINVALID;
            return OutOfMemory;
        }

        GpMemset(DisplayPlacements, 0, sizeof(INT) * CharacterCount);
    }


    INT direction = Imager->GetParagraphEmbeddingLevel() == (textItem->Level & 1) ? 1 : -1;


    stringOffset -= StartIndex;     // string offset to start of run relative to line start

    UINT offset = 0;                // string offset relative to start of run
    UINT length = stringLength;     // run length so far


    // total logical advance width so far, begin with leading adjustment

    INT  advanceSoFar = originAdjust * direction;


    while (length > 0)
    {
        UINT advance = 1;

        while (   advance < length
               && glyphMap[offset + advance] == glyphMap[offset])
        {
            advance++;
        }


        INT glyphLimit =   advance == length
                         ? glyphCount
                         : glyphMap[offset + advance];


        INT logicalAdvance = 0;

        for (INT i = glyphMap[offset]; i < glyphLimit; i++)
        {
            logicalAdvance += glyphAdvances[i];
        }


        //  advance distance is relative to text flow direction
        logicalAdvance *= direction;


        INT fullSplit = logicalAdvance / advance;
        INT remaining = logicalAdvance % advance;


        for (UINT i = offset; i < offset + advance; i++)
        {
            //  divide total glyph advances evenly among characters
            //  forming the cluster.

            ASSERT(DisplayPlacements[stringOffset + i] == 0);

            advanceSoFar += fullSplit + (remaining-- ? direction : 0);
            DisplayPlacements[stringOffset + i] = advanceSoFar;
        }

        length  -= advance;
        offset  += advance;
    }

    ASSERT(offset == stringLength);

    return Ok;
}





/////   TranslateSubline
//
//      Extract character position out of Line Services subline structures.
//      All returning values are ideal unit in text flow (U) direction of the main
//      line except for the total size which is an absolute value in ideal unit.
//
//
//      CP to X :
//          TranslateSubline (
//              cp,
//              sublines,
//              sublineCount,
//              textCell,
//              sublineCount - 1,
//              &partStart,     // [OUT] part start
//              &partSize       // [OUT] part size
//          );
//          pointUV.u = partStart + partSize;
//
//      String size :
//          TranslateSubline (
//              cp,
//              sublines,
//              sublineCount,
//              textCell,
//              -1,
//              NULL,
//              NULL,
//              &delta,
//              &size           // absolute size of the string to given cp
//          );
//
//      Selection part (trail) :
//          TranslateSubline (
//              cp,
//              sublines,
//              sublineCount,
//              textCell,
//              partIndex,
//              &partStart,     // [OUT] part start
//              &partSize       // [OUT] part size
//          );
//

GpStatus BuiltLine::TranslateSubline(
    LSCP                lineServicesStringIndex,    // [IN] string index creating sublines
    const LSQSUBINFO    *sublines,                  // [IN] Line Services sublines
    INT                 sublineCount,               // [IN] number of sublines
    const LSTEXTCELL    *textCell,                  // [IN] text cell
    INT                 trailIndex,                 // [IN] trail in question
    UINT                snapMode,                   // [IN] trail end snap mode
    INT                 *trailStart,                // [OUT] trail start
    INT                 *trailSize,                 // [OUT] trail size
    INT                 *delta,                     // [OUT] (optional) number of characters moved by snapping
    INT                 *totalTrailSize             // [OUT] (optional) total absolute size of all trails
) const
{
    ASSERT (sublines && sublineCount > 0 && textCell);

    if (trailIndex >= sublineCount)
    {
        return InvalidParameter;
    }


    GpStatus status = Ok;
    INT start;
    INT size;


    if (trailIndex >= 0)
    {
        start = sublines[trailIndex].pointUvStartSubline.u;
        size  = sublines[trailIndex].pointUvStartRun.u -
                sublines[trailIndex].pointUvStartSubline.u;


        if (snapMode & SnapDisplay)
        {
            //  Caller asks for display-precision result,
            //  make sure the actual display positions are porperly cached

            status = CheckDisplayPlacements();
            IF_NOT_OK_WARN_AND_RETURN(status);

            if (DisplayPlacements == PINVALID)
            {
                //  The rendering engine confirms that it is fine to go ahead
                //  without this info. This happens in non-gridfitted modes or
                //  when path glyph is simulated.

                snapMode &= ~SnapDisplay;
            }
        }

        if (trailIndex == sublineCount - 1)
        {

            //  Last trail is tricky as it requires more calculations
            //  as we approach the target position.

            if (snapMode & SnapDisplay)
            {
                //  Calibrate cell start position to ensure accurate result
                //  for screen selection.

                INT runStringOffset = sublines[trailIndex].plsrun->ImagerStringOffset;
                INT cellStringOffset =    textCell->cpStartCell - sublines[trailIndex].cpFirstRun
                                        + runStringOffset;

                if (cellStringOffset > runStringOffset)
                {
                    size += DisplayPlacements[cellStringOffset - 1 - StartIndex];
                }
            }
            else
            {
                size += textCell->pointUvStartCell.u -
                        sublines[trailIndex].pointUvStartRun.u;
            }

            //  Now, calculate intra-cell distance

            LSCP advance = lineServicesStringIndex - textCell->cpStartCell;

            if (advance > 0)
            {
                switch (snapMode & ~SnapDisplay)
                {
                    case SnapForward:
                        advance = textCell->cCharsInCell;
                        break;

                    case SnapBackward:
                        advance = 0;
                        break;
                }

                if (advance > (LSCP)textCell->cCharsInCell)
                {
                    //  given string index is within the hidden text range,
                    //  size added up to the last visible character in cell.

                    advance = textCell->cCharsInCell;
                }

                //  trail from cell start,
                //  i.e. querying the position inside a ligature
                //
                //  -Note- dupCell is in direction of subline while trailSize
                //  is in direction of main line (first subline).

                if (sublines[trailIndex].lstflowSubline == sublines[0].lstflowSubline)
                {
                    size += MulDiv (
                        textCell->dupCell,
                        advance,
                        textCell->cCharsInCell
                    );
                }
                else
                {
                    size -= MulDiv (
                        textCell->dupCell,
                        advance,
                        textCell->cCharsInCell
                    );
                }
            }

            if (delta)
            {
                //  the difference btw what we ask and what LS actually gives
                //
                //  delta != 0 in one of these cases
                //    - cluster snapping was applied
                //    - the position we're asking is within a hidden range

                *delta = (textCell->cpStartCell + advance) - lineServicesStringIndex;

                if (   ((snapMode & SnapForward) && *delta < 0)
                    || ((snapMode & SnapBackward) && *delta > 0))
                {
                    //  Client only cares about the snapping delta not the real delta,
                    //  thus ignore negative delta for forward snapping and positive
                    //  delta for backing snapping (wchao, 322595)

                    *delta = 0;
                }
            }
        }

        *trailStart = start;
        *trailSize  = size;
    }

    if (totalTrailSize)
    {
        INT totalSize = 0;

        for (INT i = 0; i < sublineCount; i++)
        {
            status = TranslateSubline (
                lineServicesStringIndex,
                sublines,
                sublineCount,
                textCell,
                i,
                snapMode,
                &start,
                &size,
                delta
            );

            if (status != Ok)
            {
                return status;
            }

            totalSize += abs(size);
        }

        *totalTrailSize = totalSize;
    }

    return status;
}




/////   String size
//
//      Calculate total size occupied by a string starting at the line's first character
//      position to the given string position.
//
//      Note that in BiDi scenario, the size calculated is the sum of all selection parts
//      produced by selecting a given character range.
//

GpStatus BuiltLine::CalculateStringSize (
    INT             stringOffset,           // [IN] offset to the cp relative to line start
    LSQSUBINFO      *sublines,              // [IN] Line Services sublines
    INT             maxSublineCount,        // [IN] max number of sublines
    UINT            snapMode,               // [IN] snap mode within text cell
    INT             *totalSize,             // [OUT] absolute string size
    INT             *delta                  // [OUT] (optional) delta character length after snapping
) const
{
    //  Map Line Services character position

    LSCP lineServicesStringIndex = Imager->LineServicesStringPosition (
        this,
        stringOffset
    );

    if (lineServicesStringIndex == LsStartIndex)
    {
        *totalSize = 0;
        return Ok;
    }

    GpStatus    status = Ok;
    LSTEXTCELL  textCell;
    ULONG       sublineCount = 0;

    if (LsQueryLineCpPpoint(
            LsLine,
            lineServicesStringIndex,
            maxSublineCount,
            sublines,
            &sublineCount,
            &textCell
        ) == lserrNone)
    {
        status = TranslateSubline (
                    lineServicesStringIndex,
                    sublines,
                    sublineCount,
                    &textCell,
                    -1,
                    snapMode,
                    NULL,
                    NULL,
                    delta,
                    totalSize
                 );
    }
    else
    {
        status = GenericError;
    }

    ASSERT(status == Ok);
    return status;
}




GpStatus BuiltLine::UpdateTrailRegion (
    GpRegion    *region,
    INT         linePointOffset,
    INT         trailStart,
    INT         trailSize,
    CombineMode combineMode
) const
{
    if (   !trailStart
        && !trailSize
        && combineMode != CombineModeIntersect)
    {
        return Ok;
    }


    INT x1, y1;
    INT x2, y2;

    //  rectangle start point

    LogicalToXY(
        trailStart,
        linePointOffset,
        &x1,
        &y1
    );

    //  rectangle end point

    LogicalToXY(
        trailStart + trailSize,
        linePointOffset + Ascent + Descent,
        &x2,
        &y2
    );

    //  !! workaround combine region bug !!

    if (x2 - x1 < 0)
    {
        INT xi = x1;
        x1 = x2;
        x2 = xi;
    }

    if (y2 - y1 < 0)
    {
        INT yi = y1;
        y1 = y2;
        y2 = yi;
    }

    RectF trailBox (
        TOREAL(x1 / Imager->WorldToIdeal) + Imager->ImagerOrigin.X,
        TOREAL(y1 / Imager->WorldToIdeal) + Imager->ImagerOrigin.Y,
        TOREAL((x2 - x1) / Imager->WorldToIdeal),
        TOREAL((y2 - y1) / Imager->WorldToIdeal)
    );

    return region->Combine(&trailBox, combineMode);
}




/////   Compute the insertion trail and update the given selection region
//
//      Trail is a mark left by dragging an insertion point to a given cp.
//      In bidi context, a trail contains multiple trail parts. If the given cp
//      is at the end-of-line position, the trail covers the whole line.

GpStatus BuiltLine::GetInsertionTrailRegion (
    INT             linePointOffset,    // [IN] line logical point offset
    INT             stringOffset,       // [IN] offset to the cp relative to line start
    UINT            maxTrailCount,      // [IN] maximum number of trail part
    LSQSUBINFO      *sublines,          // [IN] subline array
    GpRegion        *region             // [OUT] output trail region
) const
{
    ASSERT(region && sublines);

    if (stringOffset <= 0)
    {
        return Ok;
    }

    //  Because of trailing white spaces, the number of character
    //  in a line is limited to the last visible character

    INT characterCount =  !(Imager->GetFormatFlags() & StringFormatFlagsMeasureTrailingSpaces) && LastVisibleRun
                        ? LastVisibleRun->ImagerStringOffset + LastVisibleRun->CharacterCount - StartIndex
                        : CharacterCount;


    if (stringOffset >= characterCount)
    {
        //  Query pass the last character of the line,
        //  give out the whole line extent

        return UpdateTrailRegion(
            region,
            linePointOffset,
            0,
            LineLength,
            CombineModeXor
        );
    }


    //  Backing up til the preceding character of the insertion point is
    //  not a hotkey control (0xffff). We want to include the hotkey as part of 
    //  the selection of the character it underlines.
    
    while (   stringOffset > 0
           && Imager->String[StartIndex + stringOffset - 1] == WCH_IGNORABLE)
    {
        stringOffset--;
    }

    if (!stringOffset)
    {
        return Ok;
    }
    

    LSCP lineServicesStringPosition = Imager->LineServicesStringPosition (
        this,
        stringOffset
    );


    GpStatus    status = Ok;
    LSTEXTCELL  textCell;
    UINT        trailCount = 0;

    LSERR lserr = LsQueryLineCpPpoint(
        LsLine,
        lineServicesStringPosition,
        maxTrailCount,
        sublines,
        (ULONG *)&trailCount,
        &textCell
    );

    if (lserr != lserrNone)
    {
        return GenericError;
    }

    for (UINT i = 0; i < trailCount; i++)
    {
        INT trailStart;
        INT trailSize;

        status = TranslateSubline (
            lineServicesStringPosition,
            sublines,
            trailCount,
            &textCell,
            i,
            SnapDisplay,
            &trailStart,
            &trailSize
        );

        if (status != Ok)
        {
            return status;
        }

        status = UpdateTrailRegion(
            region,
            linePointOffset,
            trailStart,
            trailSize,
            CombineModeXor
        );
    }

    return status;
}





/////   Generate a result region covering all parts of text selection within a single line
//
//      In case of multiple line selection, caller obtain the single line region and combine
//      them to form a bigger one, which covers all text selection.
//
//      If insertion point is passed instead of selection. It returns the region covering
//      from start of the line to the insertion point.
//

GpStatus BuiltLine::GetSelectionTrailRegion (
    INT             linePointOffset,    // [IN] line logical point offset
    INT             stringOffset,       // [IN] offset to the cp relative to line start
    INT             length,             // [IN] selection length
    GpRegion        *region             // [OUT] selection region
) const
{
    if (!region)
    {
        return InvalidParameter;
    }

#if DBG
    SpanRider<BuiltLine *> lineRider(&Imager->BuiltLineVector);
    lineRider.SetPosition(StartIndex + stringOffset);
    ASSERT (StartIndex == (INT)lineRider.GetCurrentSpanStart());
#endif

    AutoArray<LSQSUBINFO> sublines(new LSQSUBINFO [MaxSublineCount]);

    if (!sublines)
    {
        return OutOfMemory;
    }


    //  Make sure display information is cached

    GpStatus status = CheckDisplayPlacements();
    IF_NOT_OK_WARN_AND_RETURN(status);


    //  The maxmium number of trail parts is never greater than
    //  the maximum of sublines.

    status = GetInsertionTrailRegion (
        linePointOffset,
        stringOffset,
        MaxSublineCount,
        sublines.Get(),
        region
    );

    if (status == Ok && length)
    {
        //  It is a selection not an insertion point

        status = GetInsertionTrailRegion (
            linePointOffset,
            stringOffset + length,
            MaxSublineCount,
            sublines.Get(),
            region
        );

        if (status == Ok)
        {

            //  What we have at this point is a series of discrete selection
            //  boxes derived from LS subline structures which snaps to the
            //  nominal position at edges.
            //
            //  Working out the right edges at subline level is too complex
            //  as subline contains multiple and most of the time partial runs
            //  with given cp in LSCP.
            //
            //  A more reliable and easier to understand approach is to handle the
            //  whole region at once after all sublines have been interpreted, making
            //  them snap to the right display boundaries pre-calculated by our
            //  drawing code. This can result in either shrinking or growing the
            //  region depending on directionality of leading/trailing adjustment
            //  of runs at edges.


            INT     blockLevel = Imager->GetParagraphEmbeddingLevel();
            lsrun   *first;

            status = Imager->GetTextRun (
                LsStartIndex,
                &first
            );
            IF_NOT_OK_WARN_AND_RETURN(status);


            INT leading  = 0;   //  line leading adjustment
            INT trailing = 0;   //  line trailing adjustment


            if (first)
            {
                INT stringAtLeading;
                INT stringAtTrailing;


                if (blockLevel == (first->Item.Level & 1))
                {
                    leading  += first->Adjust.Leading;
                    trailing += first->Adjust.Trailing;

                    stringAtLeading  = first->ImagerStringOffset;
                    stringAtTrailing = stringAtLeading + first->CharacterCount;
                }
                else
                {
                    leading  -= first->Adjust.Trailing;
                    trailing -= first->Adjust.Leading;

                    stringAtTrailing = first->ImagerStringOffset;
                    stringAtLeading  = stringAtTrailing + first->CharacterCount;
                }


                if (leading)
                {
                    //  Include/exclude line leading spaces

                    status = UpdateTrailRegion(
                        region,
                        linePointOffset,
                        0,
                        leading,
                        (
                            // Only include when we know the edge is being selected
                            leading < 0
                         && stringAtLeading - StartIndex >= stringOffset
                         && stringAtLeading - StartIndex <= stringOffset + length
                        )
                        ? CombineModeUnion
                        : CombineModeExclude
                    );
                    IF_NOT_OK_WARN_AND_RETURN(status);
                }


                if (LastVisibleRun && first != LastVisibleRun)
                {
                    if (blockLevel == (LastVisibleRun->Item.Level & 1))
                    {
                        trailing += LastVisibleRun->Adjust.Trailing;

                        stringAtTrailing =   LastVisibleRun->ImagerStringOffset
                                           + LastVisibleRun->CharacterCount;
                    }
                    else
                    {
                        trailing -= LastVisibleRun->Adjust.Leading;

                        stringAtTrailing = LastVisibleRun->ImagerStringOffset;
                    }
                }


                if (trailing)
                {
                    //  Include/exclude line trailing spaces

                    status = UpdateTrailRegion(
                        region,
                        linePointOffset,
                        LineLength,
                        trailing,
                        (
                             // Only include when we know the edge is being selected
                             trailing > 0
                          && stringAtTrailing - StartIndex >= stringOffset
                          && stringAtTrailing - StartIndex <= stringOffset + length
                        )
                        ? CombineModeUnion
                        : CombineModeExclude
                    );
                }
            }
        }
    }

    return status;
}




void BuiltLine::GetBaselineOffset(
    INT     *nominalBaseline,   // [OUT] logical distance to nominal baseline
    INT     *baselineAdjustment // [OUT] adjustment to the display baseline
) const
{
    if (     Imager->IsFormatVertical()
        &&  !Imager->IsFormatRightToLeft())
    {
        *nominalBaseline = GetDescent();
        *baselineAdjustment = Imager->DefaultFontGridFitBaselineAdjustment;

        // Adjust the bottom margin slightly to make room for hinting
        // as long as we have the left/right margins enabled - Version 2
        // should expose this as an independent value!

        const GpStringFormat *format = Imager->FormatVector.GetDefault();

        if (!format || format->GetLeadingMargin() != 0.0f)
        {
            // This offset is in ideal units, adjust the offset accordingly
            // for vertical text.
            *baselineAdjustment += GpRound(2048.0f * DefaultBottomMargin);
        }
    }
    else
    {
        *nominalBaseline = GetAscent();
        
        if (Imager->IsFormatVertical())
        {
            *baselineAdjustment = -Imager->DefaultFontGridFitBaselineAdjustment;
        }
        else
        {
            *baselineAdjustment = Imager->DefaultFontGridFitBaselineAdjustment;
        }
    }
}
   



void BuiltLine::SetDisplayBaseline(
    const PointF    *original,  // [IN] original baseline, absolute position in world unit
    const PointF    *current    // [IN] new baseline, absolute position in world unit
) const
{
    if (!DisplayBaselineAdjust)
    {
        INT originalOffset = 
            Imager->IsFormatVertical() ? 
            GpRound((original->X - Imager->ImagerOrigin.X) * Imager->WorldToIdeal) :
            GpRound((original->Y - Imager->ImagerOrigin.Y) * Imager->WorldToIdeal) ;
            
        INT currentOffset = 
            Imager->IsFormatVertical() ? 
            GpRound((current->X - Imager->ImagerOrigin.X) * Imager->WorldToIdeal) :
            GpRound((current->Y - Imager->ImagerOrigin.Y) * Imager->WorldToIdeal) ;

        DisplayBaselineAdjust += currentOffset - originalOffset;
    }
}




/////   Map logical offsets to XY TextImager's relative position
//
//      entry   textPointOffset - distance from LS start of line to point
//                                in line, positive in LS du sense.
//              linePointOffset - distance from origin into imager in
//                                paragraph flow direction.


void BuiltLine::LogicalToXY (
    IN  INT  textPointOffset,    // text flow distance (LS u)
    IN  INT  linePointOffset,    // line flow distance (LS v)
    OUT INT  *x,                 // horizontal offset  (LS x)
    OUT INT  *y                  // vertical offset    (LS y)
) const
{
    // linePointOffset represents the offset of the leading long edge of the
    // target line from the leading long edge of the first line.

    StringAlignment lineAlignment = Imager->GetFormatLineAlign();

    if (lineAlignment != StringAlignmentNear)
    {
        INT textDepth       = GpRound(Imager->TextDepth      * Imager->WorldToIdeal);
        INT textDepthLimit  = GpRound(Imager->TextDepthLimit * Imager->WorldToIdeal);

        switch (lineAlignment)
        {
            case StringAlignmentCenter: linePointOffset += (textDepthLimit - textDepth) / 2; break;
            case StringAlignmentFar:    linePointOffset += textDepthLimit - textDepth;       break;
        }
    }



    if (Imager->IsFormatVertical())
    {
        if (Imager->IsFormatRightToLeft())
        {
            // Vertical, lines advance from right to left
            *x =   GpRound(Imager->Width * Imager->WorldToIdeal)
                 - linePointOffset;
            *y = AlignmentOffset + textPointOffset;
        }
        else
        {
            // Vertical, lines advance from left to right
            *x = linePointOffset;
            *y = AlignmentOffset + textPointOffset;
        }
    }
    else
    {
        if (Imager->IsFormatRightToLeft())
        {
            // RTL horizontal. textPointOffset runs left from line origin.
            *x = AlignmentOffset - textPointOffset;
            *y = linePointOffset;
        }
        else
        {
            // Normal case. Text horizontal, origin at left
            *x = AlignmentOffset + textPointOffset;
            *y = linePointOffset;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\builtline.hpp ===
#ifndef _BUILTLINE_HPP
#define _BUILTLINE_HPP



class EllipsisInfo;



/////   BuiltLine
//
//      Contains the PLSLINE line information pointer.
//
//      Contains line position information.
//
//      Always belongs to a context.
//
//      Values are in line services ideal units.


class BuiltLine
{

public:

    enum
    {
        INFINITE_LINELIMIT  = 0x1000000,    // Unlimited line break boundary
        MAX_BREAKRECORD     = 61            // possible maximum level allowed in Unicode 3.0
    };


    BuiltLine()
    :   Imager                  (NULL),
        LsLine                  (NULL),
        LsContext               (NULL),
        LsStartIndex            (0),
        StartIndex              (0),
        LsCharacterCount        (0),
        CharacterCount          (0),
        Ascent                  (0),
        Descent                 (0),
        LineSpacing             (0),
        LineLength              (0),
        BreakRecord             (NULL),
        BreakRecordCount        (0),
        LeftOrTopMargin         (0),
        RightOrBottomMargin     (0),
        MaxSublineCount         (0),
        Trimming                (StringTrimmingNone),
        AlignmentOffset         (0),
        EllipsisPointOffset     (0),
        LeftOrTopGlyphEdge      (0),
        LastVisibleRun          (NULL),
        DisplayPlacements       ((INT *)PINVALID),
        DisplayBaselineAdjust   (0),
        Status                  (WrongState) // Should never be used constructed like this
    {}


    // This constructor does all the work of building the line

    BuiltLine(
        ols             *lineServicesOwner,          // [IN] Line Services context
        INT              stringIndex,                // [IN] string start index
        LSCP             lineServicesStartIndex,     // [IN] Line Services string start index
        StringTrimming   trimming,                   // [IN] how to end the line
        BuiltLine       *previousLine,               // [IN] previous line
        BOOL             forceEllipsis = FALSE       // [IN] enforce trim ellipsis?
    );


    ~BuiltLine()
    {
        if (LsLine)
        {
            LsDestroyLine(LsContext, LsLine);
        }

        if (BreakRecord)
        {
            delete [] BreakRecord;
        }

        if (   DisplayPlacements
            && DisplayPlacements != PINVALID)
        {
            delete [] DisplayPlacements;
        }
    }


    GpStatus Draw(const POINT *lineOrigin) const
    {
        // lineOrigin is in Line Services ideal coordinates

        if (LsDisplayLine(LsLine, lineOrigin, 1, NULL) == lserrNone)
        {
            return Ok;
        }
        else
        {
            return GenericError;
        }
    }


    bool operator== (INT right) const // This comparison only for NULL tests
    {
        ASSERT(right == 0);
        return LsLine == NULL;
    }

    INT GetAscent()                 const {return Ascent;}
    INT GetDescent()                const {return Descent;}
    INT GetLineSpacing()            const {return LineSpacing;}
    INT GetLineLength()             const {return LineLength;}
    INT GetAlignmentOffset()        const {return AlignmentOffset;}
    INT GetLeftOrTopMargin()        const {return LeftOrTopMargin;}
    INT GetRightOrBottomMargin()    const {return RightOrBottomMargin;}
    INT GetLeftOrTopGlyphEdge()     const {return LeftOrTopGlyphEdge;}


    //  Break records

    BREAKREC *GetBreakRecord()       const {return BreakRecord;}
    ULONG     GetBreakRecordCount()  const {return BreakRecordCount;}


    //  Character count

    INT GetLsStartIndex()                   const {return LsStartIndex;}
    INT GetDisplayableCharacterCount()      const {return CharacterCount;}
    INT GetLsDisplayableCharacterCount()    const {return LsCharacterCount;}



    INT GetUntrimmedCharacterCount (
        INT     stringOffset,               // [IN] line start string position
        INT     *lsLineStringLength = NULL  // [OUT] line span length in Line Services index
    );




    //  CPtoX

    GpStatus GetSelectionTrailRegion (
        INT             linePointOffset,    // [IN] line logical point offset
        INT             stringOffset,       // [IN] offset to the cp relative to line start
        INT             length,             // [IN] selection length
        GpRegion        *region             // [OUT] selection region
    ) const;



    //  Trimming

    GpStatus UpdateContentWithPathEllipsis (
        EllipsisInfo    *ellipsis,          // [IN] ellipsis info
        INT             lineLengthLimit,    // [IN] line length limit including margins
        BOOL            *contentChanged     // [IN/OUT] content changed?
    );


    BOOL IsTrimmed() const
    {
        //  Path ellipsis is not considered a trimmed line.
        //  We just hide part of it with ellipsis.

        return     Trimming != StringTrimmingNone
                && Trimming != StringTrimmingEllipsisPath;
    }

    BOOL IsEllipsis() const
    {
        return     Trimming == StringTrimmingEllipsisCharacter
                || Trimming == StringTrimmingEllipsisWord
                || Trimming == StringTrimmingEllipsisPath;
    }

    INT GetEllipsisOffset() const { return EllipsisPointOffset; }


    void SetTrimming(StringTrimming trimming)
    {
        Trimming = trimming;
    }


    /////   Coordinate mapping
    //
    //

    void LogicalToXY (
        INT   textPointOffset,    // [IN] text flow distance (LS u)
        INT   linePointOffset,    // [IN] line flow distance (LS v)
        INT  *x,                  // [OUT] horizontal offset (LS x)
        INT  *y                   // [OUT] vertical offset   (LS y)
    ) const;




    /////   Logical glyph placement
    //
    //      Called back from FullTextImager::DrawGlyphs for recording
    //      processed glyph advance width per logical cluster. Logical
    //      glyph placement is cached in BuiltLine and used by screen
    //      selection region.
    //

    GpStatus RecordDisplayPlacements(
        const GpTextItem    *textItem,              // [IN] text item
        UINT                stringOffset,           // [IN] string offset
        UINT                stringLength,           // [IN] string length
        GMAP                *glyphMap,              // [IN] character to glyph map
        const INT           *glyphAdvances,         // [IN] glyph advance widths in ideal unit
        INT                 glyphCount,             // [IN] glyph count
        INT                 originAdjust            // [IN] leading origin adjustment
    ) const;




    void UpdateLastVisibleRun(lsrun *run) const
    {
        if (   run
            && run->RunType == lsrun::RunText
            && run != LastVisibleRun
            && (   !LastVisibleRun
                || run->ImagerStringOffset >= LastVisibleRun->ImagerStringOffset))
        {
            LastVisibleRun = run;
        }
    }


    void GetBaselineOffset(
        INT     *nominalBaseline,   // [OUT] logical distance to nominal baseline
        INT     *baselineAdjustment // [OUT] adjustment to the display baseline
    ) const;


    void SetDisplayBaseline(
        const PointF    *original,  // [IN] original baseline, absolute position in world unit
        const PointF    *current    // [IN] new baseline, absolute position in world unit
    ) const;


    INT GetDisplayBaselineAdjust() const { return DisplayBaselineAdjust; }
    

    GpStatus GetStatus() const
    {
        return Status;
    }


private:


    /////   Line creation
    //

    GpStatus CreateLine (
        INT             stringIndex,            // [IN] string start position
        INT             lineLengthLimit,        // [IN] line length limit (excluding margins)
        StringTrimming  trimming,               // [IN] string trimming
        INT             formatFlags,            // [IN] format flags
        BOOL            forceEllipsis,          // [IN] enforce trim ellipsis?
        BuiltLine       *previousLine           // [IN] previous line
    );


    GpStatus CreateLineCore (
        INT             formattingWidth,        // [IN] formatting boundary
        StringTrimming  trimming,               // [IN] trimming type
        BuiltLine       *previousLine,          // [IN] previous line
        UINT            maxBrkCount,            // [IN] maximum number of break records
        BREAKREC        *brkRecords,            // [OUT] break records
        DWORD           *brkCount,              // [OUT] break record count
        LSLINFO         *lineInfo               // [OUT] line information
    );


    GpStatus RecreateLineEllipsis (
        INT             stringIndex,            // [IN] line start index
        INT             lineLengthLimit,        // [IN] line length limit
        StringTrimming  trimmingRequested,      // [IN] kind of trimming requested
        INT             formatFlags,            // [IN] format flags
        LSLINFO         *lineInfoOriginal,      // [IN] original line's properties
        BuiltLine       *previousLine,          // [IN] previous line
        StringTrimming  *trimmingDone,          // [OUT] kind of trimming implemented
        LSLINFO         *lineInfoNew            // [OUT] new line properties
    );



    /////   Querying
    //


    enum
    {
        SnapNone            = 0,    // average final position per character length within the cell
        SnapBackward        = 1,    // snap backward to the leading edge of the cell
        SnapForward         = 2,    // snap forward to the trailing edge of the cell
        SnapDisplay         = 0x10  // snap to display grid (on-screen selection)
    };


    GpStatus TranslateSubline(
        LSCP                lineServicesStringIndex,    // [IN] string index creating sublines
        const LSQSUBINFO    *sublines,                  // [IN] Line Services sublines
        INT                 sublineCount,               // [IN] number of sublines
        const LSTEXTCELL    *textCell,                  // [IN] text cell
        INT                 trailIndex,                 // [IN] trail in question
        UINT                snapMode,                   // [IN] trail end snap mode
        INT                 *trailStart,                // [OUT] trail start
        INT                 *trailSize,                 // [OUT] trail size
        INT                 *delta = NULL,              // [OUT] (optional) character length delta after snapping
        INT                 *totalTrailSize = NULL      // [OUT] (optional) total absolute size of all trails
    ) const;


    GpStatus CalculateStringSize (
        INT             stringOffset,           // [IN] offset to the cp relative to line start
        LSQSUBINFO      *sublines,              // [IN] Line Services sublines
        INT             maxSublineCount,        // [IN] max number of sublines
        UINT            snapMode,               // [IN] snap mode within text cell
        INT             *totalSize,             // [OUT] absolute string size
        INT             *delta = NULL           // [OUT] (optional) delta character length after snapping
    ) const;


    GpStatus GetInsertionTrailRegion (
        INT             linePointOffset,    // [IN] line logical point offset
        INT             stringOffset,       // [IN] offset to the cp relative to line start
        UINT            maxTrailCount,      // [IN] maximum number of trail part
        LSQSUBINFO      *sublines,          // [IN] subline array
        GpRegion        *region             // [OUT] output trail region
    ) const;


    GpStatus CalculateLineLength (
        BOOL    trailingSpacesIncluded,     // [IN] including trailing spaces?
        INT     *lineLength                 // [OUT] (optional) updated line length
    ) const;


    GpStatus CalculateCharacterCount(
        INT             stringIndex,                // [IN] line start string index
        LSCP            lineLimitIndex,             // [IN] Line Services line limit index
        INT             *characterCount             // [OUT] (optional) updated character count
    ) const;



    GpStatus CheckDisplayPlacements() const;




    /////   Backing store update
    //

    GpStatus CheckUpdateLineLength (
        BOOL    trailingSpacesIncluded, // [IN] including trailing spaces?
        BOOL    forceUpdate = FALSE     // [IN] (optional) force updating?
    );


    GpStatus CheckUpdateCharacterCount(
        INT             stringIndex,                // [IN] line start string index
        LSCP            lineLimitIndex,             // [IN] Line Services line limit index
        BOOL            forceUpdate = FALSE         // [IN] (optional) force updating?
    );



    /////   Trimming support
    //

    GpStatus TrimText (
        INT         stringOffset,           // [IN] string offset from line start
        INT         stringLength,           // [IN] string length
        INT         size,                   // [IN] string size in ideal unit
        INT         sizeLimit,              // [IN] maximum possible string size
        LSQSUBINFO  *sublines,              // [IN] LS sublines
        INT         maxSublineCount,        // [IN] valid subline count
        INT         ellipsisLength,         // [IN] character length of ellipsis string
        INT         *trimmedLength,         // [IN/OUT] number of character being trimmed out
        BOOL        leadingTrim = FALSE     // [IN] TRUE - trim from the first character onward
    );



    /////   Incremental selection region update
    //

    GpStatus UpdateTrailRegion (
        GpRegion    *region,
        INT         linePointOffset,
        INT         trailStart,
        INT         trailSize,
        CombineMode combineMode
    ) const;




    PLSLINE          LsLine;
    PLSC             LsContext;              // Used only when calling LsDestroyLine
    FullTextImager  *Imager;                 // Owning text imager

    LSCP             LsStartIndex;           // First Line Services character position
    INT              StartIndex;             // Actual first character position
    INT              LsCharacterCount;       // In Line Services character position
    INT              CharacterCount;         // Actual character count in string positions
    INT              Ascent;
    INT              Descent;
    INT              LineSpacing;
    INT              LineLength;             // In ideal units
    BREAKREC        *BreakRecord;            // Pointer to the break records
    ULONG            BreakRecordCount;       // number of break records produced
    INT              LeftOrTopMargin;        // In ideal units
    INT              RightOrBottomMargin;    // In ideal units
    ULONG            MaxSublineCount;        // Number of sublines
    StringTrimming   Trimming;               // String trimming

    INT              AlignmentOffset;        // Offset from left edge of rectangle to leading edge of line, right positive
    INT              EllipsisPointOffset;    // point offset to line's trailing ellipsis

    INT              LeftOrTopGlyphEdge;     // offset to the near edge of the line

    mutable lsrun   *LastVisibleRun;         // last visible run (updated by display engine)
    mutable INT     *DisplayPlacements;      // logical glyph placement array indexed by imager string offset

    mutable INT      DisplayBaselineAdjust;  // baseline adjustment to snap full pixel in grid-fitted display

    GpStatus         Status;
};


#endif // _BUILTLINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\digitsubstitution.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   DigitSubstitution.cpp
*
* Abstract:
*
*   Implements digit substitution logic.
*
* Notes:
*
* Revision History:
*
*   05/30/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

enum GpStringUserDigitSubstitute
{
    StringUserDigitSubstituteContext    = 0,
    StringUserDigitSubstituteNone       = 1,
    StringUserDigitSubstituteNational   = 2
};

GpStringUserDigitSubstitute UserDigitSubstitute;
LCID UserLocale;

const ItemScript LanguageToDigitScript[] = {
/*  00 NEUTRAL             */  ScriptLatinNumber,
/*  01 ARABIC              */  ScriptArabicNum,
/*  02 BULGARIAN           */  ScriptLatinNumber,
/*  03 CATALAN             */  ScriptLatinNumber,
/*  04 CHINESE             */  ScriptLatinNumber,
/*  05 CZECH               */  ScriptLatinNumber,
/*  06 DANISH              */  ScriptLatinNumber,
/*  07 GERMAN              */  ScriptLatinNumber,
/*  08 GREEK               */  ScriptLatinNumber,
/*  09 ENGLISH             */  ScriptLatinNumber,
/*  0a SPANISH             */  ScriptLatinNumber,
/*  0b FINNISH             */  ScriptLatinNumber,
/*  0c FRENCH              */  ScriptLatinNumber,
/*  0d HEBREW              */  ScriptLatinNumber,
/*  0e HUNGARIAN           */  ScriptLatinNumber,
/*  0f ICELANDIC           */  ScriptLatinNumber,
/*  10 ITALIAN             */  ScriptLatinNumber,
/*  11 JAPANESE            */  ScriptLatinNumber,
/*  12 KOREAN              */  ScriptLatinNumber,
/*  13 DUTCH               */  ScriptLatinNumber,
/*  14 NORWEGIAN           */  ScriptLatinNumber,
/*  15 POLISH              */  ScriptLatinNumber,
/*  16 PORTUGUESE          */  ScriptLatinNumber,
/*  17 RHAETOROMANIC       */  ScriptLatinNumber,
/*  18 ROMANIAN            */  ScriptLatinNumber,
/*  19 RUSSIAN             */  ScriptLatinNumber,
/*  1a CROATIAN/SERBIAN    */  ScriptLatinNumber,
/*  1b SLOVAK              */  ScriptLatinNumber,
/*  1c ALBANIAN            */  ScriptLatinNumber,
/*  1d SWEDISH             */  ScriptLatinNumber,
/*  1e THAI                */  ScriptThaiNum,
/*  1f TURKISH             */  ScriptLatinNumber,
/*  20 URDU                */  ScriptUrduNum,
/*  21 INDONESIAN          */  ScriptLatinNumber,
/*  22 UKRAINIAN           */  ScriptLatinNumber,
/*  23 BELARUSIAN          */  ScriptLatinNumber,
/*  24 SLOVENIAN           */  ScriptLatinNumber,
/*  25 ESTONIAN            */  ScriptLatinNumber,
/*  26 LATVIAN             */  ScriptLatinNumber,
/*  27 LITHUANIAN          */  ScriptLatinNumber,
/*  28 TAJIK               */  ScriptLatinNumber,
/*  29 FARSI               */  ScriptFarsiNum,
/*  2a VIETNAMESE          */  ScriptLatinNumber,
/*  2b ARMENIAN            */  ScriptLatinNumber,
/*  2c AZERI               */  ScriptLatinNumber,
/*  2d BASQUE              */  ScriptLatinNumber,
/*  2e SORBIAN             */  ScriptLatinNumber,
/*  2f MACEDONIAN          */  ScriptLatinNumber,
/*  30 SUTU                */  ScriptLatinNumber,
/*  31 TSONGA              */  ScriptLatinNumber,
/*  32 TSWANT              */  ScriptLatinNumber,
/*  33 VENDA               */  ScriptLatinNumber,
/*  34 XHOSA               */  ScriptLatinNumber,
/*  35 ZULU                */  ScriptLatinNumber,
/*  36 AFRIKAANS           */  ScriptLatinNumber,
/*  37 GEORGIAN            */  ScriptLatinNumber,
/*  38 FAEROESE            */  ScriptLatinNumber,
/*  39 HINDI               */  ScriptHindiNum,
/*  3a MALTESE             */  ScriptLatinNumber,
/*  3b SAMI                */  ScriptLatinNumber,
/*  3c GAELIC              */  ScriptLatinNumber,
/*  3d YIDDISH             */  ScriptLatinNumber,
/*  3e MALAY               */  ScriptLatinNumber,
/*  3f KAZAK               */  ScriptLatinNumber,
/*  40 KIRGHIZ             */  ScriptLatinNumber,
/*  41 SWAHILI             */  ScriptLatinNumber,
/*  42 TURKMEN             */  ScriptLatinNumber,
/*  43 UZBEK               */  ScriptLatinNumber,
/*  44 TATAR               */  ScriptLatinNumber,
/*  45 BENGALI             */  ScriptBengaliNum,
/*  46 GURMUKHI/PUNJABI    */  ScriptGurmukhiNum,
/*  47 GUJARATI            */  ScriptGujaratiNum,
/*  48 ORIYA               */  ScriptOriyaNum,
/*  49 TAMIL               */  ScriptTamilNum,
/*  4A TELUGU              */  ScriptTeluguNum,
/*  4B KANNADA             */  ScriptKannadaNum,
/*  4C MALAYALAM           */  ScriptMalayalamNum,
/*  4d ASSAMESE            */  ScriptBengaliNum,
/*  4e MARATHI             */  ScriptHindiNum,
/*  4f SANSKRIT            */  ScriptHindiNum,
/*  50 MONGOLIAN           */  ScriptMongolianNum,
/*  51 TIBETAN             */  ScriptTibetanNum,
/*  52 WELCH               */  ScriptLatinNumber,
/*  53 KHMER               */  ScriptKhmerNum,
/*  54 LAO                 */  ScriptLaoNum,
/*  55 BURMESE             */  ScriptLatinNumber,
/*  56 GALLEGO             */  ScriptLatinNumber,
/*  57 KONKANI             */  ScriptHindiNum,
/*  58 MANIPURI            */  ScriptBengaliNum,
/*  59 SINDHI              */  ScriptGurmukhiNum,
/*  5a SYRIAC              */  ScriptLatinNumber,
/*  5b SINHALESE           */  ScriptLatinNumber,
/*  5c CHEROKEE            */  ScriptLatinNumber,
/*  5d CANADIAN            */  ScriptLatinNumber,
/*  5e ETHIOPIC            */  ScriptLatinNumber,
/*  5f TAMAZIGHT           */  ScriptArabicNum,
/*  60 KASHMIRI            */  ScriptUrduNum,
/*  61 NEPALI              */  ScriptHindiNum,
/*  62 FRISIAN             */  ScriptLatinNumber,
/*  63 PASHTO              */  ScriptUrduNum,
/*  64 FILIPINO            */  ScriptLatinNumber,
/*  65 THAANA/MALDIVIAN    */  ScriptLatinNumber,
/*  66 EDO                 */  ScriptLatinNumber,
/*  67 FULFULDE            */  ScriptLatinNumber,
/*  68 HAUSA               */  ScriptLatinNumber,
/*  69 IBIBIO              */  ScriptLatinNumber,
/*  6a YORUBA              */  ScriptLatinNumber,
/*  6b                     */  ScriptLatinNumber,
/*  6c                     */  ScriptLatinNumber,
/*  6d                     */  ScriptLatinNumber,
/*  6e                     */  ScriptLatinNumber,
/*  6f                     */  ScriptLatinNumber,
/*  70 IGBO                */  ScriptLatinNumber,
/*  71 KANURI              */  ScriptLatinNumber,
/*  72 OROMO               */  ScriptLatinNumber,
/*  73 TIGRIGNA            */  ScriptLatinNumber,
/*  74 GUARANI             */  ScriptLatinNumber,
/*  75 HAWAIIAN            */  ScriptLatinNumber,
/*  76 LATIN               */  ScriptLatinNumber,
/*  77 SOMOLI              */  ScriptLatinNumber,
/*  78 YI                  */  ScriptLatinNumber
};

/**************************************************************************\
*
* Function Description:
*   this function check for the digit substitution according to the 
*   giving language and return the numeric script matches this language.
*   it also create and maintain the cache from the system.
*
* Arguments:
*   language [in] the language to check for digit substitution.
*
* Return Value:
*   the numeric script for that language or ScriptNone for no substitution
*
* Created:
*   originaly created by msadek and modified by tarekms to fit in the 
*   new design
*
\**************************************************************************/
const ItemScript GetNationalDigitScript(LANGID language)
{
    if(Globals::NationalDigitCache == NULL)
    {
        Globals::NationalDigitCache = new IntMap<BYTE>;
        if (!Globals::NationalDigitCache || Globals::NationalDigitCache->GetStatus() != Ok)
        {
            delete Globals::NationalDigitCache, Globals::NationalDigitCache = 0;
            return ScriptNone;
        }
    }
    
    switch(Globals::NationalDigitCache->Lookup(language))
    {
        case 0xff:
            // checked before and not digit substitutions needed
            return ScriptNone;

        case 0x01:
            // checked before and should be mapped to Traditional
            if(PRIMARYLANGID(language) > (ARRAY_SIZE(LanguageToDigitScript)-1))
            {
                return ScriptNone;
            }
            
            if (languageDigits[LanguageToDigitScript[PRIMARYLANGID(language)]][0] == 0)
            {
                return ScriptNone;
            }
            else
            {
                return LanguageToDigitScript[PRIMARYLANGID(language)];
            }

        case 0x00:
            // never visited before, have to fetch it from registry.
            LCID locale = MAKELCID(language, SORT_DEFAULT);
            WCHAR digits[20];
            DWORD   bufferCount;
            if(!IsValidLocale(locale, LCID_INSTALLED))
            {
                Globals::NationalDigitCache->Insert(language, 0xff);
                return ScriptNone;
            }

            BOOL isThereSubstitution = FALSE;
            if (Globals::IsNt)
            {
                bufferCount = GetLocaleInfoW(locale,
                                             LOCALE_SNATIVEDIGITS,
                                             digits, 20);
                isThereSubstitution = (bufferCount>1 && (digits[1] != 0x0031));
            }
            else
            {
                // GetLocaleInfoW fails on Windows 9x. and we cannot depend on 
                // GetLocalInfoA because it returns Ansi output which wouldn't help
                // So we hard coded the information from the file:
                // %sdxroot%\base\win32\winnls\data\other\locale.txt
                
                switch (locale)
                {
                    case 0x0401:           // Arabic   - Saudi Arabia
                    case 0x0801:           // Arabic   - Iraq
                    case 0x0c01:           // Arabic   - Egypt
                    case 0x2001:           // Arabic   - Oman
                    case 0x2401:           // Arabic   - Yemen
                    case 0x2801:           // Arabic   - Syria
                    case 0x2c01:           // Arabic   - Jordan
                    case 0x3001:           // Arabic   - Lebanon
                    case 0x3401:           // Arabic   - Kuwait
                    case 0x3801:           // Arabic   - U.A.E.
                    case 0x3c01:           // Arabic   - Bahrain
                    case 0x4001:           // Arabic   - Qatar
                    case 0x041e:           // Thai     - Thailand
                    case 0x0420:           // Urdu     - Pakistan
                    case 0x0429:           // Farsi    - Iran
                    case 0x0446:           // Punjabi  - India (Gurmukhi Script)
                    case 0x0447:           // Gujarati - India (Gujarati Script)
                    case 0x044a:           // Telugu   - India (Telugu Script)
                    case 0x044b:           // Kannada  - India (Kannada Script)
                    case 0x044e:           // Marathi  - India
                    case 0x044f:           // Sanskrit - India
                    case 0x0457:           // Konkani  - India
                        isThereSubstitution = TRUE;
                        break;
                    default:
                        isThereSubstitution = FALSE;
                        break;
                }
            }

            if (isThereSubstitution)
            {
                if(PRIMARYLANGID(language) > (ARRAY_SIZE(LanguageToDigitScript)-1))
                {
                    Globals::NationalDigitCache->Insert(language, 0xff);
                    return ScriptNone;
                }
                Globals::NationalDigitCache->Insert(language, 0x01);

                if (languageDigits[LanguageToDigitScript[PRIMARYLANGID(language)]][0] == 0)
                {
                    return ScriptNone;
                }
                else
                {
                    return LanguageToDigitScript[PRIMARYLANGID(language)];
                }
            }
            else
            {
                Globals::NationalDigitCache->Insert(language, 0xff);
                return ScriptNone;
            }
    }
    return ScriptNone;
}

/**************************************************************************\
*
* Function Description:
*   it gets the suitable numeric script for digit substitution 
*
* Arguments:
*   substitute  [in] the type of the substitution.
*   language    [in] the language to check for digit substitution.
*
* Return Value:
*   the numeric script for that language or ScriptNone for no substitution
*
* Created:
*   originaly created by msadek and modified by tarekms to fit in the 
*   new design
*
\**************************************************************************/

const ItemScript GetDigitSubstitutionsScript(GpStringDigitSubstitute substitute, LANGID language)
{
    if (LANG_NEUTRAL == PRIMARYLANGID(language))
    {
        switch(SUBLANGID(language))
        {
            case SUBLANG_SYS_DEFAULT:
                language = LANGIDFROMLCID(ConvertDefaultLocale(LOCALE_SYSTEM_DEFAULT));
            break;

            case  SUBLANG_DEFAULT:
                language = LANGIDFROMLCID(ConvertDefaultLocale(LOCALE_USER_DEFAULT));
            break;
            
            case SUBLANG_NEUTRAL:
            default : // treat anything else as user English.
                language = LANG_ENGLISH;
        }
    }
    
    if(StringDigitSubstituteNone == substitute
        || (LANG_ENGLISH == PRIMARYLANGID(language)
        && StringDigitSubstituteUser != substitute))
    {
        return ScriptNone;
    }
    
    switch(substitute)
    {
        case StringDigitSubstituteTraditional:

            if(PRIMARYLANGID(language) > (ARRAY_SIZE(LanguageToDigitScript)-1))
            {
                return ScriptNone;
            }

            if ( languageDigits[LanguageToDigitScript[PRIMARYLANGID(language)]][0] == 0)
            {
                return ScriptNone;
            }
            else
            {
                return LanguageToDigitScript[PRIMARYLANGID(language)];
            }

        case StringDigitSubstituteNational:

            return GetNationalDigitScript(language);

        case StringDigitSubstituteUser:

            LANGID userLanguage = GetUserLanguageID();

            switch (UserDigitSubstitute)
            {
                case StringUserDigitSubstituteContext:
                    if ((PRIMARYLANGID(userLanguage) != LANG_ARABIC)
                        && (PRIMARYLANGID(userLanguage) != LANG_FARSI))
                    {
                        return ScriptNone;
                    }
                    return ScriptContextNum;

                case StringUserDigitSubstituteNone:
                    return ScriptNone;

                case StringUserDigitSubstituteNational:
                    return GetNationalDigitScript(userLanguage);
            }
    }
    return ScriptNone;
}


LANGID GetUserLanguageID()
{
    if(Globals::UserDigitSubstituteInvalid)
    {
        WCHAR digits[20];
        DWORD bufferCount = 0;
        UserLocale = ConvertDefaultLocale(LOCALE_USER_DEFAULT);

        // LOCALE_IDIGITSUBSTITUTION is not defined on Windows 9x platforms
        // also GetLocaleInfoW is fail on Windows 9x so we avoid calling it
        // just in case it might return undefined result.
        
        if (Globals::IsNt)
        {
            bufferCount = GetLocaleInfoW(UserLocale,
                                LOCALE_IDIGITSUBSTITUTION,
                                digits, 20);
        }
        
        if (bufferCount == 0)
        {
            // Not on NT, or no such LC type, so read HKCU\Control Panel\International\NumShape
            DWORD   dwType;
            long    rc;             // Registry return code
            HKEY    hKey;           // Registry key
            if (RegOpenKeyExA(HKEY_CURRENT_USER,
                            "Control Panel\\International",
                            0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                digits[0] = 0;
                if ((rc = RegQueryValueExA(hKey,
                                "NumShape",
                                NULL,
                                &dwType,
                                (BYTE*)digits,
                                &bufferCount) != ERROR_SUCCESS))
                { 
                    bufferCount = 0;
                }
                RegCloseKey(hKey);
            }
        }
                     
        switch(digits[0])
        {
            case 0x0032:
                UserDigitSubstitute = StringUserDigitSubstituteNational;
                break;
                        
            case 0x0031:
                UserDigitSubstitute = StringUserDigitSubstituteNone;
                break;
                     
            case 0x0030:
                default:
                UserDigitSubstitute = StringUserDigitSubstituteContext;
        }

        Globals::UserDigitSubstituteInvalid = FALSE;
    }

    return LANGIDFROMLCID(UserLocale);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\driverstringimager.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   DriverStringImager.cpp
*
* Abstract:
*
*   Legacy text support. Provides basic glyphing - a subset of ExtTextOut.
*
* Notes:
*
*   No built in support for International text.
*   No built in support for surrogate codepoints.
*
*   The imager constructor does most of the work imaging the string.
*   It prepares the glyphs through CMAP and GSUB if necessary,  and
*   establishes their device positions.
*
*
* Created:
*
*   08/07/00 dbrown
*
\**************************************************************************/

#include "precomp.hpp"



/// VerticalAnalysis
//
//  Sets the Orientation span vector to 'ItemSideways' for characters that need
//  laying on their side, leaves it as zero for characters that remain
//  upright.
//
//  Returns TRUE if any sideways runs present in the text.

GpStatus DriverStringImager::VerticalAnalysis(BOOL * sideways)
{
    INT  runStart = 0;
    INT  state    = 0;   // 0 == upright,  1 == sideways
    *sideways = FALSE;


    // Find and mark sideways spans

    for (INT i=0; i<=GlyphCount; i++)
    {
        BYTE  chClass;

        if (i < GlyphCount)
        {
            const WCHAR ch = String[i];
            chClass = ScBaseToScFlags[SecondaryClassificationLookup[ch >> 8][ch & 0xFF]];
        }
        else
        {
            // Dummy terminator to force flush
            if (state == 0)
            {
                chClass = SecClassSA | SecClassSF;
            }
            else
            {
                chClass = 0;
            }
        }


        switch (state)
        {

        case 0: // upright
            if (    (chClass & (SecClassSA | SecClassSF))
                &&  (i < GlyphCount))
            {
                // begin sideways run
                runStart = i;
                state = 1;
                *sideways = TRUE;
            }
            break;

        case 1: // sideways
            if (!(chClass & (SecClassSA | SecClassSF)))
            {
                // Exit sideways run
                if (i > runStart)
                {
                    // Draw glyphs from runStart to i as sideways
                    GpStatus status = OrientationVector.SetSpan(runStart, i-runStart, ItemSideways);
                    if (status != Ok)
                        return status;
                }
                runStart = i;
                state = 0;
            }
            break;
        }
    }

    return Ok;
}






///// AddToPath - add glyphs to path
//
//


GpStatus DriverStringImager::AddToPath(
    GpPath                  *path,
    const UINT16            *glyphs,
    const PointF            *glyphOrigins,
    INT                      glyphCount,
    GpMatrix                *fontTransform,
    BOOL                     sideways
)
{
    GpStatus status = Ok;

    fontTransform->Scale(FontScale, FontScale);
    if (GlyphTransform)
    {
        fontTransform->Append(*GlyphTransform);
        fontTransform->RemoveTranslation();
    }

    // Build a face realization and prepare to adjust glyph placement

    const GpMatrix identity;

    GpFaceRealization faceRealization(
        Face,
        Font->GetStyle(),
        &identity,
        SizeF(150.0, 150.0),    // Arbitrary - we won't be hinting
        TextRenderingHintSingleBitPerPixel, // claudebe, do we want to allow for hinted or unhinted path ? // graphics->GetTextRenderingHint(),
        TRUE, /* bPath */
        TRUE, /* bCompatibleWidth */
        sideways
    );


    status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);

    for (INT i = 0; i < glyphCount; ++i)
    {
        // Set marker at start of each logical character = cell = cluster

        path->SetMarker();

        // Add the path for the glyph itself

        GpGlyphPath *glyphPath = NULL;

        PointF sidewaysOffset;

        status = faceRealization.GetGlyphPath(
            *(glyphs+i),
            &glyphPath,
            &sidewaysOffset
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        PointF glyphOffset(OriginOffset);

        if (sideways)
        {
            fontTransform->VectorTransform(&sidewaysOffset);
            glyphOffset = glyphOffset - sidewaysOffset;
        }


        if (glyphPath)
        {
            status = path->AddGlyphPath(
                glyphPath,
                glyphOrigins[i].X + glyphOffset.X,
                glyphOrigins[i].Y + glyphOffset.Y,
                fontTransform
            );
            IF_NOT_OK_WARN_AND_RETURN(status);
        }
    }

    // Force marker following last glyph

    path->SetMarker();

    return status;
}



/// GenerateWorldOrigins
//
//  Builds the world origins array (or assigns it from Positions, when that
//  is available).


GpStatus DriverStringImager::GenerateWorldOrigins()
{
    if (WorldOrigins != NULL)
    {
        // World origins have already been calculated

        return Status;
    }

    if (!(Flags & DriverStringOptionsRealizedAdvance))
    {
        // Easy, the client already gave us world positions.
        WorldOrigins = Positions;
    }
    else
    {
        // Map device origins back to world origins

        WorldOriginBuffer.SetSize(GlyphCount);
        if (!WorldOriginBuffer)
        {
            return OutOfMemory;
        }

        memcpy(WorldOriginBuffer.Get(), DeviceOrigins.Get(), GlyphCount * sizeof(PointF));

        GpMatrix deviceToWorld(WorldToDevice);
        deviceToWorld.Invert();
        deviceToWorld.Transform(WorldOriginBuffer.Get(), GlyphCount);

        if (Flags & DriverStringOptionsVertical)
        {
            // Correct western baseline to center baseline

            for (INT i=0; i<GlyphCount; i++)
            {
                WorldOriginBuffer[i].X -= OriginOffset.X;
                WorldOriginBuffer[i].Y -= OriginOffset.Y;
            }
        }

        WorldOrigins = WorldOriginBuffer.Get();
    }

    return Ok;
}






/////  RecordEmfPlusDrawDriverString
//
//      Records EMF+ records describing DrawDriverString

GpStatus DriverStringImager::RecordEmfPlusDrawDriverString(
    const GpBrush   *brush
)
{
    Status = GenerateWorldOrigins();
    if (Status != Ok)
    {
        return Status;
    }

    // First measure the text bounding rectangle

    GpRectF boundingBox;

    Status = Measure(&boundingBox);
    if (Status != Ok)
    {
        // MeasureDriverString failed, we cannot continue

        Graphics->SetValid(FALSE);      // Prevent any more recording
        return Status;
    }


    // Transform bounding box to device coordinates

    GpRectF deviceBounds;

    TransformBounds(
        &WorldToDevice,
        boundingBox.X,
        boundingBox.Y,
        boundingBox.GetRight(),
        boundingBox.GetBottom(),
        &deviceBounds
    );


    // Finally record details in the EmfPlus metafile

    Status = Graphics->Metafile->RecordDrawDriverString(
        &deviceBounds,
        String ? String : Glyphs,
        GlyphCount,
        Font,
        brush,
        WorldOrigins,
        Flags & ~DriverStringOptionsRealizedAdvance,
        GlyphTransform
    );

    if (Status != Ok)
    {
        Graphics->SetValid(FALSE);      // Prevent any more recording
    }

    return Status;
}





/////   GetDriverStringGlyphOrigins
//
//      Establishes glyph origins for DriverString functions when the client
//      passes just the origin with DriverStringOptionsRealizedAdvance.
//
//      The firstGlyph and glyphCopunt parameters allow the client to obtain
//      glyph origins for a subrange of glyphs.

GpStatus DriverStringImager::GetDriverStringGlyphOrigins(
    IN   const GpFaceRealization  *faceRealization,
    IN   INT                       firstGlyph,
    IN   INT                       glyphCount,
    IN   BOOL                      sideways,
    IN   const GpMatrix           *fontTransform,
    IN   INT                       style,
    IN   const PointF             *positions,      // position(s) in world coords
    OUT  PointF                   *glyphOrigins,   // position(s) in device coords
    OUT  PointF                   *finalPosition   // position following final glyph
)
{
    FontTransform = fontTransform;
    Style = style;

    // FinalPosition is provided to return the position at the end of the string
    // to a caller that is implementing realized advance in multiple substrings.
    // FinalPosition is not supported other than in the realized advance case.

    ASSERT(!finalPosition || (Flags & DriverStringOptionsRealizedAdvance));


    // If the glyphs are to be rendered using their own widths, or if they are
    // to be rendered sideways, or in vertical progression we'll need the
    // x,y components of a unit vector along the transformed baseline
    // and the transformed ascender.

    double baselineScale = 0;
    double baselineDx    = 0;
    double baselineDy    = 0;
    double ascenderScale = 0;
    double ascenderDx    = 0;
    double ascenderDy    = 0;


    if (    Flags & DriverStringOptionsVertical
        ||  Flags & DriverStringOptionsRealizedAdvance
        ||  sideways)
    {
        // Calculate device dx,dy for font 0,1 and 1,0 vectors

        if (Flags & DriverStringOptionsVertical)
        {
            ascenderDx = fontTransform->GetM11();
            ascenderDy = fontTransform->GetM12();
            baselineDx = fontTransform->GetM21();
            baselineDy = fontTransform->GetM22();
        }
        else
        {
            baselineDx = fontTransform->GetM11();
            baselineDy = fontTransform->GetM12();
            ascenderDx = fontTransform->GetM21();
            ascenderDy = fontTransform->GetM22();
        }

        baselineScale = sqrt(baselineDx*baselineDx + baselineDy*baselineDy);
        baselineDx /= baselineScale;
        baselineDy /= baselineScale;

        ascenderScale = sqrt(ascenderDx*ascenderDx + ascenderDy*ascenderDy);
        ascenderDx /= ascenderScale;
        ascenderDy /= ascenderScale;
    }


    if (Flags & DriverStringOptionsRealizedAdvance)
    {
        // Get glyph baseline advances for this glyph subrange

        DeviceAdvances.SetSize(glyphCount);
        if (!DeviceAdvances)
        {
            WARNING(("DeviceAdvances not allocated - out of memory"));
            return OutOfMemory;
        }

        GpStatus status = faceRealization->GetGlyphStringDeviceAdvanceVector(
            Glyphs + firstGlyph,
            glyphCount,
            sideways,
            DeviceAdvances.Get()
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        // Generate realized advances

        glyphOrigins[0] = positions[0];
        if (Flags & DriverStringOptionsVertical)
        {
            glyphOrigins[0].X += OriginOffset.X;
            glyphOrigins[0].Y += OriginOffset.Y;
        }
        WorldToDevice.Transform(glyphOrigins, 1);


        // Accumulate advances

        for (INT i=0; i<glyphCount-1; i++)
        {
            glyphOrigins[i+1].X = glyphOrigins[i].X + TOREAL(baselineDx * DeviceAdvances[i]);
            glyphOrigins[i+1].Y = glyphOrigins[i].Y + TOREAL(baselineDy * DeviceAdvances[i]);
        }


        if (finalPosition)
        {
            finalPosition->X = glyphOrigins[glyphCount-1].X + TOREAL(baselineDx * DeviceAdvances[glyphCount-1]);
            finalPosition->Y = glyphOrigins[glyphCount-1].Y + TOREAL(baselineDy * DeviceAdvances[glyphCount-1]);
            GpMatrix deviceToWorld(WorldToDevice);
            deviceToWorld.Invert();
            deviceToWorld.Transform(finalPosition);
            if (Flags & DriverStringOptionsVertical)
            {
                finalPosition->X -= OriginOffset.X;
                finalPosition->Y -= OriginOffset.Y;
            }
        }
    }
    else
    {
        // Derive device origins directly from world origins

        for (INT i=0; i<glyphCount; i++)
        {
            glyphOrigins[i] = positions[i];
            if (Flags & DriverStringOptionsVertical)
            {
                glyphOrigins[i].X += OriginOffset.X;
                glyphOrigins[i].Y += OriginOffset.Y;
            }
            WorldToDevice.Transform(glyphOrigins+i);
        }
    }

    return Ok;
}





/////   DriverStringImager constructor
//
//      Performs most of the driver string processing.
//
//      Allocate private glyph buffer and do CMAP lookup (if DriverStringOptionsCmapLookup)
//      Do sideways glyph analysis (if DriverStringOptionsVertical)
//      Generate FaceRealization(s) (Both upright and sideways for vertical text)
//      Generate individual glyph origins (if not DriverStringOptionsRealizedAdvance)
//      Generate device glyph origins



DriverStringImager::DriverStringImager(
    const UINT16    *text,
    INT              glyphCount,
    const GpFont    *font,
    const PointF    *positions,
    INT              flags,
    GpGraphics      *graphics,
    const GpMatrix  *glyphTransform
) :
    String                      (NULL),
    Glyphs                      (NULL),
    GlyphCount                  (glyphCount),
    Font                        (font),
    Face                        (NULL),
    Positions                   (positions),
    Flags                       (flags),
    Graphics                    (graphics),
    GlyphTransform              (glyphTransform),
    Status                      (Ok),
    WorldOrigins                (NULL),
    OriginOffset                (PointF(0,0)),
    OrientationVector           (0),
    UprightFaceRealization      (NULL),
    SidewaysFaceRealization     (NULL),
    GlyphBuffer                 (NULL)
{
    if (GlyphCount == -1)
    {
        ASSERT(Flags & DriverStringOptionsCmapLookup);
        GlyphCount = UnicodeStringLength(text);
    }

    if (GlyphCount < 0)
    {
        Status = InvalidParameter;
        return;
    }

    if (GlyphCount == 0)
    {
        return;  // Nothing to do
    }

    Face = font->GetFace();
    if (!Face)
    {
        Status = InvalidParameter;
        return;
    }

    Graphics->GetWorldToDeviceTransform(&WorldToDevice);

    if (!WorldToDevice.IsInvertible())
    {
        ASSERT(WorldToDevice.IsInvertible());
        Status = InvalidParameter;    // Can't continue unless we can get
        return;                       // back from device to world coords.
    }


    // Build font realizations

    EmSize = font->GetEmSize();
    INT style  = font->GetStyle();

    if (Font->GetUnit() != UnitWorld)
    {
        EmSize *= Graphics->GetScaleForAlternatePageUnit(font->GetUnit());
    }

    if (EmSize <= 0.0)
    {
        Status = InvalidParameter;
        return;
    }


    // Choose an appropriate world to ideal scale

    WorldToIdeal = TOREAL(2048.0 / EmSize);


    // Establish font transformation

    FontScale = TOREAL(EmSize / Face->GetDesignEmHeight());

    GpMatrix fontTransform(
        WorldToDevice.GetM11(),
        WorldToDevice.GetM12(),
        WorldToDevice.GetM21(),
        WorldToDevice.GetM22(),
        0,
        0
    );
    fontTransform.Scale(FontScale, FontScale);

    if (GlyphTransform)
    {
        fontTransform.Prepend(*GlyphTransform);
    }


    // Check that the font transform matrix will leave fonts at a visible size

    {
        PointF oneOne(1.0,1.0);
        fontTransform.VectorTransform(&oneOne);
        INT faceEmHeight = Face->GetDesignEmHeight();

        // How high will an em be on the output device?

        if (    (faceEmHeight*faceEmHeight)
            *   (oneOne.X*oneOne.X + oneOne.Y*oneOne.Y)
            <   .01)
        {
            // Font would be < 1/10 of a pixel high
            GlyphCount = 0; // Treat same as an empty string
            Status = Ok;
            return; // Transform matrix could cause out of range values or divide by 0 errors
        }
    }


    // Determine offset from top center to top baseline in world units

    if (Flags & DriverStringOptionsVertical)
    {
        OriginOffset.X = (Face->GetDesignCellDescent() - Face->GetDesignCellAscent())
                         * FontScale
                         / 2.0f;
        if (GlyphTransform)
        {
            GlyphTransform->VectorTransform(&OriginOffset);
        }
    }


    GpMatrix uprightTransform(fontTransform);

    if (Flags & DriverStringOptionsVertical)
    {
        // Upright glyphs (e.g. English) will be rotated 90 degrees clockwise
        uprightTransform.Rotate(90);
    }

    UprightFaceRealization = new GpFaceRealization(
        Face,
        style,
        &uprightTransform,
        SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
        Graphics->GetTextRenderingHintInternal(),
        FALSE, /* bPath */
        TRUE, /* bCompatibleWidth */
        FALSE  // not sideways
    );

    if (!UprightFaceRealization)
    {
        Status = OutOfMemory;
        return;
    }
    Status = UprightFaceRealization->GetStatus();
    if (Status != Ok)
        return;

    if (Flags & DriverStringOptionsLimitSubpixel)
        UprightFaceRealization->SetLimitSubpixel(TRUE);

    // Handle CMAP lookup and vertical analysis

    if (flags & DriverStringOptionsCmapLookup)
    {
        String = text;
        GlyphBuffer.SetSize(GlyphCount);
        if (!GlyphBuffer)
        {
            Status = OutOfMemory;
            return;
        }

        Face->GetCmap().LookupUnicode(text, GlyphCount, GlyphBuffer.Get(), NULL, TRUE);
        Glyphs = GlyphBuffer.Get();

        if (Flags & DriverStringOptionsVertical)
        {
            // Assume entire run is upright

            Status = OrientationVector.SetSpan(0, GlyphCount, 0);
            if (Status != Ok)
                return;

            if (!Face->IsSymbol())
            {
                BOOL sideways = FALSE;

                Status = VerticalAnalysis(&sideways);
                if (Status != Ok)
                    return;

                if (sideways)
                {
                    // Will need a sideways realization too

                    SidewaysFaceRealization = new GpFaceRealization(
                        Face,
                        style,
                        &fontTransform,
                        SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
                        Graphics->GetTextRenderingHintInternal(),
                        FALSE, /* bPath */
                        TRUE, /* bCompatibleWidth */
                        TRUE  // sideways
                    );
                    if (!SidewaysFaceRealization)
                    {
                        Status = OutOfMemory;
                        return;
                    }
                    Status = SidewaysFaceRealization->GetStatus();
                    if (Status != Ok)
                        return;

                    if (Flags & DriverStringOptionsLimitSubpixel)
                        SidewaysFaceRealization->SetLimitSubpixel(TRUE);
                }
            }
        }
    }
    else
    {
        String = NULL;
        Glyphs = text;
    }


    // Generate individual glyph origins

    DeviceOrigins.SetSize(GlyphCount);
    if (!DeviceOrigins)
    {
        Status = OutOfMemory;
        return;
    }

    // Get glyph origins in device coordinates


    if (!SidewaysFaceRealization)
    {
        // Simple case - all glyphs are upright (though the text may be vertical)

        Status = GetDriverStringGlyphOrigins(
            UprightFaceRealization,
            0,
            GlyphCount,
            FALSE,                // Upright
            &fontTransform,
            style,
            Positions,
            DeviceOrigins.Get(),
            NULL                  // Don't need final position
        );
    }
    else
    {
        // Complex case - runs of upright and sideways glyphs

        SpanRider<BYTE> orientationRider(&OrientationVector);
        PointF runOrigin(Positions[0]);

        while (!orientationRider.AtEnd())
        {
            BOOL runSideways = orientationRider.GetCurrentElement();

            if (runSideways) {

                if (!GlyphBuffer) {

                    // We'll need a copy of the glyphs

                    GlyphBuffer.SetSize(GlyphCount);
                    if (!GlyphBuffer)
                    {
                        Status = OutOfMemory;
                        return;
                    }
                    memcpy(GlyphBuffer.Get(), Glyphs, GlyphCount * sizeof(UINT16));
                    Glyphs = GlyphBuffer.Get();
                }

                // Apply OpenType vertical glyph substitution to sideways glyphs

                ASSERT(orientationRider.GetCurrentSpan().Length <  65536);

                if (Face->GetVerticalSubstitutionOriginals() != NULL) {
                    SubstituteVerticalGlyphs(
                        GlyphBuffer.Get() + orientationRider.GetCurrentSpanStart(),
                        static_cast<UINT16>(orientationRider.GetCurrentSpan().Length),
                        Face->GetVerticalSubstitutionCount(),
                        Face->GetVerticalSubstitutionOriginals(),
                        Face->GetVerticalSubstitutionSubstitutions()
                    );
                }
            }


            // GetDriverStringGlyphOrigins handles both realized and user
            // supplied glyph positions. For realized positions we need to pass
            // the origin of each run and get back the final position for that
            // run. For User supplied positions we pass the appropriate slice
            // of the user supplied array.

            const PointF *positions;
            PointF       *finalPosition;


            if (Flags & DriverStringOptionsRealizedAdvance)
            {
                    positions     = &runOrigin;
                    finalPosition = &runOrigin; // Required origin for next run
            }
            else
            {
                    positions     = Positions + orientationRider.GetCurrentSpanStart();
                    finalPosition = NULL;  // Next run position determined by callers glyph positions
            }

            Status = GetDriverStringGlyphOrigins(
                runSideways ? SidewaysFaceRealization : UprightFaceRealization,
                orientationRider.GetCurrentSpanStart(),
                orientationRider.GetCurrentSpan().Length,
                runSideways,
                &fontTransform,
                style,
                positions,
                DeviceOrigins.Get() + orientationRider.GetCurrentSpanStart(),
                finalPosition
            );

            if (Status != Ok)
            {
                return;
            }

            orientationRider++;
        }
    }
}




/// DrawGlyphRange
//
//  Draws glyphs in the specified range at origins in the Position buffer

GpStatus DriverStringImager::DrawGlyphRange(
    const GpFaceRealization  *faceRealization,
    const GpBrush            *brush,
    INT                       first,
    INT                       length
)
{
    GpStatus status;
    BOOL sideways = (SpanRider<BYTE>(&OrientationVector)[first] != 0);

    // if we record to a Meta file and even the font is Path font, we need to record
    // the call as ExtTextOut not as PolyPolygon.

    SetTextLinesAntialiasMode linesMode(Graphics, faceRealization);

    if (faceRealization->IsPathFont() &&
        Graphics->Driver != Globals::MetaDriver)
    {
        // the font size is too big to be handled by bitmap, we need to use path
        GpPath path(FillModeWinding);
        GpLock lockGraphics(Graphics->GetObjectLock());

        status = GenerateWorldOrigins();
        IF_NOT_OK_WARN_AND_RETURN(status);

        GpMatrix fontTransform;

        BOOL vertical = (Flags & DriverStringOptionsVertical);

        if (sideways && !vertical)
        {
            //  Horizontal sideways, rotate -90 degree
            fontTransform.Rotate(-90);
        }
        if (!sideways && vertical)
        {
            //  Vertical upright, rotate 90 degree
            fontTransform.Rotate(90);
        }

        status = AddToPath(
            &path,
            Glyphs + first,
            WorldOrigins + first,
            length,
            &fontTransform,
            sideways
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        status = Graphics->FillPath(brush, &path);
    }
    else
    {
        // Draw glyphs on device surface

        INT drawFlags = 0;

        status = Graphics->DrawPlacedGlyphs(
            faceRealization,
            brush,
            drawFlags,
            String+first,
            length,
            FALSE,
            Glyphs+first,
            NULL,   // no mapping (it is 1 to 1)
            DeviceOrigins.Get()+first,
            length,
            ScriptNone,
            sideways
        );
    }

    IF_NOT_OK_WARN_AND_RETURN(status);

    // we disable underline/strikeout when RealizedAdvance is OFF
    // in future we would like to underline individual glyphs
    if ((Font->GetStyle() & (FontStyleUnderline | FontStyleStrikeout)) &&
        (Flags & DriverStringOptionsRealizedAdvance))
    {
        RectF   baseline;

        status = MeasureString(
            NULL,   // need no bounding box
            &baseline
        );

        IF_NOT_OK_WARN_AND_RETURN(status);

        status = Graphics->DrawFontStyleLine(
            &PointF(
                baseline.X,
                baseline.Y
            ),
            baseline.Width,
            Face,
            brush,
            Flags & DriverStringOptionsVertical,
            EmSize,
            Font->GetStyle(),
            GlyphTransform
        );
    }

    return status;
}






/////   Draw
//
//


GpStatus DriverStringImager::Draw(
    IN const GpBrush *brush
)
{
    if (    Status != Ok
        ||  GlyphCount <= 0)
    {
        return Status;
    }


    if (Graphics->IsRecording())
    {
        Status = RecordEmfPlusDrawDriverString(brush);

        if (    Status != Ok
            ||  !Graphics->DownLevel)
        {
            // Exit on error, or if we don't need to create downlevel records
            return Status;
        }
    }

    EmfPlusDisabler disableEmfPlus(&Graphics->Metafile);

    if (SidewaysFaceRealization)
    {
        // Complex case

        SpanRider<BYTE> orientationRider(&OrientationVector);

        while (!orientationRider.AtEnd())
        {
            Status = DrawGlyphRange(
                orientationRider.GetCurrentElement()
                    ? SidewaysFaceRealization
                    : UprightFaceRealization,
                brush,
                orientationRider.GetCurrentSpanStart(),
                orientationRider.GetCurrentSpan().Length
            );

            orientationRider++;
        }
    }
    else
    {
        // Simple case
        Status = DrawGlyphRange(
            UprightFaceRealization,
            brush,
            0,
            GlyphCount
        );
    }

    return Status;
}






/////   Measure
//
//


GpStatus DriverStringImager::Measure(
    OUT RectF   *boundingBox   // Overall bounding box of cells
)
{
    Status = MeasureString(
        boundingBox
    );

    IF_NOT_OK_WARN_AND_RETURN(Status);

    if (GlyphTransform)
    {
        if (Flags & DriverStringOptionsRealizedAdvance)
        {
            TransformBounds(
                GlyphTransform,
                boundingBox->X,
                boundingBox->Y,
                boundingBox->X + boundingBox->Width,
                boundingBox->Y + boundingBox->Height,
                boundingBox
            );
        }
    }
    return Status;
}




GpStatus DriverStringImager::MeasureString(
    OUT RectF   *boundingBox,       // Overall bounding box of cells
    OUT RectF   *baseline           // base line rectangle with 0 height
)
{
    if (    Status != Ok
        ||  GlyphCount <= 0)
    {
        memset(boundingBox, 0, sizeof(*boundingBox));
        return Status;
    }


    Status = GenerateWorldOrigins();
    if (Status != Ok)
    {
        return Status;
    }


    // Build cell boundaries one by one, and return overall bounding rectangle

    GpMatrix glyphInverseTransform;

    if (GlyphTransform  &&  GlyphTransform->IsInvertible())
    {
        glyphInverseTransform = *GlyphTransform;
        glyphInverseTransform.Invert();
    }

    PointF pt = WorldOrigins[0];
    if (Flags & DriverStringOptionsRealizedAdvance)
    {
        glyphInverseTransform.Transform(&pt, 1);
    }

    REAL minX = pt.X;
    REAL minY = pt.Y;
    REAL maxX = pt.X;
    REAL maxY = pt.Y;

    REAL designToWorld  = EmSize / Face->GetDesignEmHeight();
    REAL ascent         = Face->GetDesignCellAscent() * designToWorld;
    REAL descent        = Face->GetDesignCellDescent() * designToWorld;


    // Get glyph design widths

    AutoBuffer<UINT16, 32> designAdvances(GlyphCount);
    if (!designAdvances)
    {
        return OutOfMemory;
    }


    Face->GetGlyphDesignAdvances(
        Glyphs,
        GlyphCount,
        Font->GetStyle(),
        Flags & DriverStringOptionsVertical ? TRUE : FALSE,
        1.0,
        designAdvances.Get()
    );


    PointF baselineOrigin(pt);


    // Establish overall string bounds

    if (!(Flags & DriverStringOptionsVertical))
    {
        //  Easy case as all characters are upright.

        for (INT i=0; i<GlyphCount; i++)
        {
            if (Glyphs[i] != 0xffff)
            {
                pt = WorldOrigins[i];
                REAL glyphMinX = 0;
                REAL glyphMinY = -ascent;
                REAL glyphMaxX = designAdvances[i] * designToWorld;
                REAL glyphMaxY = descent;
                if (Flags & DriverStringOptionsRealizedAdvance)
                {
                    glyphInverseTransform.Transform(&pt, 1);
                    minX = min(minX, pt.X + glyphMinX);
                    minY = min(minY, pt.Y + glyphMinY);
                    maxX = max(maxX, pt.X + glyphMaxX);
                    maxY = max(maxY, pt.Y + glyphMaxY);
                }
                else
                {
                    RectF bbox;
                    TransformBounds(
                        GlyphTransform,
                        glyphMinX,
                        glyphMinY,
                        glyphMaxX,
                        glyphMaxY,
                        &bbox
                    );
                    bbox.X += pt.X;
                    bbox.Y += pt.Y;
                    minX = min(minX, bbox.X);
                    minY = min(minY, bbox.Y);
                    maxX = max(maxX, bbox.X + bbox.Width);
                    maxY = max(maxY, bbox.Y + bbox.Height);
                }

                baselineOrigin.Y = max(baselineOrigin.Y, pt.Y);
            }
        }

        if (baseline)
        {
            baseline->X      = baselineOrigin.X;
            baseline->Y      = baselineOrigin.Y;
            baseline->Width  = maxX - minX;
            baseline->Height = 0.0;
        }
    }
    else
    {
        //  Complex, there might be mixed sideway and upright items.

        AutoBuffer<UINT16, 32> designHmtxAdvances(GlyphCount);

        if (!designHmtxAdvances)
        {
            return OutOfMemory;
        }

        Face->GetGlyphDesignAdvances(
            Glyphs,
            GlyphCount,
            Font->GetStyle(),
            FALSE,  // hmtx
            1.0,
            designHmtxAdvances.Get()
        );


        SpanRider<BYTE> orientationRider(&OrientationVector);

        while (!orientationRider.AtEnd())
        {
            for (UINT i = 0; i < orientationRider.GetCurrentSpan().Length; i++)
            {
                INT j = i + orientationRider.GetCurrentSpanStart();

                if (Glyphs[j] != 0xffff)
                {
                    pt = WorldOrigins[j];
                    REAL glyphMinX;
                    REAL glyphMaxX;
                    if (orientationRider.GetCurrentElement())
                    {
                        //  Vertical sideways
                        glyphMinX = -(designHmtxAdvances[j] / 2) * designToWorld;
                        glyphMaxX = +(designHmtxAdvances[j] / 2) * designToWorld;
                    }
                    else
                    {
                        //  Vertical upright
                        glyphMinX = -(ascent + descent) / 2;
                        glyphMaxX = +(ascent + descent) / 2;
                    }
                    REAL glyphMinY = 0;
                    REAL glyphMaxY = +designHmtxAdvances[j] * designToWorld;
                    if (Flags & DriverStringOptionsRealizedAdvance)
                    {
                        glyphInverseTransform.Transform(&pt, 1);

                        minX = min(minX, pt.X + glyphMinX);
                        maxX = max(maxX, pt.X + glyphMaxX);
                        minY = min(minY, pt.Y + glyphMinY);
                        maxY = max(maxY, pt.Y + glyphMaxY);
                    }
                    else
                    {
                        RectF bbox;
                        TransformBounds(
                            GlyphTransform,
                            glyphMinX,
                            glyphMinY,
                            glyphMaxX,
                            glyphMaxY,
                            &bbox
                        );
                        bbox.X += pt.X;
                        bbox.Y += pt.Y;
                        minX = min(minX, bbox.X);
                        minY = min(minY, bbox.Y);
                        maxX = max(maxX, bbox.X + bbox.Width);
                        maxY = max(maxY, bbox.Y + bbox.Height);
                    }
                }
            }

            baselineOrigin.X = min(baselineOrigin.X, pt.X);
            baselineOrigin.Y = min(baselineOrigin.Y, minY);

            orientationRider++;     // advance to next item
        }


        if (baseline)
        {
            baseline->X      = baselineOrigin.X;
            baseline->Y      = baselineOrigin.Y;
            baseline->Width  = maxY - minY;
            baseline->Height = 0.0;

            //  The interesting question is where the baseline should be for
            //  vertical as we centered the FE glyphs horizontally. We want to make
            //  sure the underline position (derived by this baseline) dont
            //  fall out of the bounding box and at the same time dont overlap
            //  too much of a FE glyph.
            //
            //  One possible position is to make the baseline so that its underline
            //  left most pixel is exactly at the bounding box edge.

            baseline->X += max(0.0f, minX - baseline->X - Face->GetDesignUnderscorePosition() * designToWorld);
        }
    }

    if (boundingBox)
    {
        boundingBox->X      = minX;
        boundingBox->Y      = minY;
        boundingBox->Width  = maxX - minX;
        boundingBox->Height = maxY - minY;
    }

    return Status;
}

/////   DrawDriverString - Draw codepoints or glyphs for legacy compatability
//
//

GpStatus
GpGraphics::DrawDriverString(
    const UINT16     *text,
    INT               glyphCount,
    const GpFont     *font,
    const GpBrush    *brush,
    const PointF     *positions,
    INT               flags,
    const GpMatrix   *glyphTransform     // optional
)
{
    GpStatus status = CheckTextMode();
    if (status != Ok)
        return status;

    if (font->GetStyle() & (FontStyleUnderline | FontStyleStrikeout))
    {
        //  Underline/strikeout not supported (339798)
        return InvalidParameter;
    }

    DriverStringImager imager(
        text,
        glyphCount,
        font,
        positions,
        flags,
        this,
        glyphTransform
    );

    return imager.Draw(brush);
}


/////   MeasureDriverString - Measure codepoints or glyphs for legacy compatability
//
//  last parameter is used only if the flags have DriverStringOptionsRealizedAdvance or
//  DriverStringOptionsCompensateResolution.
//  and this parameter is added only for optimizing the calculations of the bounding
//  rectangle and getting the glyph origins in same time while recording DrawDriverString
//  in EMF+. otherwise it is defaulted to NULL

GpStatus
GpGraphics::MeasureDriverString(
    const UINT16     *text,
    INT               glyphCount,
    const GpFont     *font,
    const PointF     *positions,
    INT               flags,
    const GpMatrix   *glyphTransform,   // In  - Optional glyph transform
    RectF            *boundingBox       // Out - Overall bounding box of cells
)
{
    CalculateTextRenderingHintInternal();
    DriverStringImager imager(
        text,
        glyphCount,
        font,
        positions,
        flags,
        this,
        glyphTransform
    );

    return imager.Measure(boundingBox);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\fasttext.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   FastTextImager.cpp
*
* Abstract:
*
*   Text measurement and display for the common case
*
*
* Created:
*
*   23 Oct 2000
*
\**************************************************************************/



#include "precomp.hpp"


/////   CountLength
//
//      Determine the length of a string by searching for the zero terminator.


static void CountLength(
    const WCHAR *string,
    INT          *length
)
{
    INT i = 0;
    while (string[i])
    {
        i++;
    }
    *length = i;
}



/////   ScanForGlyph
//
//

static inline INT ScanForGlyph(
    const UINT16  *glyphs,
    INT            glyphCount,
    UINT16         glyph
)
{
    INT i=0;
    while (i < glyphCount && glyphs[i] != glyph)
    {
        i++;
    }
    return i;
}



static INT SumWidths(
    const UINT16 *widths,
    INT           widthCount
)
{
    INT sum = 0;
    INT i   = 0;
    while (i < widthCount)
    {
        sum += widths[i];
        i++;
    }
    return sum;
}



//  Note: Only handle one hotkey which is a common case
//  for menu item. If we found more than one, we'll let
//  fulltext handle it.

GpStatus FastTextImager::RemoveHotkeys()
{
    // Remove hotkey codepoints by moving subsequent glyph indeces back down
    // and decrementing GlyphCount.
    // '&' is the hardcoded hotkey marker.

    INT i = 0;

    // Find the first '&'. Maybe there are none.

    while (    i < Length
           &&  String[i] != '&')
    {
        i++;
    }

    if (i >= Length)
    {
        // No hotkeys to handle.
        return Ok;
    }
    else if (i == Length-1)
    {
        // Last character is hotkey marker. Just ignore it.
        GlyphCount--;
    }
    else
    {
        // Hide the glyph by moving subsequent glyphs back over this one.

        if (String[i+1] != '&')
            HotkeyPosition = i;
        
        INT j=i+1;

        while (j < GlyphCount)
        {
            // Copy marked glyph down one (even if it is another '&').

            Glyphs[i] = Glyphs[j];
            i++;
            j++;

            // Copy subsequent glyphs down until the end, or the next hotkey marker

            while (j < GlyphCount
                   &&  String[j] != '&')
            {
                Glyphs[i] = Glyphs[j];
                i++;
                j++;
            }

            if (j < GlyphCount)
            {
                // We hit another hotkey marker,
                // wont handle it.
                return NotImplemented;
            }
        }

        GlyphCount = i;
    }
    return Ok;
}







/////   FastAdjustGlyphPositionsProportional
//
//      Since this is the fast case, there are many things it is not designed
//      to handle.
//
//      It does handle:
//
//      o  Generate glyph advance width array in device coordinates
//      o  No adjustment of leading or trailing spaces
//      o  Even spacing
//      o  Major adjustment in inter-word space, remaining adjustment
//            in inter-character space
//
//
//      There's 3 types of glyph:
//
//      o  Blanks.  We want all blanks to have the same width, and impose a
//         minimum blank width to ensure words remain distinct.
//
//      o  Last character of a word. We can't adjust the hinted width of the
//         last character of a word because it sets the point at which the
//         subsequent blank (or right margin) begins.
//
//      o  First characters of each word. Adjusting the width of the other
//         changes the inter-glyph spacing. We only do this if we cannot
//         make all our changes in the blank width.


void FastTextImager::FastAdjustGlyphPositionsProportional(
    IN   const INT       *hintedWidth,            // 28.4  device
    OUT  INT             *x,                      // 28.4  device Initial x
    OUT  IntStackBuffer  &dx,                     // 32.0  device Glyph advances
    OUT  const UINT16   **displayGlyphs,          // First displayable glyph
    OUT  INT             *displayGlyphCount,
    OUT  INT             *leadingBlankCount
)
{
    INT desiredOffset     = 0;   // 16.16 offset from left end
    INT wholePixelOffset  = 0;   // 16.16 fractional part zero


    // Identify leading and trailing blanks

    INT leadingBlanks = 0;
    while (leadingBlanks < GlyphCount && Glyphs[leadingBlanks] == BlankGlyph)
    {
        leadingBlanks++;
    }

    INT trailingBlanks = 0;
    while (leadingBlanks + trailingBlanks < GlyphCount &&
        Glyphs[GlyphCount-1-trailingBlanks] == BlankGlyph)
    {
        trailingBlanks++;
    }


    // Measure nominal and hinted widths, and count internal blanks

    INT internalBlanks = 0;
    INT totalNominal   = 0;    // 32.0 design
    INT totalHinted    = 0;    // 28.4 device
    INT blanksHinted   = 0;    // 28.4 device
    INT blanksNominal  = 0;    // 32.0 design

    INT i = leadingBlanks;
    while (i < GlyphCount-trailingBlanks)
    {
        if (Glyphs[i] == BlankGlyph)
        {
            internalBlanks++;
            blanksHinted  += hintedWidth[i];
            blanksNominal += NominalWidths[i];
        }
        else
        {
            totalNominal += NominalWidths[i];

            // Note: totalHinted is 28.4, so the overall device length of the text
            // cannot exceed 2**28 (over 250,000,000). Glyph adjustment code should
            // not be used in such large scale cases - it is intended for smaller
            // font sizes and lower resolutions, rarely exceeding 8 inches at 200
            // dpi (i.e. 16000). The available resolution is therefore larger than
            // the common worst case by a factor of 15,000.

            ASSERT(totalHinted + hintedWidth[i] >= totalHinted);    // Check overflow
            totalHinted  += hintedWidth[i];
        }

        i++;
    }

    totalHinted  += blanksHinted;
    totalNominal += blanksNominal;


    // From here on work with just the displayable gylphs.
    // 'displayGlyphs' is just a pointer to teh first nonblank glyph.

    *leadingBlankCount = leadingBlanks;
    *displayGlyphs     = Glyphs.Get() + leadingBlanks;
    *displayGlyphCount = GlyphCount - leadingBlanks - trailingBlanks;
    *x = (NominalWidths[0] * NominalToBaselineScale * leadingBlanks) / 4096;


    // Determine the damage - how much adjustment is required in 32.0 device units.

    INT adjustment = INT((((INT64(totalNominal) * NominalToBaselineScale)/4096) - totalHinted + 8) / 16);


    // Allow for small differences between hinted and nominal widths
    // without adjusting inter-glyph spacing.

    INT nonJustifiedAdjustment = 0;

    if (adjustment < 0)
    {
        // Allow overflow into margins
        // [e.g. 316851]

        nonJustifiedAdjustment = max(adjustment, -OverflowAvailable);
    }
    else if (adjustment > 0)
    {
        nonJustifiedAdjustment = static_cast<INT>(min(adjustment, (NominalToBaselineScale*(INT64)DesignEmHeight) >> 16));
    }


    if (nonJustifiedAdjustment)
    {
        // Maintain visual alignment

        switch (Alignment)
        {
        case StringAlignmentCenter:
            LeftOffset -= nonJustifiedAdjustment  / (WorldToDeviceX * 32);
            break;

        case StringAlignmentFar:
            LeftOffset -= nonJustifiedAdjustment  / (WorldToDeviceX * 16);
            break;
        }
    }


    // Determine remaining inter-glyph adjustment

    adjustment -= nonJustifiedAdjustment;


    if (    adjustment == 0
        ||  *displayGlyphCount <= 1)
    {
        // WARNING(("No glyph adjustment required"));

        // Can use hinted widths directly

        INT deviceOffset28p4 = 0;
        INT deviceOffset32p0 = 0;

        for (INT i=0; i<*displayGlyphCount; i++)
        {
            deviceOffset28p4  += hintedWidth[i+leadingBlanks];
            INT nextOffset32p0 = (deviceOffset28p4 + 8) >> 4;
            dx[i]              = nextOffset32p0 - deviceOffset32p0;
            deviceOffset32p0   = nextOffset32p0;
        }
    }
    else
    {
        // Determine how much whitespace is required according to design metrics

        INT deviceWhitespace = INT((blanksNominal * INT64(NominalToBaselineScale) + 32768) / 65536);

        // Guarantee not to reduce whitespace to less than 1/6 em (rounded up to whole pixels)
        INT minimumBlankPixels = (NominalToBaselineScale*DesignEmHeight + 5*65536) / (6*65536);
        INT minimumDeviceWhitespace = MAX(internalBlanks*minimumBlankPixels,
                                          deviceWhitespace/2);

        // We would rather not change inter-character spacing.
        // Adjust only blank widths if blanks would not be reduced below
        // minimumBlankPixels or increased above twice their nominal width.


        if (    adjustment     <=  deviceWhitespace
            &&  adjustment     >=  -(deviceWhitespace-minimumDeviceWhitespace)
            &&  internalBlanks > 0)
        {
            // WARNING(("Glyph adjustment in spaces only"));

            // Adjustment expands spaces to no more than twice their nominal
            // size and no less than half their nominal size.

            // Apply all adjustment to spaces. Determine ajusted 24.8 blank
            // width.

            INT deviceOffset24p8 = 0;
            INT deviceOffset32p0 = 0;

            const UINT16 *glyphs     = *displayGlyphs;
            INT           glyphCount = *displayGlyphCount;
            INT           blankWidth = (blanksHinted*16 + adjustment*256) / internalBlanks;
            const INT    *hinted     = hintedWidth+leadingBlanks;

            for (INT i=0; i<glyphCount; i++)
            {
                if (glyphs[i] == BlankGlyph)
                {
                    deviceOffset24p8 += blankWidth;
                }
                else
                {
                    deviceOffset24p8 += hinted[i] * 16;
                }
                INT nextOffset32p0 = (deviceOffset24p8 + 128) >> 8;
                dx[i]              = nextOffset32p0 - deviceOffset32p0;
                deviceOffset32p0   = nextOffset32p0;
            }
        }
        else
        {
            // WARNING(("Glyph adjustment in spaces and between Glyphs"));

            // Adjustment requires changes to the width of all but the last
            // glyph of each word.

            INT interCharacterAdjustment = adjustment; // 32.0

            INT blankWidth; // 32.0
            if (internalBlanks)
            {
                if (adjustment < 0)
                {
                    blankWidth = minimumBlankPixels;
                }
                else
                {
                    blankWidth = deviceWhitespace * 2 / internalBlanks;
                }
                interCharacterAdjustment -= blankWidth * internalBlanks - blanksHinted/16;
            }
            else
            {
                blankWidth = 0;
            }

            // blankWidth - Required width for each blank
            // interCharacterAdjustment - adjustment to share between all

            // Count number of blank runs (not the same as number of blank glyphs)

            INT i=0;
            INT blankRuns = 0;

            while (i < *displayGlyphCount)
            {
                if ((*displayGlyphs)[i] == BlankGlyph)
                {
                    i++;
                    while (    i < *displayGlyphCount
                           &&  (*displayGlyphs)[i] == BlankGlyph)
                    {
                        i++;
                    }
                    blankRuns++;
                }
                else
                {
                    while (    i < *displayGlyphCount
                           &&  (*displayGlyphs)[i] != BlankGlyph)
                    {
                        i++;
                    }
                }
            }

            // Establish number of adjustment points between non-blanks.
            //
            // Adjustment can happen only between non-blanks, i.e. not in blank
            // runs, nor in the character immediateley before a blank run or
            // the last character in the line.

            INT interCharacterJunctions =    *displayGlyphCount
                                          -  internalBlanks
                                          -  blankRuns
                                          -  1;


            // Prepare adjustment control variables

            #ifdef evenDistribution
                // Even distribution makes wordslook uneven
                INT OnePixelChangeEvery; // 16.16
                INT delta; // -1 or +1

                if (interCharacterAdjustment == 0)
                {
                    OnePixelChangeEvery = (interCharacterJunctions+1) * 65536; // 16.16
                    delta=0;
                }
                else
                {
                    OnePixelChangeEvery =    interCharacterJunctions * 65536
                                          /  interCharacterAdjustment; // 16.16
                    if (OnePixelChangeEvery < 0)
                    {
                        OnePixelChangeEvery = - OnePixelChangeEvery;
                        delta = -1;
                    }
                    else
                    {
                        delta = 1;
                    }
                }
                INT gapOffset = OnePixelChangeEvery / 2; // 16.16
            #else
                // When there's a remainder, apply it all at the end of the line
                // Advantage - all words are even. Disadvantage - end of line looks heavy.

                INT extraPixelsAfter;  // Position after which to start applying extraDelta
                INT extraDelta;
                INT perJunctionDelta;

                if (interCharacterJunctions <= 0)
                {
                    // There are no words of more than one character

                    // We have no chice except to make all adjustment happen in the blanks

                    if (internalBlanks <= 0)
                    {
                        // No blanks, no inter-character junctions
                        // This must be a single glyph
                        // So we're stuck. It will have to be too wide.
                    }
                    else
                    {
                        // Distribute remaining adjustment between blanks

                        blankWidth += interCharacterAdjustment / internalBlanks;
                    }

                    extraPixelsAfter = 0;
                    extraDelta = 0;
                    perJunctionDelta = 0;
                }
                else
                {
                    perJunctionDelta = interCharacterAdjustment / interCharacterJunctions;
                    if (interCharacterAdjustment < 0)
                    {
                        extraPixelsAfter =    interCharacterJunctions
                                           +  interCharacterAdjustment % interCharacterJunctions;
                        extraDelta  = -1;
                    }
                    else if (interCharacterAdjustment > 0)
                    {
                        extraPixelsAfter =    interCharacterJunctions
                                           -  interCharacterAdjustment % interCharacterJunctions;
                        extraDelta = 1;
                    }
                    else
                    {
                        extraPixelsAfter = interCharacterJunctions;
                        extraDelta = 0;
                    }
                }

                INT junctionCount = 0;
            #endif


            // Adjustment FSM

            BOOL prevCharacterBlank = (*displayGlyphs)[0] == BlankGlyph ? TRUE : FALSE;
            for (INT i=1; i<= *displayGlyphCount; i++)
            {
                if (prevCharacterBlank)
                {
                    // Previous character was blank - easy!

                    dx[i-1] = blankWidth;
                }
                else
                {
                    // Previous character nonblank

                    if (    i >= *displayGlyphCount
                        ||  (*displayGlyphs)[i] == BlankGlyph)
                    {
                        // the previous nonblank preceeded a blank or margin
                        dx[i-1] = hintedWidth[i-1+leadingBlanks] / 16;
                    }
                    else
                    {
                        // the previous nonblank is adjustable
                        // How many extra pixels to add at this gap?

                        #ifdef evenDistribution
                            // Even distribution makes words look uneven
                            INT extra = gapOffset / OnePixelChangeEvery;

                            dx[i-1] = hintedWidth[i-1+leadingBlanks] / 16 + extra * delta;
                            gapOffset += 65536 - extra * OnePixelChangeEvery;
                        #else
                            // When there's a remainder, apply it all at the end of the line
                            // Advantage - all words are even. Disadvantage - end of line looks heavy.
                            dx[i-1] =    hintedWidth[i-1+leadingBlanks] / 16
                                      +  perJunctionDelta
                                      +  (junctionCount >= extraPixelsAfter ? extraDelta : 0);
                            junctionCount++;

                        #endif
                    }
                }

                if (i < *displayGlyphCount)
                {
                    prevCharacterBlank = (*displayGlyphs)[i] == BlankGlyph ? TRUE : FALSE;
                }
            }
        }
    }
}





void
FastTextImager::GetWorldTextRectangleOrigin(
    PointF &origin
)
{
    origin.X = LayoutRectangle.X;
    origin.Y = LayoutRectangle.Y;

    REAL textWidth = TotalWorldAdvance + LeftMargin + RightMargin;

    switch(Alignment)
    {
    case StringAlignmentCenter:
        origin.X += (LayoutRectangle.Width - textWidth) / 2;
        break;

    case StringAlignmentFar:
        origin.X += LayoutRectangle.Width - textWidth;
        break;
    }

    if (Format)
    {
        StringAlignment lineAlignment = Format->GetLineAlign();

        switch(lineAlignment)
        {
        case StringAlignmentCenter:
            origin.Y += (LayoutRectangle.Height - CellHeight) / 2;
            break;
        case StringAlignmentFar:
            origin.Y += LayoutRectangle.Height - CellHeight;
            break;
        }
    }
}






void
FastTextImager::GetDeviceBaselineOrigin(
    IN   GpFaceRealization  &faceRealization,
    OUT  PointF             &origin
)
{
    GetWorldTextRectangleOrigin(origin);

    origin.X += LeftMargin + LeftOffset;

    ASSERT(!faceRealization.IsPathFont());

    if (WorldToDeviceY > 0.0f)
    {
        origin.Y -= faceRealization.GetYMin() / WorldToDeviceY;
    }
    else
    {
        origin.Y -= faceRealization.GetYMax() / WorldToDeviceY;
    }
    WorldToDevice.Transform(&origin, 1);
}






GpStatus
FastTextImager::FastDrawGlyphsNominal(
    GpFaceRealization  &faceRealization
)
{
    AutoBuffer<PointF, FAST_TEXT_PREALLOCATED_CHARACTERS> origins(GlyphCount);

    GetDeviceBaselineOrigin(faceRealization, origins[0]);

    for (INT i=1; i<GlyphCount; i++)
    {
        origins[i].X = origins[i-1].X + TOREAL(NominalWidths[i-1] * NominalToBaselineScale) / 65536;
        origins[i].Y = origins[0].Y;
    }

    GpStatus status = Graphics->DrawPlacedGlyphs(
        &faceRealization,
        Brush,
        FormatFlags &  StringFormatFlagsPrivateNoGDI ? DG_NOGDI : 0,
        String,
        Length,
        FALSE,
        Glyphs.Get(),
        NULL,
        origins.Get(),
        GlyphCount,
        ScriptLatin,
        FALSE   // sideways
    );

    if (status != Ok)
    {
        return status;
    }


    if (Style & (FontStyleUnderline | FontStyleStrikeout))
    {
        REAL lineLength = 0.0;

        for (INT i = 0; i < GlyphCount; i++)
        {
            lineLength += TOREAL(NominalWidths[i] * NominalToBaselineScale) / 65536;
        }

        status = DrawFontStyleLine(
            &origins[0],
            lineLength,
            Style
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    if (   !(Style & FontStyleUnderline)
        && HotkeyPosition >= 0  && Format && Format->GetHotkeyPrefix() == HotkeyPrefixShow)
    {
        // Draw the underline under the marked key

        status = DrawFontStyleLine(
            &origins[HotkeyPosition],
            TOREAL(NominalWidths[HotkeyPosition] * NominalToBaselineScale) / 65536,
            FontStyleUnderline
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    return Ok;
}



GpStatus
FastTextImager::DrawFontStyleLine(
    const PointF    *baselineOrigin,    // base line origin in device unit
    REAL            baselineLength,     // base line length in device unit
    INT             style               // font styles
)
{
    //  Invert transform to world unit

    PointF  starting(*baselineOrigin);
    PointF  ending(baselineOrigin->X + baselineLength, baselineOrigin->Y);

    GpMatrix deviceToWorld;
    Graphics->GetDeviceToWorldTransform(&deviceToWorld);
    deviceToWorld.Transform(&starting);
    deviceToWorld.Transform(&ending);

    // fasttext wont process vertical or text w/ any transform except scaling
    ASSERT(starting.Y == ending.Y);

    return Graphics->DrawFontStyleLine(
        &starting,
        ending.X - starting.X,
        Face,
        Brush,
        FALSE,  // no vertical
        EmSize,
        style
    );
}




GpStatus
FastTextImager::FastDrawGlyphsGridFit(
    GpFaceRealization  &faceRealization
)
{
    // Get hinted advance widths for the glyph string

    IntStackBuffer hintedWidths(GlyphCount);

    GpStatus status = faceRealization.GetGlyphStringDeviceAdvanceVector(
        Glyphs.Get(),
        GlyphCount,
        FALSE,
        hintedWidths.Get()
    );

    if (status != Ok)
    {
        return status;
    }


    INT              x;                    // 28.4 offset for first display glyph
    const UINT16    *displayGlyphs;        // First glyph to display
    INT              displayGlyphCount;    // Number of Glyphs to display
    INT              leadingBlankCount;    // Number of leading blank glyphs
    IntStackBuffer   dx(GlyphCount);       // 32.0

    if (!dx)
    {
        return OutOfMemory;
    }

    FastAdjustGlyphPositionsProportional(
        hintedWidths.Get(),     // 28.4  device
       &x,                      // 28.4  device Initial x
        dx,                     // 32.0  device Glyph advances
       &displayGlyphs,          // First displayable glyph
       &displayGlyphCount,
       &leadingBlankCount
    );

    AutoBuffer<PointF, FAST_TEXT_PREALLOCATED_CHARACTERS> origins(GlyphCount);

    GetDeviceBaselineOrigin(faceRealization, origins[0]);

    //  Round glyph origin to full pixel
    origins[0].X = TOREAL(GpRound(origins[0].X));
    origins[0].X += TOREAL(x) / 16;
    
    for (INT i=1; i<displayGlyphCount; i++)
    {
        origins[i].X = origins[i-1].X + TOREAL(dx[i-1]);
        origins[i].Y = origins[0].Y;
    }

    status = Graphics->DrawPlacedGlyphs(
        &faceRealization,
        Brush,
        FormatFlags &  StringFormatFlagsPrivateNoGDI ? DG_NOGDI : 0,
        String,
        Length,
        FALSE,
        displayGlyphs,
        NULL,
        origins.Get(),
        displayGlyphCount,
        ScriptLatin,
        FALSE  // sideways
    );
    IF_NOT_OK_WARN_AND_RETURN(status);

    if (Style & (FontStyleUnderline | FontStyleStrikeout))
    {
        REAL lineLength = 0.0;

        for (INT i = 0; i < displayGlyphCount; i++)
        {
            lineLength += TOREAL(dx[i]);
        }

        status = DrawFontStyleLine(
            &origins[0],
            lineLength,
            Style
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    if (   !(Style & FontStyleUnderline)
        && HotkeyPosition - leadingBlankCount >= 0  
        && HotkeyPosition - leadingBlankCount < displayGlyphCount
        && Format && Format->GetHotkeyPrefix() == HotkeyPrefixShow)
    {
        // Draw the underline under the marked key

        status = DrawFontStyleLine(
            &origins[HotkeyPosition - leadingBlankCount],
            TOREAL(dx[HotkeyPosition - leadingBlankCount]),
            FontStyleUnderline
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    return Ok;
}





/////   Initialize
//
//      Prepares everything common to DrawString and MeasureString.
//
//      Returns NotImplemented if this string cannot be handled by the fast imager.


GpStatus FastTextImager::Initialize(
    GpGraphics            *graphics,
    const WCHAR           *string,
    INT                    length,
    const RectF           &layoutRectangle,
    const GpFontFamily    *family,
    INT                    style,
    REAL                   emSize,  // In world units
    const GpStringFormat  *format,
    const GpBrush         *brush
)
{
    // Initialise parameter variables

    Graphics        = graphics;
    String          = string;
    Length          = length;
    LayoutRectangle = layoutRectangle;
    Family          = family;
    Style           = style;
    EmSize          = emSize;
    Format          = format;
    Brush           = brush;


    // Simple parameter validation

    // Extract world to device metrics coefficients.

    Graphics->GetWorldToDeviceTransform(&WorldToDevice);
    REAL m11 = WorldToDevice.GetM11();
    REAL m12 = WorldToDevice.GetM12();
    REAL m21 = WorldToDevice.GetM21();
    REAL m22 = WorldToDevice.GetM22();

    if (    m11 <= 0
        ||  m12 != 0
        ||  m21 != 0
        ||  m22 == 0)
    {
        // Must be no rotation, no shearing, and neither axis may
        // scale to zero. X axis scale must be positive, but
        // we do support differing x and y scale.
        return NotImplemented;
    }

    if (EmSize <= 0.0)
    {
        return InvalidParameter;
    }

    if (Graphics->Driver == Globals::MetaDriver)
        return NotImplemented;

    // Measure string if requested

    if (Length == -1)
    {
        CountLength(String, &Length);
    }


    if (Length == 0)
    {
        return Ok;  // Nothing to do.
    }


    // Generate derived variables

    // Establish left and right margins in world units, alignment and flags

    REAL tracking;  // Used only during initialisation

    StringTrimming trimming = DefaultTrimming;

    if (Format)
    {
        LeftMargin  = Format->GetLeadingMargin()  * EmSize;
        RightMargin = Format->GetTrailingMargin() * EmSize;
        Alignment   = Format->GetAlign();
        FormatFlags = Format->GetFormatFlags();
        tracking    = Format->GetTracking();

        // Certain flags are simply not supported by the fast text imager
        if ((FormatFlags & ( StringFormatFlagsDirectionRightToLeft
                          | StringFormatFlagsDirectionVertical
                          | StringFormatFlagsPrivateAlwaysUseFullImager))
            || Format->GetMeasurableCharacterRanges() > 0)
        {
            return NotImplemented;
        }

        Format->GetTrimming(&trimming);
    }
    else
    {
        LeftMargin  = DefaultMargin * EmSize;
        RightMargin = DefaultMargin * EmSize;
        Alignment   = StringAlignmentNear;
        FormatFlags = 0;
        tracking    = DefaultTracking;
    }


    // Determine line length limit. Note lineLengthLimit <= 0 implies
    // unlimited.

    LineLengthLimit = 0;   // Unlimited

    if (   !(FormatFlags & StringFormatFlagsNoWrap)
        || trimming != StringTrimmingNone)
    {
        if (FormatFlags & StringFormatFlagsDirectionVertical)
        {
            LineLengthLimit = LayoutRectangle.Height;
        }
        else
        {
            LineLengthLimit = LayoutRectangle.Width;
        }
    }


    // Establish font face that will be used (assuming no font fallback)

    Face = Family->GetFace(Style);

    if (!Face)
    {
        return InvalidParameter;
    }

    // Fonts with kerning, ligatures or opentype tables for simple horizontal
    // characters are not supported by the fast text imager

    if (Face->RequiresFullTextImager())
    {
        return NotImplemented;
    }



    // At this point we know that the font doesn't require us to distinguish
    // simple left to right scripts like Latin, greek or Ideographic.

    // Attempt to classify the string as a single simple item

    BOOL  digitSeen = FALSE;
    BOOL  complex   = FALSE;

    DetermineStringComplexity(String, Length, &complex, &digitSeen);


    if (    complex
        ||  (digitSeen && Format && Format->GetDigitScript()))
    {
        // Cannot handle this string as a single simple shaping engine run
        return NotImplemented;
    }

    BlankGlyph = Face->GetBlankGlyph();

    // Establish world to device and font to device scale factors along X axis

    DesignEmHeight           = Face->GetDesignEmHeight();
    WorldToDeviceX           = m11;  // We know m12 == 0 above.
    WorldToDeviceY           = m22;  // We know m12 == 0 above.
    REAL fontNominalToWorld  = TOREAL(EmSize) / TOREAL(DesignEmHeight);
    REAL fontScale           = fontNominalToWorld * WorldToDeviceX;

    FontTransform.SetMatrix(
        m11*fontNominalToWorld,  0,
        0,                       m22*fontNominalToWorld,
        0,                       0
    );

    CellHeight =    EmSize
                 *  (   Face->GetDesignCellAscent()
                     +  Face->GetDesignCellDescent())
                 /  DesignEmHeight;
    

    // Adjust the bottom margin slightly to make room for hinting
    // as long as we have the left/right margins enabled - Version 2
    // should expose this as an independent value!
    if (LeftMargin != 0.0f)
    {
        CellHeight += (EmSize * DefaultBottomMargin);
    }

    NominalToBaselineScale = GpRound(fontScale * 65536);

    if (NominalToBaselineScale > 65536)
    {
        // Our integer arithmetic might overflow. This limits our support
        // to font sizes less than the design em size. For Truetype this
        // is usually 2048 pixels, for example 186 pt Tahoma at 96dpi.

        return NotImplemented;
    }



    // Set space available for hinted width to expand into

    switch (Alignment)
    {
    case StringAlignmentNear:   OverflowAvailable = GpFloor(RightMargin * WorldToDeviceX);  break;
    case StringAlignmentCenter: OverflowAvailable = GpFloor(2 * min(LeftMargin, RightMargin) * WorldToDeviceX);  break;
    case StringAlignmentFar:    OverflowAvailable = GpFloor(LeftMargin * WorldToDeviceX);  break;
    }

    LeftOffset = 0.0f;


    TextRendering = Graphics->GetTextRenderingHintInternal();

    // At this point we know that the string can be displayed by a single
    // shaping engine without ligaturisation, kerning or complex script
    // shaping.

    // It may still turn out to have missing glyphs, or be too large
    // to fit on one line.

    HotkeyPosition = -1;

    //  Prepare the glyph and nominal width buffers, return NotImplemented if the
    //  string is not displayable with teh fat text imager.

    ASSERT(Length > 0);     // Client handles 0 length strings
    ASSERT(Face);

    // Preset output variables for empty string

    GlyphCount = 0;


    // Generate glyphs and check for font fallback requirement

    Glyphs.SetSize(Length);
    if (!Glyphs)
    {
        return OutOfMemory;
    }

    Face->GetCmap().LookupUnicode(
        String,
        Length,
        Glyphs.Get(),
        (UINT*)&GlyphCount,
        FALSE
    );

    ASSERT(GlyphCount == Length);  // No surrogates, chars to Glyphs are 1:1.



    /// Hotkey handling
    //
    //  Before looking for missing Glyphs, check for the presence of hotkeys
    //  in the source string and replace the corresponding Glyphs with FFFF.

    if (Format && Format->GetHotkeyPrefix())
    {
        if (RemoveHotkeys() != Ok)
        {
            return NotImplemented;
        }
    }

    if (GlyphCount <= 0)
    {
        return Ok;  // Hotkey handling left nothing to display
    }


    // Check there are no missing Glyphs

    if (    !(FormatFlags & StringFormatFlagsNoFontFallback)
        &&  !Face->IsSymbol())   // We don't fallback on the symbol fonts.
    {
        INT i = ScanForGlyph(Glyphs.Get(), GlyphCount, Face->GetMissingGlyph());

        if (i < GlyphCount)
        {
            // There is a missing glyph
            return NotImplemented;
        }
    }


    // We now have all the Glyphs needed to display the string
    // Obtain character advance widths in font nominal units

    NominalWidths.SetSize(GlyphCount);
    if (!NominalWidths)
    {
        return OutOfMemory;
    }


    // Establish nominal glyph advance widths

    Face->GetGlyphDesignAdvances(
        Glyphs.Get(),
        GlyphCount,
        Style,
        FALSE,  // not vertical
        tracking,
        NominalWidths.Get()
    );


    // Determine string length in world units

    INT totalAdvance = SumWidths(NominalWidths.Get(), GlyphCount);

    TotalWorldAdvance = (totalAdvance * EmSize) / DesignEmHeight;


    if (    LineLengthLimit > 0.0
        &&  TotalWorldAdvance + LeftMargin + RightMargin > LineLengthLimit)
    {
        // This output will need line breaking
        return NotImplemented;
    }


    //  Delete trailing spaces as required.
    //  (We do this here rather than earlier to make sure we don't bypass the
    //  full imager for special cases, and to alow the client to hotkey mark
    //  a trailing space.)

    if (!(FormatFlags & StringFormatFlagsMeasureTrailingSpaces))
    {
        while (GlyphCount > 0 && Glyphs[GlyphCount - 1] == BlankGlyph)
        {
            TotalWorldAdvance -=    NominalWidths[--GlyphCount] * EmSize
                                 /  DesignEmHeight;
        }
    }

    // We now have Glyphs and advance widths, and we know the text is all on
    // one line.

    return Ok;
}






GpStatus FastTextImager::DrawString()
{
    if (GlyphCount <= 0)
    {
        return Ok;  // No display required
    }


    // When rendering grid fitted glyphs, we need to adjust positions as
    // best we can to match nominal widths.


    // Establish face realization to obtain hinted glyph metrics

    GpFaceRealization faceRealization(
        Face,
        Style,
        &FontTransform,
        SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
        TextRendering,
        FALSE,  // Try for bits
        FALSE,   // Not specifically cleartype compatible widths
        FALSE  // not sideways
    );

    GpStatus status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);

    if (faceRealization.IsPathFont())
    {
        // we need to fall back to FullTextImager
        return NotImplemented;
    }

    //  FitBlackBox
    //
    //  We need to know whether any part of the glyph black boxes overhang the
    //  layout rectangle. Here we assume that characters are clipped to their
    //  cell height, and we check teh sidebearings.
    //
    //  With better access to the cache, this code could check the real glyph
    //  black boxes.


    if (!(FormatFlags & StringFormatFlagsNoFitBlackBox))
    {
        // Check for overhanging glyphs

        INT leadingSidebearing28p4;
        INT trailingSidebearing28p4;

        status = faceRealization.GetGlyphStringSidebearings(
            Glyphs.Get(),
            GlyphCount,
            FALSE,
            FALSE,
            &leadingSidebearing28p4,
            &trailingSidebearing28p4
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        if (    -leadingSidebearing28p4  > LeftMargin  * WorldToDeviceX * 16
            ||  -trailingSidebearing28p4 > RightMargin * WorldToDeviceX * 16)
        {
            return NotImplemented;
        }


        // Adjust margins by sidebearings to allow black pixels to reach up to
        // but not beyond clients formatting rectangle.


        switch (Alignment)
        {
        case StringAlignmentNear:
            OverflowAvailable = GpFloor(RightMargin * WorldToDeviceX) + (trailingSidebearing28p4 >> 4);
            break;

        case StringAlignmentCenter:
            OverflowAvailable = 2 * min(
                GpFloor(LeftMargin  * WorldToDeviceX) + (leadingSidebearing28p4 >> 4),
                GpFloor(RightMargin * WorldToDeviceX) + (trailingSidebearing28p4 >> 4)
            );
            break;

        case StringAlignmentFar:
            OverflowAvailable = GpFloor(LeftMargin * WorldToDeviceX) + (leadingSidebearing28p4 >> 4);
            break;
        }
    }



    //  Clipping:
    //
    //  We need to clip as requested by the client.
    //
    //  If the clients layout rectangle is tall enough for our cell height
    //  we need not clip vertically.
    //
    //  If we're fitting black box and we found an overhang, then we already
    //  fell back to the full imager, so we don't need to clip horizintally here
    //  unless the client set noFitBlackBox.
    //
    //  n - NoFitBlackBox active
    //  w - Nonzero layout rectangle width
    //  h - Nonzero layout rectangle height less than font cell height
    //
    //  n   w   h   CLipping required
    //  --- --- --- ------
    //  0   0   0   None
    //  0   0   1   Clip height
    //  0   1   0   none (width already limited by FitBlackBox)
    //  0   1   1   Clip height (width already limited by FitBlackBox)
    //  1   0   0   none
    //  1   0   1   Clip height
    //  1   1   0   Clip width
    //  1   1   1   Clip width and height




    GpRegion *previousClip  = NULL;
    BOOL      clipped       = FALSE;

    if (    !(FormatFlags & StringFormatFlagsNoClip)
        &&  (    LayoutRectangle.Width > 0
             ||  LayoutRectangle.Height > 0))
    {
        // Determine clipping rectangle, if any.

        PointF textOrigin;
        GetWorldTextRectangleOrigin(textOrigin);

        RectF clipRectangle(LayoutRectangle);

        if (clipRectangle.Width <= 0)
        {
            // Guarantee no horizontal clipping regardless of alignment
            clipRectangle.X     = textOrigin.X;
            clipRectangle.Width = TotalWorldAdvance + LeftMargin + RightMargin;
        }

        if (clipRectangle.Height <= 0)
        {
            // Guarantee no vertical clipping regardless of alignment
            clipRectangle.Y      = textOrigin.Y;
            clipRectangle.Height = CellHeight;
        }


        if (    FormatFlags & StringFormatFlagsNoFitBlackBox
            ||  clipRectangle.X > textOrigin.X
            ||  clipRectangle.GetRight() < textOrigin.X + TotalWorldAdvance + LeftMargin + RightMargin
            ||  clipRectangle.Y > textOrigin.Y
            ||  clipRectangle.GetBottom() < textOrigin.Y + CellHeight)
        {
            //  Preserve existing clipping and combine it with the new one if any

            if (!Graphics->IsClipEmpty())
            {
                previousClip = Graphics->GetClip();
            }

            Graphics->SetClip(clipRectangle, CombineModeIntersect);

            clipped = TRUE;

            // WARNING(("Clipping"));
        }
    }

    SetTextLinesAntialiasMode linesMode(Graphics, &faceRealization);
    if ((IsGridFittedTextRealizationMethod(TextRendering)) && !faceRealization.IsFixedPitch())
    {
        status = FastDrawGlyphsGridFit(faceRealization);
    }
    else
    {
        status = FastDrawGlyphsNominal(faceRealization);
    }


    if (clipped)
    {
        //  Restore clipping state if any
        if (previousClip)
        {
            Graphics->SetClip(previousClip, CombineModeReplace);
            delete previousClip;
        }
        else
        {
            Graphics->ResetClip();
        }
    }

    return status;
}






GpStatus FastTextImager::MeasureString(
    RectF *boundingBox,
    INT   *codepointsFitted,
    INT   *linesFilled
)
{
    ASSERT(GlyphCount >= 0);

    // Regardless of the displayed length, if we're using the fast imager, then
    // we fitted all the characters. (Length > GlyphCount when there are trailing spaces)

    if (codepointsFitted)
    {
        *codepointsFitted = Length;
    }

    if (linesFilled)
    {
        *linesFilled = 1;
    }


    // Return bounding box for (possibly empty) line

    PointF textOrigin;
    GetWorldTextRectangleOrigin(textOrigin);

    *boundingBox = RectF(textOrigin.X, textOrigin.Y, 0, 0);
    boundingBox->Width  = TotalWorldAdvance + LeftMargin + RightMargin;
    boundingBox->Height = CellHeight;

    if (!(FormatFlags & StringFormatFlagsNoClip))
    {
        if (   LayoutRectangle.Height > 0
            && boundingBox->Height > LayoutRectangle.Height)
        {
            boundingBox->Height = LayoutRectangle.Height;
        }

        if (   LayoutRectangle.Width > 0
            && boundingBox->Width > LayoutRectangle.Width)
        {
            boundingBox->X = LayoutRectangle.X;
            boundingBox->Width = LayoutRectangle.Width;
        }
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\glyphplacement.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   glyphPlacement.cpp
*
* Abstract:
*
*   Implements glyph measurement and justification for graphicsText
*
* Created:
*
*   17th April 2000 dbrown
*
\**************************************************************************/


#include "precomp.hpp"


/////   Coordinate systems
//
//      The following coordinate systems are used:
//
//      World coordinates (REAL) - the coordinate system used by client
//      applications and passed to most Graphics APIs (for example
//      DrawLine). Text is always purely vertical or purely horizontal in
//      world coordinates. Fonts constructed with emSize specified in
//      alternate units are first converted to world units by calling
//      GetScaleForAlternatePageUnit.
//
//      Device coordinates (REAL) - Coordinates used on the device surface.
//      World coordinates are transformed to device coordinates using the
//      Graphics.Context.WorldToDevice.Transform function. REAL device
//      coordinates may have non-integral values when addressing sub-pixels.
//
//      Font nominal coordinates (INT) - (aka deign units) coordinates used to
//      define a scalable font independant of scaled size.
//      GpFontFace.GetDesignEmHeight is the emSize of a font in nominal units.
//      Nominal coordinates are always a pure scale factor of world units with
//      no shear. For horizontal text there there is no rotation between
//      nominal and world coordinates. For vertical text, most non Far East
//      script characters are rotated by 90 degrees.
//
//      Ideal coordinates (INT) - world coordinates mapped to integers by
//      a pure scale factor for use in Line Services, OpenType services and
//      Uniscribe shaping engine interfaces. The scale factor is usually
//      2048 divided by the emSize of the default font in a text imager.


/////   Transforms
//
//      WorldToDevice - stored in a Graphics. May include scaling,
//      shearing and/or translation.
//
//      WorldToIdeal - stored in a text imager while the imager is attached
//      to a Graphics. A pure scale factor, usually 2048 divided by the emSize
//      of the imager default font.
//
//      FontTransform - stored in a FaceRealization. Maps font nominal units
//      to device coordinates, May include scaling, shearing and rotation, but
//      not translation.


/////   Common buffer parameters
//
//      glyphAdvance - per-glyph advance widths stored in ideal units measured
//      along the text baseline.
//
//      glyphOffset - combining character offsets stored in ideal units
//      measured along and perpendicular to the baseline. The glyphOffset
//      buffer is required by Line Services, OpenType services and the
//      complex script shaping engines, but may somethimes be bypassed for
//      simple scripts.
//
//      glyphOrigins - per glyph device coordinates of the glyph origin (the
//      initial point on the baseline of the glyhps advance vector).
//      Represented as PointF. Non integer values represent sub pixel
//      positions.


/////   Glyph positioning functions
//
//
//      DrawPlacedGlyphs - Builds glyphPos array and passes it to the device driver.
//          ALL text device output output eventually comes through here.
//
//      GetDeviceGlyphOriginsNominal
//          Used when there's no hinting to be accounted for.
//          Places glyph on device using nominal metrics passed in glyphAdvances
//          and glyphOffsets.
//
//      GetDeviceGlyphOriginsAdjusted
//          Used to adjust for the difference between nominal and hinted metrics
//          Generates glyph origins in device units, and adjusts the width of spaces
//          to achieve the totalRequiredIdealAdvance parameter.
//          !!! Need to add support for kashida and inter-glyph justification.
//
//      GetRealizedGlyphPlacement
//          Used to obtain hinted advance metrics along the baseline.
//          !!! Needs to be updated to call complex script shaping engines.
//
//      GetFontTransformForAlternateResolution
//          Used during XMF playback.
//          Generates a font transform to match a font that was recorded at
//          a different resolution.
//
//      MeasureGlyphsAtAlternateResolution
//          Used during XMF playback.
//          Measures glyphs passed to DrawDriverString as if they were to be rendered
//          at the original XMF recording resolution.






/////   GlyphPlacementToGlyphOrigins
//
//      Convert glyph placement in ideal units to glyph origins in device
//      units.
//
//      Note: Bidi shaping engines produces glyph positioning info
//      in the way that it'll be drawn visually. The penpoint of the
//      mark is relative to the glyph on its left, not the glyph of
//      its base consonant.

GpStatus GlyphImager::GlyphPlacementToGlyphOrigins(
    const PointF   *origin,         // In  - cell origin in world units
    GpGraphics     *graphics,
    PointF         *glyphOrigins    // Out - device units
)
{
    ASSERT(Glyphs  &&  GlyphCount);

    const INT   *glyphAdvances;
    const Point *glyphOffsets;


    if (Adjusted)
    {
        glyphAdvances = AdjustedAdvances.Get();
        glyphOffsets  = AdjustedOffsets.Get();
    }
    else
    {
        glyphAdvances = NominalAdvances;
        glyphOffsets  = NominalOffsets;
    }


    // Implement advance vector

    REAL x = origin->X;
    REAL y = origin->Y;


    if (TextItem->Flags & ItemVertical)
    {
        if (TextItem->Level & 1)
        {
            // Vertical, characters progress bottom to top
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X = x;
                glyphOrigins[i].Y = y;
                y -= TOREAL(glyphAdvances[i] / WorldToIdeal);
            }
        }
        else
        {
            // Vertical, characters progress top to bottom
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X = x;
                glyphOrigins[i].Y = y;
                y += TOREAL(glyphAdvances[i] / WorldToIdeal);
            }
        }
    }
    else if (TextItem->Level & 1)
    {
        for (INT i = 0; i < GlyphCount; i++)
        {
            glyphOrigins[i].X = x;
            glyphOrigins[i].Y = y;
            x -= TOREAL(glyphAdvances[i] / WorldToIdeal);
        }
    }
    else
    {
        for (INT i = 0; i < GlyphCount; i++)
        {
            glyphOrigins[i].X = x;
            glyphOrigins[i].Y = y;
            x += TOREAL(glyphAdvances[i] / WorldToIdeal);
        }
    }


    // Handle RTL glyphs
    //
    // In RTL rendering, the origin calculated so far is the right edge of the
    // baseline - we need to subtract the hinted glyph width so that we pass the
    // renderer the left end.

    GpStatus status = Ok;

    if (   (TextItem->Level & 1)
        && !(TextItem->Flags & ItemMirror))
    {
        // Compensate glyph origin for glyph lying on it's side or rendered RTL

        AutoBuffer<INT,32> idealAdvances(GlyphCount);
        if (!idealAdvances)
        {
            return OutOfMemory;
        }

        status = FaceRealization->GetGlyphStringIdealAdvanceVector(
            Glyphs,
            GlyphCount,
            DeviceToIdealBaseline,
            FALSE,
            idealAdvances.Get()
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        // Adjust origins from right end to left end of hinted baseline
        // (Marks are already calculated to the left end)

        const SCRIPT_VISATTR *properties = (const SCRIPT_VISATTR*) GlyphProperties;

        for (INT i=0; i<GlyphCount; i++)
        {
            if (!properties[i].fDiacritic)
            {
                if (TextItem->Flags & ItemVertical)
                {
                    glyphOrigins[i].Y -= TOREAL(idealAdvances[i] / WorldToIdeal);
                }
                else
                {
                    glyphOrigins[i].X -= TOREAL(idealAdvances[i] / WorldToIdeal);
                }
            }
        }
    }


    // Implement glyph offsets, if any

    if (glyphOffsets)
    {
        if (TextItem->Flags & ItemVertical)
        {
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X += glyphOffsets[i].Y / WorldToIdeal;
                glyphOrigins[i].Y += glyphOffsets[i].X / WorldToIdeal;
            }
        }
        else if (TextItem->Level & 1)
        {
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X -= glyphOffsets[i].X / WorldToIdeal;
                glyphOrigins[i].Y -= glyphOffsets[i].Y / WorldToIdeal;
            }
        }
        else
        {
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X += glyphOffsets[i].X / WorldToIdeal;
                glyphOrigins[i].Y -= glyphOffsets[i].Y / WorldToIdeal;
            }
        }
    }


    // Map to device units

    WorldToDevice->Transform(glyphOrigins, GlyphCount);
    return Ok;
}




/////   AdjustGlyphAdvances
//
//      Adjusted hinted glyph placement to match a required total nominal
//      width.



//  A tiny agent to collect amount of adjustment needed to revert
//  trailing whitespaces added by glyph adjustment algorithm. The
//  adjustment value grows positive in text flow direction of run.
//
//  The idea is to have the collector being independent from the
//  algorithm as much as possible.
//

namespace
{

class TrailingAdjustCollector
{
public:
    TrailingAdjustCollector(BOOL setTrailingAdjust, INT * trailingAdjust, INT * lastNonBlankGlyphHintedWidth)
        :   SetTrailingAdjust(setTrailingAdjust),
            TrailingAdjust(trailingAdjust),
            LastNonBlankGlyphHintedWidth(lastNonBlankGlyphHintedWidth),
            CollectedAdjust(0)
    {}

    ~TrailingAdjustCollector()
    {
        *LastNonBlankGlyphHintedWidth += CollectedAdjust;
        if (SetTrailingAdjust)
        {
            *TrailingAdjust = -CollectedAdjust;
        }
    }

    void operator+=(INT delta)
    {
        CollectedAdjust += delta;
    }

    void operator-=(INT delta)
    {
        CollectedAdjust -= delta;
    }

private:
    BOOL    SetTrailingAdjust;
    INT     CollectedAdjust;
    INT *   TrailingAdjust;
    INT *   LastNonBlankGlyphHintedWidth;
}; // class TrailingAdjustCollector

} // namespace

GpStatus GlyphImager::AdjustGlyphAdvances(
    INT    runGlyphOffset,
    INT    runGlyphLimit,
    BOOL   leadingEdge,
    BOOL   trailingEdge
)
{
    const INT    *nominalWidths = NominalAdvances        + runGlyphOffset;
    INT          *hintedWidths  = AdjustedAdvances.Get() + runGlyphOffset;
    const UINT16 *glyphs        = Glyphs                 + runGlyphOffset;
    INT           glyphCount    = runGlyphLimit          - runGlyphOffset;

    ASSERT(glyphCount>0);

    const UINT16 blankGlyph = Face->GetBlankGlyph();
    INT    blankWidth = GpRound(   (   Face->GetDesignAdvance().Lookup(blankGlyph)
                                    *  EmSize
                                    *  WorldToIdeal)
                                /  Face->GetDesignEmHeight());


    // Leading and trailing blanks are set to their nominal width

    INT leadingBlanks = 0;
    while (leadingBlanks < glyphCount
           && glyphs[leadingBlanks] == blankGlyph
           && hintedWidths[leadingBlanks] != 0
           )
    {
        hintedWidths[leadingBlanks] = blankWidth;
        leadingBlanks++;
    }

    INT trailingBlanks = 0;
    while (leadingBlanks + trailingBlanks < glyphCount
           && glyphs[glyphCount-1-trailingBlanks] == blankGlyph
           && hintedWidths[glyphCount-1-trailingBlanks] != 0
           )
    {
        hintedWidths[glyphCount-1-trailingBlanks] = blankWidth;
        trailingBlanks++;
    }


    // From here on in, ignore leading and trailing blanks

    glyphs        += leadingBlanks;
    nominalWidths += leadingBlanks;
    hintedWidths  += leadingBlanks;
    glyphCount    -= leadingBlanks + trailingBlanks;


    // Collect trailing white spaces caused by adjustment (if any)
    // at the end of the operation

    TrailingAdjustCollector collector(
        trailingEdge,   // TRUE only for the last sub-run of the line
        &TrailingAdjust,
        &hintedWidths[glyphCount - 1]
    );


    if (glyphCount <= 1)
    {
        // If there is just one glyph, then there is no algorithm, just give
        // it its nominal width, and we're done.
        if (glyphCount == 1)
        {
            hintedWidths[0] = nominalWidths[0];
        }
        return Ok;
    }


    // Count the leading and trailing blanks as part of the margins.
    //
    // Where there is a leading/trailing blank we don't have to guarantee
    // falling exactly on the end point. We signal this be treating these
    // like external edges. (External edges are adjustable according to
    // alignement, e.g. in left aligned text only the left edge is required
    // to match its nominal position, the right edge can be moved as a result
    // of hinted/nominal differences.

    if (leadingBlanks)
    {
        RunLeadingMargin += leadingBlanks * blankWidth;
    }

    // Note: we cannot take advantage of trailing blanks as margin space
    // because line services often includes trailing blanks that reach beyond
    // the formatting rectangle.
    //
    // if (trailingBlanks)
    // {
    //     RunTrailingMargin += trailingBlanks * blankWidth;
    // }


    // We have more than one glyph, and the glyph at each end is non-blank
    // implies there are at least 2 non-blank glyphs.

    // Measure total nominal and hinted widths, and count internal blanks

    INT internalBlanks = 0;
    INT totalNominal   = 0;    // 32.0 ideal
    INT totalHinted    = 0;    // 32.0 ideal
    INT blanksHinted   = 0;    // 32.0 ideal
    INT blanksNominal  = 0;    // 32.0 ideal
    INT clusterCount   = 0;    // Number of base glyphs (neither space nor diacritic)

    const SCRIPT_VISATTR *properties = (const SCRIPT_VISATTR*) GlyphProperties + runGlyphOffset + leadingBlanks;

    for (INT i = 0; i < glyphCount; ++i)
    {
        if (    glyphs[i] == blankGlyph
            &&  hintedWidths[i] != 0)
        {
            internalBlanks++;
            blanksHinted  += hintedWidths[i];
            blanksNominal += nominalWidths[i];
        }
        else
        {
            totalHinted  += hintedWidths[i];
            totalNominal += nominalWidths[i];
            if (!properties[i].fDiacritic)
            {
                clusterCount++;
            }
        }
    }

    totalHinted  += blanksHinted;
    totalNominal += blanksNominal;

    // WARNING(("AdjustGlyphAdvances: Nominal %d, hinted %d", totalNominal, totalHinted));


    /// Determine adjustment strategy
    //
    //  The difference between totalNominal and totalHinted is the amount to
    //  correct for hinting.
    //
    //  In the general case we rejustify runs to match their nominal width. We
    //  do this with a combination of changes to the spaces in the run, and if
    //  necessary to the inter character gaps in the run.
    //
    //  The client tells us whether either end of the run is adjacent to a
    //  margin by passing the runLeadingEdge and runTrailingEdge flags, and if
    //  adjacent the size of the margin in the runLeadingMargin and runTrailingMargin
    //  parameters.
    //
    //  When the non-aligned end of a run is adjacent to a margin we relax the
    //  rules and allow that end to not reach the nominal position: if the
    //  hinted run is short, we leave it short. If the hinted run is long we
    //  allow it to expand into the margin, if any.
    //
    //  TextItem->Script may disallow expansion (Arabic, Indic), or require
    //  diacritics to be maintained in position.
    //
    //  Goals
    //
    //     o   Use spaces before using inter-character justification
    //     o   Use any margin space that is required to aligned
    //     o   Handle leading combining characters (achieved with fitBlackBox)
    //
    //  Logic
    //     1.  Calculate adjustment required for hinting
    //           adjustment = totalNominal - totalHinted.
    //     2.  Consider any extra adjustment required for fitBlackBox
    //           and record OriginAdjust if required.
    //     3.  Early out for for total adjustment zero
    //     4.  Early out for single cluster: centre the hinted extent over the
    //           nominal extent.
    //     5.  Calculate expansion space available at end(s) away from
    //         alignment. Include all of any leading or trailing blanks and
    //         all of any margin. If there is space available at either or both
    //         ends, use up as much overall adjustment there as possible, and
    //         update OriginAdjust as appropriate.
    //     6.  Early out for remaining adjustment zero.
    //     7.  Allocate as much remaining adjustment as possible to internal
    //         blanks, but don't more than double their size or reduce them
    //         below 1/6 em unless there are no inter-cluster junctions.
    //     8.  Early out for all remaining adjustment in blanks: adjust
    //         blanks and exit.
    //     9.  Divide remaining adjustment amongst inter-cluster junctions.
    //
    //



    // Determine the damage - how much adjustment is required in 32.0 ideal units

    INT adjustment = totalNominal - totalHinted;

    //  'adjustment' is the amount by which the hinted widths need to be
    //  increased in order to match the nominal (layout) widths. For a glyph
    //  string that needs compressing 'adjustment' is negative.


    BOOL paragraphRTL =       (FormatFlags & StringFormatFlagsDirectionRightToLeft)
                         &&  !(FormatFlags & StringFormatFlagsDirectionVertical);

    StringAlignment runRelativeAlignment = Align;

    if ((RenderRTL ? 1 : 0) != paragraphRTL)
    {
        // run alignment is opposite of paragraph alignment
        switch (Align)
        {
        case StringAlignmentNear: runRelativeAlignment = StringAlignmentFar;  break;
        case StringAlignmentFar:  runRelativeAlignment = StringAlignmentNear; break;
        }
    }


    // Allow for fitBlackBox

    if (    !(FormatFlags & StringFormatFlagsNoFitBlackBox)
        &&  (leadingEdge || trailingEdge))
    {
        INT leadingOverhang         = 0;
        INT trailingOverhang        = 0;
        INT leadingSidebearing28p4  = 0;
        INT trailingSidebearing28p4 = 0;

        GpStatus status = FaceRealization->GetGlyphStringSidebearings(
            glyphs,
            glyphCount,
            TextItem->Flags & ItemSideways,
            TextItem->Level & 1,
            &leadingSidebearing28p4,
            &trailingSidebearing28p4
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        if (leadingEdge)
        {
            INT leadingSidebearing = GpRound(leadingSidebearing28p4  * DeviceToIdealBaseline / 16);
            if (leadingSidebearing < 0)
            {
                // There is overhang. Reduce the margin space appropriately.
                RunLeadingMargin += leadingSidebearing;
                if (RunLeadingMargin < 0)
                {
                    // Anything more than the available margin must add to the
                    // adjustment.
                    adjustment   += RunLeadingMargin;
                    OriginAdjust -= RunLeadingMargin;
                    RunLeadingMargin = 0;
                }
            }
            else if (    leadingSidebearing > 0
                     &&  adjustment < 0
                     &&  runRelativeAlignment != StringAlignmentNear)
            {
                // Need to compress text - take advantage of initial whitespace
                // in first glyph.
                adjustment += leadingSidebearing;
                OriginAdjust -= leadingSidebearing;
            }
        }

        if (trailingEdge)
        {
            INT trailingSidebearing = GpRound(trailingSidebearing28p4 * DeviceToIdealBaseline / 16);
            if (trailingSidebearing < 0)
            {
                // There is overhang. Reduce the margin space appropriately.
                RunTrailingMargin += trailingSidebearing;
                if (RunTrailingMargin < 0)
                {
                    // Anything more than the available margin must add to the
                    // adjustment.
                    adjustment    += RunTrailingMargin;
                    RunTrailingMargin = 0;
                }
            }
            else if (    trailingSidebearing > 0
                     &&  adjustment < 0
                     &&  runRelativeAlignment != StringAlignmentFar)
            {
                // Need to compress text - take advantage of final whitespace
                // in last glyph.
                adjustment += trailingSidebearing;
            }
        }
    }


    if (adjustment == 0)
    {
        //WARNING(("Hinted glyph adjustment: No adjustment required"));
        return Ok;
    }

    if (clusterCount + internalBlanks <= 1)
    {
        //WARNING(("Hinted glyph adjustment: No adjustment because single cluster"));
        // Center the cluster and give up
        OriginAdjust += adjustment/2;
        collector += adjustment - adjustment/2;
        return Ok;
    }


    // Attempt to handle adjustment in margins

    INT emIdeal = GpRound(EmSize * WorldToIdeal);

    switch (runRelativeAlignment)
    {
    case StringAlignmentNear:
        if (trailingEdge)
        {
            if (adjustment >= -RunTrailingMargin)
            {
                if (adjustment < emIdeal)
                {
                    // Adjustment would neither write beyond margin, nore leave
                    // more than an extra em of whitespace: allow it
                    //WARNING(("Hinted glyph adjustment: all in trailing margin"));
                    collector += adjustment;
                    return Ok;
                }
                else
                {
                    // Adjustment would leave more than an Em of whitespace in
                    // the far margin.
                    // Reduce required expansion by an Em, leaving the rest for
                    // real expansion.
                    adjustment -= emIdeal;
                    collector += emIdeal;
                }
            }
            else
            {
                // Expand into the margin
                adjustment += RunTrailingMargin;
                collector -= RunTrailingMargin;
            }
        }
        break;

    case StringAlignmentCenter:
    {
        if (leadingEdge && trailingEdge)
        {
            INT availableMargin = min(RunLeadingMargin, RunTrailingMargin) * 2;
            if (adjustment >= -availableMargin)
            {
                OriginAdjust += adjustment/2;
                collector += adjustment - adjustment/2;
                //WARNING(("Hinted glyph adjustment: in both margins"));
                return Ok;
            }
            else
            {
                // Use up available margin
                adjustment -= availableMargin;
                OriginAdjust += availableMargin/2;
                collector += availableMargin - availableMargin/2;
            }
        }
        break;
    }

    case StringAlignmentFar:
        if (leadingEdge)
        {
            if (adjustment >= -RunLeadingMargin)
            {
                if (adjustment < emIdeal)
                {
                    // Adjustment would neither write beyond margin, nore leave
                    // more than an extra em of whitespace: allow it
                    //WARNING(("Hinted glyph adjustment: all in trailing margin"));
                    OriginAdjust += adjustment;
                    return Ok;
                }
                else
                {
                    // Adjustment would leave more than an Em of whitespace in
                    // the near margin.
                    // Reduce required expansion by an Em, leaving the rest for
                    // real expansion.
                    adjustment -= emIdeal;
                    OriginAdjust += emIdeal;
                }
            }
            else
            {
                // Use the leading margin
                adjustment += RunLeadingMargin;
                OriginAdjust -= RunLeadingMargin;
            }
        }
    }


    // Determine how much whitespace is required according to design metrics
    // Guarantee not to reduce whitespace to less than 1/6 em (rounded up to whole pixels)

    INT minimumBlankPixels      = GpRound(EmSize * WorldToIdeal / 6);
    INT minimumDeviceWhitespace = MAX(internalBlanks*minimumBlankPixels, blanksNominal/2);

    // Use internal blanks to account for remaining adjustment if it wouldn't
    // change their size too much, or if expansion of joining script characters
    // would otherwise be required.

    if (    internalBlanks > 0
        &&  (        adjustment <=  blanksNominal
                 &&  adjustment >=  -(blanksNominal-minimumDeviceWhitespace)
            ||       adjustment > 0
                 &&  IsScriptConnected()
            )
       )
    {
        //WARNING(("Hinted glyph adjustment: in internal spaces"));

        // Ajdustment expands spaces to no more than twice their nominal size
        // and no less than half their nominal size.

        // Apply all adjustment to spaces

        blankWidth =    (blanksHinted + adjustment + internalBlanks/2)
                     /  internalBlanks;

        for (INT i=0; i<glyphCount; i++)
        {
            if (    glyphs[i] == blankGlyph
                &&  hintedWidths[i] != 0)
            {
                hintedWidths[i] = blankWidth;
            }
        }

        return Ok;
    }


    if (adjustment > 0 && IsScriptConnected())
    {
        // The only remaining justification method is intercharacter spacing,
        // but the adjustment requires opening the character spacing and this
        // script is one that cannot be expanded without breaking
        // the joining line between characters.

        // The best we can do is center this run

        OriginAdjust += adjustment/2;
        collector += adjustment - adjustment/2;

        return Ok;
    }


    // Adjustment will require inter-cluster justification

    //WARNING(("Hinted glyph adjustment: intercluster"));

    // Adjustment requires changes to the width of all but the last
    // glyph of each word.

    INT interClusterAdjustment = adjustment;

    if (internalBlanks)
    {
        if (adjustment < 0)
        {
            blankWidth = minimumBlankPixels;
        }
        else
        {
            blankWidth = blanksNominal * 2 / internalBlanks;
        }
        interClusterAdjustment -= blankWidth * internalBlanks - blanksHinted;
    }
    else
    {
        blankWidth = 0;
    }

    // blankWidth - Required width for each blank
    // interClusterAdjustment - adjustment to share between all

    // Count number of blank runs (not the same as number of blank glyphs)

    i=0;
    INT blankRuns = 0;

    while (i < glyphCount)
    {
        if (    glyphs[i] == blankGlyph
            &&  hintedWidths[i] != 0)
        {
            i++;
            while (    i < glyphCount
                   &&  glyphs[i] == blankGlyph
                   &&  hintedWidths[i] != 0)
            {
                i++;
            }
            blankRuns++;
        }
        else
        {
            while (    i < glyphCount
                   &&  (    glyphs[i] != blankGlyph
                        ||  hintedWidths[i] == 0))
            {
                i++;
            }
        }
    }

    // Establish number of adjustment points between non-blanks.
    //
    // Adjustment can happen only between clusters, i.e. not in blank
    // runs, nor in the cluster immediately before a blank run or
    // the last cluster in the line.

    INT interClusterJunctions =      clusterCount
                                  -  blankRuns
                                  -  1;


    // Prepare adjustment control variables

    // When there's a remainder, apply it all at the end of the line
    // Advantage - all words are even. Disadvantage - end of line looks heavy.

    INT perJunctionDelta;
    INT extraPixelLimit;
    INT pixelWidth = GpRound(DeviceToIdealBaseline);

    if (interClusterJunctions <= 0)
    {
        // There are no words of more than one cluster

        // Since we know there are at least 2 nonblank clusters,
        // this means there must be at least one blank somewhere.

        ASSERT(internalBlanks > 0);

        // We have no chice except to make all adjustment happen in the blanks

        blankWidth += (interClusterAdjustment + internalBlanks/2) / internalBlanks;
        perJunctionDelta = 0;
        extraPixelLimit  = 0;
    }
    else if (pixelWidth < 1)
    {
        // Pixels are smaller tham one ideal unit in size, which implies that
        // glyphs are over 4000 pixels high. In this case all glyphs get the
        // same adjustment and we dont bother with extra pixels for some glyphs.

        perJunctionDelta = interClusterAdjustment / interClusterJunctions;
        extraPixelLimit = 0;
    }
    else
    {
        // Every intercharacter junction gets a fixed adjustment that is
        // whole multiple of the pixel width, additionally a number of
        // initial intercharacter junctions receive an addition pixel
        // width adjustment.

        INT pixelInterClusterAdjustment = interClusterAdjustment / pixelWidth;
        INT pixelPerJunctionDelta       = pixelInterClusterAdjustment / interClusterJunctions;
        INT remainder                   =    interClusterAdjustment
                                          -  pixelPerJunctionDelta * interClusterJunctions * pixelWidth;
        INT pixelRemainder = (remainder - pixelWidth/2) / pixelWidth; // Round down to avoid 1 pixel overflow

        if (pixelRemainder >= 0)
        {
            // Start with an extra pixel until remainder are used up
            perJunctionDelta = GpRound((pixelPerJunctionDelta) * DeviceToIdealBaseline);
            extraPixelLimit = pixelRemainder;
        }
        else
        {
            // Initial junctions take per pixel delta, the rest per pixel delta -1
            // Using the same algorithm as for expansion, the the per junction delta
            // one less than it should be and use the extra pixel handling.
            perJunctionDelta = GpRound((pixelPerJunctionDelta-1) * DeviceToIdealBaseline);
            extraPixelLimit = interClusterJunctions + pixelRemainder;
        }
    }


    //  Adjustment FSM
    //
    //  perJunctionDelta  - amount to adjust every inter-character junction
    //  extraPixelLimit   - number of junctions to receive an extra pixe of adjustment
    //  pixelWidth        - amount of adjustment that spaces one pixel

    BOOL prevCharacterBlank = glyphs[0] == blankGlyph  &&  hintedWidths[0] != 0;
    for (INT i=1; i<= glyphCount; i++)
    {
        if (prevCharacterBlank)
        {
            // Previous character was blank - easy!

            hintedWidths[i-1] = blankWidth;
        }
        else
        {
            // Previous character nonblank

            // skip over diacritics. We never change the width of a glyph before
            // a diacritic, only the width of the last diacritic in a run of
            // diacritics.
            while (    i < glyphCount
                   &&  properties[i].fDiacritic)
            {
                i++;
            }

            if (    i >= glyphCount
                ||  (    glyphs[i] == blankGlyph
                     &&  hintedWidths[i] != 0))
            {
                // The previous nonblank preceeded a blank or margin
                // No change - use the hinted width
            }
            else
            {
                // The previous nonblank is adjustable
                hintedWidths[i-1] +=    perJunctionDelta
                                     +  (extraPixelLimit-- > 0 ? pixelWidth : 0);
            }
        }

        if (i < glyphCount)
        {
            prevCharacterBlank = glyphs[i] == blankGlyph  &&  hintedWidths[i] != 0;
        }
    }

    return Ok;
}





/////   Public GlyphImager methods
//
//


/////   Initialise
//
//

GpStatus GlyphImager::Initialize(
    IN  const GpFaceRealization *faceRealization,
    IN  const GpMatrix          *worldToDevice,
    IN  REAL                     worldToIdeal,
    IN  REAL                     emSize,
    IN  INT                      glyphCount,
    IN  const UINT16            *glyphs,
    IN  const GpTextItem        *textItem,
    IN  const GpStringFormat    *format,
    IN  INT                      runLeadingMargin,
    IN  INT                      runTrailingMargin,
    IN  BOOL                     runLeadingEdge,       // This run at leading edge of line
    IN  BOOL                     runTrailingEdge,      // This run at trailing edge of line
    IN  const WCHAR             *string,
    IN  INT                      stringOffset,
    IN  INT                      stringLength,
    IN  const UINT16            *glyphProperties,   // glyph properties array
    IN  const INT               *glyphAdvances,     // glyph advance width array
    IN  const Point             *glyphOffsets,      // glyph offset array
    IN  const UINT16            *glyphMap,
    IN  SpanVector<UINT32>      *rangeVector,       // optional
    IN  BOOL                     renderRTL
)
{
    Face              = faceRealization->GetFontFace();
    FaceRealization   = faceRealization;
    WorldToDevice     = worldToDevice;
    WorldToIdeal      = worldToIdeal;
    EmSize            = emSize;
    GlyphCount        = glyphCount;
    Glyphs            = glyphs;
    NominalAdvances   = glyphAdvances;
    NominalOffsets    = glyphOffsets;
    GlyphProperties   = glyphProperties;
    GlyphMap          = glyphMap;
    TextItem          = textItem;
    Format            = format;
    Adjusted          = FALSE;
    RunLeadingMargin  = runLeadingMargin;
    RunTrailingMargin = runTrailingMargin;
    RangeVector       = rangeVector;
    String            = string;
    StringOffset      = stringOffset;
    StringLength      = stringLength;
    RenderRTL         = renderRTL;
    OriginAdjust      = 0;
    TrailingAdjust    = 0;
    InitializedOk     = FALSE;

    if (format)
    {
        FormatFlags = format->GetFormatFlags();
        Align       = format->GetAlign();
    }
    else
    {
        FormatFlags = 0;
        Align       = StringAlignmentNear;
    }


    // Establish device unit to ideal unit scale factor

    REAL m1;
    REAL m2;

    if (   (textItem->Flags & ItemVertical)
        && !(textItem->Flags & ItemSideways))
    {
        m1 = WorldToDevice->GetM21();
        m2 = WorldToDevice->GetM22();
    }
    else
    {
        m1 = WorldToDevice->GetM11();
        m2 = WorldToDevice->GetM12();
    }

    REAL d = m1*m1 + m2*m2;

    if (d > 0)
    {
        DeviceToIdealBaseline = WorldToIdeal / REALSQRT(d);
    }
    else
    {
        DeviceToIdealBaseline = 0;
    }

    // Early out if:
    //
    // Client forced nominal advance with private testing flag
    // Unhinted, not continuous script, and there are margins (for glyph overhangs)

    if (    (FormatFlags & StringFormatFlagsPrivateUseNominalAdvance)
        ||  !IsScriptConnected()
            && (FaceRealization->IsFixedPitch()
                || (!IsGridFittedTextRealizationMethod(FaceRealization->RealizationMethod())
                       && runLeadingMargin >= 0
                       && runTrailingMargin >= 0
                   )
               )
       )
    {
        // No adjustment required: place Glyphs using nominal advance widths
        InitializedOk = TRUE;
        return Ok;
    }



    //// Determine amount of adjustment required

    // If we're not hinting, start with the nominal widths, otherwise
    // call the rasterizer to obtain hinted widths.

    AdjustedAdvances.SetSize(GlyphCount);
    AdjustedOffsets.SetSize(GlyphCount);

    if (    !AdjustedAdvances
        ||  !AdjustedOffsets)
    {
        return OutOfMemory;
    }

    GpStatus status = Ok;

    if (!IsGridFittedTextRealizationMethod(FaceRealization->RealizationMethod()) && !IsScriptConnected())
    {
        // Realized == nominal, so we don't need to invoke the rasterizer
        // (we only get here if we need to adjust for fitBlackBox)

        GpMemcpy(AdjustedAdvances.Get(), NominalAdvances, glyphCount * sizeof(INT));
        if (glyphOffsets)
        {
            GpMemcpy(AdjustedOffsets.Get(), NominalOffsets, glyphCount * sizeof(GOFFSET));
        }
    }
    else
    {
        status = Face->GetShapingCache()->GetRealizedGlyphPlacement(
            TextItem,
            Glyphs,
            (SCRIPT_VISATTR *)glyphProperties,
            glyphCount,
            FormatFlags,
            WorldToDevice,
            WorldToIdeal,
            EmSize,
            FaceRealization,
            AdjustedAdvances.Get(),
            NominalOffsets ? reinterpret_cast<GOFFSET*>(AdjustedOffsets.Get()) : NULL,
            NULL                    // no total advance required
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }


    // Adjust hinted advances to sum the same as the nominal placements
    // including implementation of fitBlackBox.

    if (RangeVector)
    {
        SpanRider<UINT32> rangeRider(RangeVector);

        INT runStringOffset = stringOffset;
        INT runGlyphOffset  = 0;

        while (runGlyphOffset < GlyphCount)
        {
            rangeRider.SetPosition(runStringOffset);
            INT runStringLimit;
            if (rangeRider.AtEnd())
            {
                runStringLimit = stringLength;
            }
            else
            {
                runStringLimit = runStringOffset + rangeRider.GetUniformLength();
            }

            INT runGlyphLimit;

            if (runStringLimit < stringLength)
            {
                runGlyphLimit = glyphMap[runStringLimit];
                while (    runGlyphLimit < GlyphCount
                       &&  (    runGlyphLimit < runGlyphOffset
                            ||  reinterpret_cast<const SCRIPT_VISATTR*>(glyphProperties+runGlyphLimit)->fDiacritic))
                {
                    runGlyphLimit++;
                }
            }
            else
            {
                runGlyphLimit = GlyphCount;
            }


            // Adjust between runGlyphOffset and runGlyphLimit.
            // Note, if the client specifies multiple ranges inside a cluster,
            // some glyph runs will be empty.

            if (runGlyphLimit > runGlyphOffset)
            {
                status = AdjustGlyphAdvances(
                    runGlyphOffset,
                    runGlyphLimit,
                    runGlyphOffset <= 0 ? runLeadingEdge : FALSE,
                    runGlyphLimit  >= GlyphCount ? runTrailingEdge : FALSE
                );
                IF_NOT_OK_WARN_AND_RETURN(status);
            }

            runGlyphOffset  = runGlyphLimit;
            runStringOffset = runStringLimit;
        }
    }
    else
    {
        // Adjust entire run as one
        status = AdjustGlyphAdvances(
            0,
            GlyphCount,
            runLeadingEdge,
            runTrailingEdge
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }


    //#if DBG
    //    INT totalNominal = 0;
    //    INT adjustedHinted = 0;
    //    for (INT i = 0; i < GlyphCount; ++i)
    //    {
    //        totalNominal   += NominalAdvances[i];
    //        adjustedHinted += AdjustedAdvances[i];
    //    }
    //    WARNING(("Nominal %d, adjusted hinted %d, delta %d",
    //             totalNominal, adjustedHinted, adjustedHinted-totalNominal));
    //#endif


    Adjusted      = TRUE;
    InitializedOk = TRUE;
    return Ok;
}




GpStatus GlyphImager::GetAdjustedGlyphAdvances(
    IN  const PointF    *origin,
    OUT const INT       **adjustedGlyphAdvances,
    OUT INT             *originAdjust,
    OUT INT             *trailingAdjust
)
{
    if (!InitializedOk)
    {
        return WrongState;
    }

    if (Adjusted)
    {
        if (origin)
        {
            PointF  cellOrigin;
            GetDisplayCellOrigin(*origin, &cellOrigin);

            if (FormatFlags & StringFormatFlagsDirectionVertical)
            {
                *originAdjust = OriginAdjust;
            }
            else
            {
                INT axisOriginAdjust = GpRound((cellOrigin.X - origin->X) * WorldToIdeal);
                *originAdjust = RenderRTL ? -axisOriginAdjust : axisOriginAdjust;
            }
        }
        else
        {
            *originAdjust = OriginAdjust;
        }

        *adjustedGlyphAdvances = AdjustedAdvances.Get();
        *trailingAdjust        = TrailingAdjust;
    }
    else
    {
        *adjustedGlyphAdvances = NominalAdvances;
        *originAdjust          =
        *trailingAdjust        = 0;
    }

    return Ok;
}




void GlyphImager::GetDisplayCellOrigin(
    IN  const PointF    &origin,        // baseline origin in world units
    OUT PointF          *cellOrigin     // adjusted display origin in world units
)
{
    // Convert ideal advances to glyph origins

    *cellOrigin = origin;

    INT axisOriginAdjust = RenderRTL ? -OriginAdjust : OriginAdjust;

    if (OriginAdjust != 0)
    {
        // OriginAdjust is the delta to the leading edge of the string.
        // Apply it to cellOrigin. cellOrigin is in world units.

        if (FormatFlags & StringFormatFlagsDirectionVertical)
        {
            cellOrigin->Y += axisOriginAdjust / WorldToIdeal;
        }
        else
        {
            cellOrigin->X += axisOriginAdjust / WorldToIdeal;
        }
    }

    if (Adjusted && WorldToDevice->IsTranslateScale())
    {

        // Since in some grid fit cases the glyphAdvances array will have fractional
        // pixel advances, glyph display will snap some leftward and some rightward.
        // We snap the origin here to a whole pixel in order to obtain repeatable
        // position display independant of glyph position, and so that in the
        // common justification case where ony a few pixels are removed from the
        // whole string, the pixel removal happens away from the first few glyphs.

        // The cellOrigin is in world units so to round it to the whole pixel we need to convert
        // it to device units (multiply cellOrigin->X by WorldToDevice->GetM11() for x scaling and 
        // myltiply cellOrigin->Y  by WorldToDevice->GetM22() for y scaling).
        // then round it to the whole pixel and then revert it back to world unit through dividing 
        // by the same value we already multiplied by.
        // Note that we know there is no rotation or shear involved as this codepath is only
        // active when the facerealization reports gridfitting.

        if (WorldToDevice->GetM11()!=0)
        {
            cellOrigin->X = TOREAL(GpRound(cellOrigin->X * WorldToDevice->GetM11())) / 
                                                            WorldToDevice->GetM11();
        }

        if (WorldToDevice->GetM22()!=0)
        {
            cellOrigin->Y = TOREAL(GpRound(cellOrigin->Y * WorldToDevice->GetM22())) / 
                                                            WorldToDevice->GetM22();
        }
    }
}
   




GpStatus
GlyphImager::DrawGlyphs(
    IN  const PointF               &origin,       // in world units
    IN  SpanVector<const GpBrush*> *brushVector,
    IN  GpGraphics                 *graphics,
    OUT PointF                     *cellOrigin,
    OUT const INT                  **adjustedGlyphAdvances
)
{
    if (!InitializedOk)
    {
        return WrongState;
    }

    GetDisplayCellOrigin(origin, cellOrigin);

    AutoBuffer<PointF, 32> glyphOrigins(GlyphCount);

    GpStatus status = GlyphPlacementToGlyphOrigins(
        cellOrigin,
        graphics,
        glyphOrigins.Get()
    );
    IF_NOT_OK_WARN_AND_RETURN(status);


    //  Loop through all possible different brushes,
    //  render each brush separately.

    SpanRider<const GpBrush*> brushRider(brushVector);
    brushRider.SetPosition(StringOffset);

    INT runStringOffset = 0;
    while (runStringOffset < StringLength)
    {
        INT brushLength = min(brushRider.GetUniformLength(),
                              static_cast<UINT>(StringLength - runStringOffset));

        INT runGlyphOffset = GlyphMap[runStringOffset];
        INT runGlyphCount  =    (   runStringOffset + brushLength < StringLength
                                 ?  GlyphMap[runStringOffset + brushLength]
                                 :  GlyphCount)
                             -  runGlyphOffset;

        INT drawFlags = 0;
        if (    FormatFlags & StringFormatFlagsPrivateNoGDI
            ||  TextItem->Flags & ItemSideways)
        {
            drawFlags |= DG_NOGDI;
        }

        status = graphics->DrawPlacedGlyphs(
            FaceRealization,
            brushRider.GetCurrentElement(),
            drawFlags,
            String + StringOffset + runStringOffset,
            brushLength,
            RenderRTL,
            Glyphs + runGlyphOffset,
            GlyphMap + runStringOffset,
            glyphOrigins.Get() + runGlyphOffset,
            runGlyphCount,
            TextItem->Script,
            (TextItem->Flags & ItemSideways)
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        runStringOffset += brushLength;
        brushRider.SetPosition(StringOffset + runStringOffset);
    }

    *adjustedGlyphAdvances = Adjusted ? AdjustedAdvances.Get() : NominalAdvances;

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\fulltextimager.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Full text imager implementation
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"




FullTextImager::FullTextImager (
    const WCHAR                 *string,
    INT                         length,
    REAL                        width,
    REAL                        height,
    const GpFontFamily          *family,
    INT                         style,
    REAL                        size,
    const GpStringFormat        *format,
    const GpBrush               *brush) :

    GpTextImager(),
    Width                       (width),
    Height                      (height),
    BrushVector                 (brush),
    FamilyVector                (family),
    StyleVector                 (style),
    SizeVector                  (size),
    FormatVector                (format),
    LanguageVector              (LANG_NEUTRAL),
    TextItemVector              (0),
    BreakVector                 (NULL),
    RunVector                   (NULL),
    ParagraphVector             (NULL),
    BuiltLineVector             (NULL),
    VisibilityVector            (VisibilityShow),
    RangeVector                 (0),
    LinesFilled                 (0),
    CodepointsFitted            (0),
    LeftOrTopLineEdge           (0x7fffffff),
    RightOrBottomLineEdge       (0x80000000),
    TextDepth                   (0),
    LineServicesOwner           (NULL),
    Status                      (Ok),
    RunRider                    (&RunVector),
    ParagraphRider              (&ParagraphVector),
    HighStringPosition          (0),
    HighLineServicesPosition    (0),
    Graphics                    (NULL),
    Path                        (NULL),
    Ellipsis                    (NULL),
    BreakClassFromCharClass     (BreakClassFromCharClassNarrow),
    DefaultFontGridFitBaselineAdjustment (0),
    Flags                       (0)
{
    ASSERT(MAX_SCRIPT_BITS >= ScriptMax);

    Dirty = TRUE;


    // Take local copy of client string

    String = (WCHAR*) GpMalloc(sizeof(WCHAR) * length);
    if (String)
    {
        memcpy(String, string, length * sizeof(WCHAR));
        Length = length;

        INT hotkeyOption = GetFormatHotkeyPrefix(format);

        if (hotkeyOption != HotkeyPrefixNone)
        {
            INT i = 0;
            while (i < Length)
            {
                if (String[i] == '&')
                {
                    String[i++] = WCH_IGNORABLE;

                    if (   hotkeyOption == HotkeyPrefixShow
                        && i < Length
                        && String[i] != '&')
                    {
                        HotkeyPrefix.Add(i - 1);
                    }
                }
                i++;
            }
        }
    }
    else
    {
        Status = OutOfMemory;
        Length = 0;
    }

    // Determine max length of each line and depth of accumulated lines

    if (    format
        &&  format->GetFormatFlags() & StringFormatFlagsDirectionVertical)
    {
        LineLengthLimit = Height;
        TextDepthLimit  = Width;
    }
    else
    {
        LineLengthLimit = Width;
        TextDepthLimit  = Height;
    }

    // Choose scale such that default font is 2048 units high.

    WorldToIdeal = float(2048.0 / size);


    //  Default incremental tab as big as four characters of default font
    //
    //  Incremental tab is the distance to be applied when tabs are encountered
    //  to the right of user-defined tabstops (see sample below).
    //
    //  (given - incremental tab: 5, t: user tabstop, x: text separated with tab)
    //
    //
    //          ----|----|----|----|----|----
    //                t    t
    //          xx    xx   xx xx   xx   xx
    //                        ^ (start applying incremental tab)

    DefaultIncrementalTab = GpRound(4 * size * WorldToIdeal);


    //  Determine what line break class table to be used.
    //
    //  There are quite a few characters that have ambiguous width depending on
    //  the context. If they are part of an Eastern Asian run, the user is expected
    //  to see the wide form and it should behave like a wide character concerning
    //  line breaking.
    //
    //  The disambiguation is somewhat heuristic. The language tag should really
    //  be used first. But we just dont have it around in V1. The temporary solution
    //  for now is to check if our main font supports any Far East codepages. Revisit
    //  this in V2.
    //
    //  (wchao, 01-03-2001)

    GpFontFace *fontFace = family->GetFace(style);

    if (fontFace)
    {
        static const UINT FarEastCodepages[] =
        {
            932, 936, 949, 950
        };

        INT codepageCount = sizeof(FarEastCodepages) / sizeof(FarEastCodepages[0]);

        for (INT i = 0; i < codepageCount; i++)
        {
            if (fontFace->IsCodePageSupported(FarEastCodepages[i]))
                break;
        }

        if (i < codepageCount)
        {
            //  The default font supports one of the Far East codepages.
            //  This resolves the line break classes to wide.

            BreakClassFromCharClass = BreakClassFromCharClassWide;
        }
    }
}


GpStatus FullTextImager::ReleaseVectors ()
{
    BuiltLineVector.Free();
    RunVector.Free();
    ParagraphVector.Free();
    BreakVector.Free();

    return Ok;
}


FullTextImager::~FullTextImager()
{
    //  Lines must be released before the builder
    //  since builder owns releasing it.
    //

    ReleaseVectors();

    if (String) {
         GpFree(String);
    }
    Length = 0;

    if (LineServicesOwner)
    {
        ols::ReleaseLineServicesOwner(&LineServicesOwner);
    }

    if (Ellipsis)
    {
        delete Ellipsis;
    }
}






/////   GetFallbackFontSize
//
//      Selects an appropriate size for the fallback font. Attempts a
//      compromise match of weight, legibility and clipping.
//
//      Never creates a fallback font of higher em size than original font.


void FullTextImager::GetFallbackFontSize(
    IN   const GpFontFace  *originalFace,
    IN   REAL               originalSize,   // em size
    IN   const GpFontFace  *fallbackFace,
    OUT  REAL              *fallbackSize,   // fallback em size
    OUT  REAL              *fallbackOffset  // fallback baseline offset (+=up)
)
{
    if (originalFace == fallbackFace)
    {
        // Special easy case can happen when fallback fails

        *fallbackSize   = originalSize;
        *fallbackOffset = 0;
        return;
    }



    REAL  originalAscender  = TOREAL(originalFace->GetDesignCellAscent()) /
                              TOREAL(originalFace->GetDesignEmHeight());
    REAL  originalDescender = TOREAL(originalFace->GetDesignCellDescent())/
                              TOREAL(originalFace->GetDesignEmHeight());

    REAL  fallbackAscender  = TOREAL(fallbackFace->GetDesignCellAscent()) /
                              TOREAL(fallbackFace->GetDesignEmHeight());
    REAL  fallbackDescender = TOREAL(fallbackFace->GetDesignCellDescent())/
                              TOREAL(fallbackFace->GetDesignEmHeight());


    // Default results

    *fallbackSize   = originalSize;
    *fallbackOffset = 0;

    // Early out handling

    if (    fallbackAscender  <= 0
        ||  fallbackDescender <= 0)
    {
        // We can't do anything if the fallback font is missing ascender or descender
        return;
    }


    // Start by generating a scale factor and baseline offset that places the
    // fallback font cell exactly over the original font cell


    REAL scale =    (originalAscender + originalDescender)
                 /  (fallbackAscender + fallbackDescender);


    REAL offset = originalDescender - fallbackDescender * scale;


    VERBOSE(("Fallback from %S, a%d%%, d%d%% to %S, a%d%%, d%d%%, scale %d%%, offset %d%%.",
        (BYTE*)(originalFace->pifi)+originalFace->pifi->dpwszFamilyName,
        INT(originalAscender * 100),
        INT(originalDescender * 100),
        (BYTE*)(fallbackFace->pifi)+fallbackFace->pifi->dpwszFamilyName,
        INT(fallbackAscender * 100),
        INT(fallbackDescender * 100),
        INT(scale * 100),
        INT((originalDescender - fallbackDescender) * 100)
    ));



    // We now have a scale factor and offset that size and place the fallback
    // cell directly over the original cell.
    //
    // This may not be ideal.
    //
    // If the em size is significantly reduced, the result may too small to be
    // legible.
    //
    // If the fallback font has no internal leading, the result may be
    // characters touching in subsequent lines.
    //
    // If the baseline offset is more than 10% of the em size, the characters
    // won't appear to be part of the same text.
    //
    // Note that applying these restrictions will lead to clipping of some high
    // and low marks. This is a compromise we cannot avoid.




    // Limit scale factor

    scale  = TOREAL(min(max(scale, 1.0), 1.10));

    // dbrown ToDo: To be compatible with Uniscirbe need to adjust scale
    // factor and offset limits according to emsize: at 8pt and below scale
    // should never be less than 1.0. At 12pt and above scale can drop to
    // 0.75.
    // However - I can't see how to do this in a device independant manner.
    // The client may not have requested the emSize in points.


    // Limit offset

    offset = 0; //TOREAL(min(max(offset, -0.04), 0.04));



    *fallbackSize   = originalSize * scale;
    *fallbackOffset = originalSize * offset;
}











/////   Bidirectional analysis
//
//      Runs the Unicode bidirectional algorithm, and updates the level
//      value in the GpTextItems.


GpStatus FullTextImager::BidirectionalAnalysis()
{
    AutoArray<BYTE> levels(new BYTE[Length]);

    if (!levels)
    {
        return OutOfMemory;
    }


    INT      bidiFlags      = 0;
    INT      lengthAnalyzed = 0;
    BYTE     baseLevel      = GetParagraphEmbeddingLevel();
    GpStatus status = Ok;


    if (baseLevel == 1)
    {
        bidiFlags = BidiParagraphDirectioRightToLeft;
        if (Globals::ACP == 1256  ||  PRIMARYLANGID(GetUserLanguageID()) == LANG_ARABIC)
        {
            bidiFlags |= BidiPreviousStrongIsArabic;
        }
    }

    status = UnicodeBidiAnalyze(
        String,
        Length,
        (BidiAnalysisFlags)bidiFlags,
        NULL,
        levels.Get(),
        &lengthAnalyzed
    );

    if (status != Ok)
    {
        return status;
    }

    ASSERT (lengthAnalyzed == Length);

    #define ValidLevel(l) (l == 255 ? baseLevel : l)

    #if DBG
        INT nesting = ValidLevel(levels[0]) - baseLevel;
    #endif


    // Merge levels and text items

    INT runStart = 0;
    SpanRider<GpTextItem> itemRider(&TextItemVector);


    while (runStart < lengthAnalyzed)
    {
        INT level = ValidLevel(levels[runStart]);

        itemRider.SetPosition(runStart);

        // Scan to first change in level or text item

        INT runEnd = runStart + 1;
        INT limit  = runStart + itemRider.GetUniformLength();
        if (limit > lengthAnalyzed)
        {
            limit = lengthAnalyzed;
        }

        while (    runEnd < limit
               &&  level == ValidLevel(levels[runEnd]))
        {
            runEnd++;
        }

        if (level != 0)
        {
            // Run level is different from default

            GpTextItem item = itemRider.GetCurrentElement();

            item.Level = level;

            status = itemRider.SetSpan(
                runStart,
                runEnd - runStart,
                item
            );
            if (status != Ok)
                return status;
        }

        #if DBG
            // CR/LF items must be at level zero

            itemRider.SetPosition(runStart);
            ASSERT(    String[runStart] != 0x0d
                   ||  itemRider.GetCurrentElement().Level == baseLevel);

            nesting +=    (runEnd == lengthAnalyzed
                          ? baseLevel
                          : ValidLevel(levels[runEnd]))
                       -  ValidLevel(levels[runStart]);
        #endif

        runStart = runEnd;
    }
    ASSERT (nesting == 0);  // keep the nesting level in check!

    return Ok;
}






/////   MirroredNumericAndVerticalAnalysis
//
//      Updates backing store for mirrored characters and digit substitution.
//
//      Breaks text items where required for glyph mirroring by transform,
//      for vertical glyphs remaining upright (sideways to the baseline),
//      and for numeric text requiring glyph substitution.
//
//      Notes:
//
//          Mirroring is not performed when metafiling
//          Mirroring is only performed for RTL rendering runs
//
//
//      Far Eastern text is allocated to vertical upright items, all other
//      text is allocated to vertical rotated items.
//
//      Vertical upright items use font vertical metrics to place the glyphs
//      the same way up as for horizontal text, but laid out vertically.
//
//      Vertical rotated items are the same as horizontal items, except that
//      the whole run is rotated clockwise 90 degrees.


GpStatus FullTextImager::MirroredNumericAndVerticalAnalysis(
    ItemScript numericScript
)
{
    SpanRider<GpTextItem> itemRider(&TextItemVector);

    INT mask = SecClassMS | SecClassMX;

    if (numericScript != ScriptNone)
    {
        mask |= SecClassEN | SecClassCS | SecClassET;
    }

    if (GetFormatFlags() & StringFormatFlagsDirectionVertical)
    {
        mask |= SecClassSA | SecClassSF;

        // Set ItemVertical flag on each item in a vertical text imager

        itemRider.SetPosition(0);
        while (!itemRider.AtEnd())
        {
            itemRider.GetCurrentElement().Flags |= ItemVertical;
            itemRider++;
        }
    }

    return SecondaryItemization(String, Length, numericScript, mask, GetParagraphEmbeddingLevel(),
                         GetMetaFileRecordingFlag(), &TextItemVector);
}






/////   CreateTextRuns
//
//      Create one or more runs for a given string. Multiple runs are
//      generated when font fallback is required.


GpStatus FullTextImager::CreateTextRuns(
    INT                 runLineServicesStart,
    INT                 runStringStart,
    INT                 runLength,
    const GpTextItem   &item,
    INT                 formatFlags,
    const GpFontFamily *family,
    INT                 style,
    REAL                size
)
{
    GpStatus status = Ok;

    const GpFontFace *face = family->GetFace(style);

    if (face == (GpFontFace *) NULL)
        return GenericError;

    while (runLength > 0)
    {
        // Start by glyphing the run

        GMAP    *glyphMap;
        UINT16  *glyphs;
        GPROP   *glyphProperties;
        INT      glyphCount;
        USHORT   engineState;


        status = face->GetShapingCache()->GetGlyphs(
            &item,
            String + runStringStart,
            runLength,
            formatFlags,
            GetFormatHotkeyPrefix() != HotkeyPrefixNone,
            &glyphMap,
            &glyphs,
            (SCRIPT_VISATTR**)&glyphProperties,
            &glyphCount,
            &engineState
        );
        if (status != Ok)
        {
            return status;
        }


        // Establish limit of valid clusters (clusters not containing
        // any missing glyphs).
        //
        // Establishes length in codepoints (validCodepoints) and glyphs
        // (validGlyphs).

        UINT16 missingGlyph = face->GetMissingGlyph();
        INT    validCodepoints;
        INT    nextValidCodepoints = runLength;
        INT    validGlyphs = 0;

        if ((formatFlags & StringFormatFlagsNoFontFallback) ||
             face->IsSymbol())
        {
            // Pretend there were no missing glyphs
            validCodepoints = runLength;
            validGlyphs     = glyphCount;
        }
        else
        {
            while (    validGlyphs <  glyphCount
                   &&  glyphs[validGlyphs] != missingGlyph)
            {
                validGlyphs++;
            }

            if (validGlyphs >= glyphCount)
            {
                validCodepoints = runLength;  // No missing glyphs
            }
            else
            {
                // Run forwards to find first character of cluster following that
                // containing the missing glyph, then back to the first codepoint
                // of the cluster containing the missing glyph.

                validCodepoints = 0;
                while (    validCodepoints < runLength
                       &&  glyphMap[validCodepoints] < validGlyphs)
                {
                    validCodepoints++;
                }

                nextValidCodepoints = validCodepoints;
                if (validCodepoints < runLength)
                {
                    while (   nextValidCodepoints < runLength
                           && glyphs[glyphMap[nextValidCodepoints]] == missingGlyph)
                    {
                        nextValidCodepoints++;
                    }
                }

                if (   validCodepoints == runLength
                    || glyphMap[validCodepoints] > validGlyphs)
                {
                    validCodepoints--;  // Last codepoint of cluster contain missing glyph

                    validGlyphs = glyphMap[validCodepoints]; // First glyph of cluster containing missing glyph

                    while (    validCodepoints > 0
                           &&  glyphMap[validCodepoints-1] == validGlyphs)
                    {
                        validCodepoints--;
                    }
                }
            }
        }


        if (validCodepoints > 0)
        {
            // Characters up to validCodepoints don't need fallback

            lsrun *run = new lsrun(
                lsrun::RunText,
                runStringStart,
                validCodepoints,
                item,
                formatFlags
            );
            if (!run)
            {
                return OutOfMemory;
            }

            ASSERT(validGlyphs > 0);

            run->Face            = face;
            run->EmSize          = size;
            run->GlyphCount      = validGlyphs;
            run->Glyphs          = glyphs;
            run->GlyphMap        = glyphMap;
            run->GlyphProperties = glyphProperties;
            run->EngineState     = engineState;

            status = RunVector.SetSpan(runLineServicesStart, validCodepoints, run);
            if (status != Ok)
                return status;

            // Account for amount glyphed

            runStringStart       += validCodepoints;
            runLineServicesStart += validCodepoints;
            runLength            -= validCodepoints;
        }
        else
        {
            // This run started with missing glyphs so the glyph buffers
            // returned by GetGlyphs won't be required.

            delete [] glyphs; glyphs = 0;
            delete [] glyphMap; glyphMap = 0;
            delete [] glyphProperties; glyphProperties = 0;

        }


        // We've created a run for any inital run of valid codepoints.
        // If there are more characters to glyph, the next characters
        // will require font fallback.


        if (runLength > 0)
        {
            // Create a fallback run

            const GpFontFace *newFace = NULL;
            INT               uniformLength;

            GpFamilyFallback *familyFallback = family->GetFamilyFallback();

            // it can be NULL if we failed to create the fallback.
            if (familyFallback)
            {
                ASSERT(nextValidCodepoints-validCodepoints>0);

                status = familyFallback->GetUniformFallbackFace(
                    String + runStringStart,
                    nextValidCodepoints-validCodepoints,
                    style,
                    item.Script,
                    &newFace,
                    &uniformLength
                );
                if (status != Ok)
                    return status;
            }
            else
            {
                uniformLength = runLength;
            }

            ASSERT(uniformLength > 0);
            if (uniformLength <= 0)
            {
                return GenericError;
            }

            if (newFace == NULL)
            {
                VERBOSE(("Font fallback failed to get a fallback face"));
                newFace = face;  // Reshape with original face.
            }

            // if the fallback failed to get new font face and we use the original font face
            // then we change the scipt id into ScriptNone (which is equal 0) we are going
            // to show the default glyph any way so we don't need the shaping overhead. also
            // it will be useful in case in Numbers shaping so we will show the Latin numbers
            // instead of the default glyphs.

            status = newFace->GetShapingCache()->GetGlyphs(
                newFace == face ? &GpTextItem(0) : &item,
                String + runStringStart,
                uniformLength,
                formatFlags,
                GetFormatHotkeyPrefix() != HotkeyPrefixNone,
                &glyphMap,
                &glyphs,
                (SCRIPT_VISATTR**)&glyphProperties,
                &glyphCount,
                &engineState
            );
            if (status != Ok)
            {
                return status;
            }

            lsrun *run = new lsrun(
                lsrun::RunText,
                runStringStart,
                uniformLength,
                item,
                formatFlags
            );
            if (!run)
            {
                return OutOfMemory;
            }

            ASSERT(glyphCount > 0);

            run->Face            = newFace;
            run->GlyphCount      = glyphCount;
            run->Glyphs          = glyphs;
            run->GlyphMap        = glyphMap;
            run->GlyphProperties = glyphProperties;
            run->EngineState     = engineState;

            GetFallbackFontSize(
                face,
                size,
                newFace,
                &run->EmSize,
                &run->BaselineOffset
            );

            status = RunVector.SetSpan(runLineServicesStart, uniformLength, run);
            if (status != Ok)
                return status;

            // Account for amount glyphed

            runStringStart       += uniformLength;
            runLineServicesStart += uniformLength;
            runLength            -= uniformLength;
        }

        // If any characters remain, we loop back for more glyphing and fallback.
    }

    return Ok;
}






/////   CreateLevelChangeRuns
//
//      Adds enough level change runs to the imager to account for the
//      specified delta.


GpStatus FullTextImager::CreateLevelChangeRuns(
    IN  INT                  levelChange,
    IN  INT                  runLineServicesStart,
    IN  INT                  runStringStart,
    IN  const GpFontFamily  *family,
    IN  REAL                 size,
    IN  INT                  style,
    OUT INT                 *lineServicesDelta
)
{
    GpStatus status = Ok;
    if (levelChange == 0)
    {
        *lineServicesDelta = 0;
    }
    else
    {
        for (INT i = 0; i < abs(levelChange); i++)
        {
            lsrun *run = new lsrun(
                levelChange > 0  ?  lsrun::RunLevelUp  :  lsrun::RunLevelDown,
                runStringStart,
                1,
                0,      // Null item
                0       // NULL format
            );

            if (!run)
            {
                *lineServicesDelta = i;
                return OutOfMemory;
            }

            //  LS treats reversal run as normal run. This means it'll call
            //  things like GetRunTextMetrics for reversal and expect something
            //  back from it.

            run->Face   = family->GetFace(style);  // Needed for LS GetRunTextMetrics callback
            run->EmSize = size;

            //  Too bad that Line Services couldn't take multiple reversals

            status = RunVector.SetSpan(runLineServicesStart+i, 1, run);
            if (status != Ok)
                return status;
        }

        *lineServicesDelta = abs(levelChange);
    }

    return status;
}






/////   BuildRunsFromTextItemsAndFormatting
//
//      Merges analysed text items with declarative formatting to generate
//      runs.


GpStatus FullTextImager::BuildRunsFromTextItemsAndFormatting(
    IN  INT  stringStart,
    IN  INT  lineServicesStart,
    IN  INT  lineServicesLimit,
    OUT INT *stringEnd,
    OUT INT *lineServicesEnd
)
{
    GpStatus status;

    SpanRider<GpTextItem>            itemRider(&TextItemVector);
    SpanRider<const GpFontFamily*>   familyRider(&FamilyVector);
    SpanRider<REAL>                  sizeRider(&SizeVector);
    SpanRider<INT>                   styleRider(&StyleVector);
    SpanRider<const GpStringFormat*> formatRider(&FormatVector);


    // Build runs until one includes limitLineServicesPosition

    INT runStringStart       = stringStart;
    INT runLineServicesStart = lineServicesStart;

    BOOL hotkeyEnabled = GetFormatHotkeyPrefix() != HotkeyPrefixNone;


    // Establish bidi level just before first run

    INT bidiLevel;

    if (runStringStart <= 0)
    {
        bidiLevel = GetParagraphEmbeddingLevel();
    }
    else
    {
        itemRider.SetPosition(runStringStart-1);
        bidiLevel = itemRider.GetCurrentElement().Level;
    }


    UINT runLength = 1;

    while (    runLineServicesStart <= lineServicesLimit
           &&  runLength > 0)
    {
        itemRider.SetPosition(runStringStart);
        familyRider.SetPosition(runStringStart);
        sizeRider.SetPosition(runStringStart);
        styleRider.SetPosition(runStringStart);
        formatRider.SetPosition(runStringStart);

        // !!! The following code establishes the length of the run
        //     as the distance to the nearest change.
        //     Note that in v2 this code should not break runs where
        //     underlining starts and stops, it therefore needs to
        //     calculate the style uniform length more carefully.

        runLength = Length - runStringStart;
        runLength = min(runLength, itemRider.GetUniformLength());
        runLength = min(runLength, familyRider.GetUniformLength());
        runLength = min(runLength, sizeRider.GetUniformLength());
        runLength = min(runLength, styleRider.GetUniformLength());
        runLength = min(runLength, formatRider.GetUniformLength());

        if (runLength > 0)
        {
            // Create new run. First insert LS reversals if required.

            if (itemRider.GetCurrentElement().Level != bidiLevel)
            {
                // Check that CR/LF runs are at level zero

                ASSERT(    String[runStringStart] != 0x0d
                       ||      itemRider.GetCurrentElement().Level
                           ==  GetParagraphEmbeddingLevel());


                // Insert level change run(s)

                INT lineServicesDelta;

                CreateLevelChangeRuns(
                    itemRider.GetCurrentElement().Level - bidiLevel,
                    runLineServicesStart,
                    runStringStart,
                    familyRider.GetCurrentElement(),
                    sizeRider.GetCurrentElement(),
                    styleRider.GetCurrentElement(),
                    &lineServicesDelta
                );

                bidiLevel = itemRider.GetCurrentElement().Level;
                runLineServicesStart += lineServicesDelta;
            }


            // Create text run.
            //
            // All glyphing is handled in CreateTextRuns.

            status = CreateTextRuns(
                runLineServicesStart,
                runStringStart,
                runLength,
                itemRider.GetCurrentElement(),
                formatRider.GetCurrentElement() ? formatRider.GetCurrentElement()->GetFormatFlags() : 0,
                familyRider.GetCurrentElement(),
                styleRider.GetCurrentElement(),
                sizeRider.GetCurrentElement()
            );
            if (status != Ok)
            {
                return status;
            }

            runLineServicesStart += runLength;
            runStringStart       += runLength;
        }
    }


    // Add a terminating CR/LF if necessary

    if (runLineServicesStart <= lineServicesLimit)
    {

        //  Paragraph mark must not be inside the reversal block.
        //  This is by design for Line Services.


        if (GetParagraphEmbeddingLevel() != bidiLevel)
        {
            // Insert level change run(s)

            INT lineServicesDelta;

            CreateLevelChangeRuns(
                GetParagraphEmbeddingLevel() - bidiLevel,
                runLineServicesStart,
                runStringStart,
                FamilyVector.GetDefault(),
                SizeVector.GetDefault(),
                StyleVector.GetDefault(),
                &lineServicesDelta
            );

            runLineServicesStart += lineServicesDelta;
        }


        //  Create end of paragraph run

        lsrun *run = new lsrun(
            lsrun::RunEndOfParagraph,
            runStringStart,
            2,      // Length
            0,      // Null item
            0       // NULL format
        );
        if (!run)
        {
            return OutOfMemory;
        }

        // Include nominal face and size for LS GetRunTextMetrics callback

        run->Face   = FamilyVector.GetDefault()->GetFace(StyleVector.GetDefault());
        run->EmSize = SizeVector.GetDefault();

        status = RunVector.SetSpan(runLineServicesStart, 2, run);
        if (status != Ok)
            return status;

        runLineServicesStart += 2;


        #if DBG

            //  Reversals sanity check!

            #if TRACEREVERSAL
                ItemVector.Dump();
                RunVector.Dump();
            #endif


            // Check runs and items match, that nesting returns to zero, and
            // that paragraph marks are at the paragraph embedding level.

            SpanRider<GpTextItem>  itemRider(&TextItemVector);
            SpanRider<PLSRUN>      runRider(&RunVector);

            INT nesting = 0;

            while (!runRider.AtEnd())
            {
                itemRider.SetPosition(runRider.GetCurrentElement()->ImagerStringOffset);

                switch (runRider.GetCurrentElement()->RunType)
                {
                case lsrun::RunLevelUp:
                    ASSERT (  itemRider.GetCurrentElement().Level
                            > itemRider.GetPrecedingElement().Level);
                    nesting++;
                    break;

                case lsrun::RunLevelDown:
                    ASSERT (  itemRider.GetCurrentElement().Level
                            < itemRider.GetPrecedingElement().Level);
                    nesting--;
                    break;

                case lsrun::RunText:
                    ASSERT(runRider.GetCurrentElement()->Item == itemRider.GetCurrentElement());
                    if (String[runRider.GetCurrentElement()->ImagerStringOffset] == 0x0d)
                    {
                        ASSERT(itemRider.GetCurrentElement().Level == GetParagraphEmbeddingLevel());
                    }
                    break;
                }

                runRider++;
            }

            ASSERT (nesting == 0);
        #endif  // DBG
    }


    // Done. Record how far we got.

    *lineServicesEnd = runLineServicesStart;
    *stringEnd       = runStringStart;

    return Ok;
}






/////   BuildRunsUpToAndIncluding
//
//      Algorithm
//
//      1. Itemization. Generates GpTextItems containing
//
//          GpTextItem:
//              Script
//              ScriptClass
//              Flags
//              Bidi level
//
//          Flags include:
//              Glyph transform Sideways (for vertical glyphs)
//              Glyph transform Mirrored (for mirrored chars with no suitable codepoint)
//              Glyph layout vertical    (for vertical text)
//
//          Stages:
//              a. Main itemization FSM (in itemize.cpp)
//              b. If bidi present, or RTL, do UnicodeBidiAnalysis
//              c. Mirrored, Numeric and Vertical item FSM.
//
//      2. Create runs by merging FontFamily, style, format etc. spans with
//         the text items. Reversal runs are inserted at bidi level changes.
//
//      3. During run creation, generate glyphs (GlyphRun)
//
//      4. During glyphing, apply fallback for missing glyphs.
//
//      Font fallback is performed during BuildRunsUpToAndIncluding. When
//      we return, fonts have been allocated to avoid (or minimize) the
//      the display of missing glyphs.


GpStatus FullTextImager::BuildRunsUpToAndIncluding(LSCP limitLineServicesPosition)
{
    GpStatus status;

    if (HighLineServicesPosition > limitLineServicesPosition)
    {
        return Ok;  // We've already covered enough for this call
    }


    if (HighLineServicesPosition == 0)
    {
        // !!! This should be incremental


        /// Itemization by script
        //
        //

        INT flags = 0;
        ItemizationFiniteStateMachine(
            String,
            Length,
            0,
            &TextItemVector,
            &flags
        );


        /// Bidirectional analysis
        //
        //

        BOOL bidi =     GetParagraphEmbeddingLevel() != 0
                    ||  flags & CHAR_FLAG_RTL;

        if (bidi)
        {
            BidirectionalAnalysis();
        }


        /// Digit substitution, mirrored and vertical glyphs
        //
        //  First get default format flags.

        StringDigitSubstitute digitSubstitution;
        LANGID                digitLanguage;
        INT                   formatFlags;

        const GpStringFormat *format = FormatVector.GetDefault();

        ItemScript numericScript = ScriptNone;

        if (format)
        {
            numericScript   = format->GetDigitScript();
            formatFlags     = format->GetFormatFlags();
        }
        else
        {
            formatFlags       = 0;
        }


        if (    bidi
            ||  (    flags & CHAR_FLAG_DIGIT
                 &&  numericScript != ScriptNone)
            ||  formatFlags & StringFormatFlagsDirectionVertical)
        {
            MirroredNumericAndVerticalAnalysis(numericScript);
        }
    }


    /// Generate runs from items and formatting spans
    //
    //  Includes glyphing.

    status = BuildRunsFromTextItemsAndFormatting(
        HighStringPosition,
        HighLineServicesPosition,
        limitLineServicesPosition,
        &HighStringPosition,
        &HighLineServicesPosition
    );
    if (status != Ok)
    {
        return status;
    }

    return Ok;
}






/////   Build all lines
//
//

GpStatus FullTextImager::BuildLines()
{
    GpStatus       status   = Ok;
    StringTrimming trimming = GetFormatTrimming();

    status = BuildAllLines(trimming);

    if (    status == Ok
        &&  trimming == StringTrimmingEllipsisPath)
    {
        BOOL contentChanged;

        status = UpdateContentWithPathEllipsis(&contentChanged);

        if (    status == Ok
            &&  contentChanged)
        {
            status = RebuildLines(trimming);
        }
    }
    return status;
}






GpStatus FullTextImager::RebuildLines(StringTrimming trimming)
{
    //  !! This should be done incrementally !!
    //
    //  This function should be removed when we have incremental line building.
    //  Only now that we have to rebuild the whole thing. (wchao)

    ReleaseVectors();

    //LevelVector.Reset(TRUE);
    TextItemVector.Reset(TRUE);

    Dirty = TRUE;

    HighStringPosition       =
    HighLineServicesPosition = 0;

    return BuildAllLines(trimming);
}



GpStatus FullTextImager::UpdateContentWithPathEllipsis(BOOL *contentChanged)
{
    *contentChanged = FALSE;

    const INT lineLengthLimit = GpRound(LineLengthLimit * WorldToIdeal);

    if (lineLengthLimit > 0)
    {
        EllipsisInfo *ellipsis = GetEllipsisInfo();

        if (!ellipsis)
        {
            return OutOfMemory;
        }

        INT stringStartIndex = 0;

        for (INT i = 0; i < LinesFilled; i++)
        {
            GpStatus status = BuiltLineVector[i].Element->UpdateContentWithPathEllipsis (
                ellipsis,
                lineLengthLimit,
                contentChanged
            );

            if (status != Ok)
            {
                return status;
            }

            stringStartIndex += BuiltLineVector[i].Length;
        }
    }
    return Ok;
}



GpStatus FullTextImager::BuildAllLines(StringTrimming trimming)
{
    GpStatus status = Ok;

    if (!Dirty)
    {
        return Ok;  // content is up-to-date and lines were built.
    }

    // Build lines

    if (LineServicesOwner == NULL)
    {
        LineServicesOwner = ols::GetLineServicesOwner(this);
    }


    INT  textDepth      = 0;    // In ideal units
    REAL textDepthLimit = TextDepthLimit * WorldToIdeal;

    INT  formatFlags = GetFormatFlags();

    REAL lineDepthMinAllowanceFactor = 0.0;     // assume no minimum allowance


    if (textDepthLimit > 0.0)
    {
        if (formatFlags & StringFormatFlagsLineLimit)
        {
            //  Only build full display line

            lineDepthMinAllowanceFactor = 1.0;
        }
        else if (trimming != StringTrimmingNone)
        {
            //  Trimming applied,
            //  build line with at least 1/4 of its height being able to display

            lineDepthMinAllowanceFactor = 0.25;
        }
    }


    //  No side trim if wordwrap

    StringTrimming sideTrimming = (formatFlags & StringFormatFlagsNoWrap) ? trimming : StringTrimmingNone;


    // !!! Build all lines from beginning for now

    INT stringOffset        = 0;    // string start index
    INT lsStringOffset      = 0;    // Line Services start index
    INT lineStringLength    = 0;    // actual line string length
    INT lsLineStringLength  = 0;    // actual line string length in LS index
    INT lineBuilt           = 0;
    INT displayable         = 0;


    //  Initialize bounding box edges (BuildLines may be called more than once)

    LeftOrTopLineEdge     = 0x7fffffff;
    RightOrBottomLineEdge = 0x80000000;


    BuiltLine *previousLine = NULL;
    BuiltLine *line;


    while (stringOffset < Length)
    {
        line = new BuiltLine(
                        LineServicesOwner,
                        stringOffset,
                        lsStringOffset,
                        sideTrimming,
                        previousLine
                   );

        if (!line)
        {
            return OutOfMemory;
        }

        status = line->GetStatus();
        if (status != Ok)
        {
            delete line;
            return status;
        }

        if (    lineDepthMinAllowanceFactor > 0.0
            &&  (   textDepthLimit - TOREAL(textDepth)
                 <  TOREAL(lineDepthMinAllowanceFactor * line->GetLineSpacing())))
        {
            //  Kill line with the displayable part smaller than the mininum allowance

            delete line;
            break;
        }

        textDepth += line->GetLineSpacing();

        displayable += line->GetDisplayableCharacterCount();

        lineStringLength = line->GetUntrimmedCharacterCount (
            stringOffset,
            &lsLineStringLength
        );

        status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, line);
        if (status != Ok)
            return status;
        lineBuilt++;

        LeftOrTopLineEdge = min(LeftOrTopLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                   - line->GetLeftOrTopMargin());

        RightOrBottomLineEdge = max(RightOrBottomLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                           + line->GetLineLength()
                                                           + line->GetRightOrBottomMargin());

        stringOffset    += lineStringLength;
        lsStringOffset  += lsLineStringLength;

        previousLine = line;
    }


    if (   stringOffset < Length
        && !(formatFlags & StringFormatFlagsNoWrap)
        && trimming != StringTrimmingNone)
    {
        //  Trim text bottom end

        INT spanCount = BuiltLineVector.GetSpanCount();

        if (spanCount > 0)
        {
            line = (BuiltLine *)BuiltLineVector[spanCount - 1].Element;
            lineStringLength = BuiltLineVector[spanCount - 1].Length;


            //  backup number of character built during the last line
            displayable -= lineStringLength;


            ASSERT(line && stringOffset > 0);


            if (trimming == StringTrimmingWord)
            {
                //  Optimize for trim word. No need to rebuild the line,
                //  the last line already ended properly.

                if (!IsEOP(String[stringOffset - 1]))
                {
                    //  Move back to the beginning of line

                    stringOffset    -= lineStringLength;
                    lsStringOffset  = line->GetLsStartIndex();

                    line->SetTrimming(trimming);

                    lineStringLength = line->GetUntrimmedCharacterCount(stringOffset);

                    status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, line);
                    if (status != Ok)
                        return status;
                }
            }
            else
            {
                //  Move back to the beginning of line

                stringOffset    -= lineStringLength;
                lsStringOffset  = line->GetLsStartIndex();

                //  Delete previously built last line

                status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, NULL);
                delete line, line = 0;
                if (status != Ok)
                    return status;


                //  Rebuild the line,
                //  ignore all break opportunities if trimming character

                line = new BuiltLine(
                    LineServicesOwner,
                    stringOffset,
                    lsStringOffset,
                    trimming,
                    (BuiltLine *)(spanCount > 1 ? BuiltLineVector[spanCount - 2].Element : NULL),
                    TRUE        // enforce ellipsis
                );

                if (!line)
                {
                    return OutOfMemory;
                }

                status = line->GetStatus();
                if (status != Ok)
                {
                    delete line;
                    return status;
                }

                lineStringLength = line->GetUntrimmedCharacterCount(stringOffset);

                status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, line);
                if (status != Ok)
                    return status;

                LeftOrTopLineEdge = min(LeftOrTopLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                           - line->GetLeftOrTopMargin());

                RightOrBottomLineEdge = max(RightOrBottomLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                                   + line->GetLineLength()
                                                                   + line->GetRightOrBottomMargin());
            }

            //  add up to last line's last visible character
            displayable += line->GetDisplayableCharacterCount();

            stringOffset += lineStringLength;
        }
    }

#if DBG
    INT validLines = BuiltLineVector.GetSpanCount();
    BuiltLine *defaultLine = BuiltLineVector.GetDefault();

    while (   validLines > 0
           && BuiltLineVector[validLines - 1].Element == defaultLine)
    {
        validLines--;
    }

    ASSERT (lineBuilt == validLines);
#endif

    TextDepth        = textDepth / WorldToIdeal;

    // Adjust the bottom margin slightly to make room for hinting
    // as long as we have the left/right margins enabled - Version 2
    // should expose this as an independent value!

    const GpStringFormat *format = FormatVector.GetDefault();

    if (!format || format->GetLeadingMargin() != 0.0f)
    {
        // Adjust the bottom margin slightly to make room for hinting...
        // Note that this will result in the Width of the bounding box
        // changing for Vertical text.
        TextDepth += SizeVector.GetDefault() * DefaultBottomMargin;
    }

    CodepointsFitted = displayable;
    LinesFilled      = lineBuilt;

    return status;
}






/////   Map to Line Services string position
//
//


LSCP FullTextImager::LineServicesStringPosition (
    INT stringIndex    // [IN] String index (offset from 0)
)
{
    ASSERT (stringIndex >= 0 && stringIndex <= Length);

    INT spanCount = TextItemVector.GetSpanCount();

    LSCP    lineServicesIndex = stringIndex;

    UINT    length    = 0;
    BYTE    lastLevel = GetParagraphEmbeddingLevel();

    for (INT i = 0; i < spanCount; i++)
    {
        lineServicesIndex += abs(TextItemVector[i].Element.Level - lastLevel);

        if (length + TextItemVector[i].Length >= (UINT)stringIndex)
        {
            break;
        }

        length    += TextItemVector[i].Length;
        lastLevel  = TextItemVector[i].Element.Level;
    }

    if (i == spanCount)
    {
        lineServicesIndex += abs(GetParagraphEmbeddingLevel() - lastLevel);
    }

    return lineServicesIndex;
}




GpStatus FullTextImager::GetTextRun(
    INT     lineServicesStringOffset,   // [IN] Line Services string offset
    PLSRUN  *textRun                    // [OUT] result text run
)
{
    //  Locate the nearest subsequent text run

    if (!RunRider.SetPosition(lineServicesStringOffset))
    {
        return InvalidParameter;
    }

    while (   RunRider.GetCurrentElement()
           && RunRider.GetCurrentElement()->RunType != lsrun::RunText)
    {
        RunRider++;
    }

    *textRun = RunRider.GetCurrentElement();
    return Ok;
}




LSCP FullTextImager::LineServicesStringPosition (
    const BuiltLine *line,          // [IN] line to query
    INT             stringOffset    // [IN] String offset relative to line start string position
)
{
    if (!line || stringOffset < 0)
    {
        //  Invalid parameter!
        return line->GetLsStartIndex();
    }

    UINT runPosition = line->GetLsStartIndex();
    UINT runLimit    = runPosition + line->GetLsDisplayableCharacterCount();
    INT  runLength   = 0;

    SpanRider<PLSRUN> runRider(&RunVector);
    runRider.SetPosition(runPosition);


    while (runPosition < runLimit)
    {
        if (runRider.GetCurrentElement()->RunType == lsrun::RunText)
        {
            runLength = (INT)runRider.GetUniformLength();
            if (   runLength < 0
                || stringOffset - runLength <= 0)
            {
                break;
            }
            stringOffset -= runLength;
        }

        runPosition += runRider.GetCurrentSpan().Length;
        runRider.SetPosition(runPosition);
    }

    ASSERT(   stringOffset >= 0
           && runRider.GetCurrentElement()
           && runRider.GetCurrentElement()->RunType == lsrun::RunText)

    return runPosition + stringOffset;
}





/////   RenderLine
//
//      Render one visible line. The line and the offset to its top are
//      determined by the caller.


GpStatus FullTextImager::RenderLine (
    const BuiltLine  *builtLine,       // [IN] line to be rendered
    INT               linePointOffset  // [IN] point offset to top of the line
                                       //      (in paragraph flow direction)
)
{
    //  Draw main line. Pass DrawLine the baseline origin asuming glyphs are
    //  unrotated, i.e. glyphs with their base on the baseline. We adjust for
    //  glyphs on their sides while responding to the Line Services callback.


    INT nominalBaseline;
    INT baselineAdjustment;

    builtLine->GetBaselineOffset(
        &nominalBaseline,
        &baselineAdjustment
    );

    POINT origin;
    builtLine->LogicalToXY (
        0,
        linePointOffset + nominalBaseline + baselineAdjustment,
        (INT*)&origin.x,
        (INT*)&origin.y
    );

    CurrentBuiltLine = builtLine;   // Global state required by LS callbacks.

    GpStatus status = builtLine->Draw(&origin);


    if (    status == Ok
        &&  builtLine->IsEllipsis()
        &&  GetEllipsisInfo())
    {
        EllipsisInfo *ellipsis = GetEllipsisInfo();


        //  Draw ellipsis

        builtLine->LogicalToXY (
            builtLine->GetEllipsisOffset(),
            linePointOffset + nominalBaseline + baselineAdjustment,
            (INT*)&origin.x,
            (INT*)&origin.y
        );

        status = DrawGlyphs (
            &ellipsis->Item,
            ellipsis->Face,
            ellipsis->EmSize,
            ellipsis->String,
            0,
            ellipsis->GlyphCount,
            FormatVector.GetDefault(),
            StyleVector.GetDefault(),
            GetFormatFlags(),
            ellipsis->Glyphs,
            ellipsis->GlyphMap,
            ellipsis->GlyphProperties,
            ellipsis->GlyphAdvances,
            ellipsis->GlyphOffsets,
            ellipsis->GlyphCount,
            &origin,
            ellipsis->Width
        );
    }

    CurrentBuiltLine = NULL;

    return status;
}






/////   Render
//
//      Render all visible lines. Calculates the offset of each line to be
//      displayed and passes each builtLine and offset in turn to RenderLine.


GpStatus FullTextImager::Render()
{
    if (LinesFilled <= 0)
    {
        return Ok;  // No lines: that's easy
    }


    // Establish offset from imager origin to top (near) edge of 1st line

    INT textDepth       = GpRound(TextDepth      * WorldToIdeal);
    INT textDepthLimit  = GpRound(TextDepthLimit * WorldToIdeal);


    // Establish limits of visibility


    INT firstVisibleLineOffset;
    INT lastVisibleLineLimit;


    if (textDepthLimit > 0)
    {
        // Display in rectangle

        switch (GetFormatLineAlign())
        {
        case StringAlignmentNear:   firstVisibleLineOffset = 0;                                break;
        case StringAlignmentCenter: firstVisibleLineOffset = (textDepth - textDepthLimit) / 2; break;
        case StringAlignmentFar:    firstVisibleLineOffset = textDepth - textDepthLimit;       break;
        }

        lastVisibleLineLimit = firstVisibleLineOffset + textDepthLimit;
    }
    else
    {
        // Display in infinite paragraph length area aligned to point

        firstVisibleLineOffset = 0;
        lastVisibleLineLimit   = textDepth;
    }

    if (!GetAvailableRanges())
    {
        //  No range detected, adjust baseline according to the realized metric.
        //  (More info about when range is presented, see comments in GetAvailableRanges)
        
        GpStatus status = CalculateDefaultFontGridFitBaselineAdjustment();
        IF_NOT_OK_WARN_AND_RETURN(status);
    }
    
    INT formatFlags = GetFormatFlags();

    SetTextLinesAntialiasMode linesMode(0, 0);
    if (Graphics)
    {
        INT               style     = StyleVector.GetDefault();
        const GpFontFace *face      = FamilyVector.GetDefault()->GetFace(style);
        REAL              emSize    = SizeVector.GetDefault();
        REAL              fontScale = emSize / TOREAL(face->GetDesignEmHeight());

        GpMatrix fontTransform;
        GetFontTransform(
            fontScale,
            formatFlags & StringFormatFlagsDirectionVertical,
            FALSE,  // not sideways
            FALSE,  // not mirrored
            FALSE,  // not path
            fontTransform
        );

        GpFaceRealization faceRealization(
            face,
            style,
            &fontTransform,
            SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
            Graphics->GetTextRenderingHintInternal(),
            FALSE,  // not path
            FALSE,   // don't force compatible width
            FALSE  // not sideways
        );
        GpStatus status = faceRealization.GetStatus();
        IF_NOT_OK_WARN_AND_RETURN(status);

        linesMode.SetAAMode(Graphics, &faceRealization);
    }

    // Loop through lines until no more are visible

    SpanRider<const GpStringFormat*> formatRider(&FormatVector);

    UINT stringPosition  = 0;
    INT  lineIndex       = 0;
    INT  linePointOffset = 0;    // near long edge of line offset from first line

    while (lineIndex < LinesFilled)
    {
        // Get out if invisible and beyond last (partial) line of rectangle

        if (linePointOffset > lastVisibleLineLimit)
        {
            if (    !(formatFlags & StringFormatFlagsNoClip)
                ||  (formatFlags & StringFormatFlagsLineLimit))
            {
                break;
            }
        }

        const BuiltLine *builtLine = BuiltLineVector[lineIndex].Element;
        formatRider.SetPosition(stringPosition);

        // Is this line at least partly visible?

        if (    formatFlags & StringFormatFlagsNoClip
            ||  (   linePointOffset
                 +  builtLine->GetAscent()
                 +  builtLine->GetDescent()) >= firstVisibleLineOffset)
        {
            GpStatus status = RenderLine(
                builtLine,
                linePointOffset
            );
            if (status != Ok)
            {
                return status;
            }
        }

        linePointOffset += builtLine->GetLineSpacing();
        stringPosition  += BuiltLineVector[lineIndex].Length;
        lineIndex++;
    }

    return Ok;
}



//  Establish baseline adjustment required to correct for hinting of the
//  default font. (Fallback and other fonts will align with the default font)

GpStatus FullTextImager::CalculateDefaultFontGridFitBaselineAdjustment()
{
    if (    Graphics
        &&  IsGridFittedTextRealizationMethod(Graphics->GetTextRenderingHintInternal()))
    {
        // When rendering to a Graphics surface, correct the baseline position
        // to allow for any discrepancy between the hinted ascent of the main
        // text imager font and it's scaled nominal ascent.

        INT               style     = StyleVector.GetDefault();
        const GpFontFace *face      = FamilyVector.GetDefault()->GetFace(style);
        REAL              emSize    = SizeVector.GetDefault();
        REAL              fontScale = emSize / TOREAL(face->GetDesignEmHeight());

        GpMatrix fontTransform;
        GetFontTransform(
            fontScale,
            GetFormatFlags() & StringFormatFlagsDirectionVertical,    // *
            FALSE,  // not sideways
            FALSE,  // not mirrored
            FALSE,  // not path
            fontTransform
        );


        // For angles other than 0, 90, 180, 270 there is no hinting.
        // For these angles either both m11 & m22 are zero, or both
        // m12 & m21 are zero.

        REAL m21 = fontTransform.GetM21();
        REAL m22 = fontTransform.GetM22();

        GpFaceRealization faceRealization(
            face,
            style,
            &fontTransform,
            SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
            Graphics->GetTextRenderingHintInternal(),
            FALSE,  // not path
            FALSE,   // don't force compatible width
            FALSE  // not sideways
        );
        GpStatus status = faceRealization.GetStatus();
        IF_NOT_OK_WARN_AND_RETURN(status);

        if (    !(    faceRealization.IsHorizontalTransform()
                  ||  faceRealization.IsVerticalTransform())
            ||  faceRealization.IsPathFont())
        {
            // There is no hinting with transformations that rotate axes, or
            // for path forendering.
            DefaultFontGridFitBaselineAdjustment = 0;
        }
        else
        {
            INT hintedAscentDevice;
            REAL fontAscenderToDevice;

            if (faceRealization.IsHorizontalTransform())
            {
                // 0 or 180 degrees rotation
                fontAscenderToDevice = m22;
                if (m22 > 0.0f)
                {
                    // No rotation, Glyph not flipped along y axis
                    hintedAscentDevice = -faceRealization.GetYMin();
                }
                else
                {
                    // Glyph flipped along y axis
                    hintedAscentDevice = -faceRealization.GetYMax();
                }
            }
            else
            {
                ASSERT(faceRealization.IsVerticalTransform());
                // 90 or 270 degree rotation
                fontAscenderToDevice = m21;
                if (m21 > 0.0f)
                {
                    // No rotation, Glyph not flipped along x axis
                    hintedAscentDevice = -faceRealization.GetXMin();
                }
                else
                {
                    // Glyph flipped along x axis
                    hintedAscentDevice = -faceRealization.GetXMax();
                }
            }

            INT UnhintedAscentDevice = GpRound(face->GetDesignCellAscent() * fontAscenderToDevice);

            DefaultFontGridFitBaselineAdjustment = GpRound(TOREAL(
                   (hintedAscentDevice - UnhintedAscentDevice) / fontAscenderToDevice
                *  fontScale       // font to world
                *  WorldToIdeal));
        }
    }
    return Ok;
}



void FullTextImager::GetFontTransform(
    IN   REAL               fontScale,
    IN   BOOL               vertical,
    IN   BOOL               sideways,
    IN   BOOL               mirror,
    IN   BOOL               forcePath,
    OUT  GpMatrix&          fontTransform
)
{
    ASSERT(Graphics || Path);


    if (Graphics && !forcePath)
    {
        // Start with device scale for Graphics case
        Graphics->GetWorldToDeviceTransform(&fontTransform);
    }
    else
    {
        // Start with identity matrix for Path case
        fontTransform.Reset();
    }


    fontTransform.Scale(fontScale, fontScale);


    if (mirror)
    {
        fontTransform.Scale(-1.0, 1.0);
    }


    // Add approriate rotation for sideways and vertical cases:
    //
    // vertical                rotate(90.0)
    // sideways                rotate(-90.0)
    // vertical and sideways   glyphs remain upright

    if (vertical)
    {
        if (!sideways)
        {
            fontTransform.Rotate(90.0);
        }
    }
    else if (sideways)
    {
        fontTransform.Rotate(-90.0);
    }
}



GpStatus FullTextImager::DrawGlyphs(
    const GpTextItem        *textItem,          // [IN] text item
    const GpFontFace        *fontFace,          // [IN] font face
    REAL                    emSize,             // [IN] requested em size (world unit)
    const WCHAR             *string,            // [IN] (optional) source string (null means imager's string)
    INT                     stringOffset,       // [IN] string offset relative to given string
    UINT                    stringLength,       // [IN] number of characters in the run string
    const GpStringFormat    *format,            // [IN] stringformat
    const INT               style,              // [IN] default font style
    INT                     formatFlags,        // [IN] formatting flags
    const UINT16            *glyphs,            // [IN] glyph index array
    GMAP                    *glyphMap,          // [IN] string to glyphs mapping
    const UINT16            *glyphProperties,   // [IN] glyph properties array
    const INT               *glyphAdvances,     // [IN] glyph advance width array
    const Point             *glyphOffsets,      // [IN] glyph offset array
    UINT                    glyphCount,         // [IN] number of glyphs
    const POINT             *pointOrigin,       // [IN] drawing origin (at baseline)
    INT                     totalWidth,         // [IN] glyphs total width
    lsrun::Adjustment       *displayAdjust      // [OUT] (optional) display adjustment at edges
)
{
    GpStatus status = Ok;

    const BOOL paragraphRtl    = formatFlags & StringFormatFlagsDirectionRightToLeft;
    const BOOL renderRtl       = textItem->Level & 1;
    const BOOL renderVertical  = textItem->Flags & ItemVertical;
    const BOOL glyphsMirrored  = textItem->Flags & ItemMirror;
    const INT  lineLengthLimit = GpRound(LineLengthLimit * WorldToIdeal);

    if (!string)
    {
        string = String;
    }

    if (displayAdjust)
    {
        displayAdjust->Leading =
        displayAdjust->Trailing = 0;
    }

    REAL fontScale = emSize / TOREAL(fontFace->GetDesignEmHeight());

    GpMatrix fontTransform;
    GetFontTransform(
        fontScale,
        renderVertical,
        textItem->Flags & ItemSideways,
        glyphsMirrored,
        FALSE, // don't force path yet
        fontTransform
    );

    if (Graphics)
    {
        GpFaceRealization faceRealization(
            fontFace,
            style,
            &fontTransform,
            SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
            Graphics->GetTextRenderingHintInternal(),
            FALSE, // bPath
            FALSE,  // bCompatibleWidth
            textItem->Flags & ItemSideways
        );
        status = faceRealization.GetStatus();
        IF_NOT_OK_WARN_AND_RETURN(status);

        // if we record to a Meta file and even the font is Path font, we need to record 
        // the call as ExtTextOut not as PolyPolygon.

        if (!faceRealization.IsPathFont() || Graphics->Driver == Globals::MetaDriver)
        {
            /* the rasterizer is able to render the font */

            StringAlignment align;

            if (format)
            {
                align = format->GetPhysicalAlignment();
            }
            else
            {
                align = StringAlignmentNear;
            }


            PointF origin(
                ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
                ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
            );


            // Does this run abut either end of the line?

            INT alignmentOffset = CurrentBuiltLine->GetAlignmentOffset();
            INT lineLength      = CurrentBuiltLine->GetLineLength();

            // Establish top/left offset of run

            INT runLeftOrTopOffset;      // Left edge of formatting rectangle to left edge of run

            if (renderVertical)
            {
                runLeftOrTopOffset = pointOrigin->y;
            }
            else
            {
                runLeftOrTopOffset = pointOrigin->x;

                // Correct out by one errors in the way Line Services reports
                // run pixel positions where there is a conflict of run and
                // paragraph direction.

                if (renderRtl  &&  !paragraphRtl)
                {
                    // Line services is out by one in a direction conflict
                    runLeftOrTopOffset++;
                }
                else if (paragraphRtl  &&  !renderRtl)
                {
                    // Line services is out by one in a direction conflict
                    runLeftOrTopOffset--;
                }


                // In an RTL run Line Services reports the origin as the eight end.

                if (renderRtl)
                {
                    runLeftOrTopOffset -= totalWidth;
                }
            }


            // Derive leading and/or trailing margin available for this run

            INT  runLeadingMargin  = 0;
            INT  runTrailingMargin = 0;
            BOOL runLeadingEdge    = FALSE;
            BOOL runTrailingEdge   = FALSE;

            const INT runRightOrBottomOffset  =   runLeftOrTopOffset + totalWidth;
            const INT lineLeftOrTopOffset     =   CurrentBuiltLine->GetLeftOrTopGlyphEdge();
            const INT lineRightOrBottomOffset =   lineLeftOrTopOffset
                                                + CurrentBuiltLine->GetLineLength();

            if (renderVertical  ||  !renderRtl)
            {
                // Leading edge at the top or left.
                if (runLeftOrTopOffset <= lineLeftOrTopOffset)
                {
                    runLeadingEdge   = TRUE;
                    runLeadingMargin = CurrentBuiltLine->GetLeftOrTopMargin();
                }

                if (runRightOrBottomOffset >= lineRightOrBottomOffset)
                {
                    runTrailingEdge   = TRUE;
                    runTrailingMargin = CurrentBuiltLine->GetRightOrBottomMargin();
                }
            }
            else
            {
                // Leading edge is at the right.
                if (runRightOrBottomOffset >= lineRightOrBottomOffset)
                {
                    runLeadingEdge   = TRUE;
                    runLeadingMargin = CurrentBuiltLine->GetRightOrBottomMargin();
                }

                if (runLeftOrTopOffset <= lineLeftOrTopOffset)
                {
                    runTrailingEdge   = TRUE;
                    runTrailingMargin = CurrentBuiltLine->GetLeftOrTopMargin();
                }
            }


            // Convert advance vector and glyph offsets to glyph positions
            GlyphImager glyphImager;
            GpMatrix worldToDevice;
            Graphics->GetWorldToDeviceTransform(&worldToDevice);

            status = glyphImager.Initialize(
                &faceRealization,
                &worldToDevice,
                WorldToIdeal,
                emSize,
                glyphCount,
                glyphs,
                textItem,
                format,
                runLeadingMargin,
                runTrailingMargin,
                runLeadingEdge,
                runTrailingEdge,
                string,
                stringOffset,
                stringLength,
                glyphProperties,
                glyphAdvances,
                glyphOffsets,
                glyphMap,
                (format && GetAvailableRanges(format)) ? &RangeVector : NULL,
                renderRtl
            );
            IF_NOT_OK_WARN_AND_RETURN(status);


            const INT   *adjustedGlyphAdvances;
            INT         originAdjust;
            INT         trailingAdjust;


            if (RecordDisplayPlacementsOnly)
            {
                if (glyphImager.IsAdjusted())
                {
                    status = glyphImager.GetAdjustedGlyphAdvances(
                        &PointF(
                            ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
                            ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
                        ),
                        &adjustedGlyphAdvances,
                        &originAdjust,
                        &trailingAdjust
                    );
                    IF_NOT_OK_WARN_AND_RETURN(status);

                    status = CurrentBuiltLine->RecordDisplayPlacements(
                        textItem,
                        stringOffset,
                        stringLength,
                        glyphMap,
                        adjustedGlyphAdvances,
                        glyphCount,
                        originAdjust
                    );
                    IF_NOT_OK_WARN_AND_RETURN(status);

                    if (displayAdjust)
                    {
                        displayAdjust->Leading = runLeadingEdge ? originAdjust : 0;
                        displayAdjust->Trailing = runTrailingEdge ? trailingAdjust : 0;
                    }
                }
            }
            else
            {
                PointF cellOrigin;
                PointF baseline(
                    ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
                    ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
                );

                status = glyphImager.DrawGlyphs(
                    baseline,
                    &BrushVector,
                    Graphics,
                    &cellOrigin,
                    &adjustedGlyphAdvances
                );
                IF_NOT_OK_WARN_AND_RETURN(status);


                CurrentBuiltLine->SetDisplayBaseline(
                    &baseline,
                    &cellOrigin
                );


                BOOL drawHotkey = (   GetFormatHotkeyPrefix() == HotkeyPrefixShow
                                   && HotkeyPrefix.GetCount() > 0);

                if (   drawHotkey
                    || (style & (FontStyleUnderline | FontStyleStrikeout)))
                {
                    //  Need edge adjustment for underline/strikethrough

                    status = glyphImager.GetAdjustedGlyphAdvances(
                        NULL,   // dont snap full pixel for underline position
                        &adjustedGlyphAdvances,
                        &originAdjust,
                        &trailingAdjust
                    );

                    if (drawHotkey)
                    {
                        status = DrawHotkeyUnderline(
                            textItem,
                            fontFace,
                            &cellOrigin,
                            emSize,
                            stringOffset,
                            stringLength,
                            glyphCount,
                            glyphMap,
                            adjustedGlyphAdvances,
                            runTrailingEdge ? trailingAdjust : 0
                        );
                        IF_NOT_OK_WARN_AND_RETURN(status);
                    }

                    if (displayAdjust)
                    {
                        displayAdjust->Leading = runLeadingEdge ? originAdjust : 0;
                        displayAdjust->Trailing = runTrailingEdge ? trailingAdjust : 0;
                    }
                }
            }

            return status;
        }

        if (RecordDisplayPlacementsOnly)
        {
            //  This is a graphic output with path simulation,
            //  we're not interested in caching the glyph placement
            //  in this case. The font is big and we're safe to
            //  go with nominal advance width.

            return Ok;
        }

        GetFontTransform(
            fontScale,
            renderVertical,
            textItem->Flags & ItemSideways,
            glyphsMirrored,
            TRUE, // we want path
            fontTransform
        );
    }

    // AddPathGlyphs or we are falling back here because the font size is too big for the rasterizer

    GpPath * path;
    AutoPointer<GpLock> lockGraphics;
    AutoPointer<GpPath> localPath;

    if (Path == NULL)
    {
        localPath = new GpPath(FillModeWinding);
        path = localPath.Get();
        if (path == NULL)
            return OutOfMemory;

        lockGraphics = new GpLock(Graphics->GetObjectLock());
        if (lockGraphics == NULL)
            return OutOfMemory;
    }
    else
    {
        path = Path;
    }

    // !!! Need to loop through brushes individually


    // Build a face realization and prepare to adjust glyph placement
    GpMatrix identity;


    // For complex script fonts that join, tracking will break apart the
    // glyph unless we stretch them here. Stretch glyphs along their
    // baseline by the tracking factor.

    REAL tracking = 1.0;
    if (format)
    {
        tracking = format->GetTracking();
        if (tracking != 1.0f)
        {
            identity.Scale(tracking, 1.0);
        }
    }

    GpFaceRealization faceRealization(
        fontFace,
        style,
        &identity,
        SizeF(150.0, 150.0),    // Arbitrary - we won't be hinting
        TextRenderingHintSingleBitPerPixel, // claudebe, do we want to allow for hinted or unhinted path ? // graphics->GetTextRenderingHint(),
        TRUE, /* bPath */
        FALSE, /* bCompatibleWidth */
        textItem->Flags & ItemSideways
    );
    status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);


    // Add glyphs to path

    // Establish factor from world coordinates to ideal (line services units)
    // taking vertical and right to left progress into account.

    REAL worldToIdealBaseline = WorldToIdeal;
    REAL worldToIdealAscender = WorldToIdeal;

    if (renderRtl)
    {
        // Glyphs advance to the left
        worldToIdealBaseline = -WorldToIdeal;
    }

    if (!renderVertical)
    {
        // Ascender offsets are downward
        worldToIdealAscender = -WorldToIdeal;
    }

    PointF glyphOrigin(
        ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
        ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
    );

    PointF origin = glyphOrigin;

    for (INT i = 0; i < (INT)glyphCount; ++i)
    {
        // Set marker at start of each logical character = cell = cluster

       if ((Path != NULL) && (((SCRIPT_VISATTR*)glyphProperties)[i].fClusterStart))
        {
            Path->SetMarker();
        }


        // Establish glyph offset, if any.

        PointF glyphOffset(0.0, 0.0);

        if (    glyphOffsets[i].X != 0
            ||  glyphOffsets[i].Y != 0)
        {
            // Apply combining character offset

            if (renderVertical)
            {
                glyphOffset.Y = glyphOffsets[i].X / worldToIdealBaseline;
                glyphOffset.X = glyphOffsets[i].Y / worldToIdealAscender;
            }
            else
            {
                // offset Y grows negative in the direction of paragraph flow

                glyphOffset.X = glyphOffsets[i].X / worldToIdealBaseline;
                glyphOffset.Y = glyphOffsets[i].Y / worldToIdealAscender;
            }
        }


        // Add the path for the glyph itself


        GpGlyphPath *glyphPath = NULL;
        PointF       sidewaysOrigin;

        status = faceRealization.GetGlyphPath(
            *(glyphs+i),
            &glyphPath,
            &sidewaysOrigin
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        if (renderRtl)
        {
            // Update reverse text path positon

            if (renderVertical)
            {
                //  glyph origin starts at the left edge
                glyphOrigin.Y += glyphAdvances[i] / worldToIdealBaseline;
            }
            else
            {
                //  glyph origin starts at the top edge
                glyphOrigin.X += glyphAdvances[i] / worldToIdealBaseline;
            }
        }

        if (textItem->Flags & ItemSideways)
        {
            fontTransform.VectorTransform(&sidewaysOrigin);
            glyphOffset = glyphOffset - sidewaysOrigin;
        }

        if (glyphPath != NULL)
        {
            status = path->AddGlyphPath(
                glyphPath,
                glyphOrigin.X + glyphOffset.X,
                glyphOrigin.Y + glyphOffset.Y,
                &fontTransform
            );
            IF_NOT_OK_WARN_AND_RETURN(status);
        }

        // Update forward path position

        if (!renderRtl)
        {
            // Update forward text path positon
            if (renderVertical)
            {
                glyphOrigin.Y += glyphAdvances[i] / worldToIdealBaseline;
            }
            else
            {
                glyphOrigin.X += glyphAdvances[i] / worldToIdealBaseline;
            }
        }
    }

    if (   GetFormatHotkeyPrefix() == HotkeyPrefixShow
        && HotkeyPrefix.GetCount() > 0)
    {
        status = DrawHotkeyUnderline(
            textItem,
            fontFace,
            &origin,
            emSize,
            stringOffset,
            stringLength,
            glyphCount,
            glyphMap,
            glyphAdvances,
            0
        );

        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    if (Path == NULL)
    {
        // !!! Need to loop through brushes individually

        status = Graphics->FillPath(BrushVector.GetDefault(), path);
        IF_NOT_OK_WARN_AND_RETURN(status);
    }
    else
    {
        // Force marker following last glyph
        Path->SetMarker();
    }
    return status;
}





/////   Hotkey underline
//
//      Draw underline at each hotkey position according to its
//      current brush within the run being displayed.
//
//      Underline is drawn for the whole cluster even when the hotkey
//      prefix is not exactly at the cluster start position.
//

GpStatus FullTextImager::DrawHotkeyUnderline(
    const GpTextItem        *textItem,          // [IN] text item
    const GpFontFace        *fontFace,          // [IN] font face
    const PointF            *origin,            // [IN] origin at leading edge & baseline (in world unit)
    REAL                    emSize,             // [IN] em size (in world unit)
    UINT                    stringOffset,       // [IN] string offset
    UINT                    stringLength,       // [IN] string length
    UINT                    glyphCount,         // [IN] glyph count
    const GMAP              *glyphMap,          // [IN] glyph map
    const INT               *glyphAdvances,     // [IN] glyph advance width (ideal unit)
    INT                     trailingAdjust      // [IN] adjust for last glyph's advance width
)
{
    const REAL fontToWorld = emSize / TOREAL(fontFace->GetDesignEmHeight());
    const REAL penPos   = fontFace->GetDesignUnderscorePosition() * fontToWorld; // negative down from the baseline
    REAL penWidth = fontFace->GetDesignUnderscoreSize() * fontToWorld;
    if (Graphics)
        penWidth = Graphics->GetDevicePenWidth(penWidth);

    GpStatus status = Ok;

    for (INT hk = 0; status == Ok && hk < HotkeyPrefix.GetCount(); hk++)
    {
        UINT hkOffset = HotkeyPrefix[hk] + 1;   // character next to the prefix

        if (   hkOffset >= stringOffset
            && hkOffset <  stringOffset + stringLength)
        {
            //  determine the length of hotkey underline

            UINT hkLength = hkOffset - stringOffset;
            UINT igl = glyphMap[hkLength];  // first glyph being underlined

            hkLength++;

            while (hkLength < stringLength && glyphMap[hkLength] == igl)
            {
                hkLength++;
            }

            UINT iglLimit = hkLength < stringLength ? glyphMap[hkLength] : glyphCount;


            INT start  = 0; // ideal offset to start of underline
            INT length = 0; // ideal length of underline

            for (UINT i = 0; i < igl; i++)
            {
                start += glyphAdvances[i];
            }

            for (UINT i = igl; i < iglLimit ; i++)
            {
                length += glyphAdvances[i];
            }

            if (iglLimit == glyphCount)
            {
                //  Adjust for run's trailing spaces

                length += trailingAdjust;
            }


            //  draw it!

            if (Graphics)
            {
                PointF lineStart;
                PointF lineEnd;


                //  Graphics rendering

                if (textItem->Flags & ItemVertical)
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in vertical line

                        lineStart.X = origin->X + penPos;
                        lineStart.Y = origin->Y - (start + length) / WorldToIdeal;
                        lineEnd.X   = origin->X + penPos;
                        lineEnd.Y   = origin->Y - start / WorldToIdeal;
                    }
                    else
                    {
                        //  LTR run in vertical line

                        lineStart.X = origin->X + penPos;
                        lineStart.Y = origin->Y + start / WorldToIdeal;
                        lineEnd.X   = origin->X + penPos;
                        lineEnd.Y   = origin->Y + (start + length) / WorldToIdeal;
                    }
                }
                else
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in horizontal line

                        lineStart.X = origin->X - (start + length) / WorldToIdeal;
                        lineStart.Y = origin->Y - penPos;
                        lineEnd.X   = origin->X - start / WorldToIdeal;
                        lineEnd.Y   = origin->Y - penPos;
                    }
                    else
                    {
                        //  LTR run in horizontal line

                        lineStart.X = origin->X + start / WorldToIdeal;
                        lineStart.Y = origin->Y - penPos;
                        lineEnd.X   = origin->X + (start + length) / WorldToIdeal;
                        lineEnd.Y   = origin->Y - penPos;
                    }
                }

                SpanRider<const GpBrush *> brushRider(&BrushVector);
                brushRider.SetPosition(hkOffset);

                status = Graphics->DrawLine(
                    &GpPen(brushRider.GetCurrentElement(), penWidth, UnitPixel),
                    lineStart.X,
                    lineStart.Y,
                    lineEnd.X,
                    lineEnd.Y
                );
            }
            else
            {
                //  Path rendering

                ASSERT(Path);

                RectF lineRect;

                if (textItem->Flags & ItemVertical)
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in vertical line

                        lineRect.X      = origin->X + penPos - penWidth / 2;
                        lineRect.Y      = origin->Y - (start + length) / WorldToIdeal;
                        lineRect.Width  = penWidth;
                        lineRect.Height = length / WorldToIdeal;
                    }
                    else
                    {
                        //  LTR run in vertical line

                        lineRect.X      = origin->X + penPos - penWidth / 2;
                        lineRect.Y      = origin->Y + start / WorldToIdeal;
                        lineRect.Width  = penWidth;
                        lineRect.Height = length / WorldToIdeal;
                    }
                }
                else
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in horizontal line

                        lineRect.X      = origin->X - (start + length) / WorldToIdeal;
                        lineRect.Y      = origin->Y - penPos - penWidth / 2;
                        lineRect.Width  = length / WorldToIdeal;
                        lineRect.Height = penWidth;
                    }
                    else
                    {
                        //  LTR run in horizontal line

                        lineRect.X      = origin->X + start / WorldToIdeal;
                        lineRect.Y      = origin->Y - penPos - penWidth / 2;
                        lineRect.Width  = length / WorldToIdeal;
                        lineRect.Height = penWidth;
                    }
                }

                status = Path->AddRect(
                    RectF(
                        lineRect.X,
                        lineRect.Y,
                        lineRect.Width,
                        lineRect.Height
                    )
                );
            }
        }
    }
    return status;
}





GpStatus FullTextImager::Draw(
    GpGraphics   *graphics,
    const PointF *origin
)
{
    GpStatus status;

    status = BuildLines();

    if (status != Ok)
    {
        return status;
    }

    Graphics = graphics;

    memcpy(&ImagerOrigin, origin, sizeof(ImagerOrigin));

    GpRegion *previousClip  = NULL;

    BOOL applyClip =
            !(GetFormatFlags() & StringFormatFlagsNoClip)
        &&  Width
        &&  Height;

    if (applyClip)
    {
        //  Preserve existing clipping and combine it with the new one if any
        if (!graphics->IsClipEmpty())
        {
            previousClip = graphics->GetClip();
        }

        RectF clippingRect(origin->X, origin->Y, Width, Height);
        graphics->SetClip(clippingRect, CombineModeIntersect);
    }

    status = Render();

    if (applyClip)
    {
        //  Restore clipping state if any
        if (previousClip)
        {
            graphics->SetClip(previousClip, CombineModeReplace);
            delete previousClip;
        }
        else
        {
            graphics->ResetClip();
        }
    }

    if (status != Ok)
    {
        return status;
    }

    Graphics = NULL;
    memset(&ImagerOrigin, 0, sizeof(ImagerOrigin));

    return Ok;
}




GpStatus FullTextImager::AddToPath(
    GpPath       *path,
    const PointF *origin
)
{
    GpStatus status;

    status = BuildLines();

    if (status != Ok)
    {
        return status;
    }

    Path = path;
    memcpy(&ImagerOrigin, origin, sizeof(ImagerOrigin));

    status = Render();

    if (status != Ok)
    {
        return status;
    }

    Path = NULL;
    memset(&ImagerOrigin, 0, sizeof(ImagerOrigin));

    return Ok;
}






GpStatus FullTextImager::Measure(
    GpGraphics *graphics,
    REAL       *nearGlyphEdge,
    REAL       *farGlyphEdge,
    REAL       *textDepth,
    INT        *codepointsFitted,
    INT        *linesFilled
)
{
    GpStatus status;

    status = BuildLines();

    if (status != Ok)
    {
        return status;
    }


    *nearGlyphEdge = LeftOrTopLineEdge     / WorldToIdeal;
    *farGlyphEdge  = RightOrBottomLineEdge / WorldToIdeal;

    *textDepth = TextDepth;

    if (codepointsFitted) *codepointsFitted = CodepointsFitted;
    if (linesFilled)      *linesFilled      = LinesFilled;

    return Ok;
}


GpStatus FullTextImager::MeasureRangeRegion(
    INT           firstCharacterIndex,
    INT           characterCount,
    const PointF *origin,
    GpRegion     *region
)
{
    if (!region || !region->IsValid())
    {
        return InvalidParameter;
    }

    region->SetEmpty();


    if (!characterCount)
    {
        //  return empty region
        return Ok;
    }
    else if (characterCount < 0)
    {
        firstCharacterIndex += characterCount;
        characterCount = -characterCount;
    }

    if (   firstCharacterIndex < 0
        || firstCharacterIndex > Length
        || firstCharacterIndex + characterCount > Length)
    {
        return InvalidParameter;
    }


    if (LinesFilled <= 0)
    {
        return Ok;
    }


    GpMemcpy(&ImagerOrigin, origin, sizeof(PointF));


    INT lastCharacterIndex  = firstCharacterIndex + characterCount - 1;
    INT lineFirstIndex      = 0; // line start char index
    INT linePointOffset     = 0; // line start position

    ASSERT (   firstCharacterIndex >= 0
            && firstCharacterIndex <= lastCharacterIndex);


    GpStatus status = Ok;
    

    for (INT i = 0; i < LinesFilled; i++)
    {
        const BuiltLine *line = BuiltLineVector[i].Element;
        INT lineLastIndex = lineFirstIndex + BuiltLineVector[i].Length - 1;


        if (lineLastIndex >= firstCharacterIndex)
        {
            if (lineFirstIndex > lastCharacterIndex)
            {
                //  We're done.
                break;
            }
            
            INT nominalBaseline;
            INT baselineAdjustment; // adjustment to nominal baseline
    
            line->GetBaselineOffset(
                &nominalBaseline,
                &baselineAdjustment
            );

            //  The line is either at the first, the last or the middle of
            //  the selection.

            INT selectionFirstIndex = max(firstCharacterIndex, lineFirstIndex);
            INT selectionLastIndex  = min(lastCharacterIndex, lineLastIndex);

            status = line->GetSelectionTrailRegion(
                linePointOffset + baselineAdjustment,
                selectionFirstIndex - lineFirstIndex,
                selectionLastIndex - selectionFirstIndex + 1,
                region
            );

            if (status != Ok)
            {
                return GenericError;
            }
        }

        //  Advance to the next line

        lineFirstIndex  += BuiltLineVector[i].Length;
        linePointOffset += line->GetLineSpacing();
    }

    return status;
}




GpStatus FullTextImager::MeasureRanges (
    GpGraphics      *graphics,
    const PointF    *origin,
    GpRegion        **regions
)
{
    if (!FormatVector.GetDefault())
    {
        return InvalidParameter;
    }

    GpStatus status = BuildLines();

    if (status != Ok)
    {
        return status;
    }

    Graphics = graphics;

    if (   Graphics
        && !GetMetaFileRecordingFlag())
    {
        //  If the range is being measured against real device, not metafile,
        //  we need to take the baseline adjustment into account. On the other
        //  hand if this is done for a metafile, it needs to be in nominal distance
        //  both height and width (nominal width is done in lower level)
        
        status = CalculateDefaultFontGridFitBaselineAdjustment();
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    const GpStringFormat *format = FormatVector.GetDefault();

    CharacterRange *ranges;
    INT rangeCount = format->GetMeasurableCharacterRanges(&ranges);


    RectF clipRect(origin->X, origin->Y, Width, Height);
    BOOL clipped = !(format->GetFormatFlags() & StringFormatFlagsNoClip);


    for (INT i = 0; i < rangeCount; i++)
    {
        GpLock lockRegion(regions[i]->GetObjectLock());

        if (!lockRegion.IsValid())
        {
            return ObjectBusy;
        }

        status = MeasureRangeRegion (
            ranges[i].First,
            ranges[i].Length,
            origin,
            regions[i]
        );

        if (status != Ok)
        {
            return status;
        }

        if (clipped)
        {
            // we have a clipping so we need to make sure we didn't get out
            // of the layout box

            regions[i]->Combine(&clipRect, CombineModeIntersect);
        }
    }
    return status;
}




INT FullTextImager::GetAvailableRanges(const GpStringFormat *format)
{
    if (!format)
    {
        format = FormatVector.GetDefault();

        if (!format)
        {
            return 0;
        }
    }

    if (   !InvalidRanges
        && !RangeVector.GetSpanCount()
        && (   GetMetaFileRecordingFlag()
            || format->GetFormatFlags() & StringFormatFlagsPrivateFormatPersisted))
    {

        //  Construct range vector from string format either during
        //  recording for downlevel playback or during playback of
        //  DrawString EMF+ record. Otherwise, dont process ranges at
        //  all (even if it exists in string format).


        CharacterRange *ranges = NULL;
        INT rangeCount = format->GetMeasurableCharacterRanges(&ranges);

        for (INT i = 0; i < rangeCount; i++)
        {
            INT first   = ranges[i].First;
            INT length  = ranges[i].Length;

            if (length < 0)
            {
                first += length;
                length = -length;
            }

            if (   first < 0
                || first > Length
                || first + length > Length)
            {
                //  Invalid range being set by client,
                //  ignore all ranges being collected so far

                RangeVector.Reset();
                break;
            }

            RangeVector.OrSpan(
                first,
                length,
                (UINT32)(1 << i)
            );
        }

        #if DBG_RANGEDUMP
        RangeVector.Dump();
        #endif

        if (!RangeVector.GetSpanCount())
        {
            //  No valid range being collected or invalid range found,
            //  dont bother process any of them any more.

            InvalidRanges = TRUE;
        }
    }
    return RangeVector.GetSpanCount();
}




GpStatus FullTextImager::GetTabStops (
    INT     stringOffset,
    INT     *countTabStops,
    LSTBD   **tabStops,
    INT     *incrementalTab
)
{
    SpanRider<const GpStringFormat *>   formatRider(&FormatVector);
    formatRider.SetPosition(stringOffset);

    const GpStringFormat *format = formatRider.GetCurrentElement();

    *incrementalTab = DefaultIncrementalTab;    // incremental tab as imager's default
    *tabStops       = NULL;
    *countTabStops  = 0;


    if (format)
    {
        REAL    firstTabOffset;
        REAL    *tabAdvance;

        INT     count = format->GetTabStops(
                            &firstTabOffset,
                            &tabAdvance
                        );

        if (tabAdvance && count > 0)
        {
            REAL    advance = firstTabOffset;
            LSTBD   tbd;

            GpMemset (&tbd, 0, sizeof(LSTBD));
            tbd.lskt = lsktLeft;

            TabArray.Reset();

            for (INT i = 0; i < count; i++)
            {
                advance += tabAdvance[i];
                tbd.ua = GpRoundSat(advance * WorldToIdeal);

                TabArray.Add (tbd);
            }

            *tabStops       = TabArray.GetDataBuffer();
            *countTabStops  = i;

            // no incremental tab as the last user tabstop
            *incrementalTab = GpRound(tabAdvance[count - 1] * WorldToIdeal);
        }
        else
        {
            // incremental tab as user-defined first tab offset
            *incrementalTab = GpRound(firstTabOffset * WorldToIdeal);
        }
    }
    return Ok;
}





/////   Thai Breaking function
//
//      Because of the lack of dictionary resource required to perform
//      Thai word breaking in static lib, we need to ask Uniscribe to
//      perform the task instead.
//
//      The global pointer holding the breaking function can be changed
//      once for process lifetime. It needs not to be serialized as all
//      text call is protected by the global text critical section.
//      !! Revisit this code if assumption changes !!
//
//      wchao (11-09-2000)



extern "C"
{

typedef HRESULT (WINAPI FN_SCRIPTBREAK) (
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
);


typedef HRESULT (WINAPI FN_SCRIPTITEMIZE) (
    const WCHAR             *string,        // [IN] input string
    INT                     length,         // [IN] string length
    INT                     maxItems,       // [IN] maximum possible items
    const SCRIPT_CONTROL    *scriptControl, // [IN] control structure
    const SCRIPT_STATE      *scriptState,   // [IN] starting state
    SCRIPT_ITEM             *items,         // [OUT] items
    INT                     *itemCount      // [OUT] number of item produced
);



FN_SCRIPTBREAK  *GdipThaiBreakingFunction = GdipThaiBreakingFunctionInitializer;
FN_SCRIPTBREAK  *GdipScriptBreak  = NULL;   // Uniscribe ScriptBreak API
INT             ScriptThaiUsp = 0;          // Uniscribe has a different script ID for Thai



#define MAX_MSO_PATH    256     // make sure it's sufficient

const WCHAR UspDllName[] = L"usp10.dll";
const CHAR UspDllNameA[] =  "usp10.dll";

#if DBG
//#define DBG_DLL 1
#ifdef DBG_DLL
const WCHAR MsoDllName[] = L"c:\\program files\\common files\\microsoft shared debug\\office10\\msod.dll";
const CHAR MsoDllNameA[] =  "c:\\program files\\common files\\microsoft shared debug\\office10\\msod.dll";
#else
const WCHAR MsoDllName[] = L"msod.dll";
const CHAR MsoDllNameA[] =  "msod.dll";
#endif
#else
const WCHAR MsoDllName[] = L"mso.dll";
const CHAR MsoDllNameA[] =  "mso.dll";
#endif



HRESULT WINAPI GdipThaiBreakingFunctionInGdiplus(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
)
{
    ASSERT (analysis->eScript == ScriptThai);

    return ThaiBreak(
        string,
        length,
        analysis,
        breaks
    );
}


HRESULT WINAPI GdipThaiBreakingFunctionInUniscribe(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
)
{
    ASSERT(ScriptThaiUsp != 0);

    ScriptAnalysis uspAnalysis(&GpTextItem((ItemScript)ScriptThaiUsp, 0), 0, 0);

    return GdipScriptBreak(
        string,
        length,
        &uspAnalysis.Sa,
        breaks
    );
}



HRESULT WINAPI GdipThaiBreakingFunctionInitializer(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
)
{
    HRSRC mainResource = FindResourceA((HMODULE)DllInstance, "SIAMMAIN", "SIAMDB");

    if (mainResource)
    {
        //  Main dictionary resource available,
        //  we're capable of doing it ourself.

        GdipThaiBreakingFunction = GdipThaiBreakingFunctionInGdiplus;
    }
    else
    {
        //  No resource available, search for Uniscribe in the process.
        //  Load it up if necessary.

        GdipThaiBreakingFunction = SimpleBreak;     // assume default

        HMODULE moduleUsp = NULL;

        if (Globals::IsNt)
        {

            moduleUsp = LoadLibrary(UspDllName);

            if (!moduleUsp)
            {
                //  Fail to load the system version of Uniscribe,
                //  try loading the private version from MSO directory.

#ifdef DBG_DLL
                HMODULE moduleMso = LoadLibrary(MsoDllName);
#else
                HMODULE moduleMso = GetModuleHandle(MsoDllName);
#endif

                if (moduleMso)
                {
                    AutoArray<WCHAR> pathString(new WCHAR [MAX_MSO_PATH]);

                    if (pathString)
                    {
                        WCHAR *fullPathString = pathString.Get();

                        UINT pathLength = GetModuleFileName(
                            moduleMso,
                            fullPathString,
                            MAX_MSO_PATH
                        );

                        if (pathLength)
                        {
                            while (pathLength > 0 && fullPathString[pathLength - 1] != '\\')
                            {
                                pathLength--;
                            }

                            INT uspDllNameLength = 0;

                            while (UspDllName[uspDllNameLength])
                            {
                                uspDllNameLength++;
                            }

                            if (pathLength + uspDllNameLength < MAX_MSO_PATH)
                            {
                                GpMemcpy(
                                    &fullPathString[pathLength],
                                    UspDllName,
                                    sizeof(WCHAR) * uspDllNameLength
                                );

                                fullPathString[pathLength + uspDllNameLength] = 0;

                                moduleUsp = LoadLibrary(fullPathString);
                            }
                        }
                    }
#ifdef DBG_DLL
                    FreeLibrary(moduleMso);
#endif
                }
            }
        }
        else
        {
            HMODULE moduleUsp = LoadLibraryA(UspDllNameA);

            if (!moduleUsp)
            {
                //  Fail to load the system version of Uniscribe,
                //  try loading the private version from MSO directory.

#ifdef DBG_DLL
                HMODULE moduleMso = LoadLibraryA(MsoDllNameA);
#else
                HMODULE moduleMso = GetModuleHandleA(MsoDllNameA);
#endif
                if (moduleMso)
                {
                    AutoArray<CHAR> pathString(new CHAR [MAX_MSO_PATH]);

                    if (pathString)
                    {
                        CHAR *fullPathString = pathString.Get();

                        UINT pathLength = GetModuleFileNameA(
                            moduleMso,
                            fullPathString,
                            MAX_MSO_PATH
                        );

                        if (pathLength)
                        {
                            while (pathLength > 0 && fullPathString[pathLength - 1] != '\\')
                            {
                                pathLength--;
                            }

                            INT uspDllNameLength = 0;

                            while (UspDllNameA[uspDllNameLength])
                            {
                                uspDllNameLength++;
                            }

                            if (pathLength + uspDllNameLength < MAX_MSO_PATH)
                            {
                                GpMemcpy(
                                    &fullPathString[pathLength],
                                    UspDllNameA,
                                    sizeof(CHAR) * uspDllNameLength
                                );

                                fullPathString[pathLength + uspDllNameLength] = 0;

                                moduleUsp = LoadLibraryA(fullPathString);
                            }
                        }
                    }
#ifdef DBG_DLL
                    FreeLibrary(moduleMso);
#endif
                }
            }
        }
        if (moduleUsp)
        {
            //  Locate Uniscribe ScriptBreak API

            GdipScriptBreak = (FN_SCRIPTBREAK *)GetProcAddress(
                moduleUsp,
                "ScriptBreak"
            );

            FN_SCRIPTITEMIZE *scriptItemize = (FN_SCRIPTITEMIZE *)GetProcAddress(
                moduleUsp,
                "ScriptItemize"
            );

            HRESULT hr = E_FAIL;

            if (   scriptItemize
                && GdipScriptBreak)
            {
                //  Figure out the proper Thai script ID to be used

                SCRIPT_ITEM items[2];
                INT itemCount = 0;

                hr = scriptItemize(
                    L"\x0e01",  // first Thai consonant
                    1,          // string length
                    2,          // string length + sentinel
                    NULL,       // script control
                    NULL,       // script state
                    items,
                    &itemCount
                );

                if (SUCCEEDED(hr))
                {
                    ScriptThaiUsp = items[0].a.eScript;

                    GdipThaiBreakingFunction = GdipThaiBreakingFunctionInUniscribe;
                    Globals::UniscribeDllModule = moduleUsp;    // remember to release
                }
            }

            if (FAILED(hr))
            {
                //  Uniscribe is corrupted! Very unlikely

                ASSERT(FALSE);
                FreeLibrary(moduleUsp); // release it here
            }
        }
    }

    ASSERT(GdipThaiBreakingFunction != GdipThaiBreakingFunctionInitializer);

    return GdipThaiBreakingFunction(
        string,
        length,
        analysis,
        breaks
    );
}

}   // extern "C"




////    Get character properties for complex script run
//
//      Analyze the content and determine if the character at given position starts
//      a character context either a word or cluster. Cache the result in span for
//      better performance.
//
//      Assuming maximum 12 characters for a word,
//      we're giving the algorithm at least 5 preceding and 5 succeeding surrounding words.
//

#define APPROX_MAX_WORDSIZE         12
#define APPROX_MAX_PRECEDING        60
#define APPROX_MAX_SUCCEEDING       60

#define IsDelimiter(c)              (BOOL)(c == 0x20 || c == 13 || c == 10)

GpStatus FullTextImager::GetCharacterProperties (
    ItemScript  script,             // [IN] Script id
    LSCP        position,           // [IN] Line Services character position
    BOOL        *isWordStart,       // [OUT] Is it a start of word?
    BOOL        *isWordLast,        // [OUT] Is it the word's last character?
    BOOL        *isClusterStart     // [OUT] (optional) Is it at a cluster boundary?
)
{
    if (!isWordStart || !isWordLast)
    {
        return InvalidParameter;
    }


    *isWordLast = *isWordStart = FALSE;

    GpStatus status = Ok;

    SpanRider<PLSRUN> runRider(&RunVector);
    runRider.SetPosition(position);

    ASSERT (runRider.GetCurrentElement()->RunType == lsrun::RunText);


    //  Map Line Services position to actual string position

    INT stringPosition =   position
                         - runRider.GetCurrentSpanStart()
                         + runRider.GetCurrentElement()->ImagerStringOffset;



    //  Check if we already cached the result

    SpanRider<Break*> breakRider(&BreakVector);
    breakRider.SetPosition(stringPosition);

    if (breakRider.GetCurrentElement())
    {
        //  Found it!

        *isWordStart = breakRider.GetCurrentElement()->IsWordBreak(
                            stringPosition - breakRider.GetCurrentSpanStart()
                       );

        if (   !*isWordStart
            && stringPosition < Length - 1
            && CharacterAttributes[CharClassFromCh(String[stringPosition + 1])].Script == script)
        {
            UINT32 stringOffset = stringPosition + 1 - breakRider.GetCurrentSpanStart();

            *isWordLast =    stringOffset >= breakRider.GetUniformLength()
                          || breakRider.GetCurrentElement()->IsWordBreak(stringOffset);
        }

        if (isClusterStart)
        {
            *isClusterStart = breakRider.GetCurrentElement()->IsClusterBreak(
                                    stringPosition - breakRider.GetCurrentSpanStart()
                              );
        }
        return Ok;
    }


    //  Collect enough surrounding text to resolve context boundary

    INT  startPosition  = stringPosition;
    INT  limit          = max (breakRider.GetCurrentSpanStart(),
                               (UINT)(max(0, stringPosition - APPROX_MAX_PRECEDING - 1)));


    //  Skip all the preceding delimiters
    //  (we should never start at a delimiter, however a little protection does not kill.)
    while (   startPosition > limit
           && IsDelimiter(String[startPosition - 1]))
    {
        startPosition--;
    }

    //  Span backward until reaching a delimiter or script boundary
    while (   startPosition > limit
           && !IsDelimiter(String[startPosition - 1])
           && CharacterAttributes[CharClassFromCh(String[startPosition - 1])].Script == script)
    {
        startPosition--;
    }

    //  See if the start position ends at delimiter or script boundary.
    BOOL stableStart = (   startPosition > limit
                        || limit == (INT)breakRider.GetCurrentSpanStart());


    INT endPosition = stringPosition;
    limit = min (Length, endPosition + APPROX_MAX_SUCCEEDING);

    if ((INT)breakRider.GetCurrentSpan().Length > 0)
    {
        limit = min ((UINT)limit, breakRider.GetCurrentSpanStart() + breakRider.GetCurrentSpan().Length);
    }

    //  Skip all succeeding delimiters
    while (   endPosition < limit
           && IsDelimiter(String[endPosition]))
    {
        endPosition++;
    }

    //  Span foreward until reaching a delimiter or script boundary
    while (   endPosition < limit
           && !IsDelimiter(String[endPosition])
           && CharacterAttributes[CharClassFromCh(String[endPosition])].Script == script)
    {
        endPosition++;
    }

    //  See if the end position ends at delimiter or script boundary.
    BOOL stableEnd = (   endPosition < limit
                      || limit == Length
                      || breakRider.GetUniformLength() < APPROX_MAX_SUCCEEDING);



    //  At least we should have a span of 1 character which is the one we start with
    ASSERT(endPosition > startPosition);


    AutoArray<SCRIPT_LOGATTR> breaks(new SCRIPT_LOGATTR [endPosition - startPosition]);

    if (!breaks)
    {
        return OutOfMemory;
    }


    HRESULT hr = S_OK;

    ScriptAnalysis analysis(&GpTextItem(script, 0), 0, 0);

    switch (script)
    {
        case ScriptThai:

            //  call Thai word break engine

            hr = GdipThaiBreakingFunction(
                &String[startPosition],
                endPosition - startPosition,
                &analysis.Sa,
                breaks.Get()
            );
            break;

        default:

            hr = SimpleBreak(
                &String[startPosition],
                endPosition - startPosition,
                &analysis.Sa,
                breaks.Get()
            );
    }


    if (FAILED(hr))
    {
        TERSE(("breaking function fails - HRESULT: %x\n", hr));
        return hr == E_OUTOFMEMORY ? OutOfMemory : Win32Error;
    }


    //  Cache a stable range of breaking result

    INT  kill;
    INT  newPosition;

    if (!stableEnd)
    {
        //  Stabilize the end by eliminating the last 2 words

        kill = 3;
        newPosition = endPosition - 1;

        while (newPosition > startPosition)
        {
            if (breaks[newPosition - startPosition].fWordStop)
            {
                if (!--kill)
                {
                    break;
                }
            }
            newPosition--;
        }

        if (newPosition > startPosition)
        {
            endPosition = newPosition;
        }
    }

    newPosition = startPosition;

    if (!stableStart)
    {
        //  Stabilize the beginning by eliminating the first 2 words

        kill = 3;

        while (newPosition < endPosition)
        {
            if (breaks[newPosition - startPosition].fWordStop)
            {
                if (!--kill)
                {
                    break;
                }
            }
            newPosition++;
        }
    }

    if (endPosition > newPosition)
    {
        //  Got the stable range, cache it in vector

        Break *breakRecord = new Break(
            &breaks[newPosition - startPosition],
            endPosition - newPosition
        );

        if (!breakRecord)
        {
            return OutOfMemory;
        }

        #if DBG
        //  Check overlapped range
        breakRider.SetPosition(newPosition);
        ASSERT (!breakRider.GetCurrentElement());
        breakRider.SetPosition(endPosition - 1);
        ASSERT (!breakRider.GetCurrentElement());
        #endif

        status = breakRider.SetSpan(
            newPosition,
            endPosition - newPosition,
            breakRecord
        );

        if (status != Ok)
        {
            delete breakRecord;
            return status;
        }
    }

    //  Reposition break pointer
    breakRider.SetPosition(stringPosition);

    if (breakRider.GetCurrentElement())
    {
        *isWordStart = breakRider.GetCurrentElement()->IsWordBreak(
                            stringPosition - breakRider.GetCurrentSpanStart()
                       );

        if (   !*isWordStart
            && stringPosition < Length - 1
            && CharacterAttributes[CharClassFromCh(String[stringPosition + 1])].Script == script)
        {
            UINT32 stringOffset = stringPosition + 1 - breakRider.GetCurrentSpanStart();

            *isWordLast =    stringOffset >= breakRider.GetUniformLength()
                          || breakRider.GetCurrentElement()->IsWordBreak(stringOffset);
        }

        if (isClusterStart)
        {
            *isClusterStart = breakRider.GetCurrentElement()->IsClusterBreak(
                                    stringPosition - breakRider.GetCurrentSpanStart()
                              );
        }
    }

    return status;
}




/////   Constructing ellipsis
//

EllipsisInfo::EllipsisInfo(
    const GpFontFace    *fontFace,
    REAL                emSize,
    INT                 style,
    double              designToIdeal,
    INT                 formatFlags
) :
    Face                (fontFace),
    EmSize              (emSize),
    Item                (0),
    FormatFlags         (formatFlags)
{
    const IntMap<UINT16> *cmap = &fontFace->GetCmap();


    //  First try horizontal ellipsis

    String[0]   = 0x2026;
    Glyphs[0]   = cmap->Lookup(String[0]);
    GlyphCount  = 1;

    UINT16 firstGlyph = Glyphs[0];

    if (firstGlyph != fontFace->GetMissingGlyph())
    {
        if (formatFlags & StringFormatFlagsDirectionVertical)
        {
            Item.Flags |= ItemVertical;

            //  see if 'vert' feature is presented and supplies a
            //  vertical form alternative for the ellipsis.

            SubstituteVerticalGlyphs(
                &firstGlyph,
                1,
                fontFace->GetVerticalSubstitutionCount(),
                fontFace->GetVerticalSubstitutionOriginals(),
                fontFace->GetVerticalSubstitutionSubstitutions()
            );

            if (firstGlyph != Glyphs[0])
            {
                //  Glyph has changed by 'vert' feature,
                //  we now know it's a sideway's.

                Glyphs[0] = firstGlyph;
                Item.Flags |= ItemSideways;
            }
            else
            {
                //  The glyph's vertical form is not presented (either 'vert'
                //  feature is not there or not supported), we cannot use
                //  this codepoint, fallback to three dots.

                firstGlyph = fontFace->GetMissingGlyph();
            }
        }
    }

    if (firstGlyph == fontFace->GetMissingGlyph())
    {
        //  If not available, try three dots (...)

        for (INT i = 0; i < MAX_ELLIPSIS; i++)
        {
            String[i] = '.';
            Glyphs[i] = cmap->Lookup(String[i]);
        }
        GlyphCount = i;
    }


    Item.Script = ScriptLatin;  // assume simple script

    if (formatFlags & StringFormatFlagsDirectionVertical)
    {
        Item.Flags |= ItemVertical;
    }
    else
    {
        if (formatFlags & StringFormatFlagsDirectionRightToLeft)
        {
            Item.Level = 1;
        }
    }

    SCRIPT_VISATTR glyphProperties = { SCRIPT_JUSTIFY_CHARACTER, 1, 0, 0, 0, 0 };

    Width = 0;

    fontFace->GetGlyphDesignAdvancesIdeal(
        Glyphs,
        GlyphCount,
        style,
        FALSE, // !!! vertical
        TOREAL(designToIdeal),
        1.0,
        GlyphAdvances
    );

    for (INT i = 0; i < GlyphCount; i++)
    {
        GlyphMap[i]         = (UINT16)i;

        GlyphProperties[i]  = ((UINT16 *)&glyphProperties)[0];
        GlyphOffsets[i].X   = 0;
        GlyphOffsets[i].Y   = 0;

        Width               += GlyphAdvances[i];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\flip.hpp ===
////    FlipWords and DWords - useful when processing Truetype tables
//
//      entry   pw/pdw - Pointer to initial word/double word
//              n      - Number of words or doublewords to flip


__inline void FlipWords(void *memPtr, INT n) {
    INT i;
    WORD *pw = (WORD*)memPtr;

    for (i=0; i<n; i++) {
        pw[i] = (pw[i] & 0x00ff) << 8 | pw[i] >> 8;
    }
}


__inline void FlipDWords(void *memPtr, INT n) {
    INT i;
    UNALIGNED DWORD *pdw = (UNALIGNED DWORD*) memPtr;

    for (i=0; i<n; i++) {
        pdw[i] =   (pdw[i] & 0x000000ff) << 24
                 | (pdw[i] & 0x0000ff00) <<  8
                 | (pdw[i] & 0x00ff0000) >>  8
                 | (pdw[i]             ) >> 24;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\hmtx.cpp ===
////    HMTX - Truetype hmtx font table loader
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hpp"




///     Interprets Truetype HMTX tables to extract design advance widths




////    ReadMtx - Get design widths from hmtx or vmtx table
//
//      The Hmtx contains numberOfHMetrics repetitions of longMetric
//      followed by numGlyphs-numberOfHMetrics repetitions of a UINT16.
//
//      The longHorMetrics corresponds to glyphs that vary in width,
//      and the UINT16s provide left sidebearings for fixed advance
//      width glyphs (whose advance widths comes from the last longMetric)


struct LongMetric {
    UINT16 advanceWidth;
    INT16  lsb;             // Left side bearing
};

GpStatus ReadMtx(
    BYTE           *mtx,
    UINT            mtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *designAdvance
)
{
    // All entries in the mtx are 16 bit, so flip them all to Intel byte
    // order before we start.

    FlipWords(mtx, mtxLength/2);

    ASSERT(  numberOfLongMetrics               * sizeof(LongMetric)
           + (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
           <= mtxLength);

    ASSERT(numberOfLongMetrics >= 1);   // Even a fixed pitch font must have one
                                        // to provide the fixed advance width

    if (   numberOfLongMetrics               * sizeof(LongMetric)
        +  (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
        >  mtxLength)
    {
        return Ok;
    }

    if (numberOfLongMetrics < 1)
    {
        return Ok;
    }


    GpStatus status = Ok;

    // Handle longMetric entries

    LongMetric *longMetric = (LongMetric*) mtx;

    INT i;
    for (i=0; i<numberOfLongMetrics && status == Ok; i++)
    {
        status = designAdvance->Insert(i, longMetric->advanceWidth);
        longMetric++;
    }


    // Fill in remaining entries with advance width from last longMetric entry

    UINT16 fixedAdvance = (--longMetric)->advanceWidth;

    for (i=numberOfLongMetrics; i<numGlyphs && status == Ok; i++)
    {
        status = designAdvance->Insert(i, fixedAdvance);
    }
    return status;
}




GpStatus ReadMtxSidebearing(
    BYTE           *mtx,
    UINT            mtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *sidebearing
)
{
    // All entries in the mtx are 16 bit, so flip them all to Intel byte
    // order before we start.

    FlipWords(mtx, mtxLength/2);

    ASSERT(  numberOfLongMetrics               * sizeof(LongMetric)
           + (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
           <= mtxLength);

    ASSERT(numberOfLongMetrics >= 1);   // Even a fixed pitch font must have one
                                        // to provide the fixed advance width

    if (   numberOfLongMetrics               * sizeof(LongMetric)
        +  (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
        >  mtxLength)
    {
        return Ok;
    }

    if (numberOfLongMetrics < 1)
    {
        return Ok;
    }

    GpStatus status = Ok;
    // Handle longMetric entries

    LongMetric *longMetric = (LongMetric*) mtx;

    INT i;
    for (i=0; i<numberOfLongMetrics && status == Ok; i++)
    {
        status = sidebearing->Insert(i, longMetric->lsb);
        longMetric++;
    }


    // Fill in remaining entries

    INT16 *lsb = (INT16*) longMetric;

    for (i=numberOfLongMetrics; i<numGlyphs && status == Ok; i++)
    {
        status = sidebearing->Insert(i, lsb[i-numberOfLongMetrics]);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\imager.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Text imager implementation
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"






/////   NewTextImager
//
//      Analyses the clients requirements, and chooses between the simple
//      text imager and the full text imager.
//
//      If the returned status is not Ok, then all allocated memory has been
//      released.
//
//      !v2 - the decision to use a simple or full text imager cannot be made
//      until formatting is required, since the client may make format or
//      content changes after the initial construction and before calling
//      measurement or rendering functionality.


GpStatus newTextImager(
    const WCHAR           *string,
    INT                    length,
    REAL                   width,
    REAL                   height,
    const GpFontFamily    *family,
    INT                    style,
    REAL                   fontSize,    // In world units
    const GpStringFormat  *format,
    const GpBrush         *brush,
    GpTextImager         **imager,
    BOOL                   singleUse    // Enables use of simple formatter when no format passed
)
{
    GpStatus status;

    // Establish string length

    if (length == -1)
    {
        length = 0;
        while (string[length])
        {
            length++;
        }
    }

    if (length < 0)
    {
        return InvalidParameter;
    }
    else if (length == 0)
    {
        *imager = new EmptyTextImager;
        if (!*imager)
            return OutOfMemory;
        return Ok;
    }


    // Determine line length limit

    REAL lineLengthLimit;

    if (format && format->GetFormatFlags() & StringFormatFlagsDirectionVertical)
    {
        lineLengthLimit = height;
    }
    else
    {
        lineLengthLimit = width;
    }


    if (lineLengthLimit < 0)
    {
        *imager = new EmptyTextImager;
        if (!*imager)
            return OutOfMemory;
        return Ok;
    }

    // Establish font face that will be used if no fallback is required

    GpFontFace *face = family->GetFace(style);

    if (!face)
    {
        return InvalidParameter;
    }


    // Certain flags are simply not supported by the simple text imager
    // Fonts with kerning, ligatures or opentype tables for simple horizontal
    // characters are not supported by the simple text imager

    INT64 formatFlags = format ? format->GetFormatFlags() : 0;

    *imager = new FullTextImager(
        string,
        length,
        width,
        height,
        family,
        style,
        fontSize,
        format,
        brush
    );
    if (!*imager)
        return OutOfMemory;
    status = (*imager)->GetStatus();
    if (status != Ok)
    {
        delete *imager;
        *imager = NULL;
    }
    return status;
}




void GpTextImager::CleanupTextImager()
{
    ols::deleteFreeLineServicesOwners();
}








void DetermineStringComplexity(
    const UINT16 *string,
    INT           length,
    BOOL         *complex,
    BOOL         *digitSeen
)
{
    INT     i = 0;
    INT flags = 0;

    while (i < length)
    {
        INT ch = string[i++];

        // Don't worry about surrogate pairs in this test: all surrogate
        // WCHAR values are flagged as NOTSIMPLE.

        UINT_PTR cl = (UINT_PTR)(pccUnicodeClass[ch >> 8]);

        if (cl >= CHAR_CLASS_MAX) // It's a pointer to more details
        {
            cl = ((CHAR_CLASS*)cl)[ch & 0xFF];
        }

        flags |= CharacterAttributes[cl].Flags;
    }

    *digitSeen = flags & CHAR_FLAG_DIGIT     ? TRUE : FALSE;
    *complex   = flags & CHAR_FLAG_NOTSIMPLE ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\glyphplacement.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   glyphPlacement.hpp
*
* Abstract:
*
*   Implements glyph measurement and justification for graphicsText
*
* Created:
*
*   17th April 2000 dbrown
*
\**************************************************************************/


#ifndef _GLYPHPLACEMENT_HPP
#define _GLYPHPLACEMENT_HPP

struct tagGOFFSET;
typedef struct tagGOFFSET GOFFSET;

class GlyphImager
{
public:

    GpStatus Initialize(
        IN  const GpFaceRealization *faceRealization,
        IN  const GpMatrix          *worldToDevice,
        IN  REAL                     worldToIdeal,
        IN  REAL                     emSize,
        IN  INT                      glyphCount,
        IN  const UINT16            *glyphs,
        IN  const GpTextItem        *textItem,
        IN  const GpStringFormat    *format,
        IN  INT                      runLeadingMargin,
        IN  INT                      runTrailingMargin,
        IN  BOOL                     runLeadingEdge,       // This run at leading edge of line
        IN  BOOL                     runTrailingEdge,      // This run at trailing edge of line
        IN  const WCHAR             *string,
        IN  INT                      stringOffset,
        IN  INT                      stringLength,
        IN  const UINT16            *glyphProperties,   // glyph properties array
        IN  const INT               *glyphAdvances,     // glyph advance width array
        IN  const Point             *glyphOffsets,      // glyph offset array
        IN  const UINT16            *glyphMap,
        IN  SpanVector<UINT32>      *rangeVector,       // optional
        IN  BOOL                     renderRTL
    );


    GpStatus GetAdjustedGlyphAdvances(
        IN  const PointF    *origin,
        OUT const INT       **adjustedGlyphAdvances,
        OUT INT             *originAdjust,
        OUT INT             *trailingAdjust
    );


    GpStatus DrawGlyphs(
        IN  const PointF                &origin,       // in world units
        IN  SpanVector<const GpBrush*>  *brushVector,
        IN  GpGraphics                  *graphics,
        OUT PointF                      *cellOrigin,
        OUT const INT                  **adjustedGlyphAdvances
    );


    BOOL IsAdjusted() const
    {
        return Adjusted;
    }


private:
    BOOL IsScriptConnected() const
    {
        return TextItem->Script == ScriptArabic
           ||  TextItem->Script == ScriptSyriac
           ||  TextItem->Script == ScriptThaana
           ||  TextItem->Script == ScriptDevanagari;
    }

    GpStatus GlyphPlacementToGlyphOrigins(
        IN  const PointF   *origin,         // first cell origin
        IN  GpGraphics     *graphics,
        OUT PointF         *glyphOrigins    // device units
    );


    GpStatus FitMargins();

    GpStatus AdjustGlyphAdvances(
        INT    runGlyphOffset,
        INT    runGlyphLimit,
        INT    LeftMargin,
        INT    RightMargin
    );
    

    void GetDisplayCellOrigin(
        IN  const PointF    &origin,        // baseline origin in world units
        OUT PointF          *cellOrigin     // adjusted display origin in world units
    );




    // member variables

    const GpFontFace         *Face;
    const GpFaceRealization  *FaceRealization;
    const GpMatrix           *WorldToDevice;
    REAL                      WorldToIdeal;
    REAL                      EmSize;
    INT                       GlyphCount;
    const UINT16             *Glyphs;
    const INT                *NominalAdvances;
    const Point              *NominalOffsets;
    const UINT16             *GlyphMap;
    const UINT16             *GlyphProperties;
    const GpTextItem         *TextItem;
    const GpStringFormat     *Format;
    INT                       FormatFlags;
    GpStringAlignment         Align;
    INT                       RunLeadingMargin;
    INT                       RunTrailingMargin;
    REAL                      DeviceToIdealBaseline;
    BOOL                      Adjusted;             // If False, use nominal widths
    AutoBuffer<INT, 32>       AdjustedAdvances;
    AutoBuffer<Point, 32>     AdjustedOffsets;
    INT                       OriginAdjust;
    INT                       TrailingAdjust;       // adjustment for trailing whitespaces
    SpanVector<UINT32>       *RangeVector;
    const WCHAR              *String;
    INT                       StringOffset;         // String offset at start of run
    INT                       StringLength;
    BOOL                      RenderRTL;
    BOOL                      InitializedOk;
};


#endif // defined _GLYPHPLACEMENT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\lineservicescallbacks.cpp ===
/////   LineServicesCallbacks
//
//

#include "precomp.hpp"




/////   LineServices callback functions
//
//      A set of callbacks that do the real work.
//


////    FetchRun
//
//      We return to Line Services the longest character run that is consistent
//      in those attributes that line services is interested in.
//
//      The changes that affect line services are:
//
//          UINT fUnderline
//          UINT fStrike
//          UINT fShade
//          UINT fBorder
//      Changes in vertical metrics.

LSERR WINAPI FullTextImager::GdipLscbkFetchRun(
    POLS      ols,            // [IN]  text imager instance
    LSCP      position,       // [IN]  position to fetch
    LPCWSTR   *string,        // [OUT] string of run
    DWORD     *length,        // [OUT] length of string
    BOOL      *isHidden,      // [OUT] Is this run hidden?
    PLSCHP    chp,            // [OUT] run's character properties
    PLSRUN    *run            // [OUT] fetched run
)
{
    FullTextImager *imager = ols->GetImager();
    GpStatus status = imager->BuildRunsUpToAndIncluding(position);
    if (status != Ok)
    {
        return lserrInvalidParameter;
    }

    if (!imager->RunRider.SetPosition(position))
    {
        return lserrInvalidParameter;
    }

    *run    = imager->RunRider.GetCurrentElement();
    *length = imager->RunRider.GetUniformLength();


    #if TRACERUNSPANS
        TERSE(("Fetch run String[%x] potentially run %x l %x\n",
            position,
            *run,
            *length
        ));
    #endif


    INT offsetIntoRun = position - imager->RunRider.GetCurrentSpanStart();


    *isHidden = FALSE;      // assume no hidden text

    GpMemset (chp, 0, sizeof(LSCHP));

    status = Ok;
    switch((*run)->RunType)
    {
        case lsrun::RunText:
        {
            if (offsetIntoRun == 0)
            {
                *string = imager->String + (*run)->ImagerStringOffset;
            }
            else
            {
                // We want our runs to match Line Services runs so that when Line
                // Services calls GetGlyphs, its strings will always be synchronised
                // with the start of our runs.
                //
                // Therefore, if this FetchRun does not start in the middle of one
                // of our runs, then we need to split our run.
                //
                // This strategy as recommended by Sergey Genkin 16th Dec 99.

                ASSERT(offsetIntoRun > 0);

                lsrun *previousRun = imager->RunRider.GetCurrentElement();
                ASSERT(previousRun == (*run));

                INT newRunLength = imager->RunRider.GetCurrentSpan().Length - offsetIntoRun;
                ASSERT(newRunLength > 0);

                // Split current run at new position.

                lsrun *newRun = new lsrun(*previousRun);

                if (!newRun)
                {
                    return lserrOutOfMemory;
                }

                newRun->ImagerStringOffset += offsetIntoRun;
                newRun->CharacterCount = newRunLength;


                #if TRACERUNSPANS
                    TERSE(("Splitting lsrun %x String[%x] l %x into %x and %x @ %x\n",
                        *run,
                        (*run)->ImagerStringOffset,
                        imager->RunRider.GetCurrentSpan().Length,
                        offsetIntoRun,
                        newRunLength,
                        newRun
                    ));
                #endif


                // Copy glyphs

                INT firstGlyph    = previousRun->GlyphMap[offsetIntoRun];
                INT newGlyphCount = previousRun->GlyphCount - firstGlyph;

                if (firstGlyph <= 0 || newGlyphCount <= 0)
                {
                    delete newRun;
                    return lserrInvalidRun;
                }

                newRun->GlyphCount      = newGlyphCount;
                previousRun->GlyphCount = firstGlyph;

                newRun->Glyphs          = new GINDEX[newGlyphCount];
                newRun->GlyphProperties = new GPROP[newGlyphCount];
                newRun->GlyphMap        = new GMAP[newRunLength];
                
                if (   !newRun->Glyphs
                    || !newRun->GlyphProperties
                    || !newRun->GlyphMap)
                {
                    delete newRun;
                    return lserrOutOfMemory;
                }

                memcpy(newRun->Glyphs,          previousRun->Glyphs + firstGlyph,          sizeof(GINDEX) * newGlyphCount);
                memcpy(newRun->GlyphProperties, previousRun->GlyphProperties + firstGlyph, sizeof(GPROP) * newGlyphCount);

                for (INT i=0; i<newRunLength; i++)
                {
                    newRun->GlyphMap[i] = previousRun->GlyphMap[i+offsetIntoRun] - firstGlyph;
                }

                previousRun->CharacterCount = offsetIntoRun;


                status = imager->RunRider.SetSpan(position, newRunLength, newRun);
                if (status != Ok)
                {
                    delete newRun;
                    return lserrOutOfMemory;
                }

                #if TRACERUNSPANS
                    TERSE(("SetSpan(position %x, length %x, run %x)  ",
                        position,
                        newRunLength,
                        newRun
                    ));
                    imager->RunVector.Dump();
                #endif

                *string = imager->String + newRun->ImagerStringOffset;
                *length = newRunLength;
                *run    = newRun;
            }

            //  Truncate for hidden text

            SpanRider<INT> visiRider(&imager->VisibilityVector);
            visiRider.SetPosition((*run)->ImagerStringOffset);

            *length = min(*length, visiRider.GetUniformLength());
            *isHidden = visiRider.GetCurrentElement() == VisibilityHide;

            break;
        }

        case lsrun::RunEndOfParagraph:
            *string =   L"\x0d\x0a"
                      + offsetIntoRun;
            break;

        case lsrun::RunLevelUp:
            chp->idObj  = OBJECTID_REVERSE;
            *string     = L" ";
            return lserrNone;

        case lsrun::RunLevelDown:
            chp->idObj  = idObjTextChp;
            *string     = ObjectTerminatorString;
            return lserrNone;

        case lsrun::RunLevelSeparator:
            // !!! Not implemented
            *string = NULL;
            break;
    }

    //  Set LS character properties
    //

    INT style = SpanRider<INT>(&imager->StyleVector)[(*run)->ImagerStringOffset];

    chp->idObj       = idObjTextChp;
    chp->fGlyphBased = (*run)->RunType == lsrun::RunText ? TRUE : FALSE;
    chp->fUnderline  = (style & FontStyleUnderline) ? TRUE : FALSE;
    chp->fStrike     = style & FontStyleStrikeout ? TRUE : FALSE;

    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkFetchTabs(
    POLS        ols,                // [IN] text imager instance
    LSCP        position,           // [IN] position within a paragraph to fetch
    PLSTABS     tab,                // [OUT] tab structre to be fetched
    BOOL        *hangingTab,        // [OUT] TRUE: there is hanging tab in tabs array
    long        *hangingTabWidth,   // [OUT] width of hanging tab
    WCHAR       *hangingTabLeadChar // [OUT] leading character of hanging tab
)
{
    FullTextImager  *imager = ols->GetImager();
    imager->RunRider.SetPosition(position);


    imager->GetTabStops (
        imager->RunRider.GetCurrentElement()->ImagerStringOffset,
        (INT *)&tab->iTabUserDefMac,
        &tab->pTab,
        (INT *)&tab->duaIncrementalTab
    );


    // No hanging tab

    *hangingTab         = FALSE;
    *hangingTabWidth    =
    *hangingTabLeadChar = 0;

    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkGetBreakThroughTab(
    POLS        ols,                // [IN] text imager instance
    long        rightMagin,         // [IN] right margin for breaking
    long        tabPosition,        // [IN] breakthrough tab position
    long        *newRightMargin     // [OUT] new right margin
)
{
    *newRightMargin = tabPosition;
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkFetchPap(
    POLS      ols,            // [IN] text imager instance
    LSCP      position,       // [IN] position to fetch
    PLSPAP    pap             // [OUT] paragraph properties
)
{
    #if TRACERUNSPANS
        TERSE(("FetchPap String[%x]\n"));
    #endif

    FullTextImager *imager = ols->GetImager();

    GpStatus status = imager->BuildRunsUpToAndIncluding(position);
    if (status != Ok)
    {
        return lserrInvalidParameter;
    }

    if (!imager->RunRider.SetPosition(position))
    {
        return lserrInvalidParameter;
    }

    GpMemset (pap, 0, sizeof(LSPAP));

    pap->cpFirst        = // LS doesnt really care where the paragraph starts
    pap->cpFirstContent = position;
    pap->lskeop         = lskeopEndPara12;
    pap->lskal          = lskalLeft;  // We do all alignment ourselves


    //  Apply linebreak rules for breaking classes.

    pap->grpf = fFmiApplyBreakingRules;


    if (imager->IsFormatVertical())
    {
        //  For underlining purpose, vertical text always has
        //  paragraph flowing west.

        pap->lstflow = lstflowSW;
    }
    else
    {
        //  We can have paragraphs with different reading order

        const GpStringFormat *format = SpanRider<const GpStringFormat *>(
            &imager->FormatVector)[imager->RunRider.GetCurrentElement()->ImagerStringOffset];

        pap->lstflow =    imager->IsFormatRightToLeft(format)
                       ?  lstflowWS
                       :  lstflowES;
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkFGetLastLineJustification (
    POLS         ols,                    // [IN] text imager instance
    LSKJUST      kJustification,         // [IN] kind of justification
    LSKALIGN     kAlignment,             // [IN] kind of alignment
    ENDRES       endr,                   // [IN] format result
    BOOL         *justifyLastLineOkay,   // [OUT] Should last line be fully justified?
    LSKALIGN     *kAlignmentLine         // [OUT] kind of justification of this line
)
{
    //  Just say no to justify last line
    //
    *justifyLastLineOkay = FALSE;
    *kAlignmentLine = kAlignment;
    return lserrNone;
}





////    Run management
//
//


LSERR WINAPI FullTextImager::GdipLscbkGetRunCharWidths(
    POLS      ols,            // [IN] text imager instance
    PLSRUN    run,            // [IN] run
    LSDEVICE  device,         // [IN] kind of device
    LPCWSTR   string,         // [IN] string of run
    DWORD     length,         // [IN] length of string
    long      maxWidth,       // [IN] maximum allowance of run's width
    LSTFLOW   flow,           // [IN] text flow
    int       *advance,       // [OUT] array of character's advance width
    long      *width,         // [OUT] run's total width
    long      *countAdvance   // [OUT] number of element of advance width array
)
{
    ASSERT(length > 0);

    UINT i;
    REAL fontToIdeal;

    #if TRACERUNSPANS
        WCHAR str[200];
        memcpy(str, string, min(200,length)*2);
        str[min(length,199)] = 0;
        TERSE(("GetRunCharWidths run %x, length %x, maxwidth %x: '%S'\n", run, length, maxWidth, str));
    #endif

    FullTextImager *imager = ols->GetImager();

    //  LS uses these values as a hint for run fetching.
    //
    //  Too small of return width causes over-fetching. Too great causes LS
    //  collapsing the line.
    //

    switch (run->RunType)
    {
    case lsrun::RunText:
        {
            fontToIdeal =     (run->EmSize / run->Face->GetDesignEmHeight())
                           *  imager->WorldToIdeal;

            const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
            double tracking = format ? format->GetTracking() : DefaultTracking;

            run->Face->GetShapingCache()->GetRunCharWidths(
                &run->Item,
                SpanRider<INT>(&imager->StyleVector)[run->ImagerStringOffset],
                string,
                length,
                run->FormatFlags,
                TOREAL(fontToIdeal * tracking),
                maxWidth,
                advance,
                (INT *)width,
                (INT *)countAdvance
            );
        }
        break;


    default:
        // Not really text. Return 1/4 emHeight for each 'glyph'.

        /*
        INT dummyGlyphAdvance = GpRound(float(   (run->EmSize / 4)
                                              *  imager->WorldToIdeal));
        advance[0] = dummyGlyphAdvance;
        *width     = dummyGlyphAdvance;

        i = 1;
        while (    i < length
               &&  *width < maxWidth)
        {
            advance[i] = 0; //dummyGlyphAdvance;
            //*width    += dummyGlyphAdvance;
            i++;
        }

        *countAdvance = i;

        */

        GpMemset(advance, 0, sizeof(int) * length);
        *width = 0;
        *countAdvance = length;

        break;
    }

    return lserrNone;
}




LSERR WINAPI FullTextImager::GdipLscbkGetRunTextMetrics(
    POLS     ols,            // [IN] text imager instance
    PLSRUN   run,            // [IN] run
    LSDEVICE device,         // [IN] kind of device
    LSTFLOW  flow,           // [IN] text flow
    PLSTXM   metrics         // [OUT] font metrics of run
)
{
    #if TRACERUNSPANS
        TERSE(("GetRunTextMetrics run %x\n", run));
    #endif

    FullTextImager *imager = ols->GetImager();
    ASSERT (run && run->Face);

    // Return metrics based on requested font. Font fallback does not affect
    // metrics.

    const GpFontFamily *family = SpanRider<const GpFontFamily *>(&imager->FamilyVector)
                                 [run->ImagerStringOffset];
    INT                 style  = SpanRider<INT>(&imager->StyleVector)
                                 [run->ImagerStringOffset];
    REAL                emSize = SpanRider<REAL>(&imager->SizeVector)
                                 [run->ImagerStringOffset];
    const GpFontFace *face     = family->GetFace(style);

    if (!face)
    {
        return FontStyleNotFound;
    }

    REAL fontToIdeal = (emSize / face->GetDesignEmHeight()) * imager->WorldToIdeal;

    metrics->dvAscent          = GpRound(float(   face->GetDesignCellAscent()
                                               *  fontToIdeal));
    metrics->dvDescent         = GpRound(float(   face->GetDesignCellDescent()
                                               *  fontToIdeal));
    metrics->dvMultiLineHeight = GpRound(float(   face->GetDesignLineSpacing()
                                               *  fontToIdeal));;
    metrics->fMonospaced       = FALSE;

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetRunUnderlineInfo (
    POLS       ols,                // [IN] text imager instance
    PLSRUN     run,                // [IN] run
    PCHEIGHTS  height,             // [IN] height of the run
    LSTFLOW    flow,               // [IN] text flow
    PLSULINFO  underline           // [OUT] underline information
)
{
    FullTextImager *imager = ols->GetImager();
    ASSERT (run && run->Face);

    REAL fontToIdeal =     (run->EmSize / run->Face->GetDesignEmHeight())
                        *  imager->WorldToIdeal;

    GpMemset (underline, 0, sizeof(LSULINFO));

    underline->cNumberOfLines = 1;

    underline->dvpFirstUnderlineOffset = GpRound(float(
        -run->Face->GetDesignUnderscorePosition() * fontToIdeal));

    underline->dvpFirstUnderlineSize = GpRound(float(
        run->Face->GetDesignUnderscoreSize() * fontToIdeal));

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetRunStrikethroughInfo(
    POLS       ols,            // [IN] text imager instance
    PLSRUN     run,            // [IN] run
    PCHEIGHTS  height,         // [IN] height of the run
    LSTFLOW    flow,           // [IN] text flow
    PLSSTINFO  strikethrough   // [OUT] strikethrough information
)
{
    FullTextImager *imager = ols->GetImager();
    ASSERT (run && run->Face);

    REAL fontToIdeal =     (run->EmSize / run->Face->GetDesignEmHeight())
                        *  imager->WorldToIdeal;

    GpMemset(strikethrough, 0, sizeof(LSSTINFO));

    strikethrough->cNumberOfLines = 1;

    strikethrough->dvpLowerStrikethroughOffset = GpRound(float(
        run->Face->GetDesignStrikeoutPosition() * fontToIdeal));

    strikethrough->dvpLowerStrikethroughSize = GpRound(float(
        run->Face->GetDesignStrikeoutSize() * fontToIdeal));

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkReleaseRun(
    POLS    ols,        // [IN] text imager instance
    PLSRUN  run         // [IN] run to be released
)
{
    // Nothing to be released.
    //

    return lserrNone;
}

////    Drawing
//
//


// workaround compiler bug (ntbug 312304)
#pragma optimize("", off)

LSERR WINAPI FullTextImager::GdipLscbkDrawUnderline(
    POLS         ols,                // [IN] text imager instance
    PLSRUN       run,                // [IN] run
    UINT         kUnderline,         // [IN] kind of underline
    const POINT  *pointStart,        // [IN] drawing start
    DWORD        lineLength,         // [IN] underline length
    DWORD        thickness,          // [IN] underline thickness
    LSTFLOW      flow,               // [IN] text flow
    UINT         modeDisplay,        // [IN] display mode
    const RECT   *rectClip           // [IN] clipping rectangle
)
{
    GpStatus status = Ok;
    FullTextImager *imager = ols->GetImager();

    //#if DBG
    //    WARNING(("DrawUnderline x %d, y %d, length %d", pointStart->x, pointStart->y, length));
    //#endif


    if (imager->RecordDisplayPlacementsOnly)
    {
        //  This is not an actual drawing
        return lserrNone;
    }


    PointF origin(
        TOREAL(pointStart->x), 
        TOREAL(pointStart->y)
    );
        
    BYTE runLevel = (run->Item.Level & 1);
    BOOL reverseLine;   // line being drawn from finish to start


    switch (flow)
    {
        //  Line Services tells us how to draw the line

        case lstflowWS:
        case lstflowNE:
        case lstflowNW:

            reverseLine = !runLevel;
            break;

        case lstflowES:
        case lstflowSE:
        case lstflowSW:
        default:

            reverseLine = runLevel;
    }

    INT  length = max((INT)lineLength, 0);
    BOOL vertical = imager->IsFormatVertical();
    REAL *textAxis = vertical ? &origin.Y : &origin.X;
    REAL *lineAxis = vertical ? &origin.X : &origin.Y;

    if (reverseLine)
    {
        //  line drawn from finish to start

        if (runLevel)
        {
            //  drawing from left to right or top to bottom
            *textAxis -= TOREAL(run->Adjust.Trailing);
        }
        else
        {
            //  drawing from right to left or bottom to top
            *textAxis -= TOREAL(length - run->Adjust.Leading);
        }
    }
    else
    {
        //  line drawn from start to finish

        if (runLevel)
        {
            //  drawing from right to left or bottom to top
            *textAxis -= TOREAL(length + run->Adjust.Trailing);
        }
        else
        {
            //  drawing from left to right or top to bottom
            *textAxis += TOREAL(run->Adjust.Leading);
        }
    }

    //  Adjust the line display position according to baseline adjustment.
    //  We want to draw an underline at the position relative to a baseline
    //  that snaps to full pixel in grid-fitted display. (wchao, #356546)

    if (!vertical)
    {
        //  Only adjust baseline for horizontal,
        //  let's leave vertical cases as is for now (wchao, 4-17-2001)
        
        *lineAxis += imager->CurrentBuiltLine->GetDisplayBaselineAdjust();
    }
    
    origin.X = imager->ImagerOrigin.X + origin.X / imager->WorldToIdeal;
    origin.Y = imager->ImagerOrigin.Y + origin.Y / imager->WorldToIdeal;


    length += run->Adjust.Trailing - run->Adjust.Leading;

    if (length <= 0)
    {
        //  Dont draw line w/ negative length
        return lserrNone;
    }


    REAL penWidth = thickness / imager->WorldToIdeal;
    if (imager->Graphics)
    {
        penWidth = imager->Graphics->GetDevicePenWidth(penWidth);

        const GpBrush* brush = SpanRider<const GpBrush*>(
            &imager->BrushVector)[run->ImagerStringOffset];

        PointF origins[2] = { origin, origin };
        if (vertical)
            origins[1].Y += length / imager->WorldToIdeal;
        else
            origins[1].X += length / imager->WorldToIdeal;

        status = imager->Graphics->DrawLines(
            &GpPen(brush, penWidth, UnitPixel),
            origins,
            2
        );
    }
    else
    {
        if (vertical)
        {
            status = imager->Path->AddRect(RectF(
                origin.X - penWidth / 2,
                origin.Y,
                penWidth,
                length / imager->WorldToIdeal
            ));
        }
        else
        {
            status = imager->Path->AddRect(RectF(
                origin.X,
                origin.Y - penWidth / 2,
                length / imager->WorldToIdeal,
                penWidth
            ));
        }
    }
    IF_NOT_OK_WARN_AND_RETURN(status);
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkDrawStrikethrough(
    POLS         ols,            // [IN] text imager instance
    PLSRUN       run,            // [IN] run
    UINT         kStrikethrough, // [IN] kind of strikethrough
    const POINT  *pointStart,    // [IN] drawing start
    DWORD        length,         // [IN] strikethrough length
    DWORD        thickness,      // [IN] strikethrough thickness
    LSTFLOW      flow,           // [IN] text flow
    UINT         modeDisplay,    // [IN] display mode
    const RECT   *rectClip       // [IN] clipping rectangle
)
{
    //  !! share code with underlining for now !!
    //

    return GdipLscbkDrawUnderline(
        ols,
        run,
        0,
        pointStart,
        length,
        thickness,
        flow,
        modeDisplay,
        rectClip
    );
}

#pragma optimize("", on)


LSERR WINAPI FullTextImager::GdipLscbkFInterruptUnderline(
    POLS       ols,                // [IN] text imager instance
    PLSRUN     first,              // [IN] first run
    LSCP       positionLastFirst,  // [IN] position of the last character of first run
    PLSRUN     second,             // [IN] second run
    LSCP       positionLastSecond, // [IN] position of the last character of second run
    BOOL       *interruptOK        // [OUT] Disconnect underlining between runs?
)
{
    // We need to use line services to calculate the height and thickness of
    // underlines, but we calculate the start and end positions ourselves based
    // on hinted glyph adjustment.
    //
    // Therefore we need DrawUnderline calls to correspond 1:1 with DrawGlyphs
    // calls. Per Victor Kozyrev Dec 6th 2000, returning TRUE here causes
    // LS to call DrawUnderline for each DrawGlyphs. Also guaranteed is that
    // DrawUnderline calls happen after the DrawGlyph calls they correspond to.

    *interruptOK = TRUE;
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkDrawTextRun(
    POLS           ols,                    // [IN] text imager instance
    PLSRUN         run,                    // [IN] run
    BOOL           strikethroughOkay,      // [IN] Strikethrough the run?
    BOOL           underlineOkay,          // [IN] Underline the run?
    const POINT    *pointText,             // [IN] actual start point of run (untrimmed)
    LPCWSTR        string,                 // [IN] string of run
    const int      *advances,              // [IN] character advance width array
    DWORD          length,                 // [IN] length of string
    LSTFLOW        flow,                   // [IN] text flow
    UINT           modeDisplay,            // [IN] display mode
    const POINT    *pointRun,              // [IN] start point of run (trimmed)
    PCHEIGHTS      height,                 // [IN] run's presentation height
    long           totalWidth,             // [IN] run's presentation width
    long           widthUnderlining,       // [IN] underlining limit
    const RECT     *rectClip               // [IN] clipping rectangle
)
{
    //  Ideally we should have nothing to do with this callback since everything we
    //  have is glyph-based. However LS does call this callback to display things like
    //  hyphen or paragraph separator (which is given as a space character).
    //

    GpStatus status = Ok;

    if (   run->RunType == lsrun::RunText
        && run->Item.Script != ScriptControl)
    {
        AutoArray<Point> glyphOffsets(new Point[length]);
        if (!glyphOffsets)
            return lserrOutOfMemory;

        FullTextImager *imager = ols->GetImager();

        GpMemset ((BYTE *)glyphOffsets.Get(), 0, length * sizeof(GOFFSET));

        //  Drawing properties

        const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
        INT                  style   = SpanRider<INT>(&imager->StyleVector)[run->ImagerStringOffset];

        POINT origin = *pointRun;
        origin.y = GpRound(origin.y + run->BaselineOffset * imager->WorldToIdeal);

        status = imager->DrawGlyphs (
            &run->Item,
            run->Face,
            run->EmSize,
            NULL,
            run->ImagerStringOffset,
            length,
            format,
            style,
            run->FormatFlags,
            run->Glyphs,
            run->GlyphMap,
            run->GlyphProperties,
            advances,
            glyphOffsets.Get(),
            length,
            &origin,
            totalWidth
        );
    }
    return status == Ok ? lserrNone : status;
}




LSERR WINAPI FullTextImager::GdipLscbkDrawGlyphs(
    POLS            ols,                    // [IN] text imager instance
    PLSRUN          run,                    // [IN] run
    BOOL            strikethroughOkay,      // [IN] Strikethrough the run?
    BOOL            underlineOkay,          // [IN] Underline the run?
    PCGINDEX        glyphs,                 // [IN] glyph index array
    const int      *glyphAdvances,          // [IN] glyph advance width array
    const int      *advanceBeforeJustify,   // [IN] array of glyph advance width before justification
    PGOFFSET        glyphOffsets,           // [IN] glyph offset array
    PGPROP          glyphProperties,        // [IN] glyph properties array
    PCEXPTYPE       glyphExpansionType,     // [IN] glyph expansion type array
    DWORD           glyphCount,             // [IN] number of element of glyph index array
    LSTFLOW         flow,                   // [IN] text flow
    UINT            modeDisplay,            // [IN] display mode
    const POINT    *pointRun,               // [IN] start point of run
    PCHEIGHTS       height,                 // [IN] run's presentation height
    long            totalWidth,             // [IN] run's presentation width
    long            widthUnderlining,       // [IN] underlining limit
    const RECT     *rectClip                // [IN] clipping rectangle
)
{
    FullTextImager *imager = ols->GetImager();

    ASSERT((INT)glyphCount <= run->GlyphCount);

    //  Drawing properties

    const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
    INT                  style   = SpanRider<INT>(&imager->StyleVector)[run->ImagerStringOffset];

    POINT origin = *pointRun;
    origin.y = GpRound(origin.y + run->BaselineOffset * imager->WorldToIdeal);

    UINT characterCount = run->CharacterCount;

    if (glyphCount != (UINT)run->GlyphCount)
    {
        characterCount = 0;

        while (   characterCount < run->CharacterCount
               && run->GlyphMap[characterCount] < glyphCount)
        {
            characterCount++;
        }
    }


    //#if DBG
    //    WARNING(("DrawGlyphs x %d, y %d, totalWidth %d, widthUnderlining %d",
    //             pointRun->x, pointRun->y, totalWidth, widthUnderlining));
    //#endif

    imager->CurrentBuiltLine->UpdateLastVisibleRun(run);    // cache last run being displayed

    GpStatus status = imager->DrawGlyphs (
        &run->Item,
        run->Face,
        run->EmSize,
        NULL,
        run->ImagerStringOffset,
        characterCount,
        format,
        style,
        run->FormatFlags,
        glyphs,
        run->GlyphMap,
        glyphProperties,
        glyphAdvances,
        (Point *)glyphOffsets,
        glyphCount,
        &origin,
        totalWidth,
        &run->Adjust
    );

    return status == Ok ? lserrNone : status;
}






LSERR WINAPI FullTextImager::GdipLscbkFInterruptShaping(
    POLS     ols,                    // [IN] text imager instance
    LSTFLOW  flow,                   // [IN] text flow
    PLSRUN   first,                  // [IN] first run
    PLSRUN   second,                 // [IN] second run
    BOOL     *interruptShapingOkay)  // [OUT] Disconnect glyphs between runs?
{
    //  We've cached the glyph indices since we started build up runs.
    //  Besides the performance gain, we have the benefit of not having to
    //  deal with the complexity of multiple-run GetGlyphs calls and simply
    //  ignore this callback (wchao).

    *interruptShapingOkay = TRUE;

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetGlyphs(
    POLS         ols,                // [IN] text imager instance
    PLSRUN       run,                // [IN] run
    LPCWSTR      string,             // [IN] string of run
    DWORD        length,             // [IN] length of string
    LSTFLOW      flow,               // [IN] text flow
    PGMAP        glyphMap,           // [OUT] glyph cluster mapping array
    PGINDEX      *glyphIndices,      // [OUT] pointer to glyph index array
    PGPROP       *glyphProperties,   // [OUT] pointer to glyph properties array
    DWORD        *countGlyph         // [OUT] number of element of glyph index array
)
{
    #if TRACERUNSPANS
        WCHAR str[200];
        memcpy(str, string, min(200,length)*2);
        str[min(length,199)] = 0;
        TERSE(("GetGlyphs run %x, length %x: '%S'\n", run, length, str));
    #endif

    ASSERT(ols->GetImager()->String[run->ImagerStringOffset] == string[0]);

    memcpy(glyphMap, run->GlyphMap, sizeof(GMAP) * length);


    //  Line Services may call for partial run.
    //  We need to make sure that we would never give too few glyphs. The
    //  orphan character with no correspondent glyph would assert.

    *countGlyph = run->GlyphMap[length - 1] + 1;

    while (   *countGlyph < (UINT)run->GlyphCount
           && !((SCRIPT_VISATTR *)run->GlyphProperties)[*countGlyph].fClusterStart)
    {
        (*countGlyph)++;
    }

    *glyphIndices    = run->Glyphs;
    *glyphProperties = run->GlyphProperties;

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetGlyphPositions(
    POLS         ols,                // [IN] text imager instance
    PLSRUN       run,                // [IN] run
    LSDEVICE     device,             // [IN] device to place to
    LPWSTR       string,             // [IN] string of run
    PCGMAP       glyphMap,           // [IN] glyph cluster mapping array
    DWORD        length,             // [IN] length of string
    PCGINDEX     glyphIndices,       // [IN] glyph index array
    PCGPROP      glyphProperties,    // [IN] glyph properties array
    DWORD        countGlyph,         // [IN] number of element of glyph index array
    LSTFLOW      flow,               // [IN] text flow
    int          *glyphAdvance,      // [OUT] glyph advance width array
    PGOFFSET     glyphOffset         // [OUT] glyph offset array
)
{
    #if TRACERUNSPANS
        WCHAR str[200];
        memcpy(str, string, min(200,length)*2);
        str[min(length,199)] = 0;
        TERSE(("GetGlyphPositions run %x, length %x: '%S'\n", run, length, str));
    #endif

    FullTextImager *imager = ols->GetImager();

    double designToIdeal = run->EmSize * imager->WorldToIdeal
                           / run->Face->GetDesignEmHeight();

    const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
    double tracking = format ? format->GetTracking() : DefaultTracking;

    run->Face->GetShapingCache()->GetGlyphPositions (
        &run->Item,
        (WORD *)glyphIndices,
        (SCRIPT_VISATTR *)glyphProperties,
        countGlyph,
        run->FormatFlags,
        NULL,                               // No real device
        SpanRider<INT>(&ols->GetImager()->StyleVector)[run->ImagerStringOffset],
        GpRound(TOREAL(designToIdeal * run->Face->GetDesignEmHeight())),
        GpRound(TOREAL(designToIdeal * run->Face->GetDesignEmHeight())),
        designToIdeal,
        TOREAL(tracking),
        glyphAdvance,
        glyphOffset,
        NULL,
        &run->EngineState
    );
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkResetRunContents(
    POLS      ols,                    // [IN] text imager instance
    PLSRUN    run,                    // [IN] run
    LSCP      positionBeforeShaping,  // [IN] first position of the run before shaping
    LSDCP     lengthBeforeShaping,    // [IN] length of the run before shaping
    LSCP      positionAfterShaping,   // [IN] first position of the run after shaping
    LSDCP     lengthAfterShaping      // [IN] length of the run after shaping
)
{
    //
    //  LS calls this function when a ligature extends across run boundaries.
    //  We dont have to do anything special here since we're not that sophisticate.
    //
    return lserrNone;
}





////    Line breaking
//
//

LSERR WINAPI FullTextImager::GdipLscbkGetBreakingClasses(
    POLS      ols,                      // [IN] text imager instance
    PLSRUN    run,                      // [IN] run
    LSCP      position,                 // [IN] position of the character
    WCHAR     wch,                      // [IN] character to return the class for
    BRKCLS    *breakClassAsLeading,     // [OUT] class if character is the leading in pair (break after)
    BRKCLS    *breakClassAsTrailing     // [OUT] class if character is the trailing in pair (break before)
)
{
    if (   ols->GetImager()->TruncateLine
        && wch != 0x20
        && (wch & 0xF800) != 0xD800)
    {
        //  In case of character trimming we dont apply word break rules,
        //  just break between any character pair using breakclass 0 "Break Always".

        *breakClassAsLeading  =
        *breakClassAsTrailing = 0;

        return lserrNone;
    }

    if (wch == WCH_IGNORABLE)
    {
        //  Special handling for 0xffff.
        //
        //  Classification of 0xffff is dynamic. It has the same classification
        //  as the first character found following it.
        
        ASSERT(run->RunType == lsrun::RunText);

        FullTextImager *imager = ols->GetImager();

        if (!imager->RunRider.SetPosition(position))
        {
            return lserrInvalidParameter;
        }

        UINT c = 1; // looking forward next char
        UINT i = position - imager->RunRider.GetCurrentSpanStart();
        
        while (   i + c < run->CharacterCount
               && (wch = imager->String[run->ImagerStringOffset + i + c]) == WCH_IGNORABLE)
        {
            c++;
        }

        if (wch != WCH_IGNORABLE)
        {
            position += c;
        }
    }


    CHAR_CLASS charClass  = CharClassFromCh(wch);
    BRKCLS     breakClass = ols->GetImager()->BreakClassFromCharClass[charClass];


    *breakClassAsLeading  =
    *breakClassAsTrailing = breakClass;


    if (breakClass != BREAKCLASS_THAI)
    {
        return lserrNone;
    }


    //  Dictionary-based linebreaking,
    //  As of now, only Thai falls into this category.

    BOOL isWordStart = FALSE;
    BOOL isWordLast  = FALSE;

    GpStatus status = ols->GetImager()->GetCharacterProperties (
        CharacterAttributes[charClass].Script,
        position,
        &isWordStart,
        &isWordLast
    );

    if (status == Ok)
    {
        switch (breakClass)
        {
            // !! Only Thai for now !!

            case BREAKCLASS_THAI :

                if (isWordStart)
                {
                    *breakClassAsTrailing = BREAKCLASS_THAIFIRST;
                }

                if (isWordLast)
                {
                    *breakClassAsLeading = BREAKCLASS_THAILAST;
                }
        }
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkFTruncateBefore(
    POLS       ols,                    // [IN] text imager instance
    PLSRUN     run,                    // [IN] run
    LSCP       position,               // [IN] position of truncation character
    WCHAR      character,              // [IN] truncation character
    long       width,                  // [IN] width of truncation character
    PLSRUN     runBefore,              // [IN] run of the character preceding truncation character
    LSCP       positionBefore,         // [IN] position of the character preceding truncation character
    WCHAR      characterBefore,        // [IN] character preceding truncation character
    long       widthBefore,            // [IN] width of the character preceding truncation character
    long       widthCut,               // [IN] distance from the right margin to the end of truncation character
    BOOL       *truncateBeforeOkay     // [OUT] Should the line truncated before truncation character?
)
{
    //  Always truncate before the character exceeding the margin
    //
    *truncateBeforeOkay = TRUE;
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkCanBreakBeforeChar(
    POLS        ols,                // [IN] text imager instance
    BRKCLS      breakClass,         // [IN] class of the character
    BRKCOND     *condition          // [OUT] breaking condition before the character
)
{
    //  Break behind an inline object
    //
    //  The logic below follows Michel Suignard's breaking around object table
    //  (http://ie/specs/secure/trident/text/Line_Breaking.htm)

    switch (breakClass)
    {
        case 2 :    // Closing characters
        case 3 :    // No start ideographic
        case 4 :    // Exclamation/interrogation
            *condition = brkcondNever;
            break;

        case 8 :    // Ideographic
        case 13 :   // Slash
            *condition = brkcondPlease;
            break;

        default:
            *condition = brkcondCan;
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkCanBreakAfterChar(
    POLS        ols,                // [IN] text imager instance
    BRKCLS      breakClass,         // [IN] class of the character
    BRKCOND     *condition          // [OUT] breaking condition after the character
)
{
    //  Break before an inline object
    //
    //  The logic below follows Michel Suignard's breaking around object table
    //  (http://ie/specs/secure/trident/text/Line_Breaking.htm)

    switch (breakClass)
    {
        case 1 :    // Opening characters
            *condition = brkcondNever;
            break;
            
        case 8 :    // Ideographic
        case 13 :   // Slash
            *condition = brkcondPlease;
            break;

        default:
            *condition = brkcondCan;
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetHyphenInfo(
    POLS     ols,                // [IN] text imager instance
    PLSRUN   run,                // [IN] run
    DWORD    *kysr,              // [OUT] YSR hyphenation type see "lskysr.h"
    WCHAR    *ysrCharacter       // [OUT] string of changed character caused by YSR
)
{
    //  Not support YSR hyphenation
    //
    *kysr = kysrNil;
    *ysrCharacter = 0;
    return lserrNone;
}





////    Memory management
//
//

void* WINAPI FullTextImager::GdipLscbkNewPtr(
    POLS    ols,            // [IN] text imager instance
    DWORD   countBytes      // [IN] byte count to alloc
)
{
    return GpMalloc(countBytes);
}


void WINAPI FullTextImager::GdipLscbkDisposePtr(
    POLS     ols,        // [IN] text imager instance
    void     *memory     // [IN] memory block
)
{
    GpFree(memory);
}


void* WINAPI FullTextImager::GdipLscbkReallocPtr(
    POLS    ols,        // [IN] text imager instance
    void    *memory,    // [IN] memory block
    DWORD   countBytes  // [IN] byte count to realloc
)
{
    return GpRealloc(memory, countBytes);
}




////    Misc.
//
//

LSERR WINAPI FullTextImager::GdipLscbkCheckParaBoundaries(
    POLS    ols,                   // [IN] text imager instance
    LONG    positionFirst,         // [IN] position in one paragraph
    LONG    positionSecond,        // [IN] position in different paragraph
    BOOL    *incompatibleOkay      // [OUT] Are two paragraphs incompatible?
)
{
    //  For now, two paragraphs always compatible
    //
    *incompatibleOkay = FALSE;
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkReverseGetInfo(
    POLS        ols,                    // [IN] text imager instance
    LSCP        position,               // [IN] run character position
    PLSRUN      run,                    // [IN] run
    BOOL        *dontBreakAround,       // [OUT] should reverse chunk be broken around?
    BOOL        *suppressTrailingSpaces // [OUT] suppress trailing spaces?
)
{
    *dontBreakAround        = TRUE;
    *suppressTrailingSpaces = TRUE;

    return lserrNone;
}



//  Reversal object initialization info

const REVERSEINIT ReverseObjectInitialization =
{
    REVERSE_VERSION,
    WCH_OBJECTTERMINATOR,
    NULL,
    FullTextImager::GdipLscbkReverseGetInfo,
    NULL
};



LSERR WINAPI FullTextImager::GdipLscbkGetObjectHandlerInfo(
    POLS      ols,                    // [IN] text imager instance
    DWORD     id,                     // [IN] object id
    void      *objectInitialization   // [OUT] object initialization info
)
{
    if (id == OBJECTID_REVERSE)
        GpMemcpy(objectInitialization, &ReverseObjectInitialization, sizeof(REVERSEINIT));
    else
    {
        // We should never get here unless we support other built-in objects e.g. Ruby.
        //

        ASSERTMSG(FALSE, ("Built-in object other than the reverse is detected.\n"));
    }

    return lserrNone;
}


#if DBG
void WINAPI FullTextImager::GdipLscbkAssertFailed(
    char   *string,    // [IN] assert string
    char   *file,      // [IN] file string
    int    line        // [IN] line number
)
{
    char szDebug[256];

    wsprintfA(szDebug, "LS assert - %s, file %s, line %d\n", string, file, line);
    OutputDebugStringA(szDebug);
    ASSERT(FALSE);
}
#endif



extern const LSCBK GdipLineServicesCallbacks =
{
    FullTextImager::GdipLscbkNewPtr,                     // pfnNewPtr
    FullTextImager::GdipLscbkDisposePtr,                 // pfnDisposePtr
    FullTextImager::GdipLscbkReallocPtr,                 // pfnReallocPtr
    FullTextImager::GdipLscbkFetchRun,                   // pfnFetchRun
    0,//GdipLscbkGetAutoNumberInfo,                      // pfnGetAutoNumberInfo
    0,//GdipLscbkGetNumericSeparators,                   // pfnGetNumericSeparators
    0,//GdipLscbkCheckForDigit,                          // pfnCheckForDigit
    FullTextImager::GdipLscbkFetchPap,                   // pfnFetchPap
    FullTextImager::GdipLscbkFetchTabs,                  // pfnFetchTabs
    FullTextImager::GdipLscbkGetBreakThroughTab,         // pfnGetBreakThroughTab
    FullTextImager::GdipLscbkFGetLastLineJustification,  // pfnFGetLastLineJustification
    FullTextImager::GdipLscbkCheckParaBoundaries,        // pfnCheckParaBoundaries
    FullTextImager::GdipLscbkGetRunCharWidths,           // pfnGetRunCharWidths
    0,                                                   // pfnCheckRunKernability
    0,                                                   // pfnGetRunCharKerning
    FullTextImager::GdipLscbkGetRunTextMetrics,          // pfnGetRunTextMetrics
    FullTextImager::GdipLscbkGetRunUnderlineInfo,        // pfnGetRunUnderlineInfo
    FullTextImager::GdipLscbkGetRunStrikethroughInfo,    // pfnGetRunStrikethroughInfo
    0,                                                   // pfnGetBorderInfo
    FullTextImager::GdipLscbkReleaseRun,                 // pfnReleaseRun
    0,                                                   // pfnHyphenate
    FullTextImager::GdipLscbkGetHyphenInfo,              // pfnGetHyphenInfo
    FullTextImager::GdipLscbkDrawUnderline,              // pfnDrawUnderline
    FullTextImager::GdipLscbkDrawStrikethrough,          // pfnDrawStrikethrough
    0,                                                   // pfnDrawBorder
    0,                                                   // pfnDrawUnderlineAsText
    FullTextImager::GdipLscbkFInterruptUnderline,        // pfnFInterruptUnderline
    0,                                                   // pfnFInterruptShade
    0,                                                   // pfnFInterruptBorder
    0,                                                   // pfnShadeRectangle
    FullTextImager::GdipLscbkDrawTextRun,                // pfnDrawTextRun
    0,                                                   // pfnDrawSplatLine
    FullTextImager::GdipLscbkFInterruptShaping,          // pfnFInterruptShaping
    FullTextImager::GdipLscbkGetGlyphs,                  // pfnGetGlyphs
    FullTextImager::GdipLscbkGetGlyphPositions,          // pfnGetGlyphPositions
    FullTextImager::GdipLscbkResetRunContents,           // pfnResetRunContents
    FullTextImager::GdipLscbkDrawGlyphs,                 // pfnDrawGlyphs
    0,                                                   // pfnGetGlyphExpansionInfo
    0,                                                   // pfnGetGlyphExpansionInkInfo
    0,                                                   // pfnGetEms
    0,                                                   // pfnPunctStartLine
    0,                                                   // pfnModWidthOnRun
    0,                                                   // pfnModWidthSpace
    0,                                                   // pfnCompOnRun
    0,                                                   // pfnCompWidthSpace
    0,                                                   // pfnExpOnRun
    0,                                                   // pfnExpWidthSpace
    0,                                                   // pfnGetModWidthClasses
    FullTextImager::GdipLscbkGetBreakingClasses,         // pfnGetBreakingClasses
    FullTextImager::GdipLscbkFTruncateBefore,            // pfnFTruncateBefore
    FullTextImager::GdipLscbkCanBreakBeforeChar,         // pfnCanBreakBeforeChar
    FullTextImager::GdipLscbkCanBreakAfterChar,          // pfnCanBreakAfterChar
    0,                                                   // pfnFHangingPunct
    0,                                                   // pfnGetSnapGrid
    0,                                                   // pfnDrawEffects
    0,                                                   // pfnFCancelHangingPunct
    0,                                                   // pfnModifyCompAtLastChar
    0,                                                   // pfnEnumText
    0,                                                   // pfnEnumTab
    0,                                                   // pfnEnumPen
    FullTextImager::GdipLscbkGetObjectHandlerInfo,       // pfnGetObjectHandlerInfo
#if DBG
    FullTextImager::GdipLscbkAssertFailed                // pfnAssertFailed
#else
    0                                                    // pfnAssertFailed
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\itemizer.cpp ===
////    Itemizer - Analyse Unicode into script sequences
//
//      David C Brown [dbrown] 27th November 1999.
//
//      Copyright (c) 1999-2000, Microsoft Corporation. All rights reserved.


#include "precomp.hpp"




/////   Unicode block classification
//
//      See also ftp://ftp.unicode.org/Public/UNIDATA/Blocks.txt
//
//      The following table maps unicode blocks to scripts.
//
//      Where the script column contains '-' characters in this range are
//      ambiguous in script and will be classified as part of the previous
//      run.
//
//      The script column shows the script of all or most of the characters in
//      the block. Many blocks contain script ambiguous characters, and some
//      blocks contain characters from multiple scripts.
//
//      Start End   Block Name                             Script
//      0000  007F  Basic Latin                            ScriptLatin
//      0080  00FF  Latin-1 Supplement                     ScriptLatin
//      0100  017F  Latin Extended-A                       ScriptLatin
//      0180  024F  Latin Extended-B                       ScriptLatin
//      0250  02AF  IPA Extensions                         ScriptLatin
//      02B0  02FF  Spacing Modifier Letters               ScriptLatin
//      0300  036F  Combining Diacritical Marks            -
//      0370  03FF  Greek                                  ScriptGreek
//      0400  04FF  Cyrillic                               ScriptCyrillic
//      0530  058F  Armenian                               ScriptArmenian
//      0590  05FF  Hebrew                                 ScriptHebrew
//      0600  06FF  Arabic                                 ScriptArabic
//      0700  074F  Syriac                                 ScriptSyriac
//      0780  07BF  Thaana                                 ScriptThaana
//      0900  097F  Devanagari                             ScriptDevanagari
//      0980  09FF  Bengali                                ScriptBengali
//      0A00  0A7F  Gurmukhi                               ScriptGurmukhi
//      0A80  0AFF  Gujarati                               ScriptGujarati
//      0B00  0B7F  Oriya                                  ScriptOriya
//      0B80  0BFF  Tamil                                  ScriptTamil
//      0C00  0C7F  Telugu                                 ScriptTelugu
//      0C80  0CFF  Kannada                                ScriptKannada
//      0D00  0D7F  Malayalam                              ScriptMalayalam
//      0D80  0DFF  Sinhala                                ScriptSinhala
//      0E00  0E7F  Thai                                   ScriptThai
//      0E80  0EFF  Lao                                    ScriptLao
//      0F00  0FFF  Tibetan                                ScriptTibetan
//      1000  109F  Myanmar                                ScriptMyanmar
//      10A0  10FF  Georgian                               ScriptGeorgian
//      1100  11FF  Hangul Jamo                            ScriptHangul Jamo
//      1200  137F  Ethiopic                               ScriptEthiopic
//      13A0  13FF  Cherokee                               ScriptCherokee
//      1400  167F  Unified Canadian Aboriginal Syllabics  ScriptCanadian
//      1680  169F  Ogham                                  ScriptOgham
//      16A0  16FF  Runic                                  ScriptRunic
//      1780  17FF  Khmer                                  ScriptKhmer
//      1800  18AF  Mongolian                              ScriptMongolian
//      1E00  1EFF  Latin Extended Additional              ScriptLatin
//      1F00  1FFF  Greek Extended                         ScriptGreek
//      2000  206F  General Punctuation                    Various inc ScriptControl
//      2070  209F  Superscripts and Subscripts            -
//      20A0  20CF  Currency Symbols                       -
//      20D0  20FF  Combining Marks for Symbols            -
//      2100  214F  Letterlike Symbols                     -
//      2150  218F  Number Forms                           -
//      2190  21FF  Arrows                                 -
//      2200  22FF  Mathematical Operators                 -
//      2300  23FF  Miscellaneous Technical                -
//      2400  243F  Control Pictures                       -
//      2440  245F  Optical Character Recognition          -
//      2460  24FF  Enclosed Alphanumerics                 -
//      2500  257F  Box Drawing                            -
//      2580  259F  Block Elements                         -
//      25A0  25FF  Geometric Shapes                       -
//      2600  26FF  Miscellaneous Symbols                  -
//      2700  27BF  Dingbats                               -
//      2800  28FF  Braille Patterns                       ScriptBraille
//      2E80  2EFF  CJK Radicals Supplement                ScriptIdeographic
//      2F00  2FDF  Kangxi Radicals                        ScriptIdeographic
//      2FF0  2FFF  Ideographic Description Characters     ScriptIdeographic
//      3000  303F  CJK Symbols and Punctuation            -
//      3040  309F  Hiragana                               ScriptIdeographic
//      30A0  30FF  Katakana                               ScriptIdeographic
//      3100  312F  Bopomofo                               ScriptIdeographic
//      3130  318F  Hangul Compatibility Jamo              ScriptIdeographic
//      3190  319F  Kanbun                                 ScriptIdeographic
//      31A0  31BF  Bopomofo Extended                      ScriptIdeographic
//      3200  32FF  Enclosed CJK Letters and Months        -
//      3300  33FF  CJK Compatibility                      ScriptIdeographic
//      3400  4DB5  CJK Unified Ideographs Extension A     ScriptIdeographic
//      4E00  9FFF  CJK Unified Ideographs                 ScriptIdeographic
//      A000  A48F  Yi Syllables                           ScriptIdeographic
//      A490  A4CF  Yi Radicals                            ScriptIdeographic
//      AC00  D7A3  Hangul Syllables                       ScriptIdeographic
//      D800  DB7F  High Surrogates                        ScriptSurrogate
//      DB80  DBFF  High Private Use Surrogates            ScriptSurrogate
//      DC00  DFFF  Low Surrogates                         ScriptSurrogate
//      E000  F8FF  Private Use                            ScriptPrivate
//      F900  FAFF  CJK Compatibility Ideographs           ScriptIdeographic
//      FB00  FB4F  Alphabetic Presentation Forms          -
//      FB50  FDFF  Arabic Presentation Forms-A            ScriptArabic
//      FE20  FE2F  Combining Half Marks                   ScriptCombining
//      FE30  FE4F  CJK Compatibility Forms                ScriptIdeographic
//      FE50  FE6F  Small Form Variants                    -
//      FE70  FEFE  Arabic Presentation Forms-B            ScriptArabic
//      FEFF  FEFF  Specials                               -
//      FF00  FFEF  Halfwidth and Fullwidth Forms          Various
//      FFF0  FFFD  Specials                               -


CharacterAttribute CharacterAttributes[CHAR_CLASS_MAX] = {
//                                                                Script              ScriptClass       Flags
/*  WOB_ - Open Brackets for inline-note (JIS 1 or 19)        */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NOPP - Open parenthesis (JIS 1)                           */  {ScriptLatin,       WeakClass,        0},
/*  NOPA - Open parenthesis (JIS 1)                           */  {ScriptLatin,       WeakClass,        0},
/*  NOPW - Open parenthesis (JIS 1)                           */  {ScriptLatin,       WeakClass,        0},
/*  HOP_ - Open parenthesis (JIS 1)                           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOP_ - Open parenthesis (JIS 1)                           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOP5 - Open parenthesis, Big 5 (JIS 1)                    */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NOQW - Open quotes (JIS 1)                                */  {ScriptLatin,       WeakClass,        0},
/*  AOQW - Open quotes (JIS 1)                                */  {ScriptLatin,       WeakClass,        0},
/*  WOQ_ - Open quotes (JIS 1)                                */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCB_ - Close brackets for inline-note (JIS 2 or 20)       */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NCPP - Close parenthesis (JIS 2)                          */  {ScriptLatin,       WeakClass,        0},
/*  NCPA - Close parenthesis (JIS 2)                          */  {ScriptLatin,       WeakClass,        0},
/*  NCPW - Close parenthesis (JIS 2)                          */  {ScriptLatin,       WeakClass,        0},
/*  HCP_ - Close parenthesis (JIS 2)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCP_ - Close parenthesis (JIS 2)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCP5 - Close parenthesis, Big 5 (JIS 2)                   */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NCQW - Close quotes (JIS 2)                               */  {ScriptLatin,       WeakClass,        0},
/*  ACQW - Close quotes (JIS 2)                               */  {ScriptLatin,       WeakClass,        0},
/*  WCQ_ - Close quotes (JIS 2)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  ARQW - Right single quotation mark (JIS 2)                */  {ScriptLatin,       WeakClass,        0},
/*  NCSA - Comma (JIS 2 or 15)                                */  {ScriptLatin,       WeakClass,        0},
/*  HCO_ - Comma (JIS 2 or 15)                                */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WC__ - Comma (JIS 2)                                      */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCS_ - Comma (JIS 2)                                      */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WC5_ - Comma, Big 5 (JIS 2)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WC5S - Comma, Big 5 (JIS 2)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NKS_ - Kana sound marks (JIS 3)                           */  {ScriptKana,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKSM - Kana sound marks (JIS 3)                           */  {ScriptKana,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WIM_ - Iteration marks (JIS 3)                            */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NSSW - Symbols which can?t start a line (JIS 3)           */  {ScriptLatin,       WeakClass,        0},
/*  WSS_ - Symbols that can?t start a line (JIS 3)            */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WHIM - Hiragana iteration marks (JIS 3)                   */  {ScriptHiragana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKIM - Katakana iteration marks (JIS 3)                   */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKSL - Katakana that can?t start a line (JIS 3)           */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKS_ - Katakana that can?t start a line (JIS 3)           */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKSC - Katakana that can?t start a line (JIS 3)           */  {ScriptKatakana,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  WHS_ - Hiragana that can?t start a line (JIS 3)           */  {ScriptHiragana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NQFP - Question/Exclamation (JIS 4)                       */  {ScriptLatin,       WeakClass,        0},
/*  NQFA - Question/Exclamation (JIS 4)                       */  {ScriptLatin,       WeakClass,        0},
/*  WQE_ - Question/Exclamation (JIS 4)                       */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WQE5 - Question/Exclamation, Big 5 (JIS 4)                */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NKCC - Kana centered characters (JIS 5)                   */  {ScriptKana,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WKC_ - Kana centered characters (JIS 5)                   */  {ScriptKana,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NOCP - Other centered characters (JIS 5)                  */  {ScriptLatin,       WeakClass,        0},
/*  NOCA - Other centered characters (JIS 5)                  */  {ScriptLatin,       WeakClass,        0},
/*  NOCW - Other centered characters (JIS 5)                  */  {ScriptLatin,       WeakClass,        0},
/*  WOC_ - Other centered characters (JIS 5)                  */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOCS - Other centered characters (JIS 5)                  */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOC5 - Other centered characters, Big 5 (JIS 5)           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOC6 - Other centered characters, Big 5 (JIS 5)           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  AHPW - Hyphenation point (JIS 5)                          */  {ScriptLatin,       WeakClass,        0},
/*  NPEP - Period (JIS 6 or 15)                               */  {ScriptLatin,       WeakClass,        0},
/*  NPAR - Period (JIS 6 or 15)                               */  {ScriptLatin,       StrongClass,      0},
/*  HPE_ - Period (JIS 6 or 15)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WPE_ - Period (JIS 6)                                     */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WPES - Period (JIS 6)                                     */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WPE5 - Period, Big 5 (JIS 6)                              */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NISW - Inseparable characters (JIS 7)                     */  {ScriptLatin,       WeakClass,        0},
/*  AISW - Inseparable characters (JIS 7)                     */  {ScriptLatin,       WeakClass,        0},
/*  NQCS - Glue characters (no JIS)                           */  {ScriptLatin,       StrongClass,      0},
/*  NQCW - Glue characters (no JIS)                           */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NQCC - Glue characters (no JIS)                           */  {ScriptLatin,       SimpleMarkClass,  CHAR_FLAG_NOTSIMPLE},
/*  NPTA - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  NPNA - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  NPEW - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  NPEH - Prefix currencies and symbols (JIS 8)              */  {ScriptHebrew,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NPEV - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       StrongClass,      0},
/*  APNW - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  HPEW - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  WPR_ - Prefix currencies and symbols (JIS 8)+B58          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NQEP - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  NQEW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  NQNW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  AQEW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  AQNW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  AQLW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       StrongClass,      0},
/*  WQO_ - Postfix currencies and symbols (JIS 9)             */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NSBL - Space(JIS 15 or 17)                                */  {ScriptLatin,       WeakClass,        0},
/*  WSP_ - Space (JIS 10)                                     */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WHI_ - Hiragana except small letters (JIS 11)             */  {ScriptHiragana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKA_ - Katakana except small letters Ideographic (JIS 12) */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKA_ - Katakana except small letters (JIS 12)             */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  ASNW - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       WeakClass,        0},
/*  ASEW - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       WeakClass,        0},
/*  ASRN - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       StrongClass,      0},
/*  ASEN - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       StrongClass,      0},
/*  ALA_ - Ambiguous Latin (JIS 12 or 18)                     */  {ScriptLatin,       StrongClass,      0},
/*  AGR_ - Ambiguous Greek (JIS 12 or 18)                     */  {ScriptLatin,       StrongClass,      0},
/*  ACY_ - Ambiguous Cyrillic (JIS 12 or 18)                  */  {ScriptLatin,       StrongClass,      0},
/*  WID_ - Han Ideographs (JIS 12, 14S or 14D)                */  {ScriptHan,         StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WPUA - End user defined characters (JIS 12, 14S or 14D)   */  {ScriptPrivate,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NHG_ - Hangul Ideographs (JIS 12)                         */  {ScriptHangul,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WHG_ - Hangul Ideographs (JIS 12)                         */  {ScriptHangul,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WCI_ - Compatibility Ideographs (JIS 12)                  */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NOI_ - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOI_ - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOIC - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  WOIL - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WOIS - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOIT - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NSEN - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       StrongClass,      0},
/*  NSET - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       WeakClass,        0},
/*  NSNW - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       WeakClass,        0},
/*  ASAN - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       StrongClass,      0},
/*  ASAE - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       StrongClass,      0},
/*  NDEA - Digits (JIS 15 or 18)                              */  {ScriptLatin,       DigitClass,       CHAR_FLAG_DIGIT},
/*  WD__ - Digits (JIS 15 or 18)                              */  {ScriptLatin,       StrongClass,      0},
/*  NLLA - Basic Latin (JIS 16 or 18)                         */  {ScriptLatin,       StrongClass,      0},
/*  WLA_ - Basic Latin (JIS 16 or 18)                         */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NWBL - Word breaking Spaces (JIS 17)                      */  {ScriptLatin,       WeakClass,        0},
/*  NWZW - Word breaking Spaces (JIS 17)                      */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NPLW - Punctuation in Text (JIS 18)                       */  {ScriptLatin,       StrongClass,      0},
/*  NPZW - Punctuation in Text (JIS 18)                       */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NPF_ - Punctuation in Text (JIS 18)                       */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NPFL - Punctuation in Text (JIS 18)                       */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NPNW - Punctuation in Text (JIS 18)                       */  {ScriptLatin,       WeakClass,        0},
/*  APLW - Punctuation in text (JIS 12 or 18)                 */  {ScriptLatin,       StrongClass,      0},
/*  APCO - Punctuation in text (JIS 12 or 18)                 */  {ScriptLatin,       SimpleMarkClass,  CHAR_FLAG_NOTSIMPLE},
/*  ASYW - Soft Hyphen (JIS 12 or 18)                         */  {ScriptLatin,       WeakClass,        0},
/*  NHYP - Hyphen (JIS 18)                                    */  {ScriptLatin,       WeakClass,        0},
/*  NHYW - Hyphen (JIS 18)                                    */  {ScriptLatin,       WeakClass,        0},
/*  AHYW - Hyphen (JIS 12 or 18)                              */  {ScriptLatin,       WeakClass,        0},
/*  NAPA - Apostrophe (JIS 18)                                */  {ScriptLatin,       WeakClass,        0},
/*  NQMP - Quotation mark (JIS 18)                            */  {ScriptLatin,       WeakClass,        0},
/*  NSLS - Slash (JIS 18)                                     */  {ScriptLatin,       WeakClass,        0},
/*  NSF_ - Non space word break (JIS 18)                      */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NSBB - Non space word break (JIS 18)                      */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NSBS - Non space word break (JIS 18)                      */  {ScriptLatin,       WeakClass,        0},
/*  NLA_ - Latin (JIS 18)                                     */  {ScriptLatin,       StrongClass,      0},
/*  NLQ_ - Latin Punctuation in text (JIS 18)                 */  {ScriptLatin,       StrongClass,      0},
/*  NLQC - Latin Punctuation in text (JIS 18)                 */  {ScriptLatin,       StrongClass,      0},
/*  NLQN - Latin Punctuation in text (JIS 18)                 */  {ScriptLatin,       WeakClass,        0},
/*  ALQ_ - Latin Punctuation in text (JIS 12 or 18)           */  {ScriptLatin,       WeakClass,        0},
/*  ALQN - Latin Punctuation in text (JIS 12 or 18)           */  {ScriptLatin,       WeakClass,        0},
/*  NGR_ - Greek (JIS 18)                                     */  {ScriptGreek,       StrongClass,      0},
/*  NGRN - Greek (JIS 18)                                     */  {ScriptGreek,       WeakClass,        0},
/*  NGQ_ - Greek Punctuation in text (JIS 18)                 */  {ScriptGreek,       StrongClass,      0},
/*  NGQN - Greek Punctuation in text (JIS 18)                 */  {ScriptGreek,       StrongClass,      0},
/*  NCY_ - Cyrillic (JIS 18)                                  */  {ScriptCyrillic,    StrongClass,      0},
/*  NCYP - Cyrillic Punctuation in text (JIS 18)              */  {ScriptCyrillic,    StrongClass,      0},
/*  NCYC - Cyrillic Punctuation in text (JIS 18)              */  {ScriptCyrillic,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NAR_ - Armenian (JIS 18)                                  */  {ScriptArmenian,    StrongClass,      0},
/*  NAQL - Armenian Punctuation in text (JIS 18)              */  {ScriptArmenian,    StrongClass,      0},
/*  NAQN - Armenian Punctuation in text (JIS 18)              */  {ScriptArmenian,    StrongClass,      0},
/*  NHB_ - Hebrew (JIS 18)                                    */  {ScriptHebrew,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NHBC - Hebrew (JIS 18)                                    */  {ScriptHebrew,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NHBW - Hebrew (JIS 18)                                    */  {ScriptHebrew,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NHBR - Hebrew (JIS 18)                                    */  {ScriptHebrew,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NASR - Arabic (JIS 18)                                    */  {ScriptArabic,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NAAR - Arabic (JIS 18)                                    */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NAAC - Arabic (JIS 18)                                    */  {ScriptArabic,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NAAD - Arabic (JIS 18)                                    */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NAED - Arabic (JIS 18)                                    */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NANW - Arabic (JIS 18)                                    */  {ScriptArabic,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NAEW - Arabic (JIS 18)                                    */  {ScriptArabic,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NAAS - Arabic (JIS 18)                                    */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NHI_ - Devanagari (JIS 18)                                */  {ScriptDevanagari,  StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NHIN - Devanagari (JIS 18)                                */  {ScriptDevanagari,  StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NHIC - Devanagari (JIS 18)                                */  {ScriptDevanagari,  ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NHID - Devanagari (JIS 18)                                */  {ScriptDevanagari,  StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBE_ - Bengali (JIS 18)                                   */  {ScriptBengali,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBEC - Bengali (JIS 18)                                   */  {ScriptBengali,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NBED - Bengali (JIS 18)                                   */  {ScriptBengali,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBET - Bengali (JIS 18)                                   */  {ScriptBengali,     WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NGM_ - Gurmukhi (JIS 18)                                  */  {ScriptGurmukhi,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NGMC - Gurmukhi (JIS 18)                                  */  {ScriptGurmukhi,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NGMD - Gurmukhi (JIS 18)                                  */  {ScriptGurmukhi,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NGJ_ - Gujarati (JIS 18)                                  */  {ScriptGujarati,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NGJC - Gujarati (JIS 18)                                  */  {ScriptGujarati,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NGJD - Gujarati (JIS 18)                                  */  {ScriptGujarati,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NOR_ - Oriya (JIS 18)                                     */  {ScriptOriya,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NORC - Oriya (JIS 18)                                     */  {ScriptOriya,       ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NORD - Oriya (JIS 18)                                     */  {ScriptOriya,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTA_ - Tamil (JIS 18)                                     */  {ScriptTamil,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTAC - Tamil (JIS 18)                                     */  {ScriptTamil,       ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTAD - Tamil (JIS 18)                                     */  {ScriptTamil,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTE_ - Telugu (JIS 18)                                    */  {ScriptTelugu,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTEC - Telugu (JIS 18)                                    */  {ScriptTelugu,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTED - Telugu (JIS 18)                                    */  {ScriptTelugu,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKD_ - Kannada (JIS 18)                                   */  {ScriptKannada,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKDC - Kannada (JIS 18)                                   */  {ScriptKannada,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NKDD - Kannada (JIS 18)                                   */  {ScriptKannada,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMA_ - Malayalam (JIS 18)                                 */  {ScriptMalayalam,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMAC - Malayalam (JIS 18)                                 */  {ScriptMalayalam,   ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NMAD - Malayalam (JIS 18)                                 */  {ScriptMalayalam,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTH_ - Thai (JIS 18)                                      */  {ScriptThai,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTHC - Thai (JIS 18)                                      */  {ScriptThai,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTHD - Thai (JIS 18)                                      */  {ScriptThai,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTHT - Thai (JIS 18)                                      */  {ScriptThai,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NLO_ - Lao (JIS 18)                                       */  {ScriptLao,         StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NLOC - Lao (JIS 18)                                       */  {ScriptLao,         ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NLOD - Lao (JIS 18)                                       */  {ScriptLao,         StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTI_ - Tibetan (JIS 18)                                   */  {ScriptTibetan,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTIC - Tibetan (JIS 18)                                   */  {ScriptTibetan,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTID - Tibetan (JIS 18)                                   */  {ScriptTibetan,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTIN - Tibetan (JIS 18)                                   */  {ScriptTibetan,     WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NGE_ - Georgian (JIS 18)                                  */  {ScriptGeorgian,    StrongClass,      0},
/*  NGEQ - Georgian Punctuation in text (JIS 18)              */  {ScriptGeorgian,    StrongClass,      0},
/*  NBO_ - Bopomofo (JIS 18)                                  */  {ScriptBopomofo,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBSP - No Break space (no JIS)                            */  {ScriptLatin,       WeakClass,        0},
/*  NBSS - No Break space (no JIS)                            */  {ScriptLatin,       WeakClass,        0},
/*  NOF_ - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOBS - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOEA - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NONA - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NONP - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NOEP - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NONW - Other symbols (JIS 18)                             */  {ScriptLatin,       StrongClass,      0},
/*  NOEW - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NOLW - Other symbols (JIS 18)                             */  {ScriptLatin,       StrongClass,      0},
/*  NOCO - Other symbols (JIS 18)                             */  {ScriptLatin,       SimpleMarkClass,  CHAR_FLAG_NOTSIMPLE},
/*  NOEN - Other symbols (JIS 18)                             */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NOBN - Other symbols (JIS 18)                             */  {ScriptLatin,       ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NSBN - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOLE - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NORE - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOPF - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOLO - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NORO - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NET_ - Ethiopic                                           */  {ScriptEthiopic,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NETP - Ethiopic                                           */  {ScriptEthiopic,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NETD - Ethiopic                                           */  {ScriptEthiopic,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NCA_ - Canadian Syllabics                                 */  {ScriptCanadian,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NCH_ - Cherokee                                           */  {ScriptCherokee,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WYI_ - Yi                                                 */  {ScriptYi,          StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WYIN - Yi                                                 */  {ScriptYi,          WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NBR_ - Braille                                            */  {ScriptBraille,     WeakClass,        0},
/*  NRU_ - Runic                                              */  {ScriptRunic,       StrongClass,      0},
/*  NOG_ - Ogham                                              */  {ScriptOgham,       StrongClass,      0},
/*  NOGS - Ogham                                              */  {ScriptLatin,       WeakClass,        0},
/*  NOGN - Ogham                                              */  {ScriptOgham,       WeakClass,        0},
/*  NSI_ - Sinhala                                            */  {ScriptSinhala,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NSIC - Sinhala                                            */  {ScriptSinhala,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTN_ - Thaana                                             */  {ScriptThaana,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTNC - Thaana                                             */  {ScriptThaana,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NKH_ - Khmer                                              */  {ScriptKhmer,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKHC - Khmer                                              */  {ScriptKhmer,       ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NKHD - Khmer                                              */  {ScriptKhmer,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKHT - Khmer                                              */  {ScriptKhmer,       WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NBU_ - Myanmar                                            */  {ScriptMyanmar,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBUC - Myanmar                                            */  {ScriptMyanmar,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NBUD - Myanmar                                            */  {ScriptMyanmar,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NSY_ - Syriac                                             */  {ScriptSyriac,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NSYP - Syriac                                             */  {ScriptSyriac,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NSYC - Syriac                                             */  {ScriptSyriac,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NSYW - Syriac                                             */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMO_ - Mongolian                                          */  {ScriptMongolian,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMOC - Mongolian                                          */  {ScriptMongolian,   ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NMOD - Mongolian                                          */  {ScriptMongolian,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMOB - Mongolian                                          */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NMON - Mongolian                                          */  {ScriptMongolian,   WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NHS_ - High Surrogate                                     */  {ScriptSurrogate,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WHT_ - High Surrogate                                     */  {ScriptSurrogate,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  LS__ - Low Surrogate                                      */  {ScriptSurrogate,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  XNW_ - Unassigned                                         */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  XNWA - Unassigned                                         */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  XNWB - Unassigned                                         */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},

/* CHAR_GCP_R                                                 */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/* CHAR_GCP_EN                                                */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/* CHAR_GCP_AN                                                */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/* CHAR_GCP_HN                                                */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
};



















/////   Itemization finite state machine
//
//      States:
//
//          <all scripts>
//


Status ItemizationFiniteStateMachine(
    IN  const WCHAR            *string,
    IN  INT                     length,
    IN  INT                     state,      // Initial state
    OUT SpanVector<GpTextItem> *textItemSpanVector,
    OUT INT                    *flags       // Combined flags of all items
)
{
    GpStatus status = Ok;
    GpTextItem previousClass(
        ScriptLatin,
        state
    );

    INT  previousStart = 0;
    INT  i             = 0;

    *flags = 0;

    INT              ch;
    CHAR_CLASS       characterClass;
    ItemScriptClass  scriptClass;
    ItemScript       script;

    INT fastLimit = -1;
    DoubleWideCharMappedString dwchString(string, length);

    INT combinedFlags = 0;

    // Fast loop - handles only strongltr and weak class groups

    while (    i < length
           &&  fastLimit < 0)
    {
        ch             = dwchString[i];

        characterClass = CharClassFromCh(ch);
        scriptClass    = CharacterAttributes[characterClass].ScriptClass;
        combinedFlags |= CharacterAttributes[characterClass].Flags;

        switch (scriptClass)
        {
        case StrongClass:
            script = CharacterAttributes[characterClass].Script;
            if (previousClass.Script != script)
            {
                if (i > 0)
                {
                    status = textItemSpanVector->SetSpan(
                        previousStart,
                        i - previousStart,
                        previousClass
                    );
                    if (status != Ok)
                        return status;
                    previousStart = i;
               }
                previousClass.Script = script;
                previousClass.Flags  = 0;
           }
            break;

        case WeakClass:
            break;

        case DigitClass:
            previousClass.Flags |= ItemDigits;
            break;

        default:
            // Break out of fast loop.
            fastLimit = i;
            i = length;
            break;
       }

        i++;
   }


    if (fastLimit >= 0)
    {
        // Finish the job in the full loop

        INT  nextStart     = 0;
        INT  lastJoiner    = -1;
        INT  lastZWJ       = -1;
        INT  lastWeak      = -1;  // Position of last weak encountered

        i = fastLimit;

        if (i>0) {
            // Set lastWeak appropriately
            ch             = dwchString[i-1];

            characterClass = CharClassFromCh(ch);
            if (CharacterAttributes[characterClass].ScriptClass == WeakClass)
            {
                lastWeak = i-1;
           }
       }
        else
        {
            // Full loop starts at start of string
            previousStart = -1;
       }

        while (i < length)
        {
            ch             = dwchString[i];

            characterClass = CharClassFromCh(ch);
            scriptClass    = CharacterAttributes[characterClass].ScriptClass;
            script         = CharacterAttributes[characterClass].Script;
            combinedFlags |= CharacterAttributes[characterClass].Flags;


            // Process classes appropriately
            // Set nextStart if a new run is to be started

            if (    previousClass.Script == ScriptControl
                &&  script != ScriptControl)
            {
                nextStart = i;
           }
            else
            {
                switch (scriptClass)
                {
                case StrongClass:
                    if (previousClass.Script != script)
                    {
                        nextStart = i;
                   }
                    break;

                case WeakClass:
                    lastWeak = i;
                    break;

                case DigitClass:
                    previousClass.Flags |= ItemDigits;
                    break;

                case SimpleMarkClass:
                    previousClass.Flags |= ItemCombining;
                    break;

                case ComplexMarkClass:
                    if (    previousClass.Script != script
                        &&  (    previousClass.Script != ScriptSyriac
                             ||  script != ScriptArabic))
                    {
                        if (    lastJoiner == i-1   // Special case for weak,ZWJ,mark
                            &&  lastWeak   == i-2)
                        {
                            nextStart = lastWeak;
                            if (nextStart <= previousStart)
                            {
                                previousClass.Script = script;
                           }
                       }
                        else
                        {
                            nextStart = i;
                       }
                   }
                    break;

                case ControlClass:
                    if (previousClass.Script != ScriptControl)
                    {
                        nextStart = i;
                   }
                    break;

                case JoinerClass:
                    lastJoiner = i;
                    previousClass.Flags |= ItemZeroWidth;
                    if (ch == U_ZWJ)    // Zero width joiner
                    {
                        lastZWJ = i;
                   }
                    break;

                default:
                    if (previousClass.Script == ScriptControl)
                    {
                        nextStart = i;
                   }
               }
           }

            if (nextStart > previousStart)
            {
                if (previousStart >= 0)
                {
                    status = textItemSpanVector->SetSpan(
                        previousStart,
                        nextStart - previousStart,
                        previousClass
                    );
                    if (status != Ok)
                        return status;
               }
                previousClass.Script = script;
                *flags |= previousClass.Flags;
                previousClass.Flags = 0;
                previousStart = nextStart;

                if (lastZWJ == nextStart-1)
                {
                    previousClass.State |= LeadingJoin;
               }
                else
                {
                    previousClass.State &= ~LeadingJoin;
               }
           }

            i++;
       }
   }




    // Final item

    if (length > previousStart)
    {
        status = textItemSpanVector->SetSpan(
            previousStart,
            length - previousStart,
            previousClass
        );
   }

    *flags = combinedFlags;

    return status;
}






/////  SecondaryItemization
//
//      Itemizes for secondary classification requirements:
//
//      - Mirrored glyphs (in RTL runs only)
//      - Numerics (for digit substitution only)
//      - Auto sideways (for vertical run only)


enum SecondaryItemizationState {
    Sstart,
    SleadET,
    Snumeric,
    StrailCS,
    SmirSub,
    SmirXfm,
    Ssideways
};

enum SecondaryItemizationAction {
    SeNone = 0,
    SeMark,
    SePlain,
    SePlainToM,
    SeNum,
    SeNumToM,
    SeMirSub,
    SeMirXfm,
    SeSideways
};


SecondaryItemizationState NextState[7][7] = {
//                 Sstart     SleadET    Snumeric   StrailCS   SmirSub    SmirXfm    Ssideways
/*ScOther      */ {Sstart,    Sstart,    Sstart,    Sstart,    Sstart,    Sstart,    Sstart},
/*ScSideways   */ {Ssideways, Ssideways, Ssideways, Ssideways, Ssideways, Ssideways, Ssideways},
/*ScMirrorSubst*/ {SmirSub,   SmirSub,   SmirSub,   SmirSub,   SmirSub,   SmirSub,   SmirSub},
/*ScMirrorXfrom*/ {SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm},
/*ScEN         */ {Snumeric,  Snumeric,  Snumeric,  Snumeric,  Snumeric,  Snumeric,  Snumeric},
/*ScCS         */ {Sstart,    Sstart,    StrailCS,  Sstart,    Sstart,    Sstart,    Sstart},
/*ScET         */ {SleadET,   SleadET,   Snumeric,  Sstart,    Sstart,    Sstart,    Sstart}
};

SecondaryItemizationAction NextAction[7][7] = {
//                 Sstart     SleadET    Snumeric   StrailCS   SmirSub    SmirXfm    Ssideways
/*ScOther      */ {SeNone,    SeNone,    SeNum,     SeNumToM,  SeMirSub,  SeMirXfm,  SeSideways},
/*ScSideways   */ {SePlain,   SePlain,   SeNum,     SeNumToM,  SeMirSub,  SeMirXfm,  SeNone},
/*ScMirrorSubst*/ {SePlain,   SePlain,   SeNum,     SeNumToM,  SeNone,    SeMirXfm,  SeSideways},
/*ScMirrorXfrom*/ {SePlain,   SePlain,   SeNum,     SeNumToM,  SeMirSub,  SeNone,    SeSideways},
/*ScEN         */ {SePlain,   SePlainToM,SeNone,    SeNone,    SeMirSub,  SeMirXfm,  SeSideways},
/*ScCS         */ {SeNone,    SeNone,    SeMark,    SeNumToM,  SeMirSub,  SeMirXfm,  SeSideways},
/*ScET         */ {SeMark,    SeNone,    SeNone,    SeNumToM,  SeMirSub,  SeMirXfm,  SeSideways}
};



//+----------------------------------------------------------------------------
//
//  SecondaryCharClass
//
//  Entry   ch - 32 bit Unicode codepoint for classification
//
//  Return  Character secondary classification
//
//-----------------------------------------------------------------------------

const BYTE SecondaryCharClass(INT ch)
{
    // either Unicode plane 0 or in surrogate range
    assert(ch <= 0x10FFFF);

    // Plane 0 codepoint
    if( ch <= 0xFFFF)
    {
        return SecondaryClassificationLookup[ch >> 8][ch & 0xFF];
    }
    else if((ch >= 0x020000) && (ch <= 0x03FFFF))
    {
        // Though, we don't have an official assignment here yet,
        // Uniscribe used to handle this area as CJK extension
        return ScNNFN; // FE upright character
    }
    else
    {
        // Currently, we don't have any plane1 or higher allocation.
        // Let's treat it as unassigned codepoint.
        return ScNNNN; // No special handling
    }
}




GpStatus SecondaryItemization(
    IN    const WCHAR            *string,
    IN    INT                     length,
    IN    ItemScript              numericScript,
    IN    INT                     mask,
    IN    BYTE                    defaultLevel,
    IN    BOOL                    isMetaRecording,
    OUT   SpanVector<GpTextItem> *textItemSpanVector  // InOut
)
{
    GpStatus status = Ok;
    INT   secondaryClass;
    INT   lastStrongCharacter = 0; // INT since we might be dealing with surrogate

    GpCharacterClass lastCharacterClass       = CLASS_INVALID;
    GpCharacterClass lastStrongCharacterClass = CLASS_INVALID;

    SpanRider<GpTextItem> itemRider(textItemSpanVector);

    INT mark = -1;

    SecondaryItemizationState state = Sstart;

    INT runStart = 0;
    INT charIndex = 0;

    // We need to index to the end of the string + 1 so that
    // the end-state is set properly...
    while(charIndex <= length)
    {
        // start out with the code-point as the wchar - we might
        // have to make this a surrogate code-point from 2 wchars
        int c = 0;
        BOOL fSurrogate = FALSE; // we will need to increment after the run...
        
        if (charIndex < length)
        {
            // Don't index past the end of the string...
            c = string[charIndex];

            // Check for a high surrogate...
            if (c >= 0xD800 && c < 0xDC00)
            {
                if (charIndex+1 < length)
                {
                    WCHAR wcNext = string[charIndex+1];

                    if (wcNext >= 0xDC00 && wcNext < 0xE000)
                    {
                        // Translate this to the proper surrogate codepoint!
                        c = (((c & 0x3FF) << 10) | (wcNext & 0x3FF)) + 0x10000;

                        fSurrogate = TRUE;
                    }
                }

                // If the fSurrogate flag is not set at this point, then the
                // character will be treated as an independent run. Non-paired
                // surrogates are run-breaks.
            }

            BYTE baseClass = SecondaryCharClass(c);
            secondaryClass = ScFlagsToScFE[ScBaseToScFlags[baseClass] & mask];
            
            if (numericScript == ScriptContextNum)
            {
                // we get the overhead only if we have context numeric mode
                lastCharacterClass = s_aDirClassFromCharClass[CharClassFromCh(c)];

                if (AL == lastCharacterClass || R == lastCharacterClass || L == lastCharacterClass)
                {
                    lastStrongCharacterClass = lastCharacterClass;
                    lastStrongCharacter      = c;
                }
            }
        }
        else
        {
            // Force end state
            secondaryClass = ScOther;
        }

        SecondaryItemizationState  nextState = NextState[secondaryClass][state];
        SecondaryItemizationAction action    = NextAction[secondaryClass][state];

        if (action)
        {
            INT runLimit  = 0;
            INT flags     = 0;
            INT setScript = 0;

            switch (action)
            {
            case SeMark:      mark = charIndex;                                break;
            case SePlain:     runStart = charIndex;                            break;
            case SePlainToM:  runStart = mark;                                 break;
            case SeNum:       runLimit = charIndex; setScript = numericScript; break;
            case SeNumToM:    runLimit = mark;      setScript = numericScript; break;
            case SeMirSub:    runLimit = charIndex; setScript = ScriptMirror;  break;
            case SeMirXfm:    runLimit = charIndex; flags     = ItemMirror;    break;
            case SeSideways:  runLimit = charIndex; flags     = ItemSideways;  break;
            }

            if (runLimit > 0)
            {
                while (runStart < runLimit)
                {
                    itemRider.SetPosition(runStart);

                    UINT uniformLength = itemRider.GetUniformLength();

                    INT limit = (uniformLength < (UINT) (runLimit - runStart))
                                ? runStart + uniformLength
                                : runLimit;

                    GpTextItem item = itemRider.GetCurrentElement();

                    if ((item.Level & 1) == 0 || isMetaRecording) // Don't mirror in LTR runs or Meta file recording
                    {
                        flags &= ~ItemMirror;
                        if (setScript == ScriptMirror)
                        {
                            setScript = 0;
                        }
                    }

                    if (setScript)
                    {
                        if (setScript != ScriptContextNum)
                        {
                            item.Script = (ItemScript)setScript;
                        }
                        else 
                        {
                            if ((lastStrongCharacterClass == CLASS_INVALID && defaultLevel==1) ||
                                (item.Script == ScriptArabic) ||
                                (lastStrongCharacter == 0x200F)) // RLM
                            {
                                item.Script = ScriptArabicNum;
                            }
                            // otherwise keep item.Script as it is.
                        }
                    }

                    if (flags)
                    {
                        item.Flags |= flags;
                    }

                    if (setScript | flags)
                    {
                        status = itemRider.SetSpan(runStart, limit-runStart, item);
                        if (status != Ok)
                            return status;
                    }

                    runStart = limit;
                }
            }
        }

        // If this was a surrogate, we need to increment past the low
        // surrogate value...
        if (fSurrogate)
            charIndex++;

        // Move on to the next character...
        charIndex++;

        state = nextState;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\imager.hpp ===
#ifndef _IMAGER_HPP
#define _IMAGER_HPP






/////   EmptyTextImager
//
//      Provides text imager functions when the text is empty

class EmptyTextImager : public GpTextImager
{
public:
    EmptyTextImager() : GpTextImager() {}

    ~EmptyTextImager() {}

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin)
    {
        return Ok;
    }

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin)
    {
        return Ok;
    }

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL *nearGlyphEdge,
        REAL *farGlyphEdge,
        REAL *textDepth,
        INT *codepointsFitted,
        INT *linesFilled
    )
    {
        *nearGlyphEdge    = 0;
        *farGlyphEdge     = 0;
        *textDepth        = 0;

        if (codepointsFitted)
            *codepointsFitted = 0;

        if (linesFilled)
            *linesFilled = 0;

        return Ok;
    }

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    )
    {
        return Ok;
    }

    virtual Status GetStatus() const
    {
        return Ok;
    }
};



/*
///     SimpleTextImager
//
//      Provides text imager functions when the text is simple and all on
//      one line.
//
//      The client has already generated glyphs and widths by the time
//      it creates the imager, so the constructor takes these buffers
//      as parameters.

class SimpleTextImager : public GpTextImager
{
public:
    SimpleTextImager(
        const WCHAR          *string,
        INT                   length,
        REAL                  width,
        REAL                  height,
        REAL                  leftMargin,
        REAL                  rightMargin,
        const GpFontFamily   *family,
        const GpFontFace     *face,
        INT                   style,
        REAL                  emSize,
        const GpStringFormat *format,
        const GpBrush        *brush,
        GINDEX               *glyphs,
        UINT                  glyphCount,
        UINT16               *designAdvances,
        REAL                  totalWorldAdvance
    ) :
        GpTextImager(),
        String             (string),
        Length             (length),
        Width              (width),
        Height             (height),
        LeftMargin         (leftMargin),
        RightMargin        (rightMargin),
        Family             (family),
        Face               (face),
        Style              (style),
        EmSize             (emSize),
        Format             (format),
        Brush              (brush),
        Glyphs             (glyphs),
        GlyphCount         (glyphCount),
        GlyphAdvances      (NULL),
        TotalWorldAdvance  (totalWorldAdvance),
        Status             (Ok)
    {
        GlyphAdvances = new INT[GlyphCount];

        if (!GlyphAdvances)
        {
            Status = OutOfMemory;
            return;
        }

        WorldToIdeal        = TOREAL(2048.0 / emSize);
        REAL designEmHeight = face->GetDesignEmHeight();

        for (UINT i=0; i<glyphCount; i++)
        {
            GlyphAdvances[i] = GpRound(   designAdvances[i] * emSize * WorldToIdeal
                                       /  designEmHeight);
        }
    }

    ~SimpleTextImager()
    {
        delete [] Glyphs;
        if (GlyphAdvances)
        {
            delete [] GlyphAdvances;
        }
    }

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin);

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin);

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL       *nearGlyphEdge,
        REAL       *farGlyphEdge,
        REAL       *textDepth,
        INT        *codepointsFitted,
        INT        *linesFilled
    );

#ifndef DCR_REMOVE_OLD_174340
    virtual GpStatus MeasureRegion(
        INT           firstCharacterIndex,
        INT           characterCount,
        const PointF *origin,
        GpRegion     *region
    );
#endif

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    );

    virtual Status GetStatus() const {return Status;}

private:

    GpStatus MeasureRangeRegion(
        INT           firstCharacterIndex,
        INT           characterCount,
        const PointF *origin,
        GpRegion     *region
    );


    const WCHAR          *String;
    INT                   Length;
    REAL                  Width;        // Including margins
    REAL                  Height;
    REAL                  LeftMargin;
    REAL                  RightMargin;
    const GpFontFamily   *Family;
    const GpFontFace     *Face;
    INT                   Style;
    REAL                  EmSize;
    const GpStringFormat *Format;
    const GpBrush        *Brush;
    GINDEX               *Glyphs;
    UINT                  GlyphCount;
    INT                  *GlyphAdvances;
    GpStatus              Status;
    REAL                  WorldToIdeal;
    REAL                  TotalWorldAdvance;
};


*/


class EllipsisInfo
{
public:

    EllipsisInfo(
        const GpFontFace    *fontFace,
        REAL                emSize,
        INT                 style,
        double              designToIdeal,
        INT                 formatFlags
    );

    enum
    {
        MAX_ELLIPSIS = 3
    };

    WCHAR               String[MAX_ELLIPSIS];
    UINT16              Glyphs[MAX_ELLIPSIS];
    UINT16              GlyphMap[MAX_ELLIPSIS];
    UINT16              GlyphProperties[MAX_ELLIPSIS];
    INT                 GlyphAdvances[MAX_ELLIPSIS];
    Point               GlyphOffsets[MAX_ELLIPSIS];
    INT                 GlyphCount;

    INT                 Width;

    const GpFontFace    *Face;
    REAL                EmSize;
    GpTextItem          Item;
    INT                 FormatFlags;
};




//  Thai word breaking API initializer

extern "C" HRESULT WINAPI GdipThaiBreakingFunctionInitializer(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
);




/////   Visibility
//
//

enum Visibility
{
    VisibilityShow  = 0,
    VisibilityHide  = 1
};





/////   FullTextImager
//
//      This imager handles all TextImager functionality but has
//      more setup time and oiverhead than the FastTextImager.


class FullTextImager : public GpTextImager
{
friend class BuiltLine;
friend class GlyphImager;

public:

    FullTextImager(
        const WCHAR          *string,
        INT                   length,
        REAL                  width,
        REAL                  height,
        const GpFontFamily   *family,
        INT                   style,
        REAL                  size,
        const GpStringFormat *format,
        const GpBrush        *brush
    );

    virtual ~FullTextImager();

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin);

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin);

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL       *nearGlyphEdge,
        REAL       *farGlyphEdge,
        REAL       *textDepth,
        INT        *codepointsFitted,
        INT        *linesFilled
    );

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    );

    INT            GetLength() const {return Length;}
    virtual Status GetStatus() const {return Status;}

    GpStatus SetFamily(
        const GpFontFamily *family,
        INT                 first,
        INT                 length
    )
    {
        return FamilyVector.SetSpan(first, length, family);
    }

    GpStatus SetStyle(
        INT style,
        INT first,
        INT length
    )
    {
        return StyleVector.SetSpan(first, length, style);
    }

    GpStatus SetSize(
        REAL size,
        INT  first,
        INT  length
    )
    {
        return SizeVector.SetSpan(first, length, size);
    }

    GpStatus SetFormat(
        const GpStringFormat *format,
        INT                   first,
        INT                   length
    )
    {
        return FormatVector.SetSpan(first, length, format);
    }

    GpStatus SetBrush(
        const GpBrush *brush,
        INT            first,
        INT            length
    )
    {
        GpStatus status = BrushVector.SetSpan(first, length, brush);
        #if DBG
        BrushVector.Dump();
        #endif
        return status;
    }


    EllipsisInfo *GetEllipsisInfo ()
    {
        if (!Ellipsis)
        {
            const GpFontFace *fontFace = FamilyVector.GetDefault()->GetFace(
                                            StyleVector.GetDefault()
                                         );

            REAL emSize = SizeVector.GetDefault();

            double designToIdeal = (emSize * WorldToIdeal) / fontFace->GetDesignEmHeight();

            Ellipsis = new EllipsisInfo (
                            fontFace,
                            emSize,
                            StyleVector.GetDefault(),
                            designToIdeal,
                            GetFormatFlags()
                       );
        }
        return Ellipsis;
    }


private:

    GpStatus Status;

    WCHAR *String;
    INT    Length;

    // Imager dimensions in world units. When no size is specified for the
    // imager these values are zero.

    REAL   Width;               // Horizontal size in world units
    REAL   Height;              // Vertical size

    REAL   LineLengthLimit;     // Max allowable length of each text line
    REAL   TextDepthLimit;      // Max depth of accumulated lines


    /// WorldToIdeal - Line Services ideal resolution scale factor
    //
    //  Factor from world units to line services ideal units for this imager.
    //
    //  Line Services works with integers. This scale factor converts world
    //  units to integers such that the Line Services ideal units cover the
    //  length and depth of the imager.
    //
    //  If the imager is defined with a width and height, max(width,height)
    //  determines the scale factor. If the imager has no width and height,
    //  the scale factor is determined to allow up to 65,536 lines at this
    //  font height. (Since positions are 32 bit, this gives a placement
    //  grid of 1/65536 of character height).
    //
    //  !!! Is 65536 lines per imager and resolution 1/65536 of a line the
    //      right compromise?
    //
    //  Line Services coordinates are relative to the origin of the
    //  formatting area.
    //
    //  WorldToIdeal is a pure scale factor. There is no rotation or shearing
    //  involved. All values in ideal coordinates are relative to the
    //  origin of the text imager.

    REAL WorldToIdeal;

    // Client specified formatting spans (indexed by string offsets)

    SpanVector<const GpBrush*>        BrushVector;
    SpanVector<const GpFontFamily*>   FamilyVector;
    SpanVector<INT>                   StyleVector;
    SpanVector<REAL>                  SizeVector;
    SpanVector<const GpStringFormat*> FormatVector;
    SpanVector<UINT16>                LanguageVector;
    SpanVector<Paragraph*>            ParagraphVector;

    // Internal formatting spans (indexed by string offsets)

    SpanVector<GpTextItem>            TextItemVector;
    SpanVector<Break*>                BreakVector;
    SpanVector<BuiltLine*>            BuiltLineVector;
    SpanVector<INT>                   VisibilityVector;
    SpanVector<UINT32>                RangeVector;


    // Spans indexed by Line Services positions. Line Services sees text
    // with reversal barackets inserted at bidirectional level changes.

    SpanVector<PLSRUN>     RunVector;

    SpanRider<PLSRUN>      RunRider;
    SpanRider<Paragraph*>  ParagraphRider;

    // Partial build status. These variables track how far the run and
    // paragraph building process has progressed, and will increase through
    // the line building process.

    INT  HighLineServicesPosition;
    INT  HighStringPosition;

    // Completion status - these variables are only valid when all lines are
    // fully built.

    INT     LinesFilled;
    UINT32  CodepointsFitted;
    INT     LeftOrTopLineEdge;
    INT     RightOrBottomLineEdge;
    REAL    TextDepth;

    // Line services context - a line service context is only attached during
    // the line building process. At all other times this variable is NULL.

    ols *LineServicesOwner;

    //  Presentation handling - These variables are NULL at all times except
    //  during line display. During line display one, but not both of Graphics
    //  and Path will be set.

    GpGraphics *Graphics;
    GpPath     *Path;
    PointF      ImagerOrigin;    // In world coordinates
    INT         DefaultFontGridFitBaselineAdjustment;

    // The following BuiltLine pointer is set only during rendering. It is
    // used by the DrawGlyphs callback to determine the extent of the line
    // currently being displayed.

    const BuiltLine *CurrentBuiltLine;


    // Ellipsis display information

    EllipsisInfo    *Ellipsis;


    // Character class (partition) to breaking class mapping table
    //
    // This table can be initialized to either Narrow or Wide mapping
    // table defined in linebreakclass.cxx depend on the font being
    // used. We use "Wide" table for FE-dominant font.

    const unsigned short *BreakClassFromCharClass;


    // Itemization and run building

    GpStatus BidirectionalAnalysis();

    GpStatus MirroredNumericAndVerticalAnalysis(
        ItemScript numericScript
    );

    GpStatus BuildRunsFromTextItemsAndFormatting(
        IN  INT   stringStart,
        IN  INT   lineServiceStart,
        IN  INT   lineServicesLimit,
        OUT INT  *stringEnd,
        OUT INT  *lineServicesEnd
    );

    GpStatus FullTextImager::CreateLevelChangeRuns(
        IN  INT                  levelChange,
        IN  INT                  runLineServicesStart,
        IN  INT                  runStringStart,
        IN  const GpFontFamily  *family,
        IN  REAL                 size,
        IN  INT                  style,
        OUT INT                 *lineServicesDelta
    );

    GpStatus CreateTextRuns(
        INT                 runLineServicesStart,
        INT                 runStringStart,
        INT                 runLength,
        const GpTextItem   &item,
        INT                 formatFlags,
        const GpFontFamily *family,
        INT                 style,
        REAL                size
    );


    void GetFallbackFontSize(
        IN   const GpFontFace  *originalFace,
        IN   REAL               originalSize,   // em size
        IN   const GpFontFace  *fallbackFace,
        OUT  REAL              *fallbackSize,   // fallback em size
        OUT  REAL              *fallbackOffset  // fallback baseline offset (+=up)
    );


    void GetFontTransform(
        IN   REAL       fontScale,
        IN   BOOL       vertical,
        IN   BOOL       sideways,
        IN   BOOL       mirror,
        IN   BOOL       forcePath,
        OUT  GpMatrix&  fontTransform
    );


    GpStatus BuildRunsUpToAndIncluding(LSCP lineServicesPosition);

    GpStatus CheckInsertLevelChanges (
        SpanRider<BYTE>                 *levelRider,                // [IN] level rider at the string position
        SpanRider<const GpFontFamily *> *familyRider,               // [IN] font family rider at the string position
        SpanRider<INT>                  *styleRider,                // [IN] style rider at the string position
        SpanRider<REAL>                 *sizeRider,                 // [IN] size rider at the string position
        INT                              lineServicesPosition,      // [IN] correspondent Line Services position
        INT                             *newLineServicesPosition    // [OUT] new Line Services position if changed
    );


    GpStatus ReleaseVectors();

    GpStatus Itemize();
    GpStatus Render();

    GpStatus BuildLines();
    GpStatus BuildAllLines(StringTrimming trimming);
    GpStatus RebuildLines(StringTrimming trimming);

    GpStatus UpdateContentWithPathEllipsis(BOOL *contentChanged);


    GpStatus RenderLine (
        const BuiltLine    *builtLine,        // [IN] line to be rendered
        INT                 linePointOffset   // [IN] point offset to top of the line (in paragraph flow direction)
    );


    GpStatus MeasureRangeRegion(
        INT           firstCharacterIndex,
        INT           characterCount,
        const PointF *origin,
        GpRegion     *region
    );


    struct lsrun::Adjustment;

    GpStatus DrawGlyphs (
        const GpTextItem        *textItem,          // [IN] text item
        const GpFontFace        *fontFace,          // [IN] font face
        REAL                    emSize,             // [IN] requested em size (world unit)
        const WCHAR             *string,            // [IN] (optional) source string (null means imager's string)
        INT                     stringOffset,       // [IN] string offset relative to given string
        UINT                    stringLength,       // [IN] number of characters in the run string
        const GpStringFormat    *format,            // [IN] stringformat
        const INT               style,              // [IN] default font style
        INT                     formatFlags,        // [IN] formatting flags
        const UINT16            *glyphs,            // [IN] glyph index array
        GMAP                    *glyphMap,          // [IN] string to glyphs mapping
        const UINT16            *glyphProperties,   // [IN] glyph properties array
        const INT               *glyphAdvances,     // [IN] glyph advance width array
        const Point             *glyphOffsets,      // [IN] glyph offset array
        UINT                    glyphCount,         // [IN] number of glyphs
        const POINT             *pointOrigin,       // [IN] drawing origin (at baseline)
        INT                     totalWidth,         // [IN] glyphs total width
        lsrun::Adjustment       *adjust = NULL      // [OUT] (optional) display adjustment at edges
    );


    GpStatus GetCharacterProperties (
        ItemScript  script,                 // [IN] Script id
        LSCP        position,               // [IN] Line Services character position
        BOOL        *isWordStart,           // [OUT] Is it a start of word?
        BOOL        *isWordLast,            // [OUT] Is it the word's last character?
        BOOL        *isClusterStart = NULL  // [OUT] (optional) Is it at a cluster boundary?
    );



    /////   CP mapping
    //
    //

    LSCP LineServicesStringPosition (
        INT stringOffset    // [IN] String offset from 0
    );


    LSCP LineServicesStringPosition (
        const BuiltLine *line,          // [IN] line to query
        INT             stringOffset    // [IN] String offset relative to line start string position
    );


    GpStatus GetTextRun(
        INT     lineServicesStringOffset,   // [IN] Line Services string offset
        PLSRUN  *textRun                    // [OUT] result text run
    );



    INT             DefaultIncrementalTab;  // Default incremental tab
    Vector<LSTBD>   TabArray;               // Temporary buffer for user-defined tab stops
    Vector<UINT>    HotkeyPrefix;           // Position of hotkey prefix character


    // Tab functions

    GpStatus GetTabStops (
        INT     stringOffset,
        INT     *count,
        LSTBD   **tabStops,
        INT     *defaultTab
    );



    // Alignment

    StringAlignment GetFormatLineAlign(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return format ? format->GetLineAlign() : StringAlignmentNear;
    }


    StringAlignment GetFormatAlign(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return format ? format->GetAlign() : StringAlignmentNear;
    }


    // Hotkey options

    INT GetFormatHotkeyPrefix (const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return format ? format->GetHotkeyPrefix() : HotkeyPrefixNone;
    }


    // Trimming

    StringTrimming GetFormatTrimming (const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        StringTrimming trimming = DefaultTrimming;

        if (format)
        {
            format->GetTrimming(&trimming);
        }
        return trimming;
    }



    // Utility functions

    BOOL IsFormatVertical(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return      format
                &&  (   format->GetFormatFlags()
                     &  StringFormatFlagsDirectionVertical);
    }

    BOOL IsFormatRightToLeft(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return     format
               &&  (format->GetFormatFlags()
                    &  StringFormatFlagsDirectionRightToLeft);
    }

    BOOL IsFormatNoGDI(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return     format
               &&  (format->GetFormatFlags()
                    &  StringFormatFlagsPrivateNoGDI);
    }

    INT GetFormatFlags(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }
        return  format ? format->GetFormatFlags() : DefaultFormatFlags;
    }


    BYTE GetParagraphEmbeddingLevel()
    {
        const GpStringFormat *format = FormatVector.GetDefault();

        if (!format)
        {
            return 0;
        }

        INT formatFlags = format->GetFormatFlags();

        if (    formatFlags & StringFormatFlagsDirectionRightToLeft
            &&  !(formatFlags & StringFormatFlagsDirectionVertical))
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }


    INT GetAvailableRanges(const GpStringFormat *format = NULL);
    GpStatus CalculateDefaultFontGridFitBaselineAdjustment();



    GpStatus DrawHotkeyUnderline(
        const GpTextItem        *textItem,          // [IN] text item
        const GpFontFace        *fontFace,          // [IN] font face
        const PointF            *origin,            // [IN] origin at leading edge & baseline (in world unit)
        REAL                    emSize,             // [IN] em size (in world unit)
        UINT                    stringOffset,       // [IN] string offset
        UINT                    stringLength,       // [IN] string length
        UINT                    glyphCount,         // [IN] glyph count
        const GMAP              *glyphMap,          // [IN] glyph map
        const INT               *glyphAdvances,     // [IN] glyph advance width (ideal unit)
        INT                     trailingAdjust      // [IN] adjust for last glyph's advance width
    );


    union
    {
        struct
        {
            UINT    Dirty                               :1; // Has content changed since last update?
            UINT    TruncateLine                        :1; // ignore line breaking rule
            UINT    RecordDisplayPlacementsOnly         :1; // record glyph placement at rendering time
            UINT    InvalidRanges                       :1; // ignore character ranges
        };
        UINT Flags;
    };


public:

    // Line services callbacks.

    //  LS reversal implementation little back door!

    static LSERR (WINAPI GdipLscbkReverseGetInfo)(
        POLS        ols,                    // [IN] text imager instance
        LSCP        position,               // [IN] run character position
        PLSRUN      run,                    // [IN] run
        BOOL        *dontBreakAround,       // [OUT] should reverse chunk be broken around?
        BOOL        *suppressTrailingSpaces // [OUT] suppress trailing spaces?
    );



    // From LSCBK.H

    static void* (WINAPI GdipLscbkNewPtr)(POLS, DWORD);
    static void  (WINAPI GdipLscbkDisposePtr)(POLS, void*);
    static void* (WINAPI GdipLscbkReallocPtr)(POLS, void*, DWORD);


    static LSERR (WINAPI GdipLscbkFetchRun)(POLS, LSCP, LPCWSTR*, DWORD*, BOOL*, PLSCHP,
                                            PLSRUN*);
    /* FetchRun:
     *  pols (IN):
     *  cp (IN):
     *  &lpwchRun (OUT): run of characters.
     *  &cchRun (OUT): number of characters in run
     *  &fHidden (OUT) : hidden run?
     *  &lsChp (OUT): char properties of run
     *  &plsrun (OUT): abstract representation of run properties
     */

    static LSERR (WINAPI GdipLscbkGetAutoNumberInfo)(POLS, LSKALIGN*, PLSCHP, PLSRUN*,
                                                     WCHAR*, PLSCHP, PLSRUN*, BOOL*,
                                                     long*, long*);

    /* GetAutoNumberInfo:
     *  pols (IN):
     *  &lskalAnm (OUT):
     *  &lschpAnm (OUT): lschp for Anm
     *  &plsrunAnm (OUT): plsrun for Anm
     *  &wchAdd (OUT): character to add (Nil is treated as none)
     *  &lschpWch (OUT): lschp for added char
     *  &plsrunWch (OUT): plsrun for added char
     *  &fWord95Model(OUT):
     *  &duaSpaceAnm(OUT):  relevant iff fWord95Model
     *  &duaWidthAnm(OUT):  relevant iff fWord95Model
     */

    static LSERR (WINAPI GdipLscbkGetNumericSeparators)(POLS, PLSRUN, WCHAR*,WCHAR*);
    /* GetNumericSeparators:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  &wchDecimal (OUT): decimal separator for this run.
     *  &wchThousands (OUT): thousands separator for this run
     */

    static LSERR (WINAPI GdipLscbkCheckForDigit)(POLS, PLSRUN, WCHAR, BOOL*);
    /* GetNumericSeparators:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  wch (IN): character to check
     *  &fIsDigit (OUT): this character is digit
     */

    static LSERR (WINAPI GdipLscbkFetchPap)(POLS, LSCP, PLSPAP);
    /* FetchPap:
     *  pols (IN):
     *  cp (IN): an arbitrary cp value inside the paragraph
     *  &lsPap (OUT): Paragraph properties.
     */

    static LSERR (WINAPI GdipLscbkFetchTabs)(POLS, LSCP, PLSTABS, BOOL*, long*, WCHAR*);
    /* FetchTabs:
     *  pols (IN):
     *  cp (IN): an arbitrary cp value inside the paragraph
     *  &lstabs (OUT): tabs array
     *  &fHangingTab (OUT): there is hanging tab
     *  &duaHangingTab (OUT): dua of hanging tab
     *  &wchHangingTabLeader (OUT): leader of hanging tab
     */

    static LSERR (WINAPI GdipLscbkGetBreakThroughTab)(POLS, long, long, long*);
    /* GetBreakThroughTab:
     *  pols (IN):
     *  uaRightMargin (IN): right margin for breaking
     *  uaTabPos (IN): breakthrough tab position
     *  uaRightMarginNew (OUT): new right margin
     */

    static LSERR (WINAPI GdipLscbkFGetLastLineJustification)(POLS, LSKJUST, LSKALIGN,
                                                             ENDRES, BOOL*, LSKALIGN*);
    /* FGetLastLineJustification:
     *  pols (IN):
     *  lskj (IN): kind of justification for the paragraph
     *  lskal (IN): kind of alignment for the paragraph
     *  endr (IN): result of formatting
     *  &fJustifyLastLine (OUT): should last line be fully justified
     *  &lskalLine (OUT): kind of alignment for this line
     */

    static LSERR (WINAPI GdipLscbkCheckParaBoundaries)(POLS, LSCP, LSCP, BOOL*);
    /* CheckParaBoundaries:
     *  pols (IN):
     *  cpOld (IN):
     *  cpNew (IN):
     *  &fChanged (OUT): "Dangerous" change between paragraph properties.
     */

    static LSERR (WINAPI GdipLscbkGetRunCharWidths)(POLS, PLSRUN,
                                                    LSDEVICE, LPCWSTR,
                                                    DWORD, long, LSTFLOW,
                                                    int*,long*,long*);
    /* GetRunCharWidths:
     *  pols (IN):
     *  plsrun (IN):
     *  lsDeviceID (IN): presentation or reference
     *  lpwchRun (IN): run of characters
     *  cwchRun (IN): number of characters in run
     *  du (IN): available space for characters
     *  kTFlow (IN): text direction and orientation
     *  rgDu (OUT): widths of characters
     *  &duRun (OUT): sum of widths in rgDx[0] to rgDu[limDx-1]
     *  &limDu (OUT): number of widths fetched
     */

    static LSERR (WINAPI GdipLscbkCheckRunKernability)(POLS, PLSRUN,PLSRUN, BOOL*);
    /* CheckRunKernability:
     *  pols (IN):
     *  plsrunLeft (IN): 1st of pair of adjacent runs
     *  plsrunRight (IN): 2nd of pair of adjacent runs
     *  &fKernable (OUT) : if TRUE, Line Service may kern between these runs
     */

    static LSERR (WINAPI GdipLscbkGetRunCharKerning)(POLS, PLSRUN,
                                                     LSDEVICE, LPCWSTR,
                                                     DWORD, LSTFLOW, int*);
    /* GetRunCharKerning:
     *  pols (IN):
     *  plsrun (IN):
     *  lsDeviceID (IN): presentation or reference
     *  lpwchRun (IN): run of characters
     *  cwchRun (IN): number of characters in run
     *  kTFlow (IN): text direction and orientation
     *  rgDu (OUT): widths of characters
     */

    static LSERR (WINAPI GdipLscbkGetRunTextMetrics)(POLS, PLSRUN,
                                                     LSDEVICE, LSTFLOW, PLSTXM);
    /* GetRunTextMetrics:
     *  pols (IN):
     *  plsrun (IN):
     *  deviceID (IN):  presentation, reference, or absolute
     *  kTFlow (IN): text direction and orientation
     *  &lsTxMet (OUT): Text metrics
     */

    static LSERR (WINAPI GdipLscbkGetRunUnderlineInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
                                                       PLSULINFO);
    /* GetRunUnderlineInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  heightsPres (IN):
     *  kTFlow (IN): text direction and orientation
     *  &lsUlInfo (OUT): Underline information
     */

    static LSERR (WINAPI GdipLscbkGetRunStrikethroughInfo)(POLS, PLSRUN, PCHEIGHTS,
                                                           LSTFLOW, PLSSTINFO);
    /* GetRunStrikethroughInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  heightsPres (IN):
     *  kTFlow (IN): text direction and orientation
     *  &lsStInfo (OUT): Strikethrough information
     */

    static LSERR (WINAPI GdipLscbkGetBorderInfo)(POLS, PLSRUN, LSTFLOW, long*, long*);
    /* GetBorderInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  kTFlow (IN): text direction and orientation
     *  &durBorder (OUT): Width of the border on the reference device
     *  &dupBorder (OUT): Width of the border on the presentation device
     */


    static LSERR (WINAPI GdipLscbkReleaseRun)(POLS, PLSRUN);
    /* ReleaseRun:
     *  pols (IN):
     *  plsrun (IN): run to be released, from GetRun() or FetchRun()
     */

    static LSERR (WINAPI GdipLscbkHyphenate)(POLS, PCLSHYPH, LSCP, LSCP, PLSHYPH);
    /* Hyphenate:
     *  pols (IN):
     *  &lsHyphLast (IN): last hyphenation found. kysr==kysrNil means "none"
     *  cpBeginWord (IN): 1st cp in word which exceeds column
     *  cpExceed (IN): 1st which exceeds column, in this word
     *  &lsHyph (OUT): hyphenation results. kysr==kysrNil means "none"
     */

    static LSERR (WINAPI GdipLscbkGetHyphenInfo)(POLS, PLSRUN, DWORD*, WCHAR*);
    /* GetHyphenInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  kysr (OUT)    Ysr type - see "lskysr.h"
     *  wchYsr (OUT)  Character code of YSR
    */

    static LSERR (WINAPI GdipLscbkDrawUnderline)(POLS, PLSRUN, UINT,
                                                 const POINT*, DWORD, DWORD, LSTFLOW,
                                                 UINT, const RECT*);
    /* DrawUnderline:
     *  pols (IN):
     *  plsrun (IN): run to use for the underlining
     *  kUlbase (IN): underline kind
     *  pptStart (IN): starting position (top left)
     *  dupUL (IN): underline width
     *  dvpUL (IN) : underline thickness
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawStrikethrough)(POLS, PLSRUN, UINT,
                                                     const POINT*, DWORD, DWORD, LSTFLOW,
                                                     UINT, const RECT*);
    /* DrawStrikethrough:
     *  pols (IN):
     *  plsrun (IN): the run for the strikethrough
     *  kStbase (IN): strikethrough kind
     *  pptStart (IN): starting position (top left)
     *  dupSt (IN): strikethrough width
     *  dvpSt (IN) : strikethrough thickness
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawBorder)(POLS, PLSRUN, const POINT*, PCHEIGHTS,
                                              PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long,
                                              long, LSTFLOW, UINT, const RECT*);

    /* DrawBorder:
     *  pols (IN):
     *  plsrun (IN): plsrun of the first bordered run
     *  pptStart (IN): starting point for the border
     *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
     *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
     *  pheightsSubline (IN): height of subline
     *  pheightsRuns (IN): height of collected runs to be bordered
     *  dupBorder (IN): width of one border
     *  dupRunsInclBorders (IN): width of collected runs
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawUnderlineAsText)(POLS, PLSRUN, const POINT*,
                                                       long, LSTFLOW, UINT, const RECT*);
    /* DrawUnderlineAsText:
     *  pols (IN):
     *  plsrun (IN): run to use for the underlining
     *  pptStart (IN): starting pen position
     *  dupLine (IN): length of UL
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkFInterruptUnderline)(POLS, PLSRUN, LSCP, PLSRUN, LSCP,
                                                       BOOL*);
    /* FInterruptUnderline:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the previous run
     *  cpLastFirst (IN): cp of the last character of the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  cpStartSecond (IN): cp of the first character of the current run
     *  &fInterruptUnderline (OUT): do you want to interrupt drawing of the underline between these runs
     */

    static LSERR (WINAPI GdipLscbkFInterruptShade)(POLS, PLSRUN, PLSRUN, BOOL*);
    /* FInterruptShade:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  &fInterruptShade (OUT): do you want to interrupt shading between these runs
     */

    static LSERR (WINAPI GdipLscbkFInterruptBorder)(POLS, PLSRUN, PLSRUN, BOOL*);
    /* FInterruptBorder:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  &fInterruptBorder (OUT): do you want to interrupt border between these runs
     */


    static LSERR (WINAPI GdipLscbkShadeRectangle)(POLS, PLSRUN, const POINT*, PCHEIGHTS,
                                                  PCHEIGHTS, PCHEIGHTS, PCHEIGHTS,
                                                  PCHEIGHTS, long, long, LSTFLOW, UINT,
                                                  const RECT*);

    /* ShadeRectangle:
     *  pols (IN):
     *  plsrun (IN): plsrun of the first shaded run
     *  pptStart (IN): starting point for the shading rectangle
     *  pheightsLineWithAddSpace(IN): height of the line including SpaceBefore & SpaceAfter (main baseline,
     *                      lstflow of main line)
     *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
     *  pheightsSubline (IN): height of subline (local baseline, lstflow of subline)
     *  pheightsRunsExclTrail (IN): height of collected runs to be shaded excluding
     *                                  trailing spaces area (local baseline, lstflow of subline)
     *  pheightsRunsInclTrail (IN): height of collected runs to be shaded including
     *                                  trailing spaces area (local baseline, lstflow of subline)
     *  dupRunsExclTrail (IN): width of collected runs excluding trailing spaces area
     *  dupRunsInclTrail (IN): width of collected runs including trailing spaces area
     *  kTFlow (IN): text direction and orientation of subline
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawTextRun)(POLS, PLSRUN, BOOL, BOOL, const POINT*,
                                               LPCWSTR, const int*, DWORD, LSTFLOW, UINT,
                                               const POINT*, PCHEIGHTS, long, long,
                                               const RECT*);
    /* DrawTextRun:
     *  pols (IN):
     *  plsrun (IN):
     *  fStrikeout (IN) :
     *  fUnderline (IN) :
     *  pptText (IN): starting point for the text output
     *  lpwchRun (IN): run of characters
     *  rgDupRun (IN): widths of characters
     *  cwchRun (IN): number of characters in run
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  pptRun (IN): starting point of the run
     *  heightsPres (IN): presentation heights for this run
     *  dupRun (IN): presentation width for this run
     *  dupLimUnderline (IN): underlining limit
     *  pRectClip (IN): clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawSplatLine)(POLS, enum lsksplat, LSCP, const POINT*,
                                                 PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long,
                                                 LSTFLOW, UINT, const RECT*);
    /* DrawSplatLine:
     *  pols (IN):
     *  ksplat (IN): See definitions in lsksplat.h
     *  cpSplat (IN): location of the break character which caused the splat.
     *  pptSplatLine (IN) : starting position of the splat line
     *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
     *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
     *  pheightsSubline (IN): height of subline
     *  dup (IN): distance to right margin
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  &rcClip (IN) : clipping rectangle
     */


/* Advanced typography enabling API's */

    /* Glyph enabling */

    static LSERR (WINAPI GdipLscbkFInterruptShaping)(POLS, LSTFLOW, PLSRUN, PLSRUN,
                                                     BOOL*);
    /* FInterruptShaping:
     *  pols (IN):
     *  kTFlow (IN): text direction and orientation
     *  plsrunFirst (IN): run pointer for the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  &fInterruptShaping (OUT): do you want to interrupt character shaping between these runs
    */

    static LSERR (WINAPI GdipLscbkGetGlyphs)(POLS, PLSRUN, LPCWSTR, DWORD, LSTFLOW,
                                             PGMAP, PGINDEX*, PGPROP*, DWORD*);
    /* GetGlyphs:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  pwch (IN): pointer to the string of character codes
     *  cwch (IN): number of characters to be shaped
     *  kTFlow (IN): text direction and orientation
     *  rgGmap (OUT): parallel to the char codes mapping wch->glyph info
     *  &rgGindex (OUT): array of output glyph indices
     *  &rgGprop (OUT): array of output glyph properties
     *  &cgindex (OUT): number of output glyph indices
     */

    static LSERR (WINAPI GdipLscbkGetGlyphPositions)(POLS, PLSRUN, LSDEVICE, LPWSTR,
                                                     PCGMAP, DWORD, PCGINDEX, PCGPROP,
                                                     DWORD, LSTFLOW, int*, PGOFFSET);
    /* GetGlyphPositions:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  lsDeviceID (IN): presentation or reference
     *  pwch (IN): pointer to the string of character codes
     *  pgmap (IN): array of wch->glyph mapping
     *  cwch (IN): number of characters to be shaped
     *  rgGindex (IN): array of glyph indices
     *  rgGprop (IN): array of glyph properties
     *  cgindex (IN): number glyph indices
     *  kTFlow (IN): text direction and orientation
     *  rgDu (OUT): array of widths of glyphs
     *  rgGoffset (OUT): array of offsets of glyphs
     */

    static LSERR (WINAPI GdipLscbkResetRunContents)(POLS, PLSRUN, LSCP, LSDCP, LSCP,
                                                    LSDCP);
    /* ResetRunContents:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  cpFirstOld (IN): cpFirst before shaping
     *  dcpOld (IN): dcp before shaping
     *  cpFirstNew (IN): cpFirst after shaping
     *  dcpNew (IN): dcp after shaping
     */

    static LSERR (WINAPI GdipLscbkDrawGlyphs)(POLS, PLSRUN, BOOL, BOOL, PCGINDEX,
                                              const int*, const int*, PGOFFSET, PGPROP,
                                              PCEXPTYPE, DWORD, LSTFLOW, UINT,
                                              const POINT*, PCHEIGHTS, long, long,
                                              const RECT*);
    /* DrawGlyphs:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  fStrikeout (IN) :
     *  fUnderline (IN) :
     *  pglyph (IN): array of glyph indices
     *  rgDu (IN): array of widths of glyphs
     *  rgDuBeforeJust (IN): array of widths of glyphs before justification
     *  rgGoffset (IN): array of offsets of glyphs
     *  rgGprop (IN): array of glyph properties
     *  rgExpType (IN): array of glyph expansion types
     *  cglyph (IN): number glyph indices
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  pptRun (IN): starting point of the run
     *  heightsPres (IN): presentation heights for this run
     *  dupRun (IN): presentation width for this run
     *  dupLimUnderline (IN): underlining limit
     *  pRectClip (IN): clipping rectangle
     */

    /* Glyph justification */

    static LSERR (WINAPI GdipLscbkGetGlyphExpansionInfo)(POLS, PLSRUN, LSDEVICE, LPCWSTR,
                                                         PCGMAP, DWORD, PCGINDEX,
                                                         PCGPROP, DWORD, LSTFLOW, BOOL,
                                                         PEXPTYPE, LSEXPINFO*);
    /* GetGlyphExpansionInfo:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  lsDeviceID (IN): presentation or reference
     *  pwch (IN): pointer to the string of character codes
     *  rggmap (IN): array of wchar->glyph mapping
     *  cwch (IN): number of characters to be shaped
     *  rgglyph (IN): array of glyph indices
     *  rgProp (IN): array of glyph properties
     *  cglyph (IN): number glyph indices
     *  kTFlow (IN): text direction and orientation
     *  fLastTextChunkOnLine (IN): Last text chunk on line?
     *  rgExpType (OUT): array of glyph expansion types
     *  rgexpinfo (OUT): array of glyph expansion info
     */

    static LSERR (WINAPI GdipLscbkGetGlyphExpansionInkInfo)(POLS, PLSRUN, LSDEVICE,
                                                            GINDEX, GPROP, LSTFLOW,
                                                            DWORD, long*);
    /* GetGlyphExpansionInkInfo:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  lsDeviceID (IN): presentation or reference
     *  gindex (IN): glyph index
     *  gprop (IN): glyph properties
     *  kTFlow (IN): text direction and orientation
     *  cAddInkDiscrete (IN): number of discrete values (minus 1, because maximum is already known)
     *  rgDu (OUT): array of discrete values
     */

    /* FarEast realted typograpy issues */

    static LSERR (WINAPI GdipLscbkGetEms)(POLS, PLSRUN, LSTFLOW, PLSEMS);
    /* GetEms:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  kTFlow (IN): text direction and orientation
     *  &lsems (OUT): different fractions of EM in appropriate pixels
     */

    static LSERR (WINAPI GdipLscbkPunctStartLine)(POLS, PLSRUN, MWCLS, WCHAR, LSACT*);
    /* PunctStartLine:
     *  pols (IN):
     *  plsrun (IN): run pointer for the char
     *  mwcls (IN): mod width class for the char
     *  wch (IN): char
     *  &lsact (OUT): action on the first char on the line
     */

    static LSERR (WINAPI GdipLscbkModWidthOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
                                                 LSACT*);
    /* ModWidthOnRun:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the first char
     *  wchFirst (IN): first char
     *  plsrunSecond (IN): run pointer for the second char
     *  wchSecond (IN): second char
     *  &lsact (OUT): action on the last char in 1st run
     */

    static LSERR (WINAPI GdipLscbkModWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
                                                 WCHAR, LSACT*);
    /* ModWidthSpace:
     *  pols (IN):
     *  plsrunCur (IN): run pointer for the current run
     *  plsrunPrev (IN): run pointer for the previous char
     *  wchPrev (IN): previous char
     *  plsrunNext (IN): run pointer for the next char
     *  wchNext (IN): next char
     *  &lsact (OUT): action on space's width
     */

    static LSERR (WINAPI GdipLscbkCompOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
                                             LSPRACT*);
    /* CompOnRun:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the first char
     *  wchFirst (IN): first char
     *  plsrunSecond (IN): run pointer for the second char
     *  wchSecond (IN): second char
     *  &lspract (OUT): prioritized action on the last char in 1st run
     */

    static LSERR (WINAPI GdipLscbkCompWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
                                                  WCHAR, LSPRACT*);
    /* CompWidthSpace:
     *  pols (IN):
     *  plsrunCur (IN): run pointer for the current run
     *  plsrunPrev (IN): run pointer for the previous char
     *  wchPrev (IN): previous char
     *  plsrunNext (IN): run pointer for the next char
     *  wchNext (IN): next char
     *  &lspract (OUT): prioritized action on space's width
     */


    static LSERR (WINAPI GdipLscbkExpOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
                                            LSACT*);
    /* ExpOnRun:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the first char
     *  wchFirst (IN): first char
     *  plsrunSecond (IN): run pointer for the second char
     *  wchSecond (IN): second char
     *  &lsact (OUT): action on the last run char from 1st run
     */

    static LSERR (WINAPI GdipLscbkExpWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
                                                 WCHAR, LSACT*);
    /* ExpWidthSpace:
     *  pols (IN):
     *  plsrunCur (IN): run pointer for the current run
     *  plsrunPrev (IN): run pointer for the previous char
     *  wchPrev (IN): previous char
     *  plsrunNext (IN): run pointer for the next char
     *  wchNext (IN): next char
     *  &lsact (OUT): action on space's width
     */

    static LSERR (WINAPI GdipLscbkGetModWidthClasses)(POLS, PLSRUN, const WCHAR*, DWORD,
                                                      MWCLS*);
    /* GetModWidthClasses:
     *  pols (IN):
     *  plsrun (IN): run pointer for the characters
     *  rgwch (IN): array of characters
     *  cwch (IN): number of characters in the rgwch array
     *  rgmwcls(OUT): array of ModWidthClass's for chars from the rgwch array
     */

    static LSERR (WINAPI GdipLscbkGetBreakingClasses)(POLS, PLSRUN, LSCP, WCHAR, BRKCLS*,
                                                      BRKCLS*);
    /* GetBreakingClasses:
     *  pols (IN):
     *  plsrun (IN): run pointer for the char
     *  cp (IN): cp of the character
     *  wch (IN): character
     *  &brkclsFirst (OUT): breaking class for this char as the leading one in a pair
     *  &brkclsSecond (OUT): breaking class for this char as the following one in a pair
     */

    static LSERR (WINAPI GdipLscbkFTruncateBefore)(POLS, PLSRUN, LSCP, WCHAR, long,
                                                   PLSRUN, LSCP, WCHAR, long, long,
                                                   BOOL*);
    /* FTruncateBefore:
     *  pols (IN):
     *  plsrunCur (IN): plsrun of the current character
     *  cpCur (IN): cp of truncation char
     *  wchCur (IN): truncation character
     *  durCur (IN): width of truncation character
     *  plsrunPrev (IN): plsrun of the previous character
     *  cpPrev (IN): cp of the previous character
     *  wchPrev (IN): previous character
     *  durPrev (IN): width of truncation character
     *  durCut (IN): width from the RM until the end of the current character
     *  &fTruncateBefore (OUT): truncation point is before this character
     *          (if it exceeds RM)
     */

    static LSERR (WINAPI GdipLscbkCanBreakBeforeChar)(POLS, BRKCLS, BRKCOND*);
    /* CanBreakBeforeChar:
     *  pols (IN):
     *  brkcls (IN): breaking class for the char as the following one in a pair
     *  &brktxtBefore (OUT): break condition before the character
     */

    static LSERR (WINAPI GdipLscbkCanBreakAfterChar)(POLS, BRKCLS, BRKCOND*);
    /* CanBreakAfterChar:
     *  pols (IN):
     *  brkcls (IN): breaking class for the char as the leading one in a pair
     *  &brktxtAfter (OUT): break text condition after the character
     */


    static LSERR (WINAPI GdipLscbkFHangingPunct)(POLS, PLSRUN, MWCLS, WCHAR, BOOL*);
    /* FHangingPunct:
     *  pols (IN):
     *  plsrun (IN): run pointer for the char
     *  mwcls (IN): mod width class of this char
     *  wch (IN): character
     *  &fHangingPunct (OUT): can be pushed to the right margin?
     */

    static LSERR (WINAPI GdipLscbkGetSnapGrid)(POLS, WCHAR*, PLSRUN*, LSCP*, DWORD,
                                               BOOL*, DWORD*);
    /* GetGridInfo:
     *  pols (IN):
     *  rgwch (IN): array of characters
     *  rgplsrun (IN): array of corresponding plsrun's
     *  rgcp (IN): array of corresponding cp's
     *  iwch (IN): number of characters
     *  rgfSnap (OUT): array of fSnap flags for all characters
     *  pwGridNumber (OUT): number of grid points on the line
     */

    static LSERR (WINAPI GdipLscbkDrawEffects)(POLS, PLSRUN, UINT, const POINT*, LPCWSTR,
                                               const int*, const int*, DWORD, LSTFLOW,
                                               UINT, PCHEIGHTS, long, long, const RECT*);
    /* DrawTextRun:
     *  pols (IN):
     *  plsrun (IN):
     *  EffectsFlags (IN): set of client defined special effects bits
     *  ppt (IN): output location
     *  lpwchRun (IN): run of characters
     *  rgDupRun (IN): widths of characters
     *  rgDupLeftCut (IN): dup cut from the left side of the char
     *  cwchRun (IN): number of characters in run
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  heightsPres (IN): presentation heights for this run
     *  dupRun (IN): presentation width for this run
     *  dupLimUnderline (IN): underlining limit
     *  pRectClip (IN): clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkFCancelHangingPunct)(POLS, LSCP, LSCP, WCHAR, MWCLS,
                                                       BOOL*);

    /* FCancelHangingPunct:
     *  pols (IN):
     *  cpLim (IN): cpLim of the line
     *  cpLastAdjustable (IN): cp of the last adjustable character on the line
     *  wch (IN): last character
     *  mwcls (IN): mod width class of this char
     *  pfCancelHangingPunct (OUT): cancel hanging punctuation?
    */

    static LSERR (WINAPI GdipLscbkModifyCompAtLastChar)(POLS, LSCP, LSCP, WCHAR, MWCLS, long, long, long*);

    /* ModifyCompAtLastChar:
     *  pols (IN):
     *  cpLim (IN): cpLim of the line
     *  cpLastAdjustable (IN): cp of the last adjustable character on the line
     *  wch (IN): last character
     *  mwcls (IN): mod width class of this char
     *  durCompLastRight (IN): suggested compression on the right side
     *  durCompLastLeft (IN): suggested compression on the left side
     *  pdurCahngeComp (OUT): change compression amount on the last char
    */

    /* Enumeration callbacks */

    static LSERR (WINAPI GdipLscbkEnumText)(POLS, PLSRUN, LSCP, LSDCP, LPCWSTR, DWORD,
                                            LSTFLOW, BOOL, BOOL, const POINT*, PCHEIGHTS,
                                            long, BOOL, long*);
    /* EnumText:
     *  pols (IN):
     *  plsrun (IN): from DNODE
     *  cpFirst (IN): from DNODE
     *  dcp (IN): from DNODE
     *  rgwch(IN): array of characters
     *  cwch(IN): number of characters
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryProvided (IN):
     *  pptStart (IN): starting position, iff fGeometryProvided
     *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
     *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
     *  fCharWidthProvided (IN):
     *  rgdup(IN): array of character widths, iff fCharWidthProvided
    */

    static LSERR (WINAPI GdipLscbkEnumTab)(POLS, PLSRUN, LSCP, LPCWSTR, WCHAR, LSTFLOW,
                                           BOOL, BOOL, const POINT*, PCHEIGHTS, long);
    /* EnumTab:
     *  pols (IN):
     *  plsrun (IN): from DNODE
     *  cpFirst (IN): from DNODE
     *  rgwch(IN): Pointer to one Tab character
     *  wchTabLeader (IN): tab leader
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryProvided (IN):
     *  pptStart (IN): starting position, iff fGeometryProvided
     *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
     *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
    */

    static LSERR (WINAPI GdipLscbkEnumPen)(POLS, BOOL, LSTFLOW, BOOL, BOOL, const POINT*,
                                           long, long);
    /* EnumPen:
     *  pols (IN):
     *  fBorder (IN):
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryProvided (IN):
     *  pptStart (IN): starting position, iff fGeometryProvided
     *  dup(IN): from DNODE iff fGeometryProvided
     *  dvp(IN): from DNODE iff fGeometryProvided
    */

    /* Objects bundling */

    static LSERR (WINAPI GdipLscbkGetObjectHandlerInfo)(POLS, DWORD, void*);
    /* GetObjectHandlerInfo:
     *  pols (IN):
     *  idObj (IN): id of the object handler
     *  pObjectInfo (OUT): initialization information of the specified object
    */


    /* Debugging APIs */
    static void (WINAPI GdipLscbkAssertFailed)(char*, char*, int);




    // From LSIMETH.H

    static LSERR (WINAPI GdipLscbkCreateILSObj)(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
    /* CreateILSObj
     *  pols (IN):
     *  plsc (IN): LS context
     *  plscbk (IN): callbacks
     *  idObj (IN): id of the object
     *  &pilsobj (OUT): object ilsobj
    */

    static LSERR (WINAPI GdipLscbkDestroyILSObj)(PILSOBJ);
    /* DestroyILSObj
     *  pilsobj (IN): object ilsobj
    */

    static LSERR (WINAPI GdipLscbkSetDoc)(PILSOBJ, PCLSDOCINF);
    /* SetDoc
     *  pilsobj (IN): object ilsobj
     *  lsdocinf (IN): initialization data at document level
    */

    static LSERR (WINAPI GdipLscbkCreateLNObj)(PCILSOBJ, PLNOBJ*);
    /* CreateLNObj
     *  pilsobj (IN): object ilsobj
     *  &plnobj (OUT): object lnobj
    */

    static LSERR (WINAPI GdipLscbkDestroyLNObj)(PLNOBJ);
    /* DestroyLNObj
     *  plnobj (OUT): object lnobj
    */

    static LSERR (WINAPI GdipLscbkFmt)(PLNOBJ, PCFMTIN, FMTRES*);
    /* Fmt
     *  plnobj (IN): object lnobj
     *  pfmtin (IN): formatting input
     *  &fmtres (OUT): formatting result
    */

    static LSERR (WINAPI GdipLscbkFmtResume)(PLNOBJ, const BREAKREC*, DWORD, PCFMTIN,
                                             FMTRES*);
    /* FmtResume
     *  plnobj (IN): object lnobj
     *  rgBreakRecord (IN): array of break records
     *  nBreakRecord (IN): size of the break records array
     *  pfmtin (IN): formatting input
     *  &fmtres (OUT): formatting result
    */

    static LSERR (WINAPI GdipLscbkGetModWidthPrecedingChar)(PDOBJ, PLSRUN, PLSRUN,
                                                            PCHEIGHTS, WCHAR, MWCLS,
                                                            long*);
    /* GetModWidthPrecedingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  heightsRef (IN): height info about character
     *  wchar (IN): preceding character
     *  mwcls (IN): ModWidth class of preceding character
     *  &durChange (OUT): amount by which width of the preceding char is to be changed
    */

    static LSERR (WINAPI GdipLscbkGetModWidthFollowingChar)(PDOBJ, PLSRUN, PLSRUN,
                                                            PCHEIGHTS, WCHAR, MWCLS,
                                                            long*);
    /* GetModWidthPrecedingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  heightsRef (IN): height info about character
     *  wchar (IN): following character
     *  mwcls (IN): ModWidth class of the following character
     *  &durChange (OUT): amount by which width of the following char is to be changed
    */

    static LSERR (WINAPI GdipLscbkTruncateChunk)(PCLOCCHNK, PPOSICHNK);
    /* Truncate
     *  plocchnk (IN): locchnk to truncate
     *  posichnk (OUT): truncation point
    */

    static LSERR (WINAPI GdipLscbkFindPrevBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND,
                                                      PBRKOUT);
    /* FindPrevBreakChunk
     *  plocchnk (IN): locchnk to break
     *  pposichnk (IN): place to start looking for break
     *  brkcond (IN): recommmendation about the break after chunk
     *  &brkout (OUT): results of breaking
    */

    static LSERR (WINAPI GdipLscbkFindNextBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND,
                                                      PBRKOUT);
    /* FindNextBreakChunk
     *  plocchnk (IN): locchnk to break
     *  pposichnk (IN): place to start looking for break
     *  brkcond (IN): recommmendation about the break before chunk
     *  &brkout (OUT): results of breaking
    */

    static LSERR (WINAPI GdipLscbkForceBreakChunk)(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
    /* ForceBreakChunk
     *  plocchnk (IN): locchnk to break
     *  pposichnk (IN): place to start looking for break
     *  &brkout (OUT): results of breaking
    */

    static LSERR (WINAPI GdipLscbkSetBreak)(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
    /* SetBreak
     *  pdobj (IN): dobj which is broken
     *  brkkind (IN): Previous/Next/Force/Imposed was chosen
     *  nBreakRecord (IN): size of array
     *  rgBreakRecord (OUT): array of break records
     *  nActualBreakRecord (OUT): actual number of used elements in array
    */

    static LSERR (WINAPI GdipLscbkGetSpecialEffectsInside)(PDOBJ, UINT*);
    /* GetSpecialEffects
     *  pdobj (IN): dobj
     *  &EffectsFlags (OUT): Special effects inside of this object
    */

    static LSERR (WINAPI GdipLscbkFExpandWithPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR,
                                                            MWCLS, BOOL*);
    /* FExpandWithPrecedingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  wchar (IN): preceding character
     *  mwcls (IN): ModWidth class of preceding character
     *  &fExpand (OUT): expand preceding character?
    */

    static LSERR (WINAPI GdipLscbkFExpandWithFollowingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR,
                                                            MWCLS, BOOL*);
    /* FExpandWithFollowingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  wchar (IN): following character
     *  mwcls (IN): ModWidth class of the following character
     *  &fExpand (OUT): expand object?
    */
    static LSERR (WINAPI GdipLscbkCalcPresentation)(PDOBJ, long, LSKJUST, BOOL);
    /* CalcPresentation
     *  pdobj (IN): dobj
     *  dup (IN): dup of dobj
     *  lskj (IN): current justification mode
     *  fLastVisibleOnLine (IN): this object is last visible object on line
    */

    static LSERR (WINAPI GdipLscbkQueryPointPcp)(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
    /* QueryPointPcp
     *  pdobj (IN): dobj to query
     *  ppointuvQuery (IN): query point (uQuery,vQuery)
     *  plsqin (IN): query input
     *  plsqout (OUT): query output
    */

    static LSERR (WINAPI GdipLscbkQueryCpPpoint)(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
    /* QueryCpPpoint
     *  pdobj (IN): dobj to query
     *  dcp (IN):  dcp for the query
     *  plsqin (IN): query input
     *  plsqout (OUT): query output
    */

    static LSERR (WINAPI GdipLscbkEnum)(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW,
                                        BOOL, BOOL, const POINT*, PCHEIGHTS, long);
    /* Enum object
     *  pdobj (IN): dobj to enumerate
     *  plsrun (IN): from DNODE
     *  plschp (IN): from DNODE
     *  cpFirst (IN): from DNODE
     *  dcp (IN): from DNODE
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryNeeded (IN):
     *  pptStart (IN): starting position, iff fGeometryNeeded
     *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
     *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
    */

    static LSERR (WINAPI GdipLscbkDisplay)(PDOBJ, PCDISPIN);
    /* Display
     *  pdobj (IN): dobj to display
     *  pdispin (IN): input display info
    */

    static LSERR (WINAPI GdipLscbkDestroyDObj)(PDOBJ);
    /* DestroyDObj
     *  pdobj (IN): dobj to destroy
    */

};




Status ItemizationFiniteStateMachine(
    IN  const WCHAR            *string,
    IN  INT                     length,
    IN  INT                     state,      // Initial state
    OUT SpanVector<GpTextItem> *textItemSpanVector,
    OUT INT                    *flags       // Combined flags of all items
);


GpStatus SecondaryItemization(
    IN    const WCHAR            *string,
    IN    INT                     length,
    IN    ItemScript              numericScript,
    IN    INT                     mask,
    IN    BYTE                    defaultLevel,
    IN    BOOL                    isMetaRecording,
    OUT   SpanVector<GpTextItem> *textItemSpanVector  // InOut
);



//  Kinsoku breaking rules

UINT GetKinsokuClass(WCHAR character);
BOOL CanBreakKinsokuClass(UINT class1, UINT class2);






/////   DriverStringImager
//
//      Supports DriverString APIs


class DriverStringImager
{
public:

    DriverStringImager(
        const UINT16    *text,
        INT              glyphCount,
        const GpFont    *font,
        const PointF    *positions,
        INT              flags,
        GpGraphics      *graphics,
        const GpMatrix  *matrix
    );

    ~DriverStringImager()
    {
        if (UprightFaceRealization)  delete UprightFaceRealization;
        if (SidewaysFaceRealization) delete SidewaysFaceRealization;
    }

    virtual GpStatus GetStatus() const { return Status; }

    GpStatus Draw(
        IN const GpBrush *brush
    );

    GpStatus Measure(
        OUT RectF   *boundingBox   // Overall bounding box of cells
    );

    /////   GetDriverStringGlyphOrigins
    //
    //      Establishes glyph origins for DriverString functions when the client
    //      passes just the origin with DriverStringOptionsRealizedAdvance.

    GpStatus
    GetDriverStringGlyphOrigins(
        IN   const GpFaceRealization  *faceRealization,
        IN   INT                       firstGlyph,
        IN   INT                       glyphCount,
        IN   BOOL                      sideways,
        IN   const GpMatrix           *fontTransform,
        IN   INT                       style,
        IN   const PointF             *positions,      // position(s) in world coords
        OUT  PointF                   *glyphOrigins,   // position(s) in device coords
        OUT  PointF                   *finalPosition   // position following final glyph
    );


private:

    GpStatus MeasureString(
        OUT RectF   *boundingBox,       // Overall bounding box of cells
        OUT RectF   *baseline = NULL    // base line rectangle with 0 height
    );

    GpStatus RecordEmfPlusDrawDriverString(
        const GpBrush   *brush
    );

    GpStatus GenerateWorldOrigins();


    GpStatus VerticalAnalysis(BOOL * sidewaysRunPresent);

    GpStatus DrawGlyphRange(
        const GpFaceRealization *faceRealization,
        const GpBrush           *brush,
        INT                      first,
        INT                      length
    );

    GpStatus AddToPath(
        GpPath                  *path,
        const UINT16            *glyphs,
        const PointF            *glyphOrigins,
        INT                      glyphCount,
        GpMatrix                *fontTransform,
        BOOL                     sideways
    );



    /// Buffer usage
    //
    //  WorldOrigins
    //
    //  Points either to client position array, or to internal WorldOriginBuffer.
    //  Contains glyph advance vector origins in world coordinates.
    //  For horizontal layout the advance vector is along the horizontal baseline.
    //  For vertical layout the advance vector is down the center of the glyph.
    //  Usage:
    //     Recording metafiles
    //     Origin for measuring
    //     Origin for AddToPath
    //
    //
    //  WorldOriginBuffer
    //
    //  Allocated when client does not provide individual glyph positions.
    //  Generated by transformation from device origins.
    //
    //
    //  DeviceOrigins
    //
    //  Glyph advance vector origins in device coordinates.
    //  For horizontal layout the advance vector is along the horizontal baseline.
    //  For vertical layout the advance vector is along the vertical baseline.
    //  The vertical baseline is the baseline that rotated Western text sits on.


    const UINT16           *String;
    const UINT16           *Glyphs;             // const because the glyphs may be the input string
    AutoBuffer<UINT16,32>   GlyphBuffer;
    AutoBuffer<PointF,32>   DeviceOrigins;      //
    AutoBuffer<PointF,32>   WorldOriginBuffer;
    const PointF           *WorldOrigins;
    PointF                  OriginOffset;       // From client origin to rasterizer origin
    INT                     GlyphCount;
    const GpFont           *Font;
    const GpFontFace       *Face;
    const PointF           *Positions;
    INT                     Flags;
    GpGraphics             *Graphics;
    const GpMatrix         *GlyphTransform;
    GpMatrix                WorldToDevice;
    GpStatus                Status;
    SpanVector<BYTE>        OrientationVector;
    REAL                    EmSize;
    REAL                    WorldToIdeal;
    REAL                    FontScale;
    GpFaceRealization      *UprightFaceRealization;
    GpFaceRealization      *SidewaysFaceRealization;

    REAL                    PixelsPerEm;
    const GpMatrix         *FontTransform;
    INT                     Style;
    SizeF                   Dpi;
    AutoBuffer<REAL,32>     DeviceAdvances;
};

#endif // _IMAGER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\lineservicesowner.cpp ===
/////   LineServicesOwner
//
//      Encapsulates an LSC and includes temporary buffers.


#include "precomp.hpp"



static const LSDEVRES Resolutions = {1440,1440,1440,1440};



//  Some global variables

const WCHAR ObjectTerminatorString[] = { WCH_OBJECTTERMINATOR };




/////   Linebreaking types
//
//      This table is constructed according to linebreakclass.cxx generated linebreak behavior table.
//      We assume break-CJK mode is ON. So break type 3 is the same as 2 and break type 4 is as 0.
//      (see comments in linebreakclass.cxx). =wchao, 5/15/2000=

static const LSBRK LineBreakType[5] =
{
    {1, 1},     // 0 - Break pair always
    {0, 0},     // 1 - Never break pair
    {0, 1},     // 2 - Break pair only if there're spaces in between
    {0, 1},     // 3 - (for now, same as 2)
    {1, 1}      // 4 - (for now, same as 0)
};




/////   Character configuration
//
//      Control characters used by Line Services.
//

const LSTXTCFG CharacterConfiguration =
{
    LINELENGTHHINT,
    WCH_UNDEF,                  // wchUndef
    WCH_NULL,                   // wchNull
    WCH_SPACE,                  // wchSpace
    WCH_UNDEF,                  // wchHyphen - !! we dont support hard-hyphen
    WCH_TAB,                    // wchTab
    WCH_CR,                     // wchEndPara1
    WCH_LF,                     // wchEndPara2
    WCH_PARASEPERATOR,          // wchAltEndPara
    WCH_LINEBREAK,              // wchEndLineInPara
    WCH_UNDEF,                  // wchColumnBreak
    WCH_UNDEF,                  // wchSectionBreak
    WCH_UNDEF,                  // wchPageBreak
    WCH_NONBREAKSPACE,          // wchNonBreakSpace
    WCH_NONBREAKHYPHEN,         // wchNonBreakHyphen
    WCH_NONREQHYPHEN,           // wchNonReqHyphen
    WCH_EMDASH,                 // wchEmDash
    WCH_ENDASH,                 // wchEnDash
    WCH_EMSPACE,                // wchEmSpace
    WCH_ENSPACE,                // wchEnSpace
    WCH_NARROWSPACE,            // wchNarrowSpace
    WCH_UNDEF,                  // wchOptBreak
    WCH_ZWNBSP,                 // wchNoBreak
    WCH_FESPACE,                // wchFESpace
    WCH_ZWJ,                    // wchJoiner
    WCH_ZWNJ,                   // wchNonJoiner
    WCH_UNDEF,                  // wchToReplace
    WCH_UNDEF,                  // wchReplace
    WCH_UNDEF,                  // wchVisiNull
    WCH_VISIPARASEPARATOR,      // wchVisiAltEndPara
    WCH_SPACE,                  // wchVisiEndLineInPara
    WCH_VISIPARASEPARATOR,      // wchVisiEndPara
    WCH_UNDEF,                  // wchVisiSpace
    WCH_UNDEF,                  // wchVisiNonBreakSpace
    WCH_UNDEF,                  // wchVisiNonBreakHyphe
    WCH_UNDEF,                  // wchVisiNonReqHyphen
    WCH_UNDEF,                  // wchVisiTab
    WCH_UNDEF,                  // wchVisiEmSpace
    WCH_UNDEF,                  // wchVisiEnSpace
    WCH_UNDEF,                  // wchVisiNarrowSpace
    WCH_UNDEF,                  // wchVisiOptBreak
    WCH_UNDEF,                  // wchVisiNoBreak
    WCH_UNDEF,                  // wchVisiFESpace
    WCH_OBJECTTERMINATOR,
    WCH_UNDEF,                  // wchPad
};





/////   LineServicesOwner constructor
//
//


extern const LSCBK GdipLineServicesCallbacks;

ols::ols()
:   LsContext       (NULL),
    Imager          (NULL),
    NextOwner       (NULL),
    Status          (GenericError)
{

    // Initialize context

    LSCONTEXTINFO   context;
    LSIMETHODS      lsiMethods[OBJECTID_COUNT];


    context.version = 3;    // though currently ignored by LS...


    // Loading default reverse object interface method
    //

    if (LsGetReverseLsimethods (&lsiMethods[OBJECTID_REVERSE]) != lserrNone)
    {
        return;
    }


    context.cInstalledHandlers = OBJECTID_COUNT;
    context.pInstalledHandlers = &lsiMethods[0];

    context.pols  = this;
    context.lscbk = GdipLineServicesCallbacks;

    context.fDontReleaseRuns = TRUE;         // no run to release


    // Fill up text configuration
    //
    GpMemcpy (&context.lstxtcfg, &CharacterConfiguration, sizeof(LSTXTCFG));


    if (LsCreateContext(&context, &LsContext) != lserrNone)
    {
        return;
    }


    // Give Line Services a lookup table to determine how to break a pair of
    // characters to facilitate line breaking rules.
    //

    if (LsSetBreaking(
            LsContext,
            sizeof(LineBreakType) / sizeof(LineBreakType[0]),
            LineBreakType,
            BREAKCLASS_MAX,
            (const BYTE *)LineBreakBehavior
        ) != lserrNone)
    {
        return;
    }

    if (LsSetDoc(
            LsContext,
            TRUE,           // Yes, we will be displaying
            TRUE,           // Yes, reference and presentation are the same device
            &Resolutions    // All resolution are TWIPS
        ) != lserrNone)
    {
        return;
    }


    // Successful context creation

    Status = Ok;
}



static ols *FirstFreeLineServicesOwner = NULL;

ols *ols::GetLineServicesOwner(FullTextImager *imager)
{
    ols* owner;

    // !!! Critical section required

    if (FirstFreeLineServicesOwner != NULL)
    {
        owner = FirstFreeLineServicesOwner;
        FirstFreeLineServicesOwner = FirstFreeLineServicesOwner->NextOwner;
    }
    else
    {
        owner = new ols();
    }

    if (!owner)
    {
        return NULL;
    }

    owner->Imager    = imager;
    owner->NextOwner = NULL;

    return owner;
}



void ols::ReleaseLineServicesOwner(ols **owner)
{
    // !!! Needs critical section

    ASSERT(*owner);
    (*owner)->Imager = NULL;
    (*owner)->NextOwner = FirstFreeLineServicesOwner;
    FirstFreeLineServicesOwner = (*owner);
    *owner = NULL;
}

void ols::deleteFreeLineServicesOwners()
{
    ols* thisOls = FirstFreeLineServicesOwner;
    ols* nextOls;

    // !!! Needs critical section

    while (thisOls)
    {
        nextOls = thisOls->NextOwner;
        delete thisOls;
        thisOls = nextOls;
    }
    FirstFreeLineServicesOwner = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\lineservicesowner.hpp ===
#ifndef _LINESERVICESCONTEXT_HPP
#define _LINESERVICESCONTEXT_HPP



//  Some external global variables

extern const WCHAR ObjectTerminatorString[];




//  Some constants

#define OBJECTID_REVERSE            0
#define OBJECTID_COUNT              1   // !! only support reversal for now

#define LINELENGTHHINT              70



//  Control characters used by Line Services

#define WCH_UNDEF                   0x0001          // wchUndef
#define WCH_NULL                    0x0000          // wchNull
#define WCH_SPACE                   0x0020          // wchSpace
#define WCH_HYPHEN                  0x002D          // wchHyphen
#define WCH_TAB                     0x0009          // wchTab
#define WCH_CR                      0x000D          // wchEndPara1
#define WCH_LF                      0x000A          // wchEndPara2
#define WCH_PARASEPERATOR           0x2029          // wchAltEndPara
#define WCH_LINEBREAK               0x0084          // wchEndLineInPara
#define WCH_NONBREAKSPACE           0x00A0          // wchNonBreakSpace
#define WCH_NONBREAKHYPHEN          0x2011          // wchNonBreakHyphen
#define WCH_NONREQHYPHEN            0x2010          // wchNonReqHyphen
#define WCH_EMDASH                  0x2014          // wchEmDash
#define WCH_ENDASH                  0x2013          // wchEnDash
#define WCH_EMSPACE                 0x2003          // wchEmSpace
#define WCH_ENSPACE                 0x2002          // wchEnSpace
#define WCH_NARROWSPACE             0x2009          // wchNarrowSpace
#define WCH_ZWNBSP                  0xFEFF          // wchNoBreak
#define WCH_FESPACE                 0x3000          // wchFESpace
#define WCH_ZWJ                     0x200D          // wchJoiner
#define WCH_ZWNJ                    0x200C          // wchNonJoiner
#define WCH_VISIPARASEPARATOR       0x00B6          // wchVisiEndPara

#define WCH_OBJECTTERMINATOR        0x009F          // object terminator



#define IsEOP(ch)   (BOOL)((ch) == WCH_CR || (ch) == WCH_LF)




/////   Line services context
//
//      Contains the PLSC context pointer.
//
//      Contains temporary buffers used suring glyphing and positioning
//      operations.
//
//      A pool of available contexts is mainitained.
//
//      The TextImager BuildLines function starts by obtaining a context and
//      linking it to the imager. The context is passed to Line Services for
//      all calls during the line building process.
//
//      The context is returned to the free pool when all lines are built.


struct ols  // Line services owner - type required by Line Services
{
public:
    ols();

    ~ols()
    {
        if (LsContext)
        {
            LsDestroyContext(LsContext);
        }
    }

    GpStatus GetStatus() {return Status;}

    static ols *GetLineServicesOwner(FullTextImager *imager);

    static void ReleaseLineServicesOwner(ols **owner);

    static void deleteFreeLineServicesOwners();

    FullTextImager *GetImager() {return Imager;}

    PLSC GetLsContext() {return LsContext;}

private:

    PLSC  LsContext;

    // At any one time, this context beongs either to a TextImager (Imager set
    // and NextContext NULL), or to the free list (Imager NULL, and NextCOntext
    // may be set).

    FullTextImager *Imager;     // Set only while attached to an imager
    ols            *NextOwner;  // Next in free owner pool

    GpStatus        Status;     // Creation status
};


#endif _LINESERVICESCONTEXT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\item.hpp ===
#ifndef _ITEM_HPP
#define _ITEM_HPP




/////   TextItemizer - header for itemization
//
//


/////   Purpose
//
//      The item analyser identifies scripts in a Unicode string for the
//      following purposes
//
//      o  Identify appropriate shaping engines
//      o  Select OpenType behaviour
//      o  Assign combining characters to appropriate runs
//      o  Assign ZWJ, ZWNJ and ZWNBSP and adjacent characters to appropriate runs
//      o  Break out control characters
//      o  Track unicode mode selection ASS/ISS, NADS/NODS, AAFS/IAFS
//      o  Separate numbers from other text


/////   Performance
//
//      Full Unicode processing is so much more expensive than support of
//      plain western text that the itemizer is split into a fast track and a
//      full track.
//
//      The fast track itemizer can handle only simple Western text, and is
//      very fast. The full itemizer identifies all Unicode scripts and splits
//      out numbers. (??? Number split out may be disabled).


/////   Combining diacritical marks
//
//      Characters is the range U+0300 - U+036F can combine with any previous
//      base character. Their presence does not change the script of the
//      run in which they are found, but does turn off the 'Simple' flag in the
//      run properties.


/////   Complex script combining characters
//
//      Complex script combining characters may generally be applied only to
//      characters of the same script (however some Arabic comining marks are
//      applicable to Syriac script).
//
//      When a complex script combining character follows anything other than
//      a suitable base character, it is broken into a separate item, so the
//      most suitable shaping engine for that item will be employed.


/////   Punctuation, symbols, ...
//
//      Punctuation, spaces, symbols and other script ambiguous characters are
//      kept with the preceeding characters, with the exception that a zero
//      width joiner (ZWJ) attaches a single preceeding ambiguous character to
//      a subsequent complex script combining character.


/////   Control characters
//
//      Most control characters are separated out into separate ScriptControl
//      runs.
//
//      The following control characters do not break Script spans:
//
//      ZWJ    - zero width joiner
//      ZWNJ   - zero width non-joiner
//      ZWNBSP - zero width no-break space
//      SHY    - soft hyphen
//
//      When such a control exists between characters of different strong types,
//      it remains with the preceeding span, and the leading join flag of
//      the subsequent span is set appropriately.


/////   Numbers
//
//      Western numbers are itemized separately. Where appropriate a number
//      includes adjacent currency symbols, '/', '#', '+', '-', ',', '.' etc. as
//      defined by the Unicode bidirectional classification.


/////   Flags
//
//      The following flags are generated with each run
//
//          Combining  - item contains combining diacritical marks
//          ZeroWidth  - item contains ZWJ, ZWNJ, ZWNBSP etc.
//          Surrogate  - item contains surrogate codepoints
//          Digits     - item contains ASCII digits


enum ItemFlags
{
    ItemCombining = 0x01,
    ItemZeroWidth = 0x02,
    ItemDigits    = 0x04,

    // The following flags are generated during run construction

    ItemSideways  = 0x08,   // Rotate glyphs 270 degrees relative to baseline
    ItemMirror    = 0x10,   // Reflect glyphs in their central vertical axis
    ItemVertical  = 0x20    // Lay out glyphs along y instead of x axis
};


/////   State
//
//      The following state is generated with each run
//
//          DigitSubstitute   - state of Unicode NADS/NODS control characters
//          SymmetricSwapping - state of Unicode ASS/ISS control characters
//          ArabicFormShaping - state of Unicode AAFS/IAFS control characters
//          LeadingJoin       - item was preceeded by a ZWJ character


enum ItemState
{
    DigitSubstitute = 1,
    SymmetricSwap   = 2,
    ArabicFormShape = 4,
    LeadingJoin     = 8
};


/////   Scripts
//
//      Unicode itemization breaks Unicode strings into spans of the following
//      scripts.



enum ItemScript
{
    ScriptNone,          // (OTL)
    ScriptLatin,         // latn  All purely Latin spans containing no combining marks
    ScriptLatinNumber,   //       Sequence of digits, +, -, currency etc.
    ScriptGreek,         // grek
    ScriptCyrillic,      // cyrl
    ScriptArmenian,      // armn
    ScriptHebrew,        // hebr
    ScriptArabic,        // arab
    ScriptSyriac,        // syrc
    ScriptThaana,        // thaa
    ScriptDevanagari,    // deva
    ScriptBengali,       // beng
    ScriptGurmukhi,      // guru
    ScriptGujarati,      // gujr
    ScriptOriya,         // orya
    ScriptTamil,         // taml
    ScriptTelugu,        // telu
    ScriptKannada,       // knda
    ScriptMalayalam,     // mlym
    ScriptSinhala,       // sinh
    ScriptThai,          // thai
    ScriptLao,           // lao
    ScriptTibetan,       // tibt
    ScriptMyanmar,       // mymr
    ScriptGeorgian,      // geor
    ScriptEthiopic,      // ethi
    ScriptCherokee,      // cher
    ScriptCanadian,      // cans  Unified Canadian Aboriginal Syllabics
    ScriptOgham,         //
    ScriptRunic,         //
    ScriptKhmer,         // khmr
    ScriptMongolian,     // mong
    ScriptBraille,       //
    ScriptBopomofo,      // bopo
    ScriptIdeographic,   // hani  Includes ideographs in the surrogate range
    ScriptHangulJamo,    // jamo
    ScriptHangul,        // hang
    ScriptKana,
    ScriptHiragana,      // hira
    ScriptKatakana,      // kata
    ScriptHan,
    ScriptYi,            // yi
    ScriptPrivate,       //       Private use characters in the BMP or surrogate pages
    ScriptSurrogate,     //       Surrogate characters not otherwise classified
    ScriptControl,       //       Control characters other than ZWJ, ZWNJ, ZWNBSP

    // Scripts generated by secondary classification

    ScriptArabicNum,
    ScriptThaiNum,
    ScriptDevanagariNum,
    ScriptTamilNum,
    ScriptBengaliNum,
    ScriptGurmukhiNum,
    ScriptGujaratiNum,
    ScriptOriyaNum,
    ScriptTeluguNum,
    ScriptKannadaNum,
    ScriptMalayalamNum,
    ScriptTibetanNum,
    ScriptLaoNum,
    ScriptKhmerNum,
    ScriptMyanmarNum,
    ScriptMongolianNum,
    ScriptUrduNum,
    ScriptFarsiNum,
    ScriptHindiNum,
    ScriptContextNum,    // For Arabic/Farsi context digit substitution     

    ScriptMirror,        // Generated in classifier where symmetric swapping required

    ScriptMax            // (maximum boundary)
};



enum ItemScriptClass
{
    StrongClass,       // Alphabetic or other letters
    WeakClass,         // Whitespace, punctuation, symbols
    DigitClass,        // Digits
    SimpleMarkClass,   // Mark displayable by all engines
    ComplexMarkClass,  // Mark requiring specific shaping engine
    ControlClass,      // Control characters
    JoinerClass        // Specifically ZWJ
};



struct  CharacterAttribute {
    ItemScript               Script         :8;
    ItemScriptClass          ScriptClass    :8;
    INT                      Flags          :16;
};

// Character attribute flags

#define CHAR_FLAG_NOTSIMPLE    0x0080L   // Don't try to optimise with the simple imager
#define CHAR_FLAG_DIGIT        0x0100L   // U+0030 - U+0039 only
#define CHAR_FLAG_RTL          0x0200L
// #define CHAR_FLAG_FE           0x0400L  // Already defined as 2000 in USP_PRIV.HXX


extern CharacterAttribute CharacterAttributes[CHAR_CLASS_MAX];




class GpTextItem
{
public:
    GpTextItem(
        ItemScript script,
        INT        state,
        INT        flags = 0,
        BYTE       level = 0
    )
    :   Script (script),
        State  (state),
        Flags  (flags),
        Level  (level)
    {}

    GpTextItem()
    :   Script (ScriptNone),
        State  (0),
        Flags  (0),
        Level  (0)
    {}

    GpTextItem(INT i) :
        Script (ScriptNone),
        State  (0),
        Flags  (0),
        Level  (0)
    {
        ASSERT(i==0); // For NULL costruction only
    }

    GpTextItem& operator= (const GpTextItem &right)
    {
        Flags  = right.Flags;
        State  = right.State;
        Script = right.Script;
        Level  = right.Level;

        return *this;
    }

    bool operator== (const GpTextItem &right) const
    {
        return
                Script == right.Script
            &&  Flags  == right.Flags
            &&  State  == right.State
            &&  Level  == right.Level;
    }

    bool operator== (INT right) const
    {
        ASSERT(right==0);  // For comparison with NULL only
        return Script == ScriptNone;
    }

    ItemScript Script : 8;
    INT        Flags  : 8;
    INT        State  : 8;  // Unicode state flags
    BYTE       Level  : 8;  // Bidi level
};



#endif // _ITEM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\precomp.hpp ===
#include "..\..\entry\precomp.hpp"

#define GDIPLUS 1   // Tell Uniscribe headers not to define face and size caches

extern "C"
{
struct ols;

#include "lscbk.h"
#include "lsdnfin.h"
#include "lsdnset.h"
#include "lstxtcfg.h"
#include "lsimeth.h"
#include "plsline.h"
#include "lslinfo.h"
#include "lschp.h"
#include "lspap.h"
#include "plspap.h"
#include "lstxm.h"
#include "lsdevres.h"
#include "lscontxt.h"
#include "lscrline.h"
#include "lsqline.h"
#include "lssetdoc.h"
#include "lsdsply.h"
#include "heights.h"
#include "lsstinfo.H"
#include "lsulinfo.H"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plstabs.h"
#include "lstabs.h"
#include "robj.h"
#include "ruby.h"
#include "tatenak.h"
#include "warichu.h"
#include "lsffi.h"
#include "lstfset.h"
#include "lsqsinfo.h"
#include "lscell.h"
#include "lskysr.h"
}

#include "USP10.h"
#include "usp10p.h"

#include "usp_fontcache.hpp"    // Override SIZE_CACHE & FACE_CACHE

#include "unipart.hxx"
#include "unidir.hxx"
#include "secondaryClassification.hpp"
#include "usp_priv.hxx"

#include "usp_macro.hpp"

#include "brkclass.hxx"
#include "dwchar.hxx"
#include "item.hpp"
#include "run.hpp"
#include "break.hpp"
#include "lineServicesOwner.hpp"
#include "builtLine.hpp"
#include "paragraph.hpp"
#include "span.hpp"
#include "flip.hpp"
#include "imager.hpp"
#include "glyphPlacement.hpp"
#include "shaping.hpp"
#include "BiDiAnalysis.hpp"
#include "familyfallback.hpp"

#include "otl_scrp.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\paragraph.hpp ===
#ifndef _PARAGRAPH_HPP
#define _PARAGRAPH_HPP


/////   Paragraph - Describes a paragraph in Line Services terms
//
//


struct Paragraph
{
    INT imagerStringOffset; // First char of para in imager terms
    INT imagerStringLimit;  // First char of next para in imager terms

};
#endif // _PARAGRAPH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\simpletextimager.cpp ===
/////   SimpleTextImager
//
//      Handles draw and mesure requests for a single line of simple text


/////   Assumptions
//
//      A simple text imager is only created when:
//
//          The text contains only simple script characters
//          There are no line breaks
//          The text is horizontal


#include "precomp.hpp"

GpStatus SimpleTextImager::Draw(
    GpGraphics *graphics,
    const PointF *origin
)
{
    GpStatus status;
    GpMatrix worldToDevice;
    graphics->GetWorldToDeviceTransform(&worldToDevice);

    REAL fontScale = EmSize / TOREAL(Face->GetDesignEmHeight());

    GpMatrix fontTransform(worldToDevice);
    fontTransform.Scale(fontScale, fontScale);

    // Build a face realization and prepare to adjust glyph placement

    GpFaceRealization faceRealization(
        Face,
        Style,
        &fontTransform,
        SizeF(graphics->GetDpiX(), graphics->GetDpiY()),
        graphics->GetTextRenderingHintInternal(),
        FALSE, /* bPath */
        FALSE /* bCompatibleWidth */
    );

    if (faceRealization.GetStatus() != Ok)
    {
        ASSERT(faceRealization.GetStatus() == Ok);
        return faceRealization.GetStatus();
    }

    if (faceRealization.IsPathFont())
    {
        /* the font size is too big to be handled by bitmap, we need to use path */
        GpPath path(FillModeWinding);
        GpLock lockGraphics(graphics->GetObjectLock());

        status = AddToPath( &path, origin);
        IF_NOT_OK_WARN_AND_RETURN(status);

        status = graphics->FillPath(Brush, &path);
        IF_NOT_OK_WARN_AND_RETURN(status);
    }
    else
    {

        AutoArray<PointF> glyphOrigins(new PointF[GlyphCount]);
        if (!glyphOrigins)
        {
            return OutOfMemory;
        }


        // Set first (leftmost) glyph origin

        PointF baselineOrigin(*origin);  // Origin in world coordinates

        // Offset x coordinate for alignment

        switch (Format ? Format->GetAlign() : StringAlignmentNear)
        {
        case StringAlignmentCenter:
            baselineOrigin.X += GpRound((Width - TotalWorldAdvance) / 2);
            break;

        case StringAlignmentFar:
            baselineOrigin.X += GpRound(Width - TotalWorldAdvance);
            break;
        }


        // Offset y coordinate for line alignment

        REAL cellHeight =   EmSize * (Face->GetDesignCellAscent() + Face->GetDesignCellDescent())
                          / Face->GetDesignEmHeight();

        switch (Format ? Format->GetLineAlign() : StringAlignmentNear)
        {
        case StringAlignmentCenter:
            baselineOrigin.Y += (Height - cellHeight) / 2;
            break;

        case StringAlignmentFar:
            baselineOrigin.Y += Height - cellHeight;
        }


        // Offset y coordinate from cell top to baseline

        baselineOrigin.Y +=   EmSize * Face->GetDesignCellAscent()
                             / Face->GetDesignEmHeight();

        baselineOrigin.X += LeftMargin;

        // Determine device glyph positions

        GlyphImager glyphImager(
            &faceRealization,
            &worldToDevice,
            WorldToIdeal,
            EmSize,
            GlyphCount,
            Glyphs
        );

        INT formatFlags = Format ? Format->GetFormatFlags() : 0;

        status = glyphImager.GetDeviceGlyphOrigins(
            &GpTextItem(0),
            formatFlags,
            GpRound(LeftMargin * WorldToIdeal),
            GpRound(RightMargin * WorldToIdeal),
            formatFlags & StringFormatFlagsNoFitBlackBox,
            formatFlags & StringFormatFlagsNoFitBlackBox,
            Format ? Format->GetAlign() : StringAlignmentNear,
            NULL,   // no glyph properties
            GlyphAdvances,
            NULL,   // no glyph offsets
            baselineOrigin,
            glyphOrigins.Get()
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        GpRegion *previousClip  = NULL;

        BOOL applyClip =
                Format
            &&  !(Format->GetFormatFlags() & StringFormatFlagsNoClip)
            &&  Width
            &&  Height;

        if (applyClip)
        {
            //  Preserve existing clipping and combine it with the new one if any
            if (!graphics->IsClipEmpty())
            {
                previousClip = graphics->GetClip();
            }

            RectF clippingRect(origin->X, origin->Y, Width, Height);
            graphics->SetClip(clippingRect, CombineModeIntersect);
        }

        status = graphics->DrawPlacedGlyphs(
            &faceRealization,
            Brush,
            (Format && Format->GetFormatFlags() & StringFormatFlagsPrivateNoGDI)
            ?  DG_NOGDI : 0,
            String,
            Length,
            FALSE,
            Glyphs,
            NULL, // one to one mapping in simple text imager
            glyphOrigins.Get(),
            GlyphCount,
            ScriptLatin,
            FALSE    // sideways
        );

        if (applyClip)
        {
            //  Restore clipping state if any
            if (previousClip)
            {
                graphics->SetClip(previousClip, CombineModeReplace);
                delete previousClip;
            }
            else
            {
                graphics->ResetClip();
            }
        }
    }

    return status;
}




GpStatus SimpleTextImager::AddToPath(
    GpPath *path,
    const PointF *origin
)
{
    GpStatus status;

    // !!! Need to loop through brushes individually

    // Establish font transformation

    REAL fontScale = EmSize / TOREAL(Face->GetDesignEmHeight());

    GpMatrix fontTransform;
    fontTransform.Scale(fontScale, fontScale);

    // Build a face realization and prepare to adjust glyph placement
    const GpMatrix identity;
    GpFaceRealization faceRealization(
        Face,
        Style,
        &identity,
        SizeF(150.0, 150.0),    // Arbitrary - we won't be hinting
        TextRenderingHintSingleBitPerPixel, // claudebe, do we want to allow for hinted or unhinted path ? // graphics->GetTextRenderingHint(),
        TRUE, /* bPath */
        FALSE /* bCompatibleWidth */
    );


    status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);

    // Add glyphs to path

    INT i=0;

    PointF glyphOrigin(*origin);


    // Adjust so origin corresponds to top of initial cell.

    glyphOrigin.Y += TOREAL(   Face->GetDesignCellAscent() * EmSize
                            /  Face->GetDesignEmHeight());

    glyphOrigin.X += LeftMargin;

    while (    i < (INT)GlyphCount
           &&  status == Ok)
    {
        // Set marker at start of each logical character = cell = cluster

        path->SetMarker();


        // Add the path for the glyph itself

        GpGlyphPath *glyphPath = NULL;

        status = faceRealization.GetGlyphPath(
            *(Glyphs+i),
            &glyphPath
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        if (glyphPath != NULL)
        {
            status = path->AddGlyphPath(
                glyphPath,
                glyphOrigin.X,
                glyphOrigin.Y,
                &fontTransform
            );
            IF_NOT_OK_WARN_AND_RETURN(status);
        }

        // Update path position

        glyphOrigin.X += GlyphAdvances[i] / WorldToIdeal;


        i++;
    }

    // Force marker following last glyph

    path->SetMarker();

    return status;
}


GpStatus SimpleTextImager::Measure(
    GpGraphics *graphics,
    REAL       *nearGlyphEdge,
    REAL       *farGlyphEdge,
    REAL       *textDepth,
    INT        *codepointsFitted,
    INT        *linesFilled
) {
    // Offset x coordinate for alignment

    switch (Format ? Format->GetAlign() : StringAlignmentNear)
    {
        case StringAlignmentNear:
            *nearGlyphEdge = 0;
            *farGlyphEdge  = TotalWorldAdvance;
            break;

        case StringAlignmentCenter:
            *nearGlyphEdge = TOREAL((Width - TotalWorldAdvance) / 2.0);
            *farGlyphEdge  = *nearGlyphEdge + TotalWorldAdvance;
            break;

        case StringAlignmentFar:
            *nearGlyphEdge = Width - TotalWorldAdvance;
            *farGlyphEdge  = Width;
            break;
    }


    // Offset y coordinate for line alignment

    REAL cellHeight =   EmSize * (Face->GetDesignCellAscent() + Face->GetDesignCellDescent())
                      / Face->GetDesignEmHeight();

    *textDepth = cellHeight;

    if (codepointsFitted) {*codepointsFitted = GlyphCount;}
    if (linesFilled)      {*linesFilled      = 1;}

    return Ok;
}



#ifndef DCR_REMOVE_OLD_174340
GpStatus SimpleTextImager::MeasureRegion(
    INT           firstCharacterIndex,
    INT           characterCount,
    const PointF *origin,
    GpRegion     *region
)
{
    return MeasureRangeRegion(
        firstCharacterIndex,
        characterCount,
        origin,
        region
    );
}
#endif


GpStatus SimpleTextImager::MeasureRangeRegion(
    INT           firstCharacterIndex,
    INT           characterCount,
    const PointF *origin,
    GpRegion     *region
)
{
    if (!region || !region->IsValid())
    {
        return InvalidParameter;
    }

    region->SetEmpty();


    if (!characterCount)
    {
        //  return empty region
        return Ok;
    }
    else if (characterCount < 0)
    {
        firstCharacterIndex += characterCount;
        characterCount = -characterCount;
    }

    if (   firstCharacterIndex < 0
        || firstCharacterIndex > Length
        || firstCharacterIndex + characterCount > Length)
    {
        return InvalidParameter;
    }

    RectF rect;

    rect.X = origin->X + LeftMargin;
    rect.Y = origin->Y;

    switch (Format ? Format->GetAlign() : StringAlignmentNear)
    {
        case StringAlignmentNear:
            // nothing to add
            break;

        case StringAlignmentCenter:
            rect.X += TOREAL((Width - TotalWorldAdvance) / 2.0);
            break;

        case StringAlignmentFar:
            rect.X += TOREAL(Width - TotalWorldAdvance) ;
            break;
    }

    INT i = 0;
    REAL accumulated = 0.0f;
    while (i < firstCharacterIndex)
    {
        accumulated += GlyphAdvances[i];
        i++;
    }

    rect.X += accumulated / WorldToIdeal;

    rect.Width =0;
    while (i < min(firstCharacterIndex+characterCount , Length))
    {
        rect.Width += GlyphAdvances[i];
        i++;
    }
    rect.Width /= WorldToIdeal;

    rect.Height =   EmSize * (Face->GetDesignCellAscent() + Face->GetDesignCellDescent())
                      / Face->GetDesignEmHeight();


    switch (Format ? Format->GetLineAlign() : StringAlignmentNear)
    {
        case StringAlignmentNear:
            // nothing to add
            break;

        case StringAlignmentCenter:
            rect.Y += TOREAL((Height - rect.Height) / 2.0);
            break;

        case StringAlignmentFar:
            rect.Y += TOREAL(Height - rect.Height) ;
            break;
    }

    region->Set(&rect);

    return Ok;
}


GpStatus SimpleTextImager::MeasureRanges(
    GpGraphics      *graphics,
    const PointF    *origin,
    GpRegion        **regions
)
{
    if (!Format)
    {
        return InvalidParameter;
    }

    CharacterRange *ranges;
    INT rangeCount = Format->GetMeasurableCharacterRanges(&ranges);


    RectF clipRect(origin->X, origin->Y, Width, Height);
    BOOL clipped = !(Format->GetFormatFlags() & StringFormatFlagsNoClip);

    GpStatus status = Ok;

    for (INT i = 0; i < rangeCount; i++)
    {
        GpLock lockRegion(regions[i]->GetObjectLock());

        if (!lockRegion.IsValid())
        {
            return ObjectBusy;
        }

        status = MeasureRangeRegion (
            ranges[i].First,
            ranges[i].Length,
            origin,
            regions[i]
        );

        if (status != Ok)
        {
            return status;
        }

        if (clipped)
        {
            // we have a clipping so we need to make sure we didn't get out
            // of the layout box

            regions[i]->Combine(&clipRect, CombineModeIntersect);
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\span.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Character span support
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"

////    VectorBase - very very simple dynamic array base class
//
//      VectorBase[]            - directly address index element (index checked in checked build)
//      VectorBase.Resize(size) - Allocate memory for at least size elements
//      VectorBase.Shrink(size) - Reduce vector to exactly size


template <class C> BOOL VectorBase<C>::Resize(INT targetAllocated)
{
    if (targetAllocated > Allocated)
    {
        INT newAllocated = targetAllocated;   // Required minimum new size

        // Round up to nearest higher power of sqrt(2). The idea is to
        // grow at least exponentially, but not as fast as doubling each
        // time.

        // First find nearest higher power of 2.

        newAllocated |= newAllocated >> 1;
        newAllocated |= newAllocated >> 2;
        newAllocated |= newAllocated >> 4;
        newAllocated |= newAllocated >> 8;
        newAllocated |= newAllocated >> 16;
        newAllocated |= newAllocated >> 32;
        newAllocated++;

        // We now know that newAllocated is a power of two
        // and that targetAllocated is between newAllocated/2 and newAllocated.

        // Adjust roundup to power of sqrt(2) by seeing which side of
        // 3/4 newAllocated targetAllocated falls.

        if (targetAllocated < newAllocated - (newAllocated >> 2))
        {
            // targetAllocated is between 1/2 and 3/4 the next higher power
            // of two - reduce newAllocated by 1/4 newAllocated.

            newAllocated -= newAllocated >> 2;

            // (This isn't eactly powers of root 2 as the intermediate steps
            // are 1.5 times the next lower power of two when they should be
            // 1.414 times. But this is more than good enough.)
        }

        C *newElements = (C*) GpRealloc(VectorElements, sizeof(C) * newAllocated);

        if (newElements)
        {
            Allocated      = newAllocated;
            VectorElements = newElements;
        }
        else
        {   // Reallocation failed - fatal
            return FALSE;
        }
    }

    return TRUE;
}


template <class C> BOOL VectorBase<C>::Shrink(INT targetAllocated)
{
    if (targetAllocated < Allocated)
    {
        if (targetAllocated > 0)
        {
            C *newElements = (C*) GpRealloc(VectorElements, sizeof(C) * targetAllocated);

            if (newElements)
            {
                Allocated      = targetAllocated;
                VectorElements = newElements;
                return TRUE;
            }
            else
            {   // Reallocation failed - fatal
                return FALSE;
            }
        }
        else
        {
            GpFree(VectorElements);
            Allocated      = 0;
            VectorElements = NULL;
        }
    }
    return TRUE;
}





/**************************************************************************\
*
* template <class C> void SpanVector<C>::SetSpan:
*
*   Update span vector with an Element over a range
*
* Arguments:
*
*   IN    first   - first character having this attribute
*   IN    Length  - number of characters having this attribute
*   IN    Element - attribute to record for this range
*
* Return Value:
*
*   none
*
* Algorithm
*
*   Identify first and last existing Spans affected by the change
*   Where status adjacent to the change is the same as the change
*   update the change range to include adjacent equal value.
*   Calculate how many Spans need to be added or removed.
*   Insert null Spans or delete Spans after first affected span.  The first
*   affected span may be updated, but is never removed.
*
*
* Created:
*
*   06/18/99 dbrown
*
\**************************************************************************/

template <class C> GpStatus SpanVector<C>::SetSpan(
    INT  first,
    INT  Length,
    C    Element
)
{
    GpStatus status = Ok;
    ASSERT(first  >= 0);
    ASSERT(Length >= 0);


    // Identify first span affected by update

    INT fs = 0;     // First affected span index
    INT fc = 0;     // Character position at start of first affected span

    while (    fs < Active
           &&  fc + (INT)Spans[fs].Length <= first)
    {
        fc += Spans[fs].Length;
        fs++;
    }


    // If the span list terminated before first, just add the new span

    if (fs >= Active)
    {
        // Ran out of Spans before reaching first

        ASSERT(fc <= first);

        if (fc < first)
        {
            // Create default run up to first
            status = Add(Span<C>(Default, first-fc));
            if (status != Ok)
                return status;
        }

        if (    Active > 0
            &&  Spans[Active-1].Element == Element)
        {
            // New Element matches end Element, just extend end Element
            Spans[Active-1].Length += Length;
        }
        else
        {
            status = Add(Span<C>(Element, Length));
        }

        return status;
    }


    // fs = index of first span partly or completely updated
    // fc = character index at start of fs

    // Now find the last span affected by the update

    INT ls = fs;
    INT lc = fc;

    while (    ls < Active
           &&  lc + (INT)Spans[ls].Length <= first+Length)
    {
        lc += Spans[ls].Length;
        ls++;
    }


    // ls = first span following update to remain unchanged in part or in whole
    // lc = character index at start of ls


    // expand update region backwatds to include existing Spans of identical
    // Element type

    if (first == fc)
    {
        // Item at [fs] is completely replaced. Check prior item

        if (    fs > 0
            &&  Spans[fs-1].Element == Element)
        {
            // Expand update area over previous run of equal classification
            fs--;
            fc -= Spans[fs].Length;
            first = fc;
            Length += Spans[fs].Length;
        }

    }
    else
    {
        // Item at [fs] is partially replaced. Check if it is same as update
        if (Spans[fs].Element == Element)
        {
            // Expand update area back to start of first affected equal valued run
            Length = first+Length-fc;
            first = fc;
        }
    }


    // Expand update region forwards to include existing Spans of identical
    // Element type

    if (    ls < Active
        &&  Spans[ls].Element == Element)
    {
        // Extend update region to end of existing split run

        Length = lc + Spans[ls].Length - first;
        lc += Spans[ls].Length;
        ls++;
    }


    // If no old Spans remain beyond area affected by update, handle easily:

    if (ls >= Active)
    {
        // None of the old span list extended beyond the update region

        if (fc < first)
        {
            // Updated region leaves some of [fs]

            if (Active != fs+2)
            {
                if (!Spans.Resize(fs+2))
                    return OutOfMemory;
                Active = fs+2;
            }
            Spans[fs].Length = first - fc;
            Spans[fs+1] = Span<C>(Element, Length);
        }
        else
        {
            // Updated item replaces [fs]

            if (Active != fs+1)
            {
                if (!Spans.Resize(fs+1))
                    return OutOfMemory;
                Active = fs+1;
            }
            Spans[fs] = Span<C>(Element, Length);
        }

        return status;  // DONE
    }


    // Record partial elementtype at end, if any

    C    trailingElement;
    INT  trailingLength;

    if (first+Length > lc)
    {
        trailingElement = Spans[ls].Element;
        trailingLength  = lc + Spans[ls].Length - (first+Length);
    }


    // Calculate change in number of Spans

    INT spanDelta =    1                          // The new span
                    +  (first  > fc ? 1 : 0)      // part span at start
                    -  (ls-fs);                   // existing affected span count

    // Note part span at end doesn't affect the calculation - the run may need
    // updating, but it doesn't need creating.


    if (spanDelta < 0)
    {
        status = Erase(fs + 1, -spanDelta);
        if (status != Ok)
            return status;
    }
    else if (spanDelta > 0)
    {
        status = Insert(fs + 1, spanDelta);
        if (status != Ok)
            return status;
        // Initialize inserted Spans
        for (INT i=0; i<spanDelta; i++)
        {
            Spans[fs+1+i] = Span<C>(NULL, 0);
        }
    }


    // Assign Element values

    // Correct Length of split span before updated range

    if (fc < first)
    {
        Spans[fs].Length = first-fc;
        fs++;
    }

    // Record Element type for updated range

    Spans[fs] = Span<C>(Element, Length);
    fs++;

    // Correct Length of split span following updated range

    if (lc < first+Length)
    {
        Spans[fs] = Span<C>(trailingElement, trailingLength);
    }

    // Phew, all done ....

    return Ok;
}

    // For checked builds and debugging only

#if DBG
    template <class C> void SpanVector<C>::Dump()
    {
        //OutputDebugStringA("Dump of SpanVector<");
        //OutputDebugStringA(typeid(C).name());
        //OutputDebugStringA(">\r\n  ");
        if (Active <= 0)
        {
            OutputDebugStringA("empty.");
        }
        else
        {
            INT i;
            INT offset = 0;
            for (i=0; i<Active; i++)
            {
                char str[30];
                wsprintfA(str, "[%d]L%d=%x, ", offset, Spans[i].Length, Spans[i].Element);
                offset += Spans[i].Length;
                OutputDebugStringA(str);
            }
        }
        OutputDebugStringA("\r\n");
    }
#endif





template <class C> GpStatus SpanVector<C>::OrSpan(
    INT  first,
    INT  length,
    C    element
)
{
    SpanRider<C> rider(this);
    rider.SetPosition(first);

    INT offset = first;
    UINT advance;

    while (length > 0)
    {
        advance = min(rider.GetUniformLength(), (UINT)length);
        GpStatus status = rider.SetSpan(offset, advance, element | rider.GetCurrentElement());
        if (status != Ok)
            return status;

        offset += advance;
        length -= advance;
        rider.SetPosition(offset);
    }
    return Ok;
}




/*
template <class C> GpStatus SpanVector<C>::OrSpan(
    INT  first,
    INT  length,
    C    element
)
{
    if (!length || !element)
    {
        return Ok;
    }

    ASSERT(first  >= 0);
    ASSERT(length >= 0);


    //  Identify first span affected by update

    INT fs = 0;     // First affected span index
    INT fc = 0;     // Character position at start of first affected span

    while (    fs < Active
           &&  fc + (INT)Spans[fs].Length <= first)
    {
        fc += Spans[fs].Length;
        fs++;
    }

    // If the span list terminated before first, just add the new span

    if (fs >= Active)
    {
        // Ran out of Spans before reaching first

        ASSERT(fc <= first);

        if (fc < first)
        {
            // Create default run up to first
            Add(Span<C>(Default, first - fc));
        }

        if (    Active > 0
            &&  Spans[Active - 1].Element == (element | Default))
        {
            // New Element matches end Element, just extend end Element
            Spans[Active - 1].Length += length;
        }
        else
        {
            Add(Span<C>(element, length));
        }

        return Ok;
    }

    if (first > fc)
    {
        //  Split a new span
        Insert(fs + 1, 1);

        Spans[fs + 1] = Span<C>(Spans[fs].Element, Spans[fs].Length - first + fc);
        Spans[fs].Length = first - fc;
        fs++;
        fc = first;
    }


    //  Now find the last span affected by the update

    INT ls = fs;
    INT lc = fc;

    while (    ls < Active
           &&  lc + (INT)Spans[ls].Length <= first + length)
    {
        lc += Spans[ls].Length;
        ls++;
    }

    if (   ls >= Active
        && first + length > lc)
    {
        // No old Spans remain beyond area affected by update

        INT uc = first + length - lc;   // update characters beyond end span

        if (   Active > 0
            && Spans[Active - 1].Element == (element | Default))
        {
            // New Element matches end Element, just extend end Element
            Spans[Active - 1].Length += uc;
        }
        else
        {
            Add(Span<C>(element, uc));
            ls++;
        }

        lc += uc;
    }

    if (lc < first + length)
    {
        //  Split a new span
        Insert(ls, 1);

        Spans[ls] = Span<C>(Spans[ls + 1].Element, first + length - lc);
        Spans[ls + 1].Length -= Spans[ls].Length;
        ls++;
        lc = first + length;
    }

    //  OR all affected spans

    for (INT i = fs; i < ls; i++)
    {
        Spans[i].Element |= element;
    }

    //  Merge adjacent spans if any duplicates

    fs = max(fs - 1, 0);
    ls = min(ls + 1, Active);

    INT s = fs;
    INT ms = s + 1;     // first span outside the merge range

    while (s < ls)
    {
        //  Find continuous spans to be merged
        while (   ms < ls
               && Spans[ms].Element == Spans[s].Element)
        {
            ms++;
        }

        if (ms - s > 1)
        {
            //  Merge all at once
            for (INT i = 1; i < ms - s; i++)
            {
                Spans[s].Length += Spans[s + i].Length;
            }

            Erase(s + 1, ms - s - 1);
        }

        s = ms;
        ms++;
    }

    return Ok;
}
*/


template <class C> void SpanVector<C>::Reset(BOOL shrink)
{
    Active = 0;
    if (shrink)
    {
        Spans.Shrink(0);
    }
}


template <class C> GpStatus SpanVector<C>::Erase(INT first, INT count)
{
    ASSERT(first>=0);
    ASSERT(count>=0);

    if (    first + count >= Active
        &&  first < Active)
    {
        // Erase at end
        if (!Spans.Resize(first))
            return OutOfMemory;
        Active = first;
    }
    else
    {
        GpMemmove(
            &Spans[first],
            &Spans[first+count],
            sizeof(Span<C>) * (Active - (first+count))
        );
        if (!Spans.Resize(Active-count))
            return OutOfMemory;
        Active -= count;
    }
    return Ok;
}


template <class C> GpStatus SpanVector<C>::Insert(INT first, INT count)
{
    ASSERT(first >= 0);
    ASSERT(count >= 0);


    if (first >= Active)
    {
        // All new entries are beyond exisiting entries
        if (!Spans.Resize(first+count))
            return OutOfMemory;
        Active = first+count;
    }
    else
    {
        // Make room for <count> more entries, and move all entries from
        // first to the old end up to the new end.

        /* Can't think why I wrote this: looks daft now [dbrown 19 Dec 99]
            INT amountToMove = count;
            if (amountToMove > Active-first)
            {
                amountToMove = Active-first;
            }
        */

        INT amountToMove = Active-first;

        if (!Spans.Resize(Active+count))
            return OutOfMemory;
        Active += count;
        GpMemmove(&Spans[first+count], &Spans[first], sizeof(Span<C>) * amountToMove);
    }
    return Ok;
}


template <class C> GpStatus SpanVector<C>::Add(const Span<C> &newSpan)
{
    if (!Spans.Resize(Active+1))
        return OutOfMemory;
    Active++;
    Spans[Active-1] = newSpan;
    return Ok;
}



/////   SpanRider - a class for efficiently running a cursor along a span vector
//
//


template <class C> BOOL SpanRider<C>::SetPosition(UINT32 newOffset)
{
    #if DBG
        // Check that current position details are valid

        if (newOffset > 0)
        {
            UINT offset = 0;
            INT element = 0;
            while (    offset < CurrentElementIndex
                   &&  element < Spanvector->Active)
            {
                offset += Spanvector->Spans[element].Length;
                element++;
            }

            ASSERT(element <= Spanvector->Active);
            ASSERT(element == CurrentElement);
            ASSERT(offset == CurrentElementIndex);
            if (element < Spanvector->Active)
            {
                ASSERT(CurrentOffset < offset + Spanvector->Spans[element].Length);
            }
        }
    #endif


    if (newOffset < CurrentElementIndex)
    {
        // Need to start at the beginning again
        CurrentOffset       = 0;
        CurrentElement      = 0;
        CurrentElementIndex = 0;
    }

    // Advance to element containing new offset

    while (    CurrentElement < Spanvector->Active
           &&  CurrentElementIndex + Spanvector->Spans[CurrentElement].Length <= newOffset)
    {
        CurrentElementIndex += Spanvector->Spans[CurrentElement].Length;
        CurrentElement++;
    }

    if (CurrentElement < Spanvector->Active)
    {
        CurrentOffset = newOffset;
        return TRUE;
    }
    else
    {
        CurrentOffset = min(newOffset, CurrentElementIndex);
        return FALSE;
    }
}



///// Explicit instantiations

//template class SpanVector<class BuiltLine*>;
//template class SpanVector<class GpTextItem>;
template class SpanRider<int>;
//template class SpanRider<struct lsrun *>;
template class SpanRider<class GpStringFormat const *>;
template class SpanRider<float>;
template class SpanRider<class GpBrush const *>;
template class SpanRider<BYTE>;

template GpStatus SpanVector<class BuiltLine *>::SetSpan(int,int,class BuiltLine *);
template GpStatus SpanVector<class GpTextItem>::SetSpan(int,int,class GpTextItem);
template GpStatus SpanVector<struct lsrun *>::SetSpan(int,int,struct lsrun *);
template GpStatus SpanVector<BYTE>::SetSpan(int,int,BYTE);
template GpStatus SpanVector<class Break *>::SetSpan(int,int,class Break *);
template GpStatus SpanVector<INT>::SetSpan(int,int, INT);

template void     SpanVector<UINT32>::Reset(BOOL);
template GpStatus SpanVector<UINT32>::OrSpan(int,int, UINT32);

template int      SpanRider<struct lsrun *>::SetPosition(unsigned int);
template int      SpanRider<class GpFontFamily const *>::SetPosition(unsigned int);
template int      SpanRider<class GpTextItem>::SetPosition(unsigned int);
template int      SpanRider<BYTE>::SetPosition(unsigned int);
template int      SpanRider<class Break *>::SetPosition(unsigned int);
template int      SpanRider<class BuiltLine *>::SetPosition(unsigned int);
template int      SpanRider<INT>::SetPosition(unsigned int);
template int      SpanRider<UINT32>::SetPosition(unsigned int);



template BOOL VectorBase<UINT>::Resize(INT);
template BOOL VectorBase<UINT>::Shrink(INT);
template BOOL VectorBase<LSTBD>::Resize(INT);
template BOOL VectorBase<LSTBD>::Shrink(INT);
template BOOL VectorBase<BREAKREC>::Resize(INT);
template BOOL VectorBase<BREAKREC>::Shrink(INT);


template void SpanVector<class GpTextItem>::Reset(INT);
template void SpanVector<BYTE>::Reset(INT);


#if DBG
    template void     SpanVector<struct lsrun *>::Dump();
    template void     SpanVector<BYTE>::Dump();
    template void     SpanVector<UINT32>::Dump();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\splittransform.cpp ===
#include <precomp.hpp>


const DOUBLE PI = 3.1415926535897932384626433832795;



/**************************************************************************\
*
* SplitTransform:
*
*   Separates a transform into the sequence
*
*   o  scale        x always positive, y positive or negative
*   o  rotate       0 - 2pi
*   o  shear        along x (as a positive or negative factor of y)
*   o  translate    any x,y
*
* Arguments:
*
*   IN   transform
*   OUT  scale
*   OUT  rotate
*   OUT  shear
*   OUT  translate
*
* Return Value:
*
*   none
*
* Created:
*
*   06/18/99 dbrown
*
* !!!
*   SplitTransform should probably be in matrix.hpp
*
\**************************************************************************/

void SplitTransform(
    const GpMatrix  &matrix,
    PointF          &scale,
    REAL            &rotate,
    REAL            &shear,
    PointF          &translate)
{

    REAL m[6];
    matrix.GetMatrix(m);

    // m11 = m[0]    m12 = m[1]
    // m21 = m[2]    m22 = m[3]
    //  dx = m[4]     dy = m[5]


    // Extract translation

    translate = PointF(m[4],m[5]);


    //         2           2
    // Use  Sin theta + cos theta = 1 to obtain (absolute value) of
    // the X scale factor. Because we're returning the shear in X only,
    // it is a factor of y, so this formula is correct regardless of shear.


    REAL m11Sq = m[0]*m[0];
    REAL m12Sq = m[1]*m[1];

    scale.X = TOREAL(sqrt(m11Sq + m12Sq));

    // Always treat X scale factor as positive: handle originally negative
    // X scale factors as rotation by 180 degrees and invert Y scale factor.


    if (m[1] >= 0 && m[0] > 0)
    {
        rotate = TOREAL(atan(m[1]/m[0]));          // 0-90
    }
    else if (m[0] < 0)
    {
        rotate = TOREAL(atan(m[1]/m[0]) + PI);     // 90-270
    }
    else if (m[1] < 0 && m[0] > 0)
    {
        rotate = TOREAL(atan(m[1]/m[0]) + 2*PI);   // 270-360
    }
    else
    {
        // m[0] == 0

        if (m[1] > 0)
        {
            rotate = TOREAL(PI/2);                 // 90
        }
        else
        {
            rotate = TOREAL(3*PI/2);               // 270
        }
    }


    // y scale factor in terms of x scale factor

    scale.Y = scale.X * (m[0]*m[3] - m[1]*m[2]) / (m11Sq + m12Sq);


    // Shear

    shear = (m[1]*m[3] + m[0]*m[2]) / (m11Sq + m[1]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\run.hpp ===
#ifndef _RUN_HPP
#define _RUN_HPP


////    Run - character sequence of consistent properties
//
//      Represents a run for passing to line services.
//
//      Runs are maintained in the text imager run span vector. The vector
//      is indexed by line services character position rather than imager
//      string offsets. Line services character positions are the same as
//      imager offsets for single direction text, however extra level opening
//      and closing characters are inserted for bidirectional strings.


struct lsrun
{
    enum Type
    {
        RunText,            // Normal run addressing text in the imager string
        RunEndOfParagraph,  // A virtual CR/LF representing the end of paragraph
        RunLevelUp,         // The preceding run has lower level
        RunLevelDown,       // The following run has lower level
        RunLevelSeparator,  // A level close followed by a level open
        RunNone
    } RunType;

    INT                ImagerStringOffset;  // Offset into imager string
    UINT               CharacterCount;

    // Note: the right-to-left flag in FormatFlags is the paragraph reading order.
    // The presentation order is the bottom bit of the Level field in Item.

    GpTextItem         Item;                // A copy of corresponding item in item vector
    INT                FormatFlags;         // Format flags

    const GpFontFace  *Face;                // Actual font face used, including font fallback
    REAL               EmSize;              // em size in world units
    REAL               BaselineOffset;      // Offset required for font fallback

    // The following buffers are released following line building

    INT                GlyphCount;
    GINDEX            *Glyphs;
    GMAP              *GlyphMap;
    GPROP             *GlyphProperties;
    USHORT             EngineState;         // state needed to be preserved across runs

    
    // Leading/trailing edge adjustment,
    // positive in text flow direction of run

    struct Adjustment
    {
        Adjustment (
            INT     leading,
            INT     trailing
        ) :
            Leading (leading),
            Trailing (trailing)
        {}

        INT     Leading;
        INT     Trailing;
    } Adjust;


    // Construction from basic (unglyphed) content

    lsrun(
        IN  Type               runType,
        IN  INT                runStringStart,
        IN  INT                runLength,
        IN  const GpTextItem  &item,
        IN  INT                formatFlags
    ) :
        RunType             (runType),
        ImagerStringOffset  (runStringStart),
        CharacterCount      (runLength),
        Item                (item),
        FormatFlags         (formatFlags),
        Face                (NULL),
        EmSize              (0),
        BaselineOffset      (0),
        GlyphCount          (0),
        Glyphs              (NULL),
        GlyphMap            (NULL),
        GlyphProperties     (NULL),
        EngineState         (0),
        Adjust              (0, 0)
    {}


    lsrun(const lsrun& run) :
        RunType             (run.RunType),
        ImagerStringOffset  (run.ImagerStringOffset),
        CharacterCount      (run.CharacterCount),
        Item                (run.Item),
        FormatFlags         (run.FormatFlags),
        Face                (run.Face),
        EmSize              (run.EmSize),
        BaselineOffset      (run.BaselineOffset),
        EngineState         (run.EngineState),
        Adjust              (run.Adjust),
        GlyphCount          (0),
        Glyphs              (NULL),
        GlyphMap            (NULL),
        GlyphProperties     (NULL)
    {}


    // Constructor as duplicate of existing run

    /*
    lsrun(
        const lsrun *previousRun
    )
    {
        *this = *previousRun;
    }
    */


    ~lsrun()
    {
        if (Glyphs)          delete [] Glyphs;
        if (GlyphMap)        delete [] GlyphMap;
        if (GlyphProperties) delete [] GlyphProperties;
    }
};

#endif // _RUN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\inc\otlcbdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLCBDEF.H  ********
*
*            OTL Services Library Callback Function Definitions
*
*       The OTL Services Library calls back to the functions defined
*       in this file for operating system rescources.        - deanb
*
*       Copyright 1996 - 1997. Microsoft Corporation.
*
*       Jun 13, 1996    v 0.2   First release
*       Sep 25, 1996    v 0.3   Rename to OTL, trimmed to core
*       Jan 15, 1997    v 0.4   Portability renaming, etc.
*       Mar 14, 1997    v 0.5   Table tag param for FreeTable
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************


/***********************************************************************
*
*           Resource Management Callback Function Type Definitions
*   
***********************************************************************/

typedef enum 
{
	otlDestroyContent	= 0,
	otlPreserveContent	= 1
}
otlReallocOptions;

#ifdef __cplusplus

class IOTLClient
{
public:

	virtual BYTE* GetOtlTable 
	(
		const	otlTag		tagTableName        // truetype table name tag 
	) = 0;

	virtual void FreeOtlTable 
	(
		BYTE*				pvTable,			// in: in case client needs it
		const otlTag		tagTableName        // in: truetype table name tag 
	) = 0;

	virtual otlErrCode ReallocOtlList
	(
		otlList*			pList,				// in/out 
		USHORT				cbNewDataSize,		// in 
		USHORT				celmNewMaxLen,		// in 
		otlReallocOptions	optPreserveContent	// in; if set, client may assert  
												//   cbNewDataSize == cbDataSize
	) = 0;

	virtual otlErrCode GetDefaultGlyphs 
	(
		const otlList*		pliChars,			// in: characters 
		otlList*			pliGlyphInfo		// out: glyphs 
												// (fill in the "glyph" field only) 
	) = 0;

	virtual otlErrCode GetDefaultAdv 
	(
		const otlList*		pliGlyphInfo,	// in: glyphs 
		otlList*			pliduGlyphAdv	// out:	default glyph advances 
	) = 0;

	virtual otlErrCode GetGlyphPointCoords 
	(
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement**		prgplc				// out: x, y coords of points 
	) = 0;

	virtual otlErrCode FreeGlyphPointCoords
	(
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement*		rgplc				// in: point coord array to free
	) = 0;

};

#else // !defined(__cplusplus)

typedef struct 
{
  const IOTLClientVtbl* lpVtbl;
} 
IOTLClient;


typedef struct 
{
  	BYTE* (OTL_PUBLIC * GetOtlTable) 
	(
		IOTLClient*			This,
		const	otlTag		tagTableName        // truetype table name tag 
	);

	void (OTL_PUBLIC * FreeOtlTable) 
	(
		IOTLClient*			This,
		BYTE*				pvTable,			// in: in case client needs it
		const otlTag		tagTableName        // in: truetype table name tag 
	);

	otlErrCode (OTL_PUBLIC * ReallocOtlList)
	(
		IOTLClient*			This,
		otlList*			pList,				// in/out 
		USHORT				cbNewDataSize,		// in 
		USHORT				celmNewMaxLen,		// in 
		otlReallocOptions	optPreserveContent	// in; if set, client may assert  
												//   cbNewDataSize == cbDataSize
	);

	otlErrCode (OTL_PUBLIC * GetDefaultGlyphs) 
	(
		IOTLClient*			This,
		const otlList*		pliChars,			// in: characters 
		otlList*			pliGlyphInfo		// out: glyphs 
												// (fill in the "glyph" field only) 
	);

	otlErrCode (OTL_PUBLIC * GetDefaultAdv) 
	(
		IOTLClient*			This,
		const otlList*		pliGlyphInfo,		// in: glyphs 
		otlList*			pliduGlyphAdv		// out:	default glyph advances 
	);

	otlErrCode (OTL_PUBLIC * GetGlyphPointCoords) 
	(
		IOTLClient*			This,
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement**		prgplc				// out: x, y coords of points 
	);

	otlErrCode (OTL_PUBLIC * FreeGlyphPointCoords)
	(
		IOTLClient*			This,
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement*		rgplc				// in: point coord array to free
	);

}
IOTLClientVtbl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\inc\otllib.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLLIB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       The OTL Services Library is a collection of functions which 
*       assist text processing clients with the task of text layout
*       using the information in OpenType fonts.            - deanb
*
*       Copyright 1996 - 1997. Microsoft Corporation.
*
*       Apr 01, 1996    v 0.1   First release
*       Jul 03, 1996    v 0.2   Sec prop uses feature bit mask, etc.
*       Aug 01, 1996    v 0.2a  OTLTextOut removed from API
*       Oct 11, 1996    v 0.3   Rename to OTL, trimmed to core
*       Jan 15, 1997    v 0.4   Portability renaming, etc.
*       Mar 18, 1997    v 0.5   Param changes, FreeTable, workspace
*       Apr 02, 1997    v 0.6   Feature handles
*       Apr 10, 1997    v 0.7   Otltypes.h, CharsAtPos, funits
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************
***********************************************************************/

/***********************************************************************
*   
*   The Goals of OTL Services 
* 
*   To expose the full functionality of OpenType fonts
*   To be platform independent, but pay particular attention to Windows
*   To support, not take over, text processing with helper functions
*
***********************************************************************/

/***********************************************************************
*   
*   Application Program Interface Overview
*
*   Font Information Functions
*       GetOtlVersion ( )           Returns current library version
*       GetOtlScriptList ( )        Enumerate scripts in a font
*       GetOtlLangSysList ( )       Enumerate language systems in a script
*       GetOtlFeatureDefs ( )       Enumerate features in a language system
*
*   Resource Management Functions
*       FreeOtlResources ( )        Frees all OTL tables and client memory
*
*   Text Information Functions
*       GetOtlLineSpacing ( )       Line spacing for a text run
*       GetOtlBaselineOffset ( )    Baseline adjustment between two scripts
*       GetOtlCharAtPosition ( )    What character is at given (x,y)
*       GetOtlExtentOfChars ( )     What is location of character range
*       GetOtlFeatureParams ( )     Find feature params within a run
*
*   Text Layout Functions
*       SubstituteOtlChars ( )      Do glyph subs according to features
*       SubstituteOtlGlyphs ( )     Do glyph subs according to features
*       PositionOtlGlyphs ( )       Do glyph positioning according to features
*
************************************************************************/

#include "otltypes.h"               // basic type definitions  
#include "otlcbdef.h"               // platform resource function typedefs  

#ifdef __cplusplus
#include "otltypes.inl"             // inline functions to work with OTL Types
#endif

/***********************************************************************
************************************************************************
*   
*           Application Program Interface Data Types
*
*   otlList             General expandable list structure
*   otlRunProp          Description of a font/size/script/langsys
*   otlFeatureDef       Defines features in a font
*   otlFeatureDesc      Describes how a feature is used
*   otlFeatureParam     Reports feature parameters
*   otlFeatureResults   Reports results of layout functions
*   IOTLClient          Client callback interface
*
***********************************************************************
***********************************************************************/


/***********************************************************************
*
*           Run Properties
*
*   This describes font/script/laguage system information for an entire
*   run of text. Multiple runs of text may point to the same properties
*   structure.
*
***********************************************************************/

typedef struct      // shared by multiple lines                                 
{
    IOTLClient*     pClient;        // ptr to client callback interface 
    long            lVersion;       // client expects / library supports 

    otlTag          tagScript;      // this run's script tag 
    otlTag          tagLangSys;     // set to 'dflt' for default LangSys 

    otlMetrics      metr;           // writing direction and font metrics
}
otlRunProp;                       // Hungarian: rp   


/***********************************************************************
************************************************************************
*   
*       Application Program Interface Functions
*
*   
*   Font Information Functions
*   Text Information Functions
*   Text Layout Functions
*
************************************************************************
***********************************************************************/


/***********************************************************************
*
*                       Font Information Functions
*
***********************************************************************/

/***********************************************************************
*
*   GetOtlVersion ( )       Returns current library version
*
*   Output: plVersion       Major version in top 16 bits, minor in bottom
*                           e.g. 0x00010002 = version 1.2
*
*   The client should put the smaller of this value and the version for
*   which it was written into the prpRunProp-lVersion field.
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlVersion 
( 
    long* plVersion
);


/***********************************************************************
*
*   GetOtlScriptList ( )        Enumerate scripts in a font
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pClient      Client callback data
*           pliWorkspace            Workspace memory: initialize zero-length
*
*   Output: plitagScripts          List of script tags supported in font
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlScriptList 
( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,    
    otlList*            plitagScripts
);


/***********************************************************************
*
*   GetOtlLangSysList ( )       Enumerate language systems in a script
*
*   Input:  pRunProps->lVersion    Highest shared version
*           pRunProps->pClient     Client callback data
*           pRunProps->tagScript   Script tag
*           pliWorkspace           Workspace memory: initialize zero-length
*
*   Output: plitagLangSys          List of language systems supported in script
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlLangSysList 
( 
    const otlRunProp*   pRunProps,    
    otlList*            pliWorkspace,    
    otlList*            plitagLangSys
);


/***********************************************************************
*
*   GetOtlFeatureDefs ( )       Enumerate features in a language system 
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pClient      Client callback interface
*           pRunProps->tagScript    Script tag
*           pRunProps->tagLangSys   Set to 'dflt' for default langsys
*           pliWorkspace            Workspace memory: initialize zero-length
*
*   Output: pliFDefs           List of features supported by langsys
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlFeatureDefs 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,    
    otlList*            pliFDefs
);


/***********************************************************************
*
*                       Resource Management Functions
*
***********************************************************************/

/***********************************************************************
*
*   FreeOtlResources ( )       Free OTL tables and client memory 
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pvClient     Client callback data
*           pliWorkspace            Workspace
*
*   Frees all OTL Tables and pointer to client memory that may be stored 
*   in run workspace
*
***********************************************************************/

OTL_EXPORT otlErrCode FreeOtlResources 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace   
);


/***********************************************************************
*
*                       Text Information Functions
*
***********************************************************************/

/***********************************************************************
*
*   GetOtlLineSpacing ( )       Line spacing for a text run
*
*   Input:  pRunProps           Text run properties (script & langsys)
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply (may affect spacing)
*
*   Output: pdvMax               Typographic ascender (horiz layout)
*           pdvMin               Typographic descender (horiz layout)
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlLineSpacing 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,
    
    long* pdvMax, 
    long* pdvMin
);


/***********************************************************************
*
*   GetOtlBaselineOffsets ( )   Baseline adjustment between two scripts
*
*   Input:  pRunProps           Text run properties (script & langsys)
*           pliWorkspace        Workspace memory: initialize zero-length
*
*   Output: pliBaselines        List of baseline tags and values
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlBaselineOffsets 
( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,    
    otlList*            pliBaselines
);


/***********************************************************************
*
*   GetOtlCharAtPosition ( )    What character is at given position
*
*   Input:  pRunProps           Text run properties (horiz/vert layout)
*           pliWorkspace        Workspace memory: initialize zero-length
*           pliCharMap          Unicode chars --> glyph indices mapping
*           pliGlyphInfo        Glyphs and flags
*           pliduGlyphAdv       Advance array
*
*           duAdv               Hit coordinate in advance direction
*   
*   Output: piChar              Index of character at position
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlCharAtPosition 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,    

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    long                duAdv,

    USHORT*             piChar
);


/***********************************************************************
*
*   GetOtlExtentOfChars ( )   What is location of character range
*
*   Input:  pRunProp          Text run properties (horiz/vert layout)
*           pliWorkspace      Workspace memory: initialize zero-length
*           pliCharMap        Unicode chars --> glyph indices mapping
*           pliGlyphInfo      Glyphs and flags list
*           pliduGlyphAdv     Advance array in layout direction
*           ichFirstChar      Index of first character
*           ichLastChar       Index of last character
*   
*   Output: piglfStartIdx        Index into Glyph list for first char
*           piglfEndIdx          Index into Glyph list for last char
*           pduStartPos          Left or Top of first char (right for RTL)
*           pduEndPos            Right or Bottom of last char (left for RTL)
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlExtentOfChars 
( 
    const otlRunProp*   pRunProp,
    otlList*            pliWorkspace,    

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    USHORT              ichFirstChar,
    USHORT              ichLastChar,
    
    long*               pduStartPos,
    long*               pduEndPos
);


/***********************************************************************
*
*   GetOtlFeatureParams ( )     Used to find glyph variants or feature parameter
*
*   Input:  pRunProps          Text run properties
*           pliWorkspace       Workspace memory: initialize zero-length
*           pliCharMap         Unicode chars --> glyph indices mapping
*           pliGlyphInfo       Text glyph list and glyph flag list 
*                               (chars/glyph and type)
*           tagFeature         Feature to examine
*
*   Output: plGlobalParam      Feature wide parameter
*           pliFeatureParams   List of character level feature params
*
*   Note:   Reserved for future use
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlFeatureParams 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,

    otlTag              tagFeature,
    
    long*               plGlobalParam,
    otlList*            pliFeatureParams
);


/***********************************************************************
*
*                       Text Layout Functions
*
***********************************************************************/


/***********************************************************************
*
*   SubstituteOtlChars ( )      Do glyph subs according to features
*   SubstituteOtlGlyphs ( )     Do glyph subs according to features
*
*   Input:  pRunProps           Text run properties
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply

*           pliChars            Unicode chars in a text run

*           pliCharMap          Unicode chars  --> glyph indices mapping
*           pliGlyphInfo        Glyphs in a text run and properties
*                               (for SubstituteOtlGlyphs -- in/out)
*
*   Output: pliCharMap
*           pliGlyphInfo        Modified by substitution
*           pliFResults         Results per feature descriptor(length = size of FSet)
*
***********************************************************************/

OTL_EXPORT otlErrCode SubstituteOtlChars 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    const otlList*          pliChars,

    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlList*                pliFResults
);

OTL_EXPORT otlErrCode SubstituteOtlGlyphs 
( 
    const otlRunProp*       pRunProp,
    otlList*                liWorkspace,   
    const otlFeatureSet*    pFSet,

    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlList*                pliFResults
);


/***********************************************************************
*
*   PositionOtlGlyphs ( )       Do glyph positioning according to features
*   RePositionOtlGlyphs ( )     Adjust glyph positioning according to features
*
*   Input:  pRunProps           Text run properties
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply
*           pliCharMap          Unicode chars  --> glyph indices mapping
*           pliGlyphInfo        Post-substituted glyphs and flags
*
*   Output: pliduGlyphAdv       Glyph advances 
*                               (RePositionOtlGlyphs -- in/out)
*           pliGlyphPlacement   Horizontal and vertical glyph placement
*                               (RePositionOtlGlyphs -- in/out)
*           pliFResults         Results per feature descriptor
*
***********************************************************************/

OTL_EXPORT otlErrCode PositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,

    otlList*            pliduGlyphAdv,
    otlList*            pliplcGlyphPlacement,

    otlList*            pliFResults
);


OTL_EXPORT otlErrCode RePositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,

    otlList*            pliduGlyphAdv,
    otlList*            pliplcGlyphPlacement,

    otlList*            pliFResults
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\inc\secondaryclassification.hpp ===
#ifndef _SECONDARYCLASSIFICATION_HPP
#define _SECONDARYCLASSIFICATION_HPP

///// SecondaryClassification
//
//    Provides classification for digit substitution, symmetric glyph
//    mirroring and auto vertical glyph rotoation.
//
//    DO NOT EDIT
//
//    Generated by engine/text/unilib/tools/upright.pl

enum SecondaryClassificationBase {
    ScCSAN,
    ScCSNN,
    ScENAN,
    ScENNN,
    ScETAN,
    ScETNN,
    ScNNAN,
    ScNNAS,
    ScNNFN,
    ScNNNN,
    ScNNNS,
};


/// Secondary classification flags
//
//  Bits 0-1: Numeric class,  0/EN/CS/ET
//  Bits 2-3: Mirror class,   0/MS/MX
//  Bits 4-5: Sideways class, 0/SA/SF
//
// The secondary classificationFlags exist because they an be masked for
// secondary itemization functionality.

enum SecondaryClassificationFlags {
    SecClassEN = 0x01,   // Digit U+0030-U+0039
    SecClassCS = 0x02,   // Common separator
    SecClassET = 0x03,   // European terminator
    SecClassMS = 0x04,   // Mirror subst
    SecClassMX = 0x08,   // Mirror Xform
    SecClassSA = 0x10,   // Sideways Always
    SecClassSF = 0x20,   // Sideways only in FE string
};

extern const unsigned char ScBaseToScFlags[];

enum SecondaryClassification {
    ScOther,
    ScSide,
    ScMirSub,
    ScMirXfm,
    ScEN,
    ScCS,
    ScET
};

extern const SecondaryClassification ScFlagsToScFE[];
extern const SecondaryClassification ScFlagsToScEng[];
extern const unsigned char *SecondaryClassificationLookup[];
#endif // _SECONDARYCLASSIFICATION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\inc\text_rt.h ===
/////   TEXT_RT.H
//
//      Uniscribe C-runtime redefinitions & prototypes
//
//      Created: wchao, 10-31-2000
//


#ifndef _TEXT_RT_H_
#define _TEXT_RT_H_

#ifdef GDIPLUS
#define memmove     GpMemmove
#else
#define memmove     UspMemmove
#endif

extern "C" void * __cdecl UspMemmove(void *dest, const void *src, size_t count);


#endif  // _TEXT_RT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\altersub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  ALTERSUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with alternate substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// translates lParameter to index into glyph variants array
// parameters are 1-based (0 meaning 'lookup is disabled',
// and the variant array is 0-based
inline USHORT ParameterToGlyphVariant(long lParameter)
{
	assert(lParameter > 0);
	return ((USHORT)lParameter - 1);
}


otlErrCode otlAlternateSubstLookup::apply
(
	otlList*					pliGlyphInfo,
	
	long						lParameter,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph	// out: next glyph
)												// return: did/did not apply
{ 
	assert(lParameter != 0);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	otlAlternateSubTable alternateSubst = otlAlternateSubTable(pbTable);
	otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
	
	short index = alternateSubst.coverage().getIndex(pGlyphInfo->glyph);
	if (index < 0)
	{
		return OTL_NOMATCH;
	}


	if (index > alternateSubst.alternateSetCount())
	{
		assert(false /* alternate subst: coverage index > subst count */); 
		return OTL_ERR_BAD_FONT_TABLE;
	}

	otlAlternateSetTable alternateSet = alternateSubst.altenateSet(index);

	if (lParameter < 0 || alternateSet.glyphCount() < lParameter)
	{
		assert(false); // bogus lParameter
		return OTL_ERR_BAD_INPUT_PARAM;
	}

	pGlyphInfo->glyph = alternateSet
		.alternate(ParameterToGlyphVariant(lParameter));

	*piglNextGlyph = iglIndex + 1;
	return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\altersub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  ALTERSUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with alternate substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetAlternateGlyphCount = 0;
const OFFSET offsetAlternateGlyphArray = 2;

class otlAlternateSetTable: otlTable
{
public:
	otlAlternateSetTable(const BYTE* pb): otlTable(pb) {}

	USHORT glyphCount() const
	{	return UShort(pbTable + offsetAlternateGlyphCount); }

	otlGlyphID alternate(USHORT index)
	{	assert(index < glyphCount());
		return GlyphID(pbTable + offsetAlternateGlyphArray 
								+ index * sizeof(otlGlyphID)); 
	}
};


const OFFSET offsetAlternateCoverage = 2;
const OFFSET offsetAlternateSetCount = 4;
const OFFSET offsetAlternateSetArray = 6;

class otlAlternateSubTable: public otlLookupFormat
{
public:

	otlAlternateSubTable(const BYTE* pb)
		: otlLookupFormat(pb)
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetAlternateCoverage)); }

	USHORT alternateSetCount()
	{	return UShort(pbTable + offsetAlternateSetCount); }

	otlAlternateSetTable altenateSet(USHORT index)
	{	assert(index < alternateSetCount());
		return otlAlternateSetTable(pbTable + 
				Offset(pbTable + offsetAlternateSetArray 
							   + index * sizeof(OFFSET))); 
	}
};


class otlAlternateSubstLookup: otlLookupFormat
{
public:

	otlAlternateSubstLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) {}

	otlErrCode apply
	(
	otlList*					pliGlyphInfo,

	long						lParameter,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\inc\otltypes.inl ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLTYPES.INL  ********
*
*              Open Type Layout Services Library Header File
*
*       This module contains inline functions for handling basic OTL structures
*
*       Copyright 1997. Microsoft Corporation.
*
*       July 27, 1997    v 0.9		AndreiB		Created
*
************************************************************************
***********************************************************************/

/***********************************************************************
*   
*       otlList inline helper functions 
*
***********************************************************************/

#include <assert.h>
#include <string.h>

// otlList inline functions

void otlList::reset(void* pvNewData, USHORT cbNewDataSize, 
					USHORT celmNewLength, USHORT celmNewMaxLen)
{
	assert(pvNewData != NULL || celmNewMaxLen == 0);
	assert(celmNewLength <= celmNewMaxLen);

	pvData = pvNewData;
	cbDataSize = cbNewDataSize;
	celmLength = celmNewLength;
	celmMaxLen = celmNewMaxLen;
}


inline BYTE* otlList::elementAt(unsigned short index)
{
	assert(index < celmLength);
	return (BYTE*)pvData + index * cbDataSize;
}

inline const BYTE* otlList::readAt(unsigned short index) const
{
	assert(index < celmLength);
	return (BYTE*)pvData + index * cbDataSize;
}

inline void otlList::insertAt(unsigned short index, unsigned short celm)
{
	assert(index <= celmLength);
	assert(celmMaxLen >= celmLength + celm);

	memmove((BYTE*)pvData + (index + celm) * cbDataSize,
			(BYTE*)pvData + index * cbDataSize, 
			(celmLength - index) * cbDataSize);

	celmLength += celm;
}

inline void otlList::deleteAt(unsigned short index, unsigned short celm)
{
	assert(index <= celmLength);
	assert(celmLength - celm >= 0);

	memmove((BYTE*)pvData + index * cbDataSize,
			(BYTE*)pvData + (index + celm) * cbDataSize, 
			(celmLength - index - celm) * cbDataSize);

	celmLength -= celm;
}

inline void otlList::append(const BYTE* element)
{
	assert(celmMaxLen > celmLength);
	memcpy((BYTE*)pvData + celmLength * cbDataSize, element, cbDataSize);
	++celmLength;
}


// type-specific primitives to avoid constant casting

// otlTag
inline otlTag readOtlTag(const otlList* pliTag, USHORT i)
{
	assert(pliTag->dataSize() == sizeof(otlTag));
	return *(const otlTag*)pliTag->readAt(i);
}


// otlGlyphInfo
inline const otlGlyphInfo* readOtlGlyphInfo(const otlList* pliGlyphInfo, USHORT i)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	return (const otlGlyphInfo*)pliGlyphInfo->readAt(i);
}

inline otlGlyphInfo* getOtlGlyphInfo(otlList* pliGlyphInfo, USHORT i)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	return (otlGlyphInfo*)pliGlyphInfo->elementAt(i);
}


// wchar
inline WCHAR readOtlChar(const otlList* pliChars, USHORT i)
{
	assert(pliChars->dataSize() == sizeof(WCHAR));
	return *(const WCHAR*)pliChars->readAt(i);
}


// iGlyph
inline USHORT readOtlGlyphIndex(const otlList* pliGlyphMap, USHORT i)
{
	assert(pliGlyphMap->dataSize() == sizeof(USHORT));
	return *(const USHORT*)pliGlyphMap->readAt(i);
}

inline USHORT* getOtlGlyphIndex(otlList* pliGlyphMap, USHORT i)
{
	assert(pliGlyphMap->dataSize() == sizeof(USHORT));
	return (USHORT*)pliGlyphMap->elementAt(i);
}


// otlPlacement
inline const otlPlacement* readOtlPlacement(const otlList* pliPlacement, USHORT i)
{
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	return (const otlPlacement*)pliPlacement->readAt(i);
}

inline otlPlacement* getOtlPlacement(otlList* pliPlacement, USHORT i)
{
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	return (otlPlacement*)pliPlacement->elementAt(i);
}


// advance widths
inline const long readOtlAdvance(const otlList* pliAdvance, USHORT i)
{
	assert(pliAdvance->dataSize() == sizeof(long));
	return *(const long*)pliAdvance->readAt(i);
}

inline long* getOtlAdvance(otlList* pliAdvance, USHORT i)
{
	assert(pliAdvance->dataSize() == sizeof(long));
	return (long*)pliAdvance->elementAt(i);
}


// otlFeatureDef (no read-only mode)
inline otlFeatureDef* getOtlFeatureDef(otlList* pliFDef, USHORT i)
{
	assert(pliFDef->dataSize() == sizeof(otlFeatureDef));
	return (otlFeatureDef*)pliFDef->elementAt(i);
}


// otlFeatureDesc (read-only - never modify)
inline const otlFeatureDesc* readOtlFeatureDesc(const otlList* pliFDesc, USHORT i)
{
	assert(pliFDesc->dataSize() == sizeof(otlFeatureDesc));
	return (const otlFeatureDesc*)pliFDesc->readAt(i);
}


// otlFeatureResult (no read-only mode)
inline otlFeatureResult* getOtlFeatureResult(otlList* pliFRes, USHORT i)
{
	assert(pliFRes->dataSize() == sizeof(otlFeatureResult));
	return (otlFeatureResult*)pliFRes->elementAt(i);
}


// otlBaseline (no read-only mode)
inline otlBaseline* getOtlBaseline(otlList* pliBaseline, USHORT i)
{
	assert(pliBaseline->dataSize() == sizeof(otlBaseline));
	return (otlBaseline*)pliBaseline->elementAt(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\inc\otltypes.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLTYPES.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module contains basic OTL type and structure definitions.
*
*       Copyright 1997. Microsoft Corporation.
*
*       Apr 10, 1997    v 0.7   First release
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************
***********************************************************************/

/***********************************************************************
*
*           OTL Basic Type Definitions
*
***********************************************************************/

typedef  unsigned short otlGlyphID;            // hungarian: glf
typedef  unsigned short otlGlyphFlags;         // hungarian: gf
typedef  signed long    otlTag;                // hungarian: tag
typedef  signed long    otlErrCode;            // hungarian: erc

#ifndef     BYTE
#define     BYTE    unsigned char
#endif

#ifndef     WCHAR
#define     WCHAR   unsigned short
#endif

#ifndef     USHORT
#define     USHORT  unsigned short
#endif

#ifndef     ULONG
#define     ULONG   unsigned long
#endif

#ifndef     NULL
#define     NULL    (void*)0
#endif

#ifndef     FALSE
#define     FALSE   0
#endif
#ifndef     TRUE
#define     TRUE    -1
#endif

#define     OTL_MAX_CHAR_COUNT          32000
#define     OTL_CONTEXT_NESTING_LIMIT   100

#define     OTL_PRIVATE     static
#define     OTL_PUBLIC
//#define     OTL_EXPORT      __declspec( dllexport ) /* needs portability work   */
#define     OTL_EXPORT      // No exports for LINKLIBS


#define     OTL_DEFAULT_TAG     0x746C6664

#define     OTL_GSUB_TAG        0x42555347
#define     OTL_GPOS_TAG        0x534F5047
#define     OTL_JSTF_TAG        0x4654534A
#define     OTL_BASE_TAG        0x45534142
#define     OTL_GDEF_TAG        0x46454447


/***********************************************************************
*
*                               OTL List
*
*   This is used to represent a number of different lists of data (such
*   as characters, glyphs, attributes, coordinates) that make up a text run
*
***********************************************************************/

#ifdef __cplusplus

class otlList
{
private:

    void*   pvData;                 // data pointer
    USHORT  cbDataSize;             // bytes per list element
    USHORT  celmMaxLen;             // allocated list element count
    USHORT  celmLength;             // current list element count

public:
        otlList (void* data, USHORT size, USHORT len, USHORT maxlen)
            : pvData(data), cbDataSize(size), celmLength(len), celmMaxLen(maxlen)
        {}

        inline BYTE* elementAt(USHORT index);
        inline const BYTE* readAt(USHORT index) const;

        inline void insertAt(USHORT index, USHORT celm);
        inline void deleteAt(USHORT index, USHORT celm);
        inline void append(const BYTE* element);

        void empty() { celmLength = 0; }

        USHORT length() const { return celmLength; }
        USHORT maxLength() const {return celmMaxLen; }
        USHORT dataSize() const {return cbDataSize; }
        const void*  data() const {return pvData; }

        inline void reset(void* pv, USHORT cbData, USHORT celmLen, USHORT celmMax);

};                                  // Hungarian: lixxx

#else

typedef struct otlList
{

    void*   pvData;                 // data pointer
    USHORT  cbDataSize;             // bytes per list element
    USHORT  celmMaxLen;             // allocated list element count
    USHORT  celmLength;             // current list element count

}
otlList;

#endif

/*
 *  When an OTL List is used for a function input parameter,
 *  the celmMaxLength field is not used. When an OTL List is
 *  used for a function output parameter, the celmMaxLength
 *  field is used to determine the memory available for the
 *  output data. If more memory is required than available,
 *  the function returns an OTL_ERR_INSUFFICIENT_MEMORY error
 *  message, and the celmLength field is set the the required
 *  memory size.
 *
 *  AndreiB(5-29-98) We're gonna switch to the model where OTL Services
 *  can request the client to realocate the list to the right size.
 *
 */

/**********************************************************************/


/***********************************************************************
*
*           Shared Structure Definitions
*
***********************************************************************/

typedef struct
{
    otlGlyphID      glyph;          // glyph ID
    otlGlyphFlags   grf;            // glyph flags

    USHORT          iChar;          // starting character index
    USHORT          cchLig;         // how many characters it maps to
}
otlGlyphInfo;                   // Hungarian glinf


/***********************************************************************
*
*           GlyphFlags masks and settings
*
***********************************************************************/

#define     OTL_GFLAG_CLASS     0x000F      // Base, mark, ligature, component

#define     OTL_GFLAG_SUBST     0x0010      // Glyph was substituted
#define     OTL_GFLAG_POS       0x0020      // Glyph was positioned

#define     OTL_GFLAG_RESERVED  0xFF00      // reserved

typedef enum
{
    otlUnassigned       = 0,
    otlBaseGlyph        = 1,
    otlLigatureGlyph    = 2,
    otlMarkGlyph        = 3,
    otlComponentGlyph   = 4,

    otlUnresolved       = 15, // This flag value will be substituted with 
                              // correct one from above values during OTLS
                              // call. Should be used when client creates or
                              // updates GlyphInfo structure manually
}
otlGlyphClass;

/***********************************************************************
*
*           Positioning structures
*
*   These structures (along with advance widths) are used in positioning
*   methods to relay font metrics/writing direction information and get
*   glyph positions back.
*
***********************************************************************/

typedef enum
{
    otlRunLTR   =   0,
    otlRunRTL   =   1,
    otlRunTTB   =   2,
    otlRunBTT   =   3
}
otlLayout;

typedef struct
{
    otlLayout       layout;     // horiz/vert left/right layout

    USHORT          cFUnits;        // font design units per Em
    USHORT          cPPEmX;         // horizontal pixels per Em
    USHORT          cPPEmY;         // vertical pixels per Em

}
otlMetrics;                     // Hungarian: metr

typedef struct
{
    long            dx;
    long            dy;

}
otlPlacement;                   // Hungarian: plc

/***********************************************************************
*
*           Feature Definition
*
*   These are returned by the GetOtlFeatureDefs call to identify
*   the set of features in a font, and are included in the Run
*   Property to identify the feature set
*
***********************************************************************/

typedef struct
{
    otlTag          tagFeature;             // feature tag
    USHORT          grfDetails;             // details of this feature
}
otlFeatureDef;                                  // Hungarian: fdef

#define     OTL_FEAT_FLAG_GSUB      0x0001    // does glyph substitution
#define     OTL_FEAT_FLAG_GPOS      0x0002    // does glyph positioning

/* The following flags are reserved for future use
*/
#define     OTL_FEAT_FLAG_ALTER     0x0004    // has alternate glyphs
#define     OTL_FEAT_FLAG_PARAM     0x0008    // uses a feature parameter

#define     OTL_FEAT_FLAG_EXP       0x0010    // may expand the glyph string
#define     OTL_FEAT_FLAG_SPEC      0x0020    // uses special processing


/***********************************************************************
*
*           Feature Description
*
*   This structure describes the use of one feature within a text run
*
***********************************************************************/

typedef struct
{
    otlTag          tagFeature;             // feature tag
    long            lParameter;             // 1 to enable, 0 to disable,
                                            // n for param
    USHORT          ichStart;               // start of feature range
    USHORT          cchScope;               // size of feature range
}
otlFeatureDesc;                             // Hungarian: fdsc


/***********************************************************************
*
*           Feature Set
*
*   This structure describes the set of features applied to a text run
*
***********************************************************************/
#ifdef __cplusplus

struct otlFeatureSet
{
    otlList         liFeatureDesc;      // list of feature descriptions
    USHORT          ichStart;           // offset into character list
    USHORT          cchScope;           // size of text run

    otlFeatureSet()
    : liFeatureDesc(NULL, 0, 0, 0), ichStart(0), cchScope(0)
    {}

};                              // Hungarian: fset

#else

typedef struct
{
    otlList         liFeatureDesc;      // list of feature descriptions
    USHORT          ichStart;           // offset into character list
    USHORT          cchScope;           // size of text run

} otlFeatureSet;                                // Hungarian: fset

#endif
/***********************************************************************
*
*           Feature Result
*
*   This structure is used to report results from applying a feature
*   descriptor
*
***********************************************************************/

typedef struct
{
    const otlFeatureDesc*   pFDesc;                 // feature descriptor
    USHORT                  cResActions;            // out: count of actions undertaken
}
otlFeatureResult;                               // Hungarian: fres


/***********************************************************************
*
*           Feature Parameter
*
*   This structures are returned by GetOtlFeatureParams to report
*   character level feature parameters
*
***********************************************************************/

typedef struct
{
    long            lParameter;             // feature parameter
    USHORT          ichStart;               // character start
    USHORT          cchScope;               // character length
}
otlFeatureParam;                                // Hungarian: fprm



/***********************************************************************
*
*           Base Value
*
*   This structure returns the tag and coordinate of one baseline
*
***********************************************************************/

typedef struct
{
    otlTag      tag;                    // baseline tag
    long        lCoordinate;            // baseline coordinate
}
otlBaseline;                            // Hungarian: basl



/***********************************************************************
*
*       Application Program Interface Function Return Codes
*
***********************************************************************/

inline USHORT ERRORLEVEL(otlErrCode erc) { return (USHORT)((erc & 0xFF00) >> 8); }

#define     OTL_ERRORLEVEL_MINOR            1

#define     OTL_SUCCESS                     0x0000
#define     OTL_ERROR                       0xFFFF

#define     OTL_ERR_TABLE_NOT_FOUND         0x0101
#define     OTL_ERR_SCRIPT_NOT_FOUND        0x0102
#define     OTL_ERR_LANGSYS_NOT_FOUND       0x0103
#define     OTL_ERR_FEATURE_NOT_FOUND       0x0104

#define     OTL_ERR_VERSION_OUT_OF_DATE     0x0301
#define     OTL_ERR_BAD_FONT_TABLE          0x0302
#define     OTL_ERR_CONTEXT_NESTING_TOO_DEEP 0x0303

#define     OTL_ERR_INCONSISTENT_RUNLENGTH  0x0401
#define     OTL_ERR_BAD_INPUT_PARAM         0x0402
#define     OTL_ERR_POS_OUTSIDE_TEXT        0x0403

#define     OTL_ERR_INSUFFICIENT_MEMORY     0x0501
#define     OTL_ERR_GLYPHIDS_NOT_FOUND      0x0502
#define     OTL_ERR_ADVANCE_NOT_FOUND       0x0503

#define     OTL_ERR_CANNOT_REENTER          0x0901

#define     OTL_ERR_UNDER_CONSTRUCTION      0x1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\apply.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  APPLY.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements OTL Library calls dealing with  
*       applying features and lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"
/***********************************************************************/

void InitializeFeatureResults
(
    const otlFeatureSet*        pFSet,
    otlList*                    pliFResults
)
{
    if (pliFResults == NULL) return;

    assert((pFSet->liFeatureDesc).length() == pliFResults->length());
    assert((pFSet->liFeatureDesc).dataSize() == sizeof(otlFeatureDesc));
    assert(pliFResults->dataSize() == sizeof(otlFeatureResult));

    USHORT cFeatureDesc = (pFSet->liFeatureDesc).length();
    
    for (USHORT i = 0; i < cFeatureDesc; ++i)
    {
        otlFeatureResult* pResult = getOtlFeatureResult(pliFResults, i);
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, i);

        pResult->pFDesc = pFDesc;
        pResult->cResActions = 0;
    }

}

void UpdateFeatureResults
(
    const otlFeatureSet*        pFSet,
    USHORT                      iLookup,
    long                        lParameter,

    const otlList*              pliCharMap,
    const otlList*              pliGlyphInfo,    
    USHORT                      iGlyph,

    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    otlList*                    pliFResults
)
{
    if (pliFResults == NULL) return;

    assert((pFSet->liFeatureDesc).length() == pliFResults->length());
    assert((pFSet->liFeatureDesc).dataSize() == sizeof(otlFeatureDesc));
    assert(pliFResults->dataSize() == sizeof(otlFeatureResult));

    const otlGlyphInfo* pGlyphInfo = 
        readOtlGlyphInfo(pliGlyphInfo, iGlyph);

    USHORT cFeatureDesc = (pFSet->liFeatureDesc).length();
    for (USHORT iFeature = 0; iFeature < cFeatureDesc; ++iFeature)
    {
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);

        otlFeatureResult* pResult = 
            getOtlFeatureResult(pliFResults, iFeature);

        assert(pResult->pFDesc == pFDesc);

        USHORT ichComp = pGlyphInfo->iChar;
        for (USHORT i = 0; i < pGlyphInfo->cchLig; ++i)
        {
            if (otlRange(pFDesc->ichStart, pFDesc->ichStart + pFDesc->cchScope)
                .contains(ichComp))
            {

                ++pResult->cResActions;
            }

            if (i + 1 < pGlyphInfo->cchLig)
            {
                ichComp = NextCharInLiga(pliCharMap, ichComp);
            }
        }

    }

    return;
}

// update glyph flags after lookup application
inline
void UpdateGlyphFlags
(
    otlTag      tagTable,
    otlList*    pliGlyphInfo,
    USHORT      iglFirst,
    USHORT      iglAfterLast
)
{
    if (tagTable == OTL_GSUB_TAG)
    {
        for (USHORT igl = iglFirst; igl < iglAfterLast; ++igl)
        {
            getOtlGlyphInfo(pliGlyphInfo, igl)->grf |= OTL_GFLAG_SUBST;
        }
    }
    else if (tagTable == OTL_GPOS_TAG)
    {
        for (USHORT igl = iglFirst; igl < iglAfterLast; ++igl)
        {
            getOtlGlyphInfo(pliGlyphInfo,igl)->grf |= OTL_GFLAG_POS;
        }
    }
}


void RefreshEnablesCache(
    const otlFeatureSet*        pFSet,
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    USHORT iLookup,
    otlEnablesCache  &ec
)
{    
    if (!ec.IsActive()) return;

    ec.SetFirst(iLookup); 
    ec.ClearFlags();

    USHORT cFeatures = (pFSet->liFeatureDesc).length();

    //RequiredFeature
    ec.Refresh(RequiredFeature(langSysTable, featureList), 
                                                ec.RequiredFeatureFlagIndex());

    for (USHORT iFeature = 0; iFeature < cFeatures; ++iFeature)
    {
        const otlFeatureDesc* pFDesc 
                   = readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);

        if (pFDesc->lParameter != 0)
        {
            ec.Refresh(FindFeature(langSysTable, featureList,pFDesc->tagFeature),iFeature);
        }
    }
}

void GetNewEnabledCharRange
(
    const otlFeatureSet*        pFSet,
    USHORT                      iLookup,

    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    USHORT      ichStart,
    USHORT*     pichFirst,
    USHORT*     pichAfterLast,
    long*       plParameter,

    const otlEnablesCache&      ec
)
{

    // REVIEW (PERF)
    // There are two ways to speed this process up:
    // 1. Sort feature descriptors by ichStart
    // 2. Build in advance a table indicating which feature 
    //    descriptor enables which lookup and use it
    //
    // sergeym(09/29/00): Now we use Enables cache

    USHORT cFeatures = (pFSet->liFeatureDesc).length();

    ichStart = MAX(ichStart, pFSet->ichStart);

    if (EnablesRequired(langSysTable,featureList,iLookup,ec))
    {
        *pichFirst = ichStart;
        *pichAfterLast = pFSet->ichStart + pFSet->cchScope;
        // REVIEW: a required feature should not take non-trivial parameters
        //          (or not force it -- and leave it to the app?)
        *plParameter = 1;
        return;
    }

    *pichFirst = MAXUSHORT;
    *plParameter = 0;
    for (USHORT iFeatureFirst = 0; iFeatureFirst < cFeatures; ++iFeatureFirst)
    {
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeatureFirst);

        if (Enables(langSysTable,featureList,pFDesc,iLookup,iFeatureFirst,ec) &&
            pFDesc->lParameter != 0 &&
            otlRange(pFDesc->ichStart, pFDesc->ichStart + pFDesc->cchScope)
             .intersects(otlRange(ichStart, *pichFirst))
           )   
        {
            assert(*pichFirst > pFDesc->ichStart);

            *pichFirst = MAX(ichStart, pFDesc->ichStart);
            *plParameter = pFDesc->lParameter;
        }
    }
    
    *pichFirst = MIN(*pichFirst, pFSet->ichStart + pFSet->cchScope);

    // did we get anything?
    if (*plParameter == 0)
    {
        *pichAfterLast = *pichFirst;
        return;
    }

    // got the new range start
    // now, the scope
    *pichAfterLast = *pichFirst + 1;
    USHORT iFeature = 0;
    while (iFeature < cFeatures)
    {
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);
        
        if (Enables(langSysTable,featureList,pFDesc,iLookup,iFeature,ec) &&
             pFDesc->lParameter == *plParameter &&
             otlRange(pFDesc->ichStart, pFDesc->ichStart + pFDesc->cchScope)
             .contains(*pichAfterLast)
           )
        {
            assert(*pichAfterLast < pFDesc->ichStart + pFDesc->cchScope);

            *pichAfterLast = pFDesc->ichStart + pFDesc->cchScope;
            
            // start all over (yes, we have to -- or sort)
            iFeature = 0;
        }
        else
        {
            ++iFeature;
        }
        
    }
    
    *pichAfterLast = MIN(*pichAfterLast, pFSet->ichStart + pFSet->cchScope);
}

inline
void GetGlyphRangeFromCharRange
(
    const otlList*      pliCharMap,    
    USHORT              ichFirst,
    USHORT              ichAfterLast,

    const otlList*      pliGlyphInfo,
    USHORT              iglStart,

    USHORT*             piglFirst,
    USHORT*             piglAfterLast
)
{
    // there's no 100%-correct way of mapping
    // so we stick with the simple one that's based on "visual continuity"

    *piglFirst = MAX(iglStart, readOtlGlyphIndex(pliCharMap, ichFirst));
    if (ichAfterLast < pliCharMap->length())
        *piglAfterLast = readOtlGlyphIndex(pliCharMap, ichAfterLast);
    else
        *piglAfterLast = pliGlyphInfo->length();

    return;

//  // update iglFirst, iglAfterLast acording to ichFrist, ichAfterLast
//  *piglFirst = MAXUSHORT;
//  *piglAfterLast = 0;
//  for (USHORT ich = ichFirst; ich < ichAfterLast; ++ich)
//  {
//      USHORT iGlyph = readOtlGlyphIndex(pliCharMap, ich);
//
//      if (iGlyph < *piglFirst && iGlyph >= iglStart)
//      {
//          *piglFirst = iGlyph;
//      }
//
//      if (iGlyph >= *piglAfterLast)
//      {
//          *piglAfterLast = iGlyph + 1;
//      }
//  }
}


otlErrCode ApplyFeatures
(
    otlTag                      tagTable,                   // GSUB/GPOS
    const otlFeatureSet*        pFSet,

    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,  
    
    otlResourceMgr&             resourceMgr,

    otlTag                      tagScript,
    otlTag                      tagLangSys,

    const otlMetrics&   metr,       

    otlList*            pliduGlyphAdv,              // assert null for GSUB
    otlList*            pliplcGlyphPlacement,       // assert null for GSUB

    otlList*            pliFResults
)
{
    assert(tagTable == OTL_GPOS_TAG || tagTable == OTL_GSUB_TAG);

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));

    if (tagTable == OTL_GSUB_TAG)
    {
        assert(pliduGlyphAdv == NULL && pliplcGlyphPlacement == NULL);
    }
    else
    {
        assert(pliduGlyphAdv != NULL && pliplcGlyphPlacement != NULL);
        assert(pliduGlyphAdv->dataSize() == sizeof(long));
        assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));
    }

    otlErrCode erc;

    USHORT cFeatures = pFSet->liFeatureDesc.length();

    // prepare tables
    otlFeatureListTable featureList = otlFeatureListTable((const BYTE*)NULL);
    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL);
    otlLookupListTable lookupList = otlLookupListTable((const BYTE*)NULL);

    erc = GetScriptFeatureLookupLists(tagTable, resourceMgr, 
                                            &scriptList, 
                                            &featureList, 
                                            &lookupList);
    if (erc != OTL_SUCCESS) return erc; // fatal error, return immediately

    
    // get the script and lang sys tables
    otlScriptTable scriptTable = FindScript(scriptList, tagScript);
    if (scriptTable.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }

    otlLangSysTable langSysTable = FindLangSys(scriptTable, tagLangSys);
    if (langSysTable.isNull())
    {
        return OTL_ERR_LANGSYS_NOT_FOUND;
    }

    // get GDEF
    otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

    
    // go though lookups
    USHORT cLookups = lookupList.lookupCount();
    InitializeFeatureResults(pFSet, pliFResults);


    //Init ECache
    const USHORT DefaultECacheSize =256;
    BYTE DefaultECacheBuffer[DefaultECacheSize];
    
    otlEnablesCache ec(cFeatures,DefaultECacheBuffer,DefaultECacheSize);
    
    ec.Allocate(resourceMgr,cLookups);
    ec.Reset();

    for (USHORT iLookup = 0; iLookup < cLookups; ++iLookup)
    {
        if (!ec.InCache(iLookup))
            RefreshEnablesCache(pFSet, langSysTable, featureList, iLookup, ec);

        if (!EnablesSomewhere(iLookup,ec)) continue;

        USHORT iglFirst = 0;
        USHORT iglAfterLast = 0;

        USHORT ichFirst = 0;
        USHORT ichAfterLast = 0;

        long lParameter = 0;

        // go though indexes keeping the upper bound of enabled range 
        otlLookupTable lookupTable = lookupList.lookup(iLookup);

        // REVIEW (PERF): Consider defining lookupTable.coverage(),
        // getting it here and calling getIndex on it before ApplyLookup
        // down in the loop

        bool fLookupFinished = false;
        while (iglFirst < pliGlyphInfo->length() && !fLookupFinished)
        {
            if (iglAfterLast > iglFirst)
            {
                
                // for every index where it's enabled, try applying
                USHORT iglNext;
                USHORT iglAfterLastReliable = 
                            pliGlyphInfo->length() - iglAfterLast;
                erc = ApplyLookup(tagTable,
                                pliCharMap,
                                pliGlyphInfo,
                                resourceMgr,

                                lookupTable,
                                lParameter,
                                0,              // context nesting level

                                metr,          
                                pliduGlyphAdv,          
                                pliplcGlyphPlacement,   

                                iglFirst,           
                                iglAfterLast,           

                                &iglNext        
                              );
                if (ERRORLEVEL(erc) > 0) return erc;
                
                if (erc == OTL_SUCCESS)
                {
                    // application successful
                    iglAfterLast = pliGlyphInfo->length() - iglAfterLastReliable;

                    // if GSUB, update new glyph types
                    if (tagTable == OTL_GSUB_TAG)
                    {
                        AssignGlyphTypes(pliGlyphInfo, gdef, 
                                         iglFirst, iglNext, otlDoAll);
                    }

                    // update glyph flags
                    UpdateGlyphFlags(tagTable, pliGlyphInfo, iglFirst, iglNext);
                    
                    // update results for every fdef that was enabling this lookup
                    UpdateFeatureResults(pFSet, iLookup, lParameter, 
                                        pliCharMap, pliGlyphInfo, iglFirst,
                                        langSysTable, featureList, pliFResults);
                }
                else
                {
                    iglNext = iglFirst + 1;
                }

                // update next glyph
                assert(iglNext > iglFirst);
                iglFirst = NextGlyphInLookup(pliGlyphInfo, lookupTable.flags(),  
                                             gdef, 
                                             iglNext, otlForward);
            }
            else
            {
                // update next glyph and scope
                GetNewEnabledCharRange(pFSet, iLookup, 
                                        langSysTable, featureList, ichAfterLast, 
                                        &ichFirst, &ichAfterLast, &lParameter,
                                        ec
                                      );

                if (lParameter != 0)
                {
                    assert(ichFirst < ichAfterLast);
                    GetGlyphRangeFromCharRange(pliCharMap, ichFirst, ichAfterLast,
                                               pliGlyphInfo, iglFirst, 
                                               &iglFirst, &iglAfterLast);

                    //and go to the next valid glyph for this lookup
                    iglFirst = NextGlyphInLookup(pliGlyphInfo, lookupTable.flags(), 
                                                 gdef, 
                                                 iglFirst, otlForward);
                }
                else
                {
                    //got nothing more to work on; it is time to say goodbye
                    fLookupFinished = true;
                }
            }
        }
    }

    return OTL_SUCCESS;
}


short NextGlyphInLookup
(
    const otlList*      pliGlyphInfo, 

    USHORT                  grfLookupFlags,
    const otlGDefHeader&    gdef,

    short               iglFirst,
    otlDirection        direction
)
{
    assert(pliGlyphInfo != (otlList*)NULL);

    USHORT iglAfterLast = pliGlyphInfo->length();
    assert(iglAfterLast >= iglFirst);
    assert(iglFirst >= -1);

    if(grfLookupFlags == 0)
    {
        // a shortcut
        return iglFirst;
    }

    assert( !gdef.isNull()); // no GDEF table but lookup flags are used 

    for (short i = iglFirst; i < iglAfterLast && i >= 0; i += direction)
    {
        const otlGlyphInfo* pGlyphInfo = 
            readOtlGlyphInfo(pliGlyphInfo, i);

        if ((grfLookupFlags & otlIgnoreMarks) != 0 &&
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlMarkGlyph)
        {
            continue;
        }

        if ((grfLookupFlags & otlIgnoreBaseGlyphs) != 0 &&
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlBaseGlyph)
        {
            continue;
        }

        if ((grfLookupFlags & otlIgnoreLigatures) != 0 &&
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlLigatureGlyph)
        {
            continue;
        }

        if (attachClass(grfLookupFlags)!= 0 && 
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlMarkGlyph &&
            gdef.attachClassDef().getClass(pGlyphInfo->glyph) 
                != attachClass(grfLookupFlags) )
        {
            continue;
        }

        return i;
    }

    // found nothing -- skipped all
    return (direction > 0)  ? iglAfterLast 
                            : -1;
}

otlErrCode ApplyLookup
(
    otlTag                      tagTable,           // GSUB/GPOS
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    const otlLookupTable&       lookupTable,
    long                        lParameter,
    USHORT                      nesting,

    const otlMetrics&           metr,       
    otlList*                    pliduGlyphAdv,          // assert null for GSUB
    otlList*                    pliplcGlyphPlacement,   // assert null for GSUB

    USHORT                      iglFirst,       // where to apply it
    USHORT                      iglAfterLast,   // how long a context we can use

    USHORT*                     piglNext        // out: next glyph index
)
{
    assert(tagTable == OTL_GSUB_TAG || tagTable == OTL_GPOS_TAG);

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));

    assert(lParameter != 0);

    assert(iglFirst < iglAfterLast);
    assert(iglAfterLast <= pliGlyphInfo->length());

    if (tagTable == OTL_GSUB_TAG)
    {
        assert(pliduGlyphAdv == NULL && pliplcGlyphPlacement == NULL);
    }
    else
    {
        assert(pliduGlyphAdv != NULL && pliplcGlyphPlacement != NULL);
        assert(pliduGlyphAdv->dataSize() == sizeof(long));
        assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));
        assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length() &&
                pliduGlyphAdv->length() == pliGlyphInfo->length());
    }

    assert (piglNext != NULL);


    const lookupTypeGSUBExtension=7;
    const lookupTypeGPOSExtension=9;

    otlErrCode erc;
    USHORT iSub;
    bool   bExtension;

    USHORT        lookupType  = lookupTable.lookupType();
    otlGlyphFlags lookupFlags = lookupTable.flags();
    
    if (tagTable == OTL_GSUB_TAG)
    {
        bExtension = (lookupType==lookupTypeGSUBExtension);

        for (iSub = 0; iSub < lookupTable.subTableCount(); ++iSub)
        {
            otlLookupFormat subTable = lookupTable.subTable(iSub);
            if (bExtension) 
            {
                otlExtensionLookup extLookup=otlExtensionLookup(subTable);
                lookupType = extLookup.extensionLookupType();
                subTable   = extLookup.extensionSubTable();
            }

            switch(lookupType)
            {
            case(1):    // single substitution
                erc = otlSingleSubstLookup(subTable)
                            .apply(pliGlyphInfo, 
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(2):    // multiple substitution
                erc = otlMultiSubstLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags,  
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(3):    // alternate substiution
                erc = otlAlternateSubstLookup(subTable)
                            .apply(pliGlyphInfo, 
                                   lParameter, 
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(4):    // ligature substitution
                erc = otlLigatureSubstLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags,  
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;
            
            case(5):    // context subst
                erc = otlContextLookup(subTable)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(6):    // chaining context subst
                erc = otlChainingLookup(subTable)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(7):    // extension subst
                assert(false); //we had to process it before (as Extension lookup type)
                return OTL_ERR_BAD_FONT_TABLE;
                break;

            default:
                return OTL_ERR_BAD_FONT_TABLE;
            }
        }
        return OTL_NOMATCH;
    }
    else if (tagTable == OTL_GPOS_TAG)
    {
        bExtension = (lookupType==lookupTypeGPOSExtension);

        for (iSub = 0; iSub < lookupTable.subTableCount(); ++iSub)
        {
            otlLookupFormat subTable = lookupTable.subTable(iSub);
            if (bExtension) 
            {
                otlExtensionLookup extLookup=otlExtensionLookup(subTable);
                lookupType = extLookup.extensionLookupType();
                subTable   = extLookup.extensionSubTable();
            }

            switch(lookupType)
            {
            case(1):    // single adjustment
                erc = otlSinglePosLookup(subTable)
                            .apply(pliGlyphInfo,  
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(2):    // pair adjustment
                erc = otlPairPosLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(3):    // cursive attachment
                erc = otlCursivePosLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(4):    // mark to base
                assert(lookupFlags == 0); //this lookup does not take flags
                erc = otlMkBasePosLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;
            
            case(5):    // mark to ligature
                assert(lookupFlags == 0); //this lookup does not take flags
                erc = otlMkLigaPosLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(6):    // mark to mark
                erc = otlMkMkPosLookup(subTable)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(7):    // context positionong
                erc = otlContextLookup(subTable)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(8):    // chaining context positioning
                erc = otlChainingLookup(subTable)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(9):    // extension positioning
                assert(false); //we had to process it before (as Extension lookup type)
                return OTL_ERR_BAD_FONT_TABLE;
                break;

            default:
                return OTL_ERR_BAD_FONT_TABLE;
            }
        }
        return OTL_NOMATCH;
    }
    return OTL_ERR_BAD_INPUT_PARAM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\chaining.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CHAINING.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with chaining context-based substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

	
otlErrCode otlChainingLookup::apply
(
	otlTag					tagTable,
	otlList*				pliCharMap,
	otlList*				pliGlyphInfo,
	otlResourceMgr&			resourceMgr,

	USHORT					grfLookupFlags,
	long					lParameter,
    USHORT                  nesting,

	const otlMetrics&		metr,		
	otlList*				pliduGlyphAdv,				
	otlList*				pliplcGlyphPlacement,		

	USHORT					iglIndex,
	USHORT					iglAfterLast,

	USHORT*					piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);

	switch(format())
	{
	case(1):	// simple
		{
			otlChainSubTable simpleChainContext = otlChainSubTable(pbTable);
			short index = simpleChainContext.coverage()
											.getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			if (index >= simpleChainContext.ruleSetCount())
			{
				assert(false); // bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}
			otlChainRuleSetTable ruleSet = simpleChainContext.ruleSet(index);

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			// start checking contextes
			USHORT cRules = ruleSet.ruleCount();
			bool match = false;
			for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
			{
				otlChainRuleTable rule = ruleSet.rule(iRule);

                match = true;

				const USHORT cBacktrackGlyphs = rule.backtrackGlyphCount();
				const USHORT cLookaheadGlyphs = rule.lookaheadGlyphCount();
				const USHORT cInputGlyphs = rule.inputGlyphCount();

				// a simple check so we don't waste time
                if (iglIndex < cBacktrackGlyphs ||
                    iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

				short igl = iglIndex;
				for (USHORT iGlyphBack = 0; 
							iGlyphBack < cBacktrackGlyphs && match; ++iGlyphBack)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl - 1, otlBackward);

					if (igl < 0 ||
						getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
						  rule.backtrack(iGlyphBack))
					{
						match = false;
					}
				}
				

				igl = iglIndex;
				for (USHORT iGlyphInput = 1; 
							iGlyphInput < cInputGlyphs && match; ++iGlyphInput)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl + 1, otlForward);

					if (igl >= iglAfterLast ||
						getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
						  rule.input(iGlyphInput))
					{
						match = false;
					}
				}
				
				// remember the next glyph in lookup here
				*piglNextGlyph = NextGlyphInLookup(pliGlyphInfo, 
													grfLookupFlags, gdef, 
													igl + 1, otlForward);

				// igl: stays the same
                USHORT iglUBound = pliGlyphInfo->length();
				for (USHORT iGlyphForward = 0; 
							iGlyphForward < cLookaheadGlyphs && match; ++iGlyphForward)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl + 1, otlForward);

					if (igl >= iglUBound ||
						getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
						  rule.lookahead(iGlyphForward))
					{
						match = false;
					}
				}


				if (match)
				{

					return applyContextLookups (rule.lookupRecords(),
									tagTable, 
									pliCharMap, pliGlyphInfo, resourceMgr,
									grfLookupFlags, lParameter, nesting,
									metr, pliduGlyphAdv, pliplcGlyphPlacement,	
									iglIndex, *piglNextGlyph, piglNextGlyph);
				}
			}

			return OTL_NOMATCH;
		}

	case(2):	// class-based
		{
			otlChainClassSubTable classChainContext = 
									otlChainClassSubTable(pbTable);
			short index = classChainContext.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			otlClassDef backClassDef =  classChainContext.backtrackClassDef();
			otlClassDef inputClassDef =  classChainContext.inputClassDef();
			otlClassDef aheadClassDef =  classChainContext.lookaheadClassDef();

			USHORT indexClass = inputClassDef.getClass(pGlyphInfo->glyph);

			if (indexClass >= classChainContext.ruleSetCount())
			{
				assert(false); // bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}
			otlChainClassRuleSetTable ruleSet = 
					classChainContext.ruleSet(indexClass);

			if (ruleSet.isNull())
			{
				return OTL_NOMATCH;
			}

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			// start checking contextes
			USHORT cRules = ruleSet.ruleCount();
			bool match = false;
			for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
			{
				otlChainClassRuleTable rule = ruleSet.rule(iRule);
				short igl;

				match = true;

				const USHORT cBacktrackGlyphs = rule.backtrackClassCount();
				const USHORT cInputGlyphs = rule.inputClassCount();
				const USHORT cLookaheadGlyphs = rule.lookaheadClassCount();

				// a simple check so we don't waste time
                if (iglIndex < cBacktrackGlyphs ||
                    iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

				igl = iglIndex;
				for (USHORT iGlyphBack = 0; 
							iGlyphBack < cBacktrackGlyphs && match; ++iGlyphBack)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl - 1, otlBackward);

					if (igl < 0 ||
						backClassDef
							.getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph)
						!= rule.backtrackClass(iGlyphBack))
					{
						match = false;
					}
				}
				

				igl = iglIndex;
				for (USHORT iGlyphInput = 1; 
							iGlyphInput < cInputGlyphs && match; ++iGlyphInput)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl + 1, otlForward);

					if (igl >= iglAfterLast || 
						inputClassDef
							.getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph)
						!= rule.inputClass(iGlyphInput))
					{
						match = false;
					}
				}
				
				// remember the next glyph in lookup here
				*piglNextGlyph = NextGlyphInLookup(pliGlyphInfo, 
													grfLookupFlags, gdef, 
													igl + 1, otlForward);

				// igl: stays the same
                USHORT iglUBound = pliGlyphInfo->length();
				for (USHORT iGlyphForward = 0; 
							iGlyphForward < cLookaheadGlyphs && match; ++iGlyphForward)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl + 1, otlForward);

					if (igl >= iglUBound ||
						aheadClassDef
							.getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph)
						!= rule.lookaheadClass(iGlyphForward))
					{
						match = false;
					}
				}

				if (match)
				{

					return applyContextLookups (rule.lookupRecords(),
									tagTable, 
									pliCharMap, pliGlyphInfo, resourceMgr,
									grfLookupFlags,lParameter, nesting,
									metr, pliduGlyphAdv, pliplcGlyphPlacement,	
									iglIndex,*piglNextGlyph, piglNextGlyph);
				}
			}

			return OTL_NOMATCH;
		}
	case(3):	// coverage-based
		{
			otlChainCoverageSubTable coverageChainContext = 
								otlChainCoverageSubTable(pbTable);

			bool match = true;
			
			const USHORT cBacktrackGlyphs = 
					coverageChainContext.backtrackCoverageCount();
			const USHORT cInputGlyphs = 
                        coverageChainContext.inputCoverageCount();
			const USHORT cLookaheadGlyphs = 
						coverageChainContext.lookaheadCoverageCount();

            // a simple check so we don't waste time
            if (iglIndex < cBacktrackGlyphs ||
                iglIndex + cInputGlyphs > iglAfterLast)
            {
                match = false;
            }

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			short igl = iglIndex;
			for (USHORT iGlyphBack = 0; 
						iGlyphBack < cBacktrackGlyphs && match; ++iGlyphBack)
			{
				igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
										igl - 1, otlBackward);

				if (igl < 0 ||
					coverageChainContext.backtrackCoverage(iGlyphBack)
					.getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph) < 0)
				{
					match = false;
				}
			}
				
			igl = iglIndex;
			for (USHORT iGlyphInput = 0; 
						iGlyphInput < cInputGlyphs && match; ++iGlyphInput)
			{
				if (igl >= iglAfterLast || 
					coverageChainContext.inputCoverage(iGlyphInput)
					.getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph) < 0)
				{
					match = false;
				}
				else
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl + 1, otlForward);
				}
			}

			*piglNextGlyph = igl;

			// igl: stays the same
            USHORT iglUBound = pliGlyphInfo->length();
			for (USHORT iGlyphForward = 0; 
						iGlyphForward < cLookaheadGlyphs && match; ++iGlyphForward)
			{
				if (igl >= iglUBound || 
					coverageChainContext.lookaheadCoverage(iGlyphForward)
						.getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph) < 0)
				{
					match = false;
				}
				else
				{
					igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
											igl + 1, otlForward);
				}
			}


			if (match)
			{
				return applyContextLookups (coverageChainContext.lookupRecords(),
									tagTable, 
									pliCharMap, pliGlyphInfo, resourceMgr,
									grfLookupFlags,lParameter, nesting,
									metr, pliduGlyphAdv, pliplcGlyphPlacement,	
									iglIndex, *piglNextGlyph, piglNextGlyph);
			}

			return OTL_NOMATCH;
		}

	default:
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\base.h ===
/***********************************************************************
************************************************************************
*
*                    ********  BASE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL BASE table formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetBaseTagCount = 0;
const OFFSET offsetBaselineTagArray = 2;

class otlBaseTagListTable: public otlTable
{
public:

    otlBaseTagListTable(const BYTE* pb): otlTable(pb) {}

    USHORT baseTagCount() const
    {   return UShort(pbTable + offsetBaseTagCount); }

    otlTag baselineTag(USHORT index)  const
    {   assert(index < baseTagCount());
        return *(UNALIGNED otlTag*)(pbTable + offsetBaselineTagArray
                                  + index * sizeof(otlTag));
    }
};


const OFFSET offsetBaseCoordFormat = 0;

const OFFSET offsetSimpleBaseCoordinate = 2;

class otlSimpleBaseCoord: public otlTable
{
public:
    otlSimpleBaseCoord(const BYTE* pb)
        : otlTable(pb)
    {
        assert(baseCoordFormat() == 1);
    }

    USHORT baseCoordFormat() const
    {   return  UShort(pbTable + offsetBaseCoordFormat); }

    short coordinate()  const
    {   return SShort(pbTable + offsetSimpleBaseCoordinate); }
};


const OFFSET offsetContourBaseCoordinate = 2;
const OFFSET offsetReferenceGlyph = 4;
const OFFSET offsetBaseCoordPoint = 6;

class otlContourBaseCoord: public otlTable
{
public:
    otlContourBaseCoord(const BYTE* pb)
        : otlTable(pb)
    {
        assert(baseCoordFormat() == 2);
    }

    USHORT baseCoordFormat() const
    {   return  UShort(pbTable + offsetBaseCoordFormat); }

    short coordinate()  const
    {   return SShort(pbTable + offsetContourBaseCoordinate); }

    otlGlyphID referenceGlyph() const
    {   return GlyphID(pbTable + offsetReferenceGlyph); }

    USHORT baseCoordPoint() const
    {   return UShort(pbTable + offsetBaseCoordPoint); }
};


const OFFSET offsetDeviceBaseCoordinate = 2;
const OFFSET offsetDeviceTable = 4;

class otlDeviceBaseCoord: public otlTable
{
public:
    otlDeviceBaseCoord(const BYTE* pb)
        : otlTable(pb)
    {
        assert(baseCoordFormat() == 3);
    }

    USHORT baseCoordFormat() const
    {   return  UShort(pbTable + offsetBaseCoordFormat); }

    short coordinate()  const
    {   return SShort(pbTable + offsetDeviceBaseCoordinate); }

    otlDeviceTable deviceTable() const
    {   return otlDeviceTable(pbTable + Offset(pbTable + offsetDeviceTable)); }
};


class otlBaseCoord: public otlTable
{
public:

    otlBaseCoord(const BYTE* pb): otlTable(pb) {}

    USHORT format() const
    {   return UShort(pbTable + offsetBaseCoordFormat); }

    long baseCoord
    (
        const otlMetrics&   metr,
        otlResourceMgr&     resourceMgr     // for getting coordinate points
    ) const;
};


const OFFSET offsetDefaultIndex = 0;
const OFFSET offsetBaseCoordCount = 2;
const OFFSET offsetBaseCoordArray = 4;

class otlBaseValuesTable: public otlTable
{
public:

    otlBaseValuesTable(const BYTE* pb): otlTable(pb) {}

    USHORT deafaultIndex() const
    {   return UShort(pbTable + offsetDefaultIndex); }

    USHORT baseCoordCount() const
    {   return UShort(pbTable + offsetBaseCoordCount); }

    otlBaseCoord baseCoord(USHORT index) const
    {   assert(index < baseCoordCount());
        return otlBaseCoord(pbTable +
            Offset(pbTable + offsetBaseCoordArray + index * sizeof(OFFSET)));
    }
};


const OFFSET offsetFeatureTableTag = 0;
const OFFSET offsetMinCoord = 4;
const OFFSET offsetMaxCoord = 6;

class otlFeatMinMaxRecord: public otlTable
{
    const BYTE* pbMainTable;
public:

    otlFeatMinMaxRecord(const BYTE* minmax, const BYTE* pb)
        : otlTable(pb),
          pbMainTable(minmax)
    {}

    otlTag featureTableTag() const
    {   return *(UNALIGNED otlTag*)(pbTable + offsetFeatureTableTag); }


    otlBaseCoord minCoord() const
    {   if (Offset(pbTable + offsetMinCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL);

        return otlBaseCoord(pbMainTable + Offset(pbTable + offsetMinCoord));
    }


    otlBaseCoord maxCoord() const
    {   if (Offset(pbTable + offsetMaxCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL);

        return otlBaseCoord(pbMainTable + Offset(pbTable + offsetMaxCoord));
    }

};


const OFFSET offsetDefaultMinCoord = 0;
const OFFSET offsetDefaultMaxCoord = 2;
const OFFSET offsetFeatMinMaxCount = 4;
const OFFSET offsetFeatMinMaxRecordArray = 6;
const USHORT sizeFeatMinMaxRecord = 8;

class otlMinMaxTable: public otlTable
{
public:

    otlMinMaxTable(const BYTE* pb): otlTable(pb) {}

    otlBaseCoord minCoord() const
    {   if (Offset(pbTable + offsetDefaultMinCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL);

        return otlBaseCoord(pbTable + Offset(pbTable + offsetDefaultMinCoord));
    }


    otlBaseCoord maxCoord() const
    {   if (Offset(pbTable + offsetDefaultMaxCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL);

        return otlBaseCoord(pbTable + Offset(pbTable + offsetDefaultMaxCoord));
    }


    USHORT featMinMaxCount() const
    {   return UShort(pbTable + offsetFeatMinMaxCount); }

    otlFeatMinMaxRecord featMinMaxRecord(USHORT index) const
    {   assert(index < featMinMaxCount());
        return otlFeatMinMaxRecord(pbTable,
                                   pbTable + offsetFeatMinMaxRecordArray
                                           + index * sizeFeatMinMaxRecord);
    }
};


const OFFSET offsetBaseValues = 0;
const OFFSET offsetDefaultMinMax = 2;
const OFFSET offsetBaseLangSysCount = 4;
const OFFSET offsetBaseLangSysRecordArray = 6;
const USHORT sizeBaseLangSysRecord = 6;

const OFFSET offsetBaseLangSysTag = 0;
const OFFSET offsetMinMax = 4;

class otlBaseScriptTable: public otlTable
{
public:

    otlBaseScriptTable(const BYTE* pb): otlTable(pb) {}

    otlBaseValuesTable baseValues() const
    {   if (Offset(pbTable + offsetBaseValues) == 0)
            return otlBaseValuesTable((const BYTE*)NULL);

        return otlBaseValuesTable(pbTable + Offset(pbTable + offsetBaseValues));
    }

    otlMinMaxTable defaultMinMax() const
    {   if (Offset(pbTable + offsetDefaultMinMax) == 0)
            return otlMinMaxTable((const BYTE*)NULL);

        return otlMinMaxTable(pbTable + Offset(pbTable + offsetDefaultMinMax));
    }

    USHORT baseLangSysCount() const
    {   return UShort(pbTable + offsetBaseLangSysCount); }

    otlTag baseLangSysTag(USHORT index) const
    {   assert(index < baseLangSysCount());
        return *(UNALIGNED otlTag*)(pbTable + offsetBaseLangSysRecordArray
                                  + index * sizeBaseLangSysRecord
                                  + offsetBaseLangSysTag);
    }

    otlMinMaxTable minmax(USHORT index) const
    {   assert(index < baseLangSysCount());
        return otlMinMaxTable(pbTable +
            Offset(pbTable + offsetBaseLangSysRecordArray
                           + index * sizeBaseLangSysRecord + offsetMinMax));
    }
};


const OFFSET offsetBaseScriptCount = 0;
const OFFSET offsetBaseScriptRecordArray = 2;
const USHORT sizeBaseScriptRecord = 6;

const OFFSET offsetBaseScriptTag = 0;
const OFFSET offsetBaseScriptOffset = 4;

class otlBaseScriptListTable: public otlTable
{
public:

    otlBaseScriptListTable(const BYTE* pb): otlTable(pb) {}

    USHORT baseScriptCount() const
    {   return UShort(pbTable + offsetBaseScriptCount); }

    otlTag baseScriptTag(USHORT index)
    {   assert(index < baseScriptCount());
        return *(UNALIGNED otlTag*)(pbTable + offsetBaseScriptRecordArray
                                  + index * sizeBaseScriptRecord
                                  + offsetBaseScriptTag);
    }


    otlBaseScriptTable baseScript(USHORT index) const
    {   assert(index < baseScriptCount());
        return otlBaseScriptTable(pbTable +
            Offset(pbTable + offsetBaseScriptRecordArray
                           + index * sizeBaseScriptRecord
                           + offsetBaseScriptOffset));
    }
};


const OFFSET offsetBaseTagList = 0;
const OFFSET offsetBaseScriptList = 2;

class otlAxisTable: public otlTable
{
public:

    otlAxisTable(const BYTE* pb): otlTable(pb) {}

    otlBaseTagListTable baseTagList() const
    {   if (Offset(pbTable + offsetBaseTagList) == 0)
            return otlBaseTagListTable((const BYTE*)NULL);

        return otlBaseTagListTable(pbTable + Offset(pbTable + offsetBaseTagList));
    }

    otlBaseScriptListTable baseScriptList() const
    {   return otlBaseScriptListTable(pbTable
                    + Offset(pbTable + offsetBaseScriptList));
    }
};


const OFFSET offsetBaseVersion = 0;
const OFFSET offsetHorizAxis = 4;
const OFFSET offsetVertAxis = 6;

class otlBaseHeader: public otlTable
{
public:

    otlBaseHeader(const BYTE* pb): otlTable(pb) {}

    ULONG version() const
    {   return ULong(pbTable + offsetBaseVersion); }

    otlAxisTable horizAxis() const
    {   if (Offset(pbTable + offsetHorizAxis) == 0)
            return otlAxisTable((const BYTE*)NULL);

        return otlAxisTable(pbTable + Offset(pbTable + offsetHorizAxis));
    }

    otlAxisTable vertAxis() const
    {   if (Offset(pbTable + offsetVertAxis) == 0)
            return otlAxisTable((const BYTE*)NULL);

        return otlAxisTable(pbTable + Offset(pbTable + offsetVertAxis));
    }
};


// helper functions

// returns a NULL table if not found
otlBaseScriptTable FindBaseScriptTable
(
    const otlAxisTable&     axisTable,
    otlTag                  tagScript
);

otlMinMaxTable FindMinMaxTable
(
    const otlBaseScriptTable&       scriptTable,
    otlTag                          tagLangSys
);

otlFeatMinMaxRecord FindFeatMinMaxRecord
(
    const otlMinMaxTable&   minmaxTable,
    otlTag                  tagFeature
);

otlBaseCoord FindBaselineValue
(
    const otlBaseTagListTable&  taglistTable,
    const otlBaseScriptTable&   scriptTable,
    otlTag                      tagBaseline
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\apply.h ===
/***********************************************************************
************************************************************************
*
*                    ********  APPLY.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL feature/lookup application.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#define		OTL_NOMATCH						0x0001

// HELPER FUNCTIONS

// skipps all marks as specified (assuming "skip marks" is on)
// returns iglAfter next glyph not found	(all skipped)

enum otlDirection
{
	otlForward	= 1,
	otlBackward	= -1
};

short NextGlyphInLookup
	(
	const otlList*		pliGlyphInfo, 

	USHORT					grfLookupFlags,
	const otlGDefHeader&	gdef,

	short				iglFirst,
	otlDirection		direction
	);

// calls "apply" on specific lookup types -- subclassed in each case
// has a big case statement on lookup types (but not formats!)
otlErrCode ApplyLookup
(
	otlTag						tagTable,			// GSUB/GPOS
	otlList*					pliCharMap,
	otlList*					pliGlyphInfo,
	otlResourceMgr&				resourceMgr,

	const otlLookupTable&		lookupTable,
	long						lParameter,
    USHORT                      nesting,
	
	const otlMetrics&			metr,		
	otlList*					pliduGlyphAdv,			// assert null for GSUB
	otlList*					pliplcGlyphPlacement,	// assert null for GSUB

	USHORT						iglFrist,		// where to apply it
	USHORT						iglAfterLast,	// how long a context we can use

	USHORT*						piglNext		// out: next glyph index
);												// return: did/did not apply


// main function for feature application
// calls applyLookup() to actually perform lookups
// contains all logic of feature/lookup application algorithm
otlErrCode ApplyFeatures
(
    otlTag						tagTable,					// GSUB/GPOS
    const otlFeatureSet*		pFSet,
	otlList*					pliCharMap,
    otlList*					pliGlyphInfo, 
	
	otlResourceMgr&				resourceMgr,

	otlTag						tagScript,
	otlTag						tagLangSys,

	const otlMetrics&	metr,		
	otlList*			pliduGlyphAdv,				// assert null for GSUB
    otlList*			pliplcGlyphPlacement,		// assert null for GSUB

	otlList*			pliFResults
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\span.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Character span support
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/

#ifndef _SPAN_HPP
#define _SPAN_HPP




////    VectorBase - very very simple dynamic array base class
//
//      VectorBase[]            - directly address index element (index checked in checked build)
//      VectorBase.Resize(size) - Allocate memory for at least size elements
//      VectorBase.Shrink(size) - Reduce vector to exactly size


template <class C> class VectorBase
{
public:
    VectorBase() :
        Allocated      (0),
        VectorElements (NULL)
    {}

    ~VectorBase()
    {
        if (VectorElements)
        {
            GpFree(VectorElements);
            VectorElements = NULL;
        }
    }

    C &operator[] (INT index)
    {
        ASSERT(index >= 0  &&  index < Allocated);
        return VectorElements[index];
    }

    const C &operator[] (INT index) const
    {
        ASSERT(index >= 0  &&  index < Allocated);
        return VectorElements[index];
    }

    BOOL Resize(INT targetAllocation);
    BOOL Shrink(INT targetAllocation);

private:
    INT   Allocated;
    C    *VectorElements;
};






////    Vector - dynamic array class
//
//      Vector.Add(&element)    - Add an element at the end of the array
//      Vector.Del()            - Delete an element at the end of the array
//      Vector.GetCount()       - Get the number of active element
//      Vector.Reset()          - Reset the number of active element, shrink the buffer if wanted
//      Vector.GetDataBuffer()  - Get data buffer pointer


template <class C> class Vector : public VectorBase<C>
{
public:
    Vector() :
        Active  (0)
    {}

    GpStatus Add(const C& newElement)
    {
        if (!Resize(Active + 1))
            return OutOfMemory;
        C& currentElement = operator[](Active);
        GpMemcpy (&currentElement, &newElement, sizeof(C));
        Active++;
        return Ok;
    }

    void Del()
    {
        if (Active > 0)
            Active--;
    }

    void Reset(BOOL shrink = FALSE)
    {
        Active = 0;
        if (shrink)
        {
            Shrink(0);
        }
    }

    INT GetCount()
    {
        return Active;
    }

    C* GetDataBuffer()
    {
        return &operator[](0);
    }

private:
    INT     Active;
};







/////   Span - element pointer and length
//
//      A span is a simple pairing of a pointer to an arbitrary
//      run attribute, and a run length.


template <class C> class Span {
public:

    Span() :
        Element (NULL),
        Length  (0)
    {}

    Span(const C initElement, INT initLength) :
        Element (initElement),
        Length  (initLength)
    {}

    ~Span() {}

    C       Element;
    UINT32  Length;
};






/////   SpanVector - array of spans representing arbitrary character attributes
//
//      A SpanVector is an array of spans with support routines to update
//      the spans over character ranges.
//
//      When changing, inserting or deleting attributes of character ranges,
//      the SpanVector takes care of optimising the insertions to maintain
//      a minimal Length span vector.
//
//      A span whos element has value NULL is equivalent to a missing span.
//
//      Methods:
//
//          SetSpan(first, Length, value)
//
//              Sets the range [first .. first+Length-1]  to the given
//              value. Previous values (if any) for the range are lost.
//              Adjacent ranges are merged where possible.
//
//          OrSpan(first, Length, value)
//
//              Sets the range [first .. first+Length-1]  to the result of
//              OR combination between given and existing value. Duplicate
//              ranges are merged where possible.





////    !!! Optimise to avoid creating spans which match the default value



template <class C> class SpanRider;




/////   SpanVector
//
//      SpanVector(default value)
//
//      Status   spanvector.SetSpan(first, length, value)
//      Status   spanvector.OrSpan(first, length, value)
//      const C &spanVector.GetElement(INT) - returns element at position i, default if none
//
//      const C &spanvector.GetDefault()    - gets default value
//      INT      spanvector.GetActive()     - returns number of spans in vector
//      Span<C> &spanvector[INT]            - returns specified Span
//      void     spanvector.Free()          - free every non-null element


template <class C> class SpanVector {

friend class SpanRider<C>;

public:

    SpanVector(
        C defaultValue
    ) :
        Default   (defaultValue),
        Active    (0)
    {}


    Status SetSpan(INT first, INT length, C element);
    Status OrSpan(INT first, INT length, C element);

    void Free() // Only call 'Free' if <C> is a pointer type!
    {
        // free every non-null element.

        for (INT i=0; i<Active; i++)
        {
            if (Spans[i].Element != NULL)
            {
                delete Spans[i].Element;
            }
        }
        Active = 0;

        if (Default)
        {
            delete Default;
        }
    }

    const C &GetDefault()   {return Default;}
    INT      GetSpanCount() {return Active;}

    const Span<C> &operator[] (INT i) const
    {
        ASSERT(i<Active);
        return Spans[i];
    }

    Span<C> &operator[] (INT i)
    {
        ASSERT(i<Active);
        return Spans[i];
    }

    #if DBG
        void Dump();
    #endif

    void Reset(BOOL shrink = FALSE);

private:

    GpStatus Erase(INT first, INT count);
    GpStatus Insert(INT first, INT count);
    GpStatus Add(const Span<C> &newSpan);


    C                       Default;
    VectorBase< Span< C > > Spans;
    INT                     Active;
};


/*

    Span<C> &operator[] (INT index)
    {
        if (index >= Active)
        {
            return Span<C>(Default, 0);
        }
        else
        {
            return Spans[index];
        }
    }

    INT GetActive() {return Active;}

    / *
    const C &GetElement(INT index) const
    {
        if (    index < Active
            &&  Spans[index].Element != NULL)
        {
            return Spans[index].Element;
        }
        else
        {
            return Default;
        }
    }
    * /

    const C &GetElementAt(INT offset) const
    {
        INT elementIndex  = 0;
        INT elementOffset = 0;

        while (    elementIndex < Active
               &&  offset < elementOffset + Spans[elementIndex].Length)
        {
            elementOffset += Spans[elementIndex].Length;
            elementIndex++;
        }

        if (elementIndex < Active)
        {
            return Spans[elementIndex].Element;
        }
        else
        {
            return Default;
        }
    }

    const C&GetDefault() const
    {
        return Default;
    }
*/











/////   SpanRider - a class for efficiently running a cursor along a span vector
//
//


template <class C> class SpanRider {

public:

    SpanRider(SpanVector<C> *spans) :
        Spanvector           (spans),
        DefaultSpan          (spans->Default, 0xFFFFFFFF),
        CurrentOffset        (0),
        CurrentElement       (0),
        CurrentElementIndex  (0)
    {}

    BOOL SetPosition(UINT32 newOffset);

    BOOL AtEnd()
    {
        return CurrentElement >= Spanvector->Active;
    }

    void operator++(int)
    {
        if (CurrentElement < Spanvector->Active)
        {
            CurrentElementIndex += Spanvector->Spans[CurrentElement].Length;
            CurrentElement++;
        }
    }

    C &operator[] (INT offset)
    {
        if (    Spanvector->Active > 0
            &&  SetPosition(offset))
        {
            return Spanvector->Spans[CurrentElement].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    const Span<C> &GetCurrentSpan() const
    {
        if (CurrentElement < Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement];
        }
        else
        {
            return DefaultSpan;
        }
    }

    const C &GetCurrentElement() const
    {
        if (CurrentElement < Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    C &GetCurrentElement()
    {
        if (CurrentElement < Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    const C &GetPrecedingElement() const
    {
        if (   CurrentElement > 0
            && CurrentElement <= Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement - 1].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    UINT32 GetCurrentOffset() const {return CurrentOffset;}

    UINT32 GetUniformLength() const {
        if (CurrentElement < Spanvector->Active)
        {
            return CurrentElementIndex + Spanvector->Spans[CurrentElement].Length - CurrentOffset;
        }
        else
        {
            return 0xFFFFFFFF;  // There's no limit to this span
        }
    }

    UINT32 GetCurrentSpanStart() const {return CurrentElementIndex;}


    // SpanRider has its own SetSpan that must be used to guarantee that
    // the rider remains accurate.

    Status SetSpan(INT first, INT length, C element)
    {
        // Position the rider at the beginning. This change will require
        // the rider to be recalculated.
        CurrentOffset       = 0;
        CurrentElement      = 0;
        CurrentElementIndex = 0;
        return Spanvector->SetSpan(first, length, element);
    }


private:

    SpanVector<C> *Spanvector;
    Span<C>        DefaultSpan;
    UINT32         CurrentOffset;
    INT            CurrentElement;
    UINT32         CurrentElementIndex;
};



/*
    const C &GetElement() const {
        return (*Spans)[CurrentElement].Element;
    }
*/



#if 0

/////   MultiSpanRider
//
//      Supports advancing through parallel spanvectors of different types
//      returning the max length uniform in all registerd types.
//
//      The client calls SetScript, SetLanguage etc to register which
//      spanVectors to scan in parallel.


class MultiSpanRider {
public:
    MultiSpanRider(
        UINT32 stringLength
    ) :
        StringLength  (stringLength),
        FamilyRider   (NULL),
        StyleRider    (NULL),
        SizeRider     (NULL),
        //ScriptRider   (NULL),
        LanguageRider (NULL),
        LevelRider    (NULL),
        //ItemRider     (NULL),
        LineRider     (NULL),
        Offset        (0),
        UniformLength (0),
        Started       (FALSE)
    {}

    ~MultiSpanRider()
    {
        if (FamilyRider)   delete FamilyRider;
        if (StyleRider)    delete StyleRider;
        if (SizeRider)     delete SizeRider;
        //if (ScriptRider)   delete ScriptRider;
        if (LanguageRider) delete LanguageRider;
        if (LevelRider)    delete LevelRider;
        //if (ItemRider)     delete ItemRider;
        if (LineRider)     delete LineRider;
    }

    // ---  Font

    void SetFamily(SpanVector<const GpFontFamily*> *familyVector)
    {
        ASSERT(!Started);
        FamilyRider = new SpanRider<const GpFontFamily*>(familyVector);
    }

    const GpFontFamily *GetFamily()
    {
        ASSERT(Started);
        return FamilyRider->GetCurrentElement();
    }


    void SetStyle(SpanVector<INT> *styleVector)
    {
        ASSERT(!Started);
        StyleRider = new SpanRider<INT>(styleVector);
    }

    const INT GetStyle()
    {
        ASSERT(Started);
        return StyleRider->GetCurrentElement();
    }


    void SetEmSize(SpanVector<REAL> *sizeVector)
    {
        ASSERT(!Started);
        SizeRider = new SpanRider<REAL>(sizeVector);
    }

    const REAL GetEmSize()
    {
        ASSERT(Started);
        return SizeRider->GetCurrentElement();
    }

    /*
    // ---  Script

    void SetScript(SpanVector<Script> *scriptVector)
    {
        ASSERT(!Started);
        ScriptRider = new SpanRider<Script>(scriptVector);
    }

    Script GetScript()
    {
        ASSERT(Started);
        return ScriptRider->GetCurrentElement();
    }
    */


    // ---  Language


    void SetLanguage(SpanVector<UINT16> *languageVector)
    {
        ASSERT(!Started);
        LanguageRider = new SpanRider<UINT16>(languageVector);
    }

    UINT16 GetLanguage()
    {
        ASSERT(Started);
        return LanguageRider->GetCurrentElement();
    }

    // ---  bidi Level

    void SetLevel(SpanVector<BYTE> *levelVector)
    {
        ASSERT(!Started);
        LevelRider = new SpanRider<BYTE>(levelVector);
    }

    UINT16 GetLevel()
    {
        ASSERT(Started);
        return LevelRider->GetCurrentElement();
    }

    // ---  item

    /*
    void SetItem(SpanVector<Item*> *vector)
    {
        ASSERT(!Started);
        ItemRider = new SpanRider<Item*>(vector);
    }

    Item* GetItem()
    {
        ASSERT(Started);
        return ItemRider->GetCurrentElement();
    }

    const Span<Item*> &GetItemSpan() const
    {
        ASSERT(Started);
        return ItemRider->GetCurrentSpan();
    }

    UINT32 GetItemStart() const
    {
        ASSERT(Started);
        return ItemRider->GetCurrentSpanStart();
    }
    */

    // ---  filledLine

    void SetLine(SpanVector<BuiltLine*> *vector)
    {
        ASSERT(!Started);
        LineRider = new SpanRider<BuiltLine*>(vector);
    }

    const BuiltLine* GetLine() const
    {
        ASSERT(Started);
        return LineRider->GetCurrentElement();
    }

    UINT32 GetLineStart() const
    {
        ASSERT(Started);
        return LineRider->GetCurrentSpanStart();
    }

    // ---

    UINT32 GetUniformLength()
    {
        if (!Started)
        {
            ASSERT(   FamilyRider
                   || StyleRider
                   || SizeRider
                   //|| ScriptRider
                   || LanguageRider
                   || LevelRider
                   //|| ItemRider
                   || LineRider);
            CalculateUniformLength();
            Started = TRUE;
        }

        return UniformLength;
    }

    UINT32 GetOffset()
    {
        return Offset;
    }

    void operator++(int)
    {
        ASSERT(Started);

        // Advance to next uniform length

        Offset += UniformLength;
        SetPosition(Offset);
        CalculateUniformLength();
    }



private:

    void SetPosition(UINT32 Offset)
    {
        if (FamilyRider)   FamilyRider   -> SetPosition(Offset);
        if (StyleRider)    StyleRider    -> SetPosition(Offset);
        if (SizeRider)     SizeRider     -> SetPosition(Offset);
        // if (ScriptRider)   ScriptRider   -> SetPosition(Offset);
        if (LanguageRider) LanguageRider -> SetPosition(Offset);
        if (LevelRider)    LevelRider    -> SetPosition(Offset);
        // if (ItemRider)     ItemRider     -> SetPosition(Offset);
        if (LineRider)     LineRider     -> SetPosition(Offset);
        {

        }
    }

    void CalculateUniformLength()
    {
        UniformLength = 0x3FFFFFFF;

        if (FamilyRider && FamilyRider->GetUniformLength() < UniformLength)
        {
            UniformLength = FamilyRider->GetUniformLength();
        }

        if (StyleRider && StyleRider->GetUniformLength() < UniformLength)
        {
            UniformLength = StyleRider->GetUniformLength();
        }

        if (SizeRider && SizeRider->GetUniformLength() < UniformLength)
        {
            UniformLength = SizeRider->GetUniformLength();
        }

        /*
        if (ScriptRider && ScriptRider->GetUniformLength() < UniformLength)
        {
            UniformLength = ScriptRider->GetUniformLength();
        }
        */

        if (LanguageRider && LanguageRider->GetUniformLength() < UniformLength)
        {
            UniformLength = LanguageRider->GetUniformLength();
        }

        if (LevelRider && LevelRider->GetUniformLength() < UniformLength)
        {
            UniformLength = LevelRider->GetUniformLength();
        }

        /*
        if (ItemRider && ItemRider->GetUniformLength() < UniformLength)
        {
            UniformLength = ItemRider->GetUniformLength();
        }
        */

        if (LineRider && LineRider->GetUniformLength() < UniformLength)
        {
            UniformLength = LineRider->GetUniformLength();
        }

        if (UniformLength >= StringLength - Offset)
        {
            UniformLength = StringLength - Offset;   // It's uniform all the way to the end
        }
    }



    SpanRider<const GpFontFamily*> *FamilyRider;
    SpanRider<INT>                 *StyleRider;
    SpanRider<REAL>                *SizeRider;
    // SpanRider<Script>              *ScriptRider;
    SpanRider<UINT16>              *LanguageRider;
    SpanRider<BYTE>                *LevelRider;
    // SpanRider<Item*>               *ItemRider;
    SpanRider<BuiltLine*>         *LineRider;

    UINT32  StringLength;
    UINT32  Offset;
    UINT32  UniformLength;
    BOOL    Started;
};


#endif // 0



#endif // _SPAN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\classdef.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CLASDEF.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of class definition tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// REVIEW (PERF): it's used a lot - optimize!

USHORT otlClassDef::getClass(otlGlyphID glyph) const
{
	 switch(format())
	 {
	 case(1):		// class array
		 {
			 otlClassArrayTable classArray = 
				 otlClassArrayTable(pbTable);

			 long index = glyph - classArray.startGlyph();

			 if (0 <= index && index < classArray.glyphCount())
			 {
				 return classArray.classValue((USHORT)index);
			 }
			 else
				return 0;
		 }

	 case(2):		// class ranges
		 {
             otlClassRangesTable classRanges = 
                        otlClassRangesTable(pbTable);
 
    #ifdef _DEBUG
             // in debug mode, check that the coverage is sorted
             for (USHORT i = 0; i < classRanges.classRangeCount() - 1; ++i)
             {
                 otlGlyphID glThis = classRanges.classRangeRecord(i).start();
                 otlGlyphID glNext = classRanges.classRangeRecord(i + 1).start();
                 assert(classRanges.classRangeRecord(i).start() 
                        < classRanges.classRangeRecord(i + 1).start());
             }
    #endif
 
             USHORT iLowRange = 0;
             // always beyond the upper bound
             USHORT iHighRange = classRanges.classRangeCount(); 
             while(iLowRange < iHighRange)
             {
                 USHORT iMiddleRange = (iLowRange + iHighRange) >> 1;
                 otlClassRangeRecord range = classRanges.classRangeRecord(iMiddleRange);
                 if (glyph < range.start()) 
                 {
                     iHighRange = iMiddleRange;
                 }
                 else if (range.end() < glyph)
                 {
                     iLowRange = iMiddleRange + 1;
                 }
                 else
                 {
                     return range.getClass();
                 }            
             } 
 
             return  0;
         }
	 }

     // default: invalid format
     assert(false);
     return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\base.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  BASE.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions dealing with BASE table processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/
otlBaseScriptTable FindBaseScriptTable
(
	const otlAxisTable&		axisTable,
	otlTag					tagScript
)
{
	if (axisTable.isNull())
	{
		return otlBaseScriptTable((const BYTE*)NULL);
	}

	otlBaseScriptListTable scriptList = axisTable.baseScriptList();

	USHORT cBaseScripts = scriptList.baseScriptCount();
	for (USHORT iScript = 0; iScript < cBaseScripts; ++iScript)
	{
		if (scriptList.baseScriptTag(iScript) == tagScript)
		{
			return scriptList.baseScript(iScript);
		}
	}

	return otlBaseScriptTable((const BYTE*)NULL);

}


otlMinMaxTable FindMinMaxTable
(
	const otlBaseScriptTable&		scriptTable,
	otlTag							tagLangSys
)
{
	if (tagLangSys == OTL_DEFAULT_TAG)
	{
		return scriptTable.defaultMinMax();
	}

	USHORT cLangSys = scriptTable.baseLangSysCount();
	for(USHORT iLangSys = 0; iLangSys < cLangSys; ++iLangSys)
	{
		if (scriptTable.baseLangSysTag(iLangSys) == tagLangSys)
		{
			return scriptTable.minmax(iLangSys);
		}
	}

	return otlMinMaxTable((const BYTE*)NULL);

}


otlFeatMinMaxRecord	FindFeatMinMaxRecord
(
	const otlMinMaxTable&	minmaxTable,
	otlTag					tagFeature
)
{
	USHORT cFeatures = minmaxTable.featMinMaxCount();
	for(USHORT iFeature = 0; iFeature < cFeatures; ++iFeature)
	{
		otlFeatMinMaxRecord minmaxRecord = minmaxTable.featMinMaxRecord(iFeature);
		if (minmaxRecord.featureTableTag() == tagFeature)
		{
			return minmaxRecord;
		}
	}

	return otlFeatMinMaxRecord((const BYTE*)NULL, (const BYTE*)NULL);
}


/*
otlBaseCoord FindBaselineValue
(
	const otlBaseTagListTable&	taglistTable,
	const otlBaseValuesTable&	baseValues,
	otlTag						tagBaseline
)
{
	if (tagBaseline == OTL_DEFAULT_TAG)
	{
		if (baseValues.deafaultIndex() >= baseValues.baseCoordCount())
		{
			assert(false);	// bad font
			return otlBaseCoord((const BYTE*)NULL);
		}
		return baseValues.baseCoord(baseValues.deafaultIndex());
	}

	short iBaseline;
	bool fBaselineFound = false;
	USHORT cBaselineTags = taglistTable.baseTagCount();
	for(USHORT iTag = 0; iTag < cBaselineTags && !fBaselineFound; ++iTag)
	{
		if (taglistTable.baselineTag(iTag) == tagBaseline)
		{
			iBaseline = iTag;
			fBaselineFound = true;
		}
	}

	if (!fBaselineFound)
	{
		return otlBaseCoord((const BYTE*)NULL);
	}

	if (iBaseline >= baseValues.baseCoordCount())
	{
		assert(false);  // bad font
		return otlBaseCoord((const BYTE*)NULL);
	}

	return baseValues.baseCoord(iBaseline);

}
*/

long otlBaseCoord::baseCoord
(
	const otlMetrics&	metr,		
	otlResourceMgr&		resourceMgr		// for getting coordinate points
) const
{
	assert(!isNull());

	switch(format())
	{
	case(1):	// design units only
		{
			otlSimpleBaseCoord simpleBaseline = otlSimpleBaseCoord(pbTable);
			if (metr.layout == otlRunLTR || 
				metr.layout == otlRunRTL)
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmY, 
								 (long)simpleBaseline.coordinate());
			}
			else
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmX, 
								 (long)simpleBaseline.coordinate());
			}
		}

	case(2):	// contour point
		{
			otlContourBaseCoord contourBaseline = otlContourBaseCoord(pbTable);

			otlPlacement* rgPointCoords = 
				resourceMgr.getPointCoords(contourBaseline.referenceGlyph());
			if (rgPointCoords != NULL)
			{
				USHORT iPoint = contourBaseline.baseCoordPoint();

				if (metr.layout == otlRunLTR || 
					metr.layout == otlRunRTL)
				{
					return rgPointCoords[iPoint].dy;
				}
				else
				{
					return rgPointCoords[iPoint].dx;
				}
			}
			else
				return (long)0;
		}
	
	case(3):	// design units plus device table
		{
			otlDeviceBaseCoord deviceBaseline = otlDeviceBaseCoord(pbTable);
			otlDeviceTable deviceTable = deviceBaseline.deviceTable();
			if (metr.layout == otlRunLTR || 
				metr.layout == otlRunRTL)
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmY, 
							(long)deviceBaseline.coordinate()) +
							deviceTable.value(metr.cPPEmY);
			}
			else
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmX, 
							(long)deviceBaseline.coordinate()) +
							deviceTable.value(metr.cPPEmX);
			}
		}
	
	default:	// invalid format
		assert(false);
		return (0);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\chaining.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CHAINING.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with chaining context based lookups.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetChainBacktrackGlyphCount  = 0;
const OFFSET offsetChainBacktrackGlyphArray = 2;

class otlChainRuleTable: otlTable
{
	OFFSET offsetChainInputGlyphCount;
	OFFSET offsetChainInputGlyphArray;
	OFFSET offsetChainLookaheadGlyphCount;
	OFFSET offsetChainLookaheadGlyphArray;
	OFFSET offsetChainLookupCount;
	OFFSET offsetChainLookupRecords;


public:

//	USHORT backtrackGlyphCount() const;
//	USHORT inputGlyphCount() const;
//	USHORT lookaheadGlyphCount() const;

	otlChainRuleTable(const BYTE* pb): otlTable(pb) 
	{
	
		offsetChainInputGlyphCount = offsetChainBacktrackGlyphArray 
			   + backtrackGlyphCount() * sizeof(otlGlyphID);
		offsetChainInputGlyphArray = 
				offsetChainInputGlyphCount + sizeof(USHORT);
		offsetChainLookaheadGlyphCount = offsetChainInputGlyphArray 
			   + (inputGlyphCount() - 1) * sizeof(otlGlyphID); 
		offsetChainLookaheadGlyphArray = 
				offsetChainLookaheadGlyphCount + sizeof(USHORT);
		offsetChainLookupCount = offsetChainLookaheadGlyphArray 
			   + lookaheadGlyphCount() * sizeof(otlGlyphID);
		offsetChainLookupRecords = 
				offsetChainLookupCount + sizeof(USHORT);
	}

	
	USHORT backtrackGlyphCount() const
	{	return UShort(pbTable + offsetChainBacktrackGlyphCount); }

	USHORT inputGlyphCount() const
	{	return UShort(pbTable + offsetChainInputGlyphCount); }

	USHORT lookaheadGlyphCount() const
	{	return UShort(pbTable + offsetChainLookaheadGlyphCount); }

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetChainLookupCount); }

	otlGlyphID backtrack(USHORT index) const
	{	assert(index < backtrackGlyphCount());
		return GlyphID(pbTable + offsetChainBacktrackGlyphArray 
							   + index * sizeof(otlGlyphID)); 
	}
	
	otlGlyphID input(USHORT index) const
	{	assert(index < inputGlyphCount());
		assert(index > 0);
		return GlyphID(pbTable + offsetChainInputGlyphArray 
							   + (index - 1)* sizeof(otlGlyphID)); 
	}

	otlGlyphID lookahead(USHORT index) const
	{	assert(index < lookaheadGlyphCount());
		return GlyphID(pbTable + offsetChainLookaheadGlyphArray 
							   + index * sizeof(otlGlyphID)); 
	}

	otlList lookupRecords() const
	{	return otlList((void*)(pbTable + offsetChainLookupRecords),
						sizeContextLookupRecord, lookupCount(), lookupCount());
	}
};


const OFFSET offsetChainRuleCount = 0;
const OFFSET offsetChainRuleArray = 2;

class otlChainRuleSetTable: otlTable
{
public:
	otlChainRuleSetTable(const BYTE* pb): otlTable(pb) {}

	USHORT ruleCount() const
	{	return UShort(pbTable + offsetChainRuleCount); }

	otlChainRuleTable rule(USHORT index) const
	{	assert(index < ruleCount());
		return otlChainRuleTable(pbTable + 
			Offset(pbTable + offsetChainRuleArray + index * sizeof(OFFSET)));
	}
};
													

const OFFSET offsetChainCoverage = 2;
const OFFSET offsetChainRuleSetCount = 4;
const OFFSET offsetChainRuleSetArray =6;

class otlChainSubTable: otlLookupFormat
{
public:
	otlChainSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage() const
	{	return otlCoverage(pbTable + Offset(pbTable + offsetChainCoverage)); }

	USHORT ruleSetCount() const
	{	return UShort(pbTable + offsetChainRuleSetCount); }

	otlChainRuleSetTable ruleSet(USHORT index) const
	{	assert(index < ruleSetCount());
		return otlChainRuleSetTable(pbTable +
			Offset(pbTable + offsetChainRuleSetArray + index * sizeof(OFFSET)));
	}
};



const OFFSET offsetChainBacktrackClassCount = 0;
const OFFSET offsetChainBacktrackClassArray = 2;

class otlChainClassRuleTable: otlTable
{
	OFFSET offsetChainInputClassCount;
	OFFSET offsetChainInputClassArray;
	OFFSET offsetChainLookaheadClassCount;
	OFFSET offsetChainLookaheadClassArray;
	OFFSET offsetChainLookupCount;
	OFFSET offsetChainLookupRecords;

public:
//	USHORT backtrackClassCount() const;
//	USHORT inputClassCount() const;
//	USHORT lookaheadClassCount() const;

	otlChainClassRuleTable(const BYTE* pb): otlTable(pb) 
	{
		offsetChainInputClassCount = offsetChainBacktrackGlyphArray 
			   + backtrackClassCount() * sizeof(USHORT);
		offsetChainInputClassArray = 
				offsetChainInputClassCount + sizeof(USHORT); 
		offsetChainLookaheadClassCount = offsetChainInputClassArray 
			   + (inputClassCount() - 1) * sizeof(USHORT);
		offsetChainLookaheadClassArray =
				offsetChainLookaheadClassCount + sizeof(USHORT);
		offsetChainLookupCount = offsetChainLookaheadClassArray 
			   + lookaheadClassCount() * sizeof(USHORT);
		offsetChainLookupRecords = 
				offsetChainLookupCount + sizeof(USHORT);
	}

	
	USHORT backtrackClassCount() const
	{	return UShort(pbTable + offsetChainBacktrackClassCount); }

	USHORT inputClassCount() const
	{	return UShort(pbTable + offsetChainInputClassCount); }

	USHORT lookaheadClassCount() const
	{	return UShort(pbTable + offsetChainLookaheadClassCount); }

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetChainLookupCount); }

	USHORT backtrackClass(USHORT index) const
	{	assert(index < backtrackClassCount());
		return GlyphID(pbTable + offsetChainBacktrackClassArray 
							   + index * sizeof(USHORT)); 
	}
	
	USHORT inputClass(USHORT index) const
	{	assert(index < inputClassCount());
		assert(index > 0);
		return GlyphID(pbTable + offsetChainInputClassArray 
							   + (index - 1)* sizeof(USHORT)); 
	}

	USHORT lookaheadClass(USHORT index) const
	{	assert(index < lookaheadClassCount());
		return GlyphID(pbTable + offsetChainLookaheadClassArray 
							   + index * sizeof(USHORT)); 
	}

	otlList lookupRecords() const
	{	return otlList((void*)(pbTable + offsetChainLookupRecords),
						sizeContextLookupRecord, lookupCount(), lookupCount());
	}
};


const OFFSET offsetChainClassRuleCount = 0;
const OFFSET offsetChainClassRuleArray = 2;

class otlChainClassRuleSetTable: public otlTable
{
public:
	otlChainClassRuleSetTable(const BYTE* pb): otlTable(pb) {}

	USHORT ruleCount() const
	{	return UShort(pbTable + offsetChainClassRuleCount); }

	otlChainClassRuleTable rule(USHORT index) const
	{	assert(index < ruleCount());
		return otlChainClassRuleTable(pbTable + 
			Offset(pbTable + offsetChainClassRuleArray 
						   + index * sizeof(OFFSET)));
	}
};
													

const OFFSET offsetChainClassCoverage = 2;
const OFFSET offsetChainBacktrackClassDef = 4;
const OFFSET offsetChainInputClassDef = 6;
const OFFSET offsetChainLookaheadClassDef = 8;
const OFFSET offsetChainClassRuleSetCount = 10;
const OFFSET offsetChainClassRuleSetArray = 12;

class otlChainClassSubTable: otlLookupFormat
{
public:
	otlChainClassSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 2);
	}

	otlCoverage coverage() const
	{	return otlCoverage(pbTable 
					+ Offset(pbTable + offsetChainClassCoverage)); 
	}

	otlClassDef backtrackClassDef() const
	{	return otlClassDef(pbTable 
					+ Offset(pbTable + offsetChainBacktrackClassDef)); 
	}
	
	otlClassDef inputClassDef() const
	{	return otlClassDef(pbTable 
					+ Offset(pbTable + offsetChainInputClassDef)); 
	}
	
	otlClassDef lookaheadClassDef() const
	{	return otlClassDef(pbTable 
					+ Offset(pbTable + offsetChainLookaheadClassDef)); 
	}

	USHORT ruleSetCount() const
	{	return UShort(pbTable + offsetChainClassRuleSetCount); }

	otlChainClassRuleSetTable ruleSet(USHORT index) const
	{	assert(index < ruleSetCount());

		USHORT offset = 
			Offset(pbTable + offsetChainClassRuleSetArray 
						   + index * sizeof(OFFSET));
		if (offset == 0)
			return otlChainClassRuleSetTable((const BYTE*)NULL);

		return otlChainClassRuleSetTable(pbTable + offset);
	}
};
	


const OFFSET offsetChainBacktrackCoverageCount = 2;
const OFFSET offsetChainBacktrackCoverageArray = 4;

class otlChainCoverageSubTable: otlLookupFormat
{
	OFFSET offsetChainInputCoverageCount;
	OFFSET offsetChainInputCoverageArray;
	OFFSET offsetChainLookaheadCoverageCount;
	OFFSET offsetChainLookaheadCoverageArray;
	OFFSET offsetChainLookupCount;
	OFFSET offsetChainLookupRecords;

public:

//	USHORT backtrackCoverageCount() const;
//	USHORT inputCoverageCount() const;
//	USHORT lookaheadCoverageCount() const;

	otlChainCoverageSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 3);

		offsetChainInputCoverageCount = offsetChainBacktrackCoverageArray 
			   + backtrackCoverageCount() * sizeof(OFFSET);
		offsetChainInputCoverageArray = 
				offsetChainInputCoverageCount + sizeof(USHORT);
		offsetChainLookaheadCoverageCount = offsetChainInputCoverageArray 
			   + inputCoverageCount() * sizeof(OFFSET);
		offsetChainLookaheadCoverageArray = 
				offsetChainLookaheadCoverageCount + sizeof(USHORT);
		offsetChainLookupCount = offsetChainLookaheadCoverageArray 
			   + lookaheadCoverageCount() * sizeof(OFFSET); 
		offsetChainLookupRecords = 
				offsetChainLookupCount + sizeof(USHORT);
	}

	
	USHORT backtrackCoverageCount() const
	{	return UShort(pbTable + offsetChainBacktrackCoverageCount); }

	USHORT inputCoverageCount() const
	{	return UShort(pbTable + offsetChainInputCoverageCount); }

	USHORT lookaheadCoverageCount() const
	{	return UShort(pbTable + offsetChainLookaheadCoverageCount); }

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetChainLookupCount); }

	otlCoverage backtrackCoverage(USHORT index) const
	{	assert(index < backtrackCoverageCount());
		return otlCoverage(pbTable + 
			Offset(pbTable + offsetChainBacktrackCoverageArray 
							+ index * sizeof(OFFSET))); 
	}
	
	otlCoverage inputCoverage(USHORT index) const
	{	assert(index < inputCoverageCount());
		return otlCoverage(pbTable +  
			Offset(pbTable + offsetChainInputCoverageArray
							   + index* sizeof(OFFSET))); 
	}

	otlCoverage lookaheadCoverage(USHORT index) const
	{	assert(index < lookaheadCoverageCount());
		return otlCoverage(pbTable + 
			Offset(pbTable + offsetChainLookaheadCoverageArray 
							   + index * sizeof(OFFSET))); 
	}

	otlList lookupRecords() const
	{	return otlList((void*)(pbTable + offsetChainLookupRecords),
						sizeContextLookupRecord, lookupCount(), lookupCount());
	}
};


class otlChainingLookup: otlLookupFormat
{
public:
	otlChainingLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) {}
	
	otlErrCode apply
	(
		otlTag						tagTable,
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,
		long						lParameter,
        USHORT                      nesting,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\context.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CONTEXT.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with context-based substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode applyContextLookups
(
		const otlList&				liLookupRecords,
 
		otlTag						tagTable,			// GSUB/GPOS
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,
		long						lParameter,
        USHORT                      nesting,
		
		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,			// assert null for GSUB
		otlList*					pliplcGlyphPlacement,	// assert null for GSUB

		USHORT						iglFirst,		
		USHORT						iglAfterLast,	

		USHORT*						piglNext

)
{
    if (nesting > OTL_CONTEXT_NESTING_LIMIT) return OTL_ERR_CONTEXT_NESTING_TOO_DEEP;

	otlLookupListTable lookupList = otlLookupListTable((const BYTE*)NULL);

	otlErrCode erc;
	erc =  GetScriptFeatureLookupLists(tagTable, resourceMgr, 
										(otlScriptListTable*)NULL, 
										(otlFeatureListTable*)NULL, 
										&lookupList);
	if (erc != OTL_SUCCESS) return erc;

	// get GDEF
	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

	USHORT cLookups = liLookupRecords.length();

	short iCurLookup   = -1;
	short iCurSeqIndex = -1;

	for (USHORT i = 0; i < cLookups; ++i)
	{
		USHORT iListIndex = MAXUSHORT;
		USHORT iSeqIndex  = MAXUSHORT;
		// get the next lookup index
		for (USHORT iLookup = 0; iLookup < cLookups; ++iLookup)
		{
			otlContextLookupRecord lookupRecord = 
				otlContextLookupRecord(liLookupRecords.readAt(iLookup));

			if ((lookupRecord.lookupListIndex() < iListIndex && 
				 lookupRecord.lookupListIndex() > iCurLookup
				) ||
				(lookupRecord.lookupListIndex() == iCurLookup && 
				 lookupRecord.sequenceIndex() < iSeqIndex &&
				 lookupRecord.sequenceIndex() > iCurSeqIndex
				)
			   )
			{
				iListIndex = lookupRecord.lookupListIndex();
				iSeqIndex = lookupRecord.sequenceIndex();
			}
		}

		assert(iListIndex < MAXUSHORT);
		if (iListIndex == MAXUSHORT) return OTL_ERR_BAD_FONT_TABLE;

		iCurLookup   = iListIndex;
		iCurSeqIndex = iSeqIndex;

		otlLookupTable lookupTable = lookupList.lookup(iCurLookup);

		USHORT iglLookupStart = iglFirst;
		for (USHORT iSeq = 0; iSeq < iSeqIndex && iglLookupStart < iglAfterLast; 
					++iSeq)
		{
			iglLookupStart = NextGlyphInLookup(pliGlyphInfo,  
											   grfLookupFlags, gdef, 
											   iglLookupStart + 1, otlForward);
		}

		if (iglLookupStart < iglAfterLast)
		{
			USHORT iglAfterLastReliable = pliGlyphInfo->length() - iglAfterLast;
			USHORT dummy;
			erc = ApplyLookup(tagTable, 
							  pliCharMap, pliGlyphInfo, resourceMgr,
							  lookupTable, lParameter, nesting+1,
							  metr, pliduGlyphAdv, pliplcGlyphPlacement, 
							  iglLookupStart, iglAfterLast, &dummy);
			if (ERRORLEVEL(erc) > 0) return erc;

			iglAfterLast = pliGlyphInfo->length() - iglAfterLastReliable;
		}
	}

	*piglNext = iglAfterLast;
	return OTL_SUCCESS;

}
	
otlErrCode otlContextLookup::apply
(
	otlTag						tagTable,
	otlList*					pliCharMap,
	otlList*					pliGlyphInfo,
	otlResourceMgr&				resourceMgr,

	USHORT						grfLookupFlags,
	long						lParameter,
    USHORT                      nesting,

	const otlMetrics&			metr,		
	otlList*					pliduGlyphAdv,				
	otlList*					pliplcGlyphPlacement,		

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);

	switch(format())
	{
	case(1):	// simple
		{
			otlContextSubTable simpleContext = otlContextSubTable(pbTable);
			short index = simpleContext.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			if (index >= simpleContext.ruleSetCount())
			{
				assert(false); // bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}
			otlContextRuleSetTable ruleSet = simpleContext.ruleSet(index);

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			// start checking contextes
			USHORT cRules = ruleSet.ruleCount();
			bool match = false;
			for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
			{
				otlContextRuleTable rule = ruleSet.rule(iRule);
				const USHORT cInputGlyphs = rule.glyphCount();

                // a simple check so we don't waste time
                if (iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

				USHORT igl = iglIndex;
				match = true;
				for (USHORT iGlyph = 1; 
							iGlyph < cInputGlyphs && match; ++iGlyph)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, 
											grfLookupFlags, gdef, 
											igl + 1, otlForward);

					if (igl >= iglAfterLast ||
						getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
						  rule.input(iGlyph))
					{
						match = false;
					}
				}

				if (match)
				{
					*piglNextGlyph = NextGlyphInLookup(pliGlyphInfo,  
														grfLookupFlags, gdef, 
														igl + 1, otlForward);

					return applyContextLookups 
							   (rule.lookupRecords(),
								tagTable, 
								pliCharMap, pliGlyphInfo, resourceMgr,
								grfLookupFlags, lParameter, nesting,
								metr, pliduGlyphAdv, pliplcGlyphPlacement,
								iglIndex, *piglNextGlyph, piglNextGlyph);
				}
			}

			return OTL_NOMATCH;
		}

	case(2):	// class-based
		{
			otlContextClassSubTable classContext = 
						otlContextClassSubTable(pbTable);
			short index = classContext.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			otlClassDef classDef =  classContext.classDef();
			USHORT indexClass = classDef.getClass(pGlyphInfo->glyph);

			if (indexClass >= classContext.ruleSetCount())
			{
				assert(false); // bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}
			otlContextClassRuleSetTable ruleSet = 
						classContext.ruleSet(indexClass);

			if (ruleSet.isNull())
			{
				return OTL_NOMATCH;
			}

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			// start checking contextes
			USHORT cRules = ruleSet.ruleCount();
			bool match = false;
			for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
			{
				otlContextClassRuleTable rule = ruleSet.rule(iRule);
				USHORT cInputGlyphs = rule.classCount();

                // a simple check so we don't waste time
                if (iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

				USHORT igl = iglIndex;
				match = true;
				for (USHORT iGlyph = 1; 
							iGlyph < cInputGlyphs && match; ++iGlyph)
				{
					igl = NextGlyphInLookup(pliGlyphInfo, 
											grfLookupFlags, gdef, 
											igl + 1, otlForward);

					if (igl >= iglAfterLast || 
						classDef.getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph)
						!= rule.inputClass(iGlyph))
					{
						match = false;
					}
				}

				if (match)
				{
					*piglNextGlyph = NextGlyphInLookup(pliGlyphInfo,  
														grfLookupFlags, gdef, 
														igl + 1, otlForward);

					return applyContextLookups 
								   (rule.lookupRecords(),
									tagTable, 
									pliCharMap, pliGlyphInfo, resourceMgr,
									grfLookupFlags, lParameter, nesting,
									metr, pliduGlyphAdv, pliplcGlyphPlacement,	
									iglIndex,*piglNextGlyph, piglNextGlyph);
				}
			}

			return OTL_NOMATCH;
		}
	case(3):	// coverage-based
		{
			otlContextCoverageSubTable coverageContext = 
							otlContextCoverageSubTable(pbTable);
			
			bool match = true;

			USHORT cInputGlyphs = coverageContext.glyphCount();

            // a simple check so we don't waste time
            if (iglIndex + cInputGlyphs > iglAfterLast)
            {
                match = false;
            }

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			USHORT igl = iglIndex;
			for (USHORT iGlyph = 0; 
						iGlyph < cInputGlyphs && match; ++iGlyph)
			{
				if (igl >= iglAfterLast || coverageContext.coverage(iGlyph)
					.getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph) < 0)
				{
					match = false;
				}
				else
				{
					igl = NextGlyphInLookup(pliGlyphInfo, 
											grfLookupFlags, gdef, 
											igl + 1, otlForward);
				}
			}

			if (match)
			{
				return applyContextLookups 
							   (coverageContext.lookupRecords(),
								tagTable, 
								pliCharMap, pliGlyphInfo, resourceMgr,
								grfLookupFlags, lParameter, nesting,
								metr, pliduGlyphAdv, pliplcGlyphPlacement,
								iglIndex, igl, piglNextGlyph);
			}

			return OTL_NOMATCH;
		}

	default:
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\coverage.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  COVERAGE.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of coverage tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// REVIEW (PERF): it's used a lot - optimize!

short otlCoverage::getIndex(otlGlyphID glyph) const
{
	switch (format())
	{
	case(1):	// individual glyph coverage
		{
			otlIndividualGlyphCoverageTable individualCoverage = 
				            otlIndividualGlyphCoverageTable(pbTable);
            
   #ifdef _DEBUG            
            // in debug mode, check that the coverage is sorted
            for (USHORT i = 0; i < individualCoverage.glyphCount() - 1; ++i)
            {
                assert(individualCoverage.glyph(i) < individualCoverage.glyph(i + 1));
            }
   #endif
   
            USHORT iLow = 0;
            // always beyond the upper bound
            USHORT iHigh = individualCoverage.glyphCount();  
            while(iLow < iHigh)
            {
                USHORT iMiddle = (iLow + iHigh) >> 1;
                otlGlyphID glyphMiddle = individualCoverage.glyph(iMiddle);
                if (glyph < glyphMiddle) 
                {
                    iHigh = iMiddle;
                }
                else if (glyphMiddle < glyph)
                {
                    iLow = iMiddle + 1;
                }
                else
                {
                    return iMiddle;
                }            
            } 

            return  -1;
        }

	case(2):	// range coverage
		{
			otlRangeCoverageTable rangeCoverage = 
				        otlRangeCoverageTable(pbTable);

   #ifdef _DEBUG
            // in debug mode, check that the coverage is sorted
            for (USHORT i = 0; i < rangeCoverage.rangeCount() - 1; ++i)
            {
                assert(rangeCoverage.rangeRecord(i).start() 
                       < rangeCoverage.rangeRecord(i + 1).start());
            }
   #endif

            USHORT iLowRange = 0;
            // always beyond the upper bound
            USHORT iHighRange = rangeCoverage.rangeCount(); 
            while(iLowRange < iHighRange)
            {
                USHORT iMiddleRange = (iLowRange + iHighRange) >> 1;
				otlRangeRecord range = rangeCoverage.rangeRecord(iMiddleRange);
                if (glyph < range.start()) 
                {
                    iHighRange = iMiddleRange;
                }
                else if (range.end() < glyph)
                {
                    iLowRange = iMiddleRange + 1;
                }
                else
                {
                    return glyph - range.start() + range.startCoverageIndex();
                }            
            } 

            return  -1;
        }
    }

    // default: invalid format
    assert(false);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\common.inl ===
/***********************************************************************
************************************************************************
*
*                    ********  COMMON.INL  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals OTL most common functions
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

/***********************************************************************/

/*  Read one Glyph ID (unsigned 16 bits) from the big endian table     */

inline OTL_PUBLIC otlGlyphID GlyphID(const BYTE* pbTable )
{
	return (((otlGlyphID)pbTable[0] << 8) + (otlGlyphID)pbTable[1]);
}

/***********************************************************************/

/*  Read one unsigned 16 bit value from the big endian table           */

inline OTL_PUBLIC USHORT UShort(const BYTE* pbTable )
{
	return (((USHORT)pbTable[0] << 8) + (USHORT)pbTable[1]);
}

/***********************************************************************/
/*  Read one unsigned 16 bit offset from the big endian table           */

inline OTL_PUBLIC USHORT Offset(const BYTE* pbTable )
{
	return UShort(pbTable);
}

/***********************************************************************/

/*  Read one unsigned 16 bit value from the big endian table           */

inline OTL_PUBLIC short SShort(const BYTE* pbTable )
{
	return (short)(((USHORT)pbTable[0] << 8) + (USHORT)pbTable[1]);
}

/***********************************************************************/

/*  Read one unsigned 32 bit value from the big endian table           */

inline OTL_PUBLIC ULONG ULong(const BYTE* pbTable )
{
	return (((ULONG)pbTable[0] << 24) + ((ULONG)pbTable[1] << 16) + 
			((ULONG)pbTable[2] << 8) + (ULONG)pbTable[3] );
}

/***********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\common.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  COMMON.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements common helper functions 
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/

USHORT NextCharInLiga
(
	const otlList*		pliCharMap,
	USHORT				iChar
)
{
	USHORT len = pliCharMap->length();
	USHORT iGlyph = readOtlGlyphIndex(pliCharMap, iChar);

	for(USHORT ich = iChar + 1; ich < len; ++ich)
	{
		if (readOtlGlyphIndex(pliCharMap, ich) == iGlyph)
		{
			return ich;
		}
	}

	assert(false);
	return len;
}

// REVIEW:	review handling iGlyph indices -- 
//			what we do here is very far from optimal


void InsertGlyphs
(
	otlList*			pliCharMap,
	otlList*			pliGlyphInfo,
	USHORT				iGlyph,
	USHORT				cHowMany
)
{
	if (cHowMany == 0) return;

	pliGlyphInfo->insertAt(iGlyph, cHowMany);

	for (USHORT ich = 0; ich < pliCharMap->length(); ++ich)
	{
		USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, ich);
		if (*piGlyph >= iGlyph)
		{
			*piGlyph += cHowMany;
		}
	}
}

void DeleteGlyphs
(
	otlList*			pliCharMap,
	otlList*			pliGlyphInfo,
	USHORT				iGlyph,
	USHORT				cHowMany
)
{
	if (cHowMany == 0) return;

	pliGlyphInfo->deleteAt(iGlyph, cHowMany);

	for (USHORT ich = 0; ich < pliCharMap->length(); ++ich)
	{
		USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, ich);
		if (*piGlyph >= iGlyph + cHowMany)
		{
			*piGlyph -= cHowMany;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\common.h ===
/***********************************************************************
************************************************************************
*
*                    ********  COMMON.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL common table formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/
#define     MAX(x,y)    ((x) > (y) ? (x) : (y))
#define     MIN(x,y)    ((x) > (y) ? (y) : (x))

const unsigned short MAXUSHORT = 0xFFFF;

#ifndef     OFFSET
#define     OFFSET  unsigned short
#endif


// (from ntdef.h)
#ifndef     UNALIGNED
#if defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif


inline OTL_PUBLIC otlGlyphID GlyphID( const BYTE* pbTable);
inline OTL_PUBLIC OFFSET Offset( const BYTE* pbTable);
inline OTL_PUBLIC USHORT UShort( const BYTE* pbTable);
inline OTL_PUBLIC short SShort( const BYTE* pbTable);
inline OTL_PUBLIC ULONG ULong( const BYTE* pbTable);

class otlTable
{
protected:

    const BYTE* pbTable;

    otlTable(const BYTE* pb)
        : pbTable(pb)
    {
    }

private:

    // new not allowed
    void* operator new(size_t size);

public:

    otlTable& operator = (const otlTable& copy)
    {
        pbTable = copy.pbTable;
        return *this;
    }

    bool isNull() const
    {
        return (pbTable == (const BYTE*)NULL);
    }

};


USHORT NextCharInLiga
(
    const otlList*      pliCharMap,
    USHORT              iChar
);

void InsertGlyphs
(
    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    USHORT              iGlyph,
    USHORT              cHowMany
);

void DeleteGlyphs
(
    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    USHORT              iGlyph,
    USHORT              cHowMany
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\classdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CLASSDEF.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of ClassDef tables
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetClassDefFormat = 0;

const OFFSET offsetStartClassGlyph = 2;
const OFFSET offsetClassGlyphCount = 4;
const OFFSET offsetClassValueArray = 6;

class otlClassArrayTable: public otlTable
{
public:

	otlClassArrayTable(const BYTE* pb): otlTable(pb) 
	{
		assert(format() == 1);
	}

	USHORT format() const
	{	return UShort(pbTable + offsetClassDefFormat); }

	otlGlyphID startGlyph() const 
	{	return GlyphID(pbTable + offsetStartClassGlyph); }

	USHORT glyphCount() const
	{	return UShort(pbTable + offsetClassGlyphCount); }

	USHORT classValue(USHORT index) const
	{	assert(index < glyphCount());
		return UShort(pbTable + offsetClassValueArray + index*sizeof(USHORT)); }

};


const OFFSET offsetClassRangeStart = 0;
const OFFSET offsetClassRangeEnd = 2;
const OFFSET offsetClass = 4;

class otlClassRangeRecord: public otlTable
{
public:

	otlClassRangeRecord(const BYTE* pb): otlTable(pb) {}

	otlGlyphID start() const
	{	return UShort(pbTable + offsetClassRangeStart); }

	otlGlyphID end() const
	{	return UShort(pbTable + offsetClassRangeEnd); }

	USHORT getClass() const
	{	return UShort(pbTable + offsetClass); }
};


const OFFSET offsetClassRangeCount = 2;
const OFFSET offsetClassRangeRecordArray = 4;
const USHORT sizeClassRangeRecord = 6;

class otlClassRangesTable: public otlTable
{
public:

	otlClassRangesTable(const BYTE* pb): otlTable(pb) 
	{
		assert(format() == 2);
	}

	USHORT format() const
	{	return UShort(pbTable + offsetClassDefFormat); }

	USHORT classRangeCount() const
	{	return UShort(pbTable + offsetClassRangeCount); }

	otlClassRangeRecord classRangeRecord(USHORT index) const
	{	assert(index < classRangeCount());
		return otlClassRangeRecord(pbTable + offsetClassRangeRecordArray 
											  + index*sizeClassRangeRecord); }

};


class otlClassDef: public otlTable
{
public:

	otlClassDef(const BYTE* pb): otlTable(pb) {}

	USHORT format() const
	{	return UShort(pbTable + offsetClassDefFormat); }

	USHORT getClass(otlGlyphID glyph) const;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\context.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CONTEXT.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with context based lookups.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetContextSequenceIndex = 0;
const OFFSET offsetContextLookupIndex = 2;

class otlContextLookupRecord: otlTable
{
public:
	otlContextLookupRecord(const BYTE* pb): otlTable(pb) {}

	USHORT sequenceIndex() const
	{	return UShort(pbTable + offsetContextSequenceIndex); }

	USHORT lookupListIndex() const
	{	return UShort(pbTable + offsetContextLookupIndex); }
};


const OFFSET offsetContextGlyphCount  = 0;
const OFFSET offsetContextLookupRecordCount = 2;
const OFFSET offsetContextInput = 4;
const USHORT sizeContextLookupRecord = 4;

class otlContextRuleTable: otlTable
{
public:
	otlContextRuleTable(const BYTE* pb): otlTable(pb) {}

	USHORT glyphCount() const
	{	return UShort(pbTable + offsetContextGlyphCount); }

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetContextLookupRecordCount); }

	otlGlyphID input(USHORT index) const
	{	assert(index < glyphCount());
		assert(index > 0);
		return GlyphID(pbTable + offsetContextInput 
							   + (index - 1)* sizeof(otlGlyphID)); 
	}

	otlList lookupRecords() const
	{	return otlList((void*)(pbTable + offsetContextInput 
									   + (glyphCount() - 1) * sizeof(otlGlyphID)),
						sizeContextLookupRecord, lookupCount(), lookupCount());
	}
};


const OFFSET offsetContextRuleCount = 0;
const OFFSET offsetContextRuleArray = 2;

class otlContextRuleSetTable: otlTable
{
public:
	otlContextRuleSetTable(const BYTE* pb): otlTable(pb) {}

	USHORT ruleCount() const
	{	return UShort(pbTable + offsetContextRuleCount); }

	otlContextRuleTable rule(USHORT index) const
	{	assert(index < ruleCount());
		return otlContextRuleTable(pbTable + 
			Offset(pbTable + offsetContextRuleArray + index * sizeof(OFFSET)));
	}
};
													

const OFFSET offsetContextCoverage = 2;
const OFFSET offsetContextRuleSetCount = 4;
const OFFSET offsetContextRuleSetArray =6;

class otlContextSubTable: otlLookupFormat
{
public:
	otlContextSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage() const
	{	return otlCoverage(pbTable + Offset(pbTable + offsetContextCoverage)); }

	USHORT ruleSetCount() const
	{	return UShort(pbTable + offsetContextRuleSetCount); }

	otlContextRuleSetTable ruleSet(USHORT index) const
	{	assert(index < ruleSetCount());
		return otlContextRuleSetTable(pbTable +
			Offset(pbTable + offsetContextRuleSetArray + index * sizeof(OFFSET)));
	}
};



const OFFSET offsetContextClassCount = 0;
const OFFSET offsetContextClassLookupRecordCount = 2;
const OFFSET offsetContextClassInput = 4;

class otlContextClassRuleTable: otlTable
{
public:
	otlContextClassRuleTable(const BYTE* pb): otlTable(pb) {}

	USHORT classCount() const
	{	return UShort(pbTable + offsetContextClassCount); }

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetContextClassLookupRecordCount); }

	USHORT inputClass(USHORT index) const
	{	assert(index < classCount());
		assert(index > 0);
		return GlyphID(pbTable + offsetContextClassInput 
							   + (index - 1) * sizeof(USHORT)); 
	}

	otlList lookupRecords() const
	{	return otlList((void*)(pbTable + offsetContextClassInput 
									   + (classCount() - 1) * sizeof(USHORT)),
						sizeContextLookupRecord, lookupCount(), lookupCount());
	}
};


const OFFSET offsetContextClassRuleCount = 0;
const OFFSET offsetContextClassRuleArray = 2;

class otlContextClassRuleSetTable: public otlTable
{
public:
	otlContextClassRuleSetTable(const BYTE* pb): otlTable(pb) {}

	USHORT ruleCount() const
	{	return UShort(pbTable + offsetContextClassRuleCount); }

	otlContextClassRuleTable rule(USHORT index) const
	{	assert(index < ruleCount());
		return otlContextClassRuleTable(pbTable + 
			Offset(pbTable + offsetContextClassRuleArray 
						   + index * sizeof(OFFSET)));
	}
};
													

const OFFSET offsetContextClassCoverage = 2;
const OFFSET offsetContextClassDef = 4;
const OFFSET offsetContextClassRuleSetCount = 6;
const OFFSET offsetContextClassRuleSetArray =8;

class otlContextClassSubTable: otlLookupFormat
{
public:
	otlContextClassSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 2);
	}

	otlCoverage coverage() const
	{	return otlCoverage(pbTable 
					+ Offset(pbTable + offsetContextClassCoverage)); 
	}

	otlClassDef classDef() const
	{	return otlClassDef(pbTable 
					+ Offset(pbTable + offsetContextClassDef)); }

	USHORT ruleSetCount() const
	{	return UShort(pbTable + offsetContextClassRuleSetCount); }

	otlContextClassRuleSetTable ruleSet(USHORT index) const
	{	assert(index < ruleSetCount());

		USHORT offset = 
			Offset(pbTable + offsetContextClassRuleSetArray 
						   + index * sizeof(OFFSET));
		if (offset == 0)
			return otlContextClassRuleSetTable((const BYTE*)NULL);

		return otlContextClassRuleSetTable(pbTable + offset);
	}
};
	


const OFFSET offsetContextCoverageGlyphCount = 2;
const OFFSET offsetContextCoverageLookupRecordCount = 4;
const OFFSET offsetContextCoverageArray = 6;

class otlContextCoverageSubTable: otlLookupFormat
{
public:
	otlContextCoverageSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 3);
	}

	USHORT glyphCount() const
	{	return UShort(pbTable + offsetContextCoverageGlyphCount); }

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetContextCoverageLookupRecordCount); }

	otlCoverage coverage(USHORT index) const
	{	assert(index < glyphCount());
		return otlCoverage(pbTable + 
			Offset(pbTable + offsetContextCoverageArray 
						   + index * sizeof(OFFSET)));
	}

	otlList lookupRecords() const
	{	return otlList((void*)(pbTable + offsetContextCoverageArray 
									   + glyphCount() * sizeof(OFFSET)),
						sizeContextLookupRecord, lookupCount(), lookupCount());
	}
};


class otlContextLookup: otlLookupFormat
{
public:
	otlContextLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) {}
	
	otlErrCode apply
	(
		otlTag						tagTable,
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,
		long						lParameter,
        USHORT                      nesting,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);

};

// helper functions

otlErrCode applyContextLookups
(
		const otlList&				liLookupRecords,
 
		otlTag						tagTable,			// GSUB/GPOS
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,
		long						lParameter,
        USHORT                      nesting,
		
		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,			// assert null for GSUB
		otlList*					pliplcGlyphPlacement,	// assert null for GSUB

		USHORT						iglFrist,			// where to apply it
		USHORT						iglAfterLast,		// how long a context we can use
		
		USHORT*						piglNext

);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\cursipos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CURSIPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with cursive attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// defenitions and helpers

// recording cursive attachment dependencies in glyph flags

#define     OTL_GFLAG_DEPPOS	0xFF00  // cursive attachment dependency offset
										// used to handle right-to-left attachment

USHORT getPosDependency(const otlList* pliGlyphInfo, USHORT from)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(from < pliGlyphInfo->length());

	const otlGlyphInfo* pGlyphInfoFrom = readOtlGlyphInfo(pliGlyphInfo, from);
	return from - ((pGlyphInfoFrom->grf & OTL_GFLAG_DEPPOS) >> 8);
}

void setPosDependency(otlList* pliGlyphInfo, USHORT from, USHORT to)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(from < pliGlyphInfo->length());
	assert(to < from);
	assert(from - to < 0x0100);

	otlGlyphInfo* pGlyphInfoFrom = getOtlGlyphInfo(pliGlyphInfo, from);
	pGlyphInfoFrom->grf &= ~OTL_GFLAG_DEPPOS;
	pGlyphInfoFrom->grf |= (from - to) << 8;
}

void AdjustCursiveDependents
(
	const otlList*		pliGlyphInfo,
	otlList*			pliPlacement,
	USHORT				igl,
	const otlPlacement& plcAfter,
	const otlPlacement& plcBefore
)
{
	USHORT iglPrev = getPosDependency(pliGlyphInfo, igl);
	if (iglPrev != igl)
	{
		otlPlacement* plc = getOtlPlacement(pliPlacement, iglPrev);

		plc->dx += plcAfter.dx - plcBefore.dx;
		plc->dy += plcAfter.dy - plcBefore.dy;

		AdjustCursiveDependents(pliGlyphInfo, pliPlacement, iglPrev, 
								plcAfter, plcBefore);
	}
}


otlErrCode otlCursivePosLookup::apply
(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo != NULL);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(pliduGlyphAdv != NULL);
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliplcGlyphPlacement != NULL);
	assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

	assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
	assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	assert(format() == 1);


	otlCursivePosSubTable cursiPos = otlCursivePosSubTable(pbTable);

	otlGlyphID glyph = getOtlGlyphInfo(pliGlyphInfo, iglIndex)->glyph;
	short index = cursiPos.coverage().getIndex(glyph);
	if (index < 0)
	{
		return OTL_NOMATCH;
	}

	if (index >= cursiPos.entryExitCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}

	// get GDEF
	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

	if ((grfLookupFlags & otlRightToLeft) == 0)
	{

		short iglPrev = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
										  iglIndex - 1, otlBackward);
		if (iglPrev < 0)
		{
			return OTL_NOMATCH;
		}

		otlGlyphID glPrev = getOtlGlyphInfo(pliGlyphInfo, iglPrev)->glyph;
		short indexPrev = cursiPos.coverage().getIndex(glPrev);
		if (indexPrev < 0)
		{
			return OTL_NOMATCH;
		}

		if (indexPrev >= cursiPos.entryExitCount())
		{
			assert(false);
			return OTL_ERR_BAD_FONT_TABLE;
		}


		otlAnchor anchorMain = cursiPos.entryAnchor(index);
		otlAnchor anchorPrev = cursiPos.exitAnchor(indexPrev);

		if (anchorMain.isNull() || anchorPrev.isNull())
		{
			return OTL_NOMATCH;
		}

		AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
					 iglPrev, iglIndex, anchorPrev, anchorMain, resourceMgr, 
					 metr, otlUseAdvances);

		// taking care of cursive dependencies
		setPosDependency(pliGlyphInfo, iglIndex, iglPrev);


		*piglNextGlyph = iglIndex + 1;
		return OTL_SUCCESS;

	}

	else
	{
		short iglNext = NextGlyphInLookup(pliGlyphInfo, 
										  grfLookupFlags, gdef, 
										  iglIndex + 1,	otlForward);
		if (iglNext >= iglAfterLast)
		{
			return OTL_NOMATCH;
		}

		otlGlyphID glNext = getOtlGlyphInfo(pliGlyphInfo, iglNext)->glyph;
		short indexNext = cursiPos.coverage().getIndex(glNext);
		if (indexNext < 0)
		{
			return OTL_NOMATCH;
		}

		if (indexNext >= cursiPos.entryExitCount())
		{
			assert(false);
			return OTL_ERR_BAD_FONT_TABLE;
		}


		otlAnchor anchorMain = cursiPos.exitAnchor(index);
		otlAnchor anchorNext = cursiPos.entryAnchor(indexNext);

		if (anchorMain.isNull() || anchorNext.isNull())
		{
			return OTL_NOMATCH;
		}

		otlPlacement plcBefore = *getOtlPlacement(pliplcGlyphPlacement, iglIndex);

		AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
					 iglNext, iglIndex, anchorNext, anchorMain, resourceMgr, 
					 metr, otlUseAdvances);

		
		// taking care of cursive dependencies:  
		// adjusting old ones, creating a new one
		AdjustCursiveDependents(pliGlyphInfo, pliplcGlyphPlacement, iglIndex, 
							   *getOtlPlacement(pliplcGlyphPlacement, iglIndex),
							    plcBefore);

		setPosDependency(pliGlyphInfo, iglNext, iglIndex);


		*piglNextGlyph = iglIndex + 1;
		return OTL_SUCCESS;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\device.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  DEVICE.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of device tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/
 
long otlDeviceTable::value(USHORT cPPEm) const
{
    long lDeltaValue;

    USHORT cppemStartSize = startSize();
    USHORT cppemEndSize = endSize();
    if ((cPPEm < cppemStartSize) || (cPPEm > cppemEndSize))
    {
        return 0;       /* quick return if outside the data range */
    }

    USHORT iSizeIndex = cPPEm - cppemStartSize;
	USHORT cwValueOffset, cbitShiftUp, cbitShiftDown;

    USHORT grfDeltaFormat = deltaFormat();

    switch (grfDeltaFormat)
    {
    case 1:             /* signed 2 bit value */
		{
			cwValueOffset = iSizeIndex >> 3;
			cbitShiftUp = (8 + (iSizeIndex & 0x0007)) << 1;
			cbitShiftDown = 30;
			break;
		}

    case 2:             /* signed 4 bit value */
		{
			cwValueOffset = iSizeIndex >> 2;
			cbitShiftUp = (4 + (iSizeIndex & 0x0003)) << 2;
			cbitShiftDown = 28;
			break;
		}

    case 3:             /* signed 8 bit value */
		{
			cwValueOffset = iSizeIndex >> 1;
			cbitShiftUp = (2 + (iSizeIndex & 0x0001)) << 3;
			cbitShiftDown = 24;
			break;
		}
    
    default:			/* unrecognized format */
		assert(false);
        return 0;      
    }
    
    lDeltaValue = (long)UShort((BYTE*)(deltaValueArray() + cwValueOffset));
    lDeltaValue <<= cbitShiftUp;          /* erase leading data */
    lDeltaValue >>= cbitShiftDown;        /* erase trailing data & sign extend */
    
    return lDeltaValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\device.h ===
/***********************************************************************
************************************************************************
*
*                    ********  DEVICE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL device table formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetStartSize = 0;
const OFFSET offsetEndSize = 2;
const OFFSET offsetDeltaFormat = 4;
const OFFSET offsetDeltaValues = 6;

class otlDeviceTable: public otlTable
{
private:

	USHORT startSize() const
	{	return UShort(pbTable + offsetStartSize); }

	USHORT endSize() const
	{	return UShort(pbTable + offsetEndSize); }

	USHORT deltaFormat() const
	{	return UShort(pbTable + offsetDeltaFormat); }

	USHORT* deltaValueArray() const
	{	return (USHORT*)(pbTable + offsetDeltaValues); }

public:

	otlDeviceTable(const BYTE* pb): otlTable(pb) {}

	long value(USHORT cPPEm) const;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\coverage.h ===
/***********************************************************************
************************************************************************
*
*                    ********  COVERAGE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of coverage tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetCoverageFormat = 0;

const OFFSET offsetGlyphCount = 2;
const OFFSET offsetGlyphArray = 4;

class otlIndividualGlyphCoverageTable: public otlTable
{
public:

	otlIndividualGlyphCoverageTable(const BYTE* pb): otlTable(pb) 
	{
		assert(format() == 1);
	}
	
	USHORT format()	const
	{	return UShort(pbTable + offsetCoverageFormat); }

	USHORT glyphCount() const
	{	return UShort(pbTable + offsetGlyphCount); }

	otlGlyphID glyph(USHORT index) const
	{	assert(index < glyphCount());
		return GlyphID(pbTable + offsetGlyphArray 
							   + index*sizeof(otlGlyphID)); }

};


const OFFSET offsetRangeStart = 0;
const OFFSET offsetRangeEnd = 2;
const OFFSET offsetStartCoverageIndex = 4;

class otlRangeRecord: public otlTable
{
public:

	otlRangeRecord(const BYTE* pb): otlTable(pb) {}

	otlGlyphID start() const
	{	return UShort(pbTable + offsetRangeStart); }

	otlGlyphID end() const
	{	return UShort(pbTable + offsetRangeEnd); }

	USHORT startCoverageIndex() const
	{	return UShort(pbTable + offsetStartCoverageIndex); }
};



const OFFSET offsetRangeCount = 2;
const OFFSET offsetRangeRecordArray = 4;
const USHORT sizeRangeRecord = 6;

class otlRangeCoverageTable: public otlTable
{
public:

	otlRangeCoverageTable(const BYTE* pb): otlTable(pb) 
	{
		assert(format() == 2);
	}
	
	USHORT format()	const
	{	return UShort(pbTable + offsetCoverageFormat); }

	USHORT rangeCount() const
	{	return UShort(pbTable + offsetRangeCount); }

	otlRangeRecord rangeRecord(USHORT index) const
	{	assert(index < rangeCount());
		return otlRangeRecord(pbTable + offsetRangeRecordArray 
											+ index*sizeRangeRecord); }
};


class otlCoverage: public otlTable
{
public:

	otlCoverage(const BYTE* pb): otlTable(pb) {}

	USHORT format()	const
	{	return UShort(pbTable + offsetCoverageFormat); }

	// returns -1 if glyph is not covered
	short getIndex(otlGlyphID glyph) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\cursipos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CURSIPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with cursive attachment lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetEntryAnchor = 0;
const OFFSET offsetExitAnchor = 2;

const OFFSET offsetCursiveCoverage = 2;
const OFFSET offsetEntryExitCount = 4;
const OFFSET offsetEntryExitRecordArray = 6;
const USHORT sizeEntryExitRecord = 8;

class otlCursivePosSubTable: otlLookupFormat
{
public:
	otlCursivePosSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetCursiveCoverage)); }

	USHORT entryExitCount()
	{	return UShort(pbTable + offsetEntryExitCount); }

	otlAnchor entryAnchor(USHORT index)
	{	
		assert(index < entryExitCount());
		OFFSET offset = Offset(pbTable + offsetEntryExitRecordArray
									   + index * (sizeof(OFFSET) + sizeof(OFFSET))
									   + offsetEntryAnchor);
		if (offset == 0)
			return otlAnchor((const BYTE*)NULL);
		
		return otlAnchor(pbTable + offset); 
	}

	otlAnchor exitAnchor(USHORT index)
	{	
		assert(index < entryExitCount());
		OFFSET offset = Offset(pbTable + offsetEntryExitRecordArray
									   + index * (sizeof(OFFSET) + sizeof(OFFSET))
									   + offsetExitAnchor);
		if (offset == 0)
			return otlAnchor((const BYTE*)NULL);
		
		return otlAnchor(pbTable + offset); 
	}
};


class otlCursivePosLookup: otlLookupFormat
{
public:
	otlCursivePosLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) {}

	otlErrCode apply
	(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);												// return: did/did not apply

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\extension.h ===
/***********************************************************************
************************************************************************
*
*                    ********  EXTENSION.H  ********
*
*              Open Type Layout Services Library Header File
*
*               This module deals with Extension lookup type.
*
*               Copyright 1997 - 2000. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetExtensionLookupType = 2;
const OFFSET offsetExtensionOffset     = 4;


class otlExtensionLookup: otlLookupFormat
{
public:
	otlExtensionLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) {}
	
	USHORT extensionLookupType() const
	{	return UShort(pbTable + offsetExtensionLookupType); }

	
    otlLookupFormat extensionSubTable() const
	{	return otlLookupFormat(pbTable + ULong(pbTable+offsetExtensionOffset)); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\features.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  FEATURES.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements OTL Library calls dealing with features
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/



otlErrCode GetScriptFeatureLookupLists
(
	otlTag					tagTable,
    otlResourceMgr&			resourceMgr, 

    otlScriptListTable*		pScriptList,
	otlFeatureListTable*	pFeatureList,
	otlLookupListTable*		pLookupList
)	
{
	// script list in GPOS
	if (tagTable == OTL_GSUB_TAG)
	{
		otlGSubHeader gsub = otlGSubHeader(resourceMgr.getOtlTable (OTL_GSUB_TAG));
		if (gsub.isNull()) return OTL_ERR_TABLE_NOT_FOUND;

		if (pScriptList != NULL)
		{
			*pScriptList = gsub.scriptList();
		}

		if (pFeatureList != NULL)
		{
			*pFeatureList = gsub.featureList();
		}

		if (pLookupList != NULL)
		{
			*pLookupList = gsub.lookupList();
		}

		return OTL_SUCCESS;
	}

	// script list in GSUB
	else if (tagTable == OTL_GPOS_TAG)
	{
		otlGPosHeader gpos = otlGPosHeader(resourceMgr.getOtlTable (OTL_GPOS_TAG));
		if (gpos.isNull()) return OTL_ERR_TABLE_NOT_FOUND;

		if (pScriptList != NULL)
		{
			*pScriptList = gpos.scriptList();
		}

		if (pFeatureList != NULL)
		{
			*pFeatureList = gpos.featureList();
		}

		if (pLookupList != NULL)
		{
			*pLookupList = gpos.lookupList();
		}

		return OTL_SUCCESS;
	}

	// this should not happen -- still return something
	assert(false);
	return OTL_ERR_BAD_INPUT_PARAM;
}


void AddFeatureDetails
(
	otlTag					tagTable,
	const otlFeatureRecord&	featureRecord,
	otlFeatureDef*			pfdef
)
{
	// these are the details we support so far
	// TODO: add more feature details
	if (tagTable == OTL_GSUB_TAG)
	{
		pfdef->grfDetails |= OTL_FEAT_FLAG_GSUB;
	}
	else if (tagTable == OTL_GPOS_TAG)
	{
		pfdef->grfDetails |= OTL_FEAT_FLAG_GPOS;
	}

}


otlErrCode AppendFeatureDefs
(
	otlTag						tagTable,
	otlResourceMgr&				resourceMgr,

	const otlScriptListTable&	scriptList,
	otlTag						tagScript,
	otlTag						tagLangSys,

	const otlFeatureListTable&	featureList, 
	otlList*					pliFDefs
)
{
	assert(pliFDefs->dataSize() == sizeof(otlFeatureDef));
	assert(pliFDefs->length() <= pliFDefs->maxLength());
	assert(tagTable == OTL_GSUB_TAG || tagTable == OTL_GPOS_TAG);

	// get the number of features that are already recorded
	USHORT cPrevFeatures = pliFDefs->length();
	otlErrCode erc = OTL_SUCCESS;
														  
 	otlScriptTable scriptTable = FindScript(scriptList, tagScript);
	if (scriptTable.isNull())
	{
		return OTL_ERR_SCRIPT_NOT_FOUND;
	}

	otlLangSysTable langSysTable = FindLangSys(scriptTable, tagLangSys);
	if (langSysTable.isNull())
	{
		return OTL_ERR_LANGSYS_NOT_FOUND;
	}

	// now, start filling in feature descriptors
	USHORT cFCount = langSysTable.featureCount();

	for (USHORT iFeature = 0; iFeature < cFCount; ++iFeature)
	{
		otlFeatureRecord featureRecord = 
			featureList.featureRecord(langSysTable.featureIndex(iFeature));

		otlTag tagFeature;
		tagFeature = featureRecord.featureTag();

		bool fFeatureFound = FALSE;
		for (USHORT iPrevFeature = 0; 
					iPrevFeature < cPrevFeatures && !fFeatureFound;
					++iPrevFeature)
		{
			otlFeatureDef* pFDef = 
				getOtlFeatureDef(pliFDefs, iPrevFeature);
						
			if (pFDef->tagFeature == tagFeature)
			{
				AddFeatureDetails(tagTable, featureRecord, pFDef);
				fFeatureFound = true;
			}
		}

		if (!fFeatureFound)
		{
			// make sure we have enough space
			if (pliFDefs->length() + 1 > pliFDefs->maxLength())
			{
				erc = resourceMgr.reallocOtlList(pliFDefs, 
												 pliFDefs->dataSize(), 
												 pliFDefs->maxLength() + 1, 
												 otlPreserveContent);

				if (erc != OTL_SUCCESS) return erc;
			}

			otlFeatureDef fdefNew;
			fdefNew.tagFeature = featureRecord.featureTag();

			fdefNew.grfDetails = 0;
			AddFeatureDetails(tagTable, featureRecord, &fdefNew);

			pliFDefs->append((const BYTE*)&fdefNew);
		}
	}

	return OTL_SUCCESS;
}

otlFeatureTable FindFeature
(
	const otlLangSysTable&		langSysTable,
	const otlFeatureListTable&	featureList,
	otlTag						tagFeature
)
{
	assert(!langSysTable.isNull());
	assert(!featureList.isNull());


	USHORT cFeatures = langSysTable.featureCount();

	for (USHORT iFeature = 0; iFeature < cFeatures; ++iFeature)
	{
		USHORT index = langSysTable.featureIndex(iFeature);

		assert(index < featureList.featureCount());
		// but still do not fail on a bad font
		if (index >= featureList.featureCount()) continue;
			
		otlFeatureRecord featureRecord = featureList.featureRecord(index);
		if (featureRecord.featureTag() == tagFeature)
		{
			return featureRecord.featureTable();
		}
	}

	// not found
	return otlFeatureTable((const BYTE*) NULL);
}

otlFeatureTable RequiredFeature
(
	const otlLangSysTable&		langSysTable,
	const otlFeatureListTable&	featureList
)
{
	USHORT reqIndex = langSysTable.reqFeatureIndex();
	if (reqIndex == 0xFFFF)
	{
		return otlFeatureTable((BYTE*)NULL);
	}

	if (reqIndex >= featureList.featureCount())
	{
		assert(false);	// bad font
		return otlFeatureTable((BYTE*)NULL);
	}

	return featureList.featureRecord(reqIndex).featureTable();
}

bool EnablesFull
(
	const otlFeatureTable&		featureTable,
	USHORT						iLookup
)
{
	// invalid feature tags do nothing
	if (featureTable.isNull())
	{
		return false;
	}

	USHORT cLookups = featureTable.lookupCount();

	for (USHORT i = 0; i < cLookups; ++i)
	{
		if (featureTable.lookupIndex(i) == iLookup)
		{
			return true;
		}
	}

	return false;
}


//Functions to get Enables functionality from cache

bool otlEnablesCache::Allocate( otlResourceMgr& resourceMgr, USHORT cLookups)
{
    const USHORT MaxECacheSize =8192;

    if ((cBitsPerLookup*cLookups) > (cbSize*8) )
    {
        USHORT cbNewSize = MIN(((cBitsPerLookup*cLookups-1)>>3)+1,
                             MaxECacheSize);

        BYTE* pbNewBuf = resourceMgr.getEnablesCacheBuf(cbNewSize);
        if (pbNewBuf) 
        {
            pbData = pbNewBuf;
            cbSize  = cbNewSize;
        }
        else
        {
            cbNewSize=resourceMgr.getEnablesCacheBufSize();
            if (cbNewSize>cbSize)
            {
                pbNewBuf=resourceMgr.getEnablesCacheBuf(cbNewSize);
                if (pbNewBuf) pbData=pbNewBuf;
                cbSize=cbNewSize;
            }

            if ((cbSize*8) < cBitsPerLookup)
            {
                pbData = (BYTE*)NULL;
                cbSize = 0;
                return false; //We can work only with EnablesFull function
            }
        }
    }

    cLookupsPerCache = (cbSize*8)/cBitsPerLookup;
    return true;
}

void otlEnablesCache::ClearFlags()
{
    if (!IsActive()) return;

    memset(pbData,0,cbSize);
}

void otlEnablesCache::Refresh(
    const otlFeatureTable& featureTable,
    USHORT iFlagNum
)
{
    if (!IsActive()) return;

    if (featureTable.isNull()) return;

    for(USHORT i=0; i<featureTable.lookupCount(); i++)
    {
        USHORT iLookup = featureTable.lookupIndex(i),
               LookupStartBit=(iLookup-iLookupFirst)*cBitsPerLookup;

        if (iLookup >= iLookupFirst && 
            iLookup <  iLookupAfter)
        {
            BIT_SET(pbData,LookupStartBit+iFlagNum);
            BIT_SET(pbData,LookupStartBit+AggregateFlagIndex()); //Flag for whole lookup
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gdef.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  GDEF.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions dealing with gdef processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

long otlCaret::value
(
	const otlMetrics&	metr,		
	otlPlacement*		rgPointCoords	// may be NULL
) const
{
	assert(!isNull());

	switch(format())
	{
	case(1):	// design units only
		{
			otlSimpleCaretValueTable simpleCaret = 
						otlSimpleCaretValueTable(pbTable);
			if (metr.layout == otlRunLTR || 
				metr.layout == otlRunRTL)
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmX, 
								 (long)simpleCaret.coordinate());
			}
			else
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmY, 
								 (long)simpleCaret.coordinate());
			}
		}

	case(2):	// contour point
		{
			otlContourCaretValueTable contourCaret = 
						otlContourCaretValueTable(pbTable);
			if (rgPointCoords != NULL)
			{
				USHORT iPoint = contourCaret.caretValuePoint();

				if (metr.layout == otlRunLTR || 
					metr.layout == otlRunRTL)
				{
					return rgPointCoords[iPoint].dx;
				}
				else
				{
					return rgPointCoords[iPoint].dy;
				}
			}
			else
				return (long)0;
		}
	
	case(3):	// design units plus device table
		{
			otlDeviceCaretValueTable deviceCaret = 
						otlDeviceCaretValueTable(pbTable);
			otlDeviceTable deviceTable = deviceCaret.deviceTable();
			if (metr.layout == otlRunLTR || 
				metr.layout == otlRunRTL)
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmX, 
								 (long)deviceCaret.coordinate()) +
										deviceTable.value(metr.cPPEmX);
			}
			else
			{
				return DesignToPP(metr.cFUnits, metr.cPPEmY, 
								 (long)deviceCaret.coordinate()) +
										deviceTable.value(metr.cPPEmY);
			}
		}
	
	default:	// invalid format
		assert(false);
		return (0);
	}
		
}


otlErrCode AssignGlyphTypes
(
	otlList*				pliGlyphInfo,
	const otlGDefHeader&	gdef,

	USHORT					iglFirst,
	USHORT					iglAfterLast,
	otlGlyphTypeOptions		grfOptions			

)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(iglFirst < iglAfterLast);
	assert(iglAfterLast <= pliGlyphInfo->length());

	// if no gdef, glyphs types stay unassigned forever
	if(gdef.isNull()) return OTL_SUCCESS;

	otlClassDef glyphClassDef = gdef.glyphClassDef();

	for (USHORT iGlyph = iglFirst; iGlyph < iglAfterLast; ++iGlyph)
	{
		otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iGlyph);

        if ((grfOptions & otlDoAll) ||
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlUnresolved ||
            //we process otlUnassigned just for backward compatibility
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlUnassigned) 
		{
			pGlyphInfo->grf &= ~OTL_GFLAG_CLASS;
			pGlyphInfo->grf |= glyphClassDef.getClass(pGlyphInfo->glyph);
		}
	}

	return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gsub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  GSUB.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions calls dealing with gsub 
*		processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/
otlErrCode SubstituteNtoM
(
	otlList*		pliCharMap,
	otlList*		pliGlyphInfo,
	otlResourceMgr&	resourceMgr,

	USHORT			grfLookupFlags,

	USHORT			iGlyph,
	USHORT			cGlyphs,
	const otlList&	liglSubstitutes
)
{
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(iGlyph + cGlyphs <= pliGlyphInfo->length());
	assert(cGlyphs > 0);

	assert(liglSubstitutes.dataSize() == sizeof(otlGlyphID));
	assert(liglSubstitutes.length() > 0);

	// get GDEF
	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

	// Record the original starting char and number of characters;
	// Merge all components (make all chars in all components point to iGlyph)
	otlGlyphInfo* pglinfFirst = getOtlGlyphInfo(pliGlyphInfo, iGlyph);
	USHORT iChar = pglinfFirst->iChar;
	USHORT cchLigTotal = pglinfFirst->cchLig;

	USHORT igl = iGlyph;
	for (USHORT i = 1; i < cGlyphs; ++i)
	{
		igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
								igl + 1, otlForward);

 		assert(igl < pliGlyphInfo->length());

		otlGlyphInfo* pglinf = getOtlGlyphInfo(pliGlyphInfo, igl);

		if (cchLigTotal == 0) 
            iChar = pglinf->iChar;

        cchLigTotal += pglinf->cchLig;

		USHORT ichComp = pglinf->iChar;
		for(USHORT ich = 0; ich < pglinf->cchLig; ++ich)
		{
			USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, ichComp);
			if (ich + 1 < pglinf->cchLig)
			{
				ichComp = NextCharInLiga(pliCharMap, ichComp);
			}

            assert (*piGlyph == igl);
			*piGlyph = iGlyph;
		}

	}

	// make sure we got enough space
	USHORT cNewGlyphs = liglSubstitutes.length();
	assert(cNewGlyphs > 0);

	otlErrCode erc;
	if (pliGlyphInfo->length() + cNewGlyphs - cGlyphs > pliGlyphInfo->maxLength())
	{
		erc = resourceMgr.reallocOtlList(pliGlyphInfo, 
											pliGlyphInfo->dataSize(), 
											pliGlyphInfo->maxLength() 
												+ cNewGlyphs - cGlyphs, 
											otlPreserveContent);

		if (erc != OTL_SUCCESS) return erc;
	}

	// get rid of old glyphs, allocate space for new ones
	if (grfLookupFlags == 0)
	{
		// easy special case
		if (cNewGlyphs - cGlyphs > 0)
		{
			InsertGlyphs(pliCharMap, pliGlyphInfo, iGlyph, cNewGlyphs - cGlyphs);
		}
		else if (cNewGlyphs - cGlyphs < 0)
		{
			DeleteGlyphs(pliCharMap, pliGlyphInfo, iGlyph, cGlyphs - cNewGlyphs);
		}
	}
	else
	{
		USHORT igl = iGlyph + 1;
		for (USHORT i = 1; i < cGlyphs; ++i)
		{
			igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
									igl, otlForward);

			assert(igl < pliGlyphInfo->length());
			DeleteGlyphs(pliCharMap, pliGlyphInfo, igl, 1);

		}

		InsertGlyphs(pliCharMap, pliGlyphInfo, iGlyph, cNewGlyphs - 1);
	}

	// go though glyphs assigning them the right values
	// and getting their cchLig from gdef

	// NOTE: glyph components are defined by both GDEF caret tables
	// and mark-to-liagture positioning tables
	// Where there is choice we give preference to GDEF

	USHORT cchCurTotal = 0;
	for (USHORT iSub = 0; iSub < cNewGlyphs; ++iSub)	
	{
		otlGlyphID glSubst = GlyphID(liglSubstitutes.readAt(iSub));

		otlGlyphInfo* pglinf = 
			getOtlGlyphInfo(pliGlyphInfo, iGlyph + iSub);

		pglinf->glyph = glSubst;
		pglinf->iChar = iChar;

		// REVIEW
		// this is how we distribute components in case of multiple substitution
		if (iSub + 1 == cNewGlyphs)
		{
			pglinf->cchLig = cchLigTotal - cchCurTotal;
		}
		else 
		{
			otlLigGlyphTable ligGlyph = FindLigGlyph(gdef, glSubst);
			if (!ligGlyph.isNull())
			{
				pglinf->cchLig = MIN(ligGlyph.caretCount() + 1, 
									 cchLigTotal - cchCurTotal);
			}
			else 
			{
				pglinf->cchLig = MIN(1, cchLigTotal - cchCurTotal);

			}
		}

		if (pglinf->cchLig > 0)
		{
			for (USHORT i = 0; i < pglinf->cchLig; ++i)
			{
				USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, iChar);
				if (cchCurTotal + i + 1 < cchLigTotal)
				{
					iChar = NextCharInLiga(pliCharMap, iChar);
				}

				*piGlyph = iGlyph + iSub;
			}
		}
		
		cchCurTotal += pglinf->cchLig;
	}
	
	return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  GPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL GPOS formats 
*		(GPOS header, ValueRecord,  AnchorTable and mark array)
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetGPosVersion = 0;
const OFFSET offsetGPosScriptList = 4;
const OFFSET offsetGPosFeatureList = 6;
const OFFSET offsetGPosLookupList = 8;

class otlGPosHeader: public otlTable
{
public:

	otlGPosHeader(const BYTE* pb): otlTable(pb) {}

	ULONG version() const
	{	return ULong(pbTable + offsetGPosVersion); }

	otlScriptListTable scriptList() const
	{
        ULONG tableSize = *(UNALIGNED ULONG *)pbTable;
        OFFSET scriptListOffset = Offset(pbTable + offsetGPosScriptList);
        if (tableSize < (ULONG)(scriptListOffset + 2))
        {
            return otlScriptListTable((BYTE*)NULL);
        }
        return otlScriptListTable(pbTable + scriptListOffset);
    }

	otlFeatureListTable featureList() const
	{	return otlFeatureListTable(pbTable 
					+ Offset(pbTable + offsetGPosFeatureList)); }

	otlLookupListTable lookupList() const
	{	return otlLookupListTable(pbTable 
					+ Offset(pbTable + offsetGPosLookupList)); }

};

// value record
enum  otlValueRecordFlag
{
	otlValueXPlacement	= 0x0001,
	otlValueYPlacement	= 0x0002,
	otlValueXAdvance	= 0x0004,
	otlValueYAdvance	= 0x0008,
	otlValueXPlaDevice	= 0x0010,
	otlValueYPlaDevice	= 0x0020,
	otlValueXAdvDevice	= 0x0040,
	otlValueYAdvDevice	= 0x0080 

};


class otlValueRecord: public otlTable
{
private:
	const BYTE*	pbMainTable;
	USHORT		grfValueFormat;

public:

	otlValueRecord(USHORT grf, const BYTE* table, const BYTE* pb)
		: otlTable(pb),
		  pbMainTable(table),
		  grfValueFormat(grf)
	{
	}

	otlValueRecord& operator = (const otlValueRecord& copy)
	{
		pbTable = copy.pbTable;
		pbMainTable = copy.pbMainTable;
		grfValueFormat = copy.grfValueFormat;
		return *this;
	}

	USHORT valueFormat()
	{	return grfValueFormat; }

	void adjustPos
	(
		const otlMetrics&	metr,		
		otlPlacement*	pplcGlyphPalcement,	// in/out
		long*			pduDAdvance			// in/out
	) const;

	static USHORT size(USHORT grfValueFormat );

};


const OFFSET offsetAnchorFormat = 0;

const OFFSET offsetSimpleXCoordinate = 2;
const OFFSET offsetSimpleYCoordinate = 4;

class otlSimpleAnchorTable: public otlTable
{
public:
	otlSimpleAnchorTable(const BYTE* pb)
		: otlTable(pb)
	{
		assert(UShort(pbTable + offsetAnchorFormat) == 1);
	}

	short xCoordinate() const
	{	return SShort(pbTable + offsetSimpleXCoordinate); }

	short yCoordinate() const
	{	return SShort(pbTable + offsetSimpleYCoordinate); }

};

const OFFSET offsetContourXCoordinate = 2;
const OFFSET offsetContourYCoordinate = 4;
const OFFSET offsetAnchorPoint = 6;

class otlContourAnchorTable: public otlTable
{
public:
	otlContourAnchorTable(const BYTE* pb)
		: otlTable(pb)
	{
		assert(UShort(pbTable + offsetAnchorFormat) == 2);
	}

	short xCoordinate() const
	{	return SShort(pbTable + offsetContourXCoordinate); }

	short yCoordinate() const
	{	return SShort(pbTable + offsetContourYCoordinate); }

	USHORT anchorPoint() const
	{	return UShort(pbTable + offsetAnchorPoint); }

};


const OFFSET offsetDeviceXCoordinate = 2;
const OFFSET offsetDeviceYCoordinate = 4;
const OFFSET offsetXDeviceTable = 6;
const OFFSET offsetYDeviceTable = 8;

class otlDeviceAnchorTable: public otlTable
{
public:
	otlDeviceAnchorTable(const BYTE* pb)
		: otlTable(pb)
	{
		assert(UShort(pbTable + offsetAnchorFormat) == 3);
	}

	short xCoordinate() const
	{	return SShort(pbTable + offsetDeviceXCoordinate); }

	short yCoordinate() const
	{	return SShort(pbTable + offsetDeviceYCoordinate); }

	otlDeviceTable xDeviceTable() const
	{	
		if (Offset(pbTable + offsetXDeviceTable) == 0)
			return otlDeviceTable((const BYTE*)NULL);

		return otlDeviceTable(pbTable + Offset(pbTable + offsetXDeviceTable)); 
	}

	otlDeviceTable yDeviceTable() const
	{	if (Offset(pbTable + offsetYDeviceTable) == 0)
			return otlDeviceTable((const BYTE*)NULL);

		return otlDeviceTable(pbTable + Offset(pbTable + offsetYDeviceTable)); 
	}

};


class otlAnchor: public otlTable
{

public:

	otlAnchor(const BYTE* pb): otlTable(pb) {}

	USHORT format() const
	{	return UShort(pbTable + offsetAnchorFormat); }

	void getAnchor
	(
		USHORT			cFUnits,        // font design units per Em 
		USHORT			cPPEmX,         // horizontal pixels per Em 
		USHORT			cPPEmY,         // vertical pixels per Em 
		
		otlPlacement*	rgPointCoords,	// may be NULL if not available
				
		otlPlacement*	pplcAnchorPoint	// out: anchor point in rendering units
	) const;
};



const OFFSET offsetMarkClass = 0;
const OFFSET offsetMarkAnchor = 2;

class otlMarkRecord: public otlTable
{
	const BYTE* pbMainTable;
public:

	otlMarkRecord(const BYTE* array, const BYTE* pb)
		: otlTable(pb),
		  pbMainTable(array)
	{}

	USHORT markClass() const
	{	return UShort(pbTable + offsetMarkClass); }

	otlAnchor markAnchor() const
	{	return otlAnchor(pbMainTable + Offset(pbTable + offsetMarkAnchor)); }

};


const OFFSET offsetMarkCount = 0;
const OFFSET offsetMarkRecordArray = 2;
const USHORT sizeMarkRecord = 4;

class otlMarkArray: public otlTable
{
public:

	otlMarkArray(const BYTE* pb): otlTable(pb) {}

	USHORT markCount() const
	{	return UShort(pbTable + offsetMarkCount); }

	otlMarkRecord markRecord(USHORT index) const
	{	assert(index < markCount());
		return otlMarkRecord(pbTable,
							 pbTable + offsetMarkRecordArray 
									 + index * sizeMarkRecord); 
	}
};


// helper functions

long DesignToPP
(
	USHORT			cFUnits,        // font design units per Em 
	USHORT			cPPem,			// pixels per Em

	long			lFValue			// value to convert, in design units
);

// align anchors on two glyphs; assume no spacing glyphs between these two
enum otlAnchorAlighmentOptions
{
	otlUseAdvances		=	1 

};

void AlignAnchors
(
	const otlList*		pliGlyphInfo,	
	otlList*			pliPlacement,
	otlList*			pliduDAdv,

	USHORT				iglStatic,
	USHORT				iglMobile,

	const otlAnchor&	anchorStatic,
	const otlAnchor&	anchorMobile,

    otlResourceMgr&		resourceMgr, 

	const otlMetrics&	metr,		

	USHORT				grfOptions
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\features.h ===
/***********************************************************************
************************************************************************
*
*                    ********  FEATURES.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of feature lists and tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetFeatureParams = 0;
const OFFSET offsetFeatureLookupCount = 2;
const OFFSET offsetFeatureLookupListIndexArray = 4;

class otlFeatureTable: public otlTable
{
public:

    otlFeatureTable(const BYTE* pb): otlTable(pb) {}

    OFFSET featureParamsOffset() const
    {   return Offset(pbTable + offsetFeatureParams); }

    USHORT lookupCount() const
    {   return UShort(pbTable + offsetFeatureLookupCount); }

    USHORT lookupIndex(USHORT index) const
    {   assert(index < lookupCount());
        return UShort(pbTable + offsetFeatureLookupListIndexArray
                              + index*sizeof(USHORT)); }
};


const OFFSET offsetFeatureTag = 0;
const OFFSET offsetFeature = 4;

class otlFeatureRecord: public otlTable
{

private:
    const BYTE*   pbMainTable;

public:
    otlFeatureRecord(const BYTE* pbList, const BYTE* pbRecord)
        : otlTable(pbRecord),
          pbMainTable(pbList)
    {
    }

    otlFeatureRecord& operator = (const otlFeatureRecord& copy)
    {
        pbTable = copy.pbTable;
        pbMainTable = copy.pbMainTable;
        return *this;
    }


    otlTag featureTag() const
    {   return *(UNALIGNED otlTag*)(pbTable + offsetFeatureTag); }

    otlFeatureTable featureTable() const
    {   return otlFeatureTable(pbMainTable + Offset(pbTable + offsetFeature));
    }

};


const OFFSET offsetFeatureCount = 0;
const OFFSET offsetFeatureRecordArray = 2;
const USHORT sizeFeatureRecord = 6;

class otlFeatureListTable: public otlTable
{
public:

    otlFeatureListTable(const BYTE* pb): otlTable(pb) {}

    USHORT featureCount() const
    {   return UShort(pbTable + offsetFeatureCount); }

    otlFeatureRecord featureRecord(USHORT index) const
    {   assert(index < featureCount());
        return otlFeatureRecord(pbTable,
                 pbTable + offsetFeatureRecordArray
                         + index*sizeFeatureRecord);
    }

};


// helper functions

// get script, feature and lookup list tables from either gpos or gsub
// (gets the tables form the client)
// if GetScriptFeatureLookupLists succeeds, tagTable needs to be freed
otlErrCode GetScriptFeatureLookupLists
(
    otlTag                  tagTable,
    otlResourceMgr&         resourceMgr,

    otlScriptListTable*     pScriptList,
    otlFeatureListTable*    pFeatureList,
    otlLookupListTable*     pLookupList
);

// get feature definitions
otlErrCode AppendFeatureDefs
(
    otlTag                      tagTable,
    otlResourceMgr&             resourceMgr,

    const otlScriptListTable&   scriptList,
    otlTag                      tagScript,
    otlTag                      tagLangSys,

    const otlFeatureListTable&  featureList,

    otlList*                    pliFDefs
);

// returns a NULL feature if feature not found
otlFeatureTable FindFeature
(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,
    otlTag                      tagFeature
);

otlFeatureTable RequiredFeature
(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList
);

bool EnablesFull
(
    const otlFeatureTable&      featureTable,
    USHORT                      iLookup
);

#define BIT_SET(C,i)      ( (C)[(i)>>3] |= ( 1 << ((i)&7) ) )
#define IS_BIT_SET(C,i) ( ( (C)[(i)>>3] &  ( 1 << ((i)&7) ) ) != 0)

class otlEnablesCache {

private:
    BYTE*  pbData;
    USHORT cbSize;
    USHORT cLookupsPerCache;
    USHORT cBitsPerLookup;
    USHORT iLookupFirst;
    USHORT iLookupAfter;

public:
    otlEnablesCache(USHORT cFeatures, BYTE* pb, USHORT cbS) 
        :pbData(pb), 
	 cbSize(cbS), 
         cBitsPerLookup(cFeatures+2), //+1 Required feature, +1 AggregateFlag
         cLookupsPerCache(0), iLookupFirst(0), iLookupAfter(0) {};

    bool IsActive( ) const { return (pbData!=NULL); }
    bool InCache(USHORT iLookup) const 
            { return (iLookup>=iLookupFirst && iLookup<iLookupAfter); }
    
    bool Allocate( otlResourceMgr& resourceMgr, USHORT cLookups);
    void Reset() { iLookupAfter = iLookupFirst; };
    void ClearFlags();
    void SetFirst(USHORT iLookup) 
            {iLookupFirst=iLookup; iLookupAfter=iLookup+cLookupsPerCache;}
    void Refresh(const otlFeatureTable& featureTable, USHORT iFeatureIndex);
    bool Check(USHORT iFlagIndex, USHORT iLookup) const 
          { return IS_BIT_SET(pbData,
                              (iLookup-iLookupFirst)*cBitsPerLookup+iFlagIndex
                             );
          }
    USHORT RequiredFeatureFlagIndex() const { return (cBitsPerLookup-2); }
    USHORT AggregateFlagIndex() const { return (cBitsPerLookup-1); }
};

inline bool Enables(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,
    const otlFeatureDesc*       pFDesc,

    USHORT                      iLookup,
 
    USHORT                      iFeatureIndex,
    const otlEnablesCache&      ec
)
{
    if (ec.IsActive()) return ec.Check(iFeatureIndex,iLookup);
    return EnablesFull(FindFeature(langSysTable, featureList,pFDesc->tagFeature),iLookup);
}

inline bool EnablesRequired(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    USHORT                      iLookup,
 
    const otlEnablesCache&      ec
)
{
    if (ec.IsActive()) return ec.Check(ec.RequiredFeatureFlagIndex(),iLookup);
    return EnablesFull(RequiredFeature(langSysTable, featureList),iLookup);
}


inline bool EnablesSomewhere(
    USHORT                  iLookup,
    const otlEnablesCache&  ec
)
{
    if (ec.IsActive()) return  ec.Check(ec.AggregateFlagIndex(),iLookup);
    return true; //Cache doesn't work, we need to check each feature separately
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  GPOS.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions calls dealing with gpos 
*		processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/

long DesignToPP
(
	USHORT			cFUnits,        // font design units per Em 
	USHORT			cPPEm,			// pixels per Em

	long			lFValue			// value to convert, in design units
)
{
    long lHalf;
    long lNegHalf;
    long lCorrect;


    lHalf = (long)cFUnits >> 1;
    lNegHalf = -lHalf + 1;         /* ensures the same rounding as a shift */

    if (lFValue >= 0)
    {
        lCorrect = lHalf;
    }
    else
    {
        lCorrect = lNegHalf;
    }

    return (lFValue * (long)cPPEm + lCorrect) / (long)cFUnits;
}


static USHORT const cbNibbleCount[16] = 
	{ 0, 2, 2, 4,  2, 4, 4, 6,  2, 4, 4, 6,  4, 6, 6, 8 };

USHORT otlValueRecord::size(USHORT grfValueFormat )
{
	return (cbNibbleCount[grfValueFormat & 0x000F] +
		cbNibbleCount[(grfValueFormat >> 4) & 0x000F]);
}


void otlValueRecord::adjustPos
(
	const otlMetrics&	metr,		
	otlPlacement*		pplcGlyphPalcement,	// in/out
	long*				pduDAdvance			// in/out
) const
{
	assert(!isNull());
	assert(pplcGlyphPalcement != NULL);
	assert(pduDAdvance != NULL);

	const BYTE* pbTableBrowser = pbTable;
	
	if (grfValueFormat & otlValueXPlacement)
    {
        pplcGlyphPalcement->dx += DesignToPP(metr.cFUnits, metr.cPPEmX, 
											 SShort(pbTableBrowser));
        pbTableBrowser += 2;
    }
	if (grfValueFormat & otlValueYPlacement)
    {
        pplcGlyphPalcement->dy += DesignToPP(metr.cFUnits, metr.cPPEmY, 
											 SShort(pbTableBrowser));
        pbTableBrowser += 2;
    }
	if (grfValueFormat & otlValueXAdvance)
    {
		if (metr.layout == otlRunLTR || 
			metr.layout == otlRunRTL)
        {
			*pduDAdvance += DesignToPP(metr.cFUnits, metr.cPPEmX, 
									   SShort(pbTableBrowser));
		}
        pbTableBrowser += 2;
    }
	if (grfValueFormat & otlValueYAdvance)
    {
		if (metr.layout == otlRunTTB || 
			metr.layout == otlRunBTT)
        {
			*pduDAdvance += DesignToPP(metr.cFUnits, metr.cPPEmY, 
									   SShort(pbTableBrowser));
		}
        pbTableBrowser += 2;
    }


    if (grfValueFormat & otlValueXPlaDevice)
    {
		if (Offset(pbTableBrowser) != 0) 
		{
			pplcGlyphPalcement->dx += 
				otlDeviceTable(pbMainTable + Offset(pbTableBrowser))
				.value(metr.cPPEmX);
		}
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueYPlaDevice)
    {
		if (Offset(pbTableBrowser) != 0) 
		{
			pplcGlyphPalcement->dx += 
				otlDeviceTable(pbMainTable + Offset(pbTableBrowser))
				.value(metr.cPPEmY);
		}
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueXAdvDevice)
    {
		if (metr.layout == otlRunLTR || 
			metr.layout == otlRunRTL)
        {
			if (Offset(pbTableBrowser) != 0) 
			{
				*pduDAdvance += 
					otlDeviceTable(pbMainTable + Offset(pbTableBrowser))
					.value(metr.cPPEmX);
			}
		}
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueYAdvDevice)
    {
		if (metr.layout == otlRunTTB || 
			metr.layout == otlRunBTT)
		{
			if (Offset(pbTableBrowser) != 0) 
			{
				*pduDAdvance += 
					otlDeviceTable(pbMainTable + Offset(pbTableBrowser))
					.value(metr.cPPEmY);
			}
		}
        pbTableBrowser += 2;
    }

	return;
}


void otlAnchor::getAnchor
(
	USHORT			cFUnits,        // font design units per Em 
	USHORT			cPPEmX,         // horizontal pixels per Em 
	USHORT			cPPEmY,         // vertical pixels per Em 
	
	otlPlacement*	rgPointCoords,	// may be NULL if not available
			
	otlPlacement*	pplcAnchorPoint	// out: anchor point in rendering units
) const
{
	assert(!isNull());
	assert(pplcAnchorPoint != NULL);


	switch(format())
	{
	case(1):	// design units only
		{
			otlSimpleAnchorTable simpleAnchor = otlSimpleAnchorTable(pbTable);

			pplcAnchorPoint->dx = DesignToPP(cFUnits, cPPEmX, 
											 simpleAnchor.xCoordinate());
			pplcAnchorPoint->dy = DesignToPP(cFUnits, cPPEmY, 
											 simpleAnchor.yCoordinate());
			return;
		}

	case(2):	// dsign units plus contour point
		{
			otlContourAnchorTable contourAnchor = otlContourAnchorTable(pbTable);

			if (rgPointCoords != NULL)
			{
				*pplcAnchorPoint = rgPointCoords[ contourAnchor.anchorPoint() ];
			}
			else
			{
				pplcAnchorPoint->dx = DesignToPP(cFUnits, cPPEmX, 
												 contourAnchor.xCoordinate());
				pplcAnchorPoint->dy = DesignToPP(cFUnits, cPPEmY, 
												 contourAnchor.yCoordinate());
			}

			return;
		}

	case(3):	// design units plus device table
		{
			otlDeviceAnchorTable deviceAnchor = otlDeviceAnchorTable(pbTable);

			pplcAnchorPoint->dx = DesignToPP(cFUnits, cPPEmX, 
											 deviceAnchor.xCoordinate());
			pplcAnchorPoint->dy = DesignToPP(cFUnits, cPPEmY, 
											 deviceAnchor.yCoordinate());

			otlDeviceTable deviceX = deviceAnchor.xDeviceTable();
			otlDeviceTable deviceY = deviceAnchor.yDeviceTable();

			if (!deviceX.isNull())
			{
				pplcAnchorPoint->dx += deviceX.value(cPPEmX);
			}
			if (!deviceY.isNull())
			{
				pplcAnchorPoint->dy += deviceY.value(cPPEmY);
			}

			return;
		}

	default:	// invalid anchor format
		assert(false);
	}
}


void AlignAnchors
(
	const otlList*		pliGlyphInfo,	
	otlList*			pliPlacement,
	otlList*			pliduDAdv,

	USHORT				iglStatic,
	USHORT				iglMobile,

	const otlAnchor&	anchorStatic,
	const otlAnchor&	anchorMobile,

    otlResourceMgr&		resourceMgr, 

	const otlMetrics&	metr,		
	USHORT				grfOptions
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	assert(pliduDAdv->dataSize() == sizeof(long));

	assert(pliGlyphInfo->length() == pliPlacement->length());
	assert(pliPlacement->length() == pliduDAdv->length());

	assert(iglStatic < pliGlyphInfo->length());
	assert(iglMobile < pliGlyphInfo->length());

	assert(!anchorStatic.isNull());
	assert(!anchorMobile.isNull());


	const otlGlyphInfo* pglinfStatic = 
		readOtlGlyphInfo(pliGlyphInfo, iglStatic);
	const otlGlyphInfo* pglinfMobile = 
		readOtlGlyphInfo(pliGlyphInfo, iglMobile);

	otlPlacement* pplcStatic = getOtlPlacement(pliPlacement, iglStatic);
	otlPlacement* pplcMobile = getOtlPlacement(pliPlacement, iglMobile);

	long* pduDAdvStatic = getOtlAdvance(pliduDAdv, iglStatic);
	long* pduDAdvMobile = getOtlAdvance(pliduDAdv, iglMobile);

	otlPlacement plcStaticAnchor;
	anchorStatic.getAnchor(metr.cFUnits, metr.cPPEmX, metr.cPPEmY,
							resourceMgr.getPointCoords(pglinfStatic->glyph),
							&plcStaticAnchor);

	otlPlacement plcMobileAnchor;
	anchorMobile.getAnchor(metr.cFUnits, metr.cPPEmX, metr.cPPEmY,
							resourceMgr.getPointCoords(pglinfMobile->glyph),
							&plcMobileAnchor);


	long duAdvanceInBetween = 0;
	for (USHORT igl = MIN(iglStatic, iglMobile) + 1;
				igl < MAX(iglStatic, iglMobile); ++igl)
	{
		duAdvanceInBetween += *getOtlAdvance(pliduDAdv, igl);
	}

	if (metr.layout == otlRunLTR || 
		metr.layout == otlRunRTL)
	{
		pplcMobile->dy = pplcStatic->dy + plcStaticAnchor.dy 
										- plcMobileAnchor.dy;
		
		if ((metr.layout == otlRunLTR) == (iglStatic < iglMobile))
		{
			long dx = pplcStatic->dx - *pduDAdvStatic + plcStaticAnchor.dx 
								- duAdvanceInBetween  - plcMobileAnchor.dx;

			if (grfOptions & otlUseAdvances)
			{
				*pduDAdvStatic += dx;
			}
			else
			{
				pplcMobile->dx = dx;
			}
		}
		else
		{
			long dx = pplcStatic->dx + *pduDAdvMobile + plcStaticAnchor.dx 
								+ duAdvanceInBetween  - plcMobileAnchor.dx;

			if (grfOptions & otlUseAdvances)
			{
				*pduDAdvMobile -= dx;
			}
			else
			{
				pplcMobile->dx = dx;
			}
		}
	}
	else
	{
		pplcMobile->dx = pplcStatic->dx + plcStaticAnchor.dx 
										- plcMobileAnchor.dx;
		
		if ((metr.layout == otlRunTTB) == (iglStatic < iglMobile))
		{
			long dy = pplcStatic->dy - *pduDAdvStatic + plcStaticAnchor.dy 
								 - duAdvanceInBetween - plcMobileAnchor.dy;

			if (grfOptions & otlUseAdvances)
			{
				*pduDAdvStatic += dy;
			}
			else
			{
				pplcMobile->dy = dy;
			}
		}
		else
		{
			long dy = pplcStatic->dy + *pduDAdvMobile + plcStaticAnchor.dy 
								 + duAdvanceInBetween - plcMobileAnchor.dy;

			if (grfOptions & otlUseAdvances)
			{
				*pduDAdvMobile -= dy;
			}
			else
			{
				pplcMobile->dy = dy;
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  GDEF.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL GDEF table.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetPointCount = 0;
const OFFSET offsetPointIndexArray = 2;

class otlAttachPointTable: public otlTable
{
public:

	otlAttachPointTable(const BYTE* pb): otlTable(pb) {}

	USHORT pointCount() const
	{	return UShort(pbTable + offsetPointCount); }

	USHORT pointIndex(USHORT index) const
	{	assert(index < pointCount());
		return UShort(pbTable + offsetPointIndexArray + index*sizeof(USHORT)); }
};


const OFFSET offsetCoverage = 0;
const OFFSET offsetAttachGlyphCount = 2;
const OFFSET offsetAttachPointTableArray = 4;

class otlAttachListTable: public otlTable
{
public:

	otlAttachListTable(const BYTE* pb): otlTable(pb) {}

	otlCoverage coverage() const
	{	return otlCoverage(pbTable + Offset(pbTable + offsetCoverage)); }

	USHORT glyphCount() const
	{	return UShort(pbTable + offsetAttachGlyphCount); }

	otlAttachPointTable attachPointTable(USHORT index) const
	{	assert(index < glyphCount());
		return otlAttachPointTable(pbTable 
				+ Offset(pbTable + offsetAttachPointTableArray 
								 + index*sizeof(OFFSET))); 
	}
};


const OFFSET offsetCaretValueFormat = 0;

const OFFSET offsetSimpleCaretCoordinate = 2;

class otlSimpleCaretValueTable: public otlTable
{
public:

	otlSimpleCaretValueTable(const BYTE* pb)
		: otlTable(pb)
	{
		assert(UShort(pbTable + offsetCaretValueFormat) == 1);
	}

	short coordinate() const
	{	return SShort(pbTable + offsetSimpleCaretCoordinate); }

};


const OFFSET offsetCaretValuePoint = 2;

class otlContourCaretValueTable: public otlTable
{
public:

	otlContourCaretValueTable(const BYTE* pb)
		: otlTable(pb)
	{
		assert(UShort(pbTable + offsetCaretValueFormat) == 2);
	}

	USHORT caretValuePoint() const
	{	return UShort(pbTable + offsetCaretValuePoint); }

};


const OFFSET offsetDeviceCaretCoordinate = 2;
const OFFSET offsetCaretDeviceTable = 4;

class otlDeviceCaretValueTable: public otlTable
{
public:

	otlDeviceCaretValueTable(const BYTE* pb)
		: otlTable(pb)
	{
		assert(UShort(pbTable + offsetCaretValueFormat) == 3);
	}

	short coordinate() const
	{	return SShort(pbTable + offsetDeviceCaretCoordinate); }


	otlDeviceTable deviceTable() const
	{	return otlDeviceTable(pbTable 
					+ Offset(pbTable + offsetCaretDeviceTable)); 
	}
};



class otlCaret: public otlTable
{
public:

	otlCaret(const BYTE* pb): otlTable(pb) {}

	USHORT format() const
	{	return UShort(pbTable + offsetCaretValueFormat); }

	long value
	(
		const otlMetrics&	metr,		
		otlPlacement*		rgPointCoords	// may be NULL
	) const;
};


const OFFSET offsetCaretCount = 0;
const OFFSET offsetCaretValueArray = 2;

class otlLigGlyphTable: public otlTable
{
public:

	otlLigGlyphTable(const BYTE* pb): otlTable(pb) {}

	USHORT caretCount() const
	{	return UShort(pbTable + offsetCaretCount); }

	otlCaret caret(USHORT index) const
	{	assert(index < caretCount());
		return otlCaret(pbTable 
				+ Offset(pbTable + offsetCaretValueArray 
								 + index*sizeof(OFFSET))); 
	}
};



const OFFSET offsetLigGlyphCoverage = 0;
const OFFSET offsetLigGlyphCount = 2;
const OFFSET offsetLigGlyphTableArray = 4;

class otlLigCaretListTable: public otlTable
{
public:

	otlLigCaretListTable(const BYTE* pb): otlTable(pb) {}

	otlCoverage coverage() const
	{	return otlCoverage(pbTable + Offset(pbTable + offsetLigGlyphCoverage)); }

	USHORT ligGlyphCount() const
	{	return UShort(pbTable + offsetLigGlyphCount); }

	otlLigGlyphTable ligGlyphTable(USHORT index) const
	{	assert(index < ligGlyphCount());
		return otlLigGlyphTable(pbTable 
				+ Offset(pbTable + offsetLigGlyphTableArray 
								 + index*sizeof(OFFSET))); 
	}
};


const OFFSET offsetGDefVersion = 0;
const OFFSET offsetGlyphClassDef = 4;
const OFFSET offsetAttachList = 6;
const OFFSET offsetLigCaretList = 8;
const OFFSET offsetAttachClassDef = 10;

class otlGDefHeader: public otlTable
{
public:

	otlGDefHeader(const BYTE* pb): otlTable(pb) {}

	ULONG version() const
	{	return ULong(pbTable + offsetGDefVersion); }

	otlClassDef glyphClassDef() const
	{	return otlClassDef(pbTable + Offset(pbTable + offsetGlyphClassDef)); }

	otlAttachListTable attachList() const
	{	
        if (Offset(pbTable + offsetAttachList) == 0) 
               return otlAttachListTable((const BYTE*)NULL);
        return otlAttachListTable(pbTable + Offset(pbTable + offsetAttachList)); }

	otlLigCaretListTable ligCaretList() const
	{	
        if (Offset(pbTable + offsetLigCaretList) == 0)
               return otlLigCaretListTable((const BYTE*)NULL);
        return otlLigCaretListTable(pbTable 
					+ Offset(pbTable + offsetLigCaretList)); 
	}

	otlClassDef attachClassDef() const
	{	return otlClassDef(pbTable + Offset(pbTable + offsetAttachClassDef)); }

};


// helper functions
enum otlGlyphTypeOptions
{
	otlDoUnresolved		=	0,
	otlDoAll			=	1
};

otlErrCode AssignGlyphTypes
(
	otlList*				pliGlyphInfo,
	const otlGDefHeader&	gdef,
	USHORT					iglFirst,
	USHORT					iglAfterLast,
	otlGlyphTypeOptions		grfOptions			
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\ligasub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  LIGASUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with ligature substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlLigatureSubstLookup::apply
(
	otlList*					pliCharMap,
	otlList*					pliGlyphInfo,
	otlResourceMgr&				resourceMgr,

	USHORT						grfLookupFlags,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	otlLigatureSubTable ligaSubst = otlLigatureSubTable(pbTable);
	otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
	
	short index = ligaSubst.coverage().getIndex(pGlyphInfo->glyph);
	if (index < 0)
	{
		return OTL_NOMATCH;
	}

	// look for a ligature that applies
	if (index >= ligaSubst.ligSetCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}

	// get GDEF
	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

	otlLigatureSetTable ligaSet = ligaSubst.ligatureSet(index);

	USHORT cLiga = ligaSet.ligatureCount();
	for (USHORT iLiga = 0; iLiga < cLiga; ++iLiga)
	{
		otlLigatureTable ligaTable = ligaSet.ligature(iLiga);
		USHORT cComp = ligaTable.compCount();

		bool match = true;

        // a simple check so we don't waste time
        if (iglIndex + cComp > iglAfterLast)
        {
            match = false;
        }

		USHORT iglComp = iglIndex;
		for (USHORT i = 1; i < cComp && iglComp < iglAfterLast && match; ++i)
		{
			iglComp = NextGlyphInLookup(pliGlyphInfo, 
										grfLookupFlags, gdef, 
										iglComp + 1, otlForward);
			
			if (iglComp < iglAfterLast)
			{
				otlGlyphInfo* pglinf = getOtlGlyphInfo(pliGlyphInfo, iglComp);
				if (pglinf->glyph != ligaTable.component(i))
				{
					match = false;
				}
			}
			else
			{
				match = false;
			}
		}

		if (match)
		{
			// that's where the next glyph will be after the subst is done
			*piglNextGlyph = (iglComp - cComp + 1) + 1;

			return SubstituteNtoM(pliCharMap, pliGlyphInfo, resourceMgr, 
								  grfLookupFlags,  
								  iglIndex, cComp,
								  ligaTable.substitute());
		}
	}

	return OTL_NOMATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\ligasub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  LIGASUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with ligature substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetLigGlyph = 0;
const OFFSET offsetLigCompCount = 2;
const OFFSET offsetLigComponentArray = 4;

class otlLigatureTable: otlTable
{
public:

	otlLigatureTable(const BYTE* pb): otlTable(pb) {}

	// we return otlList of length 1 so it's in the same format
	// as in multiple substitution lookup
	otlList substitute()
	{	return otlList((void*)(pbTable + offsetLigGlyph), 
						sizeof(otlGlyphID), 1, 1); 
	}
	
	USHORT compCount()
	{	return UShort(pbTable + offsetLigCompCount); }

	otlGlyphID component(USHORT index)
	{	assert(index < compCount());
		assert(index > 0);
		return GlyphID(pbTable + offsetLigComponentArray 
								+ (index - 1) * sizeof(otlGlyphID)); 
	}
};


const OFFSET offsetLigatureCount = 0;
const OFFSET offsetLigatureArray = 2;

class otlLigatureSetTable: otlTable
{
public:

	otlLigatureSetTable(const BYTE* pb): otlTable(pb) {}

	USHORT ligatureCount()
	{	return UShort(pbTable + offsetLigatureCount); }

	otlLigatureTable ligature(USHORT index)
	{	assert(index < ligatureCount());
		return otlLigatureTable(pbTable + 
					Offset(pbTable + offsetLigatureArray 
								   + index * sizeof(OFFSET)));
	}
};


const OFFSET offsetLigaCoverage = 2;
const OFFSET offsetLigSetCount = 4;
const OFFSET offsetLigatureSetArray = 6;

class otlLigatureSubTable: otlLookupFormat
{
public:
	otlLigatureSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetLigaCoverage)); }

	USHORT ligSetCount()
	{	return UShort(pbTable + offsetLigSetCount); }
	
	otlLigatureSetTable ligatureSet(USHORT index)
	{	assert(index < ligSetCount());
		return otlLigatureSetTable(pbTable + 
					Offset(pbTable + offsetLigatureSetArray 
								   + index * sizeof(OFFSET)));
	}
};


class otlLigatureSubstLookup: otlLookupFormat
{
public:
	otlLigatureSubstLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) {}
	
	otlErrCode apply
	(
	otlList*					pliCharMap,
	otlList*					pliGlyphInfo,
	otlResourceMgr&				resourceMgr,

	USHORT						grfLookupFlags,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\mkbaspos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MKBASPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-base attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// Look for the *logically* preceding base
short findBase
(
	const otlList*				pliCharMap,
	const otlList*				pliGlyphInfo,
	USHORT						iglMark
)
{
	USHORT iglBase;
	bool fFoundBase = false;
	for (short ich = readOtlGlyphInfo(pliGlyphInfo, iglMark)->iChar; 
				ich >= 0 && !fFoundBase; --ich)
	{
		USHORT igl = readOtlGlyphIndex(pliCharMap, ich);
		if ((readOtlGlyphInfo(pliGlyphInfo, igl)->grf & OTL_GFLAG_CLASS) 
				!= otlMarkGlyph)
		{
			iglBase = igl;
			fFoundBase = true;
		}
	}
	if (!fFoundBase)
	{
		return -1;
	}
	
	return iglBase;
}

otlErrCode otlMkBasePosLookup::apply
(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo != NULL);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(pliduGlyphAdv != NULL);
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliplcGlyphPlacement != NULL);
	assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

	assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
	assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	assert(format() == 1);

	otlGlyphInfo* pMarkInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
	if ((pMarkInfo->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
	{
		return OTL_NOMATCH;
	}

	MkBasePosSubTable mkBasePos = MkBasePosSubTable(pbTable);

	short indexMark = mkBasePos.markCoverage().getIndex(pMarkInfo->glyph);
	if (indexMark < 0)
	{
		return OTL_NOMATCH;
	}


	// Look for the *logically* preceding base
	short iglBase = findBase(pliCharMap, pliGlyphInfo, iglIndex);
	if (iglBase < 0)
	{
		return OTL_NOMATCH;
	}

	otlGlyphInfo* pBaseInfo = getOtlGlyphInfo(pliGlyphInfo, iglBase);
	short indexBase = mkBasePos.baseCoverage().getIndex(pBaseInfo->glyph);
	if (indexBase < 0)
	{
		return OTL_NOMATCH;
	}



	if (indexMark >= mkBasePos.markArray().markCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlMarkRecord markRecord = mkBasePos.markArray().markRecord(indexMark);
	otlAnchor anchorMark = markRecord.markAnchor();

	if (indexBase >= mkBasePos.baseArray().baseCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	if (markRecord.markClass() >= mkBasePos.baseArray().classCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlAnchor anchorBase = 
		mkBasePos.baseArray().baseAnchor(indexBase, markRecord.markClass());


	AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
				 iglBase, iglIndex, anchorBase, anchorMark, resourceMgr, 
				 metr, 0);

	*piglNextGlyph = iglIndex + 1;
	return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gsub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  GSUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL GSUB formats (GSUB Header).
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetGSubVersion = 0;
const OFFSET offsetGSubScriptList = 4;
const OFFSET offsetGSubFeatureList = 6;
const OFFSET offsetGSubLookupList = 8;

class otlGSubHeader: public otlTable
{
public:

	otlGSubHeader(const BYTE* pb): otlTable(pb) {}

	ULONG version() const
	{	return ULong(pbTable + offsetGSubVersion); }

	otlScriptListTable scriptList() const
	{
        ULONG tableSize = *(UNALIGNED ULONG *)pbTable;
        OFFSET scriptListOffset = Offset(pbTable + offsetGSubScriptList);
        if (tableSize < (ULONG)(scriptListOffset + 2))
        {
            return otlScriptListTable((BYTE*)NULL);
        }
        return otlScriptListTable(pbTable + scriptListOffset); 
	}

	otlFeatureListTable featureList() const
	{	return otlFeatureListTable(pbTable 
					+ Offset(pbTable + offsetGSubFeatureList)); 
	}

	otlLookupListTable lookupList() const
	{	return otlLookupListTable(pbTable 
					+ Offset(pbTable + offsetGSubLookupList)); 
	}

};


class otlRange
{
private:

	USHORT	iFirst;
	USHORT	iAfterLast;

	// new not allowed
	void* operator new(size_t size);

public:

	otlRange(USHORT first, USHORT after_last)
		: iFirst(first), iAfterLast(after_last)
	{}

	bool contains (USHORT i) const
	{	return (iFirst <= i) && (iAfterLast > i); }

	bool intersects (const otlRange& other) const
	{	return MAX(iFirst, other.iFirst) < MIN(iAfterLast, other.iAfterLast); }

};


// n --> m substitution
otlErrCode SubstituteNtoM
(
	otlList*		pliCharMap,
	otlList*		pliGlyphInfo,
	otlResourceMgr&	resourceMgr,

	USHORT			grfLookupFlags,

	USHORT			iGlyph,
	USHORT			cGlyphs,
	const otlList&	liglSubstitutes
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\lookups.h ===
/***********************************************************************
************************************************************************
*
*                    ********  LOOKUPS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with functions common for all lookup formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const USHORT offsetLookupFormat = 0;

class otlSingleSubstLookup;
class otlAlternateSubstLookup;
class otlMultiSubstLookup;
class otlLigatureSubstLookup;

class otlSinglePosLookup;
class otlPairPosLookup;
class otlCursivePosLookup;
class otlMkBasePosLookup;
class otlMkLigaPosLookup;
class otlMkMkPosLookup;

class otlContextLookup;
class otlChainingLookup;
class otlExtensionLookup;

class otlLookupFormat: public otlTable 
{
public:

	friend otlSingleSubstLookup;
	friend otlAlternateSubstLookup;
	friend otlMultiSubstLookup;
	friend otlLigatureSubstLookup;

	friend otlSinglePosLookup;
	friend otlPairPosLookup;
	friend otlCursivePosLookup;
	friend otlMkBasePosLookup;
	friend otlMkLigaPosLookup;
	friend otlMkMkPosLookup;

	friend otlContextLookup;
	friend otlChainingLookup;
    friend otlExtensionLookup;
	
	otlLookupFormat(const BYTE* pb): otlTable(pb) {}

	USHORT format() const 
	{	return UShort(pbTable + offsetLookupFormat); }

};


const USHORT offsetLookupType = 0;
const USHORT offsetLookupFlags = 2;
const USHORT offsetSubTableCount = 4;
const USHORT offsetSubTableArray = 6;

class otlLookupTable: public otlTable
{
public:

	otlLookupTable(const BYTE* pb): otlTable(pb) {}

	USHORT	lookupType() const 
	{	return UShort(pbTable + offsetLookupType); }

	otlGlyphFlags	flags() const 
	{	return UShort(pbTable + offsetLookupFlags); }

	unsigned int	subTableCount() const
	{	return UShort(pbTable + offsetSubTableCount); }

	// we don't know the type
	otlLookupFormat subTable(USHORT index) const
	{	assert(index < subTableCount());
		return otlLookupFormat(pbTable + Offset(pbTable + offsetSubTableArray 
														+ index*sizeof(OFFSET))); 
	}
};

enum otlLookupFlag
{
	otlRightToLeft			= 0x0001,	// for CursiveAttachment only
	otlIgnoreBaseGlyphs		= 0x0002,	
	otlIgnoreLigatures		= 0x0004,	
	otlIgnoreMarks			= 0x0008,

	otlMarkAttachClass		= 0xFF00
};

inline USHORT attachClass(USHORT grfLookupFlags)
{	return (grfLookupFlags & otlMarkAttachClass) >> 8; }


const OFFSET offsetLookupCount = 0;
const OFFSET offsetLookupArray = 2;

class otlLookupListTable: public otlTable
{
public:

	otlLookupListTable(const BYTE* pb): otlTable(pb) {}

	USHORT lookupCount() const
	{	return UShort(pbTable + offsetLookupCount); }

	otlLookupTable lookup(USHORT index) const
	{	assert(index < lookupCount());
		return otlLookupTable(pbTable 
					 + Offset(pbTable + offsetLookupArray 
									  + index*sizeof(OFFSET))); 
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\measure.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MEASURE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL measuring functions
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

otlLigGlyphTable FindLigGlyph
(
	const otlGDefHeader&	gdef,
	otlGlyphID				glLigature
);

// count marks to this base
USHORT CountMarks
(
	const otlList*	pliCharMap,
	const otlList*	pliGlyphInfo,
	USHORT			ichBase
);

USHORT ComponentToChar
(
	const otlList*	pliCharMap,
	const otlList*	pliGlyphInfo,
	USHORT			iglLigature,
	USHORT			iComponent
);

USHORT CharToComponent
(
	const otlList*	pliCharMap,
	const otlList*	pliGlyphInfo,
	USHORT			iChar
);

otlErrCode GetCharAtPos 
( 
	const otlList*		pliCharMap,
    const otlList*		pliGlyphInfo,
    const otlList*		pliduGlyphAdv,
    otlResourceMgr&		resourceMgr, 

    long				duAdv,
    
	const otlMetrics&	metr,		
    USHORT*				piChar
);

otlErrCode GetPosOfChar 
( 
	const otlList*		pliCharMap,
    const otlList*		pliGlyphInfo,
    const otlList*		pliduGlyphAdv,
    otlResourceMgr&		resourceMgr, 

	const otlMetrics&	metr,		
    USHORT				iChar,
    
    long*				pduStartPos,
    long*				pduEndPos
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\measure.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MEASURE.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements measuring-related functions
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// find caret value for a ligature component
// returns NULL if caret is not defined for that ligature
// (fall back to glyph advance then)
otlLigGlyphTable FindLigGlyph
(
	const otlGDefHeader&	gdef,
	otlGlyphID				glLigature
)
{
	if(gdef.isNull()) return otlLigGlyphTable((const BYTE*)NULL);

	otlLigCaretListTable ligCaretList = gdef.ligCaretList();
	if (ligCaretList.isNull()) 
	{
		return otlLigGlyphTable((const BYTE*)NULL);
	}

	short index = ligCaretList.coverage().getIndex(glLigature);

	// glyph not covered?
	if (index < 0) return otlLigGlyphTable((const BYTE*)NULL);

	assert(index < ligCaretList.ligGlyphCount());
	// if the table is broken, still return something
	if (index >= ligCaretList.ligGlyphCount()) 
	{
		return otlLigGlyphTable((const BYTE*)NULL);
	}

	return ligCaretList.ligGlyphTable(index);

}


// find character corresponding to ligature component
USHORT ComponentToChar
(
	const otlList*	pliCharMap,
	const otlList*	pliGlyphInfo,
	USHORT			iglLigature,
	USHORT			iComponent
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(iglLigature < pliGlyphInfo->length());

	const otlGlyphInfo* pglinfLigature = 
		readOtlGlyphInfo(pliGlyphInfo, iglLigature);

	assert(iComponent < pglinfLigature->cchLig);

	USHORT iChar = pglinfLigature->iChar;
	for(USHORT ich = 0; ich < iComponent; ++ich)
	{
		iChar = NextCharInLiga(pliCharMap, iChar);
		assert(iChar < pliCharMap->length());
	}	

	return iChar;
}


// find ligature compoonent	corresponding to character
USHORT CharToComponent
(
	const otlList*	pliCharMap,
	const otlList*	pliGlyphInfo,
	USHORT			iChar
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));

	USHORT iglLigature = readOtlGlyphIndex(pliCharMap, iChar);

	const otlGlyphInfo* pglinfLigature = 
		readOtlGlyphInfo(pliGlyphInfo, iglLigature);

	USHORT ich = pglinfLigature->iChar;
	assert(ich <= iChar);
	for (USHORT iComp = 0; iComp < pglinfLigature->cchLig; ++iComp )
	{
		if (ich == iChar)
		{
			return iComp;
		}
		
		ich = NextCharInLiga(pliCharMap, ich);
	}

	assert(false);
	return 0;

}


// count marks to this base
USHORT CountMarks
(
	const otlList*	pliCharMap,
	const otlList*	pliGlyphInfo,
	USHORT			ichBase
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	
	USHORT cMarks = 0;

	bool done = false;
	for (USHORT ich = ichBase + 1; ich < pliCharMap->length(); ++ich)
	{
		USHORT iglMark = readOtlGlyphIndex(pliCharMap, ich);

		const otlGlyphInfo*	pglinfMark = 
			readOtlGlyphInfo(pliGlyphInfo, iglMark);
		
		// are we done?	have we gone too far?
		if ((pglinfMark->grf & OTL_GFLAG_CLASS) == otlMarkGlyph)
		{
			++cMarks;
		}
		else
		{
			return cMarks;
		}
	}

	return cMarks;
}


otlErrCode GetCharAtPos 
( 
    const otlList*		pliCharMap,
    const otlList*		pliGlyphInfo,
    const otlList*		pliduGlyphAdv,
    otlResourceMgr&		resourceMgr, 

    const long			duAdv,

	const otlMetrics&	metr,		
    USHORT*				piChar
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliGlyphInfo->length() == pliduGlyphAdv->length());

	if (duAdv < 0) return OTL_ERR_POS_OUTSIDE_TEXT;

	long duPen = 0;
	long duLastAdv = 0;

	USHORT iglBase;
	bool found = false;
	for(USHORT igl = 0; igl < pliGlyphInfo->length() && !found; ++igl)
	{
		duLastAdv = readOtlAdvance(pliduGlyphAdv, igl);

		if (duPen + duLastAdv > duAdv)
		{
			iglBase = igl;
			found = true;
		}
		else
		{
			duPen += duLastAdv;
		}
	}

	if (!found) return OTL_ERR_POS_OUTSIDE_TEXT;

	const otlGlyphInfo*	pglinfBase = readOtlGlyphInfo(pliGlyphInfo, iglBase);

	// ok we found our glyph

	// now if it's a ligature we need to figure which component to take

	// if it's not however, then it's simple
	if (pglinfBase->cchLig <= 1)
	{
		*piChar = pglinfBase->iChar;
		return OTL_SUCCESS;
	}

	// now we try to figure out the component
	USHORT iComponent;
	long duComponent = duAdv - duPen;

	assert(duComponent >= 0);
	assert(duComponent < duLastAdv);

	// try to get caret information if it's a ligature
	// time to get GDEF
	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

	otlLigGlyphTable ligGlyph = FindLigGlyph(gdef, pglinfBase->glyph);
	if (!ligGlyph.isNull())
	{
		// now we know it's a ligature, and caret table was found
		// go through carets
		iComponent = 0;

		USHORT cCarets = ligGlyph.caretCount();
		for (USHORT iCaret = 0; iCaret < cCarets; ++iCaret)
		{
			 if (duComponent >= ligGlyph.caret(iCaret)
				 .value(metr, resourceMgr.getPointCoords(pglinfBase->glyph))
				)
					   
			 {
				 ++iComponent;
			 }
		}
	}
	else
	{
		// resort to the simplistic fallback

		// Round it up, so that we always round-trip 
		// iComponent --> duComponent --> iComponent
		iComponent = (USHORT)((pglinfBase->cchLig * (duComponent + 1) - 1) / duLastAdv);
	}
						
	iComponent  = MIN(iComponent, pglinfBase->cchLig);
	
	*piChar =  ComponentToChar(pliCharMap, pliGlyphInfo, iglBase, iComponent);

	return OTL_SUCCESS;
}


otlErrCode GetPosOfChar 
( 
    const otlList*		pliCharMap,
    const otlList*		pliGlyphInfo,
    const otlList*		pliduGlyphAdv,
    otlResourceMgr&		resourceMgr, 

	const otlMetrics&	metr,		
    USHORT				iChar,
    
    long*				pduStartPos,
    long*				pduEndPos
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliGlyphInfo->length() == pliduGlyphAdv->length());
	
	if(iChar >= pliCharMap->length()) 
	{
		return OTL_ERR_POS_OUTSIDE_TEXT;
	}

	USHORT iGlyph = readOtlGlyphIndex(pliCharMap, iChar);

	const otlGlyphInfo* pglinfBase = 
		readOtlGlyphInfo(pliGlyphInfo, iGlyph);

	
	// sum up advances to get to our glyph
	long duPen = 0;
	for(USHORT iglPen = 0; iglPen < iGlyph; ++iglPen)
	{
		duPen += readOtlAdvance(pliduGlyphAdv, iglPen);

	}

	long duLastAdv = readOtlAdvance(pliduGlyphAdv, iGlyph);

	// add advances of glyphs that go to the same character
	// we should add this space to the last component as all these
	// glyphs map to the last character
	long duExtra = 0;
	for (USHORT igl = iGlyph + 1; igl < pliGlyphInfo->length() 
				&& readOtlGlyphInfo(pliGlyphInfo, igl)->cchLig == 0; ++igl)
	{
		assert(readOtlGlyphInfo(pliGlyphInfo, igl)->iChar == iChar);
		duExtra += readOtlAdvance(pliduGlyphAdv, igl);

	}

	// now if it's a ligature we need to figure which component to take
	// if it's not however, then it's simple
	if (pglinfBase->cchLig == 1)
	{
		*pduStartPos = 	duPen;
		*pduEndPos = duPen + duLastAdv + duExtra;

		return OTL_SUCCESS;
	}

	USHORT iComponent = CharToComponent(pliCharMap, pliGlyphInfo, iChar);

	// else try to get caret information if it's a ligature
	// time to get GDEF
	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

	otlLigGlyphTable ligGlyph = FindLigGlyph(gdef, pglinfBase->glyph);
	if (!ligGlyph.isNull())
	{
		// got the caret table
		// now our position is between two carets
		if (iComponent == 0)
		{
			 *pduStartPos = duPen;
		}
		else if (iComponent - 1 < ligGlyph.caretCount())
		{
			*pduStartPos = 	duPen + ligGlyph.caret(iComponent - 1)
				.value(metr, resourceMgr.getPointCoords(pglinfBase->glyph));
		}
		else
		{
			assert(false);			// more components than caret pos + 1
			*pduStartPos = duPen + duLastAdv + duExtra;
		}

		if (iComponent < ligGlyph.caretCount())
		{
			*pduEndPos = 	duPen + ligGlyph.caret(iComponent)
				.value(metr, resourceMgr.getPointCoords(pglinfBase->glyph));
		}
		else if (iComponent == ligGlyph.caretCount())
		{
			*pduEndPos = duPen + duLastAdv + duExtra;
		}
		else
		{
			assert(false);			// more components than caret pos + 1
			*pduStartPos = duPen + duLastAdv + duExtra;
		}

	}
	else
	{
		// simplistic fallback
		*pduStartPos = 	duPen + (duLastAdv * iComponent) / pglinfBase->cchLig;
		*pduEndPos = duPen + (duLastAdv * (iComponent + 1)) / pglinfBase->cchLig;

		if (iComponent + 1 == pglinfBase->cchLig)
		{
			*pduEndPos += duExtra;
		}
	}

	return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\mkligpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MKLIGPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-ligature attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// Look for the *logically* preceding base
short findBaseLigature
(
	const otlList*				pliCharMap,
	const otlList*				pliGlyphInfo,
	USHORT						iglMark,
	USHORT*						piComponent
)
{
	USHORT ichBase, iglBase;
	bool fFoundBase = false;
	for (short ich = readOtlGlyphInfo(pliGlyphInfo, iglMark)->iChar; 
				ich >= 0 && !fFoundBase; --ich)
	{
		USHORT igl = readOtlGlyphIndex(pliCharMap, ich);
		if ((readOtlGlyphInfo(pliGlyphInfo, igl)->grf & OTL_GFLAG_CLASS) 
				!= otlMarkGlyph)
		{
			ichBase = ich;
			iglBase = igl;
			fFoundBase = true;
		}
	}
	if (!fFoundBase)
	{
		return -1;
	}

	*piComponent = CharToComponent(pliCharMap, pliGlyphInfo, ichBase);
	
	return iglBase;
}


otlErrCode otlMkLigaPosLookup::apply
(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo != NULL);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(pliduGlyphAdv != NULL);
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliplcGlyphPlacement != NULL);
	assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

	assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
	assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	assert(format() == 1);

	otlGlyphInfo* pMarkInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
	if ((pMarkInfo->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
	{
		return OTL_NOMATCH;
	}

	MkLigaPosSubTable mkLigaPos = MkLigaPosSubTable(pbTable);

	short indexMark = mkLigaPos.markCoverage().getIndex(pMarkInfo->glyph);
	if (indexMark < 0)
	{
		return OTL_NOMATCH;
	}


	// Look for the *logically* preceding base
	USHORT iComponent;
	short iglBase = findBaseLigature(pliCharMap, pliGlyphInfo, 
									 iglIndex, &iComponent);
	if (iglBase < 0)
	{
		return OTL_NOMATCH;
	}

	otlGlyphInfo* pBaseInfo = getOtlGlyphInfo(pliGlyphInfo, iglBase);
	short indexBase = mkLigaPos.ligatureCoverage().getIndex(pBaseInfo->glyph);
	if (indexBase < 0)
	{
		return OTL_NOMATCH;
	}


	if (indexBase >= mkLigaPos.ligatureArray().ligatureCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlLigatureAttachTable ligaAttach = 
		mkLigaPos.ligatureArray().ligatureAttach(indexBase);

	if (iComponent >= ligaAttach.componentCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}	
	
	if (indexMark >= mkLigaPos.markArray().markCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlMarkRecord markRecord = mkLigaPos.markArray().markRecord(indexMark);


	otlAnchor anchorMark = markRecord.markAnchor();

	if (markRecord.markClass() >= ligaAttach.classCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlAnchor anchorBase = 
		ligaAttach.ligatureAnchor(iComponent, markRecord.markClass());


	AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
				 iglBase, iglIndex, anchorBase, anchorMark, resourceMgr, 
				 metr, 0);

	*piglNextGlyph = iglIndex + 1;

	return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\mkbaspos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MKBASPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-base positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetBaseCount = 0;
const OFFSET offsetBaseRecordArray = 2;

class otlBaseArray: otlTable
{
	const USHORT cClassCount;

public:
	otlBaseArray(USHORT classCount, const BYTE* pb)
		: otlTable(pb),
		  cClassCount(classCount)
	{}

	USHORT baseCount()
	{	return UShort(pbTable + offsetBaseCount); }

	USHORT classCount()
	{	return cClassCount; }

	otlAnchor baseAnchor(USHORT index, USHORT iClass)
	{	assert(index < baseCount());
		return otlAnchor(pbTable + 
			Offset(pbTable + offsetBaseRecordArray 
						   + (index * cClassCount + iClass) * sizeof(OFFSET)));
	}
};


const OFFSET offsetMkBaseMarkCoverage = 2;
const OFFSET offsetMkBaseBaseCoverage = 4;
const OFFSET offsetMkBaseClassCount = 6;
const OFFSET offsetMkBaseMarkArray = 8;
const OFFSET offsetMkBaseBaseArray = 10;

class MkBasePosSubTable: otlLookupFormat
{
public:
	MkBasePosSubTable(const BYTE* pb): otlLookupFormat(pb)
	{
		assert(format() == 1);
	}

	otlCoverage markCoverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetMkBaseMarkCoverage)); }

	otlCoverage baseCoverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetMkBaseBaseCoverage)); }

	USHORT classCount()
	{	return UShort(pbTable + offsetMkBaseClassCount); }

	otlMarkArray markArray()
	{	return otlMarkArray(pbTable + Offset(pbTable + offsetMkBaseMarkArray)); }

	otlBaseArray baseArray()
	{	return otlBaseArray(classCount(),
							pbTable + Offset(pbTable + offsetMkBaseBaseArray)); }

};


class otlMkBasePosLookup: otlLookupFormat
{
public:
	otlMkBasePosLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}
	
	otlErrCode apply
	(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\multisub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MULTISUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with multiple substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlMultiSubstLookup::apply
(
	otlList*					pliCharMap, 
	otlList*					pliGlyphInfo,
	otlResourceMgr&				resourceMgr,

	USHORT						grfLookupFlags,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
)	// return: did/did not apply
{ 
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(pliCharMap->dataSize() == sizeof(USHORT));
	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	otlMultiSubTable multiSubst = otlMultiSubTable(pbTable);
	otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
	
	short index = multiSubst.coverage().getIndex(pGlyphInfo->glyph);
	if (index < 0)
	{
		return OTL_NOMATCH;
	}

	if (index >= multiSubst.sequenceCount())
	{
		assert(false); // bad font
		return OTL_ERR_BAD_FONT_TABLE;
	}

	otlSequenceTable sequence = multiSubst.sequence(index);

	otlErrCode erc;

	*piglNextGlyph = iglIndex + sequence.glyphCount();
	erc = SubstituteNtoM(pliCharMap, pliGlyphInfo, resourceMgr,
						 grfLookupFlags, 
						 iglIndex, 1, sequence.substituteArray());
	return erc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\mkmkpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MKMKPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-mark attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlMkMkPosLookup::apply
(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo != NULL);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(pliduGlyphAdv != NULL);
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliplcGlyphPlacement != NULL);
	assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

	assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
	assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	assert(format() == 1);

	otlGlyphInfo* pMark1Info = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
	if ((pMark1Info->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
	{
		return OTL_NOMATCH;
	}

	MkMkPosSubTable mkMkPos = MkMkPosSubTable(pbTable);

	short indexMark1 = mkMkPos.mark1Coverage().getIndex(pMark1Info->glyph);
	if (indexMark1 < 0)
	{
		return OTL_NOMATCH;
	}

	otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));


	// preceding glyph 

	short iglPrev = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, 
									  iglIndex - 1, otlBackward);
	if (iglPrev < 0)
	{
		return OTL_NOMATCH;
	}

	otlGlyphInfo* pMark2Info = getOtlGlyphInfo(pliGlyphInfo, iglPrev);
	if ((pMark2Info->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
	{
		return OTL_NOMATCH;
	}

	short indexMark2 = mkMkPos.mark2Coverage().getIndex(pMark2Info->glyph);
	if (indexMark2 < 0)
	{
		return OTL_NOMATCH;
	}

	// make sure that marks of different bases or components don't interact
	for (USHORT ichBetween = pMark2Info->iChar + 1; 
                ichBetween < pMark1Info->iChar; ++ichBetween)
    {
        USHORT iglBetween = readOtlGlyphIndex(pliCharMap, ichBetween);
        if ((readOtlGlyphInfo(pliGlyphInfo, iglBetween)->grf & OTL_GFLAG_CLASS) 
				!= otlMarkGlyph)
	    {
		    return OTL_NOMATCH;
	    }
    }

	if (indexMark1 >= mkMkPos.mark1Array().markCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlMarkRecord markRecord = mkMkPos.mark1Array().markRecord(indexMark1);


	otlAnchor anchorMark1 = markRecord.markAnchor();

	if (indexMark2 >= mkMkPos.mark2Array().mark2Count())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	if (markRecord.markClass() >= mkMkPos.mark2Array().classCount())
	{
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}
	otlAnchor anchorMark2 = 
		mkMkPos.mark2Array().mark2Anchor(indexMark2, markRecord.markClass());

	AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
				 iglPrev, iglIndex, anchorMark2, anchorMark1, resourceMgr, 
				 metr, 0);

	*piglNextGlyph = iglIndex + 1;

	return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\mkligpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MKLIGAPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-ligature positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetComponentCount = 0;
const OFFSET offsetLigatureAnchorArray = 2;

class otlLigatureAttachTable: otlTable
{
	const USHORT cClassCount;

public:
	otlLigatureAttachTable(USHORT classCount, const BYTE* pb)
		: otlTable(pb),
		  cClassCount(classCount)
	{}

	USHORT componentCount()
	{	return UShort(pbTable + offsetComponentCount); }

	USHORT classCount()
	{	return cClassCount; }

	otlAnchor ligatureAnchor(USHORT componentIndex, USHORT classIndex)
	{	assert(componentIndex < componentCount());
		assert(classIndex < classCount());

		return otlAnchor(pbTable + 
			Offset(pbTable + offsetLigatureAnchorArray  
						   + (componentIndex * cClassCount + classIndex) 
							  * sizeof(OFFSET)));
	}
};


const OFFSET offsetAttachLigatureCount = 0;
const OFFSET offsetLigatureAttachArray = 2;

class otlLigatureArrayTable: otlTable
{
	const USHORT cClassCount;

public:
	otlLigatureArrayTable(USHORT classCount, const BYTE* pb)
		: otlTable(pb),
		  cClassCount(classCount)
	{}

	USHORT ligatureCount()
	{	return UShort(pbTable + offsetAttachLigatureCount); }

	USHORT classCount()
	{	return cClassCount; }

	otlLigatureAttachTable ligatureAttach(USHORT index)
	{	assert(index < ligatureCount());
		return otlLigatureAttachTable(cClassCount, pbTable + 		
				Offset(pbTable + offsetLigatureAttachArray 
							   + index * sizeof(OFFSET)));
	}
};


const OFFSET offsetMkLigaMarkCoverage = 2;
const OFFSET offsetMkLigaLigatureCoverage = 4;
const OFFSET offsetMkLigaClassCount = 6;
const OFFSET offsetMkLigaMarkArray = 8;
const OFFSET offsetMkLigaLigatureArray = 10;

class MkLigaPosSubTable: otlLookupFormat
{
public:
	MkLigaPosSubTable(const BYTE* pb): otlLookupFormat(pb)
	{
		assert(format() == 1);
	}

	otlCoverage markCoverage()
	{	return otlCoverage(pbTable 
					+ Offset(pbTable + offsetMkLigaMarkCoverage)); 
	}

	otlCoverage ligatureCoverage()
	{	return otlCoverage(pbTable 
					+ Offset(pbTable + offsetMkLigaLigatureCoverage)); 
	}

	USHORT classCount()
	{	return UShort(pbTable + offsetMkLigaClassCount); }

	otlMarkArray markArray()
	{	return otlMarkArray(pbTable 
					+ Offset(pbTable + offsetMkLigaMarkArray)); 
	}

	otlLigatureArrayTable ligatureArray()
	{	return otlLigatureArrayTable(classCount(),
					pbTable + Offset(pbTable + offsetMkLigaLigatureArray)); 
	}

};


class otlMkLigaPosLookup: otlLookupFormat
{
public:
	otlMkLigaPosLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}
	
	otlErrCode apply
	(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\mkmkpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MKMKPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-mark positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetMark2Count = 0;
const OFFSET offsetMark2AnchorArray = 2;

class otlMark2Array: otlTable
{
	const USHORT cClassCount;

public:
	otlMark2Array(USHORT classCount, const BYTE* pb)
		: otlTable(pb),
		  cClassCount(classCount)
	{}

	USHORT mark2Count()
	{	return UShort(pbTable + offsetComponentCount); }

	USHORT classCount()
	{	return cClassCount; }

	otlAnchor mark2Anchor(USHORT mark2Index, USHORT classIndex)
	{	assert(mark2Index < mark2Count());
		assert(classIndex < classCount());

		return otlAnchor(pbTable + 
			Offset(pbTable + offsetMark2AnchorArray  
						   + (mark2Index * cClassCount + classIndex) 
							  * sizeof(OFFSET)));
	}
};



const OFFSET offsetMkMkMark1Coverage = 2;
const OFFSET offsetMkMkMark2Coverage = 4;
const OFFSET offsetMkMkClassCount = 6;
const OFFSET offsetMkMkMark1Array = 8;
const OFFSET offsetMkMkMark2Array = 10;

class MkMkPosSubTable: otlLookupFormat
{
public:
	MkMkPosSubTable(const BYTE* pb): otlLookupFormat(pb)
	{
		assert(format() == 1);
	}

	otlCoverage mark1Coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetMkMkMark1Coverage)); }

	otlCoverage mark2Coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetMkMkMark2Coverage)); }

	USHORT classCount()
	{	return UShort(pbTable + offsetMkMkClassCount); }

	otlMarkArray mark1Array()
	{	return otlMarkArray(pbTable + Offset(pbTable + offsetMkMkMark1Array)); }

	otlMark2Array mark2Array()
	{	return otlMark2Array(classCount(),
							pbTable + Offset(pbTable + offsetMkMkMark2Array)); }

};


class otlMkMkPosLookup: otlLookupFormat
{
public:
	otlMkMkPosLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}
	
	otlErrCode apply
	(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\multisub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MULTISUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with alternate substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetSequenceGlyphCount = 0;
const OFFSET offsetSubstituteArray = 2;

class otlSequenceTable: otlTable
{
public:

	otlSequenceTable(const BYTE* pb): otlTable(pb) {}

	USHORT glyphCount()
	{	return UShort(pbTable + offsetSequenceGlyphCount); }

	otlList substituteArray()
	{	return otlList((void*)(pbTable + offsetSubstituteArray), 
						sizeof(otlGlyphID),
						glyphCount(), glyphCount()); 
	}
};


const OFFSET offsetMultiCoverage = 2;
const OFFSET offsetSequenceCount = 4;
const OFFSET offsetSequenceArray = 6;

class otlMultiSubTable: public otlLookupFormat
{
public:

	otlMultiSubTable(const BYTE* pb)
		: otlLookupFormat(pb)
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetMultiCoverage)); }

	USHORT sequenceCount()
	{	return UShort(pbTable + offsetSequenceCount); }

	otlSequenceTable sequence(USHORT index)
	{	return otlSequenceTable(pbTable + 
				Offset(pbTable + offsetSequenceArray 
							   + index * sizeof(OFFSET))); }
};


class otlMultiSubstLookup: otlLookupFormat
{
public:

	otlMultiSubstLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}

	otlErrCode apply
	(
	otlList*					pliCharMap,
	otlList*					pliGlyphInfo,
	otlResourceMgr&				resourceMgr,

	USHORT						grfLookupFlags,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\pch.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  PCH.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module includes all internal and external header files in order.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\otllib.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLLIB.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements all top-level OTL Library calls.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/

#define     OTL_MAJOR_VERSION           1
#define     OTL_MINOR_VERSION           0
#define     OTL_MAJOR_VERSION_MASK      0xFF00

/***********************************************************************/

inline long version()
{
    return (OTL_MAJOR_VERSION << 16) + OTL_MINOR_VERSION;
}

OTL_EXPORT otlErrCode GetOtlVersion ( 
    long* plVersion
)
{
    *plVersion = version();

    return OTL_SUCCESS; 
}

// make sure that the (major) version we support is greater
// or equal to what the client requests
inline bool checkVersion(const otlRunProp* pRunProps)
{
    return (version() & OTL_MAJOR_VERSION_MASK) >= 
            (pRunProps->lVersion & OTL_MAJOR_VERSION_MASK);
}


OTL_EXPORT otlErrCode GetOtlScriptList 
    ( 
    const otlRunProp*   pRunProps, 
    otlList*            pliWorkspace,   
    otlList*            plitagScripts
    )
{
    // sanity check
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        plitagScripts == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if(plitagScripts->dataSize() != sizeof(otlTag) ||
        plitagScripts->length() > plitagScripts->maxLength()) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc, ercGSub, ercGPos;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    plitagScripts->empty();

    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL);

    
    // GSUB
    ercGSub = GetScriptFeatureLookupLists(OTL_GSUB_TAG, resourceMgr,  
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL);
    if (ercGSub == OTL_SUCCESS) 
        // get the script list from GSUB 
        ercGSub = AppendScriptTags(scriptList, plitagScripts, resourceMgr);
    
    if (ERRORLEVEL(ercGSub) > OTL_ERRORLEVEL_MINOR) return ercGSub;


    // GPOS
    ercGPos = GetScriptFeatureLookupLists(OTL_GPOS_TAG, resourceMgr, 
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL);
    if (ercGPos == OTL_SUCCESS)
        // get the script list, from GPOS
        ercGPos = AppendScriptTags(scriptList, plitagScripts, resourceMgr);
        

    // return greater error
    if (ERRORLEVEL(ercGSub) < ERRORLEVEL(ercGPos)) 
        return ercGPos; 
    else 
        return ercGSub;
    
}



OTL_EXPORT otlErrCode GetOtlLangSysList 
    ( 
    const otlRunProp*   pRunProps,    
    otlList*            pliWorkspace,   
    otlList*            plitagLangSys
    )
{
    // sanity check
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        plitagLangSys == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if(plitagLangSys->dataSize() != sizeof(otlTag) ||
        plitagLangSys->length() > plitagLangSys->maxLength()) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc, ercGSub, ercGPos;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    plitagLangSys->empty();

    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL);

    
    // GSUB
    ercGSub = GetScriptFeatureLookupLists(OTL_GSUB_TAG, resourceMgr, 
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL);
    if (ercGSub == OTL_SUCCESS)
        ercGSub = AppendLangSysTags(scriptList, pRunProps->tagScript, 
                                    plitagLangSys, resourceMgr);

    // return immediately if fatal error, but keep going if script was not found
    if (ERRORLEVEL(ercGSub) > OTL_ERRORLEVEL_MINOR) return ercGSub;  


    // GPOS
    ercGPos = GetScriptFeatureLookupLists(OTL_GPOS_TAG, resourceMgr, 
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL);
    if (ercGPos == OTL_SUCCESS)
        ercGPos = AppendLangSysTags(scriptList, pRunProps->tagScript, 
                                    plitagLangSys, resourceMgr);

    
    // return greater error
    if (ERRORLEVEL(ercGSub) < ERRORLEVEL(ercGPos)) 
        return ercGPos; 
    else 
        return ercGSub;
    
}


OTL_EXPORT otlErrCode GetOtlFeatureDefs 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   
    otlList*            pliFDefs
)
{
    // sanity check
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL || 
        pliFDefs == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if(pliFDefs->dataSize() != sizeof(otlFeatureDef) ||
        pliFDefs->length() > pliFDefs->maxLength()) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc, ercGSub , ercGPos;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    pliFDefs->empty();

    otlFeatureListTable featureList = otlFeatureListTable((const BYTE*)NULL);
    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL);

    
    // GSUB
    ercGSub = GetScriptFeatureLookupLists(OTL_GSUB_TAG, resourceMgr, 
                                            &scriptList, 
                                            &featureList, 
                                            (otlLookupListTable*)NULL);
    if (ercGSub == OTL_SUCCESS)
        ercGSub = AppendFeatureDefs(OTL_GSUB_TAG, resourceMgr, 
                                    scriptList, 
                                    pRunProps->tagScript,
                                    pRunProps->tagLangSys,
                                    featureList, pliFDefs);

    // return immediately if fatal error, but keep going if script 
    // or langsys were not found
    if (ERRORLEVEL(ercGSub) > OTL_ERRORLEVEL_MINOR) return ercGSub;
    
    
    // GPOS
    ercGPos = GetScriptFeatureLookupLists(OTL_GPOS_TAG, resourceMgr, 
                                            &scriptList, 
                                            &featureList, 
                                            (otlLookupListTable*)NULL);
    if (ercGPos == OTL_SUCCESS)
        ercGPos = AppendFeatureDefs(OTL_GPOS_TAG, resourceMgr, 
                                    scriptList,  
                                    pRunProps->tagScript,
                                    pRunProps->tagLangSys,
                                    featureList, pliFDefs);

    
    // return greater error
    if (ERRORLEVEL(ercGSub) < ERRORLEVEL(ercGPos)) 
        return ercGPos; 
    else 
        return ercGSub;

}


OTL_EXPORT otlErrCode FreeOtlResources 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace   
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;
    
    return resourceMgr.freeResources();
}


OTL_EXPORT otlErrCode GetOtlLineSpacing 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,   
    const otlFeatureSet*    pFSet,
    
    long* pdvMax, 
    long* pdvMin
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pdvMax == (long*)NULL || pdvMin == (long*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    // get BASE
    otlBaseHeader base =  otlBaseHeader(resourceMgr.getOtlTable (OTL_BASE_TAG));
    if (base.isNull()) return  OTL_ERR_TABLE_NOT_FOUND;

    otlBaseScriptTable baseScript = otlBaseScriptTable((const BYTE*)NULL);
    if (pRunProps->metr.layout == otlRunLTR ||
        pRunProps->metr.layout == otlRunRTL)
    {
        baseScript = FindBaseScriptTable(base.horizAxis(), pRunProps->tagScript);
    }
    else
    {
        baseScript = FindBaseScriptTable(base.vertAxis(), pRunProps->tagScript);
    }

    if (baseScript.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }
    
    otlMinMaxTable minmaxTable = 
        FindMinMaxTable(baseScript, pRunProps->tagLangSys);
    if (minmaxTable.isNull())
    {
        return OTL_ERR_LANGSYS_NOT_FOUND;
    }

    long lMinCoord, lMaxCoord;
    lMinCoord = minmaxTable.minCoord().baseCoord(pRunProps->metr, resourceMgr);

    lMaxCoord = minmaxTable.maxCoord().baseCoord(pRunProps->metr, resourceMgr);

    if (pFSet != (otlFeatureSet*)NULL)
    {
        for(USHORT iFeature = 0; 
                   iFeature < pFSet->liFeatureDesc.length(); ++iFeature)
        {
            const otlFeatureDesc* pFeatureDesc = 
                readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);

            otlFeatMinMaxRecord featMinMax = 
                FindFeatMinMaxRecord(minmaxTable, pFeatureDesc->tagFeature);

            if (!featMinMax.isNull())
            {
                lMinCoord = MIN(lMinCoord, featMinMax.minCoord()
                      .baseCoord(pRunProps->metr, resourceMgr));

                lMaxCoord = MAX(lMinCoord, featMinMax.maxCoord()
                      .baseCoord(pRunProps->metr, resourceMgr));
            }
        }
    }

    *pdvMin = lMinCoord;
    *pdvMax = lMaxCoord;

    return OTL_SUCCESS;
}


OTL_EXPORT otlErrCode GetOtlBaselineOffsets 
    ( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,   
    otlList*            pliBaselines
    )
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliBaselines == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    // get BASE
    otlBaseHeader base =  otlBaseHeader(resourceMgr.getOtlTable (OTL_BASE_TAG));
    if (base.isNull()) return  OTL_ERR_TABLE_NOT_FOUND;

    otlAxisTable axisTable = otlAxisTable((const BYTE*)NULL);
    if (pRunProps->metr.layout == otlRunLTR ||
        pRunProps->metr.layout == otlRunRTL)
    {
        axisTable = base.horizAxis();
    }
    else
    {
        axisTable = base.vertAxis();
    }

    otlBaseScriptTable baseScript = 
        FindBaseScriptTable(axisTable, pRunProps->tagScript);

    if (baseScript.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }
    
    otlBaseTagListTable baseTagList = axisTable.baseTagList();
    
    USHORT cBaselines = baseTagList.baseTagCount();


    if (pliBaselines->maxLength() < cBaselines ||
        pliBaselines->dataSize() != sizeof(otlBaseline))
    {
        erc = resourceMgr.reallocOtlList(pliBaselines, 
                                         sizeof(otlBaseline), 
                                         cBaselines, 
                                         otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliBaselines->empty();


    otlBaseValuesTable baseValues = baseScript.baseValues();
    if (baseValues.isNull())
    {
        // no baselines -- nothing to report
        return OTL_SUCCESS;
    }
    
    if (cBaselines != baseValues.baseCoordCount())
    {
        assert(false);  // bad font -- the values should match up
        return OTL_ERR_BAD_FONT_TABLE;
    }
    

    for (USHORT iBaseline = 0; iBaseline < cBaselines; ++iBaseline)
    {
        otlBaseline baseline;

        baseline.tag = baseTagList.baselineTag(iBaseline);
        baseline.lCoordinate = baseValues.baseCoord(iBaseline)
                      .baseCoord(pRunProps->metr, resourceMgr);
        pliBaselines->append((const BYTE*)&baseline);
    }
        

    return OTL_SUCCESS;
}



OTL_EXPORT otlErrCode GetOtlCharAtPosition 
    ( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    const long          duAdv,
    
    USHORT*             piChar
    )
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliCharMap == (otlList*)NULL || pliGlyphInfo == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (piChar == (USHORT*)NULL) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) ||
        pliduGlyphAdv->dataSize() != sizeof(long) ||
        pliGlyphInfo->length() != pliduGlyphAdv->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    erc = GetCharAtPos(pliCharMap, pliGlyphInfo, pliduGlyphAdv, resourceMgr, 
                        duAdv, pRunProps->metr, piChar);
    if (erc != OTL_SUCCESS) return erc;

    return OTL_SUCCESS;
}



OTL_EXPORT otlErrCode GetOtlExtentOfChars ( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    USHORT              ichFirstChar,
    USHORT              ichLastChar,
    
    long*               pduStartPos,
    long*               pduEndPos
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliCharMap == (otlList*)NULL || pliGlyphInfo == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pduStartPos == (long*)NULL || pduEndPos == (long*)NULL) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) ||
        pliduGlyphAdv->dataSize() != sizeof(long) ||
        pliGlyphInfo->length() != pliduGlyphAdv->length() ||
        ichFirstChar > ichLastChar)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc; 
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    erc = GetPosOfChar(pliCharMap, pliGlyphInfo, pliduGlyphAdv, resourceMgr,                         
                        pRunProps->metr,
                        ichFirstChar, pduStartPos, pduEndPos);
    if (erc != OTL_SUCCESS) return erc;

    if (ichFirstChar != ichLastChar)
    {
        long duStartLastPos;
        erc = GetPosOfChar(pliCharMap, pliGlyphInfo, pliduGlyphAdv,resourceMgr,    
                            pRunProps->metr,
                            ichLastChar, &duStartLastPos, pduEndPos);
    }

    return erc;
}


OTL_EXPORT otlErrCode GetOtlFeatureParams ( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,

    const otlTag        tagFeature,
    
    long*               plGlobalParam,
    otlList*            pliFeatureParams
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliCharMap == (otlList*)NULL || pliGlyphInfo == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (plGlobalParam == (long*)NULL || pliFeatureParams == (otlList*)NULL) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    // REVIEW: -- feature parameters are not defined in the current spec
    // (TODO)   we probably should report information for alternative
    //          substitution parameters here
    *plGlobalParam = 0;
    pliFeatureParams->empty();

    return OTL_SUCCESS;
}


OTL_EXPORT otlErrCode SubstituteOtlChars ( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    const otlList*          pliChars,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    otlList*            pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL || 
        pliChars == (otlList*)NULL || pliCharMap == (otlList*)NULL ||
        (otlList*)pliGlyphInfo == NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliChars->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    // allocate lists for CMAP application
    //
    USHORT cChars = pliChars->length();

    if (pliGlyphInfo->maxLength() < cChars ||
        pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliGlyphInfo, 
                                                 sizeof(otlGlyphInfo), 
                                                 cChars, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliGlyphInfo->empty();
    pliGlyphInfo->insertAt(0, cChars);

    if (pliCharMap->maxLength() < cChars ||
        pliCharMap->dataSize() != sizeof(USHORT))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliCharMap, 
                                                 sizeof(USHORT), 
                                                 cChars, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliCharMap->empty();
    pliCharMap->insertAt(0, cChars);
    

    // initialize the glyph info
    erc = pRunProps->pClient->GetDefaultGlyphs(pliChars, pliGlyphInfo);
    if (erc != OTL_SUCCESS) return erc;

    if (pliChars->length() != pliGlyphInfo->length())
    {
        return OTL_ERR_INCONSISTENT_RUNLENGTH;
    }

    USHORT cGlyphs = pliGlyphInfo->length();

    // initialize info structures
    for (USHORT i = 0; i < cGlyphs; ++i)
    {
        *getOtlGlyphIndex(pliCharMap, i) = i;

        otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, i);

        pGlyphInfo->iChar = i;
        pGlyphInfo->cchLig = 1;
        pGlyphInfo->grf = otlUnresolved;
    }

    // assign glyph types
    // get GDEF
    otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

    erc = AssignGlyphTypes(pliGlyphInfo, gdef, 0, pliGlyphInfo->length(), 
                            otlDoAll);
    if (erc != OTL_SUCCESS) return erc;

    // we kill the resource manager here just so we can create 
    // another one in SubstituteOtlGlyphs
    resourceMgr.detach();  

    // no features -- no substitutions; we just set everything up
    if (pFSet == (otlFeatureSet*)NULL) return OTL_SUCCESS;

    // now do the substitutions
    erc = SubstituteOtlGlyphs (pRunProps, pliWorkspace, pFSet, 
                               pliCharMap, pliGlyphInfo, pliFResults);

    return erc;
}


OTL_EXPORT otlErrCode SubstituteOtlGlyphs ( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    otlList*            pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pFSet == (otlFeatureSet*)NULL || pliCharMap == (otlList*)NULL ||
        pliGlyphInfo == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) ||
        pliCharMap->dataSize() != sizeof(USHORT) ||
        pFSet->liFeatureDesc.dataSize() != sizeof(otlFeatureDesc))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pFSet->ichStart >= pliCharMap->length() || 
        pFSet->ichStart + pFSet->cchScope > pliCharMap->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliCharMap->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    if (pliFResults != (otlList*)NULL)
    {
        if (pliFResults->maxLength() < pFSet->liFeatureDesc.length() ||
            pliFResults->dataSize() != sizeof(otlFeatureResult))        
        {
            erc = pRunProps->pClient->ReallocOtlList(pliFResults, 
                                                     sizeof(otlFeatureResult), 
                                                     pFSet->liFeatureDesc.length(), 
                                                     otlDestroyContent);

            if (erc != OTL_SUCCESS) return erc;
        }
        pliFResults->empty();
        pliFResults->insertAt(0, pFSet->liFeatureDesc.length());
    }


    // get GDEF
    otlGDefHeader gdef =  otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

    erc = AssignGlyphTypes(pliGlyphInfo, gdef, 0, pliGlyphInfo->length(), 
                            otlDoUnresolved);
    if (erc != OTL_SUCCESS) return erc;


    erc = ApplyFeatures
            (
                OTL_GSUB_TAG,
                pFSet,
                pliCharMap,
                pliGlyphInfo,    
                resourceMgr,

                pRunProps->tagScript,
                pRunProps->tagLangSys,

                pRunProps->metr,        // not needed, but still pass
                (otlList*)NULL,             
                (otlList*)NULL, 

                pliFResults
            );

    return erc;

}


OTL_EXPORT otlErrCode PositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*        pliCharMap,         // these could be const except we may 
    otlList*        pliGlyphInfo,       // need to restore glyph flags
                                        // (and ApplyLokups doesn't take consts)

    otlList*        pliduGlyphAdv,
    otlList*        pliplcGlyphPlacement,

    otlList*        pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pFSet == (otlFeatureSet*)NULL || 
        pliGlyphInfo == (otlList*)NULL || pliCharMap == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL || pliplcGlyphPlacement == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) || 
        pliCharMap->dataSize() != sizeof(USHORT) ||
        pFSet->liFeatureDesc.dataSize() != sizeof(otlFeatureDesc))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pFSet->ichStart >= pliCharMap->length() || 
        pFSet->ichStart + pFSet->cchScope > pliCharMap->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliCharMap->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }


    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    const USHORT cGlyphs = pliGlyphInfo->length();

    if (pliduGlyphAdv->maxLength() < cGlyphs ||
        pliduGlyphAdv->dataSize() != sizeof(long))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliduGlyphAdv, 
                                                 sizeof(long), 
                                                 cGlyphs, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliduGlyphAdv->empty();
    pliduGlyphAdv->insertAt(0, cGlyphs);

    if (pliplcGlyphPlacement->maxLength() < cGlyphs ||
        pliplcGlyphPlacement->dataSize() != sizeof(otlPlacement))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliplcGlyphPlacement, 
                                                 sizeof(otlPlacement), 
                                                 cGlyphs, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliplcGlyphPlacement->empty();
    pliplcGlyphPlacement->insertAt(0, cGlyphs);
    
    // initialize advance and placement
    erc = pRunProps->pClient->GetDefaultAdv (pliGlyphInfo, pliduGlyphAdv);
    if (erc != OTL_SUCCESS) return erc;
    
    for (USHORT iGlyph = 0; iGlyph < cGlyphs; ++iGlyph)
    {
        otlPlacement* plc = getOtlPlacement(pliplcGlyphPlacement, iGlyph);

        plc->dx = 0;
        plc->dy = 0;
    }

    // reassign glyph types where necessary 
    // (so clients don't have to cache them)
    otlGDefHeader gdef = otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

    erc = AssignGlyphTypes(pliGlyphInfo, gdef, 
                            0, cGlyphs, otlDoUnresolved);
    if (erc != OTL_SUCCESS) return erc;

    // we kill the resource manager here just so we can create 
    // another one in RePositionOtlGlyphs
    resourceMgr.detach();
    
    // now everything's initialized, position!
    erc = RePositionOtlGlyphs (pRunProps, pliWorkspace, pFSet, 
                               pliCharMap, pliGlyphInfo, 
                               pliduGlyphAdv, pliplcGlyphPlacement, 
                               pliFResults);

    return erc;
        
}

OTL_EXPORT otlErrCode RePositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*        pliCharMap,          
    otlList*        pliGlyphInfo,       
                                        

    otlList*        pliduGlyphAdv,
    otlList*        pliplcGlyphPlacement,

    otlList*        pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pFSet == (otlFeatureSet*)NULL || 
        pliGlyphInfo == (otlList*)NULL || pliCharMap == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL || pliplcGlyphPlacement == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) || 
        pliCharMap->dataSize() != sizeof(USHORT) ||
        pFSet->liFeatureDesc.dataSize() != sizeof(otlFeatureDesc))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pFSet->ichStart >= pliCharMap->length() || 
        pFSet->ichStart + pFSet->cchScope > pliCharMap->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliCharMap->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliduGlyphAdv->length() != pliGlyphInfo->length() ||
        pliplcGlyphPlacement->length() != pliGlyphInfo->length())
    {
        return OTL_ERR_INCONSISTENT_RUNLENGTH;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    if (pliFResults != (otlList*)NULL)
    {
        if (pliFResults->maxLength() < pFSet->liFeatureDesc.length() ||
            pliFResults->dataSize() != sizeof(otlFeatureResult))        
        {
            erc = pRunProps->pClient->ReallocOtlList(pliFResults, 
                                                     sizeof(otlFeatureResult), 
                                                     pFSet->liFeatureDesc.length(), 
                                                     otlDestroyContent);

            if (erc != OTL_SUCCESS) return erc;
        }
        pliFResults->empty();
        pliFResults->insertAt(0, pFSet->liFeatureDesc.length());
    }

    // now apply features
    erc = ApplyFeatures
            (
                OTL_GPOS_TAG,
                pFSet,
                pliCharMap,
                pliGlyphInfo,   
                resourceMgr,

                pRunProps->tagScript,
                pRunProps->tagLangSys,

                pRunProps->metr,
                pliduGlyphAdv,              
                pliplcGlyphPlacement,   

                pliFResults
            );

    return erc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\pairpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  PAIRPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with pair positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetSecondGlyph = 0;
const OFFSET offsetPairValues = 2;

class otlPairValueRecord: otlTable
{
	const BYTE* pbMainTable;
	USHORT		grfValueFormat1;
	USHORT		grfValueFormat2;
public:

	otlPairValueRecord(USHORT format1, USHORT format2, 
					   const BYTE* table, const BYTE* pb)
		: otlTable(pb),
		  pbMainTable(table),
		  grfValueFormat1(format1),
		  grfValueFormat2(format2)
	{}

	otlGlyphID secondGlyph()
	{	return GlyphID(pbTable + offsetSecondGlyph); }

	otlValueRecord valueRecord1()
	{	return otlValueRecord(grfValueFormat1, pbMainTable, 
							  pbTable + offsetPairValues); }

	otlValueRecord valueRecord2()
	{	return otlValueRecord(grfValueFormat2, pbMainTable, 
							  pbTable + offsetPairValues 
								+ otlValueRecord::size(grfValueFormat1));
	}

	static size(USHORT grfFormat1, USHORT grfFormat2)
	{	return sizeof(otlGlyphID) + 
				otlValueRecord::size(grfFormat1) + 
				otlValueRecord::size(grfFormat2);
	}
};


const OFFSET offsetPairValueCount = 0;
const OFFSET offsetPairValueRecordArray = 2;

class otlPairSetTable: otlTable
{
	USHORT grfValueFormat1;
	USHORT grfValueFormat2;
public:

	otlPairSetTable(USHORT format1, USHORT format2, const BYTE* pb)
		: otlTable(pb),
		  grfValueFormat1(format1),
		  grfValueFormat2(format2)
	{}

	USHORT pairValueCount()
	{	return UShort(pbTable + offsetPairValueCount); }

	otlPairValueRecord pairValueRecord(USHORT index)
	{	assert(index < pairValueCount());
		return otlPairValueRecord(grfValueFormat1, grfValueFormat2, pbTable,
			pbTable + offsetPairValueRecordArray +
			index * otlPairValueRecord::size(grfValueFormat1, grfValueFormat2));
	}
};


const OFFSET offsetPairPosCoverage = 2;
const OFFSET offsetPairPosFormat1 = 4;
const OFFSET offsetPairPosFormat2 = 6;
const OFFSET offsetPairSetCount = 8;
const OFFSET offsetPairSetArray = 10;

class otlPairPosSubTable: otlLookupFormat
{
public:
	otlPairPosSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetPairPosCoverage)); }

	USHORT valueFormat1()
	{	return UShort(pbTable + offsetPairPosFormat1); }

	USHORT valueFormat2()
	{	return UShort(pbTable + offsetPairPosFormat2); }

	USHORT pairSetCount()
	{	return UShort(pbTable + offsetPairSetCount); }

	otlPairSetTable pairSet(USHORT index)
	{	assert(index < pairSetCount());
		return otlPairSetTable(valueFormat1(), valueFormat2(),
			   pbTable + Offset(pbTable + offsetPairSetArray 
										+ index * sizeof(OFFSET)));
	}
};


class otlClassValueRecord: otlTable
{
	const BYTE*	pbMainTable;
	USHORT		grfValueFormat1;
	USHORT		grfValueFormat2;
public:

	otlClassValueRecord(USHORT format1, USHORT format2, 
						const BYTE* table, const BYTE* pb)
		: otlTable(pb),
		  pbMainTable(table),
		  grfValueFormat1(format1),
		  grfValueFormat2(format2)
	{}

	otlValueRecord valueRecord1()
	{	return otlValueRecord(grfValueFormat1, pbMainTable, pbTable); }

	otlValueRecord valueRecord2()
	{	return otlValueRecord(grfValueFormat2, pbMainTable, 
							  pbTable + otlValueRecord::size(grfValueFormat1)); 
	}

	static size(USHORT grfFormat1, USHORT grfFormat2)
	{	return otlValueRecord::size(grfFormat1) +
			   otlValueRecord::size(grfFormat2);
	}
};


const OFFSET offsetClassPairPosCoverage = 2;
const OFFSET offsetClassPairPosFormat1 = 4;
const OFFSET offsetClassPairPosFormat2 = 6;
const OFFSET offsetClassPairPosClassDef1 = 8;
const OFFSET offsetClassPairPosClassDef2 = 10;
const OFFSET offsetClassPairPosClass1Count = 12;
const OFFSET offsetClassPairPosClass2Count = 14;
const OFFSET offsetClassPairPosValueRecordArray = 16;

class otlClassPairPosSubTable: otlLookupFormat
{
public:
	otlClassPairPosSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 2);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetClassPairPosCoverage)); 
	}

	USHORT valueFormat1()
	{	return UShort(pbTable + offsetClassPairPosFormat1); }

	USHORT valueFormat2()
	{	return UShort(pbTable + offsetClassPairPosFormat2); }

	otlClassDef classDef1()
	{	return otlClassDef(pbTable 
					+ Offset(pbTable + offsetClassPairPosClassDef1)); 
	}

	otlClassDef classDef2()
	{	return otlClassDef(pbTable 
					+ Offset(pbTable + offsetClassPairPosClassDef2)); 
	}

	USHORT class1Count()
	{	return UShort(pbTable + offsetClassPairPosClass1Count); }

	USHORT class2Count()
	{	return UShort(pbTable + offsetClassPairPosClass2Count); }

	otlClassValueRecord classRecord(USHORT index1, USHORT index2)
	{
		assert(index1 < class1Count());
		assert(index2 < class2Count());
		return otlClassValueRecord(valueFormat1(), valueFormat2(), pbTable, 
				pbTable + offsetClassPairPosValueRecordArray + 
				(index1 * class2Count() + index2) * 
					otlClassValueRecord::size(valueFormat1(), valueFormat2()));
	}
};


class otlPairPosLookup: otlLookupFormat
{
public:
	otlPairPosLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}
	
	otlErrCode apply
	(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\resource.h ===
/************************************************************************
*
*                    ********  RESOURCE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL resource management.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

enum otlResourceFlag
{
	otlBusy	=	0x0001
};

struct otlResources
{
	// a copy to ensure consistent processing
	// reset the workspace every time you change run props
	otlRunProp		RunProp;
	
	USHORT			grf;
	
	BYTE*			pbGSUB;
	BYTE*			pbGPOS;
	BYTE*			pbGDEF;
	BYTE*			pbBASE;

	// TODO: cache more than one contour point array!!!

	otlGlyphID		glLastGlyph;
	otlPlacement*	rgplcLastContourPtArray;
};


class otlResourceMgr
{
private:

	IOTLClient*			pClient;

	otlList*			pliWorkspace;

	// new not allowed
	void* operator new(size_t size);

public:

	otlResourceMgr()
		: pClient((IOTLClient*)NULL), 
		  pliWorkspace((otlList*)NULL)
	{}

	~otlResourceMgr();

	otlList* workspace () {	return pliWorkspace; }

	otlErrCode reallocOtlList
	(
	otlList*				pList,				// in/out 
	const USHORT			cbNewDataSize,		// in 
	const USHORT			celmNewMaxLen,		// in 
	otlReallocOptions		optPreserveContent	// in (may assert cbNewDataSize 
												//                == cbDataSize)
	)
	{
		return pClient->ReallocOtlList(pList, cbNewDataSize, 
										celmNewMaxLen, optPreserveContent);
	}	
		
	otlErrCode init(const otlRunProp* prp, otlList* workspace);

	void detach();

	const BYTE* getOtlTable (const otlTag tagTableName );

	otlPlacement* getPointCoords (const otlGlyphID glyph);

    BYTE*  getEnablesCacheBuf(USHORT cbSize);
    USHORT getEnablesCacheBufSize();

	otlErrCode freeResources ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\scrilang.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  SCRILANG.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements functions dealing with scripts and languages.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// returns a NULL script if not found
otlScriptTable FindScript
(
	const otlScriptListTable&	scriptList,
	otlTag						tagScript
)
{
	if (scriptList.isNull())
    {
        return otlScriptTable((const BYTE*)NULL);
    }
	
	USHORT cScripts = scriptList.scriptCount();

	for(USHORT iScript = 0; iScript < cScripts; ++iScript)
	{
		if (scriptList.scriptRecord(iScript).scriptTag() == tagScript)
		{
			return 	scriptList.scriptRecord(iScript).scriptTable();
		}
	}

	return otlScriptTable((const BYTE*)NULL);

}

// returns a NULL language system if not found
otlLangSysTable FindLangSys
(
	const otlScriptTable&	scriptTable,
	otlTag					tagLangSys
)
{
	assert(!scriptTable.isNull());
	
	if (tagLangSys == OTL_DEFAULT_TAG)
	{
		return scriptTable.defaultLangSys();
	}
	
	USHORT cLangSys = scriptTable.langSysCount();

	for(USHORT iLangSys = 0; iLangSys < cLangSys; ++iLangSys)
	{
		if (scriptTable.langSysRecord(iLangSys).langSysTag() == tagLangSys)
		{
			return 	scriptTable.langSysRecord(iLangSys).langSysTable();
		}
	}

	return otlLangSysTable((const BYTE*)NULL);
}


// helper function-- tells us if a tag is already in the list
bool isNewTag
(
	USHORT		cTagsToCheck,
	otlList*	pliTags,
	otlTag		newtag
)
{
	assert(pliTags != NULL);
	assert(pliTags->dataSize() == sizeof(otlTag));
	assert(cTagsToCheck <= pliTags->length());

	bool fTagFound = FALSE;
	for (USHORT iPrevTag = 0; iPrevTag < cTagsToCheck && !fTagFound; ++iPrevTag)
	{
		if (readOtlTag(pliTags, iPrevTag) == newtag)
		{
			fTagFound = true;
		}
	}

	return !fTagFound;
}


// append new script tags to the current list

otlErrCode AppendScriptTags
(
	const otlScriptListTable&		scriptList,

    otlList*						plitagScripts,
    otlResourceMgr&					resourceMgr   
)
{
	assert(plitagScripts != NULL);
	assert(plitagScripts->dataSize() == sizeof(otlTag));
	assert(plitagScripts->length() <= plitagScripts->maxLength());

	USHORT cPrevTags = plitagScripts->length();

	otlErrCode erc = OTL_SUCCESS;	
	
	if (scriptList.isNull())
		return OTL_ERR_TABLE_NOT_FOUND;

	USHORT cScripts = scriptList.scriptCount();


	// add tags that are new
	for (USHORT iScript = 0; iScript < cScripts; ++iScript)
	{
		otlTag newtag = scriptList.scriptRecord(iScript).scriptTag();

		if (isNewTag(cPrevTags, plitagScripts, newtag) )
		{
			// make sure we have the space
			if (plitagScripts->length() + 1 > plitagScripts->maxLength())
			{
				erc = resourceMgr.reallocOtlList(plitagScripts, 
												 plitagScripts->dataSize(), 
												 plitagScripts->maxLength() + 1, 
												 otlPreserveContent);

				if (erc != OTL_SUCCESS) return erc;
			}

			plitagScripts->append((BYTE*)&newtag);
		}
	}

	return OTL_SUCCESS;
}


// append new language system tags to the current list
otlErrCode AppendLangSysTags
(
	const otlScriptListTable&		scriptList,
	otlTag							tagScript,

    otlList*						plitagLangSys,
    otlResourceMgr&					resourceMgr   
)
{
	assert(plitagLangSys != NULL);
	assert(plitagLangSys->dataSize() == sizeof(otlTag));
	assert(plitagLangSys->length() <= plitagLangSys->maxLength());

	USHORT cPrevTags = plitagLangSys->length();
	otlErrCode erc = OTL_SUCCESS;

	if (scriptList.isNull())
		return OTL_ERR_TABLE_NOT_FOUND;

	otlScriptTable scriptTable = FindScript(scriptList, tagScript);
	if (scriptTable.isNull()) return OTL_ERR_SCRIPT_NOT_FOUND;

	USHORT cLangSys = scriptTable.langSysCount();


	// add lang sys tags that are new
	for (USHORT iLangSys = 0; iLangSys < cLangSys; ++iLangSys)
	{
		otlTag newtag = scriptTable.langSysRecord(iLangSys).langSysTag();

		if (isNewTag(cPrevTags, plitagLangSys, newtag))
		{
			// make sure we have the space
			// add one for the default lang sys
			if (plitagLangSys->length() + 1 > plitagLangSys->maxLength())
			{
				erc = resourceMgr.reallocOtlList(plitagLangSys, 
													plitagLangSys->dataSize(), 
													plitagLangSys->length() + 1, 
													otlPreserveContent);

				if (erc != OTL_SUCCESS) return erc;
			}
			plitagLangSys->append((BYTE*)&newtag);
		}
	}

	// add the 'dflt' if it's not there and is supported
	if (!scriptTable.defaultLangSys().isNull())
	{
		otlTag newtag = OTL_DEFAULT_TAG;
		if (isNewTag(cPrevTags, plitagLangSys, newtag))
		{
			if (plitagLangSys->length() + 1 > plitagLangSys->maxLength())
			{
				erc = resourceMgr.reallocOtlList(plitagLangSys, 
													plitagLangSys->dataSize(), 
													plitagLangSys->length() + 1, 
													otlPreserveContent);

				if (erc != OTL_SUCCESS) return erc;
			}
			plitagLangSys->append((BYTE*)&newtag);
		}
	}

	return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\pairpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  PAIRPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with pair adjustment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlPairPosLookup::apply
(
		otlList*					pliCharMap,
		otlList*					pliGlyphInfo,
		otlResourceMgr&				resourceMgr,

		USHORT						grfLookupFlags,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo != NULL);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(pliduGlyphAdv != NULL);
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliplcGlyphPlacement != NULL);
	assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

	assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
	assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

    // a simple check so we don't waste time; 2 is for 'pair'
    if (iglIndex + 2 > iglAfterLast)
    {
        return OTL_NOMATCH;
    }

	switch(format())
	{
	case(1):		// glyph pairs
		{
			otlPairPosSubTable pairPos = otlPairPosSubTable(pbTable);

			otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
			short index = pairPos.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));

			USHORT iglSecond = NextGlyphInLookup(pliGlyphInfo, 
												 grfLookupFlags, gdef, 
												 iglIndex + 1, otlForward);
			if (iglSecond  >= iglAfterLast)
			{
				return OTL_NOMATCH;
			}


			if (index > pairPos.pairSetCount())
			{
				assert(false);	// bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}
			otlPairSetTable pairSet = pairPos.pairSet(index);

			USHORT cSecondGlyphs = pairSet.pairValueCount();
			otlGlyphID glSecond = getOtlGlyphInfo(pliGlyphInfo, iglSecond)->glyph;
			for (USHORT iSecond = 0; iSecond < cSecondGlyphs; ++iSecond)
			{
				otlPairValueRecord pairRecord = pairSet.pairValueRecord(iSecond);
				
				if (pairRecord.secondGlyph() == glSecond)
				{
					pairRecord.valueRecord1()
						.adjustPos(metr,
								   getOtlPlacement(pliplcGlyphPlacement, iglIndex), 
								   getOtlAdvance(pliduGlyphAdv, iglIndex));

					pairRecord.valueRecord2()
						.adjustPos(metr, 
								   getOtlPlacement(pliplcGlyphPlacement, iglSecond), 
								   getOtlAdvance(pliduGlyphAdv, iglSecond));

					if (pairPos.valueFormat2() == 0)
					{
						*piglNextGlyph = iglIndex + 1;
					}
					else
					{
						*piglNextGlyph = iglSecond + 1;
					}
					return OTL_SUCCESS;
				}

			}

		return OTL_NOMATCH;
		}


	case(2):		// class pair adjustment
		{
			otlClassPairPosSubTable classPairPos = 
						otlClassPairPosSubTable(pbTable);

			otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
			short indexCoverage = 
				classPairPos.coverage().getIndex(pGlyphInfo->glyph);
			if (indexCoverage < 0)
			{
				return OTL_NOMATCH;
			}

			// get GDEF
			otlGDefHeader gdef =  
				otlGDefHeader(resourceMgr.getOtlTable (OTL_GDEF_TAG));
			
			USHORT iglSecond = NextGlyphInLookup(pliGlyphInfo, 
												 grfLookupFlags, gdef, 
												 iglIndex + 1, otlForward);
			if (iglSecond  >= iglAfterLast)
			{
				return OTL_NOMATCH;
			}


			USHORT iClass1 = classPairPos.classDef1().getClass(pGlyphInfo->glyph);
			if (iClass1 > classPairPos.class1Count())
			{
				assert(false);	// bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}

			otlGlyphID glSecond = getOtlGlyphInfo(pliGlyphInfo, iglSecond)->glyph;
			USHORT iClass2 = classPairPos.classDef2().getClass(glSecond);
			if (iClass2 > classPairPos.class2Count())
			{
				assert(false);	// bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}

			otlClassValueRecord classRecord = 
				classPairPos.classRecord(iClass1, iClass2);
			
			classRecord.valueRecord1()
				.adjustPos(metr, 
							getOtlPlacement(pliplcGlyphPlacement, iglIndex), 
							getOtlAdvance(pliduGlyphAdv, iglIndex));

			classRecord.valueRecord2()
				.adjustPos(metr, 
							getOtlPlacement(pliplcGlyphPlacement, iglSecond), 
							getOtlAdvance(pliduGlyphAdv, iglSecond));

			if (classPairPos.valueFormat2() == 0)
			{
				*piglNextGlyph = iglIndex + 1;
			}
			else
			{
				*piglNextGlyph = iglSecond + 1;
			}
			return OTL_SUCCESS;

		}


	default:
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\resource.cpp ===
/************************************************************************
*
*                    ********  RESOURCE.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL resource management.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

const otlGlyphID GLYPH_INVALID = (otlGlyphID)(-1);

otlErrCode otlResourceMgr::init(const otlRunProp *prp, otlList* workspace)
{
	if (workspace == (otlList*)NULL ||
		prp == (otlRunProp*)NULL)
	{
		return OTL_ERR_BAD_INPUT_PARAM;
	}

	otlErrCode erc;
	if (workspace->length() == 0)
	{
		if (workspace->maxLength() < sizeof(otlResources)|| 
			 workspace->dataSize() != sizeof(BYTE))
		{
			erc = prp->pClient->ReallocOtlList(workspace, sizeof(BYTE), 
												sizeof(otlResources), 
												otlDestroyContent);
			if (erc != OTL_SUCCESS) return erc;
		}
		workspace->insertAt(0, sizeof(otlResources));
	
		otlResources* pres = (otlResources*)workspace->data();

		// initialize newly constructured otlResources structure

		// copy the run properties for verification
		// one needs to re-initialize workspace every time they change 
		memcpy((void*)&pres->RunProp, (void*)prp, sizeof(otlResources));

		pres->pbBASE = pres->pbGDEF = pres->pbGPOS = pres->pbGSUB = (BYTE*)NULL;
		pres->grf = 0;
		pres->rgplcLastContourPtArray = (otlPlacement*)NULL;
		pres->glLastGlyph = GLYPH_INVALID;
	}
	else if (workspace->length() < sizeof(otlResources) || 
			 workspace->dataSize() != sizeof(BYTE))
	{
		return OTL_ERR_BAD_INPUT_PARAM;
	}

	otlResources* pres = (otlResources*)workspace->data();

	// make sure the workspace cache and run properties match
	// REVIEW: (AndreiB): so far disabled -- is it really the level of fool-proof we need?
//	if ((pres->RunProp).pClient != prp->pClient ||
//		pres->RunProp.metr.layout != prp->metr.layout ||
//		pres->RunProp.metr.cFUnits != prp->metr.cFUnits ||
//		pres->RunProp.metr.cPPEmX != prp->metr.cPPEmX ||
//		pres->RunProp.metr.cPPEmY != prp->metr.cPPEmY )
//	{
//		return OTL_ERR_BAD_INPUT_PARAM;
//	}

	if ((pres->grf & otlBusy) != 0)
	{
		return OTL_ERR_CANNOT_REENTER;
	}
	pres->grf |= otlBusy;

	pClient = prp->pClient;
	pliWorkspace = workspace;

	return OTL_SUCCESS;
}

otlResourceMgr::~otlResourceMgr()
{
	detach();
}

void otlResourceMgr::detach()
{
	if (pliWorkspace == (otlList*)NULL) 
	{
		return;
	}
	
	assert(pliWorkspace->dataSize() == sizeof(BYTE));
	assert(pliWorkspace->length() >= sizeof(otlResources));
	assert(pClient != (IOTLClient*)NULL);

	otlResources* pres = (otlResources*)pliWorkspace->data();

	// TODO -- move these to FreeOtlResources
	// (will need to call FreeOtlResources in OtlPad)

	if (pres->pbGSUB != NULL)
	{
		pClient->FreeOtlTable(pres->pbGSUB, OTL_GSUB_TAG);
	}
	if (pres->pbGPOS != NULL)
	{
		pClient->FreeOtlTable(pres->pbGPOS, OTL_GPOS_TAG);
	}
	if (pres->pbGDEF != NULL)
	{
		pClient->FreeOtlTable(pres->pbGDEF, OTL_GDEF_TAG);
	}
	if (pres->pbBASE != NULL)
	{
		pClient->FreeOtlTable(pres->pbBASE, OTL_BASE_TAG);
	}

	pres->pbBASE = pres->pbGDEF = pres->pbGPOS = pres->pbGSUB = (BYTE*)NULL;

	pres->grf &= ~otlBusy;

	// now null everything out to return to the "clean" state
	pClient = (IOTLClient*)NULL;
	pliWorkspace = (otlList*)NULL;
}


otlErrCode otlResourceMgr::freeResources ()
{
	assert(pliWorkspace->dataSize() == sizeof(BYTE));
	assert(pliWorkspace->length() >= sizeof(otlResources));

	otlResources* pres = (otlResources*)pliWorkspace->data();

	// (TODO) later on we will cache more glyph contour point arrays in 
	// the workspace list then we will free them all here

	if (pres->rgplcLastContourPtArray != NULL)
	{
		otlErrCode erc;
		erc = pClient->FreeGlyphPointCoords(pres->glLastGlyph, 
											pres->rgplcLastContourPtArray);
		if (erc != OTL_SUCCESS) return erc;

		pres->rgplcLastContourPtArray = (otlPlacement*)NULL;
		pres->glLastGlyph = GLYPH_INVALID;	
	}

	return OTL_SUCCESS;
}


const BYTE* otlResourceMgr::getOtlTable (const otlTag	tagTableName )
{
	assert(pliWorkspace->dataSize() == sizeof(BYTE));
	assert(pliWorkspace->length() >= sizeof(otlResources));

	BYTE** ppbTable;
	otlResources* pres = (otlResources*)pliWorkspace->data();

	if (tagTableName == OTL_GSUB_TAG)
	{
			ppbTable = &pres->pbGSUB;
	}
	else if (tagTableName == OTL_GPOS_TAG)
	{
			ppbTable = &pres->pbGPOS;
	}
	else if (tagTableName == OTL_GDEF_TAG)
	{
			ppbTable = &pres->pbGDEF;
	}
	else if (tagTableName == OTL_BASE_TAG)
	{
			ppbTable = &pres->pbBASE;
	}
	else
	{
		// we should not ask for any other table
		assert(false);
		return (const BYTE*)NULL;
	}

	// now ppbTable points to the right pointer
	if (*ppbTable == NULL)
		*ppbTable = pClient->GetOtlTable(tagTableName);

	return *ppbTable;
}


// called from inside OTL Services library
otlPlacement* otlResourceMgr::getPointCoords 
(
	const otlGlyphID	glyph
)
{
	assert(pliWorkspace->dataSize() == sizeof(BYTE));
	assert(pliWorkspace->length() >= sizeof(otlResources));

	otlResources* pres = (otlResources*)pliWorkspace->data();

	// for now, getting them one-by-one is good enough
	// we never need glyph coords for two points at the same time (REVIEW!)
	// (TODO) we will cache more of them and free on request later
	if (glyph != pres->glLastGlyph)
	{
		otlErrCode erc;
		if (pres->rgplcLastContourPtArray != NULL)
		{
			erc = pClient->FreeGlyphPointCoords(pres->glLastGlyph, 
												pres->rgplcLastContourPtArray);
			if (erc != OTL_SUCCESS) return (otlPlacement*)NULL;
		}
		pres->glLastGlyph = GLYPH_INVALID;	

		erc = pClient->GetGlyphPointCoords(glyph, &pres->rgplcLastContourPtArray);
		if (erc != OTL_SUCCESS) return (otlPlacement*)NULL;
		pres->glLastGlyph = glyph;
	}

	return pres->rgplcLastContourPtArray;

}

BYTE*  otlResourceMgr::getEnablesCacheBuf(USHORT cbSize)
{
	assert(pliWorkspace->dataSize() == sizeof(BYTE));
	assert(pliWorkspace->length() >= sizeof(otlResources));

    otlErrCode erc;

    if ( (sizeof(otlResources)+cbSize) > pliWorkspace->length() )
    {   
        erc = reallocOtlList(pliWorkspace,sizeof(BYTE),sizeof(otlResources)+cbSize,otlPreserveContent);
        if (erc != OTL_SUCCESS) return (BYTE*)NULL;
    }

    return (BYTE*)pliWorkspace->data() + sizeof(otlResources);
}

USHORT otlResourceMgr::getEnablesCacheBufSize()
{
	assert(pliWorkspace->dataSize() == sizeof(BYTE));
	assert(pliWorkspace->length() >= sizeof(otlResources));

    return pliWorkspace->length() - sizeof(otlResources);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\scrilang.h ===
/***********************************************************************
************************************************************************
*
*                    ********  SCRILANG.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of script and lang system tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetLookupOrder = 0;
const OFFSET offsetReqFeatureIndex = 2;
const OFFSET offsetLangFeatureCount = 4;
const OFFSET offsetLangFeatureIndexArray = 6;

class otlLangSysTable: public otlTable
{
public:

    otlLangSysTable(const BYTE* pb): otlTable(pb) {}

    USHORT reqFeatureIndex() const
    {   return UShort(pbTable + offsetReqFeatureIndex); }

    USHORT featureCount() const
    {   return UShort(pbTable + offsetLangFeatureCount); }

    USHORT featureIndex(USHORT index) const
    {   assert(index < featureCount());
        return UShort(pbTable + offsetLangFeatureIndexArray
                              + index*sizeof(USHORT));
    }
};


const OFFSET offsetLangSysTag = 0;
const OFFSET offsetLangSys = 4;

class otlLangSysRecord: public otlTable
{

private:
    const BYTE* pbScriptTable;

public:
    otlLangSysRecord(const BYTE* pbScript, const BYTE* pbRecord)
        : otlTable(pbRecord),
          pbScriptTable(pbScript)
    {
    }

    otlLangSysRecord& operator = (const otlLangSysRecord& copy)
    {
        pbTable = copy.pbTable;
        pbScriptTable = copy.pbScriptTable;
        return *this;
    }

    otlTag langSysTag() const
    {   return *(UNALIGNED otlTag*)(pbTable + offsetLangSysTag); }

    otlLangSysTable langSysTable() const
    {   return otlLangSysTable(pbScriptTable + Offset(pbTable + offsetLangSys)); }

};


const OFFSET offsetDefaultLangSys = 0;
const OFFSET offsetLangSysCount = 2;
const OFFSET offsetLangSysRecordArray = 4;
const OFFSET sizeLangSysRecord = 6;

class otlScriptTable: public otlTable
{
public:

    otlScriptTable(const BYTE* pb): otlTable(pb) {}

    otlLangSysTable defaultLangSys() const
    {   if (Offset(pbTable + offsetDefaultLangSys) == 0)
            return otlLangSysTable((const BYTE*)NULL);
        return otlLangSysTable(pbTable + Offset(pbTable + offsetDefaultLangSys));
    }

    USHORT langSysCount() const
    {   return UShort(pbTable + offsetLangSysCount); }

    otlLangSysRecord langSysRecord(USHORT index) const
    {   assert(index < langSysCount());
        return otlLangSysRecord(pbTable, pbTable + offsetLangSysRecordArray
                                                 + index*sizeLangSysRecord);
    }
};



const OFFSET offsetScriptTag = 0;
const OFFSET offsetScript = 4;

class otlScriptRecord: public otlTable
{
private:
    const BYTE* pbMainTable;

public:

    otlScriptRecord(const BYTE* pbList, const BYTE* pbRecord)
        : otlTable(pbRecord),
          pbMainTable(pbList)
    {
    }

    otlScriptRecord& operator = (const otlScriptRecord& copy)
    {
        pbTable = copy.pbTable;
        pbMainTable = copy.pbMainTable;
        return *this;
    }

    otlTag scriptTag() const
    {   return *(UNALIGNED otlTag*)(pbTable + offsetScriptTag); }

    otlScriptTable scriptTable() const
    {   return otlScriptTable(pbMainTable + Offset(pbTable + offsetScript)); }

};


const OFFSET offsetScriptCount = 0;
const OFFSET offsetScriptRecordArray = 2;
const USHORT sizeScriptRecord = 6;

class otlScriptListTable: public otlTable
{
public:

    otlScriptListTable(const BYTE* pb): otlTable(pb) {}

    USHORT scriptCount() const
    {   return UShort(pbTable + offsetScriptCount); }

    otlScriptRecord scriptRecord(USHORT index) const
    {   assert(index < scriptCount());
        return otlScriptRecord(pbTable,
                 pbTable + offsetScriptRecordArray + index*sizeScriptRecord); }
};


// helper functions

// returns a NULL script if not found
otlScriptTable FindScript
(
    const otlScriptListTable&   scriptList,
    otlTag                      tagScript
);

// returns a NULL language system if not found
otlLangSysTable FindLangSys
(
    const otlScriptTable&   scriptTable,
    otlTag                  tagLangSys
);

// append script tags to the otl list; ask for more memory if needed
otlErrCode AppendScriptTags
(
    const otlScriptListTable&       scriptList,

    otlList*                        plitagScripts,
    otlResourceMgr&                 resourceMgr
);

// append lang system tags to the otl list; ask for more memory if needed
// the desired script is in prp->tagScript
otlErrCode AppendLangSysTags
(
    const otlScriptListTable&       scriptList,
    otlTag                          tagScript,

    otlList*                        plitagLangSys,
    otlResourceMgr&                 resourceMgr
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\singlsub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLSUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlSingleSubstLookup::apply
(
	otlList*					pliGlyphInfo,

	USHORT						iglIndex,
	USHORT						iglAfterLast,

	USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	switch(format())
	{
	case(1):		// calculated
		{
			otlCalculatedSingleSubTable calcSubst = 
					otlCalculatedSingleSubTable(pbTable);
			otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
			
			short index = calcSubst.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			pGlyphInfo->glyph += calcSubst.deltaGlyphID();

			*piglNextGlyph = iglIndex + 1;
			return OTL_SUCCESS;
		}


	case(2):		// glyph list
		{
			otlListSingleSubTable listSubst = otlListSingleSubTable(pbTable);
			otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
			
			short index = listSubst.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			if (index > listSubst.glyphCount())
			{
				assert(false); // bad font
				return OTL_ERR_BAD_FONT_TABLE;
			}

			pGlyphInfo->glyph = listSubst.substitute(index);

			*piglNextGlyph = iglIndex + 1;
			return OTL_SUCCESS;
		}

	default:
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\singlpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetSinglPosCoverage = 2;
const OFFSET offsetSinglePosValueFormat = 4;
const OFFSET offsetSinglePosValueRecord = 6;

class otlOneSinglePosSubTable: otlLookupFormat
{
public:
	otlOneSinglePosSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + Offset(pbTable + offsetSinglPosCoverage)); }

	USHORT valueFormat()
	{	return UShort(pbTable + offsetSinglePosValueFormat); }

	otlValueRecord valueRecord()
	{	return otlValueRecord(valueFormat(), pbTable, 
					pbTable + offsetSinglePosValueRecord); 
	}
};


const OFFSET offsetSinglPosArrayCoverage = 2;
const OFFSET offsetSinglePosArrayValueFormat = 4;
const OFFSET offsetSinglePosArrayValueCount = 6;
const OFFSET offsetSinglePosValueRecordArray = 8;

class otlSinglePosArraySubTable: otlLookupFormat
{
public:
	otlSinglePosArraySubTable(const BYTE* pb): otlLookupFormat(pb)
	{
		assert(format() == 2);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable 
					+ Offset(pbTable + offsetSinglPosArrayCoverage)); 
	}

	USHORT valueFormat()
	{	return UShort(pbTable + offsetSinglePosArrayValueFormat); }

	USHORT valueCount()
	{	return UShort(pbTable + offsetSinglePosArrayValueCount); }

	otlValueRecord valueRecord(USHORT index)
	{	assert(index < valueCount());	
		return otlValueRecord(valueFormat(), pbTable, 
							  pbTable + offsetSinglePosValueRecordArray
							+ index * otlValueRecord::size(valueFormat())); 
	}
	
};


class otlSinglePosLookup: otlLookupFormat
{
public:
	otlSinglePosLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}
	
	otlErrCode apply
	(
		otlList*					pliGlyphInfo,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
	);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\singlpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single positioning lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlSinglePosLookup::apply
(
		otlList*					pliGlyphInfo,

		const otlMetrics&			metr,		
		otlList*					pliduGlyphAdv,				
		otlList*					pliplcGlyphPlacement,		

		USHORT						iglIndex,
		USHORT						iglAfterLast,

		USHORT*						piglNextGlyph		// out: next glyph
)
{
	assert(pliGlyphInfo != NULL);
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

	assert(pliduGlyphAdv != NULL);
	assert(pliduGlyphAdv->dataSize() == sizeof(long));
	assert(pliplcGlyphPlacement != NULL);
	assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

	assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
	assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

	assert(iglAfterLast > iglIndex);
	assert(iglAfterLast <= pliGlyphInfo->length());

	switch(format())
	{
	case(1):		// one value record
		{
			otlOneSinglePosSubTable onePos = otlOneSinglePosSubTable(pbTable);

			otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
			short index = onePos.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			long* pduDAdv = getOtlAdvance(pliduGlyphAdv, iglIndex);
			otlPlacement* pplc = getOtlPlacement(pliplcGlyphPlacement, iglIndex);
			
			onePos.valueRecord().adjustPos(metr, pplc, pduDAdv);

			*piglNextGlyph = iglIndex + 1;
			return OTL_SUCCESS;
		}


	case(2):		// value record array
		{
			otlSinglePosArraySubTable arrayPos = 
					otlSinglePosArraySubTable(pbTable);

			otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);

			short index = arrayPos.coverage().getIndex(pGlyphInfo->glyph);
			if (index < 0)
			{
				return OTL_NOMATCH;
			}

			if (index >= arrayPos.valueCount())
			{
				assert(false); // bad font table;
				return OTL_ERR_BAD_FONT_TABLE;
			}

			long* pduDAdv = getOtlAdvance(pliduGlyphAdv, iglIndex);
			otlPlacement* pplc = getOtlPlacement(pliplcGlyphPlacement, iglIndex);
			
			arrayPos.valueRecord(index).adjustPos(metr, pplc, pduDAdv);

			*piglNextGlyph = iglIndex + 1;
			return OTL_SUCCESS;
		}

	default:
		assert(false);
		return OTL_ERR_BAD_FONT_TABLE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\gpotls\pch.h ===
/***********************************************************************
************************************************************************
*
*                    ********  PCH.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This header includes all other headers in the right order
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#define OTL_CONSTANT    const

#include "runtime.hpp"   // GdiPlus runtime, including private memory allocation

#define GDIPLUS     1
#include "text_rt.h"


#define assert ASSERT


#include "otllib.h"

#include "common.h"
#include "common.inl"

#include "resource.h"

#include "coverage.h"
#include "classdef.h"
#include "device.h"

#include "base.h"

#include "scrilang.h"
#include "lookups.h"
#include "features.h"

#include "GDEF.h"
#include "GSUB.h"
#include "GPOS.h"

#include "apply.h"
#include "measure.h"

/***********************************************************************/

#include "singlsub.h"
#include "multisub.h"
#include "altersub.h"
#include "ligasub.h"

#include "singlpos.h"
#include "pairpos.h"
#include "cursipos.h"
#include "mkbaspos.h"
#include "mkligpos.h"
#include "mkmkpos.h"

#include "context.h"
#include "chaining.h"
#include "extension.h"

/***********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\sources.inc ===
!include "..\..\..\..\sources.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\otls\pch.h ===
/***********************************************************************
************************************************************************
*
*                    ********  PCH.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This header includes all other headers in the right order
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#define OTL_CONSTANT    const

#include "text_rt.h"

#include "otllib.h"

#include "common.h"
#include "common.inl"

#include "resource.h"

#include "coverage.h"
#include "classdef.h"
#include "device.h"

#include "base.h"

#include "scrilang.h"
#include "lookups.h"
#include "features.h"

#include "GDEF.h"
#include "GSUB.h"
#include "GPOS.h"

#include "apply.h"
#include "measure.h"

/***********************************************************************/

#include "singlsub.h"
#include "multisub.h"
#include "altersub.h"
#include "ligasub.h"

#include "singlpos.h"
#include "pairpos.h"
#include "cursipos.h"
#include "mkbaspos.h"
#include "mkligpos.h"
#include "mkmkpos.h"

#include "context.h"
#include "chaining.h"
#include "extension.h"

/***********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\otls\singlsub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLSUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetCalculatedSingleCoverage = 2;
const OFFSET offsetDeltaGlyphID = 4;

class otlCalculatedSingleSubTable: otlLookupFormat
{
public:

	otlCalculatedSingleSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 1);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + 
					Offset(pbTable + offsetCalculatedSingleCoverage));
	}

	short deltaGlyphID()
	{	return SShort(pbTable + offsetDeltaGlyphID); }
};

const OFFSET offsetListSingleSubTableCoverage = 2;
const OFFSET offsetSingleGlyphCount = 4;
const OFFSET offsetSingleSubstituteArray = 6;

class otlListSingleSubTable: otlLookupFormat
{
public:

	otlListSingleSubTable(const BYTE* pb): otlLookupFormat(pb) 
	{
		assert(format() == 2);
	}

	otlCoverage coverage()
	{	return otlCoverage(pbTable + 
					Offset(pbTable + offsetListSingleSubTableCoverage));
	}
	

	USHORT glyphCount()
	{	return UShort(pbTable + offsetSingleGlyphCount); }

	otlGlyphID substitute(USHORT index)
	{	assert(index < glyphCount());
		return GlyphID(pbTable + offsetSingleSubstituteArray 
								+ index * sizeof(otlGlyphID));
	}
};


class otlSingleSubstLookup: otlLookupFormat
{
public:

	otlSingleSubstLookup(otlLookupFormat subtable)
		: otlLookupFormat(subtable.pbTable) 
	{}
	
	otlErrCode apply
	(
	otlList*			pliGlyphInfo,

	USHORT				iglIndex,
	USHORT				iglAfterLast,

	USHORT*				piglNextGlyph		// out: next glyph
	);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\unilib\linebreakclass.cxx ===
//
// This is a generated file.  Do not modify by hand.
//
// Copyright (c) 2000  Microsoft Corporation
//
// Generating script: breakclass_extract.pl
// Generated on Wed Jun  6 01:24:48 2001
//

#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif // !X__UNIPART_H

#include "brkclass.hxx"


const unsigned short BreakClassFromCharClassNarrow[CHAR_CLASS_UNICODE_MAX] =
{
    1   ,  // (  0) WOB_ - Open brackets for inline-note
    1   ,  // (  1) NOPP - Open parenthesis
    1   ,  // (  2) NOPA - Open parenthesis
    1   ,  // (  3) NOPW - Open parenthesis
    1   ,  // (  4) HOP_ - Open parenthesis
    1   ,  // (  5) WOP_ - Open parenthesis
    1   ,  // (  6) WOP5 - Open parenthesis, Big 5
    14  ,  // (  7) NOQW - Open quotes
    14  ,  // (  8) AOQW - Open quotes
    1   ,  // (  9) WOQ_ - Open quotes
    2   ,  // ( 10) WCB_ - Close brackets for inline-note
    2   ,  // ( 11) NCPP - Close parenthesis
    2   ,  // ( 12) NCPA - Close parenthesis
    2   ,  // ( 13) NCPW - Close parenthesis
    2   ,  // ( 14) HCP_ - Close parenthesis
    2   ,  // ( 15) WCP_ - Close parenthesis
    2   ,  // ( 16) WCP5 - Close parenthesis, Big 5
    14  ,  // ( 17) NCQW - Close quotes
    14  ,  // ( 18) ACQW - Close quotes
    2   ,  // ( 19) WCQ_ - Close quotes
    14  ,  // ( 20) ARQW - Right single quotation mark
    15  ,  // ( 21) NCSA - Comma
    2   ,  // ( 22) HCO_ - Comma
    2   ,  // ( 23) WC__ - Comma
    2   ,  // ( 24) WCS_ - Comma
    2   ,  // ( 25) WC5_ - Comma, Big 5
    2   ,  // ( 26) WC5S - Comma, Big 5
    3   ,  // ( 27) NKS_ - Kana Sound marks
    3   ,  // ( 28) WKSM - Kana Sound marks
    3   ,  // ( 29) WIM_ - Iteration mark
    3   ,  // ( 30) NSSW - Symbols which can't start a line
    3   ,  // ( 31) WSS_ - Symbols which can't start a line
    3   ,  // ( 32) WHIM - Hiragana iteration marks
    3   ,  // ( 33) WKIM - Katakana iteration marks
    3   ,  // ( 34) NKSL - Katakana that can't start a line
    3   ,  // ( 35) WKS_ - Katakana that can't start a line
    20  ,  // ( 36) WKSC - Katakana that can't start a line
    3   ,  // ( 37) WHS_ - Hiragana that can't start a line
    4   ,  // ( 38) NQFP - Question/exclamation
    4   ,  // ( 39) NQFA - Question/exclamation
    3   ,  // ( 40) WQE_ - Question/exclamation
    3   ,  // ( 41) WQE5 - Question/exclamation, Big 5
    3   ,  // ( 42) NKCC - Kana centered characters
    3   ,  // ( 43) WKC_ - Kana centered characters
    15  ,  // ( 44) NOCP - Other centered characters
    15  ,  // ( 45) NOCA - Other centered characters
    15  ,  // ( 46) NOCW - Other centered characters
    3   ,  // ( 47) WOC_ - Other centered characters
    3   ,  // ( 48) WOCS - Other centered characters
    3   ,  // ( 49) WOC5 - Other centered characters, Big 5
    3   ,  // ( 50) WOC6 - Other centered characters, Big 5
    3   ,  // ( 51) AHPW - Hyphenation point
    15  ,  // ( 52) NPEP - Period
    15  ,  // ( 53) NPAR - Period
    3   ,  // ( 54) HPE_ - Period
    3   ,  // ( 55) WPE_ - Period
    3   ,  // ( 56) WPES - Period
    3   ,  // ( 57) WPE5 - Period, Big 5
    5   ,  // ( 58) NISW - Inseparable characters
    5   ,  // ( 59) AISW - Inseparable characters
    12  ,  // ( 60) NQCS - Glue characters
    12  ,  // ( 61) NQCW - Glue characters
    12  ,  // ( 62) NQCC - Glue characters
    6   ,  // ( 63) NPTA - Prefix currencies and symbols
    6   ,  // ( 64) NPNA - Prefix currencies and symbols
    6   ,  // ( 65) NPEW - Prefix currencies and symbols
    6   ,  // ( 66) NPEH - Prefix currencies and symbols
    6   ,  // ( 67) NPEV - Prefix currencies and symbols
    6   ,  // ( 68) APNW - Prefix currencies and symbols
    6   ,  // ( 69) HPEW - Prefix currencies and symbols
    6   ,  // ( 70) WPR_ - Prefix currencies and symbols
    7   ,  // ( 71) NQEP - Postfix currencies and symbols
    7   ,  // ( 72) NQEW - Postfix currencies and symbols
    7   ,  // ( 73) NQNW - Postfix currencies and symbols
    7   ,  // ( 74) AQEW - Postfix currencies and symbols
    7   ,  // ( 75) AQNW - Postfix currencies and symbols
    7   ,  // ( 76) AQLW - Postfix currencies and symbols
    7   ,  // ( 77) WQO_ - Postfix currencies and symbols
    21  ,  // ( 78) NSBL - Space
    8   ,  // ( 79) WSP_ - Space
    8   ,  // ( 80) WHI_ - Hiragana, except small letters
    8   ,  // ( 81) NKA_ - Katakana, except small letters
    8   ,  // ( 82) WKA_ - Katakana, except small letters
    11  ,  // ( 83) ASNW - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 84) ASEW - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 85) ASRN - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 86) ASEN - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 87) ALA_ - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 88) AGR_ - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 89) ACY_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 90) WID_ - Han Ideographs
    8   ,  // ( 91) WPUA - End user defined characters
    16  ,  // ( 92) NHG_ - Hangul Ideographs
    16  ,  // ( 93) WHG_ - Hangul Ideographs
    8   ,  // ( 94) WCI_ - Compatibility Ideographs
    8   ,  // ( 95) NOI_ - Other Ideographs
    8   ,  // ( 96) WOI_ - Other Ideographs
    20  ,  // ( 97) WOIC - Other Ideographs
    8   ,  // ( 98) WOIL - Other Ideographs
    8   ,  // ( 99) WOIS - Other Ideographs
    8   ,  // (100) WOIT - Other Ideographs
    11  ,  // (101) NSEN - Super/subscript/attachment characters
    11  ,  // (102) NSET - Super/subscript/attachment characters
    11  ,  // (103) NSNW - Super/subscript/attachment characters
    11  ,  // (104) ASAN - Super/subscript/attachment characters
    11  ,  // (105) ASAE - Super/subscript/attachment characters
    9   ,  // (106) NDEA - Digits
    8   ,  // (107) WD__ - Digits
    11  ,  // (108) NLLA - Basic Latin
    8   ,  // (109) WLA_ - Basic Latin
    10  ,  // (110) NWBL - Word breaking spaces
    10  ,  // (111) NWZW - Word breaking spaces
    11  ,  // (112) NPLW - Punctuation in text
    11  ,  // (113) NPZW - Punctuation in text
    11  ,  // (114) NPF_ - Punctuation in text
    11  ,  // (115) NPFL - Punctuation in text
    11  ,  // (116) NPNW - Punctuation in text
    11  ,  // (117) APLW - Punctuation in text
    20  ,  // (118) APCO - Punctuation in text
    10  ,  // (119) ASYW - Soft Hyphen
    10  ,  // (120) NHYP - Hyphen
    10  ,  // (121) NHYW - Hyphen
    10  ,  // (122) AHYW - Hyphen
    14  ,  // (123) NAPA - Apostrophe
    14  ,  // (124) NQMP - Quotation mark
    13  ,  // (125) NSLS - Slash
    10  ,  // (126) NSF_ - Non space word break
    10  ,  // (127) NSBB - Non space word break
    10  ,  // (128) NSBS - Non space word break
    11  ,  // (129) NLA_ - Latin
    11  ,  // (130) NLQ_ - Latin Punctuation in text
    20  ,  // (131) NLQC - Latin Punctuation in text
    11  ,  // (132) NLQN - Latin Punctuation in text
    11  ,  // (133) ALQ_ - Latin Punctuation in text
    11  ,  // (134) ALQN - Latin Punctuation in text
    11  ,  // (135) NGR_ - Greek
    11  ,  // (136) NGRN - Greek
    11  ,  // (137) NGQ_ - Greek Punctuation in text
    11  ,  // (138) NGQN - Greek Punctuation in text
    11  ,  // (139) NCY_ - Cyrillic
    11  ,  // (140) NCYP - Cyrillic Punctuation in text
    20  ,  // (141) NCYC - Cyrillic Punctuation in text
    11  ,  // (142) NAR_ - Armenian
    11  ,  // (143) NAQL - Armenian Punctuation in text
    11  ,  // (144) NAQN - Armenian Punctuation in text
    11  ,  // (145) NHB_ - Hebrew
    20  ,  // (146) NHBC - Hebrew
    11  ,  // (147) NHBW - Hebrew
    11  ,  // (148) NHBR - Hebrew
    11  ,  // (149) NASR - Arabic
    11  ,  // (150) NAAR - Arabic
    20  ,  // (151) NAAC - Arabic
    9   ,  // (152) NAAD - Arabic
    9   ,  // (153) NAED - Arabic
    11  ,  // (154) NANW - Arabic
    11  ,  // (155) NAEW - Arabic
    11  ,  // (156) NAAS - Arabic
    11  ,  // (157) NHI_ - Devanagari
    11  ,  // (158) NHIN - Devanagari
    20  ,  // (159) NHIC - Devanagari
    9   ,  // (160) NHID - Devanagari
    11  ,  // (161) NBE_ - Bengali
    20  ,  // (162) NBEC - Bengali
    9   ,  // (163) NBED - Bengali
    6   ,  // (164) NBET - Bengali
    11  ,  // (165) NGM_ - Gurmukhi
    20  ,  // (166) NGMC - Gurmukhi
    9   ,  // (167) NGMD - Gurmukhi
    11  ,  // (168) NGJ_ - Gujarati
    20  ,  // (169) NGJC - Gujarati
    9   ,  // (170) NGJD - Gujarati
    11  ,  // (171) NOR_ - Oriya
    20  ,  // (172) NORC - Oriya
    9   ,  // (173) NORD - Oriya
    11  ,  // (174) NTA_ - Tamil
    20  ,  // (175) NTAC - Tamil
    9   ,  // (176) NTAD - Tamil
    11  ,  // (177) NTE_ - Telugu
    20  ,  // (178) NTEC - Telugu
    9   ,  // (179) NTED - Telugu
    11  ,  // (180) NKD_ - Kannada
    20  ,  // (181) NKDC - Kannada
    9   ,  // (182) NKDD - Kannada
    11  ,  // (183) NMA_ - Malayalam
    20  ,  // (184) NMAC - Malayalam
    9   ,  // (185) NMAD - Malayalam
    19  ,  // (186) NTH_ - Thai
    19  ,  // (187) NTHC - Thai
    9   ,  // (188) NTHD - Thai
    7   ,  // (189) NTHT - Thai
    11  ,  // (190) NLO_ - Lao
    20  ,  // (191) NLOC - Lao
    9   ,  // (192) NLOD - Lao
    11  ,  // (193) NTI_ - Tibetan
    20  ,  // (194) NTIC - Tibetan
    9   ,  // (195) NTID - Tibetan
    11  ,  // (196) NTIN - Tibetan
    11  ,  // (197) NGE_ - Georgian
    11  ,  // (198) NGEQ - Georgian Punctuation in text
    11  ,  // (199) NBO_ - Bopomofo
    12  ,  // (200) NBSP - No Break space
    12  ,  // (201) NBSS - No Break space
    11  ,  // (202) NOF_ - Other symbols
    11  ,  // (203) NOBS - Other symbols
    11  ,  // (204) NOEA - Other symbols
    11  ,  // (205) NONA - Other symbols
    11  ,  // (206) NONP - Other symbols
    11  ,  // (207) NOEP - Other symbols
    11  ,  // (208) NONW - Other symbols
    11  ,  // (209) NOEW - Other symbols
    11  ,  // (210) NOLW - Other symbols
    20  ,  // (211) NOCO - Other symbols
    11  ,  // (212) NOEN - Other symbols
    11  ,  // (213) NOBN - Other symbols
    11  ,  // (214) NSBN - Other symbols
    11  ,  // (215) NOLE - Other symbols
    11  ,  // (216) NORE - Other symbols
    11  ,  // (217) NOPF - Other symbols
    11  ,  // (218) NOLO - Other symbols
    11  ,  // (219) NORO - Other symbols
    11  ,  // (220) NET_ - Ethiopic
    22  ,  // (221) NETP - Ethiopic
    9   ,  // (222) NETD - Ethiopic
    11  ,  // (223) NCA_ - Canadian Syllabics
    11  ,  // (224) NCH_ - Cherokee
    8   ,  // (225) WYI_ - Yi
    8   ,  // (226) WYIN - Yi
    11  ,  // (227) NBR_ - Braille
    11  ,  // (228) NRU_ - Runic
    11  ,  // (229) NOG_ - Oghma
    11  ,  // (230) NOGS - Oghma
    11  ,  // (231) NOGN - Oghma
    11  ,  // (232) NSI_ - Sinhala
    20  ,  // (233) NSIC - Sinhala
    11  ,  // (234) NTN_ - Thaana
    20  ,  // (235) NTNC - Thaana
    11  ,  // (236) NKH_ - Khmer
    20  ,  // (237) NKHC - Khmer
    9   ,  // (238) NKHD - Khmer
    6   ,  // (239) NKHT - Khmer
    11  ,  // (240) NBU_ - Burmese
    20  ,  // (241) NBUC - Burmese
    9   ,  // (242) NBUD - Burmese
    11  ,  // (243) NSY_ - Syriac
    11  ,  // (244) NSYP - Syriac
    20  ,  // (245) NSYC - Syriac
    11  ,  // (246) NSYW - Syriac
    11  ,  // (247) NMO_ - Mongolian
    20  ,  // (248) NMOC - Mongolian
    9   ,  // (249) NMOD - Mongolian
    11  ,  // (250) NMOB - Mongolian
    11  ,  // (251) NMON - Mongolian
    11  ,  // (252) NHS_ - High Surrogate
    8   ,  // (253) WHT_ - High Surrogate
    20  ,  // (254) LS__ - Low Surrogate
    11  ,  // (255) XNW_ - Undefined or reserved characters
    11  ,  // (256) XNWA - Undefined or reserved characters
    11  ,  // (257) XNWB - Undefined or reserved characters
};


const unsigned short BreakClassFromCharClassWide[CHAR_CLASS_UNICODE_MAX] =
{
    1   ,  // (  0) WOB_ - Open brackets for inline-note
    1   ,  // (  1) NOPP - Open parenthesis
    1   ,  // (  2) NOPA - Open parenthesis
    1   ,  // (  3) NOPW - Open parenthesis
    1   ,  // (  4) HOP_ - Open parenthesis
    1   ,  // (  5) WOP_ - Open parenthesis
    1   ,  // (  6) WOP5 - Open parenthesis, Big 5
    14  ,  // (  7) NOQW - Open quotes
    1   ,  // (  8) AOQW - Open quotes
    1   ,  // (  9) WOQ_ - Open quotes
    2   ,  // ( 10) WCB_ - Close brackets for inline-note
    2   ,  // ( 11) NCPP - Close parenthesis
    2   ,  // ( 12) NCPA - Close parenthesis
    2   ,  // ( 13) NCPW - Close parenthesis
    2   ,  // ( 14) HCP_ - Close parenthesis
    2   ,  // ( 15) WCP_ - Close parenthesis
    2   ,  // ( 16) WCP5 - Close parenthesis, Big 5
    14  ,  // ( 17) NCQW - Close quotes
    2   ,  // ( 18) ACQW - Close quotes
    2   ,  // ( 19) WCQ_ - Close quotes
    2   ,  // ( 20) ARQW - Right single quotation mark
    15  ,  // ( 21) NCSA - Comma
    2   ,  // ( 22) HCO_ - Comma
    2   ,  // ( 23) WC__ - Comma
    2   ,  // ( 24) WCS_ - Comma
    2   ,  // ( 25) WC5_ - Comma, Big 5
    2   ,  // ( 26) WC5S - Comma, Big 5
    3   ,  // ( 27) NKS_ - Kana Sound marks
    3   ,  // ( 28) WKSM - Kana Sound marks
    3   ,  // ( 29) WIM_ - Iteration mark
    3   ,  // ( 30) NSSW - Symbols which can't start a line
    3   ,  // ( 31) WSS_ - Symbols which can't start a line
    3   ,  // ( 32) WHIM - Hiragana iteration marks
    3   ,  // ( 33) WKIM - Katakana iteration marks
    3   ,  // ( 34) NKSL - Katakana that can't start a line
    3   ,  // ( 35) WKS_ - Katakana that can't start a line
    20  ,  // ( 36) WKSC - Katakana that can't start a line
    3   ,  // ( 37) WHS_ - Hiragana that can't start a line
    4   ,  // ( 38) NQFP - Question/exclamation
    4   ,  // ( 39) NQFA - Question/exclamation
    3   ,  // ( 40) WQE_ - Question/exclamation
    3   ,  // ( 41) WQE5 - Question/exclamation, Big 5
    3   ,  // ( 42) NKCC - Kana centered characters
    3   ,  // ( 43) WKC_ - Kana centered characters
    15  ,  // ( 44) NOCP - Other centered characters
    15  ,  // ( 45) NOCA - Other centered characters
    15  ,  // ( 46) NOCW - Other centered characters
    3   ,  // ( 47) WOC_ - Other centered characters
    3   ,  // ( 48) WOCS - Other centered characters
    3   ,  // ( 49) WOC5 - Other centered characters, Big 5
    3   ,  // ( 50) WOC6 - Other centered characters, Big 5
    3   ,  // ( 51) AHPW - Hyphenation point
    15  ,  // ( 52) NPEP - Period
    15  ,  // ( 53) NPAR - Period
    3   ,  // ( 54) HPE_ - Period
    3   ,  // ( 55) WPE_ - Period
    3   ,  // ( 56) WPES - Period
    3   ,  // ( 57) WPE5 - Period, Big 5
    5   ,  // ( 58) NISW - Inseparable characters
    5   ,  // ( 59) AISW - Inseparable characters
    12  ,  // ( 60) NQCS - Glue characters
    12  ,  // ( 61) NQCW - Glue characters
    12  ,  // ( 62) NQCC - Glue characters
    6   ,  // ( 63) NPTA - Prefix currencies and symbols
    6   ,  // ( 64) NPNA - Prefix currencies and symbols
    6   ,  // ( 65) NPEW - Prefix currencies and symbols
    6   ,  // ( 66) NPEH - Prefix currencies and symbols
    6   ,  // ( 67) NPEV - Prefix currencies and symbols
    6   ,  // ( 68) APNW - Prefix currencies and symbols
    6   ,  // ( 69) HPEW - Prefix currencies and symbols
    6   ,  // ( 70) WPR_ - Prefix currencies and symbols
    7   ,  // ( 71) NQEP - Postfix currencies and symbols
    7   ,  // ( 72) NQEW - Postfix currencies and symbols
    7   ,  // ( 73) NQNW - Postfix currencies and symbols
    7   ,  // ( 74) AQEW - Postfix currencies and symbols
    7   ,  // ( 75) AQNW - Postfix currencies and symbols
    7   ,  // ( 76) AQLW - Postfix currencies and symbols
    7   ,  // ( 77) WQO_ - Postfix currencies and symbols
    21  ,  // ( 78) NSBL - Space
    8   ,  // ( 79) WSP_ - Space
    8   ,  // ( 80) WHI_ - Hiragana, except small letters
    8   ,  // ( 81) NKA_ - Katakana, except small letters
    8   ,  // ( 82) WKA_ - Katakana, except small letters
    8   ,  // ( 83) ASNW - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 84) ASEW - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 85) ASRN - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 86) ASEN - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 87) ALA_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 88) AGR_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 89) ACY_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 90) WID_ - Han Ideographs
    8   ,  // ( 91) WPUA - End user defined characters
    16  ,  // ( 92) NHG_ - Hangul Ideographs
    16  ,  // ( 93) WHG_ - Hangul Ideographs
    8   ,  // ( 94) WCI_ - Compatibility Ideographs
    8   ,  // ( 95) NOI_ - Other Ideographs
    8   ,  // ( 96) WOI_ - Other Ideographs
    20  ,  // ( 97) WOIC - Other Ideographs
    8   ,  // ( 98) WOIL - Other Ideographs
    8   ,  // ( 99) WOIS - Other Ideographs
    8   ,  // (100) WOIT - Other Ideographs
    11  ,  // (101) NSEN - Super/subscript/attachment characters
    11  ,  // (102) NSET - Super/subscript/attachment characters
    11  ,  // (103) NSNW - Super/subscript/attachment characters
    11  ,  // (104) ASAN - Super/subscript/attachment characters
    11  ,  // (105) ASAE - Super/subscript/attachment characters
    9   ,  // (106) NDEA - Digits
    8   ,  // (107) WD__ - Digits
    11  ,  // (108) NLLA - Basic Latin
    8   ,  // (109) WLA_ - Basic Latin
    10  ,  // (110) NWBL - Word breaking spaces
    10  ,  // (111) NWZW - Word breaking spaces
    11  ,  // (112) NPLW - Punctuation in text
    11  ,  // (113) NPZW - Punctuation in text
    11  ,  // (114) NPF_ - Punctuation in text
    11  ,  // (115) NPFL - Punctuation in text
    11  ,  // (116) NPNW - Punctuation in text
    8   ,  // (117) APLW - Punctuation in text
    20  ,  // (118) APCO - Punctuation in text
    10  ,  // (119) ASYW - Soft Hyphen
    10  ,  // (120) NHYP - Hyphen
    10  ,  // (121) NHYW - Hyphen
    10  ,  // (122) AHYW - Hyphen
    14  ,  // (123) NAPA - Apostrophe
    14  ,  // (124) NQMP - Quotation mark
    13  ,  // (125) NSLS - Slash
    10  ,  // (126) NSF_ - Non space word break
    10  ,  // (127) NSBB - Non space word break
    10  ,  // (128) NSBS - Non space word break
    11  ,  // (129) NLA_ - Latin
    11  ,  // (130) NLQ_ - Latin Punctuation in text
    20  ,  // (131) NLQC - Latin Punctuation in text
    11  ,  // (132) NLQN - Latin Punctuation in text
    8   ,  // (133) ALQ_ - Latin Punctuation in text
    8   ,  // (134) ALQN - Latin Punctuation in text
    11  ,  // (135) NGR_ - Greek
    11  ,  // (136) NGRN - Greek
    11  ,  // (137) NGQ_ - Greek Punctuation in text
    11  ,  // (138) NGQN - Greek Punctuation in text
    11  ,  // (139) NCY_ - Cyrillic
    11  ,  // (140) NCYP - Cyrillic Punctuation in text
    20  ,  // (141) NCYC - Cyrillic Punctuation in text
    11  ,  // (142) NAR_ - Armenian
    11  ,  // (143) NAQL - Armenian Punctuation in text
    11  ,  // (144) NAQN - Armenian Punctuation in text
    11  ,  // (145) NHB_ - Hebrew
    20  ,  // (146) NHBC - Hebrew
    11  ,  // (147) NHBW - Hebrew
    11  ,  // (148) NHBR - Hebrew
    11  ,  // (149) NASR - Arabic
    11  ,  // (150) NAAR - Arabic
    20  ,  // (151) NAAC - Arabic
    9   ,  // (152) NAAD - Arabic
    9   ,  // (153) NAED - Arabic
    11  ,  // (154) NANW - Arabic
    11  ,  // (155) NAEW - Arabic
    11  ,  // (156) NAAS - Arabic
    11  ,  // (157) NHI_ - Devanagari
    11  ,  // (158) NHIN - Devanagari
    20  ,  // (159) NHIC - Devanagari
    9   ,  // (160) NHID - Devanagari
    11  ,  // (161) NBE_ - Bengali
    20  ,  // (162) NBEC - Bengali
    9   ,  // (163) NBED - Bengali
    6   ,  // (164) NBET - Bengali
    11  ,  // (165) NGM_ - Gurmukhi
    20  ,  // (166) NGMC - Gurmukhi
    9   ,  // (167) NGMD - Gurmukhi
    11  ,  // (168) NGJ_ - Gujarati
    20  ,  // (169) NGJC - Gujarati
    9   ,  // (170) NGJD - Gujarati
    11  ,  // (171) NOR_ - Oriya
    20  ,  // (172) NORC - Oriya
    9   ,  // (173) NORD - Oriya
    11  ,  // (174) NTA_ - Tamil
    20  ,  // (175) NTAC - Tamil
    9   ,  // (176) NTAD - Tamil
    11  ,  // (177) NTE_ - Telugu
    20  ,  // (178) NTEC - Telugu
    9   ,  // (179) NTED - Telugu
    11  ,  // (180) NKD_ - Kannada
    20  ,  // (181) NKDC - Kannada
    9   ,  // (182) NKDD - Kannada
    11  ,  // (183) NMA_ - Malayalam
    20  ,  // (184) NMAC - Malayalam
    9   ,  // (185) NMAD - Malayalam
    19  ,  // (186) NTH_ - Thai
    19  ,  // (187) NTHC - Thai
    9   ,  // (188) NTHD - Thai
    7   ,  // (189) NTHT - Thai
    11  ,  // (190) NLO_ - Lao
    20  ,  // (191) NLOC - Lao
    9   ,  // (192) NLOD - Lao
    11  ,  // (193) NTI_ - Tibetan
    20  ,  // (194) NTIC - Tibetan
    9   ,  // (195) NTID - Tibetan
    11  ,  // (196) NTIN - Tibetan
    11  ,  // (197) NGE_ - Georgian
    11  ,  // (198) NGEQ - Georgian Punctuation in text
    11  ,  // (199) NBO_ - Bopomofo
    12  ,  // (200) NBSP - No Break space
    12  ,  // (201) NBSS - No Break space
    11  ,  // (202) NOF_ - Other symbols
    11  ,  // (203) NOBS - Other symbols
    11  ,  // (204) NOEA - Other symbols
    11  ,  // (205) NONA - Other symbols
    11  ,  // (206) NONP - Other symbols
    11  ,  // (207) NOEP - Other symbols
    11  ,  // (208) NONW - Other symbols
    11  ,  // (209) NOEW - Other symbols
    11  ,  // (210) NOLW - Other symbols
    20  ,  // (211) NOCO - Other symbols
    11  ,  // (212) NOEN - Other symbols
    11  ,  // (213) NOBN - Other symbols
    11  ,  // (214) NSBN - Other symbols
    11  ,  // (215) NOLE - Other symbols
    11  ,  // (216) NORE - Other symbols
    11  ,  // (217) NOPF - Other symbols
    11  ,  // (218) NOLO - Other symbols
    11  ,  // (219) NORO - Other symbols
    11  ,  // (220) NET_ - Ethiopic
    22  ,  // (221) NETP - Ethiopic
    9   ,  // (222) NETD - Ethiopic
    11  ,  // (223) NCA_ - Canadian Syllabics
    11  ,  // (224) NCH_ - Cherokee
    8   ,  // (225) WYI_ - Yi
    8   ,  // (226) WYIN - Yi
    11  ,  // (227) NBR_ - Braille
    11  ,  // (228) NRU_ - Runic
    11  ,  // (229) NOG_ - Oghma
    11  ,  // (230) NOGS - Oghma
    11  ,  // (231) NOGN - Oghma
    11  ,  // (232) NSI_ - Sinhala
    20  ,  // (233) NSIC - Sinhala
    11  ,  // (234) NTN_ - Thaana
    20  ,  // (235) NTNC - Thaana
    11  ,  // (236) NKH_ - Khmer
    20  ,  // (237) NKHC - Khmer
    9   ,  // (238) NKHD - Khmer
    6   ,  // (239) NKHT - Khmer
    11  ,  // (240) NBU_ - Burmese
    20  ,  // (241) NBUC - Burmese
    9   ,  // (242) NBUD - Burmese
    11  ,  // (243) NSY_ - Syriac
    11  ,  // (244) NSYP - Syriac
    20  ,  // (245) NSYC - Syriac
    11  ,  // (246) NSYW - Syriac
    11  ,  // (247) NMO_ - Mongolian
    20  ,  // (248) NMOC - Mongolian
    9   ,  // (249) NMOD - Mongolian
    11  ,  // (250) NMOB - Mongolian
    11  ,  // (251) NMON - Mongolian
    11  ,  // (252) NHS_ - High Surrogate
    8   ,  // (253) WHT_ - High Surrogate
    20  ,  // (254) LS__ - Low Surrogate
    11  ,  // (255) XNW_ - Undefined or reserved characters
    11  ,  // (256) XNWA - Undefined or reserved characters
    11  ,  // (257) XNWB - Undefined or reserved characters
};


// 0 indicates that line breaking is allowed between these 2 classes.
// 1 indicates no line breaking as well as no break across space.
// 2 indicates no line breaking, but can break across space. 
// 3 is like 0 when break-latin is on, otherwise it is 2.
// 4 is like 0 when break-CJK is on, otherwise it is 2.
//

const unsigned char LineBreakBehavior[BREAKCLASS_MAX][BREAKCLASS_MAX] =
{
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},  // ( 0) *Break Always*
    {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1},  // ( 1) Opening characters
    {0, 0, 1, 1, 1, 0, 0, 2, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 2) Closing characters
    {0, 0, 1, 2, 1, 2, 0, 2, 4, 0, 0, 4, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // ( 3) No start ideographic
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 4) Exclamation/interrogation
    {0, 0, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 5) Inseparable
    {0, 2, 1, 2, 1, 0, 2, 0, 2, 2, 0, 3, 2, 1, 2, 1, 2, 2, 0, 0, 2, 1, 1},  // ( 6) Prefix
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 7) Postfix
    {0, 0, 1, 2, 1, 2, 0, 2, 4, 0, 0, 4, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // ( 8) Ideographic
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 3, 0, 3, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 9) Numeral sequence
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // (10) Alpha space
    {0, 0, 1, 2, 1, 2, 2, 2, 4, 3, 0, 3, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // (11) Alpha characters/symbols
    {0, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1},  // (12) Glue Characters
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 2, 0, 3, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // (13) Slash
    {0, 1, 1, 2, 1, 2, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1},  // (14) Quotation characters
    {0, 0, 1, 2, 1, 0, 2, 2, 0, 2, 0, 3, 2, 1, 2, 2, 0, 0, 0, 0, 2, 1, 1},  // (15) Numeric separators
    {0, 0, 1, 2, 1, 2, 0, 2, 4, 0, 0, 4, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // (16) Hangul
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 1, 2, 1, 4, 2, 2, 2, 2, 1, 1},  // (17) Thai first
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 2, 2, 2, 1, 1},  // (18) Thai last
    {0, 0, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 1, 0, 2, 2, 2, 2, 1, 1},  // (19) Thai middle
    {0, 0, 1, 2, 1, 2, 2, 2, 4, 3, 0, 3, 2, 1, 2, 1, 4, 0, 0, 0, 1, 1, 1},  // (20) Combining
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // (21) Ascii space
    {0, 0, 1, 2, 1, 0, 2, 2, 0, 2, 0, 0, 2, 1, 2, 2, 0, 0, 0, 0, 2, 1, 2},  // (22) Special punctuation
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\unilib\mirror.cxx ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Mirrored Helper
*
* Abstract:
*
*   Contains Mirrorred codepoints helper routines
*
*
* Revision History:
*
*   05/15/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/
#include "windows.h"
    const INT acc_00[256] = // U+00xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 00 - 0F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0029,0x0028,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x003E,0x0000,0x003C,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x005D,0x0000,0x005B,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x007D,0x0000,0x007B,0x0000,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00BB,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00AB,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };

    const INT acc_20[256] = // U+20xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 00 - 0F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x203A,0x2039,0x0000,0x0000,0x0000,0x0000,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x2046,0x2045,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x207E,0x207D,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x208E,0x208D,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };
    
    const INT acc_22[256] = // U+22xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x2201,0x2202,0x2203,0x2204,0x0000,0x0000,0x0000,0x220B,0x220C,0x220D,0x2208,0x2209,0x220A,0x0000,0x0000, // 00 - 0F
    0x0000,0x2211,0x0000,0x0000,0x0000,0x2216,0x2215,0x0000,0x0000,0x0000,0x221A,0x221B,0x221C,0x221D,0x0000,0x221F, // 10 - 1F
    0x2220,0x2221,0x2222,0x0000,0x2224,0x0000,0x2226,0x0000,0x0000,0x0000,0x0000,0x222B,0x222C,0x222D,0x222E,0x222F, // 20 - 2F
    0x2230,0x2231,0x2232,0x2233,0x0000,0x0000,0x0000,0x0000,0x0000,0x2239,0x0000,0x223B,0x223D,0x223C,0x223E,0x223F, // 30 - 3F
    0x2240,0x2241,0x2242,0x22CD,0x2244,0x2245,0x2246,0x2247,0x2248,0x2249,0x224A,0x224B,0x224C,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x2253,0x2252,0x2255,0x2254,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x225F, // 50 - 5F
    0x2260,0x0000,0x2262,0x0000,0x2265,0x2264,0x2267,0x2266,0x2269,0x2268,0x226B,0x226A,0x0000,0x0000,0x226F,0x226E, // 60 - 6F
    0x2271,0x2270,0x2273,0x2272,0x2275,0x2274,0x2277,0x2276,0x2279,0x2278,0x227B,0x227A,0x227D,0x227C,0x227F,0x227E, // 70 - 7F
    0x2281,0x2280,0x2283,0x2282,0x2285,0x2284,0x2287,0x2286,0x2289,0x2288,0x228B,0x228A,0x228C,0x0000,0x0000,0x2290, // 80 - 8F
    0x228F,0x2292,0x2291,0x0000,0x0000,0x0000,0x0000,0x0000,0x2298,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x22A3,0x22A2,0x0000,0x0000,0x22A6,0x22A7,0x22A8,0x22A9,0x22AA,0x22AB,0x22AC,0x22AD,0x22AE,0x22AF, // A0 - AF
    0x22B1,0x22B0,0x22B3,0x22B2,0x22B5,0x22B4,0x22B7,0x22B6,0x22B8,0x0000,0x0000,0x0000,0x0000,0x0000,0x22BE,0x22BF, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x22CA,0x22C9,0x22CC,0x22CB,0x2243,0x0000,0x0000, // C0 - CF
    0x22D1,0x22D0,0x0000,0x0000,0x0000,0x0000,0x22D7,0x22D6,0x22D9,0x22D8,0x22DB,0x22DA,0x22DD,0x22DC,0x22DF,0x22DE, // D0 - DF
    0x22E1,0x22E0,0x22E3,0x22E2,0x22E5,0x22E4,0x22E7,0x22E6,0x22E9,0x22E8,0x22EB,0x22EA,0x22ED,0x22EC,0x0000,0x0000, // E0 - EF
    0x22F1,0x22F0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };
    

    const INT acc_23[256] = // U+23xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2309,0x2308,0x230B,0x230A,0x0000,0x0000,0x0000,0x0000, // 00 - 0F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x2320,0x2321,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x232A,0x2329,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };

    const INT acc_30[256] = // U+30xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3009,0x3008,0x300B,0x300A,0x300C,0x300D,0x300E,0x300F, // 00 - 0F
    0x3011,0x3010,0x0000,0x0000,0x3014,0x3015,0x3017,0x3016,0x3019,0x3018,0x301B,0x301A,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };

    const INT * const pccUnicodeLevel1[256] =
    {
    acc_00, NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 00 - 07
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 08 - 0F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 10 - 17
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 18 - 1F
    acc_20, NULL,   acc_22, acc_23, NULL,   NULL,   NULL,   NULL,    // 20 - 27
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 28 - 2F
    acc_30, NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 30 - 37
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 38 - 3F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 40 - 47
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 48 - 4F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 50 - 57
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 58 - 5F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 60 - 67
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 68 - 6F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 70 - 77
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 78 - 7F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 80 - 87
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 88 - 8F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 90 - 97
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 98 - 9F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // A0 - A7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // A8 - AF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // B0 - B7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // B8 - BF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // C0 - C7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // C8 - CF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // D0 - D7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // D8 - DF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // E0 - E7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // E8 - EF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // F0 - F7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // F8 - FF
    };

//
// GetMirroredCodepoint
//
// if the passed codepoint has a valid mirrored codepoint, it return it.
// otherwise it returns the original passed codepoint.

INT __stdcall
GetMirroredCodepoint(INT codepoint)
{
    if(codepoint > 0xFFFF)
    {
        // no surrogates mirrored codepoint so far
        return codepoint;
    }
    const INT *pcc;
    if(!(pcc = pccUnicodeLevel1[(codepoint & 0xFFFF)>>8]))
    {
        return codepoint;
    }
    
    // No parameter validation for performace.
    INT mirroredCodepoint = pcc[codepoint & 0xff];
    return mirroredCodepoint==0 ? codepoint : mirroredCodepoint;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\unilib\unidir.cxx ===
//
// This is a generated file.  Do not modify by hand.
//
// Generating script: unicodedirection_maketable.pl
// Generated on Tue Apr 17 17:25:36 2001
//

#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif

#ifndef X__UNIDIR_H
#define X__UNIDIR_H
#include "unidir.hxx"
#endif

extern "C" const GpCharacterClass s_aDirClassFromCharClass[CHAR_CLASS_UNICODE_MAX] =
{
    ON ,  // WOB_ - Open Brackets for inline-note (JIS 1 or 19)
    ON ,  // NOPP - Open parenthesis (JIS 1)
    ON ,  // NOPA - Open parenthesis (JIS 1)
    ON ,  // NOPW - Open parenthesis (JIS 1)
    ON ,  // HOP_ - Open parenthesis (JIS 1)
    ON ,  // WOP_ - Open parenthesis (JIS 1)
    ON ,  // WOP5 - Open parenthesis, Big 5 (JIS 1)
    ON ,  // NOQW - Open quotes (JIS 1)
    ON ,  // AOQW - Open quotes (JIS 1)
    ON ,  // WOQ_ - Open quotes (JIS 1)
    ON ,  // WCB_ - Close brackets for inline-note (JIS 2 or 20)
    ON ,  // NCPP - Close parenthesis (JIS 2)
    ON ,  // NCPA - Close parenthesis (JIS 2)
    ON ,  // NCPW - Close parenthesis (JIS 2)
    ON ,  // HCP_ - Close parenthesis (JIS 2)
    ON ,  // WCP_ - Close parenthesis (JIS 2)
    ON ,  // WCP5 - Close parenthesis, Big 5 (JIS 2)
    ON ,  // NCQW - Close quotes (JIS 2)
    ON ,  // ACQW - Close quotes (JIS 2)
    ON ,  // WCQ_ - Close quotes (JIS 2)
    ON ,  // ARQW - Right single quotation mark (JIS 2)
    CS ,  // NCSA - Comma (JIS 2 or 15)
    ON ,  // HCO_ - Comma (JIS 2 or 15)
    ON ,  // WC__ - Comma (JIS 2)
    CS ,  // WCS_ - Comma (JIS 2)
    ON ,  // WC5_ - Comma, Big 5 (JIS 2)
    CS ,  // WC5S - Comma, Big 5 (JIS 2)
    L  ,  // NKS_ - Kana sound marks (JIS 3)
    ON ,  // WKSM - Kana sound marks (JIS 3)
    L  ,  // WIM_ - Iteration marks (JIS 3)
    ON ,  // NSSW - Symbols which cant start a line (JIS 3)
    ON ,  // WSS_ - Symbols that cant start a line (JIS 3)
    L  ,  // WHIM - Hiragana iteration marks (JIS 3)
    L  ,  // WKIM - Katakana iteration marks (JIS 3)
    L  ,  // NKSL - Katakana that cant start a line (JIS 3)
    L  ,  // WKS_ - Katakana that cant start a line (JIS 3)
    NSM,  // WKSC - Katakana that cant start a line (JIS 3)
    L  ,  // WHS_ - Hiragana that cant start a line (JIS 3)
    ON ,  // NQFP - Question/Exclamation (JIS 4)
    ON ,  // NQFA - Question/Exclamation (JIS 4)
    ON ,  // WQE_ - Question/Exclamation (JIS 4)
    ON ,  // WQE5 - Question/Exclamation, Big 5 (JIS 4)
    ON ,  // NKCC - Kana centered characters (JIS 5)
    ON ,  // WKC_ - Kana centered characters (JIS 5)
    CS ,  // NOCP - Other centered characters (JIS 5)
    ON ,  // NOCA - Other centered characters (JIS 5)
    ON ,  // NOCW - Other centered characters (JIS 5)
    ON ,  // WOC_ - Other centered characters (JIS 5)
    CS ,  // WOCS - Other centered characters (JIS 5)
    CS ,  // WOC5 - Other centered characters, Big 5 (JIS 5)
    ON ,  // WOC6 - Other centered characters, Big 5 (JIS 5)
    ON ,  // AHPW - Hyphenation point (JIS 5)
    CS ,  // NPEP - Period (JIS 6 or 15)
    L  ,  // NPAR - Period (JIS 6 or 15)
    ON ,  // HPE_ - Period (JIS 6 or 15)
    ON ,  // WPE_ - Period (JIS 6)
    CS ,  // WPES - Period (JIS 6)
    CS ,  // WPE5 - Period, Big 5 (JIS 6)
    ON ,  // NISW - Inseparable characters (JIS 7)
    ON ,  // AISW - Inseparable characters (JIS 7)
    WS ,  // NQCS - Glue characters (no JIS)
    BN ,  // NQCW - Glue characters (no JIS)
    NSM,  // NQCC - Glue characters (no JIS)
    ET ,  // NPTA - Prefix currencies and symbols (JIS 8)
    ON ,  // NPNA - Prefix currencies and symbols (JIS 8)
    ET ,  // NPEW - Prefix currencies and symbols (JIS 8)
    ET ,  // NPEH - Prefix currencies and symbols (JIS 8)
    ET ,  // NPEV - Prefix currencies and symbols (JIS 8)
    ON ,  // APNW - Prefix currencies and symbols (JIS 8)
    ET ,  // HPEW - Prefix currencies and symbols (JIS 8)
    ET ,  // WPR_ - Prefix currencies and symbols (JIS 8)
    ET ,  // NQEP - Postfix currencies and symbols (JIS 9)
    ET ,  // NQEW - Postfix currencies and symbols (JIS 9)
    ON ,  // NQNW - Postfix currencies and symbols (JIS 9)
    ET ,  // AQEW - Postfix currencies and symbols (JIS 9)
    ON ,  // AQNW - Postfix currencies and symbols (JIS 9)
    L  ,  // AQLW - Postfix currencies and symbols (JIS 9)
    ET ,  // WQO_ - Postfix currencies and symbols (JIS 9)
    WS ,  // NSBL - Space(JIS 15 or 17)
    WS ,  // WSP_ - Space (JIS 10)
    L  ,  // WHI_ - Hiragana except small letters (JIS 11)
    L  ,  // NKA_ - Katakana except small letters Ideographic (JIS 12)
    L  ,  // WKA_ - Katakana except small letters (JIS 12)
    ON ,  // ASNW - Ambiguous symbols (JIS 12 or 18) 
    ET ,  // ASEW - Ambiguous symbols (JIS 12 or 18) 
    L  ,  // ASRN - Ambiguous symbols (JIS 12 or 18) 
    EN ,  // ASEN - Ambiguous symbols (JIS 12 or 18) 
    L  ,  // ALA_ - Ambiguous Latin (JIS 12 or 18) 
    L  ,  // AGR_ - Ambiguous Greek (JIS 12 or 18) 
    L  ,  // ACY_ - Ambiguous Cyrillic (JIS 12 or 18) 
    L  ,  // WID_ - Han Ideographs (JIS 12, 14S or 14D)
    L  ,  // WPUA - End user defined characters (JIS 12, 14S or 14D)
    L  ,  // NHG_ - Hangul Ideographs (JIS 12)
    L  ,  // WHG_ - Hangul Ideographs (JIS 12)
    L  ,  // WCI_ - Compatibility Ideographs (JIS 12)
    ON ,  // NOI_ - Other Ideographs (JIS 12)
    ON ,  // WOI_ - Other Ideographs (JIS 12)
    NSM,  // WOIC - Other Ideographs (JIS 12)
    L  ,  // WOIL - Other Ideographs (JIS 12)
    ES ,  // WOIS - Other Ideographs (JIS 12)
    ET ,  // WOIT - Other Ideographs (JIS 12)
    EN ,  // NSEN - Superscript/Subscript/Attachments (JIS 13)
    ET ,  // NSET - Superscript/Subscript/Attachments (JIS 13)
    ON ,  // NSNW - Superscript/Subscript/Attachments (JIS 13)
    L  ,  // ASAN - Superscript/Subscript/Attachments (JIS 13)
    EN ,  // ASAE - Superscript/Subscript/Attachments (JIS 13)
    EN ,  // NDEA - Digits (JIS 15 or 18)
    EN ,  // WD__ - Digits (JIS 15 or 18)
    L  ,  // NLLA - Basic Latin (JIS 16 or 18)
    L  ,  // WLA_ - Basic Latin (JIS 16 or 18)
    WS ,  // NWBL - Word breaking Spaces (JIS 17)
    BN ,  // NWZW - Word breaking Spaces (JIS 17)
    L  ,  // NPLW - Punctuation in Text (JIS 18)
    BN ,  // NPZW - Punctuation in Text (JIS 18)
    R  ,  // NPF_ - Punctuation in Text (JIS 18)
    L  ,  // NPFL - Punctuation in Text (JIS 18)
    ON ,  // NPNW - Punctuation in Text (JIS 18)
    L  ,  // APLW - Punctuation in text (JIS 12 or 18)
    NSM,  // APCO - Punctuation in text (JIS 12 or 18)
    ON ,  // ASYW - Soft Hyphen (JIS 12 or 18)
    ES ,  // NHYP - Hyphen (JIS 18)
    ON ,  // NHYW - Hyphen (JIS 18)
    ON ,  // AHYW - Hyphen (JIS 12 or 18)
    ON ,  // NAPA - Apostrophe (JIS 18)
    ON ,  // NQMP - Quotation mark (JIS 18)
    CS ,  // NSLS - Slash (JIS 18)
    S  ,  // NSF_ - Non space word break (JIS 18)
    B  ,  // NSBB - Non space word break (JIS 18)
    WS ,  // NSBS - Non space word break (JIS 18)
    L  ,  // NLA_ - Latin (JIS 18)
    L  ,  // NLQ_ - Latin Punctuation in text (JIS 18)
    L  ,  // NLQC - Latin Punctuation in text (JIS 18)
    ON ,  // NLQN - Latin Punctuation in text (JIS 18)
    ON ,  // ALQ_ - Latin Punctuation in text (JIS 12 or 18)
    ON ,  // ALQN - Latin Punctuation in text (JIS 12 or 18)
    L  ,  // NGR_ - Greek (JIS 18)
    ON ,  // NGRN - Greek (JIS 18)
    L  ,  // NGQ_ - Greek Punctuation in text (JIS 18)
    ON ,  // NGQN - Greek Punctuation in text (JIS 18)
    L  ,  // NCY_ - Cyrillic (JIS 18)
    L  ,  // NCYP - Cyrillic Punctuation in text (JIS 18)
    NSM,  // NCYC - Cyrillic Punctuation in text (JIS 18)
    L  ,  // NAR_ - Armenian (JIS 18)
    L  ,  // NAQL - Armenian Punctuation in text (JIS 18)
    ON ,  // NAQN - Armenian Punctuation in text (JIS 18)
    R  ,  // NHB_ - Hebrew (JIS 18)
    NSM,  // NHBC - Hebrew (JIS 18)
    ET ,  // NHBW - Hebrew (JIS 18)
    R  ,  // NHBR - Hebrew (JIS 18)
    CS ,  // NASR - Arabic (JIS 18)
    AL ,  // NAAR - Arabic (JIS 18)
    NSM,  // NAAC - Arabic (JIS 18)
    AN ,  // NAAD - Arabic (JIS 18)
    EN ,  // NAED - Arabic (JIS 18)
    ON ,  // NANW - Arabic (JIS 18)
    ET ,  // NAEW - Arabic (JIS 18)
    AL ,  // NAAS - Arabic (JIS 18)
    L  ,  // NHI_ - Devanagari (JIS 18)
    L  ,  // NHIN - Devanagari (JIS 18)
    NSM,  // NHIC - Devanagari (JIS 18)
    L  ,  // NHID - Devanagari (JIS 18)
    L  ,  // NBE_ - Bengali (JIS 18)
    NSM,  // NBEC - Bengali (JIS 18)
    L  ,  // NBED - Bengali (JIS 18)
    ET ,  // NBET - Bengali (JIS 18)
    L  ,  // NGM_ - Gurmukhi (JIS 18)
    NSM,  // NGMC - Gurmukhi (JIS 18)
    L  ,  // NGMD - Gurmukhi (JIS 18)
    L  ,  // NGJ_ - Gujarati (JIS 18)
    NSM,  // NGJC - Gujarati (JIS 18)
    L  ,  // NGJD - Gujarati (JIS 18)
    L  ,  // NOR_ - Oriya (JIS 18)
    NSM,  // NORC - Oriya (JIS 18)
    L  ,  // NORD - Oriya (JIS 18)
    L  ,  // NTA_ - Tamil (JIS 18)
    NSM,  // NTAC - Tamil (JIS 18)
    L  ,  // NTAD - Tamil (JIS 18)
    L  ,  // NTE_ - Telugu (JIS 18)
    NSM,  // NTEC - Telugu (JIS 18)
    L  ,  // NTED - Telugu (JIS 18)
    L  ,  // NKD_ - Kannada (JIS 18)
    NSM,  // NKDC - Kannada (JIS 18)
    L  ,  // NKDD - Kannada (JIS 18)
    L  ,  // NMA_ - Malayalam (JIS 18)
    NSM,  // NMAC - Malayalam (JIS 18)
    L  ,  // NMAD - Malayalam (JIS 18)
    L  ,  // NTH_ - Thai (JIS 18) 
    NSM,  // NTHC - Thai (JIS 18) 
    L  ,  // NTHD - Thai (JIS 18) 
    ET ,  // NTHT - Thai (JIS 18) 
    L  ,  // NLO_ - Lao (JIS 18)
    NSM,  // NLOC - Lao (JIS 18)
    L  ,  // NLOD - Lao (JIS 18)
    L  ,  // NTI_ - Tibetan (JIS 18)
    NSM,  // NTIC - Tibetan (JIS 18)
    L  ,  // NTID - Tibetan (JIS 18)
    ON ,  // NTIN - Tibetan (JIS 18)
    L  ,  // NGE_ - Georgian (JIS 18)
    L  ,  // NGEQ - Georgian Punctuation in text (JIS 18)
    L  ,  // NBO_ - Bopomofo (JIS 18)
    CS ,  // NBSP - No Break space (no JIS) 
    WS ,  // NBSS - No Break space (no JIS) 
    S  ,  // NOF_ - Other symbols (JIS 18)
    B  ,  // NOBS - Other symbols (JIS 18)
    ET ,  // NOEA - Other symbols (JIS 18)
    ON ,  // NONA - Other symbols (JIS 18)
    ON ,  // NONP - Other symbols (JIS 18)
    ES ,  // NOEP - Other symbols (JIS 18)
    ON ,  // NONW - Other symbols (JIS 18)
    ET ,  // NOEW - Other symbols (JIS 18)
    L  ,  // NOLW - Other symbols (JIS 18)
    NSM,  // NOCO - Other symbols (JIS 18)
    EN ,  // NOEN - Other symbols (JIS 18)
    BN ,  // NOBN - Other symbols (JIS 18)
    BN ,  // NSBN - Other symbols (JIS 18)
    LRE,  // NOLE - Other symbols (JIS 18)
    RLE,  // NORE - Other symbols (JIS 18)
    PDF,  // NOPF - Other symbols (JIS 18)
    LRO,  // NOLO - Other symbols (JIS 18)
    RLO,  // NORO - Other symbols (JIS 18)
    L  ,  // NET_ - Ethiopic
    L  ,  // NETP - Ethiopic
    L  ,  // NETD - Ethiopic
    L  ,  // NCA_ - Canadian Syllabics
    L  ,  // NCH_ - Cherokee
    L  ,  // WYI_ - Yi
    ON ,  // WYIN - Yi
    ON ,  // NBR_ - Braille
    L  ,  // NRU_ - Runic
    L  ,  // NOG_ - Ogham
    WS ,  // NOGS - Ogham
    ON ,  // NOGN - Ogham
    L  ,  // NSI_ - Sinhala
    NSM,  // NSIC - Sinhala
    AL ,  // NTN_ - Thaana
    NSM,  // NTNC - Thaana
    L  ,  // NKH_ - Khmer
    NSM,  // NKHC - Khmer
    L  ,  // NKHD - Khmer
    ET ,  // NKHT - Khmer
    L  ,  // NBU_ - Burmese/Myanmar
    NSM,  // NBUC - Burmese/Myanmar
    L  ,  // NBUD - Burmese/Myanmar
    AL ,  // NSY_ - Syriac
    AL ,  // NSYP - Syriac
    NSM,  // NSYC - Syriac
    BN ,  // NSYW - Syriac
    L  ,  // NMO_ - Mongolian
    NSM,  // NMOC - Mongolian
    L  ,  // NMOD - Mongolian
    BN ,  // NMOB - Mongolian
    ON ,  // NMON - Mongolian
    L  ,  // NHS_ - High Surrogate
    L  ,  // WHT_ - High Surrogate
    L  ,  // LS__ - Low Surrogate
    L  ,  // XNW_ - Unassigned
    AL ,  // XNWA - Unassigned
    BN ,  // XNWB - Unassigned
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\unilib\classify.cxx ===
#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif

#include "windows.h"
#include "assert.h"


//+----------------------------------------------------------------------------
//
//  Function:   CharClassFromCh
//
//  Synopsis:   Given a character return a Unicode character class.  This
//              character class implies other properties, such as script id,
//              breaking class, etc.
//
//      Note:   pccUnicodeClass is a hack table.  For every Unicode page for
//              which every codepoint is the same value, the table entry is
//              the charclass itself.  Otherwise we have a pointer to a table
//              of charclass.
//
//-----------------------------------------------------------------------------

CHAR_CLASS __stdcall
CharClassFromCh(INT wch)
{
    // either Unicode plane 0 or in surrogate range
    assert(wch <= 0x10FFFF);

    // Plane 0 codepoint
    if( wch <= 0xFFFF)
    {
        const CHAR_CLASS * const pcc = pccUnicodeClass[(wch & 0xFFFF)>>8];
        const UINT_PTR icc = UINT_PTR(pcc);

        return (CHAR_CLASS)(icc < 256 ? icc : pcc[wch & 0xff]);
    }
    else if(   ((wch >= 0x00010000) && (wch <= 0x0001FFFF))
            || ((wch >= 0x00040000) && (wch <= 0x0010FFFF)))
    {
        // non-Han surrogates - high ranges D800-D83F and D8C0 - DBFF
        return NHS_;
    }
    else if((wch >= 0x00020000) && (wch <= 0x0003FFFF))
    {
        // Han surrogates - high range D840 - D8BF
        return WHT_;
    }
    else
    {
        // Currently, we don't have any plane1 or higher allocation.
        // Let's treat it as unassigned codepoint.
        return XNW_;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\unilib\unipart.cxx ===
//
// This is a generated file.  Do not modify by hand.
//
// Generating script: unicodepartition_maketables.pl
// Generated on Mon Apr 30 19:22:17 2001
//

#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif

#include "windows.h"
#include "assert.h"
#pragma data_seg( "Shared" )

const CHAR_CLASS acc_00[256] = // U+00xx
{
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NSF_,NSBB,NOF_,NSBS,NSBB,NOBN,NOBN, // 00 - 0F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBS,NOBS,NOF_, // 10 - 1F
    NSBL,NQFP,NQMP,NOEA,NPTA,NQEP,NONA,NAPA,NOPP,NCPP,NONP,NOEP,NCSA,NHYP,NPEP,NSLS, // 20 - 2F
    NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NOCP,NOCA,NONA,NONP,NONA,NQFA, // 30 - 3F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 40 - 4F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPP,NPNA,NCPP,NONA,NONA, // 50 - 5F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 60 - 6F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPA,NONA,NCPA,NONA,NOBN, // 70 - 7F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 80 - 8F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 90 - 9F
    NBSP,ASNW,NQEW,NPEW,ASEW,NPEW,NONW,ASNW,ASNW,NONW,ASAN,NOQW,NONW,ASYW,NONW,ASNW, // A0 - AF
    AQEW,ASEW,ASAE,ASAE,ASNW,NOLW,ASNW,ASNW,ASNW,ASAE,ASAN,NCQW,ASNW,ASNW,ASNW,ASNW, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ASNW,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // D0 - DF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,ALA_,ALA_,ALA_,NLA_,ALA_,ALA_,NLA_,NLA_, // E0 - EF
    ALA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ASNW,ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_01[256] = // U+01xx
{
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_, // 30 - 3F
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_,ALA_,ALA_,ALA_,ALA_,ALA_,ALA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_, // C0 - CF
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_02[256] = // U+02xx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    ALA_,ALA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPLW,NPLW,NPLW,NPLW,NPLW, // B0 - BF
    NPLW,NPLW,NPNW,NPNW,NPNW,NPNW,ALQN,ALQ_,NPNW,ALQ_,ALQ_,ALQ_,NPNW,ALQ_,NPNW,NPNW, // C0 - CF
    APLW,NPLW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,ALQ_,ALQ_,ALQ_,ALQ_,NLQN,ALQ_,NPNW,NPNW, // D0 - DF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPLW,NPLW, // E0 - EF
    NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW  // F0 - FF
};

const CHAR_CLASS acc_03[256] = // U+03xx
{
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 00 - 0F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 30 - 3F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 40 - 4F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 50 - 5F
    NQCC,NQCC,NQCC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC, // 60 - 6F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQ_,NGQN,NGQN,NGQN,NGQN,NGQN, // 70 - 7F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGR_,NGQN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // 90 - 9F
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // B0 - BF
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // E0 - EF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_  // F0 - FF
};

const CHAR_CLASS acc_04[256] = // U+04xx
{
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 10 - 1F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 20 - 2F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 30 - 3F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 40 - 4F
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 50 - 5F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 60 - 6F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 70 - 7F
    NCY_,NCY_,NCYP,NCYC,NCYC,NCYC,NCYC,NCYC,NCYC,NCYC,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 80 - 8F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 90 - 9F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // A0 - AF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // B0 - BF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // C0 - CF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // D0 - DF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // E0 - EF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_  // F0 - FF
};

const CHAR_CLASS acc_05[256] = // U+05xx
{
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 10 - 1F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 20 - 2F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 30 - 3F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 40 - 4F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL, // 50 - 5F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 60 - 6F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 70 - 7F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NPAR,NAQN,NAQL,NAQL,NAQL,NAQL,NAQL, // 80 - 8F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // 90 - 9F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // A0 - AF
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHB_,NHBC, // B0 - BF
    NHB_,NHBC,NHBC,NHB_,NHBC,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // C0 - CF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // D0 - DF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // E0 - EF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_  // F0 - FF
};

const CHAR_CLASS acc_06[256] = // U+06xx
{
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NASR,NAAR,NAAR,NAAR, // 00 - 0F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 10 - 1F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 20 - 2F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 30 - 3F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC, // 40 - 4F
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 50 - 5F
    NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAEW,NAAD,NAAD,NAAR,NAAR,NAAR, // 60 - 6F
    NAAC,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 70 - 7F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 80 - 8F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 90 - 9F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // A0 - AF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // B0 - BF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // C0 - CF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // D0 - DF
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAR,NAAR,NAAC,NAAC,NANW,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // E0 - EF
    NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR  // F0 - FF
};

const CHAR_CLASS acc_07[256] = // U+07xx
{
    NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYW, // 00 - 0F
    NSY_,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 10 - 1F
    NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 20 - 2F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC, // 30 - 3F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_, // 40 - 4F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 50 - 5F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 60 - 6F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 70 - 7F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 80 - 8F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 90 - 9F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC, // A0 - AF
    NTNC,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_09[256] = // U+09xx
{
    NHI_,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 00 - 0F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 10 - 1F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 20 - 2F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHIC,NHI_,NHIC,NHIC, // 30 - 3F
    NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_, // 40 - 4F
    NHI_,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 50 - 5F
    NHI_,NHI_,NHIC,NHIC,NHIN,NHIN,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID, // 60 - 6F
    NHIN,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 70 - 7F
    NBE_,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 80 - 8F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 90 - 9F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // A0 - AF
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBEC,NBE_,NBEC,NBEC, // B0 - BF
    NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_, // C0 - CF
    NBE_,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // D0 - DF
    NBE_,NBE_,NBEC,NBEC,NBE_,NBE_,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED, // E0 - EF
    NBE_,NBE_,NBET,NBET,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_  // F0 - FF
};

const CHAR_CLASS acc_0A[256] = // U+0Axx
{
    NGM_,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 00 - 0F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 10 - 1F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 20 - 2F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGMC,NGM_,NGMC,NGMC, // 30 - 3F
    NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_, // 40 - 4F
    NGM_,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 50 - 5F
    NGM_,NGM_,NGMC,NGMC,NGM_,NGM_,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD, // 60 - 6F
    NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 70 - 7F
    NGJ_,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 80 - 8F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 90 - 9F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // A0 - AF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJC,NGJ_,NGJC,NGJC, // B0 - BF
    NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_, // C0 - CF
    NGJ_,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // D0 - DF
    NGJ_,NGJ_,NGJC,NGJC,NGJ_,NGJ_,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD, // E0 - EF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_  // F0 - FF
};

const CHAR_CLASS acc_0B[256] = // U+0Bxx
{
    NOR_,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 00 - 0F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 10 - 1F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 20 - 2F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NORC,NOR_,NORC,NORC, // 30 - 3F
    NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_, // 40 - 4F
    NOR_,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 50 - 5F
    NOR_,NOR_,NORC,NORC,NOR_,NOR_,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD, // 60 - 6F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 70 - 7F
    NTA_,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 80 - 8F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 90 - 9F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // A0 - AF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTAC,NTA_,NTAC,NTAC, // B0 - BF
    NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_, // C0 - CF
    NTA_,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // D0 - DF
    NTA_,NTA_,NTAC,NTAC,NTA_,NTA_,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD, // E0 - EF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_  // F0 - FF
};

const CHAR_CLASS acc_0C[256] = // U+0Cxx
{
    NTE_,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 00 - 0F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 10 - 1F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 20 - 2F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTEC,NTE_,NTEC,NTEC, // 30 - 3F
    NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_, // 40 - 4F
    NTE_,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 50 - 5F
    NTE_,NTE_,NTEC,NTEC,NTE_,NTE_,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED, // 60 - 6F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 70 - 7F
    NKD_,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 80 - 8F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 90 - 9F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // A0 - AF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKDC,NKD_,NKDC,NKDC, // B0 - BF
    NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_, // C0 - CF
    NKD_,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // D0 - DF
    NKD_,NKD_,NKDC,NKDC,NKD_,NKD_,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD, // E0 - EF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_  // F0 - FF
};

const CHAR_CLASS acc_0D[256] = // U+0Dxx
{
    NMA_,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 00 - 0F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 10 - 1F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 20 - 2F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMAC,NMA_,NMAC,NMAC, // 30 - 3F
    NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_, // 40 - 4F
    NMA_,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 50 - 5F
    NMA_,NMA_,NMAC,NMAC,NMA_,NMA_,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD, // 60 - 6F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 70 - 7F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 80 - 8F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 90 - 9F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // A0 - AF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // B0 - BF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSIC,NSI_,NSI_,NSI_,NSI_,NSIC, // C0 - CF
    NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC, // D0 - DF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // E0 - EF
    NSI_,NSI_,NSIC,NSIC,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_  // F0 - FF
};

const CHAR_CLASS acc_0E[256] = // U+0Exx
{
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 00 - 0F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 10 - 1F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 20 - 2F
    NTH_,NTHC,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHT, // 30 - 3F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTH_, // 40 - 4F
    NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 50 - 5F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 60 - 6F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 70 - 7F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 80 - 8F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 90 - 9F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // A0 - AF
    NLO_,NLOC,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLO_,NLO_,NLO_, // B0 - BF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC, // C0 - CF
    NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // D0 - DF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // E0 - EF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_  // F0 - FF
};

const CHAR_CLASS acc_0F[256] = // U+0Fxx
{
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTI_,NTI_,NTI_, // 00 - 0F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 10 - 1F
    NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID, // 20 - 2F
    NTID,NTID,NTID,NTID,NTI_,NTIC,NTI_,NTIC,NTI_,NTIC,NTIN,NTIN,NTIN,NTIN,NTIC,NTIC, // 30 - 3F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 40 - 4F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 50 - 5F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 60 - 6F
    NTI_,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 70 - 7F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 80 - 8F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 90 - 9F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // A0 - AF
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTI_,NTI_, // B0 - BF
    NTIC,NTIC,NTIC,NTIC,NTI_,NTI_,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // C0 - CF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // D0 - DF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // E0 - EF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_  // F0 - FF
};

const CHAR_CLASS acc_10[256] = // U+10xx
{
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 00 - 0F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 10 - 1F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC, // 20 - 2F
    NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC, // 30 - 3F
    NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 40 - 4F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 50 - 5F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 60 - 6F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 70 - 7F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 80 - 8F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 90 - 9F
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // A0 - AF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // B0 - BF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // C0 - CF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // D0 - DF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // E0 - EF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGEQ,NGE_,NGE_,NGE_,NGE_  // F0 - FF
};

const CHAR_CLASS acc_13[256] = // U+13xx
{
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 00 - 0F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 10 - 1F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 20 - 2F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 30 - 3F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 40 - 4F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 50 - 5F
    NET_,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETD,NETD,NETD,NETD,NETD,NETD,NETD, // 60 - 6F
    NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NET_,NET_,NET_, // 70 - 7F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 80 - 8F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 90 - 9F
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // A0 - AF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // B0 - BF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // C0 - CF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // D0 - DF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // E0 - EF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_  // F0 - FF
};

const CHAR_CLASS acc_16[256] = // U+16xx
{
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 00 - 0F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 10 - 1F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 20 - 2F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 30 - 3F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 40 - 4F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 50 - 5F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 60 - 6F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 70 - 7F
    NOGS,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_, // 80 - 8F
    NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOGN,NOGN,NOG_,NOG_,NOG_, // 90 - 9F
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // A0 - AF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // B0 - BF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // C0 - CF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // D0 - DF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // E0 - EF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_  // F0 - FF
};

const CHAR_CLASS acc_17[256] = // U+17xx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 80 - 8F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 90 - 9F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // A0 - AF
    NKH_,NKH_,NKH_,NKH_,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // B0 - BF
    NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // C0 - CF
    NKHC,NKHC,NKHC,NKHC,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKHT,NKH_,NKH_,NKH_,NKH_, // D0 - DF
    NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // E0 - EF
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_  // F0 - FF
};

const CHAR_CLASS acc_18[256] = // U+18xx
{
    NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMOB,NMOB,NMOB,NMOB,NMOB, // 00 - 0F
    NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 10 - 1F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 20 - 2F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 30 - 3F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 40 - 4F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 50 - 5F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 60 - 6F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 70 - 7F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 80 - 8F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 90 - 9F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMOC,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // A0 - AF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_1E[256] = // U+1Exx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // B0 - BF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_1F[256] = // U+1Fxx
{
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 00 - 0F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 10 - 1F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 20 - 2F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 30 - 3F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 40 - 4F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 50 - 5F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 60 - 6F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 70 - 7F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 90 - 9F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGR_,NGRN, // B0 - BF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // E0 - EF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN  // F0 - FF
};

const CHAR_CLASS acc_20[256] = // U+20xx
{
    NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NQCS,NWBL,NWBL,NWBL,NWZW,NPZW,NPZW,NPFL,NPF_, // 00 - 0F
    AHYW,NPNW,NHYW,AHYW,AISW,ASNW,ASNW,NONW,AOQW,ARQW,NCQW,NOQW,AOQW,ACQW,NCQW,NOQW, // 10 - 1F
    ASNW,ASNW,NOCW,NONW,NISW,AISW,AISW,AHPW,NSBS,NSBB,NOLE,NORE,NOPF,NOLO,NORO,NBSS, // 20 - 2F
    AQEW,NQEW,AQEW,AQEW,NQEW,AQNW,NQNW,NQNW,NONW,NOQW,NCQW,ASNW,NSSW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NSSW,NOPW,NCPW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NSBN,NSBN,NSBN,NSBN,NSBN,NSBN, // 60 - 6F
    NSEN,NSEN,NSEN,NSEN,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,ASAN, // 70 - 7F
    NSEN,ASAE,ASAE,ASAE,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,NSNW, // 80 - 8F
    NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW, // 90 - 9F
    NOEW,NPEW,NPEW,NOEW,NPEW,NOEW,NOEW,NQEW,NOEW,HPEW,NPEH,NPEV,NOEW,NOEW,NOEW,NOEW, // A0 - AF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // B0 - BF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // C0 - CF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // D0 - DF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // E0 - EF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO  // F0 - FF
};

const CHAR_CLASS acc_21[256] = // U+21xx
{
    NONW,NONW,NOLW,AQNW,NONW,ASNW,NONW,NOLW,NONW,AQNW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 00 - 0F
    NOLW,NOLW,NOLW,ASRN,NONW,NOLW,APNW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW, // 10 - 1F
    NONW,ASNW,ASNW,NONW,NOLW,NONW,AQLW,NONW,NOLW,NONW,NOLW,ASRN,NOLW,NOLW,NOEW,NOLW, // 20 - 2F
    NOLW,NOLW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW, // 30 - 3F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 40 - 4F
    NOLW,NOLW,NOLW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW, // 50 - 5F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 70 - 7F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 80 - 8F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_22[256] = // U+22xx
{
    ASNW,NONW,ASNW,ASNW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW, // 00 - 0F
    NONW,ASNW,NOEW,NOEW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,NONW,NONW,ASNW,NONW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_23[256] = // U+23xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 30 - 3F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 40 - 4F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 50 - 5F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_24[256] = // U+24xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 60 - 6F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 70 - 7F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 80 - 8F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASRN,ASRN,ASRN,ASRN, // 90 - 9F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // A0 - AF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // B0 - BF
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // C0 - CF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // D0 - DF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOEN,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_25[256] = // U+25xx
{
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 00 - 0F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 20 - 2F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 30 - 3F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW, // 40 - 4F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 50 - 5F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 60 - 6F
    ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 80 - 8F
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // B0 - BF
    ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW, // C0 - CF
    ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_26[256] = // U+26xx
{
    NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,ASNW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,NONW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_27[256] = // U+27xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_2E[256] = // U+2Exx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 80 - 8F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 90 - 9F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // A0 - AF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // B0 - BF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // C0 - CF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // D0 - DF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // E0 - EF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_  // F0 - FF
};

const CHAR_CLASS acc_30[256] = // U+30xx
{
    WSP_,WC__,WPE_,WOI_,WOI_,WIM_,WOIL,WOIL,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_, // 00 - 0F
    WOP_,WCP_,WOI_,WOI_,WOB_,WCB_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WSS_,WOQ_,WCQ_,WCQ_, // 10 - 1F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIC,WOIC,WOIC,WOIC,WOIC,WOIC, // 20 - 2F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOI_,WOI_,WOIL,WOIL,WOIL,WOI_,WOI_,WOI_,WOI_,WOI_, // 30 - 3F
    WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 40 - 4F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 50 - 5F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 60 - 6F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 70 - 7F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHS_,WHI_, // 80 - 8F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WKSC,WKSC,WKSM,WKSM,WHIM,WHIM,WHI_, // 90 - 9F
    WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // A0 - AF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // B0 - BF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // C0 - CF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // D0 - DF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKA_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKS_,WKA_,WKA_,WKA_,WKA_,WKC_,WKS_,WKIM,WKIM,WKA_  // F0 - FF
};

const CHAR_CLASS acc_31[256] = // U+31xx
{
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 00 - 0F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 10 - 1F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 20 - 2F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 30 - 3F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 40 - 4F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // A0 - AF
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_  // F0 - FF
};

const CHAR_CLASS acc_32[256] = // U+32xx
{
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 00 - 0F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 10 - 1F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 20 - 2F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 30 - 3F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 40 - 4F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // A0 - AF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // E0 - EF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL  // F0 - FF
};

const CHAR_CLASS acc_33[256] = // U+33xx
{
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 00 - 0F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 10 - 1F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 20 - 2F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 30 - 3F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 40 - 4F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 60 - 6F
    WCI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 70 - 7F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 80 - 8F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 90 - 9F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // A0 - AF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // E0 - EF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_  // F0 - FF
};

const CHAR_CLASS acc_A4[256] = // U+A4xx
{
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 00 - 0F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 10 - 1F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 20 - 2F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 30 - 3F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 40 - 4F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 50 - 5F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 60 - 6F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 70 - 7F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 80 - 8F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // 90 - 9F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // A0 - AF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // B0 - BF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // C0 - CF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // D0 - DF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // E0 - EF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN  // F0 - FF
};

const CHAR_CLASS acc_D8[256] = // U+D8xx
{
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 00 - 0F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 10 - 1F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 20 - 2F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 30 - 3F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 40 - 4F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 50 - 5F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 60 - 6F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 70 - 7F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 80 - 8F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 90 - 9F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // A0 - AF
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // B0 - BF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // C0 - CF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // D0 - DF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // E0 - EF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_  // F0 - FF
};

const CHAR_CLASS acc_E7[256] = // U+E7xx
{
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 00 - 0F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 10 - 1F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 20 - 2F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 30 - 3F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 40 - 4F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 50 - 5F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 60 - 6F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 70 - 7F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 80 - 8F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 90 - 9F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // A0 - AF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // B0 - BF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // C0 - CF
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // D0 - DF
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // E0 - EF
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_  // F0 - FF
};

const CHAR_CLASS acc_E8[256] = // U+E8xx
{
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 00 - 0F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 10 - 1F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 20 - 2F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 30 - 3F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 40 - 4F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 50 - 5F
    WID_,WID_,WID_,WID_,WID_,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 60 - 6F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 70 - 7F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 80 - 8F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 90 - 9F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // A0 - AF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // B0 - BF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // C0 - CF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // D0 - DF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // E0 - EF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA  // F0 - FF
};

const CHAR_CLASS acc_FB[256] = // U+FBxx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NHBR,NHBC,NHBR, // 10 - 1F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBW,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 20 - 2F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 30 - 3F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FD[256] = // U+FDxx
{
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 00 - 0F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 10 - 1F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 20 - 2F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NANW,NANW, // 30 - 3F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // D0 - DF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FE[256] = // U+FExx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5, // 30 - 3F
    WCP5,WOP5,WCP5,WOP5,WCP5,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 40 - 4F
    WC5S,WC5_,WPE5,WOI_,WOC6,WOC5,WQE5,WQE5,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOIT, // 50 - 5F
    WOI_,WOI_,WOIT,WOIT,WOI_,WOI_,WOI_,WOI_,WOI_,WPR_,WQO_,WOI_,WOI_,WOI_,WOI_,WOI_, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NQCW  // F0 - FF
};

const CHAR_CLASS acc_FF[256] = // U+FFxx
{
    XNW_,WQE_,WOI_,WOIT,WPR_,WQO_,WOI_,WOI_,WOB_,WCB_,WOI_,WOIT,WCS_,WOIT,WPES,WOIS, // 00 - 0F
    WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WOCS,WOC_,WOI_,WOI_,WOI_,WQE_, // 10 - 1F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 20 - 2F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOB_,WOI_,WCB_,WOI_,WOI_, // 30 - 3F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 40 - 4F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOP_,WOI_,WCP_,WOI_,XNW_, // 50 - 5F
    XNW_,HPE_,HOP_,HCP_,HCO_,NKCC,NKA_,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL, // 60 - 6F
    NKSL,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 70 - 7F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 80 - 8F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKS_,NKS_, // 90 - 9F
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // A0 - AF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // B0 - BF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // C0 - CF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,XNW_,XNW_,XNW_, // D0 - DF
    WQO_,WPR_,WOI_,WOI_,WOI_,WPR_,WPR_,XNW_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,XNW_, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NOBN,NOBN,NOBN,NONW,NONW,NOBN,XNWB  // F0 - FF
};

#pragma data_seg()   // The following structure contains pointers and so cannot be shared

static const CHAR_CLASS * const pccUnicodeClass[256] =
{
    acc_00, acc_01, acc_02, acc_03, acc_04, acc_05, acc_06, acc_07,  // 00 - 07
    __XNW_, acc_09, acc_0A, acc_0B, acc_0C, acc_0D, acc_0E, acc_0F,  // 08 - 0F
    acc_10, __WHG_, __NET_, acc_13, __NCA_, __NCA_, acc_16, acc_17,  // 10 - 17
    acc_18, __XNW_, __XNW_, __XNW_, __XNW_, __XNW_, acc_1E, acc_1F,  // 18 - 1F
    acc_20, acc_21, acc_22, acc_23, acc_24, acc_25, acc_26, acc_27,  // 20 - 27
    __NBR_, __NONW, __NONW, __XNW_, __XNW_, __XNW_, acc_2E, __WOI_,  // 28 - 2F
    acc_30, acc_31, acc_32, acc_33, __WID_, __WID_, __WID_, __WID_,  // 30 - 37
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 38 - 3F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 40 - 47
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 48 - 4F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 50 - 57
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 58 - 5F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 60 - 67
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 68 - 6F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 70 - 77
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 78 - 7F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 80 - 87
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 88 - 8F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 90 - 97
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 98 - 9F
    __WYI_, __WYI_, __WYI_, __WYI_, acc_A4, __XNW_, __XNW_, __XNW_,  // A0 - A7
    __XNW_, __XNW_, __XNW_, __XNW_, __WHG_, __WHG_, __WHG_, __WHG_,  // A8 - AF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B0 - B7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B8 - BF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C0 - C7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C8 - CF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // D0 - D7
    acc_D8, __NHS_, __NHS_, __NHS_, __LS__, __LS__, __LS__, __LS__,  // D8 - DF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, acc_E7,  // E0 - E7
    acc_E8, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // E8 - EF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // F0 - F7
    __WPUA, __WID_, __WID_, acc_FB, __NAAS, acc_FD, acc_FE, acc_FF   // F8 - FF
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\gpexts\extparse.cxx ===
#include "precomp.hxx"

/* Command line parsing routines
 *
 * This routine should return an array of char* 's in the idx parameter
 * with the beginning of each token in the array.
 * It also returns the number of tokens found. 
 */
int parse_Tokenizer(char *cmdstr, char **tok) {
  char *seps=" \t\n";                  //white space separators
  int tok_count = 0;                   //the token count
  char *token = strtok(cmdstr, seps);  //get the first token
  while(token) {
    tok[tok_count++]=token;
    token = strtok(NULL, seps);
  }
  return tok_count;
}

/* This routine finds the token specified in srchtok 
 * and returns the index into tok.
 * A return value of -1 is used if the token is not found.
 *
 * Generally we use the case insensitive version (parse_iFindToken) 
 * but occasionally we need the case sensitive version (parse_FindToken).
 */
int parse_FindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(strcmp(tok[i], srchtok)==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

int parse_iFindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(_strnicmp(tok[i], srchtok, strlen(srchtok))==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* Verifies that the given token at tok[tok_pos] is a switch
 * and contains the switch value sw.
 *
 * Both case sensitive and insensitive versions.
 */
int parse_iIsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(toupper(*s)==toupper(sw)) {return 1;}
    }
  }
  return 0;
}

int parse_IsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(*s==sw) {return 1;}      //search each char
    }
  }
  return 0;
}

/* Finds a switch in a given list of tokens.
 * of the form -xxx(sw)xxx or /xxx(sw)xxx
 * example:
 * searching for 'a' in -jklabw returns true.
 *
 * Again both case sensitive and insensitive versions are needed.
 */
int parse_FindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {                          //search each token
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}

int parse_iFindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}


/* Find the first non-switch token starting from position start
 * Will find token at position start
 */
int parse_FindNonSwitch(char **tok, int ntok, int start) {
  for(int i=start; i<ntok; i++) {
    if((tok[i][0]!='-')&&(tok[i][0]!='/')) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* case insensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 *
 * Pay careful attention to the length specifier in the _strnicmp
 */
int parse_iIsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (_strnicmp(tok[tok_pos], chk, strlen(chk))==0);
}

/* case sensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 */
int parse_IsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (strcmp(tok[tok_pos], chk)==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\unilib\secondaryclassification.cpp ===
#include "SecondaryClassification.hpp"

///// SecondaryClassification
//
//    Provides classification for digit substitution, symmetric glyph
//    mirroring and auto vertical glyph rotoation.
//
//    DO NOT EDIT
//
//    Generated by engine/text/unilib/tools/upright.pl

const unsigned char ScBaseToScFlags[] = {
/*ScCSAN*/    SecClassCS | SecClassSA,
/*ScCSNN*/    SecClassCS,
/*ScENAN*/    SecClassEN | SecClassSA,
/*ScENNN*/    SecClassEN,
/*ScETAN*/    SecClassET | SecClassSA,
/*ScETNN*/    SecClassET,
/*ScNNAN*/    SecClassSA,
/*ScNNAS*/    SecClassSA | SecClassMS,
/*ScNNFN*/    SecClassSF,
/*ScNNNN*/    0,
/*ScNNNS*/    SecClassMS,
};

const SecondaryClassification ScFlagsToScFE[] = {
    ScOther,  ScEN,     ScCS,     ScET,     // 00 - 03
    ScMirSub, ScMirSub, ScMirSub, ScMirSub, // 04 - 07 MS
    ScMirXfm, ScMirXfm, ScMirXfm, ScMirXfm, // 08 - 0C MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 0D - 0F invalid
    ScSide,   ScSide,   ScSide,   ScSide,   // 10 - 13 SA
    ScSide,   ScSide,   ScSide,   ScSide,   // 14 - 17 SA MS
    ScSide,   ScSide,   ScSide,   ScSide,   // 18 - 1C SA MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 1D - 1F invalid
    ScSide,   ScSide,   ScSide,   ScSide,   // 20 - 23 SF
    ScSide,   ScSide,   ScSide,   ScSide,   // 24 - 27 SF MS
    ScSide,   ScSide,   ScSide,   ScSide,   // 28 - 2C SF MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 2D - 2F invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 30 - 33 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 34 - 37 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 38 - 3C invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 3D - 3F invalid
};

const SecondaryClassification ScFlagsToScEng[] = {
    ScOther,  ScEN,     ScCS,     ScET,     // 00 - 03
    ScMirSub, ScMirSub, ScMirSub, ScMirSub, // 04 - 07 MS
    ScMirXfm, ScMirXfm, ScMirXfm, ScMirXfm, // 08 - 0C MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 0D - 0F invalid
    ScSide,   ScSide,   ScSide,   ScSide,   // 10 - 13 SA
    ScSide,   ScSide,   ScSide,   ScSide,   // 14 - 17 SA MS
    ScSide,   ScSide,   ScSide,   ScSide,   // 18 - 1C SA MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 1D - 1F invalid
    ScOther,  ScEN,     ScCS,     ScET,     // 20 - 23 SF
    ScMirSub, ScMirSub, ScMirSub, ScMirSub, // 24 - 27 SF MS
    ScMirXfm, ScMirXfm, ScMirXfm, ScMirXfm, // 28 - 2C SF MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 2D - 2F invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 30 - 33 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 34 - 37 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 38 - 3C invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 3D - 3F invalid
};


unsigned char ScPage00[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScETNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScETNN, ScCSNN, ScETNN, ScCSNN, ScNNNN, 
  ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScCSNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScCSNN, ScNNNN, ScETNN, ScETNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETNN, ScETNN, ScENNN, ScENNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScENNN, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage06[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScCSNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage09[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage0E[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage17[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage20[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScENNN, ScNNNN, ScNNNN, ScNNNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScETNN, ScETNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, 
  ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScETNN, ScETNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage21[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage22[] = {
  ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNS, ScETNN, ScETNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, 
  ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage23[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage24[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScENAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage25[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage2E[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage2F[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage30[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, 
  ScNNAS, ScNNAS, ScNNAN, ScNNAN, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage31[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageA4[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageD7[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageD8[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageDB[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
};

unsigned char ScPageFB[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageFE[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScCSNN, ScNNNN, ScCSNN, ScNNNN, ScNNNN, ScCSNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, 
  ScNNNN, ScNNNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageFF[] = {
  ScNNAN, ScNNAN, ScNNAN, ScETAN, ScETAN, ScETAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScETAN, ScCSAN, ScETAN, ScCSAN, ScNNAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScCSAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETAN, ScETAN, ScNNAN, ScNNAN, ScNNAN, ScETAN, ScETAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};



/// Classes used for entire pages
//

unsigned char ScPgNNAN[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPgNNFN[] = {
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
};

unsigned char ScPgNNNN[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};



const unsigned char *SecondaryClassificationLookup[] = {
  ScPage00, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage06, ScPgNNNN, ScPgNNNN, ScPage09, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage0E, ScPgNNNN, 
  ScPgNNNN, ScPgNNAN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage17, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, 
  ScPage20, ScPage21, ScPage22, ScPage23, ScPage24, ScPage25, ScPgNNAN, ScPgNNAN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage2E, ScPage2F, 
  ScPage30, ScPage31, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPageA4, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPageD7, ScPageD8, ScPgNNNN, ScPgNNNN, ScPageDB, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, 
  ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, 
  ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNAN, ScPgNNAN, ScPageFB, ScPgNNNN, ScPgNNNN, ScPageFE, ScPageFF, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\gpexts\gpexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: gpexts.cxx
*
* This file is for debugging tools and extensions.
*
* Created: 05-14-99
* Author: Adrian Secchia
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
#include <excpt.h>
#include <ntstatus.h>
#include <wdbgexts.h>
};

/***************************************************************************\
* Global variables
\***************************************************************************/
WINDBG_EXTENSION_APIS   ExtensionApis;
EXT_API_VERSION         ApiVersion = { (GPVER_PRODUCTVERSION_W >> 8), (GPVER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

char *gaszHelpCli[] = {
 "=======================================================================\n"
,"GPEXTS client debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"GDI+ UM debugger extensions\n"
,"dgraphics: dumps a Graphics structure\n"
,"dgpgraphics: dumps a GpGraphics structure\n"
,"dmh: dumps gdi+ memory header for memory tracking\n"
,"=======================================================================\n"
,NULL
};

DECLARE_API(help)
{
    char **ppsz = gaszHelpCli;
    while (*ppsz)
      dprintf(*ppsz++);

}

char *gaszStatus[] = {
 "Ok"
,"GenericError"
,"InvalidParameter"
,"OutOfMemory"
,"ObjectBusy"
,"InsufficientBuffer"
,"NotImplemented"
,"Win32Error"
,NULL
};

DECLARE_API(dgraphics)
{
  ULONG Size;
  using namespace Gdiplus;
  GPOBJECT(Gdiplus::Graphics, g);
  PARSE_POINTER(dgraphics_help);
  ReadMemory(arg, g, sizeof(Gdiplus::Graphics), &Size);

  dprintf("Graphics\n");
  dprintf("GpGraphics   *nativeGraphics     %p\n",      g->nativeGraphics);
  dprintf("Status       lastResult          %s (%d)\n", gaszStatus[g->lastResult], g->lastResult);
  return;

dgraphics_help:
    dprintf("Usage: dgraphics [-?] graphics\n");
}


char *gaszGraphicsType[] = {
 "GraphicsBitmap"
,"GraphicsScreen"
,"GraphicsMetafile"
,NULL
};

DECLARE_API(dgpgraphics)
{
  ULONG Size;
  GPOBJECT(GpGraphics, g);
  PARSE_POINTER(dgpgraphics_help);
  ReadMemory(arg, g, sizeof(GpGraphics), &Size);

  dprintf("GpGraphics\n");
  dprintf("GpLockable   Lockable.LockCount  %ld\n", g->Lockable.LockCount);
  dprintf("BOOL         Valid               %s\n",  (g->Tag == ObjectTagGraphics)?"True":"False");
  dprintf("GpRect       SurfaceBounds       (%#lx, %#lx, %#lx, %#lx)\n",
            g->SurfaceBounds.X,
            g->SurfaceBounds.Y,
            g->SurfaceBounds.Width,
            g->SurfaceBounds.Height);
  dprintf("DpBitmap     *Surface            %p\n", g->Surface);
  dprintf("GpMetafile   *Metafile           %p\n", g->Metafile);
  dprintf("GraphicsType Type                %s (%d)\n", gaszGraphicsType[g->Type], g->Type);
  dprintf("GpDevice     *Device             %p\n", g->Device);
  dprintf("DpDriver     *Driver             %p\n", g->Driver);
  dprintf("DpContext    *Context            %p\n", g->Context);
  dprintf("&DpContext   BottomContext       %p\n", GPOFFSETOF(g->BottomContext));
  dprintf("&DpRegion    WindowClip          %p\n", GPOFFSETOF(g->WindowClip));

  return;

dgpgraphics_help:
    dprintf("Usage: dgpgraphics [-?] graphics\n");
  return;
}


// copied from Engine\runtime\standalone\mem.cpp

enum AllocTrackHeaderFlags
{
    MemoryAllocated     = 0x00000001,
    MemoryFreed         = 0x00000002,     // useful in catching double frees
    APIAllocation       = 0x00000004
};

struct AllocTrackHeader {
  struct AllocTrackHeader *flink;
  struct AllocTrackHeader *blink;
  DWORD  size;
  DWORD  caller_address;
  DWORD  flags;
#if DBROWN
  char  *callerFileName;
  INT    callerLineNumber;
#endif
};


DECLARE_API(dmh)
{
  ULONG Size;
  BOOL bRecursive = FALSE;
  BOOL bFLink = FALSE;
  BOOL bBLink = FALSE;
  BOOL bCount = FALSE;
  BOOL bAPI = FALSE;
  int count = 0;

  GPOBJECT(AllocTrackHeader, hdr);
  PARSE_POINTER(dmh_help);


  if(parse_iFindSwitch(tokens, ntok, 'r')!=-1) { bRecursive = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) { bFLink = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'b')!=-1) { bBLink = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'c')!=-1) { bCount = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) { bAPI = TRUE; }


  do {

    ReadMemory(arg, hdr, sizeof(AllocTrackHeader), &Size);

    if( !bAPI || (hdr->flags & APIAllocation) )
    {
      if(!bCount) {
        dprintf("GPMEM Block (%p)\n", arg);
        dprintf("FLink               0x%p\n", hdr->flink);
        dprintf("BLink               0x%p\n", hdr->blink);
        dprintf("size                0x%p\n", hdr->size);
        dprintf("Allocation callsite 0x%p\n", hdr->caller_address);
        dprintf("Flags               0x%p ", hdr->flags);
        if(hdr->flags & APIAllocation) {dprintf("API");}
        dprintf("\n");
      }
    
      count++;
    }
    arg = (UINT_PTR)(hdr->flink);
    if(bBLink) arg = (UINT_PTR)(hdr->blink);

  } while( bRecursive && arg );


  if(bRecursive) {
    dprintf("Total: %d\n", count);
  }

  return;

dmh_help:
  dprintf("Usage: dmh [-?] [-rfbca] memoryblock\n");
  dprintf("  FLink and BLink are forward and backward memory links in the\n"
          "    double linked list of tracked allocations\n");
  dprintf("  Size is the amount of memory in this allocation\n");
  dprintf("  Allocation Callsite is the return address of the GpMalloc call that\n"
          "    allocated this memory block. Unassemble to find the symbol\n");
  dprintf("  The tracked memory list head is at gdiplus!gpmemAllocList\n");
  dprintf("  -r recursive - default FLink \n");
  dprintf("  -f follow FLink (only useful with -r)\n");
  dprintf("  -b follow BLink (only useful with -r, will override -f)\n");
  dprintf("  -c Suppress output, only display the count. Only useful with -r\n");
  dprintf("  -a Only display blocks with the API flag set.\n");
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplus.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.h
*
* Abstract:
*
*   GDI+ public header file
*
\**************************************************************************/

#ifndef _GDIPLUS_H
#define _GDIPLUS_H

struct IDirectDrawSurface7;

typedef signed   short   INT16;
typedef unsigned short  UINT16;

#include <pshpack8.h>   // set structure packing to 8

namespace Gdiplus
{
    namespace DllExports
    {
        #include "GdiplusMem.h"
    };

    #include "GdiplusBase.h"

    #include "GdiplusEnums.h"
    #include "GdiplusTypes.h"
    #include "GdiplusInit.h"
    #include "GdiplusPixelFormats.h"
    #include "GdiplusColor.h"
    #include "GdiplusMetaHeader.h"
    #include "GdiplusImaging.h"
    #include "GdiplusColorMatrix.h"

    #include "GdiplusGpStubs.h"
    #include "GdiplusHeaders.h"

    namespace DllExports
    {
        #include "GdiplusFlat.h"
    };


    #include "GdiplusImageAttributes.h"
    #include "GdiplusMatrix.h"
    #include "GdiplusBrush.h"
    #include "GdiplusPen.h"
    #include "GdiplusStringFormat.h"
    #include "GdiplusPath.h"
    #include "GdiplusLineCaps.h"
    #include "GdiplusMetafile.h"
    #include "GdiplusGraphics.h"
    #include "GdiplusCachedBitmap.h"
    #include "GdiplusRegion.h"
    #include "GdiplusFontCollection.h"
    #include "GdiplusFontFamily.h"
    #include "GdiplusFont.h"
    #include "GdiplusBitmap.h"
    #include "GdiplusImageCodec.h"

}; // namespace Gdiplus

#include <poppack.h>    // pop structure packing back to previous state

#endif // !_GDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\privinc\imaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imaging.h
*
* Abstract:
*
*   Public SDK header file for the imaging library
*
* Notes:
*
*   This is hand-coded for now. Eventually it'll be automatically
*   generated from an IDL file.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGING_H
#define _IMAGING_H

#include "..\sdkinc\GdiplusPixelFormats.h"
#include "..\sdkinc\GdiplusImaging.h"

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include "imgguids.h"

// Default bitmap resolution

#define DEFAULT_RESOLUTION 96   // most display screens are set to 96 dpi

// Default thumbnail image size in pixels

#define DEFAULT_THUMBNAIL_SIZE 120


//
// Image Property types
//

#define TAG_TYPE_BYTE       1   // 8-bit unsigned int
#define TAG_TYPE_ASCII      2   // 8-bit byte containing one 7-bit ASCII code.
                                // NULL terminated.
#define TAG_TYPE_SHORT      3   // 16-bit unsigned int
#define TAG_TYPE_LONG       4   // 32-bit unsigned int
#define TAG_TYPE_RATIONAL   5   // Two LONGs.  The first LONG is the numerator,
                                // the second LONG expresses the denomintor.
#define TAG_TYPE_UNDEFINED  7   // 8-bit byte that can take any value depending
                                // on field definition
#define TAG_TYPE_SLONG      9   // 32-bit singed integer (2's compliment
                                // notation)
#define TAG_TYPE_SRATIONAL  10  // Two SLONGs. First is numerator, second is
                                // denominator.


//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_NEW_SUBFILE_TYPE    0x00FE
#define TAG_SUBFILE_TYPE        0x00FF
#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_THRESH_HOLDING      0x0107
#define TAG_CELL_WIDTH          0x0108
#define TAG_CELL_HEIGHT         0x0109
#define TAG_FILL_ORDER          0x010A
#define TAG_DOCUMENT_NAME       0x010D
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_MIN_SAMPLE_VALUE    0x0118
#define TAG_MAX_SAMPLE_VALUE    0x0119
#define TAG_X_RESOLUTION        0x011A  // Image resolution in width direction
#define TAG_Y_RESOLUTION        0x011B  // Image resolution in height direction
#define TAG_PLANAR_CONFIG       0x011C  // Image data arrangement
#define TAG_PAGE_NAME           0x011D
#define TAG_X_POSITION          0x011E
#define TAG_Y_POSITION          0x011F
#define TAG_FREE_OFFSET         0x0120
#define TAG_FREE_BYTE_COUNTS    0x0121
#define TAG_GRAY_RESPONSE_UNIT  0x0122
#define TAG_GRAY_RESPONSE_CURVE 0x0123
#define TAG_T4_OPTION           0x0124
#define TAG_T6_OPTION           0x0125
#define TAG_RESOLUTION_UNIT     0x0128  // Unit of X and Y resolution
#define TAG_PAGE_NUMBER         0x0129
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_HOST_COMPUTER       0x013C
#define TAG_PREDICTOR           0x013D
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F
#define TAG_COLOR_MAP           0x0140
#define TAG_HALFTONE_HINTS      0x0141
#define TAG_TILE_WIDTH          0x0142
#define TAG_TILE_LENGTH         0x0143
#define TAG_TILE_OFFSET         0x0144
#define TAG_TILE_BYTE_COUNTS    0x0145
#define TAG_INK_SET             0x014C
#define TAG_INK_NAMES           0x014D
#define TAG_NUMBER_OF_INKS      0x014E
#define TAG_DOT_RANGE           0x0150
#define TAG_TARGET_PRINTER      0x0151
#define TAG_EXTRA_SAMPLES       0x0152
#define TAG_SAMPLE_FORMAT       0x0153
#define TAG_SMIN_SAMPLE_VALUE   0x0154
#define TAG_SMAX_SAMPLE_VALUE   0x0155
#define TAG_TRANSFER_RANGE      0x0156

#define TAG_JPEG_PROC           0x0200
#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_JPEG_RESTART_INTERVAL     0x0203
#define TAG_JPEG_LOSSLESS_PREDICTORS  0x0205
#define TAG_JPEG_POINT_TRANSFORMS     0x0206
#define TAG_JPEG_Q_TABLES       0x0207
#define TAG_JPEG_DC_TABLES      0x0208
#define TAG_JPEG_AC_TABLES      0x0209

#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

// ICC profile and gamma
#define TAG_ICC_PROFILE         0x8773          // This TAG is defined by ICC
                                                // for embedded ICC in TIFF
#define TAG_GAMMA               0x0301
#define TAG_ICC_PROFILE_DESCRIPTOR  0x0302
#define TAG_SRGB_RENDERING_INTENT   0x0303

#define TAG_IMAGE_TITLE         0x0320

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT           0x5001
#define TAG_RESOLUTION_Y_UNIT           0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT    0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT    0x5004
#define TAG_PRINT_FLAGS                 0x5005
#define TAG_PRINT_FLAGS_VERSION         0x5006
#define TAG_PRINT_FLAGS_CROP            0x5007
#define TAG_PRINT_FLAGS_BLEEDWIDTH      0x5008
#define TAG_PRINT_FLAGS_BLEEDWIDTHSCALE 0x5009
#define TAG_HALFTONE_LPI                0x500A
#define TAG_HALFTONE_LPI_UNIT           0x500B
#define TAG_HALFTONE_DEGREE             0x500C
#define TAG_HALFTONE_SHAPE              0x500D
#define TAG_HALFTONE_MISC               0x500E
#define TAG_HALFTONE_SCREEN             0x500F
#define TAG_JPEG_QUALITY                0x5010
#define TAG_GRID_SIZE                   0x5011
#define TAG_THUMBNAIL_FORMAT            0x5012  // 1 = JPEG, 0 = RAW RGB
#define TAG_THUMBNAIL_WIDTH             0x5013
#define TAG_THUMBNAIL_HEIGHT            0x5014
#define TAG_THUMBNAIL_COLORDEPTH        0x5015
#define TAG_THUMBNAIL_PLANES            0x5016
#define TAG_THUMBNAIL_RAWBYTES          0x5017
#define TAG_THUMBNAIL_SIZE              0x5018
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5019
#define TAG_COLORTRANSFER_FUNCTION      0x501A
#define TAG_THUMBNAIL_DATA              0x501B  // RAW thumbnail bits in JPEG
                                                // format or RGB format depends
                                                // on TAG_THUMBNAIL_FORMAT

// Thumbnail related TAGs
                                                
#define TAG_THUMBNAIL_IMAGE_WIDTH       0x5020  // Thumbnail width
#define TAG_THUMBNAIL_IMAGE_HEIGHT      0x5021  // Thumbnail height
#define TAG_THUMBNAIL_BITS_PER_SAMPLE   0x5022  // Number of bits per component
#define TAG_THUMBNAIL_COMPRESSION       0x5023  // Compression Scheme
#define TAG_THUMBNAIL_PHOTOMETRIC_INTERP 0x5024 // Pixel composition
#define TAG_THUMBNAIL_IMAGE_DESCRIPTION 0x5025  // Image Tile
#define TAG_THUMBNAIL_EQUIP_MAKE        0x5026  // Manufacturer of Image Input
                                                // equipment
#define TAG_THUMBNAIL_EQUIP_MODEL       0x5027  // Model of Image input
                                                // equipment
#define TAG_THUMBNAIL_STRIP_OFFSETS     0x5028  // Image data location
#define TAG_THUMBNAIL_ORIENTATION       0x5029  // Orientation of image
#define TAG_THUMBNAIL_SAMPLES_PER_PIXEL 0x502A  // Number of components
#define TAG_THUMBNAIL_ROWS_PER_STRIP    0x502B  // Number of rows per strip
#define TAG_THUMBNAIL_STRIP_BYTES_COUNT 0x502C  // Bytes per compressed strip
#define TAG_THUMBNAIL_RESOLUTION_X      0x502D  // Resolution in width direction
#define TAG_THUMBNAIL_RESOLUTION_Y      0x502E  // Resolution in height direc
#define TAG_THUMBNAIL_PLANAR_CONFIG     0x502F  // Image data arrangement
#define TAG_THUMBNAIL_RESOLUTION_UNIT   0x5030  // Unit of X and Y Resolution
#define TAG_THUMBNAIL_TRANSFER_FUNCTION 0x5031  // Transfer function
#define TAG_THUMBNAIL_SOFTWARE_USED     0x5032  // Software used
#define TAG_THUMBNAIL_DATE_TIME         0x5033  // File change date and time
#define TAG_THUMBNAIL_ARTIST            0x5034  // Person who created the image
#define TAG_THUMBNAIL_WHITE_POINT       0x5035  // White point chromaticity
#define TAG_THUMBNAIL_PRIMAY_CHROMATICS 0x5036  // Chromaticities of primaries
#define TAG_THUMBNAIL_YCbCr_COEFFICIENTS 0x5037 // Color space transformation
                                                // coefficients
#define TAG_THUMBNAIL_YCbCr_SUBSAMPLING 0x5038  // Subsampling ratio of Y to C
#define TAG_THUMBNAIL_YCbCr_POSITIONING 0x5039  // Y and C position
#define TAG_THUMBNAIL_REF_BLACK_WHITE   0x503A  // Pair of black and white
                                                // reference values
#define TAG_THUMBNAIL_COPYRIGHT         0x503B  // CopyRight holder

#define TAG_INTEROP_INDEX               0x5041  // InteroperabilityIndex
#define TAG_INTEROP_EXIFR98VER          0x5042  // ExifR98 Version

// Special JPEG internal values

#define TAG_LUMINANCE_TABLE             0x5090
#define TAG_CHROMINANCE_TABLE           0x5091

// GIF image

#define TAG_FRAMEDELAY                  0x5100
#define TAG_LOOPCOUNT                   0x5101

// PNG Image

#define TAG_PIXEL_UNIT                  0x5110  // Unit specifier for pixel/unit
#define TAG_PIXEL_PER_UNIT_X            0x5111  // Pixels per unit in X
#define TAG_PIXEL_PER_UNIT_Y            0x5112  // Pixels per unit in Y
#define TAG_PALETTE_HISTOGRAM           0x5113  // Palette histogram

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

typedef PixelFormat PixelFormatID;

// Map COM Flags to GDI+ Flags
#define PIXFMTFLAG_INDEXED      PixelFormatIndexed
#define PIXFMTFLAG_GDI          PixelFormatGDI
#define PIXFMTFLAG_ALPHA        PixelFormatAlpha
#define PIXFMTFLAG_PALPHA       PixelFormatPAlpha
#define PIXFMTFLAG_EXTENDED     PixelFormatExtended
#define PIXFMTFLAG_CANONICAL    PixelFormatCanonical
#define PIXFMT_UNDEFINED        PixelFormatUndefined
#define PIXFMT_DONTCARE         PixelFormatDontCare
#define PIXFMT_1BPP_INDEXED     PixelFormat1bppIndexed
#define PIXFMT_4BPP_INDEXED     PixelFormat4bppIndexed
#define PIXFMT_8BPP_INDEXED     PixelFormat8bppIndexed
#define PIXFMT_16BPP_GRAYSCALE  PixelFormat16bppGrayScale
#define PIXFMT_16BPP_RGB555     PixelFormat16bppRGB555
#define PIXFMT_16BPP_RGB565     PixelFormat16bppRGB565
#define PIXFMT_16BPP_ARGB1555   PixelFormat16bppARGB1555
#define PIXFMT_24BPP_RGB        PixelFormat24bppRGB
#define PIXFMT_32BPP_RGB        PixelFormat32bppRGB
#define PIXFMT_32BPP_ARGB       PixelFormat32bppARGB
#define PIXFMT_32BPP_PARGB      PixelFormat32bppPARGB
#define PIXFMT_48BPP_RGB        PixelFormat48bppRGB
#define PIXFMT_64BPP_ARGB       PixelFormat64bppARGB
#define PIXFMT_64BPP_PARGB      PixelFormat64bppPARGB

#define PIXFMT_24BPP_BGR        (15 | (24 << 8) | PixelFormatGDI)
#define PIXFMT_MAX              PixelFormatMax + 1

#define PALFLAG_HASALPHA        PaletteFlagsHasAlpha
#define PALFLAG_GRAYSCALE       PaletteFlagsGrayScale
#define PALFLAG_HALFTONE        PaletteFlagsHalftone

#define IMGLOCK_READ              ImageLockModeRead
#define IMGLOCK_WRITE             ImageLockModeWrite
#define IMGLOCK_USERINPUTBUF      ImageLockModeUserInputBuf

#define IMGFLAG_NONE                ImageFlagsNone
#define IMGFLAG_SCALABLE            ImageFlagsScalable
#define IMGFLAG_HASALPHA            ImageFlagsHasAlpha
#define IMGFLAG_HASTRANSLUCENT      ImageFlagsHasTranslucent
#define IMGFLAG_PARTIALLY_SCALABLE  ImageFlagsPartiallyScalable
#define IMGFLAG_COLORSPACE_RGB      ImageFlagsColorSpaceRGB
#define IMGFLAG_COLORSPACE_CMYK     ImageFlagsColorSpaceCMYK
#define IMGFLAG_COLORSPACE_GRAY     ImageFlagsColorSpaceGRAY
#define IMGFLAG_COLORSPACE_YCBCR    ImageFlagsColorSpaceYCBCR
#define IMGFLAG_COLORSPACE_YCCK     ImageFlagsColorSpaceYCCK
#define IMGFLAG_HASREALDPI          ImageFlagsHasRealDPI
#define IMGFLAG_HASREALPIXELSIZE    ImageFlagsHasRealPixelSize
#define IMGFLAG_READONLY            ImageFlagsReadOnly
#define IMGFLAG_CACHING             ImageFlagsCaching

#define ImageFlag                   ImageFlags


//
// Decoder flags
//

/* Only used in COM interface */
enum DecoderInitFlag
{
    DecoderInitFlagNone        = 0,

    // NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DecoderInitFlagNoBlock     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DecoderInitFlagBuiltIn1st  = 0x0002
};

#define DECODERINIT_NONE          DecoderInitFlagNone
#define DECODERINIT_NOBLOCK       DecoderInitFlagNoBlock
#define DECODERINIT_BUILTIN1ST    DecoderInitFlagBuiltIn1st

/* Only used in COM interface */
enum BufferDisposalFlag
{
    BufferDisposalFlagNone,
    BufferDisposalFlagGlobalFree,
    BufferDisposalFlagCoTaskMemFree,
    BufferDisposalFlagUnmapView
};
    
#define DISPOSAL_NONE            BufferDisposalFlagNone
#define DISPOSAL_GLOBALFREE      BufferDisposalFlagGlobalFree
#define DISPOSAL_COTASKMEMFREE   BufferDisposalFlagCoTaskMemFree
#define DISPOSAL_UNMAPVIEW       BufferDisposalFlagUnmapView

//---------------------------------------------------------------------------
// Intepolation hints used by resize/rotation operations
//---------------------------------------------------------------------------
enum InterpolationHint
{
    InterpolationHintDefault,
    InterpolationHintNearestNeighbor,
    InterpolationHintBilinear,
    InterpolationHintAveraging,
    InterpolationHintBicubic
};

#define INTERP_DEFAULT              InterpolationHintDefault
#define INTERP_NEAREST_NEIGHBOR     InterpolationHintNearestNeighbor
#define INTERP_BILINEAR             InterpolationHintBilinear
#define INTERP_AVERAGING            InterpolationHintAveraging
#define INTERP_BICUBIC              InterpolationHintBicubic

#define IMGCODEC_ENCODER          ImageCodecFlagsEncoder
#define IMGCODEC_DECODER          ImageCodecFlagsDecoder
#define IMGCODEC_SUPPORT_BITMAP   ImageCodecFlagsSupportBitmap
#define IMGCODEC_SUPPORT_VECTOR   ImageCodecFlagsSupportVector
#define IMGCODEC_SEEKABLE_ENCODE  ImageCodecFlagsSeekableEncode
#define IMGCODEC_BLOCKING_DECODE  ImageCodecFlagsBlockingDecode

#define IMGCODEC_BUILTIN          ImageCodecFlagsBuiltin
#define IMGCODEC_SYSTEM           ImageCodecFlagsSystem
#define IMGCODEC_USER             ImageCodecFlagsUser

//
// Identifier for channel(s) in a pixel
//
/* Only used internally */
enum ChannelID
{
    ChannelID_Alpha      = 0x00000001,
    ChannelID_Red        = 0x00000002,
    ChannelID_Green      = 0x00000004,
    ChannelID_Blue       = 0x00000008,
    ChannelID_Color      = ChannelID_Red|ChannelID_Green|ChannelID_Blue,
    ChannelID_All        = ChannelID_Color|ChannelID_Alpha,
    
    ChannelID_Intensity  = 0x00010000
};

//
// Data structure for communicating to an image sink
//

/* Only used internally */
enum SinkFlags
{
    // Low-word: shared with ImgFlagx

    SinkFlagsScalable          = ImageFlagsScalable,
    SinkFlagsHasAlpha          = ImageFlagsHasAlpha,
    SinkFlagsPartiallyScalable = ImageFlagsPartiallyScalable,
    
    // High-word

    SinkFlagsTopDown    = 0x00010000,
    SinkFlagsBottomUp   = 0x00020000,
    SinkFlagsFullWidth  = 0x00040000,
    SinkFlagsMultipass  = 0x00080000,
    SinkFlagsComposite  = 0x00100000,
    SinkFlagsWantProps  = 0x00200000
};

#define SINKFLAG_SCALABLE           SinkFlagsScalable
#define SINKFLAG_HASALPHA           SinkFlagsHasAlpha
#define SINKFLAG_PARTIALLY_SCALABLE SinkFlagsPartiallyScalable
#define SINKFLAG_TOPDOWN    SinkFlagsTopDown
#define SINKFLAG_BOTTOMUP   SinkFlagsBottomUp
#define SINKFLAG_FULLWIDTH  SinkFlagsFullWidth
#define SINKFLAG_MULTIPASS  SinkFlagsMultipass
#define SINKFLAG_COMPOSITE  SinkFlagsComposite
#define SINKFLAG_WANTPROPS  SinkFlagsWantProps

/* Only used internally */
struct ImageInfo
{
    GUID RawDataFormat;
    PixelFormat PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
};

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;

//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;
};

//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp,
        BOOL    bNeedCloneProperty
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        ) = 0;

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID     Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID     Guid,
        IN UINT     Length,
        IN PVOID    Value
        ) = 0;
    
    // Property related functions

    STDMETHOD(GetPropertyCount)(
        OUT UINT* numOfProperty
        ) = 0;

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
  	    IN OUT PROPID* list
        ) = 0;

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        ) = 0;
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID propId,
        IN UINT propSize,
        IN OUT PropertyItem* buffer
        ) = 0;

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
		OUT UINT* numProperties
        ) = 0;

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        ) = 0;

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        ) = 0;

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        ) = 0;

    STDMETHOD(GetRawInfo)(
        IN OUT VOID **ppRawInfo
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(NeedRawProperty)(
        IN void *pSrc) = 0;
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        ) = 0;

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        ) = 0;
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        ) = 0;
};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
    
    STDMETHOD(GetEncoderParameterListSize)(
       	OUT UINT* size
        ) = 0;

    STDMETHOD(GetEncoderParameterList)(
        IN UINT	  size,
        OUT EncoderParameters* Params
        ) = 0;

    STDMETHOD(SetEncoderParameters)(
        IN const EncoderParameters* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)
#define IMGERR_FAILLOADCODEC    MAKE_IMGERR(9)
#define IMGERR_PROPERTYNOTFOUND MAKE_IMGERR(10)
#define IMGERR_PROPERTYNOTSUPPORTED MAKE_IMGERR(11)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusbase.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBase.h
*
* Abstract:
*
*   GDI+ base memory allocation class
*
\**************************************************************************/

#ifndef _GDIPLUSBASE_H
#define _GDIPLUSBASE_H

class GdiplusBase
{
public:
    void (operator delete)(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new)(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
    void (operator delete[])(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new[])(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\privinc\pixelformats.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Pixel Format definitions.
*
* Abstract:
*
*   Internal pixel format definitions.
*
* Created:
*
*   08/09/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _PIXELFORMATS_H
#define _PIXELFORMATS_H


// First bit of the reserved area
// Used for surfaces that have multiple pixel formats
// e.g. the meta device surface for the multimon driver.

#define PixelFormatMulti        ((PixelFormatID)0x10000000)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\privinc\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DECODER_ICONRES, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
DEFINE_GUID(DECODER_USEICC,  0x1d6347c4,0x5ec2,0x4070,0x81,0x4d,0x7a,0x6e,0x39,0xa4,0x23,0xa2);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
DEFINE_GUID(ENCODER_TRANSFORMATION,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(ENCODER_LUMINANCE_TABLE,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(ENCODER_CHROMINANCE_TABLE,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(ENCODER_TRIMEDGE,0xac9cd9ec,0x116a,0x484e,0xba,0xea,0xca,0x32,0xef,0x9b,0x84,0x80);
DEFINE_GUID(ENCODER_SUPPRESSAPP0,0xb42b3959,0x57ef,0x4efc,0xa3,0x63,0x94,0x22,0x0,0x8a,0xdc,0xb4);
DEFINE_GUID(ENCODER_SAVE_FLAG,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusbitmap.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBitmap.h
*
* Abstract:
*
*   GDI+ Bitmap class
*
\**************************************************************************/

#ifndef _GDIPLUSBITMAP_H
#define _GDIPLUSBITMAP_H

inline 
Image::Image(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromFileICM(
            filename, 
            &nativeImage
        );
    }
    else
    {      
        lastResult = DllExports::GdipLoadImageFromFile(
            filename, 
            &nativeImage
        );
    }
}

inline 
Image::Image(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromStreamICM(
            stream, 
            &nativeImage
        );
    }
    else
    {
        lastResult = DllExports::GdipLoadImageFromStream(
            stream, 
            &nativeImage
        );
    }
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Image*
Image::FromStream(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        stream,
        useEmbeddedColorManagement
    );
}

inline 
Image::~Image()
{
    DllExports::GdipDisposeImage(nativeImage);
}

inline Image* 
Image::Clone() 
{
    GpImage *cloneimage = NULL;

    SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

    return new Image(cloneimage, lastResult);
}

inline UINT
Image::GetEncoderParameterListSize(
    IN const CLSID* clsidEncoder
    ) 
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetEncoderParameterListSize(nativeImage,
                                                          clsidEncoder,
                                                          &size));
    return size;
}

inline Status
Image::GetEncoderParameterList(
    IN const CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* buffer
    )
{
    return SetStatus(DllExports::GdipGetEncoderParameterList(nativeImage,
                                                             clsidEncoder,
                                                             size,
                                                             buffer));
}

inline Status
Image::Save(
    IN const WCHAR* filename,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToFile(nativeImage,
                                                     filename,
                                                     clsidEncoder,
                                                     encoderParams));
}

inline Status
Image::Save(
    IN IStream* stream,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToStream(nativeImage,
                                                       stream,
                                                       clsidEncoder,
                                                       encoderParams));
}

inline Status
Image::SaveAdd(
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveAdd(nativeImage,
                                             encoderParams));
}

inline Status
Image::SaveAdd(
    IN Image* newImage,
    IN const EncoderParameters *encoderParams
    )
{
    if ( newImage == NULL )
    {
        return SetStatus(InvalidParameter);
    }

    return SetStatus(DllExports::GdipSaveAddImage(nativeImage,
                                                  newImage->nativeImage,
                                                  encoderParams));
}

inline ImageType 
Image::GetType() const
{
    ImageType type = ImageTypeUnknown;

    SetStatus(DllExports::GdipGetImageType(nativeImage, &type));

    return type;
}

inline Status 
Image::GetPhysicalDimension(
    OUT SizeF* size
    ) 
{
    if (size == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    REAL width, height;
    Status status;

    status = SetStatus(DllExports::GdipGetImageDimension(nativeImage,
                                                         &width, &height));

    size->Width  = width;
    size->Height = height;

    return status;
}

inline Status 
Image::GetBounds(
    OUT RectF *srcRect, 
    OUT Unit *srcUnit
    )
{
    return SetStatus(DllExports::GdipGetImageBounds(nativeImage,
                                                    srcRect, srcUnit));
}

inline UINT 
Image::GetWidth()
{
    UINT width = 0;

    SetStatus(DllExports::GdipGetImageWidth(nativeImage, &width));

    return width;
}

inline UINT 
Image::GetHeight()
{
    UINT height = 0;

    SetStatus(DllExports::GdipGetImageHeight(nativeImage, &height));

    return height;
}

inline REAL 
Image::GetHorizontalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageHorizontalResolution(nativeImage, &resolution));

    return resolution;
}

inline REAL 
Image::GetVerticalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageVerticalResolution(nativeImage, &resolution));

    return resolution;
}

inline UINT 
Image::GetFlags()
{
    UINT flags = 0;

    SetStatus(DllExports::GdipGetImageFlags(nativeImage, &flags));

    return flags;
}

inline Status 
Image::GetRawFormat(OUT GUID *format)
{
    return SetStatus(DllExports::GdipGetImageRawFormat(nativeImage, format));
}

inline PixelFormat 
Image::GetPixelFormat()
{
    PixelFormat format;

    SetStatus(DllExports::GdipGetImagePixelFormat(nativeImage, &format));

    return format;
}

inline INT 
Image::GetPaletteSize()
{
    INT size = 0;
    
    SetStatus(DllExports::GdipGetImagePaletteSize(nativeImage, &size));
    
    return size;
}

inline Status 
Image::GetPalette(
    OUT ColorPalette *palette,
    IN INT size
)
{
    return SetStatus(DllExports::GdipGetImagePalette(nativeImage, palette, size));
}

inline Status 
Image::SetPalette(
    IN const ColorPalette *palette
    )
{
    return SetStatus(DllExports::GdipSetImagePalette(nativeImage, palette));
}

inline Image* 
Image::GetThumbnailImage(
    IN UINT thumbWidth,
    IN UINT thumbHeight,
    IN GetThumbnailImageAbort callback,
    IN VOID* callbackData
    )
{
    GpImage *thumbimage = NULL;

    SetStatus(DllExports::GdipGetImageThumbnail(nativeImage,
                                                thumbWidth, thumbHeight,
                                                &thumbimage,
                                                callback, callbackData));

    Image *newImage = new Image(thumbimage, lastResult);

    if (newImage == NULL) 
    {
        DllExports::GdipDisposeImage(thumbimage);
    }

    return newImage;
}

inline UINT 
Image::GetFrameDimensionsCount()
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameDimensionsCount(nativeImage,
                                                                  &count));

    return count;
}

inline Status 
Image::GetFrameDimensionsList(
    OUT GUID* dimensionIDs, 
    IN UINT count
    )
{
    return SetStatus(DllExports::GdipImageGetFrameDimensionsList(nativeImage,
                                                                 dimensionIDs,
                                                                 count));
}

inline UINT 
Image::GetFrameCount(
    IN const GUID* dimensionID
    )
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameCount(nativeImage,
                                                        dimensionID,
                                                        &count));
    return count;
}

inline Status 
Image::SelectActiveFrame(
    IN const GUID *dimensionID, 
    IN UINT frameIndex
    )
{
    return SetStatus(DllExports::GdipImageSelectActiveFrame(nativeImage,
                                                            dimensionID,
                                                            frameIndex));
}

inline Status
Image::RotateFlip(
    IN RotateFlipType rotateFlipType
    )
{
    return SetStatus(DllExports::GdipImageRotateFlip(nativeImage,
                                                     rotateFlipType));
}

inline UINT 
Image::GetPropertyCount()
{
    UINT numProperty = 0;

    SetStatus(DllExports::GdipGetPropertyCount(nativeImage,
                                               &numProperty));

    return numProperty;
}

inline Status 
Image::GetPropertyIdList(
    IN UINT numOfProperty, 
    OUT PROPID* list
    )
{
    return SetStatus(DllExports::GdipGetPropertyIdList(nativeImage,
                                                       numOfProperty, list));
}
    
inline UINT 
Image::GetPropertyItemSize(
    IN PROPID propId
    )
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetPropertyItemSize(nativeImage,
                                                  propId,
                                                  &size));

    return size;
}

inline Status 
Image::GetPropertyItem(
    IN PROPID propId, 
    IN UINT propSize,
    OUT PropertyItem* buffer
    )
{
    return SetStatus(DllExports::GdipGetPropertyItem(nativeImage,
                                                     propId, propSize, buffer));
}

inline Status 
Image::GetPropertySize(
    OUT UINT* totalBufferSize, 
    OUT UINT* numProperties
    )
{
    return SetStatus(DllExports::GdipGetPropertySize(nativeImage,
                                                     totalBufferSize,
                                                     numProperties));
}

inline Status 
Image::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    OUT PropertyItem* allItems
    )
{
    if (allItems == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    return SetStatus(DllExports::GdipGetAllPropertyItems(nativeImage,
                                                         totalBufferSize,
                                                         numProperties,
                                                         allItems));
}

inline Status 
Image::RemovePropertyItem(
    IN PROPID propId
    )
{
    return SetStatus(DllExports::GdipRemovePropertyItem(nativeImage, propId));
}

inline Status 
Image::SetPropertyItem(
    IN const PropertyItem* item
    )
{
    return SetStatus(DllExports::GdipSetPropertyItem(nativeImage, item));
}

inline Status
Image::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline 
Image::Image(GpImage *nativeImage, Status status)
{
    SetNativeImage(nativeImage);
    lastResult = status;
}

inline VOID 
Image::SetNativeImage(GpImage *nativeImage)
{
    this->nativeImage = nativeImage;
}

inline 
Bitmap::Bitmap(
    IN const WCHAR *filename, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement) 
    {
        lastResult = DllExports::GdipCreateBitmapFromFileICM(filename, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromFile(filename, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IStream *stream, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipCreateBitmapFromStreamICM(stream, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromStream(stream, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN INT stride,
    IN PixelFormat format,
    IN BYTE *scan0
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       stride,
                                                       format,
                                                       scan0,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       0,
                                                       format,
                                                       NULL,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width, 
    IN INT height, 
    IN Graphics* target)
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGraphics(width,
                                                          height,
                                                          target->nativeGraphics,
                                                          &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromDirectDrawSurface(surface,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGdiDib(gdiBitmapInfo,
                                                        gdiBitmapData,
                                                        &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHBITMAP(hbm, hpal, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HICON hicon
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHICON(hicon, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromResource(hInstance,
                                                          bitmapName,
                                                          &bitmap);

    SetNativeImage(bitmap);
}


inline Bitmap* 
Bitmap::FromFile(
    IN const WCHAR *filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromStream(
    IN IStream *stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        stream, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromDirectDrawSurface7(
    IN IDirectDrawSurface7* surface
    )
{
    return new Bitmap(surface);
}

inline Bitmap* 
Bitmap::FromBITMAPINFO(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData)
{
    return new Bitmap(gdiBitmapInfo, gdiBitmapData);
}

inline Bitmap* 
Bitmap::FromHBITMAP(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    return new Bitmap(hbm, hpal);
}

inline Bitmap* 
Bitmap::FromHICON(
    IN HICON hicon
    )
{
    return new Bitmap(hicon);
}

inline Bitmap* 
Bitmap::FromResource(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName)
{
    return new Bitmap(hInstance, bitmapName);
}

inline Status 
Bitmap::GetHBITMAP(
    IN const Color& colorBackground,
    OUT HBITMAP* hbmReturn
    )
{
    return SetStatus(DllExports::GdipCreateHBITMAPFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hbmReturn,
                                        colorBackground.GetValue()));
}

inline Status 
Bitmap::GetHICON(
    OUT HICON* hiconReturn
    )
{
    return SetStatus(DllExports::GdipCreateHICONFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hiconReturn));
}

inline Bitmap* 
Bitmap::Clone(
    IN const Rect& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap* 
Bitmap::Clone(
    IN INT x,
    IN INT y,
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   lastResult = DllExports::GdipCloneBitmapAreaI(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap);

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap* 
Bitmap::Clone(
    IN const RectF& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap*
Bitmap::Clone(
    IN REAL x,
    IN REAL y,
    IN REAL width,
    IN REAL height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   SetStatus(DllExports::GdipCloneBitmapArea(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap));

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap::Bitmap(GpBitmap *nativeBitmap)
{
    lastResult = Ok;

    SetNativeImage(nativeBitmap);
}

inline Status
Bitmap::LockBits(
    IN const Rect* rect,
    IN UINT flags,
    IN PixelFormat format,
    OUT BitmapData* lockedBitmapData
)
{
    return SetStatus(DllExports::GdipBitmapLockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    rect,
                                    flags,
                                    format,
                                    lockedBitmapData));
}

inline Status 
Bitmap::UnlockBits(
    IN BitmapData* lockedBitmapData
    )
{
    return SetStatus(DllExports::GdipBitmapUnlockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    lockedBitmapData));
}

inline Status 
Bitmap::GetPixel(
    IN INT x, 
    IN INT y, 
    OUT Color *color) 
{
    ARGB argb;

    Status status = SetStatus(DllExports::GdipBitmapGetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,        
        &argb));

    if (status == Ok) 
    {
        color->SetValue(argb);
    }

    return  status;
}

inline Status 
Bitmap::SetPixel(
    IN INT x, 
    IN INT y, 
    IN const Color& color) 
{
    return SetStatus(DllExports::GdipBitmapSetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,
        color.GetValue()));
}

inline Status 
Bitmap::SetResolution(
    IN REAL xdpi, 
    IN REAL ydpi)
{
    return SetStatus(DllExports::GdipBitmapSetResolution(
        static_cast<GpBitmap *>(nativeImage),
        xdpi, ydpi));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusbrush.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBrush.h
*
* Abstract:
*
*   GDI+ Brush class
*
\**************************************************************************/

#ifndef _GDIPLUSBRUSH_H
#define _GDIPLUSBRUSH_H

class GraphicsPath;

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class Brush : public GdiplusBase
{
public:
    friend class Pen;
    friend class Graphics;

    virtual ~Brush()
    {
        DllExports::GdipDeleteBrush(nativeBrush);
    }

    virtual Brush* Clone() const
    {
        GpBrush *brush = NULL;

        SetStatus(DllExports::GdipCloneBrush(nativeBrush, &brush));

        Brush *newBrush = new Brush(brush, lastResult);
        
        if (newBrush == NULL) 
        {
            DllExports::GdipDeleteBrush(brush);
        }

        return newBrush;
    }

    BrushType GetType() const
    {
        BrushType type = static_cast<BrushType>(-1);

        SetStatus(DllExports::GdipGetBrushType(nativeBrush, &type));

        return type;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:

    Brush()
    {
        SetStatus(NotImplemented);
    }

private:
    Brush(const Brush& brush);
    Brush& operator=(const Brush& brush);
protected:

    Brush(GpBrush* nativeBrush, Status status)
    {
        lastResult = status;
        SetNativeBrush(nativeBrush);
    }

    VOID SetNativeBrush(GpBrush* nativeBrush)
    {
        this->nativeBrush = nativeBrush;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpBrush* nativeBrush;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Solid Fill Brush Object
//--------------------------------------------------------------------------

class SolidBrush : public Brush
{
public:
    friend class Pen;

    SolidBrush(IN const Color& color)
    {
        GpSolidFill *brush = NULL;

        lastResult = DllExports::GdipCreateSolidFill(color.GetValue(), &brush);

        SetNativeBrush(brush);
    }

    Status GetColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetSolidFillColor((GpSolidFill*)nativeBrush,
                                                    &argb));

        *color = Color(argb);

        return lastResult;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetSolidFillColor((GpSolidFill*)nativeBrush, 
                                                           color.GetValue()));
    }

private:
    SolidBrush(const SolidBrush &);
    SolidBrush& operator=(const SolidBrush &);

protected:

    SolidBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Texture Brush Fill Object
//--------------------------------------------------------------------------

class TextureBrush : public Brush
{
public:
    friend class Pen;

    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode = WrapModeTile)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture(
                                                  image->nativeImage,
                                                  wrapMode, &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode,
                 IN const RectF &dstRect)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstRect.X, 
                                                   dstRect.Y, 
                                                   dstRect.Width, 
                                                   dstRect.Height,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image *image, 
                 IN const RectF &dstRect,
                 IN const ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image *image, 
                 IN const Rect &dstRect,
                 IN const ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIAI(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }

    TextureBrush(
        IN Image* image,
        IN WrapMode wrapMode,
        
        const IN Rect &dstRect
    )
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstRect.X, 
                                                    dstRect.Y, 
                                                    dstRect.Width, 
                                                    dstRect.Height,
                                                    &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN REAL dstX, 
                 IN REAL dstY, 
                 IN REAL dstWidth, 
                 IN REAL dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstX, 
                                                   dstY, 
                                                   dstWidth, 
                                                   dstHeight,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN INT dstX, 
                 IN INT dstY, 
                 IN INT dstWidth, 
                 IN INT dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstX, 
                                                    dstY, 
                                                    dstWidth, 
                                                    dstHeight,
                                                    &texture);

        SetNativeBrush(texture);
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetTextureTransform((GpTexture*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyTextureTransform((GpTexture*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateTextureTransform((GpTexture*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleTextureTransform((GpTexture*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateTextureTransform((GpTexture*)nativeBrush,
                                                              angle, order));
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTextureWrapMode((GpTexture*)nativeBrush, 
                                                            wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTextureWrapMode((GpTexture*)nativeBrush, 
                                                     &wrapMode));
        return wrapMode;
    }

    Image *GetImage() const
    {
        GpImage *image;

        SetStatus(DllExports::GdipGetTextureImage((GpTexture *)nativeBrush,
                                                  &image));

        Image *retimage = new Image(image, lastResult);

        if (retimage == NULL) 
        {
            DllExports::GdipDisposeImage(image);
        }

        return retimage;
    }

private:
    TextureBrush(const TextureBrush &);
    TextureBrush& operator=(const TextureBrush &);

protected:

    TextureBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Linear Gradient Brush Object
//--------------------------------------------------------------------------

class LinearGradientBrush : public Brush
{
public:
    friend class Pen;

    LinearGradientBrush(IN const PointF& point1,
                        IN const PointF& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrush(&point1,
                                                     &point2,
                                                     color1.GetValue(),
                                                     color2.GetValue(),
                                                     WrapModeTile,
                                                     &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Point& point1,
                        IN const Point& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushI(&point1,
                                                      &point2,
                                                      color1.GetValue(),
                                                      color2.GetValue(),
                                                      WrapModeTile,
                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRect(&rect,
                                                             color1.GetValue(),
                                                             color2.GetValue(),
                                                             mode,
                                                             WrapModeTile,
                                                             &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectI(&rect,
                                                              color1.GetValue(),
                                                              color2.GetValue(),
                                                              mode,
                                                              WrapModeTile,
                                                              &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngle(&rect,
                                                                      color1.GetValue(),
                                                                      color2.GetValue(),
                                                                      angle,
                                                                      isAngleScalable,
                                                                      WrapModeTile,
                                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngleI(&rect,
                                                                       color1.GetValue(),
                                                                       color2.GetValue(),
                                                                       angle,
                                                                       isAngleScalable,
                                                                       WrapModeTile,
                                                                       &brush);

        SetNativeBrush(brush);
    }

    Status SetLinearColors(IN const Color& color1, 
                           IN const Color& color2)
    {
        return SetStatus(DllExports::GdipSetLineColors((GpLineGradient*)nativeBrush,
                                                       color1.GetValue(),
                                                       color2.GetValue()));
    }

    Status GetLinearColors(OUT Color* colors) const
    {
        ARGB argb[2];

        if (colors == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        SetStatus(DllExports::GdipGetLineColors((GpLineGradient*) nativeBrush, argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
        }

        return lastResult;
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRect((GpLineGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRectI((GpLineGradient*)nativeBrush, rect));
    }

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    useGammaCorrection));
    }
    
    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLineBlendCount((GpLineGradient*)
                                                    nativeBrush,
                                                    &count));

        return count;
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions,
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetLineBlend((GpLineGradient*)
                                                      nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    Status GetBlend(OUT REAL* blendFactors, 
                    OUT REAL* blendPositions, 
                    IN INT count) const 
    {
        return SetStatus(DllExports::GdipGetLineBlend((GpLineGradient*)nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    INT GetInterpolationColorCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLinePresetBlendCount((GpLineGradient*)
                                                          nativeBrush,
                                                          &count));

        return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);
         
        ARGB *argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetLinePresetBlend(
                                                                        (GpLineGradient*) nativeBrush,
                                                                        argbs,
                                                                        blendPositions,
                                                                        count));
            delete [] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors, 
                                  OUT REAL* blendPositions, 
                                  IN INT count) const 
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);

        ARGB* argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetLinePresetBlend((GpLineGradient*)nativeBrush,
                                                                     argbs,
                                                                     blendPositions,
                                                                     count));
        if (status == Ok) 
        {
            for (INT i = 0; i < count; i++)
            { 
                presetColors[i] = Color(argbs[i]);
            }
        }
        
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0f)
    {
        return SetStatus(DllExports::GdipSetLineSigmaBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0f
    )
    {
        return SetStatus(DllExports::GdipSetLineLinearBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetLineTransform((GpLineGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyLineTransform((GpLineGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateLineTransform((GpLineGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleLineTransform((GpLineGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateLineTransform((GpLineGradient*)nativeBrush,
                                                              angle, order));
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetLineWrapMode((GpLineGradient*)nativeBrush, 
                                                         wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetLineWrapMode((GpLineGradient*)
                                                  nativeBrush, 
                                                  &wrapMode));

        return wrapMode;
    }

private:
    LinearGradientBrush(const LinearGradientBrush &);
    LinearGradientBrush& operator=(const LinearGradientBrush &);

protected:

    LinearGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// PathGradientBrush object is defined
// in gdipluspath.h.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Hatch Brush Object
//--------------------------------------------------------------------------

class HatchBrush : public Brush
{
public:
    friend class Pen;

    HatchBrush(IN HatchStyle hatchStyle, 
               IN const Color& foreColor,
               IN const Color& backColor = Color())
    {
        GpHatch *brush = NULL;

        lastResult = DllExports::GdipCreateHatchBrush(hatchStyle, 
                                                      foreColor.GetValue(), 
                                                      backColor.GetValue(),
                                                      &brush);
        SetNativeBrush(brush);
    }

    HatchStyle GetHatchStyle() const
    {
        HatchStyle hatchStyle;

        SetStatus(DllExports::GdipGetHatchStyle((GpHatch*)nativeBrush, 
                                                &hatchStyle));

        return hatchStyle;
    }
    
    Status GetForegroundColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        Status status = SetStatus(DllExports::GdipGetHatchForegroundColor(
                                                        (GpHatch*)nativeBrush, 
                                                        &argb));

        color->SetValue(argb);

        return status;
    }

    Status GetBackgroundColor(OUT Color *color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        Status status = SetStatus(DllExports::GdipGetHatchBackgroundColor(
                                                        (GpHatch*)nativeBrush,
                                                        &argb));

        color->SetValue(argb);
        
        return status;
    }

private:
    HatchBrush(const HatchBrush &);
    HatchBrush& operator=(const HatchBrush &);

protected:

    HatchBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusfontfamily.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFontFamily.h
*
* Abstract:
*
*   GDI+ Font Family class
*
\**************************************************************************/

#ifndef _GDIPLUS_FONT_FAMILY_H
#define _GDIPLUS_FONT_FAMILY_H

inline 
FontFamily::FontFamily() :
    nativeFamily (NULL),
    lastResult    (Ok)
{
}

inline 
FontFamily::FontFamily(
    IN const WCHAR*          name,
    IN const FontCollection* fontCollection
)
{
    nativeFamily = NULL;
    lastResult = DllExports::GdipCreateFontFamilyFromName(
        name,
        fontCollection ? fontCollection->nativeFontCollection : NULL,
        &nativeFamily
    );
}

inline
FontFamily::FontFamily(
    IN GpFontFamily *nativeOrig,
    IN Status status
)
{
    lastResult    = status;
    nativeFamily = nativeOrig;
}

inline const FontFamily *
FontFamily::GenericSansSerif() 
{
    if (GenericSansSerifFontFamily != NULL)
    {
        return GenericSansSerifFontFamily;
    }

    GenericSansSerifFontFamily =
        (FontFamily*) GenericSansSerifFontFamilyBuffer;

    GenericSansSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySansSerif(
            &(GenericSansSerifFontFamily->nativeFamily)
        );

    return GenericSansSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericSerif() 
{
    if (GenericSerifFontFamily != NULL)
    {
        return GenericSerifFontFamily;
    }

    GenericSerifFontFamily =
        (FontFamily*) GenericSerifFontFamilyBuffer;

    GenericSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySerif(
            &(GenericSerifFontFamily->nativeFamily)
        );

    return GenericSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericMonospace()
{
    if (GenericMonospaceFontFamily != NULL)
    {
        return GenericMonospaceFontFamily;
    }

    GenericMonospaceFontFamily =
        (FontFamily*) GenericMonospaceFontFamilyBuffer;

    GenericMonospaceFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilyMonospace(
            &(GenericMonospaceFontFamily->nativeFamily)
        );

    return GenericMonospaceFontFamily;
}

inline FontFamily::~FontFamily()
{
    DllExports::GdipDeleteFontFamily (nativeFamily);
}

inline FontFamily *
FontFamily::Clone() const
{
    GpFontFamily * clonedFamily = NULL;

    SetStatus(DllExports::GdipCloneFontFamily (nativeFamily, &clonedFamily));

    return new FontFamily(clonedFamily, lastResult);
}

inline Status 
FontFamily::GetFamilyName(
    IN WCHAR name[LF_FACESIZE],
    IN LANGID language
) const
{
    return SetStatus(DllExports::GdipGetFamilyName(nativeFamily, 
                                                   name, 
                                                   language));
}

inline BOOL 
FontFamily::IsStyleAvailable(IN INT style) const
{
    BOOL    StyleAvailable;
    Status  status;

    status = SetStatus(DllExports::GdipIsStyleAvailable(nativeFamily, style, &StyleAvailable));

    if (status != Ok)
        StyleAvailable = FALSE;

    return StyleAvailable;
}


inline UINT16 
FontFamily::GetEmHeight(IN INT style) const
{
    UINT16  EmHeight;

    SetStatus(DllExports::GdipGetEmHeight(nativeFamily, style, &EmHeight));

    return EmHeight;
}

inline UINT16 
FontFamily::GetCellAscent(IN INT style) const
{
    UINT16  CellAscent;

    SetStatus(DllExports::GdipGetCellAscent(nativeFamily, style, &CellAscent));

    return CellAscent;
}

inline UINT16 
FontFamily::GetCellDescent(IN INT style) const
{
    UINT16  CellDescent;

    SetStatus(DllExports::GdipGetCellDescent(nativeFamily, style, &CellDescent));

    return CellDescent;
}


inline UINT16 
FontFamily::GetLineSpacing(IN INT style) const
{
    UINT16  LineSpacing;

    SetStatus(DllExports::GdipGetLineSpacing(nativeFamily, style, &LineSpacing));

    return LineSpacing;

}

inline Status 
FontFamily::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline Status
FontFamily::SetStatus(Status status) const 
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluscolormatrix.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusColorMatrix.h
*
* Abstract:
*
*  GDI+ Color Matrix object, used with Graphics.DrawImage
*
\**************************************************************************/

#ifndef _GDIPLUSCOLORMATRIX_H
#define _GDIPLUSCOLORMATRIX_H

//----------------------------------------------------------------------------
// Color matrix
//----------------------------------------------------------------------------

struct ColorMatrix
{
    REAL m[5][5];
};

//----------------------------------------------------------------------------
// Color Matrix flags
//----------------------------------------------------------------------------

enum ColorMatrixFlags
{
    ColorMatrixFlagsDefault   = 0,
    ColorMatrixFlagsSkipGrays = 1,
    ColorMatrixFlagsAltGray   = 2
};

//----------------------------------------------------------------------------
// Color Adjust Type
//----------------------------------------------------------------------------

enum ColorAdjustType
{
    ColorAdjustTypeDefault,
    ColorAdjustTypeBitmap,
    ColorAdjustTypeBrush,
    ColorAdjustTypePen,
    ColorAdjustTypeText,
    ColorAdjustTypeCount,
    ColorAdjustTypeAny      // Reserved
};

//----------------------------------------------------------------------------
// Color Map
//----------------------------------------------------------------------------

struct ColorMap
{
    Color oldColor;
    Color newColor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluscolor.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusColor.h
*
* Abstract:
*
*   GDI+ Color Object
*
\**************************************************************************/

#ifndef _GDIPLUSCOLOR_H
#define _GDIPLUSCOLOR_H

//----------------------------------------------------------------------------
// Color mode
//----------------------------------------------------------------------------

enum ColorMode
{
    ColorModeARGB32 = 0,
    ColorModeARGB64 = 1
};

//----------------------------------------------------------------------------
// Color Channel flags
//----------------------------------------------------------------------------

enum ColorChannelFlags
{
    ColorChannelFlagsC = 0,
    ColorChannelFlagsM,
    ColorChannelFlagsY,
    ColorChannelFlagsK,
    ColorChannelFlagsLast
};

//----------------------------------------------------------------------------
// Color
//----------------------------------------------------------------------------

class Color
{
public:

    Color()
    {
        Argb = (ARGB)Color::Black;
    }

    // Construct an opaque Color object with
    // the specified Red, Green, Blue values.
    //
    // Color values are not premultiplied.

    Color(IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(255, r, g, b);
    }

    Color(IN BYTE a,
          IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(a, r, g, b);
    }

    Color(IN ARGB argb)
    {
        Argb = argb;
    }

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetA() const
    {
        return GetAlpha();
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetR() const
    {
        return GetRed();
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetG() const
    {
        return GetGreen();
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    BYTE GetB() const
    {
        return GetBlue();
    }

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    VOID SetFromCOLORREF(IN COLORREF rgb)
    {
        Argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

public:

    // Common color constants
    
    enum
    {
        AliceBlue            = 0xFFF0F8FF,
        AntiqueWhite         = 0xFFFAEBD7,
        Aqua                 = 0xFF00FFFF,
        Aquamarine           = 0xFF7FFFD4,
        Azure                = 0xFFF0FFFF,
        Beige                = 0xFFF5F5DC,
        Bisque               = 0xFFFFE4C4,
        Black                = 0xFF000000,
        BlanchedAlmond       = 0xFFFFEBCD,
        Blue                 = 0xFF0000FF,
        BlueViolet           = 0xFF8A2BE2,
        Brown                = 0xFFA52A2A,
        BurlyWood            = 0xFFDEB887,
        CadetBlue            = 0xFF5F9EA0,
        Chartreuse           = 0xFF7FFF00,
        Chocolate            = 0xFFD2691E,
        Coral                = 0xFFFF7F50,
        CornflowerBlue       = 0xFF6495ED,
        Cornsilk             = 0xFFFFF8DC,
        Crimson              = 0xFFDC143C,
        Cyan                 = 0xFF00FFFF,
        DarkBlue             = 0xFF00008B,
        DarkCyan             = 0xFF008B8B,
        DarkGoldenrod        = 0xFFB8860B,
        DarkGray             = 0xFFA9A9A9,
        DarkGreen            = 0xFF006400,
        DarkKhaki            = 0xFFBDB76B,
        DarkMagenta          = 0xFF8B008B,
        DarkOliveGreen       = 0xFF556B2F,
        DarkOrange           = 0xFFFF8C00,
        DarkOrchid           = 0xFF9932CC,
        DarkRed              = 0xFF8B0000,
        DarkSalmon           = 0xFFE9967A,
        DarkSeaGreen         = 0xFF8FBC8B,
        DarkSlateBlue        = 0xFF483D8B,
        DarkSlateGray        = 0xFF2F4F4F,
        DarkTurquoise        = 0xFF00CED1,
        DarkViolet           = 0xFF9400D3,
        DeepPink             = 0xFFFF1493,
        DeepSkyBlue          = 0xFF00BFFF,
        DimGray              = 0xFF696969,
        DodgerBlue           = 0xFF1E90FF,
        Firebrick            = 0xFFB22222,
        FloralWhite          = 0xFFFFFAF0,
        ForestGreen          = 0xFF228B22,
        Fuchsia              = 0xFFFF00FF,
        Gainsboro            = 0xFFDCDCDC,
        GhostWhite           = 0xFFF8F8FF,
        Gold                 = 0xFFFFD700,
        Goldenrod            = 0xFFDAA520,
        Gray                 = 0xFF808080,
        Green                = 0xFF008000,
        GreenYellow          = 0xFFADFF2F,
        Honeydew             = 0xFFF0FFF0,
        HotPink              = 0xFFFF69B4,
        IndianRed            = 0xFFCD5C5C,
        Indigo               = 0xFF4B0082,
        Ivory                = 0xFFFFFFF0,
        Khaki                = 0xFFF0E68C,
        Lavender             = 0xFFE6E6FA,
        LavenderBlush        = 0xFFFFF0F5,
        LawnGreen            = 0xFF7CFC00,
        LemonChiffon         = 0xFFFFFACD,
        LightBlue            = 0xFFADD8E6,
        LightCoral           = 0xFFF08080,
        LightCyan            = 0xFFE0FFFF,
        LightGoldenrodYellow = 0xFFFAFAD2,
        LightGray            = 0xFFD3D3D3,
        LightGreen           = 0xFF90EE90,
        LightPink            = 0xFFFFB6C1,
        LightSalmon          = 0xFFFFA07A,
        LightSeaGreen        = 0xFF20B2AA,
        LightSkyBlue         = 0xFF87CEFA,
        LightSlateGray       = 0xFF778899,
        LightSteelBlue       = 0xFFB0C4DE,
        LightYellow          = 0xFFFFFFE0,
        Lime                 = 0xFF00FF00,
        LimeGreen            = 0xFF32CD32,
        Linen                = 0xFFFAF0E6,
        Magenta              = 0xFFFF00FF,
        Maroon               = 0xFF800000,
        MediumAquamarine     = 0xFF66CDAA,
        MediumBlue           = 0xFF0000CD,
        MediumOrchid         = 0xFFBA55D3,
        MediumPurple         = 0xFF9370DB,
        MediumSeaGreen       = 0xFF3CB371,
        MediumSlateBlue      = 0xFF7B68EE,
        MediumSpringGreen    = 0xFF00FA9A,
        MediumTurquoise      = 0xFF48D1CC,
        MediumVioletRed      = 0xFFC71585,
        MidnightBlue         = 0xFF191970,
        MintCream            = 0xFFF5FFFA,
        MistyRose            = 0xFFFFE4E1,
        Moccasin             = 0xFFFFE4B5,
        NavajoWhite          = 0xFFFFDEAD,
        Navy                 = 0xFF000080,
        OldLace              = 0xFFFDF5E6,
        Olive                = 0xFF808000,
        OliveDrab            = 0xFF6B8E23,
        Orange               = 0xFFFFA500,
        OrangeRed            = 0xFFFF4500,
        Orchid               = 0xFFDA70D6,
        PaleGoldenrod        = 0xFFEEE8AA,
        PaleGreen            = 0xFF98FB98,
        PaleTurquoise        = 0xFFAFEEEE,
        PaleVioletRed        = 0xFFDB7093,
        PapayaWhip           = 0xFFFFEFD5,
        PeachPuff            = 0xFFFFDAB9,
        Peru                 = 0xFFCD853F,
        Pink                 = 0xFFFFC0CB,
        Plum                 = 0xFFDDA0DD,
        PowderBlue           = 0xFFB0E0E6,
        Purple               = 0xFF800080,
        Red                  = 0xFFFF0000,
        RosyBrown            = 0xFFBC8F8F,
        RoyalBlue            = 0xFF4169E1,
        SaddleBrown          = 0xFF8B4513,
        Salmon               = 0xFFFA8072,
        SandyBrown           = 0xFFF4A460,
        SeaGreen             = 0xFF2E8B57,
        SeaShell             = 0xFFFFF5EE,
        Sienna               = 0xFFA0522D,
        Silver               = 0xFFC0C0C0,
        SkyBlue              = 0xFF87CEEB,
        SlateBlue            = 0xFF6A5ACD,
        SlateGray            = 0xFF708090,
        Snow                 = 0xFFFFFAFA,
        SpringGreen          = 0xFF00FF7F,
        SteelBlue            = 0xFF4682B4,
        Tan                  = 0xFFD2B48C,
        Teal                 = 0xFF008080,
        Thistle              = 0xFFD8BFD8,
        Tomato               = 0xFFFF6347,
        Transparent          = 0x00FFFFFF,
        Turquoise            = 0xFF40E0D0,
        Violet               = 0xFFEE82EE,
        Wheat                = 0xFFF5DEB3,
        White                = 0xFFFFFFFF,
        WhiteSmoke           = 0xFFF5F5F5,
        Yellow               = 0xFFFFFF00,
        YellowGreen          = 0xFF9ACD32
    };

    // Shift count and bit mask for A, R, G, B components
    
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

protected:

    ARGB Argb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusenums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.h
*
* Abstract:
*
*   GDI+ Enumeration Types
*
\**************************************************************************/

#ifndef _GDIPLUSENUMS_H
#define _GDIPLUSENUMS_H

//--------------------------------------------------------------------------
// Default bezier flattening tolerance in device pixels.
//--------------------------------------------------------------------------

const float FlatnessDefault = 1.0f/4.0f;

//--------------------------------------------------------------------------
// Graphics and Container State cookies
//--------------------------------------------------------------------------

typedef UINT     GraphicsState;
typedef UINT     GraphicsContainer;

//--------------------------------------------------------------------------
// Fill mode constants
//--------------------------------------------------------------------------

enum FillMode
{
    FillModeAlternate,        // 0
    FillModeWinding           // 1
};

//--------------------------------------------------------------------------
// Quality mode constants
//--------------------------------------------------------------------------

enum QualityMode
{
    QualityModeInvalid   = -1,
    QualityModeDefault   = 0,
    QualityModeLow       = 1, // Best performance
    QualityModeHigh      = 2  // Best rendering quality
};

//--------------------------------------------------------------------------
// Alpha Compositing mode constants
//--------------------------------------------------------------------------

enum CompositingMode
{
    CompositingModeSourceOver,    // 0
    CompositingModeSourceCopy     // 1
};

//--------------------------------------------------------------------------
// Alpha Compositing quality constants
//--------------------------------------------------------------------------

enum CompositingQuality
{
    CompositingQualityInvalid          = QualityModeInvalid,
    CompositingQualityDefault          = QualityModeDefault,
    CompositingQualityHighSpeed        = QualityModeLow,
    CompositingQualityHighQuality      = QualityModeHigh,
    CompositingQualityGammaCorrected,
    CompositingQualityAssumeLinear
};

//--------------------------------------------------------------------------
// Unit constants
//--------------------------------------------------------------------------

enum Unit
{
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
};

//--------------------------------------------------------------------------
// MetafileFrameUnit
//
// The frameRect for creating a metafile can be specified in any of these
// units.  There is an extra frame unit value (MetafileFrameUnitGdi) so
// that units can be supplied in the same units that GDI expects for
// frame rects -- these units are in .01 (1/100ths) millimeter units
// as defined by GDI.
//--------------------------------------------------------------------------

enum MetafileFrameUnit
{
    MetafileFrameUnitPixel      = UnitPixel,
    MetafileFrameUnitPoint      = UnitPoint,
    MetafileFrameUnitInch       = UnitInch,
    MetafileFrameUnitDocument   = UnitDocument,
    MetafileFrameUnitMillimeter = UnitMillimeter,
    MetafileFrameUnitGdi                        // GDI compatible .01 MM units
};

//--------------------------------------------------------------------------
// Coordinate space identifiers
//--------------------------------------------------------------------------

enum CoordinateSpace
{
    CoordinateSpaceWorld,     // 0
    CoordinateSpacePage,      // 1
    CoordinateSpaceDevice     // 2
};

//--------------------------------------------------------------------------
// Various wrap modes for brushes
//--------------------------------------------------------------------------

enum WrapMode
{
    WrapModeTile,        // 0
    WrapModeTileFlipX,   // 1
    WrapModeTileFlipY,   // 2
    WrapModeTileFlipXY,  // 3
    WrapModeClamp        // 4
};

//--------------------------------------------------------------------------
// Various hatch styles
//--------------------------------------------------------------------------

enum HatchStyle
{
    HatchStyleHorizontal,                   // 0
    HatchStyleVertical,                     // 1
    HatchStyleForwardDiagonal,              // 2
    HatchStyleBackwardDiagonal,             // 3
    HatchStyleCross,                        // 4
    HatchStyleDiagonalCross,                // 5
    HatchStyle05Percent,                    // 6
    HatchStyle10Percent,                    // 7
    HatchStyle20Percent,                    // 8
    HatchStyle25Percent,                    // 9
    HatchStyle30Percent,                    // 10
    HatchStyle40Percent,                    // 11
    HatchStyle50Percent,                    // 12
    HatchStyle60Percent,                    // 13
    HatchStyle70Percent,                    // 14
    HatchStyle75Percent,                    // 15
    HatchStyle80Percent,                    // 16
    HatchStyle90Percent,                    // 17
    HatchStyleLightDownwardDiagonal,        // 18
    HatchStyleLightUpwardDiagonal,          // 19
    HatchStyleDarkDownwardDiagonal,         // 20
    HatchStyleDarkUpwardDiagonal,           // 21
    HatchStyleWideDownwardDiagonal,         // 22
    HatchStyleWideUpwardDiagonal,           // 23
    HatchStyleLightVertical,                // 24
    HatchStyleLightHorizontal,              // 25
    HatchStyleNarrowVertical,               // 26
    HatchStyleNarrowHorizontal,             // 27
    HatchStyleDarkVertical,                 // 28
    HatchStyleDarkHorizontal,               // 29
    HatchStyleDashedDownwardDiagonal,       // 30
    HatchStyleDashedUpwardDiagonal,         // 31
    HatchStyleDashedHorizontal,             // 32
    HatchStyleDashedVertical,               // 33
    HatchStyleSmallConfetti,                // 34
    HatchStyleLargeConfetti,                // 35
    HatchStyleZigZag,                       // 36
    HatchStyleWave,                         // 37
    HatchStyleDiagonalBrick,                // 38
    HatchStyleHorizontalBrick,              // 39
    HatchStyleWeave,                        // 40
    HatchStylePlaid,                        // 41
    HatchStyleDivot,                        // 42
    HatchStyleDottedGrid,                   // 43
    HatchStyleDottedDiamond,                // 44
    HatchStyleShingle,                      // 45
    HatchStyleTrellis,                      // 46
    HatchStyleSphere,                       // 47
    HatchStyleSmallGrid,                    // 48
    HatchStyleSmallCheckerBoard,            // 49
    HatchStyleLargeCheckerBoard,            // 50
    HatchStyleOutlinedDiamond,              // 51
    HatchStyleSolidDiamond,                 // 52

    HatchStyleTotal,   
    HatchStyleLargeGrid = HatchStyleCross,  // 4

    HatchStyleMin       = HatchStyleHorizontal,
    HatchStyleMax       = HatchStyleTotal - 1,
};

//--------------------------------------------------------------------------
// Dash style constants
//--------------------------------------------------------------------------

enum DashStyle
{
    DashStyleSolid,          // 0
    DashStyleDash,           // 1
    DashStyleDot,            // 2
    DashStyleDashDot,        // 3
    DashStyleDashDotDot,     // 4
    DashStyleCustom          // 5
};

//--------------------------------------------------------------------------
// Dash cap constants
//--------------------------------------------------------------------------

enum DashCap
{
    DashCapFlat             = 0,
    DashCapRound            = 2,
    DashCapTriangle         = 3
};

//--------------------------------------------------------------------------
// Line cap constants (only the lowest 8 bits are used).
//--------------------------------------------------------------------------

enum LineCap
{
    LineCapFlat             = 0,
    LineCapSquare           = 1,
    LineCapRound            = 2,
    LineCapTriangle         = 3,

    LineCapNoAnchor         = 0x10, // corresponds to flat cap
    LineCapSquareAnchor     = 0x11, // corresponds to square cap
    LineCapRoundAnchor      = 0x12, // corresponds to round cap
    LineCapDiamondAnchor    = 0x13, // corresponds to triangle cap
    LineCapArrowAnchor      = 0x14, // no correspondence

    LineCapCustom           = 0xff, // custom cap

    LineCapAnchorMask       = 0xf0  // mask to check for anchor or not.
};

//--------------------------------------------------------------------------
// Custom Line cap type constants
//--------------------------------------------------------------------------

enum CustomLineCapType
{
    CustomLineCapTypeDefault         = 0,
    CustomLineCapTypeAdjustableArrow = 1
};

//--------------------------------------------------------------------------
// Line join constants
//--------------------------------------------------------------------------

enum LineJoin
{
    LineJoinMiter        = 0,
    LineJoinBevel        = 1,
    LineJoinRound        = 2,
    LineJoinMiterClipped = 3
};

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Bezier (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier3    = 3,         // cubic Bezier
};


//--------------------------------------------------------------------------
// WarpMode constants
//--------------------------------------------------------------------------

enum WarpMode
{
    WarpModePerspective,    // 0
    WarpModeBilinear        // 1
};

//--------------------------------------------------------------------------
// LineGradient Mode
//--------------------------------------------------------------------------

enum LinearGradientMode
{
    LinearGradientModeHorizontal,         // 0
    LinearGradientModeVertical,           // 1
    LinearGradientModeForwardDiagonal,    // 2
    LinearGradientModeBackwardDiagonal    // 3
};

//--------------------------------------------------------------------------
// Region Comine Modes
//--------------------------------------------------------------------------

enum CombineMode
{
    CombineModeReplace,     // 0
    CombineModeIntersect,   // 1
    CombineModeUnion,       // 2
    CombineModeXor,         // 3
    CombineModeExclude,     // 4
    CombineModeComplement   // 5 (Exclude From)
};

//--------------------------------------------------------------------------
 // Image types
//--------------------------------------------------------------------------

enum ImageType
{
    ImageTypeUnknown,   // 0
    ImageTypeBitmap,    // 1
    ImageTypeMetafile   // 2
};

//--------------------------------------------------------------------------
// Interpolation modes
//--------------------------------------------------------------------------

enum InterpolationMode
{
    InterpolationModeInvalid          = QualityModeInvalid,
    InterpolationModeDefault          = QualityModeDefault,
    InterpolationModeLowQuality       = QualityModeLow,
    InterpolationModeHighQuality      = QualityModeHigh,
    InterpolationModeBilinear,
    InterpolationModeBicubic,
    InterpolationModeNearestNeighbor,
    InterpolationModeHighQualityBilinear,
    InterpolationModeHighQualityBicubic
};

//--------------------------------------------------------------------------
// Pen types
//--------------------------------------------------------------------------

enum PenAlignment
{
    PenAlignmentCenter       = 0,
    PenAlignmentInset        = 1
};

//--------------------------------------------------------------------------
// Brush types
//--------------------------------------------------------------------------

enum BrushType
{
   BrushTypeSolidColor       = 0,
   BrushTypeHatchFill        = 1,
   BrushTypeTextureFill      = 2,
   BrushTypePathGradient     = 3,
   BrushTypeLinearGradient   = 4
};

//--------------------------------------------------------------------------
// Pen's Fill types
//--------------------------------------------------------------------------

enum PenType
{
   PenTypeSolidColor       = BrushTypeSolidColor,
   PenTypeHatchFill        = BrushTypeHatchFill,
   PenTypeTextureFill      = BrushTypeTextureFill,
   PenTypePathGradient     = BrushTypePathGradient,
   PenTypeLinearGradient   = BrushTypeLinearGradient,
   PenTypeUnknown          = -1
};

//--------------------------------------------------------------------------
// Matrix Order
//--------------------------------------------------------------------------

enum MatrixOrder
{
    MatrixOrderPrepend    = 0,
    MatrixOrderAppend     = 1
};

//--------------------------------------------------------------------------
// Generic font families
//--------------------------------------------------------------------------

enum GenericFontFamily
{
    GenericFontFamilySerif,
    GenericFontFamilySansSerif,
    GenericFontFamilyMonospace

};

//--------------------------------------------------------------------------
// FontStyle: face types and common styles
//--------------------------------------------------------------------------

enum FontStyle
{
    FontStyleRegular    = 0,
    FontStyleBold       = 1,
    FontStyleItalic     = 2,
    FontStyleBoldItalic = 3,
    FontStyleUnderline  = 4,
    FontStyleStrikeout  = 8
};

//---------------------------------------------------------------------------
// Smoothing Mode
//---------------------------------------------------------------------------

enum SmoothingMode
{
    SmoothingModeInvalid     = QualityModeInvalid,
    SmoothingModeDefault     = QualityModeDefault,
    SmoothingModeHighSpeed   = QualityModeLow,
    SmoothingModeHighQuality = QualityModeHigh,
    SmoothingModeNone,
    SmoothingModeAntiAlias
};

//---------------------------------------------------------------------------
// Pixel Format Mode
//---------------------------------------------------------------------------

enum PixelOffsetMode
{
    PixelOffsetModeInvalid     = QualityModeInvalid,
    PixelOffsetModeDefault     = QualityModeDefault,
    PixelOffsetModeHighSpeed   = QualityModeLow,
    PixelOffsetModeHighQuality = QualityModeHigh,
    PixelOffsetModeNone,    // No pixel offset
    PixelOffsetModeHalf     // Offset by -0.5, -0.5 for fast anti-alias perf
};

//---------------------------------------------------------------------------
// Text Rendering Hint
//---------------------------------------------------------------------------

enum TextRenderingHint
{
    TextRenderingHintSystemDefault = 0,            // Glyph with system default rendering hint
    TextRenderingHintSingleBitPerPixelGridFit,     // Glyph bitmap with hinting
    TextRenderingHintSingleBitPerPixel,            // Glyph bitmap without hinting
    TextRenderingHintAntiAliasGridFit,             // Glyph anti-alias bitmap with hinting
    TextRenderingHintAntiAlias,                    // Glyph anti-alias bitmap without hinting
    TextRenderingHintClearTypeGridFit              // Glyph CT bitmap with hinting
};

//---------------------------------------------------------------------------
// Metafile Types
//---------------------------------------------------------------------------

enum MetafileType
{
    MetafileTypeInvalid,            // Invalid metafile
    MetafileTypeWmf,                // Standard WMF
    MetafileTypeWmfPlaceable,       // Placeable WMF
    MetafileTypeEmf,                // EMF (not EMF+)
    MetafileTypeEmfPlusOnly,        // EMF+ without dual, down-level records
    MetafileTypeEmfPlusDual         // EMF+ with dual, down-level records
};

//---------------------------------------------------------------------------
// Specifies the type of EMF to record
//---------------------------------------------------------------------------

enum EmfType
{
    EmfTypeEmfOnly     = MetafileTypeEmf,          // no EMF+, only EMF
    EmfTypeEmfPlusOnly = MetafileTypeEmfPlusOnly,  // no EMF, only EMF+
    EmfTypeEmfPlusDual = MetafileTypeEmfPlusDual   // both EMF+ and EMF
};

//---------------------------------------------------------------------------
// EMF+ Persistent object types
//---------------------------------------------------------------------------

enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeCustomLineCap,

    ObjectTypeMax = ObjectTypeCustomLineCap,
    ObjectTypeMin = ObjectTypeBrush
};

inline BOOL
ObjectTypeIsValid(
    ObjectType      type
    )
{
    return ((type >= ObjectTypeMin) && (type <= ObjectTypeMax));
}

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.

enum EmfPlusRecordType;

#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
   // Since we have to enumerate GDI records right along with GDI+ records,
   // We list all the GDI records here so that they can be part of the
   // same enumeration type which is used in the enumeration callback.

    WmfRecordTypeSetBkColor              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKCOLOR),
    WmfRecordTypeSetBkMode               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKMODE),
    WmfRecordTypeSetMapMode              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPMODE),
    WmfRecordTypeSetROP2                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETROP2),
    WmfRecordTypeSetRelAbs               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETRELABS),
    WmfRecordTypeSetPolyFillMode         = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPOLYFILLMODE),
    WmfRecordTypeSetStretchBltMode       = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETSTRETCHBLTMODE),
    WmfRecordTypeSetTextCharExtra        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCHAREXTRA),
    WmfRecordTypeSetTextColor            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCOLOR),
    WmfRecordTypeSetTextJustification    = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTJUSTIFICATION),
    WmfRecordTypeSetWindowOrg            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWORG),
    WmfRecordTypeSetWindowExt            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWEXT),
    WmfRecordTypeSetViewportOrg          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTORG),
    WmfRecordTypeSetViewportExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTEXT),
    WmfRecordTypeOffsetWindowOrg         = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETWINDOWORG),
    WmfRecordTypeScaleWindowExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEWINDOWEXT),
    WmfRecordTypeOffsetViewportOrg       = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETVIEWPORTORG),
    WmfRecordTypeScaleViewportExt        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEVIEWPORTEXT),
    WmfRecordTypeLineTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_LINETO),
    WmfRecordTypeMoveTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_MOVETO),
    WmfRecordTypeExcludeClipRect         = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXCLUDECLIPRECT),
    WmfRecordTypeIntersectClipRect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_INTERSECTCLIPRECT),
    WmfRecordTypeArc                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_ARC),
    WmfRecordTypeEllipse                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_ELLIPSE),
    WmfRecordTypeFloodFill               = GDIP_WMF_RECORD_TO_EMFPLUS(META_FLOODFILL),
    WmfRecordTypePie                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_PIE),
    WmfRecordTypeRectangle               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RECTANGLE),
    WmfRecordTypeRoundRect               = GDIP_WMF_RECORD_TO_EMFPLUS(META_ROUNDRECT),
    WmfRecordTypePatBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_PATBLT),
    WmfRecordTypeSaveDC                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_SAVEDC),
    WmfRecordTypeSetPixel                = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPIXEL),
    WmfRecordTypeOffsetClipRgn           = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETCLIPRGN),
    WmfRecordTypeTextOut                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_TEXTOUT),
    WmfRecordTypeBitBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_BITBLT),
    WmfRecordTypeStretchBlt              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHBLT),
    WmfRecordTypePolygon                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYGON),
    WmfRecordTypePolyline                = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYLINE),
    WmfRecordTypeEscape                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_ESCAPE),
    WmfRecordTypeRestoreDC               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESTOREDC),
    WmfRecordTypeFillRegion              = GDIP_WMF_RECORD_TO_EMFPLUS(META_FILLREGION),
    WmfRecordTypeFrameRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_FRAMEREGION),
    WmfRecordTypeInvertRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_INVERTREGION),
    WmfRecordTypePaintRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_PAINTREGION),
    WmfRecordTypeSelectClipRegion        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTCLIPREGION),
    WmfRecordTypeSelectObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTOBJECT),
    WmfRecordTypeSetTextAlign            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTALIGN),
    WmfRecordTypeDrawText                = GDIP_WMF_RECORD_TO_EMFPLUS(0x062F),  // META_DRAWTEXT
    WmfRecordTypeChord                   = GDIP_WMF_RECORD_TO_EMFPLUS(META_CHORD),
    WmfRecordTypeSetMapperFlags          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPPERFLAGS),
    WmfRecordTypeExtTextOut              = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTTEXTOUT),
    WmfRecordTypeSetDIBToDev             = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETDIBTODEV),
    WmfRecordTypeSelectPalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTPALETTE),
    WmfRecordTypeRealizePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_REALIZEPALETTE),
    WmfRecordTypeAnimatePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_ANIMATEPALETTE),
    WmfRecordTypeSetPalEntries           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPALENTRIES),
    WmfRecordTypePolyPolygon             = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYPOLYGON),
    WmfRecordTypeResizePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESIZEPALETTE),
    WmfRecordTypeDIBBitBlt               = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBBITBLT),
    WmfRecordTypeDIBStretchBlt           = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBSTRETCHBLT),
    WmfRecordTypeDIBCreatePatternBrush   = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBCREATEPATTERNBRUSH),
    WmfRecordTypeStretchDIB              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHDIB),
    WmfRecordTypeExtFloodFill            = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTFLOODFILL),
    WmfRecordTypeSetLayout               = GDIP_WMF_RECORD_TO_EMFPLUS(0x0149),  // META_SETLAYOUT
    WmfRecordTypeResetDC                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x014C),  // META_RESETDC
    WmfRecordTypeStartDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x014D),  // META_STARTDOC
    WmfRecordTypeStartPage               = GDIP_WMF_RECORD_TO_EMFPLUS(0x004F),  // META_STARTPAGE
    WmfRecordTypeEndPage                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x0050),  // META_ENDPAGE
    WmfRecordTypeAbortDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x0052),  // META_ABORTDOC
    WmfRecordTypeEndDoc                  = GDIP_WMF_RECORD_TO_EMFPLUS(0x005E),  // META_ENDDOC
    WmfRecordTypeDeleteObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_DELETEOBJECT),
    WmfRecordTypeCreatePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPALETTE),
    WmfRecordTypeCreateBrush             = GDIP_WMF_RECORD_TO_EMFPLUS(0x00F8),  // META_CREATEBRUSH
    WmfRecordTypeCreatePatternBrush      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPATTERNBRUSH),
    WmfRecordTypeCreatePenIndirect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPENINDIRECT),
    WmfRecordTypeCreateFontIndirect      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEFONTINDIRECT),
    WmfRecordTypeCreateBrushIndirect     = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEBRUSHINDIRECT),
    WmfRecordTypeCreateBitmapIndirect    = GDIP_WMF_RECORD_TO_EMFPLUS(0x02FD),  // META_CREATEBITMAPINDIRECT
    WmfRecordTypeCreateBitmap            = GDIP_WMF_RECORD_TO_EMFPLUS(0x06FE),  // META_CREATEBITMAP
    WmfRecordTypeCreateRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEREGION),

    EmfRecordTypeHeader                  = EMR_HEADER,
    EmfRecordTypePolyBezier              = EMR_POLYBEZIER,
    EmfRecordTypePolygon                 = EMR_POLYGON,
    EmfRecordTypePolyline                = EMR_POLYLINE,
    EmfRecordTypePolyBezierTo            = EMR_POLYBEZIERTO,
    EmfRecordTypePolyLineTo              = EMR_POLYLINETO,
    EmfRecordTypePolyPolyline            = EMR_POLYPOLYLINE,
    EmfRecordTypePolyPolygon             = EMR_POLYPOLYGON,
    EmfRecordTypeSetWindowExtEx          = EMR_SETWINDOWEXTEX,
    EmfRecordTypeSetWindowOrgEx          = EMR_SETWINDOWORGEX,
    EmfRecordTypeSetViewportExtEx        = EMR_SETVIEWPORTEXTEX,
    EmfRecordTypeSetViewportOrgEx        = EMR_SETVIEWPORTORGEX,
    EmfRecordTypeSetBrushOrgEx           = EMR_SETBRUSHORGEX,
    EmfRecordTypeEOF                     = EMR_EOF,
    EmfRecordTypeSetPixelV               = EMR_SETPIXELV,
    EmfRecordTypeSetMapperFlags          = EMR_SETMAPPERFLAGS,
    EmfRecordTypeSetMapMode              = EMR_SETMAPMODE,
    EmfRecordTypeSetBkMode               = EMR_SETBKMODE,
    EmfRecordTypeSetPolyFillMode         = EMR_SETPOLYFILLMODE,
    EmfRecordTypeSetROP2                 = EMR_SETROP2,
    EmfRecordTypeSetStretchBltMode       = EMR_SETSTRETCHBLTMODE,
    EmfRecordTypeSetTextAlign            = EMR_SETTEXTALIGN,
    EmfRecordTypeSetColorAdjustment      = EMR_SETCOLORADJUSTMENT,
    EmfRecordTypeSetTextColor            = EMR_SETTEXTCOLOR,
    EmfRecordTypeSetBkColor              = EMR_SETBKCOLOR,
    EmfRecordTypeOffsetClipRgn           = EMR_OFFSETCLIPRGN,
    EmfRecordTypeMoveToEx                = EMR_MOVETOEX,
    EmfRecordTypeSetMetaRgn              = EMR_SETMETARGN,
    EmfRecordTypeExcludeClipRect         = EMR_EXCLUDECLIPRECT,
    EmfRecordTypeIntersectClipRect       = EMR_INTERSECTCLIPRECT,
    EmfRecordTypeScaleViewportExtEx      = EMR_SCALEVIEWPORTEXTEX,
    EmfRecordTypeScaleWindowExtEx        = EMR_SCALEWINDOWEXTEX,
    EmfRecordTypeSaveDC                  = EMR_SAVEDC,
    EmfRecordTypeRestoreDC               = EMR_RESTOREDC,
    EmfRecordTypeSetWorldTransform       = EMR_SETWORLDTRANSFORM,
    EmfRecordTypeModifyWorldTransform    = EMR_MODIFYWORLDTRANSFORM,
    EmfRecordTypeSelectObject            = EMR_SELECTOBJECT,
    EmfRecordTypeCreatePen               = EMR_CREATEPEN,
    EmfRecordTypeCreateBrushIndirect     = EMR_CREATEBRUSHINDIRECT,
    EmfRecordTypeDeleteObject            = EMR_DELETEOBJECT,
    EmfRecordTypeAngleArc                = EMR_ANGLEARC,
    EmfRecordTypeEllipse                 = EMR_ELLIPSE,
    EmfRecordTypeRectangle               = EMR_RECTANGLE,
    EmfRecordTypeRoundRect               = EMR_ROUNDRECT,
    EmfRecordTypeArc                     = EMR_ARC,
    EmfRecordTypeChord                   = EMR_CHORD,
    EmfRecordTypePie                     = EMR_PIE,
    EmfRecordTypeSelectPalette           = EMR_SELECTPALETTE,
    EmfRecordTypeCreatePalette           = EMR_CREATEPALETTE,
    EmfRecordTypeSetPaletteEntries       = EMR_SETPALETTEENTRIES,
    EmfRecordTypeResizePalette           = EMR_RESIZEPALETTE,
    EmfRecordTypeRealizePalette          = EMR_REALIZEPALETTE,
    EmfRecordTypeExtFloodFill            = EMR_EXTFLOODFILL,
    EmfRecordTypeLineTo                  = EMR_LINETO,
    EmfRecordTypeArcTo                   = EMR_ARCTO,
    EmfRecordTypePolyDraw                = EMR_POLYDRAW,
    EmfRecordTypeSetArcDirection         = EMR_SETARCDIRECTION,
    EmfRecordTypeSetMiterLimit           = EMR_SETMITERLIMIT,
    EmfRecordTypeBeginPath               = EMR_BEGINPATH,
    EmfRecordTypeEndPath                 = EMR_ENDPATH,
    EmfRecordTypeCloseFigure             = EMR_CLOSEFIGURE,
    EmfRecordTypeFillPath                = EMR_FILLPATH,
    EmfRecordTypeStrokeAndFillPath       = EMR_STROKEANDFILLPATH,
    EmfRecordTypeStrokePath              = EMR_STROKEPATH,
    EmfRecordTypeFlattenPath             = EMR_FLATTENPATH,
    EmfRecordTypeWidenPath               = EMR_WIDENPATH,
    EmfRecordTypeSelectClipPath          = EMR_SELECTCLIPPATH,
    EmfRecordTypeAbortPath               = EMR_ABORTPATH,
    EmfRecordTypeReserved_069            = 69,  // Not Used
    EmfRecordTypeGdiComment              = EMR_GDICOMMENT,
    EmfRecordTypeFillRgn                 = EMR_FILLRGN,
    EmfRecordTypeFrameRgn                = EMR_FRAMERGN,
    EmfRecordTypeInvertRgn               = EMR_INVERTRGN,
    EmfRecordTypePaintRgn                = EMR_PAINTRGN,
    EmfRecordTypeExtSelectClipRgn        = EMR_EXTSELECTCLIPRGN,
    EmfRecordTypeBitBlt                  = EMR_BITBLT,
    EmfRecordTypeStretchBlt              = EMR_STRETCHBLT,
    EmfRecordTypeMaskBlt                 = EMR_MASKBLT,
    EmfRecordTypePlgBlt                  = EMR_PLGBLT,
    EmfRecordTypeSetDIBitsToDevice       = EMR_SETDIBITSTODEVICE,
    EmfRecordTypeStretchDIBits           = EMR_STRETCHDIBITS,
    EmfRecordTypeExtCreateFontIndirect   = EMR_EXTCREATEFONTINDIRECTW,
    EmfRecordTypeExtTextOutA             = EMR_EXTTEXTOUTA,
    EmfRecordTypeExtTextOutW             = EMR_EXTTEXTOUTW,
    EmfRecordTypePolyBezier16            = EMR_POLYBEZIER16,
    EmfRecordTypePolygon16               = EMR_POLYGON16,
    EmfRecordTypePolyline16              = EMR_POLYLINE16,
    EmfRecordTypePolyBezierTo16          = EMR_POLYBEZIERTO16,
    EmfRecordTypePolylineTo16            = EMR_POLYLINETO16,
    EmfRecordTypePolyPolyline16          = EMR_POLYPOLYLINE16,
    EmfRecordTypePolyPolygon16           = EMR_POLYPOLYGON16,
    EmfRecordTypePolyDraw16              = EMR_POLYDRAW16,
    EmfRecordTypeCreateMonoBrush         = EMR_CREATEMONOBRUSH,
    EmfRecordTypeCreateDIBPatternBrushPt = EMR_CREATEDIBPATTERNBRUSHPT,
    EmfRecordTypeExtCreatePen            = EMR_EXTCREATEPEN,
    EmfRecordTypePolyTextOutA            = EMR_POLYTEXTOUTA,
    EmfRecordTypePolyTextOutW            = EMR_POLYTEXTOUTW,
    EmfRecordTypeSetICMMode              = 98,  // EMR_SETICMMODE,
    EmfRecordTypeCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
    EmfRecordTypeSetColorSpace           = 100, // EMR_SETCOLORSPACE,
    EmfRecordTypeDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
    EmfRecordTypeGLSRecord               = 102, // EMR_GLSRECORD,
    EmfRecordTypeGLSBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
    EmfRecordTypePixelFormat             = 104, // EMR_PIXELFORMAT,
    EmfRecordTypeDrawEscape              = 105, // EMR_RESERVED_105,
    EmfRecordTypeExtEscape               = 106, // EMR_RESERVED_106,
    EmfRecordTypeStartDoc                = 107, // EMR_RESERVED_107,
    EmfRecordTypeSmallTextOut            = 108, // EMR_RESERVED_108,
    EmfRecordTypeForceUFIMapping         = 109, // EMR_RESERVED_109,
    EmfRecordTypeNamedEscape             = 110, // EMR_RESERVED_110,
    EmfRecordTypeColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
    EmfRecordTypeSetICMProfileA          = 112, // EMR_SETICMPROFILEA,
    EmfRecordTypeSetICMProfileW          = 113, // EMR_SETICMPROFILEW,
    EmfRecordTypeAlphaBlend              = 114, // EMR_ALPHABLEND,
    EmfRecordTypeSetLayout               = 115, // EMR_SETLAYOUT,
    EmfRecordTypeTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
    EmfRecordTypeReserved_117            = 117, // Not Used
    EmfRecordTypeGradientFill            = 118, // EMR_GRADIENTFILL,
    EmfRecordTypeSetLinkedUFIs           = 119, // EMR_RESERVED_119,
    EmfRecordTypeSetTextJustification    = 120, // EMR_RESERVED_120,
    EmfRecordTypeColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
    EmfRecordTypeCreateColorSpaceW       = 122, // EMR_CREATECOLORSPACEW,
    EmfRecordTypeMax                     = 122,
    EmfRecordTypeMin                     = 1,

    // That is the END of the GDI EMF records.

    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects
    
    EmfPlusRecordTypeObject,

    // Drawing Records
    
    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records
    
    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextContrast,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    EmfPlusRecordTypeDrawDriverString,

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};

//---------------------------------------------------------------------------
// StringFormatFlags
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// String format flags
//
//  DirectionRightToLeft          - For horizontal text, the reading order is
//                                  right to left. This value is called
//                                  the base embedding level by the Unicode
//                                  bidirectional engine.
//                                  For vertical text, columns are read from
//                                  right to left.
//                                  By default, horizontal or vertical text is
//                                  read from left to right.
//
//  DirectionVertical             - Individual lines of text are vertical. In
//                                  each line, characters progress from top to
//                                  bottom.
//                                  By default, lines of text are horizontal,
//                                  each new line below the previous line.
//
//  NoFitBlackBox                 - Allows parts of glyphs to overhang the
//                                  bounding rectangle.
//                                  By default glyphs are first aligned
//                                  inside the margines, then any glyphs which
//                                  still overhang the bounding box are
//                                  repositioned to avoid any overhang.
//                                  For example when an italic
//                                  lower case letter f in a font such as
//                                  Garamond is aligned at the far left of a
//                                  rectangle, the lower part of the f will
//                                  reach slightly further left than the left
//                                  edge of the rectangle. Setting this flag
//                                  will ensure the character aligns visually
//                                  with the lines above and below, but may
//                                  cause some pixels outside the formatting
//                                  rectangle to be clipped or painted.
//
//  DisplayFormatControl          - Causes control characters such as the
//                                  left-to-right mark to be shown in the
//                                  output with a representative glyph.
//
//  NoFontFallback                - Disables fallback to alternate fonts for
//                                  characters not supported in the requested
//                                  font. Any missing characters will be
//                                  be displayed with the fonts missing glyph,
//                                  usually an open square.
//
//  NoWrap                        - Disables wrapping of text between lines
//                                  when formatting within a rectangle.
//                                  NoWrap is implied when a point is passed
//                                  instead of a rectangle, or when the
//                                  specified rectangle has a zero line length.
//
//  NoClip                        - By default text is clipped to the
//                                  formatting rectangle. Setting NoClip
//                                  allows overhanging pixels to affect the
//                                  device outside the formatting rectangle.
//                                  Pixels at the end of the line may be
//                                  affected if the glyphs overhang their
//                                  cells, and either the NoFitBlackBox flag
//                                  has been set, or the glyph extends to far
//                                  to be fitted.
//                                  Pixels above/before the first line or
//                                  below/after the last line may be affected
//                                  if the glyphs extend beyond their cell
//                                  ascent / descent. This can occur rarely
//                                  with unusual diacritic mark combinations.

//---------------------------------------------------------------------------

enum StringFormatFlags
{
    StringFormatFlagsDirectionRightToLeft        = 0x00000001,
    StringFormatFlagsDirectionVertical           = 0x00000002,
    StringFormatFlagsNoFitBlackBox               = 0x00000004,
    StringFormatFlagsDisplayFormatControl        = 0x00000020,
    StringFormatFlagsNoFontFallback              = 0x00000400,
    StringFormatFlagsMeasureTrailingSpaces       = 0x00000800,
    StringFormatFlagsNoWrap                      = 0x00001000,
    StringFormatFlagsLineLimit                   = 0x00002000,

    StringFormatFlagsNoClip                      = 0x00004000
};

//---------------------------------------------------------------------------
// StringTrimming
//---------------------------------------------------------------------------

enum StringTrimming {
    StringTrimmingNone              = 0,
    StringTrimmingCharacter         = 1,
    StringTrimmingWord              = 2,
    StringTrimmingEllipsisCharacter = 3,
    StringTrimmingEllipsisWord      = 4,
    StringTrimmingEllipsisPath      = 5
};

//---------------------------------------------------------------------------
// National language digit substitution
//---------------------------------------------------------------------------

enum StringDigitSubstitute
{
    StringDigitSubstituteUser        = 0,  // As NLS setting
    StringDigitSubstituteNone        = 1,
    StringDigitSubstituteNational    = 2,
    StringDigitSubstituteTraditional = 3
};

//---------------------------------------------------------------------------
// Hotkey prefix interpretation
//---------------------------------------------------------------------------

enum HotkeyPrefix
{
    HotkeyPrefixNone        = 0,
    HotkeyPrefixShow        = 1,
    HotkeyPrefixHide        = 2
};

//---------------------------------------------------------------------------
// String alignment flags
//---------------------------------------------------------------------------

enum StringAlignment
{
    // Left edge for left-to-right text,
    // right for right-to-left text,
    // and top for vertical
    StringAlignmentNear   = 0,
    StringAlignmentCenter = 1,
    StringAlignmentFar    = 2
};

//---------------------------------------------------------------------------
// DriverStringOptions
//---------------------------------------------------------------------------

enum DriverStringOptions
{
    DriverStringOptionsCmapLookup             = 1,
    DriverStringOptionsVertical               = 2,
    DriverStringOptionsRealizedAdvance        = 4,
    DriverStringOptionsLimitSubpixel          = 8
};

//---------------------------------------------------------------------------
// Flush Intention flags
//---------------------------------------------------------------------------

enum FlushIntention
{
    FlushIntentionFlush = 0,        // Flush all batched rendering operations
    FlushIntentionSync = 1          // Flush all batched rendering operations
                                    // and wait for them to complete
};

//---------------------------------------------------------------------------
// Image encoder parameter related types
//---------------------------------------------------------------------------

enum EncoderParameterValueType
{
    EncoderParameterValueTypeByte           = 1,    // 8-bit unsigned int
    EncoderParameterValueTypeASCII          = 2,    // 8-bit byte containing one 7-bit ASCII
                                                    // code. NULL terminated.
    EncoderParameterValueTypeShort          = 3,    // 16-bit unsigned int
    EncoderParameterValueTypeLong           = 4,    // 32-bit unsigned int
    EncoderParameterValueTypeRational       = 5,    // Two Longs. The first Long is the
                                                    // numerator, the second Long expresses the
                                                    // denomintor.
    EncoderParameterValueTypeLongRange      = 6,    // Two longs which specify a range of
                                                    // integer values. The first Long specifies
                                                    // the lower end and the second one
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
    EncoderParameterValueTypeUndefined      = 7,    // 8-bit byte that can take any value
                                                    // depending on field definition
    EncoderParameterValueTypeRationalRange  = 8     // Two Rationals. The first Rational
                                                    // specifies the lower end and the second
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
};

//---------------------------------------------------------------------------
// Image encoder value types
//---------------------------------------------------------------------------

enum EncoderValue
{
    EncoderValueColorTypeCMYK,
    EncoderValueColorTypeYCCK,
    EncoderValueCompressionLZW,
    EncoderValueCompressionCCITT3,
    EncoderValueCompressionCCITT4,
    EncoderValueCompressionRle,
    EncoderValueCompressionNone,
    EncoderValueScanMethodInterlaced,
    EncoderValueScanMethodNonInterlaced,
    EncoderValueVersionGif87,
    EncoderValueVersionGif89,
    EncoderValueRenderProgressive,
    EncoderValueRenderNonProgressive,
    EncoderValueTransformRotate90,
    EncoderValueTransformRotate180,
    EncoderValueTransformRotate270,
    EncoderValueTransformFlipHorizontal,
    EncoderValueTransformFlipVertical,
    EncoderValueMultiFrame,
    EncoderValueLastFrame,
    EncoderValueFlush,
    EncoderValueFrameDimensionTime,
    EncoderValueFrameDimensionResolution,
    EncoderValueFrameDimensionPage
};

//---------------------------------------------------------------------------
// Conversion of Emf To WMF Bits flags
//---------------------------------------------------------------------------

enum EmfToWmfBitsFlags
{
    EmfToWmfBitsFlagsDefault          = 0x00000000,
    EmfToWmfBitsFlagsEmbedEmf         = 0x00000001,
    EmfToWmfBitsFlagsIncludePlaceable = 0x00000002,
    EmfToWmfBitsFlagsNoXORClip        = 0x00000004
};

//---------------------------------------------------------------------------
// Test Control flags
//---------------------------------------------------------------------------

enum GpTestControlEnum
{
    TestControlForceBilinear = 0,
    TestControlNoICM = 1,
    TestControlGetBuildNumber = 2
};



#endif // !_GDIPLUSENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluscachedbitmap.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap class definition
*
* Abstract:
*
*   GDI+ CachedBitmap is a representation of an accelerated drawing
*   that has restrictions on what operations are allowed in order
*   to accelerate the drawing to the destination.
*
*   Look for class definition in GdiplusHeaders.h
*
**************************************************************************/

#ifndef _GDIPLUSCACHEDBITMAP_H
#define _GDIPLUSCACHEDBITMAP_H

inline 
CachedBitmap::CachedBitmap(
    IN Bitmap *bitmap, 
    IN Graphics *graphics)
{
    nativeCachedBitmap = NULL;    

    lastResult = DllExports::GdipCreateCachedBitmap(
        (GpBitmap *)bitmap->nativeImage,
        graphics->nativeGraphics,
        &nativeCachedBitmap
    );
}

inline 
CachedBitmap::~CachedBitmap()
{
    DllExports::GdipDeleteCachedBitmap(nativeCachedBitmap);
}

inline Status 
CachedBitmap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusimagecodec.h ===
/**************************************************************************\
*
* Copyright (c) 2000-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusImageCodec.h
*
* Abstract:
*
*   GDI+ Codec Image APIs
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGECODEC_H
#define _GDIPLUSIMAGECODEC_H

//--------------------------------------------------------------------------
// Codec Management APIs
//--------------------------------------------------------------------------

inline Status 
GetImageDecodersSize(
    OUT UINT *numDecoders,
    OUT UINT *size)
{
    return DllExports::GdipGetImageDecodersSize(numDecoders, size);
}


inline Status 
GetImageDecoders(
    IN UINT numDecoders,
    IN UINT size,
    OUT ImageCodecInfo *decoders)
{
    return DllExports::GdipGetImageDecoders(numDecoders, size, decoders);
}


inline Status 
GetImageEncodersSize(
    OUT UINT *numEncoders, 
    OUT UINT *size)
{
    return DllExports::GdipGetImageEncodersSize(numEncoders, size);
}


inline Status 
GetImageEncoders(
    IN UINT numEncoders,
    IN UINT size,
    OUT ImageCodecInfo *encoders)
{
    return DllExports::GdipGetImageEncoders(numEncoders, size, encoders);
}

#endif  // _GDIPLUSIMAGECODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusfontcollection.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
* 
*   GdiplusFontCollection.h
*
* Abstract:
*
*   Font collections (Installed and Private)
*
\**************************************************************************/

#ifndef _GDIPLUSFONTCOLL_H
#define _GDIPLUSFONTCOLL_H

inline
FontCollection::FontCollection()
{
    nativeFontCollection = NULL;
}

inline
FontCollection::~FontCollection()
{
}

inline INT
FontCollection::GetFamilyCount() const
{
    INT numFound = 0;

    lastResult = DllExports::GdipGetFontCollectionFamilyCount(
                             nativeFontCollection, &numFound);



    return numFound;
}

inline Status
FontCollection::GetFamilies(
    IN INT           numSought,
    OUT FontFamily * gpfamilies,
    OUT INT *        numFound
) const
{
    if (numSought <= 0 || gpfamilies == NULL || numFound == NULL)
    {
        return SetStatus(InvalidParameter);
    }
    *numFound = 0;
    GpFontFamily **nativeFamilyList = new GpFontFamily*[numSought];

    if (nativeFamilyList == NULL)
    {
        return SetStatus(OutOfMemory);
    }

    Status status = SetStatus(DllExports::GdipGetFontCollectionFamilyList(
        nativeFontCollection,
        numSought,
        nativeFamilyList,
        numFound
    ));
    if (status == Ok)
    {
        for (INT i = 0; i < *numFound; i++)
        {
            DllExports::GdipCloneFontFamily(nativeFamilyList[i],
                                            &gpfamilies[i].nativeFamily);
        }
    }

    delete [] nativeFamilyList;

    return status;
}

inline Status FontCollection::GetLastStatus () const
{
    return lastResult;
}

inline Status
FontCollection::SetStatus(IN Status status) const
{
    lastResult = status;
    return lastResult;
}

inline
InstalledFontCollection::InstalledFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewInstalledFontCollection(&nativeFontCollection);
}

inline
InstalledFontCollection::~InstalledFontCollection()
{
}

inline
PrivateFontCollection::PrivateFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewPrivateFontCollection(&nativeFontCollection);
}

inline
PrivateFontCollection::~PrivateFontCollection()
{
    DllExports::GdipDeletePrivateFontCollection(&nativeFontCollection);
}

inline Status
PrivateFontCollection::AddFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipPrivateAddFontFile(nativeFontCollection, filename));
}

inline Status
PrivateFontCollection::AddMemoryFont(IN const void* memory,
                                     IN INT length)
{
    return SetStatus(DllExports::GdipPrivateAddMemoryFont(
        nativeFontCollection,
        memory,
        length));
}

#endif // _GDIPLUSFONTCOLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusfont.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFont.h
*
* Abstract:
*
*   GDI+ Font class
*
\**************************************************************************/

#ifndef _GDIPLUSFONT_H
#define _GDIPLUSFONT_H

inline
Font::Font(IN HDC hdc)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const HFONT hfont)
{
    GpFont *font = NULL;

    if (hfont)
    {
        LOGFONTA lf;

        if(GetObjectA(hfont, sizeof(LOGFONTA), &lf))
            lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, &lf, &font);
        else
            lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTW* logfont)
{
    GpFont *font = NULL;
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontW(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTA* logfont)
{
    GpFont *font = NULL;

    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(
     IN const FontFamily * family,
     IN REAL         emSize,
     IN INT          style,
     IN Unit         unit
)
{
    GpFont *font = NULL;

    lastResult = DllExports::GdipCreateFont(family ? family->nativeFamily : NULL,
                    emSize,
                    style,
                    unit,
                    &font);

    SetNativeFont(font);
}

inline
Font::Font(
     IN const WCHAR *          familyName,
     IN REAL                   emSize,
     IN INT                    style,
     IN Unit                   unit,
     IN const FontCollection * fontCollection
)
{
    nativeFont = NULL;

    FontFamily family(familyName, fontCollection);
    GpFontFamily *nativeFamily = family.nativeFamily;

    lastResult = family.GetLastStatus();

    if (lastResult != Ok)
    {
        nativeFamily = FontFamily::GenericSansSerif()->nativeFamily;
        lastResult = FontFamily::GenericSansSerif()->lastResult;
        if (lastResult != Ok)
            return;
    }

    lastResult = DllExports::GdipCreateFont(nativeFamily,
                            emSize,
                            style,
                            unit,
                            &nativeFont);

    if (lastResult != Ok)
    {
        nativeFamily = FontFamily::GenericSansSerif()->nativeFamily;
        lastResult = FontFamily::GenericSansSerif()->lastResult;
        if (lastResult != Ok)
            return;

        lastResult = DllExports::GdipCreateFont(
            nativeFamily,
            emSize,
            style,
            unit,
            &nativeFont);
    }
}

inline Status
Font::GetLogFontA(IN const Graphics *g,
                  OUT LOGFONTA *logfontA) const
{
    return SetStatus(DllExports::GdipGetLogFontA(nativeFont, g ? g->nativeGraphics : NULL, logfontA));

}

inline Status
Font::GetLogFontW(IN const Graphics *g,
                  OUT LOGFONTW *logfontW) const
{
    return SetStatus(DllExports::GdipGetLogFontW(nativeFont, g ? g->nativeGraphics : NULL, logfontW));
}


inline Font*
Font::Clone() const
{
    GpFont *cloneFont = NULL;

    SetStatus(DllExports::GdipCloneFont(nativeFont, &cloneFont));

    return new Font(cloneFont, lastResult);
}

inline
Font::~Font()
{
    DllExports::GdipDeleteFont(nativeFont);
}

// Operations

inline BOOL
Font::IsAvailable() const
{
    return (nativeFont ? TRUE : FALSE);
}

inline Status
Font::GetFamily(OUT FontFamily *family) const
{
    if (family == NULL)
    {
        return SetStatus(InvalidParameter);
    }

    Status status = DllExports::GdipGetFamily(nativeFont, &(family->nativeFamily));
    family->SetStatus(status);

    return SetStatus(status);
}

inline INT
Font::GetStyle() const
{
    INT style;

    SetStatus(DllExports::GdipGetFontStyle(nativeFont, &style));

    return style;
}

inline REAL
Font::GetSize() const
{
    REAL size;
    SetStatus(DllExports::GdipGetFontSize(nativeFont, &size));
    return size;
}

inline Unit
Font::GetUnit() const
{
    Unit unit;
    SetStatus(DllExports::GdipGetFontUnit(nativeFont, &unit));
    return unit;
}

inline REAL
Font::GetHeight(IN const Graphics *graphics) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeight(
        nativeFont,
        graphics ? graphics->nativeGraphics : NULL,
        &height
    ));
    return height;
}


inline REAL
Font::GetHeight(IN REAL dpi) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeightGivenDPI(nativeFont, dpi, &height));
    return height;
}

inline
Font::Font(IN GpFont* font,
           IN Status status)
{
    lastResult = status;
    SetNativeFont(font);
}

inline VOID
Font::SetNativeFont(GpFont *Font)
{
    nativeFont = Font;
}

inline Status
Font::GetLastStatus(void) const
{
    return lastResult;
}

inline Status
Font::SetStatus(IN Status status) const
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusflat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFlat.h
*
* Abstract:
*
*   Private GDI+ header file.
*
\**************************************************************************/

#ifndef _FLATAPI_H
#define _FLATAPI_H

#define WINGDIPAPI __stdcall

#define GDIPCONST const

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// GraphicsPath APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePath(GpFillMode brushMode, GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2(GDIPCONST GpPointF*, GDIPCONST BYTE*, INT, GpFillMode,
                                    GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2I(GDIPCONST GpPoint*, GDIPCONST BYTE*, INT, GpFillMode,
                                     GpPath **path);

GpStatus WINGDIPAPI
GdipClonePath(GpPath* path, GpPath **clonePath);

GpStatus WINGDIPAPI
GdipDeletePath(GpPath* path);

GpStatus WINGDIPAPI
GdipResetPath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPointCount(GpPath* path, INT* count);

GpStatus WINGDIPAPI
GdipGetPathTypes(GpPath* path, BYTE* types, INT count);

GpStatus WINGDIPAPI
GdipGetPathPoints(GpPath*, GpPointF* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathPointsI(GpPath*, GpPoint* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathFillMode(GpPath *path, GpFillMode *fillmode);

GpStatus WINGDIPAPI
GdipSetPathFillMode(GpPath *path, GpFillMode fillmode);

GpStatus WINGDIPAPI
GdipGetPathData(GpPath *path, GpPathData* pathData);

GpStatus WINGDIPAPI
GdipStartPathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigures(GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathMarker(GpPath* path);

GpStatus WINGDIPAPI
GdipClearPathMarkers(GpPath* path);

GpStatus WINGDIPAPI
GdipReversePath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPathLastPoint(GpPath* path, GpPointF* lastPoint);

GpStatus WINGDIPAPI
GdipAddPathLine(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipAddPathLine2(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArc(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezier(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2,
                           REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipAddPathBeziers(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangle(GpPath *path, REAL x, REAL y, REAL width, REAL height);

GpStatus WINGDIPAPI
GdipAddPathRectangles(GpPath *path, GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipse(GpPath *path, REAL x, REAL y, REAL width,
                            REAL height);

GpStatus WINGDIPAPI
GdipAddPathPie(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygon(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathPath(GpPath *path, GDIPCONST GpPath* addingPath, BOOL connect);

GpStatus WINGDIPAPI
GdipAddPathString(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST RectF *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathStringI(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST Rect *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathLineI(GpPath *path, INT x1, INT y1, INT x2, INT y2);

GpStatus WINGDIPAPI
GdipAddPathLine2I(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArcI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezierI(GpPath *path, INT x1, INT y1, INT x2, INT y2,
                           INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipAddPathBeziersI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangleI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathRectanglesI(GpPath *path, GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipseI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathPieI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygonI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFlattenPath(GpPath *path, GpMatrix* matrix, REAL flatness);

GpStatus WINGDIPAPI
GdipWindingModeOutline(
    GpPath *path,
    GpMatrix *matrix,
    REAL flatness
);

GpStatus WINGDIPAPI
GdipWidenPath(
    GpPath *nativePath,
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
);

GpStatus WINGDIPAPI
GdipWarpPath(GpPath *path, GpMatrix* matrix,
            GDIPCONST GpPointF *points, INT count,
            REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
            WarpMode warpMode, REAL flatness);

GpStatus WINGDIPAPI
GdipTransformPath(GpPath* path, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetPathWorldBounds(GpPath* path, GpRectF* bounds, 
                       GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipGetPathWorldBoundsI(GpPath* path, GpRect* bounds, 
                        GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipIsVisiblePathPoint(GpPath* path, REAL x, REAL y,
                       GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePathPointI(GpPath* path, INT x, INT y,
                        GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPoint(GpPath* path, REAL x, REAL y, GpPen *pen,
                              GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPointI(GpPath* path, INT x, INT y, GpPen *pen,
                               GpGraphics *graphics, BOOL *result);


//----------------------------------------------------------------------------
// PathIterator APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathIter(GpPathIterator **iterator, GpPath* path);

GpStatus WINGDIPAPI
GdipDeletePathIter(GpPathIterator *iterator);

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextPathType(GpPathIterator* iterator, INT* resultCount,
        BYTE* pathType, INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarker(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path);

GpStatus WINGDIPAPI
GdipPathIterGetCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterIsValid(GpPathIterator* iterator, BOOL* valid);

GpStatus WINGDIPAPI
GdipPathIterHasCurve(GpPathIterator* iterator, BOOL* hasCurve);

GpStatus WINGDIPAPI
GdipPathIterRewind(GpPathIterator* iterator);

GpStatus WINGDIPAPI
GdipPathIterEnumerate(GpPathIterator* iterator, INT* resultCount,
    GpPointF *points, BYTE *types, INT count);

GpStatus WINGDIPAPI
GdipPathIterCopyData(GpPathIterator* iterator, INT* resultCount,
    GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

//----------------------------------------------------------------------------
// Matrix APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix2(REAL m11, REAL m12, REAL m21, REAL m22, REAL dx,
                                      REAL dy, GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3(GDIPCONST GpRectF *rect, GDIPCONST GpPointF *dstplg,
                                      GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3I(GDIPCONST GpRect *rect, GDIPCONST GpPoint *dstplg,
                                       GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCloneMatrix(GpMatrix *matrix, GpMatrix **cloneMatrix);

GpStatus WINGDIPAPI
GdipDeleteMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetMatrixElements(GpMatrix *matrix, REAL m11, REAL m12, REAL m21, REAL m22,
                      REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipMultiplyMatrix(GpMatrix *matrix, GpMatrix* matrix2,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX, REAL offsetY,
                    GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateMatrix(GpMatrix *matrix, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipShearMatrix(GpMatrix *matrix, REAL shearX, REAL shearY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);

GpStatus WINGDIPAPI
GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipGetMatrixElements(GDIPCONST GpMatrix *matrix, REAL *matrixOut);

GpStatus WINGDIPAPI
GdipIsMatrixInvertible(GDIPCONST GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixIdentity(GDIPCONST GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixEqual(GDIPCONST GpMatrix *matrix, GDIPCONST GpMatrix *matrix2, 
                  BOOL *result);

//----------------------------------------------------------------------------
// Region APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateRegion(GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRect(GDIPCONST GpRectF *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRectI(GDIPCONST GpRect *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionPath(GpPath *path, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRgnData(GDIPCONST BYTE *regionData, INT size, 
                        GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionHrgn(HRGN hRgn, GpRegion **region);

GpStatus WINGDIPAPI
GdipCloneRegion(GpRegion *region, GpRegion **cloneRegion);

GpStatus WINGDIPAPI
GdipDeleteRegion(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetInfinite(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetEmpty(GpRegion *region);

GpStatus WINGDIPAPI
GdipCombineRegionRect(GpRegion *region, GDIPCONST GpRectF *rect,
                      CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRectI(GpRegion *region, GDIPCONST GpRect *rect,
                       CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionPath(GpRegion *region, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRegion(GpRegion *region,  GpRegion *region2,
                        CombineMode combineMode);

GpStatus WINGDIPAPI
GdipTranslateRegion(GpRegion *region, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateRegionI(GpRegion *region, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipTransformRegion(GpRegion *region, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetRegionBounds(GpRegion *region, GpGraphics *graphics,
                             GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetRegionBoundsI(GpRegion *region, GpGraphics *graphics,
                             GpRect *rect);

GpStatus WINGDIPAPI
GdipGetRegionHRgn(GpRegion *region, GpGraphics *graphics, HRGN *hRgn);

GpStatus WINGDIPAPI
GdipIsEmptyRegion(GpRegion *region, GpGraphics *graphics,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsInfiniteRegion(GpRegion *region, GpGraphics *graphics,
                              BOOL *result);

GpStatus WINGDIPAPI
GdipIsEqualRegion(GpRegion *region, GpRegion *region2,
                           GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionDataSize(GpRegion *region, UINT * bufferSize);

GpStatus WINGDIPAPI
GdipGetRegionData(GpRegion *region, BYTE * buffer, UINT bufferSize, 
                  UINT * sizeFilled);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPoint(GpRegion *region, REAL x, REAL y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPointI(GpRegion *region, INT x, INT y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRect(GpRegion *region, REAL x, REAL y, REAL width,
                        REAL height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRectI(GpRegion *region, INT x, INT y, INT width,
                         INT height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionScansCount(GpRegion *region, UINT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScans(GpRegion *region, GpRectF* rects, INT* count, 
                   GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScansI(GpRegion *region, GpRect* rects, INT* count, 
                    GpMatrix* matrix);

//----------------------------------------------------------------------------
// Brush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCloneBrush(GpBrush *brush, GpBrush **cloneBrush);

GpStatus WINGDIPAPI
GdipDeleteBrush(GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetBrushType(GpBrush *brush, GpBrushType *type);

//----------------------------------------------------------------------------
// HatchBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateHatchBrush(GpHatchStyle hatchstyle, ARGB forecol,
                              ARGB backcol, GpHatch **brush);

GpStatus WINGDIPAPI
GdipGetHatchStyle(GpHatch *brush, GpHatchStyle *hatchstyle);

GpStatus WINGDIPAPI
GdipGetHatchForegroundColor(GpHatch *brush, ARGB* forecol);

GpStatus WINGDIPAPI
GdipGetHatchBackgroundColor(GpHatch *brush, ARGB* backcol);

//----------------------------------------------------------------------------
// TextureBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateTexture(GpImage *image, GpWrapMode wrapmode,
                           GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode, REAL x,
                   REAL y, REAL width, REAL height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIA(GpImage *image, 
                    GDIPCONST GpImageAttributes *imageAttributes,
                    REAL x, REAL y, REAL width, REAL height,
                    GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode, INT x,
                    INT y, INT width, INT height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIAI(GpImage *image, 
                     GDIPCONST GpImageAttributes *imageAttributes,
                     INT x, INT y, INT width, INT height,
                     GpTexture **texture);


GpStatus WINGDIPAPI
GdipGetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetTextureTransform(GpTexture *brush, GDIPCONST GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetTextureTransform(GpTexture* brush);

GpStatus WINGDIPAPI
GdipMultiplyTextureTransform(GpTexture* brush, GDIPCONST GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateTextureTransform(GpTexture* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleTextureTransform(GpTexture* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateTextureTransform(GpTexture* brush, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetTextureWrapMode(GpTexture *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureWrapMode(GpTexture *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureImage(GpTexture *brush, GpImage **image);

//----------------------------------------------------------------------------
// SolidBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateSolidFill(ARGB color, GpSolidFill **brush);

GpStatus WINGDIPAPI
GdipSetSolidFillColor(GpSolidFill *brush, ARGB color);

GpStatus WINGDIPAPI
GdipGetSolidFillColor(GpSolidFill *brush, ARGB *color);

//----------------------------------------------------------------------------
// LineBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateLineBrush(GDIPCONST GpPointF* point1,
                    GDIPCONST GpPointF* point2,
                    ARGB color1, ARGB color2,
                    GpWrapMode wrapMode,
                    GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushI(GDIPCONST GpPoint* point1,
                     GDIPCONST GpPoint* point2,
                     ARGB color1, ARGB color2,
                     GpWrapMode wrapMode,
                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRect(GDIPCONST GpRectF* rect,
                            ARGB color1, ARGB color2,
                            LinearGradientMode mode,
                            GpWrapMode wrapMode,
                            GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectI(GDIPCONST GpRect* rect,
                             ARGB color1, ARGB color2,
                             LinearGradientMode mode,
                             GpWrapMode wrapMode,
                             GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(GDIPCONST GpRectF* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(GDIPCONST GpRect* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipSetLineColors(GpLineGradient *brush, ARGB color1, ARGB color2);

GpStatus WINGDIPAPI
GdipGetLineColors(GpLineGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipGetLineRect(GpLineGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetLineRectI(GpLineGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipSetLineGammaCorrection(GpLineGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineGammaCorrection(GpLineGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLineBlend(GpLineGradient *brush, REAL *blend, REAL* positions,
                 INT count);

GpStatus WINGDIPAPI
GdipSetLineBlend(GpLineGradient *brush, GDIPCONST REAL *blend,
                 GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlend(GpLineGradient *brush, ARGB *blend,
                                           REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLinePresetBlend(GpLineGradient *brush, GDIPCONST ARGB *blend,
                       GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLineSigmaBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineLinearBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineWrapMode(GpLineGradient *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetLineWrapMode(GpLineGradient *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetLineTransform(GpLineGradient *brush, GDIPCONST GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetLineTransform(GpLineGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyLineTransform(GpLineGradient* brush, GDIPCONST GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateLineTransform(GpLineGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleLineTransform(GpLineGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateLineTransform(GpLineGradient* brush, REAL angle, 
                        GpMatrixOrder order);

//----------------------------------------------------------------------------
// PathGradientBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathGradient(GDIPCONST GpPointF* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientI(GDIPCONST GpPoint* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientFromPath(GDIPCONST GpPath* path,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB colors);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush, ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush,
                        GDIPCONST ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientPath(GpPathGradient *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathGradientPath(GpPathGradient *brush, GDIPCONST GpPath *path);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPoint(
                        GpPathGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPointI(
                        GpPathGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPoint(
                        GpPathGradient *brush, GDIPCONST GpPointF* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPointI(
                        GpPathGradient *brush, GDIPCONST GpPoint* points);

GpStatus WINGDIPAPI
GdipGetPathGradientRect(GpPathGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientRectI(GpPathGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientPointCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientGammaCorrection(GpPathGradient *brush, 
                                   BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientGammaCorrection(GpPathGradient *brush, 
                                   BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientBlendCount(GpPathGradient *brush,
                                             INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientBlend(GpPathGradient *brush,
                                    REAL *blend, REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientBlend(GpPathGradient *brush,
                GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlendCount(GpPathGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlend(GpPathGradient *brush, ARGB *blend,
                                                REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientPresetBlend(GpPathGradient *brush, GDIPCONST ARGB *blend,
                                        GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientSigmaBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetPathGradientLinearBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipGetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipSetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPathGradientTransform(GpPathGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyPathGradientTransform(GpPathGradient* brush, 
                                  GDIPCONST GpMatrix *matrix,
                                  GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePathGradientTransform(GpPathGradient* brush, REAL dx, REAL dy,
                                   GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePathGradientTransform(GpPathGradient* brush, REAL sx, REAL sy,
                               GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePathGradientTransform(GpPathGradient* brush, REAL angle,
                                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetPathGradientFocusScales(GpPathGradient *brush, REAL* xScale, 
                               REAL* yScale);

GpStatus WINGDIPAPI
GdipSetPathGradientFocusScales(GpPathGradient *brush, REAL xScale, 
                               REAL yScale);

//----------------------------------------------------------------------------
// Pen APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen);

GpStatus WINGDIPAPI
GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit,
                        GpPen **pen);

GpStatus WINGDIPAPI
GdipClonePen(GpPen *pen, GpPen **clonepen);

GpStatus WINGDIPAPI
GdipDeletePen(GpPen *pen);

GpStatus WINGDIPAPI
GdipSetPenWidth(GpPen *pen, REAL width);

GpStatus WINGDIPAPI
GdipGetPenWidth(GpPen *pen, REAL *width);

GpStatus WINGDIPAPI
GdipSetPenUnit(GpPen *pen, GpUnit unit);

GpStatus WINGDIPAPI
GdipGetPenUnit(GpPen *pen, GpUnit *unit);

GpStatus WINGDIPAPI
GdipSetPenLineCap197819(GpPen *pen, GpLineCap startCap, GpLineCap endCap,
                  GpDashCap dashCap);

GpStatus WINGDIPAPI
GdipSetPenStartCap(GpPen *pen, GpLineCap startCap);

GpStatus WINGDIPAPI
GdipSetPenEndCap(GpPen *pen, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipSetPenDashCap197819(GpPen *pen, GpDashCap dashCap);

GpStatus WINGDIPAPI
GdipGetPenStartCap(GpPen *pen, GpLineCap *startCap);

GpStatus WINGDIPAPI
GdipGetPenEndCap(GpPen *pen, GpLineCap *endCap);

GpStatus WINGDIPAPI
GdipGetPenDashCap197819(GpPen *pen, GpDashCap *dashCap);

GpStatus WINGDIPAPI
GdipSetPenLineJoin(GpPen *pen, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetPenLineJoin(GpPen *pen, GpLineJoin *lineJoin);

GpStatus WINGDIPAPI
GdipSetPenCustomStartCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomStartCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenCustomEndCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomEndCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenMiterLimit(GpPen *pen, REAL miterLimit);

GpStatus WINGDIPAPI
GdipGetPenMiterLimit(GpPen *pen, REAL *miterLimit);

GpStatus WINGDIPAPI
GdipSetPenMode(GpPen *pen, GpPenAlignment penMode);

GpStatus WINGDIPAPI
GdipGetPenMode(GpPen *pen, GpPenAlignment *penMode);

GpStatus WINGDIPAPI
GdipSetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPenTransform(GpPen *pen);

GpStatus WINGDIPAPI
GdipMultiplyPenTransform(GpPen *pen, GDIPCONST GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePenTransform(GpPen *pen, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePenTransform(GpPen *pen, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePenTransform(GpPen *pen, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetPenColor(GpPen *pen, ARGB argb);

GpStatus WINGDIPAPI
GdipGetPenColor(GpPen *pen, ARGB *argb);

GpStatus WINGDIPAPI
GdipSetPenBrushFill(GpPen *pen, GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetPenBrushFill(GpPen *pen, GpBrush **brush);

GpStatus WINGDIPAPI
GdipGetPenFillType(GpPen *pen, GpPenType* type);

GpStatus WINGDIPAPI
GdipGetPenDashStyle(GpPen *pen, GpDashStyle *dashstyle);

GpStatus WINGDIPAPI
GdipSetPenDashStyle(GpPen *pen, GpDashStyle dashstyle);

GpStatus WINGDIPAPI
GdipGetPenDashOffset(GpPen *pen, REAL *offset);

GpStatus WINGDIPAPI
GdipSetPenDashOffset(GpPen *pen, REAL offset);

GpStatus WINGDIPAPI
GdipGetPenDashCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenDashArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenDashArray(GpPen *pen, REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenCompoundArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundArray(GpPen *pen, REAL *dash, INT count);

//----------------------------------------------------------------------------
// CustomLineCap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCustomLineCap(GpPath* fillPath, GpPath* strokePath,
   GpLineCap baseCap, REAL baseInset, GpCustomLineCap **customCap);

GpStatus WINGDIPAPI
GdipDeleteCustomLineCap(GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipCloneCustomLineCap(GpCustomLineCap* customCap,
                       GpCustomLineCap** clonedCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapType(GpCustomLineCap* customCap,
                       CustomLineCapType* capType);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap startCap, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap* startCap, GpLineCap* endCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, 
                               GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, 
                               GpLineJoin* lineJoin);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap baseCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap* baseCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL inset);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL* inset);

GpStatus WINGDIPAPI
GdipSetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL widthScale);

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL* widthScale);

//----------------------------------------------------------------------------
// AdjustableArrowCap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateAdjustableArrowCap(REAL height, REAL width, BOOL isFilled,
                             GpAdjustableArrowCap **cap);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL height);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL* height);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL width);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL* width);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, 
                                     REAL middleInset);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, 
                                     REAL* middleInset);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL fillState);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL* fillState);

//----------------------------------------------------------------------------
// Image APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipLoadImageFromStream(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFile(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromStreamICM(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFileICM(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipCloneImage(GpImage *image, GpImage **cloneImage);

GpStatus WINGDIPAPI
GdipDisposeImage(GpImage *image);

GpStatus WINGDIPAPI
GdipSaveImageToFile(GpImage *image, GDIPCONST WCHAR* filename,
                    GDIPCONST CLSID* clsidEncoder, 
                    GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveImageToStream(GpImage *image, IStream* stream,
                      GDIPCONST CLSID* clsidEncoder, 
                      GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAdd(GpImage *image, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAddImage(GpImage *image, GpImage* newImage,
                 GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipGetImageBounds(GpImage *image, GpRectF *srcRect, GpUnit *srcUnit);

GpStatus WINGDIPAPI
GdipGetImageDimension(GpImage *image, REAL *width, REAL *height);

GpStatus WINGDIPAPI
GdipGetImageType(GpImage *image, ImageType *type);

GpStatus WINGDIPAPI
GdipGetImageWidth(GpImage *image, UINT *width);

GpStatus WINGDIPAPI
GdipGetImageHeight(GpImage *image, UINT *height);

GpStatus WINGDIPAPI
GdipGetImageHorizontalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageVerticalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageFlags(GpImage *image, UINT *flags);

GpStatus WINGDIPAPI
GdipGetImageRawFormat(GpImage *image, GUID *format);

GpStatus WINGDIPAPI
GdipGetImagePixelFormat(GpImage *image, PixelFormat *format);

GpStatus WINGDIPAPI
GdipGetImageThumbnail(GpImage *image, UINT thumbWidth, UINT thumbHeight,
                      GpImage **thumbImage,
                      GetThumbnailImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipGetEncoderParameterListSize(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                                UINT* size);

GpStatus WINGDIPAPI
GdipGetEncoderParameterList(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                            UINT size, EncoderParameters* buffer);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsCount(GpImage* image, UINT* count);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsList(GpImage* image, GUID* dimensionIDs, 
                                UINT count);

GpStatus WINGDIPAPI
GdipImageGetFrameCount(GpImage *image, GDIPCONST GUID* dimensionID, 
                       UINT* count);

GpStatus WINGDIPAPI
GdipImageSelectActiveFrame(GpImage *image, GDIPCONST GUID* dimensionID,
                           UINT frameIndex);

GpStatus WINGDIPAPI
GdipImageRotateFlip(GpImage *image, RotateFlipType rfType);

GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size);

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette);

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size);

GpStatus WINGDIPAPI
GdipGetPropertyCount(GpImage *image, UINT* numOfProperty);

GpStatus WINGDIPAPI
GdipGetPropertyIdList(GpImage *image, UINT numOfProperty, PROPID* list);

GpStatus WINGDIPAPI
GdipGetPropertyItemSize(GpImage *image, PROPID propId, UINT* size);

GpStatus WINGDIPAPI
GdipGetPropertyItem(GpImage *image, PROPID propId,UINT propSize,
                    PropertyItem* buffer);

GpStatus WINGDIPAPI
GdipGetPropertySize(GpImage *image, UINT* totalBufferSize, 
                    UINT* numProperties);

GpStatus WINGDIPAPI
GdipGetAllPropertyItems(GpImage *image, UINT totalBufferSize,
                        UINT numProperties, PropertyItem* allItems);

GpStatus WINGDIPAPI
GdipRemovePropertyItem(GpImage *image, PROPID propId);

GpStatus WINGDIPAPI
GdipSetPropertyItem(GpImage *image, GDIPCONST PropertyItem* item);

GpStatus WINGDIPAPI
GdipImageForceValidation(GpImage *image);

//----------------------------------------------------------------------------
// Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateBitmapFromStream(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFile(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromStreamICM(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFileICM(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromScan0(INT width,
                          INT height,
                          INT stride,
                          PixelFormat format,
                          BYTE* scan0,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGraphics(INT width,
                             INT height,
                             GpGraphics* target,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(IDirectDrawSurface7* surface,
                                      GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGdiDib(GDIPCONST BITMAPINFO* gdiBitmapInfo,
                           VOID* gdiBitmapData,
                           GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHBITMAP(HBITMAP hbm,
                            HPALETTE hpal,
                            GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHBITMAPFromBitmap(GpBitmap* bitmap,
                            HBITMAP* hbmReturn,
                            ARGB background);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHICON(HICON hicon,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHICONFromBitmap(GpBitmap* bitmap,
                          HICON* hbmReturn);

GpStatus WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height,
                            PixelFormat format,
                            GpBitmap *srcBitmap,
                            GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapAreaI(INT x,
                     INT y,
                     INT width,
                     INT height,
                     PixelFormat format,
                     GpBitmap *srcBitmap,
                     GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipBitmapLockBits(GpBitmap* bitmap,
                   GDIPCONST GpRect* rect,
                   UINT flags,
                   PixelFormat format,
                   BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapUnlockBits(GpBitmap* bitmap,
                     BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapGetPixel(GpBitmap* bitmap, INT x, INT y, ARGB *color);

GpStatus WINGDIPAPI
GdipBitmapSetPixel(GpBitmap* bitmap, INT x, INT y, ARGB color);

GpStatus WINGDIPAPI
GdipBitmapSetResolution(GpBitmap* bitmap, REAL xdpi, REAL ydpi);

//----------------------------------------------------------------------------
// ImageAttributes APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr);

GpStatus WINGDIPAPI
GdipCloneImageAttributes(GDIPCONST GpImageAttributes *imageattr,
                         GpImageAttributes **cloneImageattr);

GpStatus WINGDIPAPI
GdipDisposeImageAttributes(GpImageAttributes *imageattr);

GpStatus WINGDIPAPI
GdipSetImageAttributesToIdentity(GpImageAttributes *imageattr,
                                 ColorAdjustType type);
GpStatus WINGDIPAPI
GdipResetImageAttributes(GpImageAttributes *imageattr,
                         ColorAdjustType type);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorMatrix(GpImageAttributes *imageattr,
                               ColorAdjustType type,
                               BOOL enableFlag,
                               GDIPCONST ColorMatrix* colorMatrix,
                               GDIPCONST ColorMatrix* grayMatrix,
                               ColorMatrixFlags flags);

GpStatus WINGDIPAPI
GdipSetImageAttributesThreshold(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                REAL threshold);

GpStatus WINGDIPAPI
GdipSetImageAttributesGamma(GpImageAttributes *imageattr,
                            ColorAdjustType type,
                            BOOL enableFlag,
                            REAL gamma);

GpStatus WINGDIPAPI
GdipSetImageAttributesNoOp(GpImageAttributes *imageattr,
                           ColorAdjustType type,
                           BOOL enableFlag);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorKeys(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                ARGB colorLow,
                                ARGB colorHigh);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannel(GpImageAttributes *imageattr,
                                    ColorAdjustType type,
                                    BOOL enableFlag,
                                    ColorChannelFlags channelFlags);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(GpImageAttributes *imageattr,
                                                ColorAdjustType type,
                                                BOOL enableFlag,
                                                GDIPCONST 
                                                  WCHAR *colorProfileFilename);

GpStatus WINGDIPAPI
GdipSetImageAttributesRemapTable(GpImageAttributes *imageattr,
                                 ColorAdjustType type,
                                 BOOL enableFlag,
                                 UINT mapSize,
                                 GDIPCONST ColorMap *map);
GpStatus WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
);

GpStatus WINGDIPAPI
GdipSetImageAttributesICMMode(
    GpImageAttributes *imageAttr,
    BOOL on
);

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
);

//----------------------------------------------------------------------------
// Graphics APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipFlush(GpGraphics *graphics, GpFlushIntention intention);

GpStatus WINGDIPAPI
GdipCreateFromHDC(HDC hdc, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHDC2(HDC hdc, HANDLE hDevice, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWNDICM(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipDeleteGraphics(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetDC(GpGraphics* graphics, HDC * hdc);

GpStatus WINGDIPAPI
GdipReleaseDC(GpGraphics* graphics, HDC hdc);

GpStatus WINGDIPAPI
GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode);

GpStatus WINGDIPAPI
GdipGetCompositingMode(GpGraphics *graphics, CompositingMode *compositingMode);

GpStatus WINGDIPAPI
GdipSetRenderingOrigin(GpGraphics *graphics, INT x, INT y);

GpStatus WINGDIPAPI
GdipGetRenderingOrigin(GpGraphics *graphics, INT *x, INT *y);

GpStatus WINGDIPAPI
GdipSetCompositingQuality(GpGraphics *graphics, 
                          CompositingQuality compositingQuality);

GpStatus WINGDIPAPI
GdipGetCompositingQuality(GpGraphics *graphics, 
                          CompositingQuality *compositingQuality);
                          
GpStatus WINGDIPAPI
GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode);

GpStatus WINGDIPAPI
GdipGetSmoothingMode(GpGraphics *graphics, SmoothingMode *smoothingMode);

GpStatus WINGDIPAPI
GdipSetPixelOffsetMode(GpGraphics* graphics, PixelOffsetMode pixelOffsetMode);

GpStatus WINGDIPAPI
GdipGetPixelOffsetMode(GpGraphics *graphics, PixelOffsetMode *pixelOffsetMode);

GpStatus WINGDIPAPI
GdipSetTextRenderingHint(GpGraphics *graphics, TextRenderingHint mode);

GpStatus WINGDIPAPI
GdipGetTextRenderingHint(GpGraphics *graphics, TextRenderingHint *mode);

GpStatus  WINGDIPAPI
GdipSetTextContrast(GpGraphics *graphics, UINT contrast);

GpStatus  WINGDIPAPI
GdipGetTextContrast(GpGraphics *graphics, UINT * contrast);

GpStatus WINGDIPAPI
GdipSetInterpolationMode(GpGraphics *graphics, 
                         InterpolationMode interpolationMode);

GpStatus WINGDIPAPI
GdipGetInterpolationMode(GpGraphics *graphics, 
                         InterpolationMode *interpolationMode);

GpStatus WINGDIPAPI
GdipSetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetWorldTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipMultiplyWorldTransform(GpGraphics *graphics, GDIPCONST GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateWorldTransform(GpGraphics *graphics, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleWorldTransform(GpGraphics *graphics, REAL sx, REAL sy,
                        GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateWorldTransform(GpGraphics *graphics, REAL angle, 
                         GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPageTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetPageUnit(GpGraphics *graphics, GpUnit *unit);

GpStatus WINGDIPAPI
GdipGetPageScale(GpGraphics *graphics, REAL *scale);

GpStatus WINGDIPAPI
GdipSetPageUnit(GpGraphics *graphics, GpUnit unit);

GpStatus WINGDIPAPI
GdipSetPageScale(GpGraphics *graphics, REAL scale);

GpStatus WINGDIPAPI
GdipGetDpiX(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipGetDpiY(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipTransformPoints(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPointF *points,
                             INT count);

GpStatus WINGDIPAPI
GdipTransformPointsI(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPoint *points,
                             INT count);

GpStatus WINGDIPAPI
GdipGetNearestColor(GpGraphics *graphics, ARGB* argb);

// Creates the Win9x Halftone Palette (even on NT) with correct Desktop colors
HPALETTE WINGDIPAPI
GdipCreateHalftonePalette();

GpStatus WINGDIPAPI
GdipDrawLine(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                      REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                      INT x2, INT y2);

GpStatus WINGDIPAPI
GdipDrawLines(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawLinesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawArc(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawArcI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawBezier(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                        REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipDrawBezierI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                        INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipDrawBeziers(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawBeziersI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawRectangle(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                      REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                      INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawRectangles(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRectF *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawRectanglesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRect *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawEllipse(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                         REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                         INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawPie(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                     REAL width, REAL height, REAL startAngle, 
            REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPieI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPolygon(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPath(GpGraphics *graphics, GpPen *pen, GpPath *path);

GpStatus WINGDIPAPI
GdipDrawCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
               INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve(GpGraphics *graphics, GpPen *pen,
                    GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurveI(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPointF *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2I(GpGraphics *graphics, GpPen *pen,
                      GDIPCONST GpPoint *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipGraphicsClear(GpGraphics *graphics, ARGB color);

GpStatus WINGDIPAPI
GdipFillRectangle(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                  REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                   INT width, INT height);

GpStatus WINGDIPAPI
GdipFillRectangles(GpGraphics *graphics, GpBrush *brush,
                   GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipFillRectanglesI(GpGraphics *graphics, GpBrush *brush,
                    GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon(GpGraphics *graphics, GpBrush *brush,
                GDIPCONST GpPointF *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPoint *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygon2(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon2I(GpGraphics *graphics, GpBrush *brush,
                  GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillEllipse(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                 INT width, INT height);

GpStatus WINGDIPAPI
GdipFillPie(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPieI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
             INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPath(GpGraphics *graphics, GpBrush *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipFillClosedCurve(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurveI(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurve2(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillClosedCurve2I(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillRegion(GpGraphics *graphics, GpBrush *brush,
                        GpRegion *region);

GpStatus WINGDIPAPI
GdipDrawImage(GpGraphics *graphics, GpImage *image, REAL x, REAL y);

GpStatus WINGDIPAPI
GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y);

GpStatus WINGDIPAPI
GdipDrawImageRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y,
                           REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawImageRectI(GpGraphics *graphics, GpImage *image, INT x, INT y,
                           INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawImagePoints(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPointF *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointsI(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPoint *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointRect(GpGraphics *graphics, GpImage *image, REAL x,
                                REAL y, REAL srcx, REAL srcy, REAL srcwidth,
                                REAL srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImagePointRectI(GpGraphics *graphics, GpImage *image, INT x,
                                INT y, INT srcx, INT srcy, INT srcwidth,
                                INT srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImageRectRect(GpGraphics *graphics, GpImage *image, REAL dstx,
                      REAL dsty, REAL dstwidth, REAL dstheight,
                      REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
                      GpUnit srcUnit,
                      GDIPCONST GpImageAttributes* imageAttributes,
                      DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImageRectRectI(GpGraphics *graphics, GpImage *image, INT dstx,
                       INT dsty, INT dstwidth, INT dstheight,
                       INT srcx, INT srcy, INT srcwidth, INT srcheight,
                       GpUnit srcUnit,
                       GDIPCONST GpImageAttributes* imageAttributes,
                       DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image,
                        GDIPCONST GpPointF *points, INT count, REAL srcx,
                        REAL srcy, REAL srcwidth, REAL srcheight,
                        GpUnit srcUnit,
                        GDIPCONST GpImageAttributes* imageAttributes,
                        DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRectI(GpGraphics *graphics, GpImage *image,
                         GDIPCONST GpPoint *points, INT count, INT srcx,
                         INT srcy, INT srcwidth, INT srcheight,
                         GpUnit srcUnit,
                         GDIPCONST GpImageAttributes* imageAttributes,
                         DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    );

GpStatus WINGDIPAPI
GdipSetClipGraphics(GpGraphics *graphics, GpGraphics *srcgraphics,
                    CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRect(GpGraphics *graphics, REAL x, REAL y,
                         REAL width, REAL height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRectI(GpGraphics *graphics, INT x, INT y,
                         INT width, INT height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipPath(GpGraphics *graphics, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRegion(GpGraphics *graphics, GpRegion *region,
                  CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipHrgn(GpGraphics *graphics, HRGN hRgn, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipResetClip(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipTranslateClip(GpGraphics *graphics, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateClipI(GpGraphics *graphics, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipGetClip(GpGraphics *graphics, GpRegion *region);

GpStatus WINGDIPAPI
GdipGetClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetVisibleClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetVisibleClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsVisibleClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePoint(GpGraphics *graphics, REAL x, REAL y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePointI(GpGraphics *graphics, INT x, INT y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRect(GpGraphics *graphics, REAL x, REAL y,
                           REAL width, REAL height, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRectI(GpGraphics *graphics, INT x, INT y,
                           INT width, INT height, BOOL *result);

GpStatus WINGDIPAPI
GdipSaveGraphics(GpGraphics *graphics, GraphicsState *state);

GpStatus WINGDIPAPI
GdipRestoreGraphics(GpGraphics *graphics, GraphicsState state);

GpStatus WINGDIPAPI
GdipBeginContainer(GpGraphics *graphics, GDIPCONST GpRectF* dstrect,
                   GDIPCONST GpRectF *srcrect, GpUnit unit, 
                   GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainerI(GpGraphics *graphics, GDIPCONST GpRect* dstrect,
                    GDIPCONST GpRect *srcrect, GpUnit unit, 
                    GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainer2(GpGraphics *graphics, GraphicsContainer* state);

GpStatus WINGDIPAPI
GdipEndContainer(GpGraphics *graphics, GraphicsContainer state);

GpStatus
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    GDIPCONST WmfPlaceableFileHeader *     wmfPlaceableFileHeader,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    );

GpStatus WINGDIPAPI
GdipCreateStreamOnFile(GDIPCONST WCHAR * filename, UINT access, 
                       IStream **stream);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmf(HMETAFILE hWmf, BOOL deleteWmf,
                          GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader, 
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromEmf(HENHMETAFILE hEmf, BOOL deleteEmf,
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromFile(GDIPCONST WCHAR* file, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmfFile(GDIPCONST WCHAR* file, 
                              GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader, 
                              GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromStream(IStream * stream, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipSetMetafileDownLevelRasterizationLimit(
    GpMetafile *            metafile,
    UINT                    metafileRasterizationLimitDpi
    );

GpStatus WINGDIPAPI
GdipGetMetafileDownLevelRasterizationLimit(
    GDIPCONST GpMetafile *  metafile,
    UINT *                  metafileRasterizationLimitDpi
    );

GpStatus WINGDIPAPI
GdipGetImageDecodersSize(UINT *numDecoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     ImageCodecInfo *decoders);

GpStatus WINGDIPAPI
GdipGetImageEncodersSize(UINT *numEncoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     ImageCodecInfo *encoders);

GpStatus WINGDIPAPI
GdipComment(GpGraphics* graphics, UINT sizeData, GDIPCONST BYTE * data);

//----------------------------------------------------------------------------
// FontFamily APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **FontFamily);

GpStatus WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *FontFamily);

GpStatus WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *FontFamily, GpFontFamily **clonedFontFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily);


GpStatus WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily  *family,
    WCHAR                name[LF_FACESIZE],
    LANGID               language
);

GpStatus   WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, 
                     BOOL * IsStyleAvailable);

GpStatus WINGDIPAPI
GdipFontCollectionEnumerable(
    GpFontCollection* fontCollection,
    GpGraphics* graphics,
    INT *       numFound
);

GpStatus WINGDIPAPI GdipFontCollectionEnumerate(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound,
    GpGraphics*     graphics
);

GpStatus WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, 
                UINT16 * EmHeight);

GpStatus WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style,
                  UINT16 * CellAscent);

GpStatus WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, 
                   UINT16 * CellDescent);

GpStatus WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, 
                   UINT16 * LineSpacing);


//----------------------------------------------------------------------------
// Font APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC        hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC        hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily  *fontFamily,
    REAL                 emSize,
    INT                  style,
    Unit                 unit,
    GpFont             **font
);

GpStatus WINGDIPAPI
GdipCloneFont(GpFont* font, GpFont** cloneFont);

GpStatus WINGDIPAPI
GdipDeleteFont(GpFont* font);

GpStatus WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family);

GpStatus WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style);

GpStatus WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size);

GpStatus WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit);

GpStatus WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, 
                  REAL *height);

GpStatus WINGDIPAPI
GdipGetFontHeightGivenDPI(GDIPCONST GpFont *font, REAL dpi, REAL *height);

GpStatus WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA);

GpStatus WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW);

GpStatus WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection* fontCollection,
    INT *       numFound
);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
);

GpStatus WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
);

//----------------------------------------------------------------------------
// Text APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
);

GpStatus WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,
    INT                      *linesFilled
);

GpStatus
WINGDIPAPI
GdipMeasureCharacterRanges(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       regionCount,
    GpRegion                **regions
);

GpStatus WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix
);

GpStatus WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix,
    RectF *boundingBox
);

//----------------------------------------------------------------------------
// String format APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format);

GpStatus WINGDIPAPI
GdipCloneStringFormat(GDIPCONST GpStringFormat *format, 
                      GpStringFormat **newFormat);

GpStatus WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags);

GpStatus WINGDIPAPI GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, 
                                             INT *flags);

GpStatus WINGDIPAPI
GdipSetStringFormatAlign(GpStringFormat *format, StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatAlign(GDIPCONST GpStringFormat *format, 
                         StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatLineAlign(GpStringFormat *format,
                             StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatLineAlign(GDIPCONST GpStringFormat *format,
                             StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
);

GpStatus WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
);

GpStatus WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(GpStringFormat *format, INT hotkeyPrefix);

GpStatus WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(GDIPCONST GpStringFormat *format, 
                                INT *hotkeyPrefix);

GpStatus WINGDIPAPI
GdipSetStringFormatTabStops(GpStringFormat *format, REAL firstTabOffset, 
                            INT count, GDIPCONST REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStops(GDIPCONST GpStringFormat *format, INT count, 
                            REAL *firstTabOffset, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStopCount(GDIPCONST GpStringFormat *format, INT * count);

GpStatus WINGDIPAPI
GdipSetStringFormatDigitSubstitution(GpStringFormat *format, LANGID language,
                                     StringDigitSubstitute substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatDigitSubstitution(GDIPCONST GpStringFormat *format, 
                                     LANGID *language,
                                     StringDigitSubstitute *substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatMeasurableCharacterRangeCount(
    GDIPCONST GpStringFormat    *format,
    INT                         *count
);

GpStatus WINGDIPAPI
GdipSetStringFormatMeasurableCharacterRanges(
    GpStringFormat              *format,
    INT                         rangeCount,
    GDIPCONST CharacterRange    *ranges
);

//----------------------------------------------------------------------------
// Cached Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **cachedBitmap
);

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap);

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *graphics,
    GpCachedBitmap *cachedBitmap,
    INT x,
    INT y
);

UINT WINGDIPAPI
GdipEmfToWmfBits(
    HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags
);

GpStatus WINGDIPAPI
GdipSetImageAttributesCachedBackground(
    GpImageAttributes *imageattr,
    BOOL enableFlag
);

GpStatus WINGDIPAPI
GdipTestControl(
    GpTestControlEnum control,
    void * param
);

GpStatus WINAPI
GdiplusNotificationHook(
    OUT ULONG_PTR *token
);

VOID WINAPI
GdiplusNotificationUnhook(
    ULONG_PTR token
);

#ifdef __cplusplus
}
#endif

#endif // !_FLATAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusgpstubs.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGpStubs.h
*
* Abstract:
*
*   Private GDI+ header file.
*
\**************************************************************************/

#ifndef _GDIPLUSGPSTUBS_H
#define _GDIPLUSGPSTUBS_H

//---------------------------------------------------------------------------
// GDI+ classes for forward reference
//---------------------------------------------------------------------------

class Graphics;
class Pen;
class Brush;
class Matrix;
class Bitmap;
class Metafile;
class GraphicsPath;
class PathIterator;
class Region;
class Image;
class TextureBrush;
class HatchBrush;
class SolidBrush;
class LinearGradientBrush;
class PathGradientBrush;
class Font;
class FontFamily;
class FontCollection;
class InstalledFontCollection;
class PrivateFontCollection;
class ImageAttributes;
class CachedBitmap;

//---------------------------------------------------------------------------
// Private GDI+ classes for internal type checking
//---------------------------------------------------------------------------
class GpGraphics {};

class GpBrush {};
class GpTexture : public GpBrush {};
class GpSolidFill : public GpBrush {};
class GpLineGradient : public GpBrush {};
class GpPathGradient : public GpBrush {};
class GpHatch : public GpBrush {};

class GpPen {};
class GpCustomLineCap {};
class GpAdjustableArrowCap : public GpCustomLineCap {};

class GpImage {};
class GpBitmap : public GpImage {};
class GpMetafile : public GpImage {};
class GpImageAttributes {};

class GpPath {};
class GpRegion {};
class GpPathIterator {};

class GpFontFamily {};
class GpFont {};
class GpStringFormat {};
class GpFontCollection {};
class GpInstalledFontCollection : public GpFontCollection {};
class GpPrivateFontCollection : public GpFontCollection {};

class GpCachedBitmap;

typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef WrapMode GpWrapMode;
typedef Unit GpUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef PointF GpPointF;
typedef Point GpPoint;
typedef RectF GpRectF;
typedef Rect GpRect;
typedef SizeF GpSizeF;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;
typedef DashCap GpDashCap;


typedef PenAlignment GpPenAlignment;

typedef LineJoin GpLineJoin;
typedef PenType GpPenType;

typedef Matrix GpMatrix;
typedef BrushType GpBrushType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;
typedef PathData GpPathData;

#endif  // !_GDIPLUSGPSTUBS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusimageattributes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Image Attributes
*
* Abstract:
*
*   GDI+ Image Attributes used with Graphics.DrawImage
*
* There are 5 possible sets of color adjustments:
*          ColorAdjustDefault,
*          ColorAdjustBitmap,
*          ColorAdjustBrush,
*          ColorAdjustPen,
*          ColorAdjustText,
*
* Bitmaps, Brushes, Pens, and Text will all use any color adjustments
* that have been set into the default ImageAttributes until their own
* color adjustments have been set.  So as soon as any "Set" method is
* called for Bitmaps, Brushes, Pens, or Text, then they start from
* scratch with only the color adjustments that have been set for them.
* Calling Reset removes any individual color adjustments for a type
* and makes it revert back to using all the default color adjustments
* (if any).  The SetToIdentity method is a way to force a type to
* have no color adjustments at all, regardless of what previous adjustments
* have been set for the defaults or for that type.
*
\********************************************************************F******/

#ifndef _GDIPLUSIMAGEATTRIBUTES_H
#define _GDIPLUSIMAGEATTRIBUTES_H

class GpImageAttributes;

class ImageAttributes : public GdiplusBase
{
    friend class Graphics;
    friend class TextureBrush;

public:

    ImageAttributes()
    {
        nativeImageAttr = NULL;
        lastResult = DllExports::GdipCreateImageAttributes(&nativeImageAttr);
    }

    ~ImageAttributes()
    {
        DllExports::GdipDisposeImageAttributes(nativeImageAttr);
    }

    ImageAttributes* Clone() const
    {
        GpImageAttributes* clone;

        SetStatus(DllExports::GdipCloneImageAttributes(
                                            nativeImageAttr,
                                            &clone));

        return new ImageAttributes(clone, lastResult);
    }

    Status
    SetToIdentity(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesToIdentity(
                                            nativeImageAttr,
                                            type));
    }

    Status
    Reset(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipResetImageAttributes(
                                            nativeImageAttr,
                                            type));
    }

    Status
    SetColorMatrix(
        IN const ColorMatrix *colorMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            NULL,
                                            mode));
    }

    Status ClearColorMatrix(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status
    SetColorMatrices(
        IN const ColorMatrix *colorMatrix,
        IN const ColorMatrix *grayMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            grayMatrix,
                                            mode));
    }

    Status ClearColorMatrices(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status SetThreshold(
        IN REAL threshold,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            threshold));
    }

    Status ClearThreshold(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetGamma(
        IN REAL gamma,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            gamma));
    }

    Status ClearGamma(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            TRUE));
    }

    Status ClearNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            FALSE));
    }

    Status SetColorKey(
        IN const Color& colorLow, 
        IN const Color& colorHigh,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorLow.GetValue(),
                                            colorHigh.GetValue()));
    }

    Status ClearColorKey(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL));
    }

    Status SetOutputChannel(
        IN ColorChannelFlags channelFlags,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            channelFlags));
    }
    
    Status ClearOutputChannel(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            ColorChannelFlagsLast));
    }

    Status SetOutputChannelColorProfile(
        IN const WCHAR *colorProfileFilename,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorProfileFilename));
    }
    
    Status ClearOutputChannelColorProfile(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL));
    }
    
    Status SetRemapTable(
        IN UINT mapSize, 
        IN const ColorMap *map,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            mapSize,
                                            map));
    }

    Status ClearRemapTable(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0,
                                            NULL));
    }

    Status SetBrushRemapTable(IN UINT mapSize, 
                              IN const ColorMap *map)
    {
        return this->SetRemapTable(mapSize, map, ColorAdjustTypeBrush);
    }

    Status ClearBrushRemapTable()
    {
        return this->ClearRemapTable(ColorAdjustTypeBrush);
    }

    Status SetWrapMode(IN WrapMode wrap, 
                       IN const Color& color = Color(), 
                       IN BOOL clamp = FALSE) 
    {
        ARGB argb = color.GetValue();

        return SetStatus(DllExports::GdipSetImageAttributesWrapMode(
                           nativeImageAttr, wrap, argb, clamp));
    }

    // The flags of the palette are ignored.

    Status GetAdjustedPalette(IN OUT ColorPalette* colorPalette,
                              IN ColorAdjustType colorAdjustType) const 
    {
        return SetStatus(DllExports::GdipGetImageAttributesAdjustedPalette(
                           nativeImageAttr, colorPalette, colorAdjustType));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
    
        return lastStatus;
    }
    
private:
    ImageAttributes(const ImageAttributes &);
    ImageAttributes& operator=(const ImageAttributes &);

protected:
    ImageAttributes(GpImageAttributes* imageAttr, Status status)
    {
        SetNativeImageAttr(imageAttr);
        lastResult = status;
    }

    VOID SetNativeImageAttr(GpImageAttributes* nativeImageAttr)
    {
        this->nativeImageAttr = nativeImageAttr;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpImageAttributes* nativeImageAttr;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusheaders.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusHeaders.h
*
* Abstract:
*
*   GDI+ Region, Font, Image, CustomLineCap class definitions.
*
*
* Class definition and inline class implementation are separated into
* different files to avoid circular dependencies.
*
\**************************************************************************/

#ifndef _GDIPLUSHEADERS_H
#define _GDIPLUSHEADERS_H

class Region : public GdiplusBase
{
public:
    friend class Graphics;

    Region();
    Region(IN const RectF& rect);
    Region(IN const Rect& rect);
    Region(IN const GraphicsPath* path);
    Region(IN const BYTE* regionData, IN INT size);
    Region(IN HRGN hRgn);
    static Region* FromHRGN(IN HRGN hRgn);

    ~Region();
    Region* Clone() const;

    Status MakeInfinite();
    Status MakeEmpty();

    UINT GetDataSize() const;

    // buffer     - where to put the data
    // bufferSize - how big the buffer is (should be at least as big as GetDataSize())
    // sizeFilled - if not NULL, this is an OUT param that says how many bytes
    //              of data were written to the buffer.

    Status GetData(OUT BYTE* buffer,
                   IN UINT bufferSize,
                   OUT UINT* sizeFilled = NULL) const;

    Status Intersect(IN const Rect& rect);
    Status Intersect(IN const RectF& rect);
    Status Intersect(IN const GraphicsPath* path);
    Status Intersect(IN const Region* region);
    Status Union(IN const Rect& rect);
    Status Union(IN const RectF& rect);
    Status Union(IN const GraphicsPath* path);
    Status Union(IN const Region* region);
    Status Xor(IN const Rect& rect);
    Status Xor(IN const RectF& rect);
    Status Xor(IN const GraphicsPath* path);
    Status Xor(IN const Region* region);
    Status Exclude(IN const Rect& rect);
    Status Exclude(IN const RectF& rect);
    Status Exclude(IN const GraphicsPath* path);
    Status Exclude(IN const Region* region);
    Status Complement(IN const Rect& rect);
    Status Complement(IN const RectF& rect);
    Status Complement(IN const GraphicsPath* path);
    Status Complement(IN const Region* region);
    Status Translate(IN REAL dx,
                     IN REAL dy);
    Status Translate(IN INT dx,
                     IN INT dy);
    Status Transform(IN const Matrix* matrix);

    Status GetBounds(OUT Rect* rect,
                     IN const Graphics* g) const;

    Status GetBounds(OUT RectF* rect,
                     IN const Graphics* g) const;

    HRGN   GetHRGN  (IN const Graphics * g) const;

    BOOL IsEmpty(IN const Graphics *g) const;
    BOOL IsInfinite(IN const Graphics *g) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(Point(x, y), g);
    }

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(PointF(x, y), g);
    }

    BOOL IsVisible(IN const PointF& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN const Graphics* g) const
    {
        return IsVisible(Rect(x, y, width, height), g);
    }

    BOOL IsVisible(IN const Rect& rect,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(RectF(x, y, width, height), g);
    }

    BOOL IsVisible(IN const RectF& rect,
                   IN const Graphics* g = NULL) const;

    BOOL Equals(IN const Region* region,
                IN const Graphics* g) const;

    UINT GetRegionScansCount(IN const Matrix* matrix) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT RectF* rects,
                          OUT INT* count) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT Rect*  rects,
                          OUT INT* count) const;
    Status GetLastStatus() const;

protected:

private:
    Region(const Region &region);
    Region& operator=(const Region &region);
protected:

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    Region(GpRegion* nativeRegion);

    VOID SetNativeRegion(GpRegion* nativeRegion);

protected:
    GpRegion* nativeRegion;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// FontFamily
//--------------------------------------------------------------------------

class FontFamily : public GdiplusBase
{
public:
    friend class Font;
    friend class Graphics;
    friend class GraphicsPath;
    friend class FontCollection;

    FontFamily();

    FontFamily(
        IN const WCHAR          *name,
        IN const FontCollection *fontCollection = NULL
    );

    ~FontFamily();

    static const FontFamily *GenericSansSerif();
    static const FontFamily *GenericSerif();
    static const FontFamily *GenericMonospace();

    Status GetFamilyName(
        OUT WCHAR        name[LF_FACESIZE],
        IN LANGID        language = 0
    ) const;

    FontFamily * Clone() const;

    BOOL    IsAvailable() const
    {
        return (nativeFamily != NULL);
    };

    BOOL    IsStyleAvailable(IN INT style) const;

    UINT16  GetEmHeight     (IN INT style) const;
    UINT16  GetCellAscent   (IN INT style) const;
    UINT16  GetCellDescent  (IN INT style) const;
    UINT16  GetLineSpacing  (IN INT style) const;
    
    Status GetLastStatus() const;

private:
    FontFamily(const FontFamily &);
    FontFamily& operator=(const FontFamily &);

protected:
    Status SetStatus(Status status) const;

    FontFamily(GpFontFamily * nativeFamily, Status status);

protected:

    GpFontFamily    *nativeFamily;
    mutable Status   lastResult;
};

static FontFamily *GenericSansSerifFontFamily = NULL;
static FontFamily *GenericSerifFontFamily     = NULL;
static FontFamily *GenericMonospaceFontFamily = NULL;

static BYTE GenericSansSerifFontFamilyBuffer[sizeof(FontFamily)] = {0};
static BYTE GenericSerifFontFamilyBuffer    [sizeof(FontFamily)] = {0};
static BYTE GenericMonospaceFontFamilyBuffer[sizeof(FontFamily)] = {0};


//--------------------------------------------------------------------------
// Font
//--------------------------------------------------------------------------

class Font : public GdiplusBase
{
public:
    friend class Graphics;

    Font(IN HDC hdc);
    Font(IN HDC hdc,
         IN const LOGFONTA* logfont);
    Font(IN HDC hdc,
         IN const LOGFONTW* logfont);
    Font(IN HDC hdc,
         IN const HFONT hfont);
    Font(
        IN const FontFamily * family,
        IN REAL         emSize,
        IN INT          style   = FontStyleRegular,
        IN Unit         unit    = UnitPoint
    );

    Font(
        IN const WCHAR *           familyName,
        IN REAL                    emSize,
        IN INT                     style   = FontStyleRegular,
        IN Unit                    unit    = UnitPoint,
        IN const FontCollection *  fontCollection = NULL
    );

    Status GetLogFontA(IN const Graphics* g,
                       OUT  LOGFONTA * logfontA) const;
    Status GetLogFontW(IN const Graphics* g,
                       OUT LOGFONTW * logfontW) const;

    Font* Clone() const;
    ~Font();
    BOOL        IsAvailable()   const;
    INT         GetStyle()      const;
    REAL        GetSize()       const;
    Unit        GetUnit()       const;
    Status      GetLastStatus() const;
    REAL        GetHeight(IN const Graphics *graphics) const;
    REAL        GetHeight(IN REAL dpi) const;

    Status GetFamily(OUT FontFamily *family) const;

private:
    Font(const Font &);
    Font& operator=(const Font &);

protected:
    Font(GpFont* font, Status status);
    VOID SetNativeFont(GpFont *Font);
    Status SetStatus(Status status) const;

protected:

    GpFont* nativeFont;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Font Collection
//--------------------------------------------------------------------------

class FontCollection : public GdiplusBase
{
public:
    friend class FontFamily;

    FontCollection();
    virtual ~FontCollection();

    INT GetFamilyCount() const;

    Status GetFamilies(
        IN INT           numSought,
        OUT FontFamily * gpfamilies,
        OUT INT        * numFound
    ) const;

    Status GetLastStatus() const;

private:
    FontCollection(const FontCollection &);
    FontCollection& operator=(const FontCollection &);

protected:
    Status SetStatus(Status status) const ;

    GpFontCollection *nativeFontCollection;
    mutable Status    lastResult;
};


class InstalledFontCollection : public FontCollection
{
public:
    InstalledFontCollection();
    ~InstalledFontCollection();

private:
    InstalledFontCollection(const InstalledFontCollection &);
    InstalledFontCollection& operator=(const InstalledFontCollection &);

protected:
    Status SetStatus(Status status) const ;
};


class PrivateFontCollection : public FontCollection
{
public:
    PrivateFontCollection();
    ~PrivateFontCollection();

    Status AddFontFile(IN const WCHAR* filename);
    Status AddMemoryFont(IN const VOID* memory,
                         IN INT length);

private:
    PrivateFontCollection(const PrivateFontCollection &);
    PrivateFontCollection& operator=(const PrivateFontCollection &);
};


//--------------------------------------------------------------------------
// Abstract base class for Image and Metafile
//--------------------------------------------------------------------------

class Image : public GdiplusBase
{
public:
    friend class Brush;
    friend class TextureBrush;
    friend class Graphics;

    Image(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Image(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Image* FromFile(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Image* FromStream(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    virtual ~Image();
    virtual Image* Clone();

    Status Save(IN const WCHAR* filename,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status Save(IN IStream* stream,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status SaveAdd(IN const EncoderParameters* encoderParams);
    Status SaveAdd(IN Image* newImage,
                   IN const EncoderParameters* encoderParams);

    ImageType GetType() const;
    Status GetPhysicalDimension(OUT SizeF* size);
    Status GetBounds(OUT RectF* srcRect,
                     OUT Unit* srcUnit);

    UINT GetWidth();
    UINT GetHeight();
    REAL GetHorizontalResolution();
    REAL GetVerticalResolution();
    UINT GetFlags();
    Status GetRawFormat(OUT GUID *format);
    PixelFormat GetPixelFormat();

    INT GetPaletteSize();
    Status GetPalette(OUT ColorPalette* palette,
                      IN INT size);
    Status SetPalette(IN const ColorPalette* palette);

    Image* GetThumbnailImage(IN UINT thumbWidth,
                             IN UINT thumbHeight,
                             IN GetThumbnailImageAbort callback = NULL,
                             IN VOID* callbackData = NULL);
    UINT GetFrameDimensionsCount();
    Status GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                  IN UINT count);
    UINT GetFrameCount(IN const GUID* dimensionID);
    Status SelectActiveFrame(IN const GUID* dimensionID,
                             IN UINT frameIndex);
    Status RotateFlip(IN RotateFlipType rotateFlipType);
    UINT GetPropertyCount();
    Status GetPropertyIdList(IN UINT numOfProperty,
                             OUT PROPID* list);
    UINT GetPropertyItemSize(IN PROPID propId);
    Status GetPropertyItem(IN PROPID propId,
                           IN UINT propSize,
                           OUT PropertyItem* buffer);
    Status GetPropertySize(OUT UINT* totalBufferSize,
                           OUT UINT* numProperties);
    Status GetAllPropertyItems(IN UINT totalBufferSize,
                               IN UINT numProperties,
                               OUT PropertyItem* allItems);
    Status RemovePropertyItem(IN PROPID propId);
    Status SetPropertyItem(IN const PropertyItem* item);

    UINT  GetEncoderParameterListSize(IN const CLSID* clsidEncoder);
    Status GetEncoderParameterList(IN const CLSID* clsidEncoder,
                                   IN UINT size,
                                   OUT EncoderParameters* buffer);

    Status GetLastStatus() const;

protected:

    Image() {}

    Image(GpImage *nativeImage, Status status);

    VOID SetNativeImage(GpImage* nativeImage);

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpImage* nativeImage;
    mutable Status lastResult;
    mutable Status loadStatus;

private:
    Image(IN const Image& C);
    Image& operator=(IN const Image& C);
};

class Bitmap : public Image
{
public:
    friend class Image;
    friend class CachedBitmap;

    Bitmap(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Bitmap(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Bitmap* FromFile(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Bitmap* FromStream(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Bitmap(IN INT width,
           IN INT height,
           IN INT stride, PixelFormat format,
           IN BYTE* scan0);
    Bitmap(IN INT width,
           IN INT height,
           IN PixelFormat format = PixelFormat32bppARGB);
    Bitmap(IN INT width,
           IN INT height,
           IN  Graphics* target);

    Bitmap* Clone(IN const Rect& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN INT x,
                  IN INT y,
                  IN INT width,
                  IN INT height,
                  IN PixelFormat format);
    Bitmap* Clone(IN const RectF& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN REAL x,
                  IN REAL y,
                  IN REAL width,
                  IN REAL height,
                  IN PixelFormat format);

    Status LockBits(IN const Rect* rect,
                    IN UINT flags,
                    IN PixelFormat format,
                    OUT BitmapData* lockedBitmapData);
    Status UnlockBits(IN BitmapData* lockedBitmapData);
    Status GetPixel(IN INT x,
                    IN INT y,
                    OUT Color *color);
    Status SetPixel(IN INT x,
                    IN INT y,
                    IN const Color &color);
    Status SetResolution(IN REAL xdpi,
                         IN REAL ydpi);

    Bitmap(IN IDirectDrawSurface7* surface);
    Bitmap(IN const BITMAPINFO* gdiBitmapInfo,
           IN VOID* gdiBitmapData);
    Bitmap(IN HBITMAP hbm,
           IN HPALETTE hpal);
    Bitmap(IN HICON hicon);
    Bitmap(IN HINSTANCE hInstance,
           IN const WCHAR * bitmapName);
    static Bitmap* FromDirectDrawSurface7(IN IDirectDrawSurface7* surface);
    static Bitmap* FromBITMAPINFO(IN const BITMAPINFO* gdiBitmapInfo,
                                  IN VOID* gdiBitmapData);
    static Bitmap* FromHBITMAP(IN HBITMAP hbm,
                               IN HPALETTE hpal);
    static Bitmap* FromHICON(IN HICON hicon);
    static Bitmap* FromResource(IN HINSTANCE hInstance,
                                IN const WCHAR * bitmapName);

    Status GetHBITMAP(IN const Color& colorBackground,
                      OUT HBITMAP *hbmReturn);
    Status GetHICON(HICON *hicon);

private:
    Bitmap(const Bitmap &);
    Bitmap& operator=(const Bitmap &);

protected:
    Bitmap(GpBitmap *nativeBitmap);
};

class CustomLineCap : public GdiplusBase
{
public:
    friend class Pen;

    CustomLineCap(
        IN const GraphicsPath* fillPath,
        IN const GraphicsPath* strokePath,
        IN LineCap baseCap = LineCapFlat,
        IN REAL baseInset = 0
        );
    virtual ~CustomLineCap();

    CustomLineCap* Clone() const;

    // This changes both the start and end cap.

    Status SetStrokeCap(IN LineCap strokeCap)
    {
        return SetStrokeCaps(strokeCap, strokeCap);
    }

    Status SetStrokeCaps(IN LineCap startCap,
                         IN LineCap endCap);
    Status GetStrokeCaps(OUT LineCap* startCap,
                         OUT LineCap* endCap) const;
    Status SetStrokeJoin(IN LineJoin lineJoin);
    LineJoin GetStrokeJoin() const;
    Status SetBaseCap(IN LineCap baseCap);
    LineCap GetBaseCap() const;
    Status SetBaseInset(IN REAL inset);
    REAL GetBaseInset() const;
    Status SetWidthScale(IN REAL widthScale);
    REAL GetWidthScale() const;
    Status GetLastStatus() const;

protected:
    CustomLineCap();

private:
    CustomLineCap(const CustomLineCap &);
    CustomLineCap& operator=(const CustomLineCap &);

protected:
    CustomLineCap(GpCustomLineCap* nativeCap, Status status)
    {
        lastResult = status;
        SetNativeCap(nativeCap);
    }

    VOID SetNativeCap(GpCustomLineCap* nativeCap)
    {
        this->nativeCap = nativeCap;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpCustomLineCap* nativeCap;
    mutable Status lastResult;
};

class CachedBitmap : public GdiplusBase
{
    friend Graphics;

public:
    CachedBitmap(IN Bitmap *bitmap,
                 IN Graphics *graphics);
    virtual ~CachedBitmap();

    Status GetLastStatus() const;

private:
    CachedBitmap(const CachedBitmap &);
    CachedBitmap& operator=(const CachedBitmap &);

protected:
    GpCachedBitmap *nativeCachedBitmap;
    mutable Status lastResult;
};

#endif  // !_GDIPLUSHEADERS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusgraphics.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGraphics.h
*
* Abstract:
*
*   GDI+ Graphics Object
*
\**************************************************************************/

#ifndef _GDIPLUSGRAPHICS_H
#define _GDIPLUSGRAPHICS_H

class Graphics : public GdiplusBase
{
public:
    friend class Region;
    friend class GraphicsPath;
    friend class Image;
    friend class Bitmap;
    friend class Metafile;
    friend class Font;
    friend class FontFamily;
    friend class FontCollection;
    friend class CachedBitmap;

    static Graphics* FromHDC(IN HDC hdc)
    {
        return new Graphics(hdc);
    }

    static Graphics* FromHDC(IN HDC hdc,
                             IN HANDLE hdevice)
    {
        return new Graphics(hdc, hdevice);
    }

    static Graphics* FromHWND(IN HWND hwnd,
                              IN BOOL icm = FALSE)
    {
        return new Graphics(hwnd, icm);
    }

    static Graphics* FromImage(IN Image *image)
    {
        return new Graphics(image);
    }

    Graphics(IN HDC hdc)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC(hdc, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HDC hdc,
             IN HANDLE hdevice)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC2(hdc, hdevice, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HWND hwnd,
             IN BOOL icm = FALSE)
    {
        GpGraphics *graphics = NULL;

        if (icm)
        {
            lastResult = DllExports::GdipCreateFromHWNDICM(hwnd, &graphics);
        }
        else
        {
            lastResult = DllExports::GdipCreateFromHWND(hwnd, &graphics);
        }

        SetNativeGraphics(graphics);
    }

    Graphics(IN Image* image)
    {
        GpGraphics *graphics = NULL;

        if (image != NULL)
        {
            lastResult = DllExports::GdipGetImageGraphicsContext(
                                                                image->nativeImage, &graphics);
        }
        SetNativeGraphics(graphics);
    }

    ~Graphics()
    {
        DllExports::GdipDeleteGraphics(nativeGraphics);
    }

    VOID Flush(IN FlushIntention intention = FlushIntentionFlush)
    {
        DllExports::GdipFlush(nativeGraphics, intention);
    }

    //------------------------------------------------------------------------
    // GDI Interop methods
    //------------------------------------------------------------------------

    // Locks the graphics until ReleaseDC is called

    HDC GetHDC()
    {
        HDC     hdc = NULL;

        SetStatus(DllExports::GdipGetDC(nativeGraphics, &hdc));

        return hdc;
    }

    VOID ReleaseHDC(IN HDC hdc)
    {
        SetStatus(DllExports::GdipReleaseDC(nativeGraphics, hdc));
    }

    //------------------------------------------------------------------------
    // Rendering modes
    //------------------------------------------------------------------------

    Status SetRenderingOrigin(IN INT x, IN INT y)
    {
        return SetStatus(
            DllExports::GdipSetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status GetRenderingOrigin(OUT INT *x, OUT INT *y) const
    {
        return SetStatus(
            DllExports::GdipGetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status SetCompositingMode(IN CompositingMode compositingMode)
    {
        return SetStatus(DllExports::GdipSetCompositingMode(nativeGraphics,
                                                            compositingMode));
    }

    CompositingMode GetCompositingMode() const
    {
        CompositingMode mode;

        SetStatus(DllExports::GdipGetCompositingMode(nativeGraphics,
                                                     &mode));

        return mode;
    }

    Status SetCompositingQuality(IN CompositingQuality compositingQuality)
    {
        return SetStatus(DllExports::GdipSetCompositingQuality(
            nativeGraphics,
            compositingQuality));
    }

    CompositingQuality GetCompositingQuality() const
    {
        CompositingQuality quality;

        SetStatus(DllExports::GdipGetCompositingQuality(
            nativeGraphics,
            &quality));

        return quality;
    }

    Status SetTextRenderingHint(IN TextRenderingHint newMode)
    {
        return SetStatus(DllExports::GdipSetTextRenderingHint(nativeGraphics,
                                                          newMode));
    }

    TextRenderingHint GetTextRenderingHint() const
    {
        TextRenderingHint hint;

        SetStatus(DllExports::GdipGetTextRenderingHint(nativeGraphics,
                                                   &hint));

        return hint;
    }

    Status SetTextContrast(IN UINT contrast)
    {
        return SetStatus(DllExports::GdipSetTextContrast(nativeGraphics,
                                                          contrast));
    }

    UINT GetTextContrast() const
    {
        UINT contrast;

        SetStatus(DllExports::GdipGetTextContrast(nativeGraphics,
                                                    &contrast));

        return contrast;
    }

    InterpolationMode GetInterpolationMode() const
    {
        InterpolationMode mode = InterpolationModeInvalid;

        SetStatus(DllExports::GdipGetInterpolationMode(nativeGraphics,
                                                           &mode));

        return mode;
    }

    Status SetInterpolationMode(IN InterpolationMode interpolationMode)
    {
        return SetStatus(DllExports::GdipSetInterpolationMode(nativeGraphics,
                                                           interpolationMode));
    }

    SmoothingMode GetSmoothingMode() const
    {
        SmoothingMode smoothingMode = SmoothingModeInvalid;

        SetStatus(DllExports::GdipGetSmoothingMode(nativeGraphics,
                                                   &smoothingMode));

        return smoothingMode;
    }

    Status SetSmoothingMode(IN SmoothingMode smoothingMode)
    {
        return SetStatus(DllExports::GdipSetSmoothingMode(nativeGraphics,
                                                          smoothingMode));
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        PixelOffsetMode pixelOffsetMode = PixelOffsetModeInvalid;

        SetStatus(DllExports::GdipGetPixelOffsetMode(nativeGraphics,
                                                     &pixelOffsetMode));

        return pixelOffsetMode;
    }

    Status SetPixelOffsetMode(IN PixelOffsetMode pixelOffsetMode)
    {
        return SetStatus(DllExports::GdipSetPixelOffsetMode(nativeGraphics,
                                                            pixelOffsetMode));
    }

    //------------------------------------------------------------------------
    // Manipulate current world transform
    //------------------------------------------------------------------------

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetWorldTransform(nativeGraphics,
                                                        matrix->nativeMatrix));
    }
    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetWorldTransform(nativeGraphics));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyWorldTransform(nativeGraphics,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateWorldTransform(nativeGraphics,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx,
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleWorldTransform(nativeGraphics,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle,
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateWorldTransform(nativeGraphics,
                                                              angle, order));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetWorldTransform(nativeGraphics,
                                                           matrix->nativeMatrix));
    }

    Status SetPageUnit(IN Unit unit)
    {
        return SetStatus(DllExports::GdipSetPageUnit(nativeGraphics,
                                                     unit));
    }

    Status SetPageScale(IN REAL scale)
    {
        return SetStatus(DllExports::GdipSetPageScale(nativeGraphics,
                                                      scale));
    }

    Unit GetPageUnit() const
    {
        Unit unit;

        SetStatus(DllExports::GdipGetPageUnit(nativeGraphics, &unit));

        return unit;
    }

    REAL GetPageScale() const
    {
        REAL scale;

        SetStatus(DllExports::GdipGetPageScale(nativeGraphics, &scale));

        return scale;
    }

    REAL GetDpiX() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiX(nativeGraphics, &dpi));

        return dpi;
    }

    REAL GetDpiY() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiY(nativeGraphics, &dpi));

        return dpi;
    }

    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT PointF* pts,
                           IN INT count) const
    {
        return SetStatus(DllExports::GdipTransformPoints(nativeGraphics,
                                                         destSpace,
                                                         srcSpace,
                                                         pts,
                                                         count));
    }

    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT Point* pts,
                           IN INT count) const
    {

        return SetStatus(DllExports::GdipTransformPointsI(nativeGraphics,
                                                          destSpace,
                                                          srcSpace,
                                                          pts,
                                                          count));
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces).  Note: Alpha is ignored.
    //------------------------------------------------------------------------
    
    Status GetNearestColor(IN OUT Color* color) const
    {
        if (color == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        ARGB argb = color->GetValue();

        Status status = SetStatus(DllExports::GdipGetNearestColor(nativeGraphics, &argb));

        color->SetValue(argb);

        return status;
    }

    Status DrawLine(IN const Pen* pen,
                    IN REAL x1,
                    IN REAL y1,
                    IN REAL x2,
                    IN REAL y2)
    {
        return SetStatus(DllExports::GdipDrawLine(nativeGraphics,
                                                  pen->nativePen, x1, y1, x2,
                                                  y2));
    }

    Status DrawLine(IN const Pen* pen,
                    IN const PointF& pt1,
                    IN const PointF& pt2)
    {
        return DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status DrawLines(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLines(nativeGraphics,
                                                   pen->nativePen,
                                                   points, count));
    }

    Status DrawLine(IN const Pen* pen,
                    IN INT x1,
                    IN INT y1,
                    IN INT x2,
                    IN INT y2)
    {
        return SetStatus(DllExports::GdipDrawLineI(nativeGraphics,
                                                   pen->nativePen,
                                                   x1,
                                                   y1,
                                                   x2,
                                                   y2));
    }

    Status DrawLine(IN const Pen* pen,
                    IN const Point& pt1,
                    IN const Point& pt2)
    {
        return DrawLine(pen,
                        pt1.X,
                        pt1.Y,
                        pt2.X,
                        pt2.Y);
    }

    Status DrawLines(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLinesI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawArc(IN const Pen* pen,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArc(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawArc(IN const Pen* pen,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status DrawArc(IN const Pen* pen,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArcI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }


    Status DrawArc(IN const Pen* pen,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawArc(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawBezier(IN const Pen* pen,
                      IN REAL x1,
                      IN REAL y1,
                      IN REAL x2,
                      IN REAL y2,
                      IN REAL x3,
                      IN REAL y3,
                      IN REAL x4,
                      IN REAL y4)
    {
        return SetStatus(DllExports::GdipDrawBezier(nativeGraphics,
                                                    pen->nativePen, x1, y1,
                                                    x2, y2, x3, y3, x4, y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const PointF& pt1,
                      IN const PointF& pt2,
                      IN const PointF& pt3,
                      IN const PointF& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const PointF* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziers(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN INT x1,
                      IN INT y1,
                      IN INT x2,
                      IN INT y2,
                      IN INT x3,
                      IN INT y3,
                      IN INT x4,
                      IN INT y4)
    {
        return SetStatus(DllExports::GdipDrawBezierI(nativeGraphics,
                                                     pen->nativePen,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2,
                                                     x3,
                                                     y3,
                                                     x4,
                                                     y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const Point& pt1,
                      IN const Point& pt2,
                      IN const Point& pt3,
                      IN const Point& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const Point* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziersI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN const RectF& rect)
    {
        return DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN REAL x,
                         IN REAL y,
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawRectangle(nativeGraphics,
                                                       pen->nativePen, x, y,
                                                       width, height));
    }

    Status DrawRectangles(IN const Pen* pen,
                          IN const RectF* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectangles(nativeGraphics,
                                                        pen->nativePen,
                                                        rects, count));
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN const Rect& rect)
    {
        return DrawRectangle(pen,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN INT x,
                         IN INT y,
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipDrawRectangleI(nativeGraphics,
                                                        pen->nativePen,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status DrawRectangles(IN const Pen* pen,
                          IN const Rect* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectanglesI(nativeGraphics,
                                                         pen->nativePen,
                                                         rects,
                                                         count));
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN const RectF& rect)
    {
        return DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN REAL x,
                       IN REAL y,
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawEllipse(nativeGraphics,
                                                     pen->nativePen,
                                                     x,
                                                     y,
                                                     width,
                                                     height));
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN const Rect& rect)
    {
        return DrawEllipse(pen,
                           rect.X,
                           rect.Y,
                           rect.Width,
                           rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN INT x,
                       IN INT y,
                       IN INT width,
                       IN INT height)
    {
        return SetStatus(DllExports::GdipDrawEllipseI(nativeGraphics,
                                                      pen->nativePen,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    Status DrawPie(IN const Pen* pen,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPie(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawPie(IN const Pen* pen,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPieI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status DrawPolygon(IN const Pen* pen,
                       IN const PointF* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygon(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    Status DrawPolygon(IN const Pen* pen,
                       IN const Point* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygonI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    Status DrawPath(IN const Pen* pen,
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipDrawPath(nativeGraphics,
                                                  pen ? pen->nativePen : NULL,
                                                  path ? path->nativePath : NULL));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurve(nativeGraphics,
                                                   pen->nativePen, points,
                                                   count));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count,
                     IN INT offset,
                     IN INT numberOfSegments,
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, offset,
                                                    numberOfSegments, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurveI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count,
                     IN INT offset,
                     IN INT numberOfSegments,
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     offset,
                                                     numberOfSegments,
                                                     tension));
    }

    Status DrawClosedCurve(IN const Pen* pen,
                           IN const PointF* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve(nativeGraphics,
                                                         pen->nativePen,
                                                         points, count));
    }

    Status DrawClosedCurve(IN const Pen *pen,
                           IN const PointF* points,
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2(nativeGraphics,
                                                          pen->nativePen,
                                                          points, count,
                                                          tension));
    }

    Status DrawClosedCurve(IN const Pen* pen,
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurveI(nativeGraphics,
                                                          pen->nativePen,
                                                          points,
                                                          count));
    }

    Status DrawClosedCurve(IN const Pen *pen,
                           IN const Point* points,
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2I(nativeGraphics,
                                                           pen->nativePen,
                                                           points,
                                                           count,
                                                           tension));
    }

    Status Clear(IN const Color &color)
    {
        return SetStatus(DllExports::GdipGraphicsClear(
            nativeGraphics,
            color.GetValue()));
    }

    Status FillRectangle(IN const Brush* brush,
                         IN const RectF& rect)
    {
        return FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillRectangle(IN const Brush* brush,
                         IN REAL x,
                         IN REAL y,
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipFillRectangle(nativeGraphics,
                                                       brush->nativeBrush, x, y,
                                                       width, height));
    }

    Status FillRectangles(IN const Brush* brush,
                          IN const RectF* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectangles(nativeGraphics,
                                                        brush->nativeBrush,
                                                        rects, count));
    }

    Status FillRectangle(IN const Brush* brush,
                         IN const Rect& rect)
    {
        return FillRectangle(brush,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status FillRectangle(IN const Brush* brush,
                         IN INT x,
                         IN INT y,
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipFillRectangleI(nativeGraphics,
                                                        brush->nativeBrush,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status FillRectangles(IN const Brush* brush,
                          IN const Rect* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectanglesI(nativeGraphics,
                                                         brush->nativeBrush,
                                                         rects,
                                                         count));
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const PointF* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const PointF* points,
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygon(nativeGraphics,
                                                     brush->nativeBrush,
                                                     points, count, fillMode));
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const Point* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const Point* points,
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygonI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      points, count,
                                                      fillMode));
    }

    Status FillEllipse(IN const Brush* brush,
                       IN const RectF& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush,
                       IN REAL x,
                       IN REAL y,
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipFillEllipse(nativeGraphics,
                                                     brush->nativeBrush, x, y,
                                                     width, height));
    }

    Status FillEllipse(IN const Brush* brush,
                       IN const Rect& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush,
                       IN INT x,
                       IN INT y,
                       IN INT width,
                       IN INT height)
    {
        return SetStatus(DllExports::GdipFillEllipseI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    Status FillPie(IN const Brush* brush,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPie(nativeGraphics,
                                                 brush->nativeBrush, x, y,
                                                 width, height, startAngle,
                                                 sweepAngle));
    }

    Status FillPie(IN const Brush* brush,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPieI(nativeGraphics,
                                                  brush->nativeBrush,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status FillPath(IN const Brush* brush,
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipFillPath(nativeGraphics,
                                                  brush->nativeBrush,
                                                  path->nativePath));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const PointF* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurve(nativeGraphics,
                                                         brush->nativeBrush,
                                                         points, count));

    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const PointF* points,
                           IN INT count,
                           IN FillMode fillMode,
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points, count,
                                                          tension, fillMode));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurveI(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points,
                                                          count));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const Point* points,
                           IN INT count,
                           IN FillMode fillMode,
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2I(nativeGraphics,
                                                           brush->nativeBrush,
                                                           points, count,
                                                           tension, fillMode));
    }

    Status FillRegion(IN const Brush* brush,
                      IN const Region* region)
    {
        return SetStatus(DllExports::GdipFillRegion(nativeGraphics,
                                                    brush->nativeBrush,
                                                    region->nativeRegion));
    }

    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
    )
    {
        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const StringFormat *stringFormat,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            codepointsFitted,
            linesFilled
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const SizeF        &layoutRectSize,
        IN const StringFormat *stringFormat,
        OUT SizeF             *size,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        RectF   layoutRect(0, 0, layoutRectSize.Width, layoutRectSize.Height);
        RectF   boundingBox;
        Status  status;

        if (size == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        status = SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            size ? &boundingBox : NULL,
            codepointsFitted,
            linesFilled
        ));

        if (size && status == Ok)
        {
            size->Width  = boundingBox.Width;
            size->Height = boundingBox.Height;
        }

        return status;
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const PointF       &origin,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const RectF  &layoutRect,
        OUT RectF       *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const PointF &origin,
        OUT RectF       *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }


    Status
    MeasureCharacterRanges(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN INT                 regionCount,
        OUT Region            *regions
    ) const
    {
        if (!regions || regionCount <= 0)
        {
            return InvalidParameter;
        }

        GpRegion **nativeRegions = new GpRegion* [regionCount];

        if (!nativeRegions)
        {
            return OutOfMemory;
        }

        for (INT i = 0; i < regionCount; i++)
        {
            nativeRegions[i] = regions[i].nativeRegion;
        }

        Status status = SetStatus(DllExports::GdipMeasureCharacterRanges(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            regionCount,
            nativeRegions
        ));

        delete [] nativeRegions;

        return status;
    }

    Status DrawDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const Brush   *brush,
        IN const PointF  *positions,
        IN INT            flags,
        IN const Matrix        *matrix
    )
    {
        return SetStatus(DllExports::GdipDrawDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            brush ? brush->nativeBrush : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL
        ));
    }

    Status MeasureDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN const Matrix        *matrix,
        OUT RectF        *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            boundingBox
        ));
    }

    // Draw a cached bitmap on this graphics destination offset by
    // x, y. Note this will fail with WrongState if the CachedBitmap
    // native format differs from this Graphics.

    Status DrawCachedBitmap(IN CachedBitmap *cb,
                            IN INT x,
                            IN INT y)
    {
        return SetStatus(DllExports::GdipDrawCachedBitmap(
            nativeGraphics,
            cb->nativeCachedBitmap,
            x, y
        ));
    }

    Status DrawImage(IN Image* image,
                     IN const PointF& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y)
    {
        return SetStatus(DllExports::GdipDrawImage(nativeGraphics,
                                                   image ? image->nativeImage
                                                         : NULL,
                                                   x,
                                                   y));
    }

    Status DrawImage(IN Image* image, 
                     IN const RectF& rect)
    {
        return DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y,
                     IN REAL width,
                     IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawImageRect(nativeGraphics,
                                                       image ? image->nativeImage
                                                             : NULL,
                                                       x,
                                                       y,
                                                       width,
                                                       height));
    }

    Status DrawImage(IN Image* image,
                     IN const Point& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y)
    {
        return SetStatus(DllExports::GdipDrawImageI(nativeGraphics,
                                                    image ? image->nativeImage
                                                          : NULL,
                                                    x,
                                                    y));
    }

    Status DrawImage(IN Image* image,
                     IN const Rect& rect)
    {
        return DrawImage(image,
                         rect.X,
                         rect.Y,
                         rect.Width,
                         rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y,
                     IN INT width,
                     IN INT height) {
        return SetStatus(DllExports::GdipDrawImageRectI(nativeGraphics,
                                                        image ? image->nativeImage
                                                              : NULL,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    
    // Affine Draw Image
    // destPoints.length = 3: rect => parallelogram
    //     destPoints[0] <=> top-left corner of the source rectangle
    //     destPoints[1] <=> top-right corner
    //     destPoints[2] <=> bottom-left corner
    // destPoints.length = 4: rect => quad
    //     destPoints[3] <=> bottom-right corner
    
    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints,
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePoints(nativeGraphics,
                                                         image ? image->nativeImage
                                                               : NULL,
                                                         destPoints, count));
    }

    Status DrawImage(IN Image* image,
                     IN const Point* destPoints,
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePointsI(nativeGraphics,
                                                          image ? image->nativeImage
                                                                : NULL,
                                                          destPoints,
                                                          count));
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRect(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            x, y,
                                                            srcx, srcy,
                                                            srcwidth, srcheight, srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const RectF& destRect,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRect(nativeGraphics,
                                                           image ? image->nativeImage
                                                                 : NULL,
                                                           destRect.X,
                                                           destRect.Y,
                                                           destRect.Width,
                                                           destRect.Height,
                                                           srcx, srcy,
                                                           srcwidth, srcheight,
                                                           srcUnit,
                                                           imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                           callback,
                                                           callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints,
                     IN INT count,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRect(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             destPoints, count,
                                                             srcx, srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit,
                                                             imageAttributes
                                                              ? imageAttributes->nativeImageAttr
                                                              : NULL,
                                                             callback,
                                                             callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRectI(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             x,
                                                             y,
                                                             srcx,
                                                             srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const Rect& destRect,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRectI(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            destRect.X,
                                                            destRect.Y,
                                                            destRect.Width,
                                                            destRect.Height,
                                                            srcx,
                                                            srcy,
                                                            srcwidth,
                                                            srcheight,
                                                            srcUnit,
                                                            imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                            callback,
                                                            callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN const Point* destPoints,
                     IN INT count,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRectI(nativeGraphics,
                                                              image ? image->nativeImage
                                                                    : NULL,
                                                              destPoints,
                                                              count,
                                                              srcx,
                                                              srcy,
                                                              srcwidth,
                                                              srcheight,
                                                              srcUnit,
                                                              imageAttributes
                                                               ? imageAttributes->nativeImageAttr
                                                               : NULL,
                                                              callback,
                                                              callbackData));
    }

    // The following methods are for playing an EMF+ to a graphics
    // via the enumeration interface.  Each record of the EMF+ is
    // sent to the callback (along with the callbackData).  Then
    // the callback can invoke the Metafile::PlayRecord method
    // to play the particular record.

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }
    
    Status SetClip(IN const Graphics* g,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipGraphics(nativeGraphics,
                                                         g->nativeGraphics,
                                                         combineMode));
    }

    Status SetClip(IN const RectF& rect,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     combineMode));
    }

    Status SetClip(IN const Rect& rect,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      combineMode));
    }

    Status SetClip(IN const GraphicsPath* path,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipPath(nativeGraphics,
                                                     path->nativePath,
                                                     combineMode));
    }

    Status SetClip(IN const Region* region,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       combineMode));
    }

    // This is different than the other SetClip methods because it assumes
    // that the HRGN is already in device units, so it doesn't transform
    // the coordinates in the HRGN.
    
    Status SetClip(IN HRGN hRgn,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipHrgn(nativeGraphics, hRgn,
                                                     combineMode));
    }

    Status IntersectClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeIntersect));
    }

    Status IntersectClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeIntersect));
    }

    Status IntersectClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeIntersect));
    }

    Status ExcludeClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeExclude));
    }

    Status ExcludeClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeExclude));
    }

    Status ExcludeClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeExclude));
    }

    Status ResetClip()
    {
        return SetStatus(DllExports::GdipResetClip(nativeGraphics));
    }

    Status TranslateClip(IN REAL dx,
                         IN REAL dy)
    {
        return SetStatus(DllExports::GdipTranslateClip(nativeGraphics, dx, dy));
    }

    Status TranslateClip(IN INT dx,
                         IN INT dy)
    {
        return SetStatus(DllExports::GdipTranslateClipI(nativeGraphics,
                                                        dx, dy));
    }

    Status GetClip(OUT Region* region) const
    {
        return SetStatus(DllExports::GdipGetClip(nativeGraphics,
                                                 region->nativeRegion));
    }

    Status GetClipBounds(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBounds(nativeGraphics, rect));
    }

    Status GetClipBounds(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBoundsI(nativeGraphics, rect));
    }

    BOOL IsClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    Status GetVisibleClipBounds(OUT RectF *rect) const
    {

        return SetStatus(DllExports::GdipGetVisibleClipBounds(nativeGraphics,
                                                              rect));
    }

    Status GetVisibleClipBounds(OUT Rect *rect) const
    {
       return SetStatus(DllExports::GdipGetVisibleClipBoundsI(nativeGraphics,
                                                              rect));
    }

    BOOL IsVisibleClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisibleClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y) const
    {
        return IsVisible(Point(x,y));
    }

    BOOL IsVisible(IN const Point& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePointI(nativeGraphics,
                                                  point.X,
                                                  point.Y,
                                                  &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height) const
    {
        return IsVisible(Rect(x, y, width, height));
    }

    BOOL IsVisible(IN const Rect& rect) const
    {

        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRectI(nativeGraphics,
                                                 rect.X,
                                                 rect.Y,
                                                 rect.Width,
                                                 rect.Height,
                                                 &booln));
        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y) const
    {
        return IsVisible(PointF(x, y));
    }

    BOOL IsVisible(IN const PointF& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePoint(nativeGraphics,
                                                 point.X,
                                                 point.Y,
                                                 &booln));

        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height) const
    {
        return IsVisible(RectF(x, y, width, height));
    }

    BOOL IsVisible(IN const RectF& rect) const
    {
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRect(nativeGraphics,
                                                rect.X,
                                                rect.Y,
                                                rect.Width,
                                                rect.Height,
                                                &booln));
        return booln;
    }

    GraphicsState Save() const
    {
        GraphicsState gstate;

        SetStatus(DllExports::GdipSaveGraphics(nativeGraphics, &gstate));

        return gstate;
    }

    Status Restore(IN GraphicsState gstate)
    {
        return SetStatus(DllExports::GdipRestoreGraphics(nativeGraphics,
                                                         gstate));
    }

    GraphicsContainer BeginContainer(IN const RectF &dstrect,
                                     IN const RectF &srcrect,
                                     IN Unit         unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer(nativeGraphics, &dstrect,
                                                 &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer(IN const Rect    &dstrect,
                                     IN const Rect    &srcrect,
                                     IN Unit           unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainerI(nativeGraphics, &dstrect,
                                                  &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer()
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer2(nativeGraphics, &state));

        return state;
    }

    Status EndContainer(IN GraphicsContainer state)
    {
        return SetStatus(DllExports::GdipEndContainer(nativeGraphics, state));
    }

    // Only valid when recording metafiles.

    Status AddMetafileComment(IN const BYTE * data,
                              IN UINT sizeData)
    {
        return SetStatus(DllExports::GdipComment(nativeGraphics, sizeData, data));
    }

    static HPALETTE GetHalftonePalette()
    {
        return DllExports::GdipCreateHalftonePalette();
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    Graphics(const Graphics &);
    Graphics& operator=(const Graphics &);

protected:
    Graphics(GpGraphics* graphics)
    {
        lastResult = Ok;
        SetNativeGraphics(graphics);
    }

    VOID SetNativeGraphics(GpGraphics *graphics)
    {
        this->nativeGraphics = graphics;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpGraphics* GetNativeGraphics() const
    {
        return this->nativeGraphics;
    }

    GpPen* GetNativePen(const Pen* pen)
    {
        return pen->nativePen;
    }

protected:
    GpGraphics* nativeGraphics;
    mutable Status lastResult;

};

//----------------------------------------------------------------------------
// Implementation of GraphicsPath methods that use Graphics
//----------------------------------------------------------------------------

// The GetBounds rectangle may not be the tightest bounds.

inline Status
GraphicsPath::GetBounds(
    OUT RectF* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBounds(nativePath, bounds,
                                                   nativeMatrix, nativePen));
}

inline Status
GraphicsPath::GetBounds(
    OUT Rect* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen
) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBoundsI(nativePath, bounds,
                                                    nativeMatrix, nativePen));
}

inline BOOL
GraphicsPath::IsVisible(
    IN REAL x,
    IN REAL y,
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPoint(nativePath,
                                                x, y, nativeGraphics,
                                                &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsVisible(
    IN INT x,
    IN INT y,
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPointI(nativePath,
                                                 x, y, nativeGraphics,
                                                 &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN REAL x,
    IN REAL y,
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPoint(nativePath,
                                                        x, y, nativePen, nativeGraphics,
                                                        &booln));
    return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN INT x,
    IN INT y,
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPointI(nativePath,
                                                         x, y, nativePen, nativeGraphics,
                                                         &booln));
    return booln;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusinit.h ===
/**************************************************************************
*
* Copyright (c) 2000-2001 Microsoft Corporation
*
* Module Name:
*
*   Gdiplus initialization
*
* Abstract:
*
*   GDI+ Startup and Shutdown APIs
*
**************************************************************************/

#ifndef _GDIPLUSINIT_H
#define _GDIPLUSINIT_H

enum DebugEventLevel
{
    DebugEventLevelFatal,
    DebugEventLevelWarning
};

// Callback function that GDI+ can call, on debug builds, for assertions
// and warnings.

typedef VOID (WINAPI *DebugEventProc)(DebugEventLevel level, CHAR *message);

// Notification functions which the user must call appropriately if
// "SuppressBackgroundThread" (below) is set.

typedef Status (WINAPI *NotificationHookProc)(OUT ULONG_PTR *token);
typedef VOID (WINAPI *NotificationUnhookProc)(ULONG_PTR token);

// Input structure for GdiplusStartup()

struct GdiplusStartupInput
{
    UINT32 GdiplusVersion;             // Must be 1
    DebugEventProc DebugEventCallback; // Ignored on free builds
    BOOL SuppressBackgroundThread;     // FALSE unless you're prepared to call 
                                       // the hook/unhook functions properly
    BOOL SuppressExternalCodecs;       // FALSE unless you want GDI+ only to use
                                       // its internal image codecs.
    
    GdiplusStartupInput(
        DebugEventProc debugEventCallback = NULL,
        BOOL suppressBackgroundThread = FALSE,
        BOOL suppressExternalCodecs = FALSE)
    {
        GdiplusVersion = 1;
        DebugEventCallback = debugEventCallback;
        SuppressBackgroundThread = suppressBackgroundThread;
        SuppressExternalCodecs = suppressExternalCodecs;
    }
};

// Output structure for GdiplusStartup()

struct GdiplusStartupOutput
{
    // The following 2 fields are NULL if SuppressBackgroundThread is FALSE.
    // Otherwise, they are functions which must be called appropriately to
    // replace the background thread.
    //
    // These should be called on the application's main message loop - i.e.
    // a message loop which is active for the lifetime of GDI+.
    // "NotificationHook" should be called before starting the loop,
    // and "NotificationUnhook" should be called after the loop ends.
    
    NotificationHookProc NotificationHook;
    NotificationUnhookProc NotificationUnhook;
};

// GDI+ initialization. Must not be called from DllMain - can cause deadlock.
//
// Must be called before GDI+ API's or constructors are used.
//
// token  - may not be NULL - accepts a token to be passed in the corresponding
//          GdiplusShutdown call.
// input  - may not be NULL
// output - may be NULL only if input->SuppressBackgroundThread is FALSE.

extern "C" Status WINAPI GdiplusStartup(
    OUT ULONG_PTR *token,
    const GdiplusStartupInput *input,
    OUT GdiplusStartupOutput *output);

// GDI+ termination. Must be called before GDI+ is unloaded. 
// Must not be called from DllMain - can cause deadlock.
//
// GDI+ API's may not be called after GdiplusShutdown. Pay careful attention
// to GDI+ object destructors.

extern "C" VOID WINAPI GdiplusShutdown(ULONG_PTR token);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluslinecaps.h ===
/**************************************************************************\
* 
* Copyright (c) 2000-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
* 
*    GdiplusLineCaps.h
*
* Abstract:
*
*   GDI+ CustomLineCap APIs
*
\**************************************************************************/

#ifndef _GDIPLUSLINECAPS_H
#define _GDIPLUSLINECAPS_H

inline 
CustomLineCap::CustomLineCap(
    IN const GraphicsPath* fillPath,
    IN const GraphicsPath* strokePath,
    IN LineCap baseCap,
    IN REAL baseInset
    )
{
    nativeCap = NULL;
    GpPath* nativeFillPath = NULL;
    GpPath* nativeStrokePath = NULL;

    if(fillPath)
        nativeFillPath = fillPath->nativePath;
    if(strokePath)
        nativeStrokePath = strokePath->nativePath;

    lastResult = DllExports::GdipCreateCustomLineCap(
                    nativeFillPath, nativeStrokePath,
                    baseCap, baseInset, &nativeCap);
}

inline 
CustomLineCap::CustomLineCap()
{
    nativeCap = NULL;
    lastResult = Ok;
}

inline 
CustomLineCap::~CustomLineCap()
{
    DllExports::GdipDeleteCustomLineCap(nativeCap);
}

inline Status 
CustomLineCap::SetStrokeCaps(
    IN LineCap startCap, 
    IN LineCap endCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeCaps(nativeCap,
                startCap, endCap));
}

inline Status 
CustomLineCap::GetStrokeCaps(
    OUT LineCap* startCap, 
    OUT LineCap* endCap) const
{
    return SetStatus(DllExports::GdipGetCustomLineCapStrokeCaps(nativeCap,
                 startCap, endCap));
}

inline Status 
CustomLineCap::SetStrokeJoin(
    IN LineJoin lineJoin)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeJoin(nativeCap, 
                                                                lineJoin));
}

inline LineJoin 
CustomLineCap::GetStrokeJoin() const
{
    LineJoin lineJoin;

    SetStatus(DllExports::GdipGetCustomLineCapStrokeJoin(nativeCap, 
                                                         &lineJoin));

    return lineJoin;
}

inline Status 
CustomLineCap::SetBaseCap(IN LineCap baseCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseCap(nativeCap, 
                                                             baseCap));
}

inline LineCap 
CustomLineCap::GetBaseCap() const
{
    LineCap baseCap;
    SetStatus(DllExports::GdipGetCustomLineCapBaseCap(nativeCap, &baseCap));

    return baseCap;
}

inline Status 
CustomLineCap::SetBaseInset(IN REAL inset)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseInset(nativeCap, 
                                                               inset));
}

inline REAL 
CustomLineCap::GetBaseInset() const
{
    REAL inset;
    SetStatus(DllExports::GdipGetCustomLineCapBaseInset(nativeCap, &inset));

    return inset;
}


inline Status 
CustomLineCap::SetWidthScale(IN REAL widthScale)
{
    return SetStatus(DllExports::GdipSetCustomLineCapWidthScale(nativeCap, 
                                                                widthScale));
}

inline REAL 
CustomLineCap::GetWidthScale() const
{
    REAL widthScale;
    SetStatus(DllExports::GdipGetCustomLineCapWidthScale(nativeCap, 
                                                         &widthScale));

    return widthScale;
}

inline CustomLineCap* 
CustomLineCap::Clone() const
{
    GpCustomLineCap *newNativeLineCap = NULL;
    
    SetStatus(DllExports::GdipCloneCustomLineCap(nativeCap, 
                                                 &newNativeLineCap));

    if (lastResult == Ok) 
    {
        CustomLineCap *newLineCap = new CustomLineCap(newNativeLineCap, 
                                                      lastResult);
        if (newLineCap == NULL) 
        {
            SetStatus(DllExports::GdipDeleteCustomLineCap(newNativeLineCap));
        }

        return newLineCap;
    }

    return NULL;
}

inline Status 
CustomLineCap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

class AdjustableArrowCap : public CustomLineCap
{
public:

    AdjustableArrowCap(
        IN REAL height,
        IN REAL width,
        IN BOOL isFilled = TRUE
        )
    {
        GpAdjustableArrowCap* cap = NULL;

        lastResult = DllExports::GdipCreateAdjustableArrowCap(
                        height, width, isFilled, &cap);
        SetNativeCap(cap);
    }

    Status SetHeight(IN REAL height)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapHeight(
                            cap, height));
    }

    REAL GetHeight() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL height;
        SetStatus(DllExports::GdipGetAdjustableArrowCapHeight(
                            cap, &height));

        return height;
    }

    Status SetWidth(IN REAL width)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapWidth(
                            cap, width));
    }

    REAL GetWidth() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL width;
        SetStatus(DllExports::GdipGetAdjustableArrowCapWidth(
                            cap, &width));

        return width;
    }

    Status SetMiddleInset(IN REAL middleInset)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapMiddleInset(
                            cap, middleInset));
    }

    REAL GetMiddleInset() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL middleInset;
        SetStatus(DllExports::GdipGetAdjustableArrowCapMiddleInset(
                            cap, &middleInset));

        return middleInset;
    }

    Status SetFillState(IN BOOL isFilled)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapFillState(
                            cap, isFilled));
    }

    BOOL IsFilled() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        BOOL isFilled;
        SetStatus(DllExports::GdipGetAdjustableArrowCapFillState(
                            cap, &isFilled));

        return isFilled;
    }

private:
    AdjustableArrowCap(const AdjustableArrowCap &);
    AdjustableArrowCap& operator=(const AdjustableArrowCap &);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusimaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GdiplusImaging.h
*
* Abstract:
*
*   GDI+ Imaging GUIDs
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGING_H
#define _GDIPLUSIMAGING_H

//---------------------------------------------------------------------------
// Image file format identifiers
//---------------------------------------------------------------------------

DEFINE_GUID(ImageFormatUndefined, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatMemoryBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatBMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatWMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatJPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatPNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatGIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatTIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatIcon, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//---------------------------------------------------------------------------
// Predefined multi-frame dimension IDs
//---------------------------------------------------------------------------

DEFINE_GUID(FrameDimensionTime, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FrameDimensionResolution, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FrameDimensionPage, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//---------------------------------------------------------------------------
// Property sets
//---------------------------------------------------------------------------

DEFINE_GUID(FormatIDImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FormatIDJpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//---------------------------------------------------------------------------
// Encoder parameter sets
//---------------------------------------------------------------------------

DEFINE_GUID(EncoderCompression, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(EncoderColorDepth, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(EncoderScanMethod, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(EncoderVersion, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(EncoderRenderMethod, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(EncoderQuality, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(EncoderTransformation,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(EncoderLuminanceTable,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(EncoderChrominanceTable,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(EncoderSaveFlag,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);

DEFINE_GUID(CodecIImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

MIDL_INTERFACE("025D1823-6C7D-447B-BBDB-A3CBC3DFA2FC")
IImageBytes : public IUnknown
{
public:
    // Return total number of bytes in the IStream

    STDMETHOD(CountBytes)(
        OUT UINT *pcb
        ) = 0;
    
    // Locks "cb" bytes, starting from "ulOffset" in the stream, and returns the
    // pointer to the beginning of the locked memory chunk in "ppvBytes"

    STDMETHOD(LockBytes)(
        IN UINT cb,
        IN ULONG ulOffset,
        OUT const VOID ** ppvBytes
        ) = 0;

    // Unlocks "cb" bytes, pointed by "pvBytes", starting from "ulOffset" in the
    // stream

    STDMETHOD(UnlockBytes)(
        IN const VOID *pvBytes,
        IN UINT cb,
        IN ULONG ulOffset
        ) = 0;
};

//--------------------------------------------------------------------------
// ImageCodecInfo structure
//--------------------------------------------------------------------------

class ImageCodecInfo
{
public:          
    CLSID Clsid;
    GUID  FormatID;
    const WCHAR* CodecName;
    const WCHAR* DllName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD Version;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
};

//--------------------------------------------------------------------------
// Information flags about image codecs
//--------------------------------------------------------------------------

enum ImageCodecFlags
{
    ImageCodecFlagsEncoder            = 0x00000001,
    ImageCodecFlagsDecoder            = 0x00000002,
    ImageCodecFlagsSupportBitmap      = 0x00000004,
    ImageCodecFlagsSupportVector      = 0x00000008,
    ImageCodecFlagsSeekableEncode     = 0x00000010,
    ImageCodecFlagsBlockingDecode     = 0x00000020,

    ImageCodecFlagsBuiltin            = 0x00010000,
    ImageCodecFlagsSystem             = 0x00020000,
    ImageCodecFlagsUser               = 0x00040000
};

//---------------------------------------------------------------------------
// Access modes used when calling Image::LockBits
//---------------------------------------------------------------------------

enum ImageLockMode
{
    ImageLockModeRead        = 0x0001,
    ImageLockModeWrite       = 0x0002,
    ImageLockModeUserInputBuf= 0x0004
};

//---------------------------------------------------------------------------
// Information about image pixel data
//---------------------------------------------------------------------------

class BitmapData
{
public:
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormat PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
};

//---------------------------------------------------------------------------
// Image flags
//---------------------------------------------------------------------------

enum ImageFlags
{
    ImageFlagsNone                = 0,

    // Low-word: shared with SINKFLAG_x

    ImageFlagsScalable            = 0x0001,
    ImageFlagsHasAlpha            = 0x0002,
    ImageFlagsHasTranslucent      = 0x0004,
    ImageFlagsPartiallyScalable   = 0x0008,

    // Low-word: color space definition

    ImageFlagsColorSpaceRGB       = 0x0010,
    ImageFlagsColorSpaceCMYK      = 0x0020,
    ImageFlagsColorSpaceGRAY      = 0x0040,
    ImageFlagsColorSpaceYCBCR     = 0x0080,
    ImageFlagsColorSpaceYCCK      = 0x0100,
 
    // Low-word: image size info

    ImageFlagsHasRealDPI          = 0x1000,
    ImageFlagsHasRealPixelSize    = 0x2000,

    // High-word

    ImageFlagsReadOnly            = 0x00010000,
    ImageFlagsCaching             = 0x00020000
};

enum RotateFlipType
{
    RotateNoneFlipNone = 0,
    Rotate90FlipNone   = 1,
    Rotate180FlipNone  = 2,
    Rotate270FlipNone  = 3,

    RotateNoneFlipX    = 4,
    Rotate90FlipX      = 5,
    Rotate180FlipX     = 6,
    Rotate270FlipX     = 7,

    RotateNoneFlipY    = Rotate180FlipX,
    Rotate90FlipY      = Rotate270FlipX,
    Rotate180FlipY     = RotateNoneFlipX,
    Rotate270FlipY     = Rotate90FlipX,

    RotateNoneFlipXY   = Rotate180FlipNone,
    Rotate90FlipXY     = Rotate270FlipNone,
    Rotate180FlipXY    = RotateNoneFlipNone,
    Rotate270FlipXY    = Rotate90FlipNone
};

//---------------------------------------------------------------------------
// Encoder Parameter structure
//---------------------------------------------------------------------------
class EncoderParameter
{
public:
    GUID    Guid;               // GUID of the parameter
    ULONG   NumberOfValues;     // Number of the parameter values
    ULONG   Type;               // Value type, like ValueTypeLONG  etc.
    VOID*   Value;              // A pointer to the parameter values
};

//---------------------------------------------------------------------------
// Encoder Parameters structure
//---------------------------------------------------------------------------
class EncoderParameters
{
public:
    UINT Count;                      // Number of parameters in this structure
    EncoderParameter Parameter[1];   // Parameter values
};

//---------------------------------------------------------------------------
// Property Item
//---------------------------------------------------------------------------
class PropertyItem
{
public:
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    VOID*   value;              // property value
};

//---------------------------------------------------------------------------
// Image property types 
//---------------------------------------------------------------------------
#define PropertyTagTypeByte        1
#define PropertyTagTypeASCII       2
#define PropertyTagTypeShort       3
#define PropertyTagTypeLong        4
#define PropertyTagTypeRational    5
#define PropertyTagTypeUndefined   7
#define PropertyTagTypeSLONG       9
#define PropertyTagTypeSRational  10

//---------------------------------------------------------------------------
// Image property ID tags
//---------------------------------------------------------------------------

#define PropertyTagExifIFD             0x8769
#define PropertyTagGpsIFD              0x8825

#define PropertyTagNewSubfileType      0x00FE
#define PropertyTagSubfileType         0x00FF
#define PropertyTagImageWidth          0x0100
#define PropertyTagImageHeight         0x0101
#define PropertyTagBitsPerSample       0x0102
#define PropertyTagCompression         0x0103
#define PropertyTagPhotometricInterp   0x0106
#define PropertyTagThreshHolding       0x0107
#define PropertyTagCellWidth           0x0108
#define PropertyTagCellHeight          0x0109
#define PropertyTagFillOrder           0x010A
#define PropertyTagDocumentName        0x010D
#define PropertyTagImageDescription    0x010E
#define PropertyTagEquipMake           0x010F
#define PropertyTagEquipModel          0x0110
#define PropertyTagStripOffsets        0x0111
#define PropertyTagOrientation         0x0112
#define PropertyTagSamplesPerPixel     0x0115
#define PropertyTagRowsPerStrip        0x0116
#define PropertyTagStripBytesCount     0x0117
#define PropertyTagMinSampleValue      0x0118
#define PropertyTagMaxSampleValue      0x0119
#define PropertyTagXResolution         0x011A   // Image resolution in width direction
#define PropertyTagYResolution         0x011B   // Image resolution in height direction
#define PropertyTagPlanarConfig        0x011C   // Image data arrangement
#define PropertyTagPageName            0x011D
#define PropertyTagXPosition           0x011E
#define PropertyTagYPosition           0x011F
#define PropertyTagFreeOffset          0x0120
#define PropertyTagFreeByteCounts      0x0121
#define PropertyTagGrayResponseUnit    0x0122
#define PropertyTagGrayResponseCurve   0x0123
#define PropertyTagT4Option            0x0124
#define PropertyTagT6Option            0x0125
#define PropertyTagResolutionUnit      0x0128   // Unit of X and Y resolution
#define PropertyTagPageNumber          0x0129
#define PropertyTagTransferFuncition   0x012D
#define PropertyTagSoftwareUsed        0x0131
#define PropertyTagDateTime            0x0132
#define PropertyTagArtist              0x013B
#define PropertyTagHostComputer        0x013C
#define PropertyTagPredictor           0x013D
#define PropertyTagWhitePoint          0x013E
#define PropertyTagPrimaryChromaticities 0x013F
#define PropertyTagColorMap            0x0140
#define PropertyTagHalftoneHints       0x0141
#define PropertyTagTileWidth           0x0142
#define PropertyTagTileLength          0x0143
#define PropertyTagTileOffset          0x0144
#define PropertyTagTileByteCounts      0x0145
#define PropertyTagInkSet              0x014C
#define PropertyTagInkNames            0x014D
#define PropertyTagNumberOfInks        0x014E
#define PropertyTagDotRange            0x0150
#define PropertyTagTargetPrinter       0x0151
#define PropertyTagExtraSamples        0x0152
#define PropertyTagSampleFormat        0x0153
#define PropertyTagSMinSampleValue     0x0154
#define PropertyTagSMaxSampleValue     0x0155
#define PropertyTagTransferRange       0x0156

#define PropertyTagJPEGProc            0x0200
#define PropertyTagJPEGInterFormat     0x0201
#define PropertyTagJPEGInterLength     0x0202
#define PropertyTagJPEGRestartInterval 0x0203
#define PropertyTagJPEGLosslessPredictors  0x0205
#define PropertyTagJPEGPointTransforms     0x0206
#define PropertyTagJPEGQTables         0x0207
#define PropertyTagJPEGDCTables        0x0208
#define PropertyTagJPEGACTables        0x0209

#define PropertyTagYCbCrCoefficients   0x0211
#define PropertyTagYCbCrSubsampling    0x0212
#define PropertyTagYCbCrPositioning    0x0213
#define PropertyTagREFBlackWhite       0x0214

#define PropertyTagICCProfile          0x8773   // This TAG is defined by ICC
                                                // for embedded ICC in TIFF
#define PropertyTagGamma               0x0301
#define PropertyTagICCProfileDescriptor 0x0302
#define PropertyTagSRGBRenderingIntent 0x0303

#define PropertyTagImageTitle          0x0320
#define PropertyTagCopyright           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define PropertyTagResolutionXUnit           0x5001
#define PropertyTagResolutionYUnit           0x5002
#define PropertyTagResolutionXLengthUnit     0x5003
#define PropertyTagResolutionYLengthUnit     0x5004
#define PropertyTagPrintFlags                0x5005
#define PropertyTagPrintFlagsVersion         0x5006
#define PropertyTagPrintFlagsCrop            0x5007
#define PropertyTagPrintFlagsBleedWidth      0x5008
#define PropertyTagPrintFlagsBleedWidthScale 0x5009
#define PropertyTagHalftoneLPI               0x500A
#define PropertyTagHalftoneLPIUnit           0x500B
#define PropertyTagHalftoneDegree            0x500C
#define PropertyTagHalftoneShape             0x500D
#define PropertyTagHalftoneMisc              0x500E
#define PropertyTagHalftoneScreen            0x500F
#define PropertyTagJPEGQuality               0x5010
#define PropertyTagGridSize                  0x5011
#define PropertyTagThumbnailFormat           0x5012  // 1 = JPEG, 0 = RAW RGB
#define PropertyTagThumbnailWidth            0x5013
#define PropertyTagThumbnailHeight           0x5014
#define PropertyTagThumbnailColorDepth       0x5015
#define PropertyTagThumbnailPlanes           0x5016
#define PropertyTagThumbnailRawBytes         0x5017
#define PropertyTagThumbnailSize             0x5018
#define PropertyTagThumbnailCompressedSize   0x5019
#define PropertyTagColorTransferFunction     0x501A
#define PropertyTagThumbnailData             0x501B// RAW thumbnail bits in
                                                   // JPEG format or RGB format
                                                   // depends on
                                                   // PropertyTagThumbnailFormat

// Thumbnail related TAGs
                                                
#define PropertyTagThumbnailImageWidth       0x5020  // Thumbnail width
#define PropertyTagThumbnailImageHeight      0x5021  // Thumbnail height
#define PropertyTagThumbnailBitsPerSample    0x5022  // Number of bits per
                                                     // component
#define PropertyTagThumbnailCompression      0x5023  // Compression Scheme
#define PropertyTagThumbnailPhotometricInterp 0x5024 // Pixel composition
#define PropertyTagThumbnailImageDescription 0x5025  // Image Tile
#define PropertyTagThumbnailEquipMake        0x5026  // Manufacturer of Image
                                                     // Input equipment
#define PropertyTagThumbnailEquipModel       0x5027  // Model of Image input
                                                     // equipment
#define PropertyTagThumbnailStripOffsets     0x5028  // Image data location
#define PropertyTagThumbnailOrientation      0x5029  // Orientation of image
#define PropertyTagThumbnailSamplesPerPixel  0x502A  // Number of components
#define PropertyTagThumbnailRowsPerStrip     0x502B  // Number of rows per strip
#define PropertyTagThumbnailStripBytesCount  0x502C  // Bytes per compressed
                                                     // strip
#define PropertyTagThumbnailResolutionX      0x502D  // Resolution in width
                                                     // direction
#define PropertyTagThumbnailResolutionY      0x502E  // Resolution in height
                                                     // direction
#define PropertyTagThumbnailPlanarConfig     0x502F  // Image data arrangement
#define PropertyTagThumbnailResolutionUnit   0x5030  // Unit of X and Y
                                                     // Resolution
#define PropertyTagThumbnailTransferFunction 0x5031  // Transfer function
#define PropertyTagThumbnailSoftwareUsed     0x5032  // Software used
#define PropertyTagThumbnailDateTime         0x5033  // File change date and
                                                     // time
#define PropertyTagThumbnailArtist           0x5034  // Person who created the
                                                     // image
#define PropertyTagThumbnailWhitePoint       0x5035  // White point chromaticity
#define PropertyTagThumbnailPrimaryChromaticities 0x5036 
                                                     // Chromaticities of
                                                     // primaries
#define PropertyTagThumbnailYCbCrCoefficients 0x5037 // Color space transforma-
                                                     // tion coefficients
#define PropertyTagThumbnailYCbCrSubsampling 0x5038  // Subsampling ratio of Y
                                                     // to C
#define PropertyTagThumbnailYCbCrPositioning 0x5039  // Y and C position
#define PropertyTagThumbnailRefBlackWhite    0x503A  // Pair of black and white
                                                     // reference values
#define PropertyTagThumbnailCopyRight        0x503B  // CopyRight holder

#define PropertyTagLuminanceTable            0x5090
#define PropertyTagChrominanceTable          0x5091

#define PropertyTagFrameDelay                0x5100
#define PropertyTagLoopCount                 0x5101

#define PropertyTagPixelUnit         0x5110  // Unit specifier for pixel/unit
#define PropertyTagPixelPerUnitX     0x5111  // Pixels per unit in X
#define PropertyTagPixelPerUnitY     0x5112  // Pixels per unit in Y
#define PropertyTagPaletteHistogram  0x5113  // Palette histogram

// EXIF specific tag

#define PropertyTagExifExposureTime  0x829A
#define PropertyTagExifFNumber       0x829D

#define PropertyTagExifExposureProg  0x8822
#define PropertyTagExifSpectralSense 0x8824
#define PropertyTagExifISOSpeed      0x8827
#define PropertyTagExifOECF          0x8828

#define PropertyTagExifVer            0x9000
#define PropertyTagExifDTOrig         0x9003 // Date & time of original
#define PropertyTagExifDTDigitized    0x9004 // Date & time of digital data generation

#define PropertyTagExifCompConfig     0x9101
#define PropertyTagExifCompBPP        0x9102

#define PropertyTagExifShutterSpeed   0x9201
#define PropertyTagExifAperture       0x9202
#define PropertyTagExifBrightness     0x9203
#define PropertyTagExifExposureBias   0x9204
#define PropertyTagExifMaxAperture    0x9205
#define PropertyTagExifSubjectDist    0x9206
#define PropertyTagExifMeteringMode   0x9207
#define PropertyTagExifLightSource    0x9208
#define PropertyTagExifFlash          0x9209
#define PropertyTagExifFocalLength    0x920A
#define PropertyTagExifMakerNote      0x927C
#define PropertyTagExifUserComment    0x9286
#define PropertyTagExifDTSubsec       0x9290  // Date & Time subseconds
#define PropertyTagExifDTOrigSS       0x9291  // Date & Time original subseconds
#define PropertyTagExifDTDigSS        0x9292  // Date & TIme digitized subseconds

#define PropertyTagExifFPXVer         0xA000
#define PropertyTagExifColorSpace     0xA001
#define PropertyTagExifPixXDim        0xA002
#define PropertyTagExifPixYDim        0xA003
#define PropertyTagExifRelatedWav     0xA004  // related sound file
#define PropertyTagExifInterop        0xA005
#define PropertyTagExifFlashEnergy    0xA20B
#define PropertyTagExifSpatialFR      0xA20C  // Spatial Frequency Response
#define PropertyTagExifFocalXRes      0xA20E  // Focal Plane X Resolution
#define PropertyTagExifFocalYRes      0xA20F  // Focal Plane Y Resolution
#define PropertyTagExifFocalResUnit   0xA210  // Focal Plane Resolution Unit
#define PropertyTagExifSubjectLoc     0xA214
#define PropertyTagExifExposureIndex  0xA215
#define PropertyTagExifSensingMethod  0xA217
#define PropertyTagExifFileSource     0xA300
#define PropertyTagExifSceneType      0xA301
#define PropertyTagExifCfaPattern     0xA302

#define PropertyTagGpsVer             0x0000
#define PropertyTagGpsLatitudeRef     0x0001
#define PropertyTagGpsLatitude        0x0002
#define PropertyTagGpsLongitudeRef    0x0003
#define PropertyTagGpsLongitude       0x0004
#define PropertyTagGpsAltitudeRef     0x0005
#define PropertyTagGpsAltitude        0x0006
#define PropertyTagGpsGpsTime         0x0007
#define PropertyTagGpsGpsSatellites   0x0008
#define PropertyTagGpsGpsStatus       0x0009
#define PropertyTagGpsGpsMeasureMode  0x00A
#define PropertyTagGpsGpsDop          0x000B  // Measurement precision
#define PropertyTagGpsSpeedRef        0x000C
#define PropertyTagGpsSpeed           0x000D
#define PropertyTagGpsTrackRef        0x000E
#define PropertyTagGpsTrack           0x000F
#define PropertyTagGpsImgDirRef       0x0010
#define PropertyTagGpsImgDir          0x0011
#define PropertyTagGpsMapDatum        0x0012
#define PropertyTagGpsDestLatRef      0x0013
#define PropertyTagGpsDestLat         0x0014
#define PropertyTagGpsDestLongRef     0x0015
#define PropertyTagGpsDestLong        0x0016
#define PropertyTagGpsDestBearRef     0x0017
#define PropertyTagGpsDestBear        0x0018
#define PropertyTagGpsDestDistRef     0x0019
#define PropertyTagGpsDestDist        0x001A

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusmem.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMem.h
*
* Abstract:
*
*   GDI+ Private Memory Management APIs
*
\**************************************************************************/

#ifndef _GDIPLUSMEM_H
#define _GDIPLUSMEM_H

#ifdef __cplusplus
extern "C" {
#endif

#define WINGDIPAPI __stdcall

//----------------------------------------------------------------------------
// Memory Allocation APIs
//----------------------------------------------------------------------------

void* WINGDIPAPI
GdipAlloc(size_t size);

void WINGDIPAPI
GdipFree(void* ptr);

#ifdef __cplusplus
}
#endif

#endif // !_GDIPLUSMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusmatrix.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMatrix.h
*
* Abstract:
*
*   GDI+ Matrix class
*
\**************************************************************************/

class Matrix : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;
    friend class TextureBrush;
    friend class LinearGradientBrush;
    friend class PathGradientBrush;
    friend class Pen;
    friend class Region;
    
    // Default constructor is set to identity matrix.

    Matrix()
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix(&matrix);
    
        SetNativeMatrix(matrix);
    }

    Matrix(IN REAL m11, 
           IN REAL m12,
           IN REAL m21, 
           IN REAL m22,
           IN REAL dx, 
           IN REAL dy)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix2(m11, m12, m21, m22, 
                                                      dx, dy, &matrix);
    
        SetNativeMatrix(matrix);
    }
    
    Matrix(IN const RectF& rect, 
           IN const PointF* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3(&rect, 
                                                   dstplg,
                                                   &matrix);

        SetNativeMatrix(matrix);
    }

    Matrix(IN const Rect& rect, 
           IN const Point* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3I(&rect, 
                                                    dstplg,
                                                    &matrix);

        SetNativeMatrix(matrix);
    }

    ~Matrix()
    {
        DllExports::GdipDeleteMatrix(nativeMatrix);
    }

    Matrix *Clone() const
    {
        GpMatrix *cloneMatrix = NULL;

        SetStatus(DllExports::GdipCloneMatrix(nativeMatrix,
                                                  &cloneMatrix));

        if (lastResult != Ok)
            return NULL;

        return new Matrix(cloneMatrix);
    }

    Status GetElements(OUT REAL *m) const 
    {
        return SetStatus(DllExports::GdipGetMatrixElements(nativeMatrix, m));
    }
    
    Status SetElements(IN REAL m11, 
                       IN REAL m12, 
                       IN REAL m21, 
                       IN REAL m22, 
                       IN REAL dx, 
                       IN REAL dy)
    {
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                            m11, m12, m21, m22, dx, dy));
    }

    REAL OffsetX() const
    {
        REAL elements[6];

        if (GetElements(&elements[0]) == Ok)
            return elements[4];
        else 
            return 0.0f;
    }

    REAL OffsetY() const
    {
       REAL elements[6];

       if (GetElements(&elements[0]) == Ok)
           return elements[5];
       else 
           return 0.0f;
    }

    Status Reset()
    {
        // set identity matrix elements 
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                                             1.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    }

    Status Multiply(IN const Matrix *matrix, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyMatrix(nativeMatrix, 
                                          matrix->nativeMatrix,
                                          order));
    }

    Status Translate(IN REAL offsetX, 
                     IN REAL offsetY, 
                     IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, offsetX,
                                                         offsetY, order));
    }

    Status Scale(IN REAL scaleX, 
                 IN REAL scaleY, 
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleMatrix(nativeMatrix, scaleX, 
                                                     scaleY, order));
    }

    Status Rotate(IN REAL angle, 
                  IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                      order));
    }
    
    Status RotateAt(IN REAL angle, 
                    IN const PointF& center, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        if(order == MatrixOrderPrepend)
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X,
                                                      center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                   order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix,
                                                             -center.X, 
                                                             -center.Y, 
                                                             order));
        }
        else
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, 
                                                      - center.X, 
                                                      - center.Y, 
                                                      order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                   order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, 
                                                             center.X, 
                                                             center.Y, 
                                                             order));
        }
    }

    Status Shear(IN REAL shearX, 
                 IN REAL shearY,
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipShearMatrix(nativeMatrix, shearX, 
                                                     shearY, order));
    }

    Status Invert()
    {
        return SetStatus(DllExports::GdipInvertMatrix(nativeMatrix));
    }

    // float version
    Status TransformPoints(IN OUT PointF* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPoints(nativeMatrix, 
                                                               pts, count));
    }
    
    Status TransformPoints(IN OUT Point* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPointsI(nativeMatrix, 
                                                                pts, 
                                                                count));
    }

    Status TransformVectors(IN OUT PointF* pts, 
                            IN INT count = 1) const
    { 
        return SetStatus(DllExports::GdipVectorTransformMatrixPoints(
                                        nativeMatrix, pts, count));
    }

    Status TransformVectors(IN OUT Point* pts, 
                            IN INT count = 1) const
    { 
       return SetStatus(DllExports::GdipVectorTransformMatrixPointsI(
                                        nativeMatrix, 
                                        pts, 
                                        count));
    }
    
    BOOL IsInvertible() const
    {
        BOOL result = FALSE;

        SetStatus(DllExports::GdipIsMatrixInvertible(nativeMatrix, &result));
    
        return result;
    }

    BOOL IsIdentity() const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixIdentity(nativeMatrix, &result));
    
       return result;
    }

    BOOL Equals(IN const Matrix *matrix) const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixEqual(nativeMatrix,
                                               matrix->nativeMatrix, 
                                               &result));
   
       return result;
    }
    
    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
 
        return lastStatus;
    }

private:
    Matrix(const Matrix &);
    Matrix& operator=(const Matrix &);

protected:
    Matrix(GpMatrix *nativeMatrix)
    {
        lastResult = Ok;
        SetNativeMatrix(nativeMatrix);
    }
    
    VOID SetNativeMatrix(GpMatrix *nativeMatrix)
    {
        this->nativeMatrix = nativeMatrix;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpMatrix *nativeMatrix;
    mutable Status lastResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusmetafile.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMetafile.h
*
* Abstract:
*
*   GDI+ Metafile class
*
\**************************************************************************/

#ifndef _GDIPLUSMETAFILE_H
#define _GDIPLUSMETAFILE_H

class Metafile : public Image
{
public:
    friend class Image;

    // Playback a metafile from a HMETAFILE
    // If deleteWmf is TRUE, then when the metafile is deleted,
    // the hWmf will also be deleted.  Otherwise, it won't be.
    
    Metafile(IN HMETAFILE                      hWmf,
             IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader,
             IN BOOL                           deleteWmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromWmf(hWmf, deleteWmf, 
                                                           wmfPlaceableFileHeader, 
                                                           &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a HENHMETAFILE
    // If deleteEmf is TRUE, then when the metafile is deleted,
    // the hEmf will also be deleted.  Otherwise, it won't be.
    
    Metafile(IN HENHMETAFILE hEmf,
             IN BOOL deleteEmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromEmf(hEmf, deleteEmf, 
                                                           &metafile);

        SetNativeImage(metafile);
    }

    Metafile(IN const WCHAR* filename)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromFile(filename, 
                                                            &metafile);

        SetNativeImage(metafile);
    }

    // Playback a WMF metafile from a file.

    Metafile(IN const WCHAR*                   filename,
             IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader
            )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromWmfFile(filename, 
                                                               wmfPlaceableFileHeader, 
                                                               &metafile);

        SetNativeImage(metafile);
    }

    Metafile(IN IStream* stream)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromStream(stream, 
                                                              &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileI(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileNameI(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStreamI(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    static Status GetMetafileHeader(
        IN HMETAFILE                       hWmf,
        IN const WmfPlaceableFileHeader *  wmfPlaceableFileHeader,
        OUT MetafileHeader *               header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromWmf(hWmf,
                                                        wmfPlaceableFileHeader, 
                                                        header);
    }

    static Status GetMetafileHeader(
        IN HENHMETAFILE        hEmf,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromEmf(hEmf, header);
    }

    static Status GetMetafileHeader(
        IN const WCHAR*        filename,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromFile(filename, header);
    }

    static Status GetMetafileHeader(
        IN IStream *           stream,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromStream(stream, header);
    }

    Status GetMetafileHeader(
        OUT MetafileHeader *    header
        ) const
    {
        return SetStatus(DllExports::GdipGetMetafileHeaderFromMetafile(
                                              (GpMetafile *)nativeImage,
                                              header));
    }

    // Once this method is called, the Metafile object is in an invalid state
    // and can no longer be used.  It is the responsiblity of the caller to
    // invoke DeleteEnhMetaFile to delete this hEmf.

    HENHMETAFILE GetHENHMETAFILE()
    {
        HENHMETAFILE hEmf;

        SetStatus(DllExports::GdipGetHemfFromMetafile(
                                  (GpMetafile *)nativeImage, 
                                  &hEmf));

        return hEmf;
    }

    // Used in conjuction with Graphics::EnumerateMetafile to play an EMF+
    // The data must be DWORD aligned if it's an EMF or EMF+.  It must be
    // WORD aligned if it's a WMF.
    
    Status PlayRecord(
        IN EmfPlusRecordType   recordType,
        IN UINT                flags,
        IN UINT                dataSize,
        IN const BYTE *        data
        ) const
    {
        return SetStatus(DllExports::GdipPlayMetafileRecord(
                                (GpMetafile *)nativeImage,
                                recordType,
                                flags,
                                dataSize,
                                data));
    }

    // If you're using a printer HDC for the metafile, but you want the
    // metafile rasterized at screen resolution, then use this API to set
    // the rasterization dpi of the metafile to the screen resolution,
    // e.g. 96 dpi or 120 dpi.
    
    Status SetDownLevelRasterizationLimit(
        IN UINT     metafileRasterizationLimitDpi
        )
    {
        return SetStatus(DllExports::
                         GdipSetMetafileDownLevelRasterizationLimit(
                                (GpMetafile *)nativeImage,
                                metafileRasterizationLimitDpi));
    }

    UINT GetDownLevelRasterizationLimit() const
    {
        UINT    metafileRasterizationLimitDpi = 0;

        SetStatus(DllExports::GdipGetMetafileDownLevelRasterizationLimit(
                                (GpMetafile *)nativeImage,
                                &metafileRasterizationLimitDpi));

        return metafileRasterizationLimitDpi;
    }

    static UINT Metafile::EmfToWmfBits(
        IN HENHMETAFILE       hemf,
        IN UINT               cbData16,
        OUT LPBYTE            pData16,
        IN INT                iMapMode = MM_ANISOTROPIC,
        IN INT                eFlags = EmfToWmfBitsFlagsDefault
    )
    {
        return DllExports::GdipEmfToWmfBits(
            hemf,
            cbData16,
            pData16,
            iMapMode,
            eFlags);
    }

protected:
    Metafile()
    {
        SetNativeImage(NULL);
        lastResult = Ok;
    }

private:
    Metafile(const Metafile &);
    Metafile& operator=(const Metafile &);
};

#endif // !_METAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpinit.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is probably specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects.
*   The ordering is important when apps make global GDI+ objects.
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"
#include "gpinit.h"

GdiplusInitHelper::GdiplusInitHelper() : gpToken(0), Valid(FALSE)
{
    Gdiplus::GdiplusStartupInput sti;
    if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
    {
        Valid = TRUE;
    }
}
    
GdiplusInitHelper::~GdiplusInitHelper()
{
    if (Valid)
    {
        Gdiplus::GdiplusShutdown(gpToken);
    }
}

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluspath.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusPath.h
*
* Abstract:
*
*   GDI+ Graphics Path class
*
\**************************************************************************/

#ifndef _GDIPLUSPATH_H
#define _GDIPLUSPATH_H

class GraphicsPath : public GdiplusBase
{
public:
    friend class Graphics;
    friend class Region;
    friend class PathGradientBrush;
    friend class GraphicsPathIterator;
    friend class CustomLineCap;

    GraphicsPath(IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath(fillMode, &nativePath);
    }

    GraphicsPath(IN const PointF* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2(points,
                                                 types,
                                                 count,
                                                 fillMode,
                                                 &nativePath);
    }

    GraphicsPath(IN const Point* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2I(points,
                                                  types,
                                                  count,
                                                  fillMode,
                                                  &nativePath);
    }

    ~GraphicsPath()
    {
        DllExports::GdipDeletePath(nativePath);
    }

    GraphicsPath* Clone() const
    {
        GpPath *clonepath = NULL;

        SetStatus(DllExports::GdipClonePath(nativePath, &clonepath));

        return new GraphicsPath(clonepath);
    }

    // Reset the path object to empty (and fill mode to FillModeAlternate)

    Status Reset()
    {
        return SetStatus(DllExports::GdipResetPath(nativePath));
    }

    FillMode GetFillMode() const
    {
        FillMode fillmode = FillModeAlternate;

        SetStatus(DllExports::GdipGetPathFillMode(nativePath, &fillmode));

        return fillmode;
    }

    Status SetFillMode(IN FillMode fillmode)
    {
        return SetStatus(DllExports::GdipSetPathFillMode(nativePath, 
                                                         fillmode));
    }

    Status GetPathData(OUT PathData* pathData) const
    {
        if (pathData == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        INT count = GetPointCount();
        
        if ((count <= 0) || (pathData->Count>0 && pathData->Count<count))
        {
            pathData->Count = 0;
            if (pathData->Points)
            {
                delete pathData->Points;
                pathData->Points = NULL;
            }

            if (pathData->Types) 
            {
                delete pathData->Types;
                pathData->Types = NULL;
            }

            if (count <= 0)
            {
                return lastResult;
            }
        }

        if (pathData->Count == 0) 
        {
            pathData->Points = new PointF[count];
            if (pathData->Points == NULL) 
            {
                return SetStatus(OutOfMemory);
            
            }
            pathData->Types = new byte[count];
            if (pathData->Types == NULL) 
            {
                delete pathData->Points;
                pathData->Points = NULL;

                return SetStatus(OutOfMemory);
            }
            pathData->Count = count;
        }

        return SetStatus(DllExports::GdipGetPathData(nativePath, pathData));
    }

    Status StartFigure()
    {
        return SetStatus(DllExports::GdipStartPathFigure(nativePath));
    }

    Status CloseFigure()
    {
        return SetStatus(DllExports::GdipClosePathFigure(nativePath));
    }

    Status CloseAllFigures()
    {
        return SetStatus(DllExports::GdipClosePathFigures(nativePath));
    }

    Status SetMarker()
    {
        return SetStatus(DllExports::GdipSetPathMarker(nativePath));
    }

    Status ClearMarkers()
    {
        return SetStatus(DllExports::GdipClearPathMarkers(nativePath));
    }

    Status Reverse()
    {
        return SetStatus(DllExports::GdipReversePath(nativePath));
    }

    Status GetLastPoint(OUT PointF* lastPoint) const
    {
        return SetStatus(DllExports::GdipGetPathLastPoint(nativePath, 
                                                          lastPoint));
    }

    Status AddLine(IN const PointF& pt1, 
                   IN const PointF& pt2)
    {
        return AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status AddLine(IN REAL x1,
                   IN REAL y1, 
                   IN REAL x2, 
                   IN REAL y2)
    {
        return SetStatus(DllExports::GdipAddPathLine(nativePath, x1, y1, 
                                                     x2, y2));
    }

    Status AddLines(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2(nativePath, points, 
                                                      count));
    }

    Status AddLine(IN const Point& pt1, 
                   IN const Point& pt2)
    {
        return AddLine(pt1.X,
                       pt1.Y,
                       pt2.X,
                       pt2.Y);
    }

    Status AddLine(IN INT x1, 
                   IN INT y1, 
                   IN INT x2, 
                   IN INT y2)
    {
        return SetStatus(DllExports::GdipAddPathLineI(nativePath,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2));
    }

    Status AddLines(IN const Point* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2I(nativePath,
                                                       points,
                                                       count));
    }

    Status AddArc(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArc(nativePath, x, y, width, 
                                                    height, startAngle, 
                                                    sweepAngle));
    }

    Status AddArc(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArcI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    Status AddBezier(IN const PointF& pt1, 
                     IN const PointF& pt2,
                     IN const PointF& pt3, 
                     IN const PointF& pt4)
    {
        return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                         pt4.Y);
    }

    Status AddBezier(IN REAL x1, 
                     IN REAL y1, 
                     IN REAL x2, 
                     IN REAL y2,
                     IN REAL x3, 
                     IN REAL y3, 
                     IN REAL x4, 
                     IN REAL y4)
    {
        return SetStatus(DllExports::GdipAddPathBezier(nativePath, x1, y1, x2, 
                                                       y2, x3, y3, x4, y4));
    }

    Status AddBeziers(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathBeziers(nativePath, points, 
                                                        count));
    }

    Status AddBezier(IN const Point& pt1, 
                     IN const Point& pt2,
                     IN const Point& pt3, 
                     IN const Point& pt4)
    {
       return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                        pt4.Y);
    }

    Status AddBezier(IN INT x1, 
                     IN INT y1, 
                     IN INT x2, 
                     IN INT y2,
                     IN INT x3,
                     IN INT y3, 
                     IN INT x4, 
                     IN INT y4)
    {
       return SetStatus(DllExports::GdipAddPathBezierI(nativePath,
                                                      x1,
                                                      y1,
                                                      x2,
                                                      y2,
                                                      x3,
                                                      y3,
                                                      x4,
                                                      y4));
    }

    Status AddBeziers(IN const Point* points,
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathBeziersI(nativePath,
                                                        points,
                                                        count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathCurve(nativePath,
                                                      points,
                                                      count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count,
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve2(nativePath,
                                                       points,
                                                       count,
                                                       tension));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve3(nativePath,
                                                       points,
                                                       count,
                                                       offset,
                                                       numberOfSegments,
                                                       tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathCurveI(nativePath,
                                                     points,
                                                     count));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve2I(nativePath,
                                                      points,
                                                      count,
                                                      tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve3I(nativePath,
                                                      points,
                                                      count,
                                                      offset,
                                                      numberOfSegments,
                                                      tension));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve(nativePath,
                                                            points,
                                                            count));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count, 
                          IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve2(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    Status AddClosedCurve(IN const Point* points, 
                          IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurveI(nativePath,
                                                            points,
                                                            count));
    }


    Status AddClosedCurve(IN const Point* points, 
                          IN INT count,
                          IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurve2I(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    Status AddRectangle(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangle(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const RectF* rects, 
                         IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectangles(nativePath,
                                                           rects,
                                                           count));
    }

    Status AddRectangle(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangleI(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const Rect* rects, INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectanglesI(nativePath,
                                                           rects,
                                                           count));
    }

    Status AddEllipse(IN const RectF& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN REAL x, 
                      IN REAL y, 
                      IN REAL width, 
                      IN REAL height)
    {
        return SetStatus(DllExports::GdipAddPathEllipse(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status AddEllipse(IN const Rect& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN INT x, 
                      IN INT y, 
                      IN INT width, 
                      IN INT height)
    {
        return SetStatus(DllExports::GdipAddPathEllipseI(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status AddPie(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                      sweepAngle);
    }

    Status AddPie(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPie(nativePath, x, y, width,
                                                    height, startAngle, 
                                                    sweepAngle));
    }

    Status AddPie(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X,
                      rect.Y,
                      rect.Width,
                      rect.Height,
                      startAngle,
                      sweepAngle);
    }

    Status AddPie(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPieI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    Status AddPolygon(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathPolygon(nativePath, points, 
                                                        count));
    }

    Status AddPolygon(IN const Point* points, 
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathPolygonI(nativePath, points, 
                                                        count));
    }

    Status AddPath(IN const GraphicsPath* addingPath, 
                   IN BOOL connect)
    {
        GpPath* nativePath2 = NULL;
        if(addingPath)
            nativePath2 = addingPath->nativePath;

        return SetStatus(DllExports::GdipAddPathPath(nativePath, nativePath2, 
                                                     connect));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const PointF        &origin,
        IN const StringFormat  *format
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const RectF         &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const Point         &origin,
        IN const StringFormat  *format
    )
    {
        Rect rect(origin.X, origin.Y, 0, 0);

        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const Rect          &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }
    
    Status Transform(IN const Matrix* matrix)
    {
        if(matrix)
            return SetStatus(DllExports::GdipTransformPath(nativePath, 
                                                      matrix->nativeMatrix));
        else
            return Ok;
    }

    // This is not always the tightest bounds.

    Status GetBounds(OUT RectF* bounds, 
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    Status GetBounds(OUT Rect* bounds,
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    // Once flattened, the resultant path is made of line segments and
    // the original path information is lost.  When matrix is NULL the
    // identity matrix is assumed.
        
    Status Flatten(IN const Matrix* matrix = NULL, 
                   IN REAL flatness = FlatnessDefault)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
        {
            nativeMatrix = matrix->nativeMatrix;
        }

        return SetStatus(DllExports::GdipFlattenPath(
            nativePath, 
            nativeMatrix, 
            flatness
        ));
    }

    Status Widen(
        IN const Pen* pen, 
        IN const Matrix* matrix = NULL,
        IN REAL flatness = FlatnessDefault
    )
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPath(
            nativePath, 
            pen->nativePen,
            nativeMatrix, 
            flatness
        ));
    }

    Status Outline(
        IN const Matrix *matrix = NULL,
        IN REAL flatness = FlatnessDefault
    )
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
        {
            nativeMatrix = matrix->nativeMatrix;
        }

        return SetStatus(DllExports::GdipWindingModeOutline(
            nativePath, nativeMatrix, flatness
        ));
    }
    
    // Once this is called, the resultant path is made of line segments and
    // the original path information is lost.  When matrix is NULL, the 
    // identity matrix is assumed.
    
    Status Warp(IN const PointF* destPoints, 
                IN INT count,
                IN const RectF& srcRect, 
                IN const Matrix* matrix = NULL,
                IN WarpMode warpMode = WarpModePerspective,
                IN REAL flatness = FlatnessDefault)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWarpPath(
                                        nativePath,
                                        nativeMatrix,
                                        destPoints,
                                        count,
                                        srcRect.X,
                                        srcRect.Y,
                                        srcRect.Width,
                                        srcRect.Height,
                                        warpMode,
                                        flatness));
    }

    INT GetPointCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetPointCount(nativePath, &count));

        return count;
    }

    Status GetPathTypes(OUT BYTE* types, 
                        IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathTypes(nativePath, types,
                                                      count));
    }

    Status GetPathPoints(OUT PointF* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPoints(nativePath, points, 
                                                       count));
    }

    Status GetPathPoints(OUT Point* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPointsI(nativePath, points, 
                                                        count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

    BOOL IsVisible(IN const PointF& point, 
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }
    
    BOOL IsVisible(IN REAL x, 
                   IN REAL y, 
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }

    BOOL IsVisible(IN INT x, 
                   IN INT y, 
                   IN const Graphics* g = NULL) const;
    
    BOOL IsOutlineVisible(IN const PointF& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }

    BOOL IsOutlineVisible(IN REAL x, 
                          IN REAL y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

    BOOL IsOutlineVisible(IN const Point& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }
    
    BOOL IsOutlineVisible(IN INT x, 
                          IN INT y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

protected:

    GraphicsPath(const GraphicsPath& path)
    {
        GpPath *clonepath = NULL;
        SetStatus(DllExports::GdipClonePath(path.nativePath, &clonepath));
        SetNativePath(clonepath);
    }

private:
    GraphicsPath& operator=(const GraphicsPath &);

protected:
    GraphicsPath(GpPath* nativePath)
    {
        lastResult = Ok;
        SetNativePath(nativePath);
    }

    VOID SetNativePath(GpPath *nativePath)
    {
        this->nativePath = nativePath;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPath* nativePath;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// GraphisPathIterator class
//--------------------------------------------------------------------------

class GraphicsPathIterator : public GdiplusBase
{
public:

    GraphicsPathIterator(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;
        if(path)
            nativePath = path->nativePath;

        GpPathIterator *iter = NULL;
        lastResult = DllExports::GdipCreatePathIter(&iter, nativePath);
        SetNativeIterator(iter);
    }

    ~GraphicsPathIterator()
    {
        DllExports::GdipDeletePathIter(nativeIterator);
    }


    INT NextSubpath(OUT INT* startIndex,
                    OUT INT* endIndex,
                    OUT BOOL* isClosed)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextSubpath(nativeIterator,
            &resultCount, startIndex, endIndex, isClosed));

        return resultCount;
    }


    INT NextSubpath(OUT const GraphicsPath* path, 
                    OUT BOOL* isClosed)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextSubpathPath(nativeIterator,
            &resultCount, nativePath, isClosed));

        return resultCount;
    }

    INT NextPathType(OUT BYTE* pathType, 
                     OUT INT* startIndex, 
                     OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextPathType(nativeIterator,
            &resultCount, pathType, startIndex, endIndex));

        return resultCount;
    }

    INT NextMarker(OUT INT* startIndex, 
                   OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextMarker(nativeIterator,
            &resultCount, startIndex, endIndex));

        return resultCount;
    }


    INT NextMarker(OUT const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextMarkerPath(nativeIterator,
            &resultCount, nativePath));

        return resultCount;
    }

    INT GetCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetCount(nativeIterator, 
                                                   &resultCount));

        return resultCount;
    }

    INT GetSubpathCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetSubpathCount(nativeIterator, 
                                                          &resultCount));

        return resultCount;
    }

    BOOL HasCurve() const
    {
        BOOL hasCurve;

        SetStatus(DllExports::GdipPathIterHasCurve(nativeIterator, &hasCurve));

        return hasCurve;
    }

    VOID Rewind()
    {
        SetStatus(DllExports::GdipPathIterRewind(nativeIterator));
    }

    INT Enumerate(OUT PointF *points,
                  OUT BYTE *types, 
                  IN INT count)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterEnumerate(nativeIterator,
            &resultCount, points, types, count));

        return resultCount;
    }

    INT CopyData(OUT PointF* points, 
                 OUT BYTE* types,
                 IN INT startIndex, 
                 IN INT endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterCopyData(nativeIterator,
            &resultCount, points, types, startIndex, endIndex));

        return resultCount;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    GraphicsPathIterator(const GraphicsPathIterator &);
    GraphicsPathIterator& operator=(const GraphicsPathIterator &);

protected:
    VOID SetNativeIterator(GpPathIterator *nativeIterator)
    {
        this->nativeIterator = nativeIterator;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPathIterator* nativeIterator;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Path Gradient Brush
//--------------------------------------------------------------------------

class PathGradientBrush : public Brush
{
public:
    friend class Pen;

    PathGradientBrush(
        IN const PointF* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradient(
                                        points, count,
                                        wrapMode, &brush);
        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const Point* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientI(
                                        points, count,
                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const GraphicsPath* path
        )
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientFromPath(
                                        path->nativePath, &brush);
        SetNativeBrush(brush);
    }

    Status GetCenterColor(OUT Color* color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush, &argb));

        color->SetValue(argb);

        return lastResult;
    }

    Status SetCenterColor(IN const Color& color)
    {
        SetStatus(DllExports::GdipSetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush,
                       color.GetValue()));

        return lastResult;
    }

    INT GetPointCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientPointCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    INT GetSurroundColorCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    Status GetSurroundColors(OUT Color* colors, 
                             IN OUT INT* count) const
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1;
        
        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                        (GpPathGradient*) nativeBrush, &count1));

        if(lastResult != Ok)
            return lastResult;

        if((*count < count1) || (count1 <= 0))
            return SetStatus(InsufficientBuffer);

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        SetStatus(DllExports::GdipGetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
        {
            for(INT i = 0; i < count1; i++)
            {
                colors[i].SetValue(argbs[i]);
            }        
            *count = count1;
        }

        delete [] argbs;
        return lastResult;
    }

    Status SetSurroundColors(IN const Color* colors, 
                             IN OUT INT* count)
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1 = GetPointCount();

        if((*count > count1) || (count1 <= 0))
            return SetStatus(InvalidParameter);

        count1 = *count;

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        for(INT i = 0; i < count1; i++)
        {
            argbs[i] = colors[i].GetValue();
        }

        SetStatus(DllExports::GdipSetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
            *count = count1;

        delete [] argbs;

        return lastResult;
    }

    Status GetGraphicsPath(OUT GraphicsPath* path) const
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status SetGraphicsPath(IN const GraphicsPath* path)
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipSetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status GetCenterPoint(OUT PointF* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status GetCenterPoint(OUT Point* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status SetCenterPoint(IN const PointF& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status SetCenterPoint(IN const Point& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRect(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRectI(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, useGammaCorrection));
    }

    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientBlendCount(
                           (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status GetBlend(OUT REAL* blendFactors,
                    OUT REAL* blendPositions,
                    IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    INT GetInterpolationColorCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientPresetBlendCount(
                        (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        if(argbs)
        {
            for(INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::
                               GdipSetPathGradientPresetBlend(
                                    (GpPathGradient*) nativeBrush,
                                    argbs,
                                    blendPositions,
                                    count));
            delete[] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors,
                                  OUT REAL* blendPositions, 
                                  IN INT count) const
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        GpStatus status = SetStatus(DllExports::GdipGetPathGradientPresetBlend(
                                (GpPathGradient*)nativeBrush,
                                argbs,
                                blendPositions,
                                count));
        
        for(INT i = 0; i < count; i++)
        {
            presetColors[i] = Color(argbs[i]);
        }
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetPathGradientSigmaBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    {
        return SetStatus(DllExports::GdipSetPathGradientLinearBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, 
                            matrix->nativeMatrix));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, 
                            matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPathGradientTransform(
                            (GpPathGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            matrix->nativeMatrix,
                            order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            angle, order));
    }

    Status GetFocusScales(OUT REAL* xScale, 
                          OUT REAL* yScale) const
    {
        return SetStatus(DllExports::GdipGetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    Status SetFocusScales(IN REAL xScale,
                          IN REAL yScale)
    {
        return SetStatus(DllExports::GdipSetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetPathGradientWrapMode(
                     (GpPathGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetPathGradientWrapMode(
                            (GpPathGradient*) nativeBrush, wrapMode));
    }

private:
    PathGradientBrush(const PathGradientBrush &);
    PathGradientBrush& operator=(const PathGradientBrush &);

protected:

    PathGradientBrush()
    {
    }
};

#endif // !_GRAPHICSPATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluspixelformats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus Pixel Formats
*
* Abstract:
*
*   GDI+ Pixel Formats
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

// In-memory pixel data formats:
// bits 0-7 = format index
// bits 8-15 = pixel size (in bits)
// bits 16-23 = flags
// bits 24-31 = reserved

typedef INT PixelFormat;

#define    PixelFormatIndexed      0x00010000 // Indexes into a palette
#define    PixelFormatGDI          0x00020000 // Is a GDI-supported format
#define    PixelFormatAlpha        0x00040000 // Has an alpha component
#define    PixelFormatPAlpha       0x00080000 // Pre-multiplied alpha
#define    PixelFormatExtended     0x00100000 // Extended color 16 bits/channel
#define    PixelFormatCanonical    0x00200000 

#define    PixelFormatUndefined       0
#define    PixelFormatDontCare        0

#define    PixelFormat1bppIndexed     (1 | ( 1 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat4bppIndexed     (2 | ( 4 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat8bppIndexed     (3 | ( 8 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat16bppGrayScale  (4 | (16 << 8) | PixelFormatExtended)
#define    PixelFormat16bppRGB555     (5 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppRGB565     (6 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppARGB1555   (7 | (16 << 8) | PixelFormatAlpha | PixelFormatGDI)
#define    PixelFormat24bppRGB        (8 | (24 << 8) | PixelFormatGDI)
#define    PixelFormat32bppRGB        (9 | (32 << 8) | PixelFormatGDI)
#define    PixelFormat32bppARGB       (10 | (32 << 8) | PixelFormatAlpha | PixelFormatGDI | PixelFormatCanonical)
#define    PixelFormat32bppPARGB      (11 | (32 << 8) | PixelFormatAlpha | PixelFormatPAlpha | PixelFormatGDI)
#define    PixelFormat48bppRGB        (12 | (48 << 8) | PixelFormatExtended)
#define    PixelFormat64bppARGB       (13 | (64 << 8) | PixelFormatAlpha  | PixelFormatCanonical | PixelFormatExtended)
#define    PixelFormat64bppPARGB      (14 | (64 << 8) | PixelFormatAlpha  | PixelFormatPAlpha | PixelFormatExtended)
#define    PixelFormatMax             15

inline UINT
GetPixelFormatSize(
                   PixelFormat pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

inline BOOL
IsIndexedPixelFormat(
                     PixelFormat pixfmt
    )
{
    return (pixfmt & PixelFormatIndexed) != 0;
}

inline BOOL
IsAlphaPixelFormat(
                     PixelFormat pixfmt
)
{
   return (pixfmt & PixelFormatAlpha) != 0;
}

inline BOOL
IsExtendedPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatExtended) != 0;
}

//--------------------------------------------------------------------------
// Determine if the Pixel Format is Canonical format:
//   PixelFormat32bppARGB
//   PixelFormat32bppPARGB
//   PixelFormat64bppARGB
//   PixelFormat64bppPARGB
//--------------------------------------------------------------------------

inline BOOL
IsCanonicalPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatCanonical) != 0;
}

enum PaletteFlags
{
    PaletteFlagsHasAlpha    = 0x0001,
    PaletteFlagsGrayScale   = 0x0002,
    PaletteFlagsHalftone    = 0x0004
};

struct ColorPalette
{
public:
    UINT Flags;             // Palette flags
    UINT Count;             // Number of color entries
    ARGB Entries[1];        // Palette color entries
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdipluspen.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusPen.h
*
* Abstract:
*
*   GDI+ Pen class
*
\**************************************************************************/
#ifndef _GDIPLUSPEN_H
#define _GDIPLUSPEN_H

//--------------------------------------------------------------------------
// Pen class
//--------------------------------------------------------------------------

class Pen : public GdiplusBase
{
public:
    friend class GraphicsPath;
    friend class Graphics;

    Pen(IN const Color& color, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen1(color.GetValue(),
                                    width, unit, &nativePen);
    }

    Pen(IN const Brush* brush, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen2(brush->nativeBrush,
                                    width, unit, &nativePen);
    }

    ~Pen()
    {
        DllExports::GdipDeletePen(nativePen);
    }

    Pen* Clone() const
    {
        GpPen *clonePen = NULL;

        lastResult = DllExports::GdipClonePen(nativePen, &clonePen);
   
        return new Pen(clonePen, lastResult);
    }

    Status SetWidth(IN REAL width)
    {
        return SetStatus(DllExports::GdipSetPenWidth(nativePen, width));
    }

    REAL GetWidth() const
    {
        REAL width;

        SetStatus(DllExports::GdipGetPenWidth(nativePen, &width));
        
        return width;
    }
    
    // Set/get line caps: start, end, and dash

    // Line cap and join APIs by using LineCap and LineJoin enums.

    Status SetLineCap(IN LineCap startCap, 
                      IN LineCap endCap, 
                      IN DashCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenLineCap197819(nativePen, 
                                   startCap, endCap, dashCap));
    }

    Status SetStartCap(IN LineCap startCap)
    {
        return SetStatus(DllExports::GdipSetPenStartCap(nativePen, startCap));
    }

    Status SetEndCap(IN LineCap endCap)
    {
        return SetStatus(DllExports::GdipSetPenEndCap(nativePen, endCap));
    }

    Status SetDashCap(IN DashCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenDashCap197819(nativePen,
                                   dashCap));
    }

    LineCap GetStartCap() const
    {
        LineCap startCap;

        SetStatus(DllExports::GdipGetPenStartCap(nativePen, &startCap));
        
        return startCap;
    }

    LineCap GetEndCap() const
    {
        LineCap endCap;

        SetStatus(DllExports::GdipGetPenEndCap(nativePen, &endCap));

        return endCap;
    }

    DashCap GetDashCap() const
    {
        DashCap dashCap;

        SetStatus(DllExports::GdipGetPenDashCap197819(nativePen,
                            &dashCap));

        return dashCap;
    }

    Status SetLineJoin(IN LineJoin lineJoin)
    {
        return SetStatus(DllExports::GdipSetPenLineJoin(nativePen, lineJoin));
    }

    LineJoin GetLineJoin() const
    {
        LineJoin lineJoin;
        
        SetStatus(DllExports::GdipGetPenLineJoin(nativePen, &lineJoin));
        
        return lineJoin;
    }

    Status SetCustomStartCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomStartCap(nativePen, 
                                                              nativeCap));
    }

    Status GetCustomStartCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomStartCap(nativePen, 
                                                    &(customCap->nativeCap)));
    }

    Status SetCustomEndCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomEndCap(nativePen, 
                                                            nativeCap));
    }

    Status GetCustomEndCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomEndCap(nativePen, 
                                                    &(customCap->nativeCap)));
    }

    Status SetMiterLimit(IN REAL miterLimit)
    {
        return SetStatus(DllExports::GdipSetPenMiterLimit(nativePen, 
                                                    miterLimit));
    }

    REAL GetMiterLimit() const
    {
        REAL miterLimit;

        SetStatus(DllExports::GdipGetPenMiterLimit(nativePen, &miterLimit));

        return miterLimit;
    }

    Status SetAlignment(IN PenAlignment penAlignment)
    {
        return SetStatus(DllExports::GdipSetPenMode(nativePen, penAlignment));
    }

    PenAlignment GetAlignment() const
    {
        PenAlignment penAlignment;
        
        SetStatus(DllExports::GdipGetPenMode(nativePen, &penAlignment));
        
        return penAlignment;
    }
    
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPenTransform(nativePen, 
                                                       matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetPenTransform(nativePen, 
                                                         matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPenTransform(nativePen));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPenTransform(nativePen,
                                                         matrix->nativeMatrix,
                                                         order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePenTransform(nativePen,
                                                               dx, 
                                                               dy, 
                                                               order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePenTransform(nativePen,
                                                           sx, 
                                                           sy, 
                                                           order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePenTransform(nativePen,
                                                            angle, 
                                                            order));
    }

    PenType GetPenType() const
    {
       PenType type;
       SetStatus(DllExports::GdipGetPenFillType(nativePen, &type));

       return type;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetPenColor(nativePen,
                                                     color.GetValue()));
    }

    Status SetBrush(IN const Brush* brush)
    {
        return SetStatus(DllExports::GdipSetPenBrushFill(nativePen, 
                                       brush->nativeBrush));
    }

    Status GetColor(OUT Color* color) const
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        PenType type = GetPenType();

        if (type != PenTypeSolidColor) 
        {
            return WrongState;
        }
        
        ARGB argb;
        
        SetStatus(DllExports::GdipGetPenColor(nativePen,
                                              &argb));
        if (lastResult == Ok)
        {
            color->SetValue(argb);
        }
        
        return lastResult;
    }

    Brush* GetBrush() const
    {
       PenType type = GetPenType();

       Brush* brush = NULL;

       switch(type)
       {
       case PenTypeSolidColor:
           brush = new SolidBrush();
           break;

       case PenTypeHatchFill:
           brush = new HatchBrush();
           break;

       case PenTypeTextureFill:
           brush = new TextureBrush();
           break;

       case PenTypePathGradient:
           brush = new Brush();
           break;

       case PenTypeLinearGradient:
           brush = new LinearGradientBrush();
           break;

       default:
           break;
       }

       if(brush)
       {
           GpBrush* nativeBrush;

           SetStatus(DllExports::GdipGetPenBrushFill(nativePen, 
                                                     &nativeBrush));
           brush->SetNativeBrush(nativeBrush);
       }

       return brush;
    }

    DashStyle GetDashStyle() const
    {
        DashStyle dashStyle;

        SetStatus(DllExports::GdipGetPenDashStyle(nativePen, &dashStyle));

        return dashStyle;
    }

    Status SetDashStyle(IN DashStyle dashStyle)
    {
        return SetStatus(DllExports::GdipSetPenDashStyle(nativePen, 
                                                         dashStyle));
    }

    REAL GetDashOffset() const
    {
        REAL dashOffset;

        SetStatus(DllExports::GdipGetPenDashOffset(nativePen, &dashOffset));

        return dashOffset;
    }

    Status SetDashOffset(IN REAL dashOffset)
    {
        return SetStatus(DllExports::GdipSetPenDashOffset(nativePen, 
                                                          dashOffset));
    }
    
    Status SetDashPattern(IN const REAL* dashArray, IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenDashArray(nativePen,
                                                         dashArray, 
                                                         count));
    }
    
    INT GetDashPatternCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenDashCount(nativePen, &count));
        
        return count;
    }

    Status GetDashPattern(OUT REAL* dashArray, 
                          IN INT count) const
    {
        if (dashArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenDashArray(nativePen, 
                                                         dashArray, 
                                                         count));
    }

    Status SetCompoundArray(IN const REAL* compoundArray,
                            IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenCompoundArray(nativePen, 
                                                             compoundArray,
                                                             count));
    }

    INT GetCompoundArrayCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenCompoundCount(nativePen, &count));
        
        return count;
    }

    Status GetCompoundArray(OUT REAL* compoundArray, 
                            IN INT count) const
    {
        if (compoundArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenCompoundArray(nativePen, 
                                                             compoundArray, 
                                                             count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    Pen(const Pen &);
    Pen& operator=(const Pen &);

protected:
    Pen(GpPen* nativePen, Status status)
    {
        lastResult = status;
        SetNativePen(nativePen);
    }

    VOID SetNativePen(GpPen* nativePen)
    {
        this->nativePen = nativePen;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpPen* nativePen;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusmetaheader.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile headers
*
* Abstract:
*
*   GDI+ Metafile Related Structures
*
\**************************************************************************/

#ifndef _GDIPLUSMETAHEADER_H
#define _GDIPLUSMETAHEADER_H

typedef struct
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame .01mm unit
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode desc string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
} ENHMETAHEADER3;

// Placeable WMFs

// Placeable Metafiles were created as a non-standard way of specifying how 
// a metafile is mapped and scaled on an output device.
// Placeable metafiles are quite wide-spread, but not directly supported by
// the Windows API. To playback a placeable metafile using the Windows API,
// you will first need to strip the placeable metafile header from the file.
// This is typically performed by copying the metafile to a temporary file
// starting at file offset 22 (0x16). The contents of the temporary file may
// then be used as input to the Windows GetMetaFile(), PlayMetaFile(),
// CopyMetaFile(), etc. GDI functions.

// Each placeable metafile begins with a 22-byte header,
//  followed by a standard metafile:

#include <pshpack2.h>   // set structure packing to 2

typedef struct
{
    INT16           Left;
    INT16           Top;
    INT16           Right;
    INT16           Bottom;
} PWMFRect16;

typedef struct
{
    UINT32          Key;            // GDIP_WMF_PLACEABLEKEY
    INT16           Hmf;            // Metafile HANDLE number (always 0)
    PWMFRect16      BoundingBox;    // Coordinates in metafile units
    INT16           Inch;           // Number of metafile units per inch
    UINT32          Reserved;       // Reserved (always 0)
    INT16           Checksum;       // Checksum value for previous 10 WORDs
} WmfPlaceableFileHeader;

#include <poppack.h>

// Key contains a special identification value that indicates the presence
// of a placeable metafile header and is always 0x9AC6CDD7.

// Handle is used to stored the handle of the metafile in memory. When written
// to disk, this field is not used and will always contains the value 0.

// Left, Top, Right, and Bottom contain the coordinates of the upper-left
// and lower-right corners of the image on the output device. These are
// measured in twips.

// A twip (meaning "twentieth of a point") is the logical unit of measurement
// used in Windows Metafiles. A twip is equal to 1/1440 of an inch. Thus 720
// twips equal 1/2 inch, while 32,768 twips is 22.75 inches.

// Inch contains the number of twips per inch used to represent the image.
// Normally, there are 1440 twips per inch; however, this number may be
// changed to scale the image. A value of 720 indicates that the image is
// double its normal size, or scaled to a factor of 2:1. A value of 360
// indicates a scale of 4:1, while a value of 2880 indicates that the image
// is scaled down in size by a factor of two. A value of 1440 indicates
// a 1:1 scale ratio.

// Reserved is not used and is always set to 0.

// Checksum contains a checksum value for the previous 10 WORDs in the header.
// This value can be used in an attempt to detect if the metafile has become
// corrupted. The checksum is calculated by XORing each WORD value to an
// initial value of 0.

// If the metafile was recorded with a reference Hdc that was a display.

#define GDIP_EMFPLUSFLAGS_DISPLAY       0x00000001

class MetafileHeader
{
public:
    MetafileType        Type;
    UINT                Size;               // Size of the metafile (in bytes)
    UINT                Version;            // EMF+, EMF, or WMF version
    UINT                EmfPlusFlags;
    REAL                DpiX;
    REAL                DpiY;
    INT                 X;                  // Bounds in device units
    INT                 Y;
    INT                 Width;
    INT                 Height;
    union
    {
        METAHEADER      WmfHeader;
        ENHMETAHEADER3  EmfHeader;
    };
    INT                 EmfPlusHeaderSize;  // size of the EMF+ header in file
    INT                 LogicalDpiX;        // Logical Dpi of reference Hdc
    INT                 LogicalDpiY;        // usually valid only for EMF+

public:
    MetafileType GetType() const { return Type; }

    UINT GetMetafileSize() const { return Size; }

    // If IsEmfPlus, this is the EMF+ version; else it is the WMF or EMF ver
    
    UINT GetVersion() const { return Version; }

    // Get the EMF+ flags associated with the metafile
    
    UINT GetEmfPlusFlags() const { return EmfPlusFlags; }

    REAL GetDpiX() const { return DpiX; }

    REAL GetDpiY() const { return DpiY; }

    VOID GetBounds (OUT Rect *rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }
    
    // Is it any type of WMF (standard or Placeable Metafile)?
    
    BOOL IsWmf() const
    {
       return ((Type == MetafileTypeWmf) || (Type == MetafileTypeWmfPlaceable));
    }

    // Is this an Placeable Metafile?

    BOOL IsWmfPlaceable() const { return (Type == MetafileTypeWmfPlaceable); }

    // Is this an EMF (not an EMF+)?
    
    BOOL IsEmf() const { return (Type == MetafileTypeEmf); }

    // Is this an EMF or EMF+ file?
    
    BOOL IsEmfOrEmfPlus() const { return (Type >= MetafileTypeEmf); }

    // Is this an EMF+ file?
    
    BOOL IsEmfPlus() const { return (Type >= MetafileTypeEmfPlusOnly); }

    // Is this an EMF+ dual (has dual, down-level records) file?
    
    BOOL IsEmfPlusDual() const { return (Type == MetafileTypeEmfPlusDual); }

    // Is this an EMF+ only (no dual records) file?
    
    BOOL IsEmfPlusOnly() const { return (Type == MetafileTypeEmfPlusOnly); }

    // If it's an EMF+ file, was it recorded against a display Hdc?
    
    BOOL IsDisplay() const
    {
        return (IsEmfPlus() &&
                ((EmfPlusFlags & GDIP_EMFPLUSFLAGS_DISPLAY) != 0));
    }

    // Get the WMF header of the metafile (if it is a WMF)
    
    const METAHEADER * GetWmfHeader() const
    {
        if (IsWmf())
        {
            return &WmfHeader;
        }
        return NULL;
    }

    // Get the EMF header of the metafile (if it is an EMF)
    
    const ENHMETAHEADER3 * GetEmfHeader() const
    {
        if (IsEmfOrEmfPlus())
        {
            return &EmfHeader;
        }
        return NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpinit.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/25/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _GPINIT_H
#define _GPINIT_H

class GdiplusInitHelper
{
public:
    GdiplusInitHelper();
    ~GdiplusInitHelper();
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

extern GdiplusInitHelper gGdiplusInitHelper;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpinit.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects
*   (important when apps make global GDI+ objects.)
*
* Notes:
*
*   A test app should include this in *just one* of its .cpp files.
*   It should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
*   We use "#pragma code_seg()", which resets the code segment to "whatever
*   it was when compilation began" (MSDN). In other words, we stomp on whatever
*   the code segment might have been changed to before this file was included.
*   You don't need to worry about this unless you use "#pragma code_seg"
*   yourself, in the file which includes this one.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        Gdiplus::GdiplusStartupInput sti;
        if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
        {
            Valid = TRUE;
        }
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            Gdiplus::GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusregion.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusRegion.h
*
* Abstract:
*
*   GDI+ Region class implementation
*
\**************************************************************************/

#ifndef _GDIPLUSREGION_H
#define _GDIPLUSREGION_H

inline 
Region::Region()
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegion(&region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const RectF& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRect(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const Rect& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRectI(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const GraphicsPath* path)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionPath(path->nativePath, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const BYTE* regionData, IN INT size)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRgnData(regionData, size, 
                                                     &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionHrgn(hRgn, &region);

    SetNativeRegion(region);
}

inline 
Region* Region::FromHRGN(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    if (DllExports::GdipCreateRegionHrgn(hRgn, &region) == Ok)
    {
        Region* newRegion = new Region(region);

        if (newRegion == NULL) 
        {
            DllExports::GdipDeleteRegion(region);
        }

        return newRegion;
    }
    else
        return NULL;
}

inline 
Region::~Region()
{
    DllExports::GdipDeleteRegion(nativeRegion);
}

inline Region* 
Region::Clone() const
{
    GpRegion *region = NULL;

    SetStatus(DllExports::GdipCloneRegion(nativeRegion, &region));

    return new Region(region);
}

inline Status 
Region::MakeInfinite()
{
    return SetStatus(DllExports::GdipSetInfinite(nativeRegion));
}

inline Status 
Region::MakeEmpty()
{
    return SetStatus(DllExports::GdipSetEmpty(nativeRegion));
}

inline Status 
Region::Intersect(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeIntersect));
}

inline Status 
Region::Union(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeUnion));
}

inline Status 
Region::Union(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeUnion));
}

inline Status 
Region::Union(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeUnion));
}

inline Status 
Region::Union(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeUnion));
}

inline Status 
Region::Xor(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeXor));
}

inline Status 
Region::Xor(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeXor));
}

inline Status 
Region::Xor(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeXor));
}

inline Status 
Region::Xor(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeXor));
}

inline Status 
Region::Exclude(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeExclude));
}

inline Status 
Region::Exclude(IN const Rect& rect)
{
     return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                         CombineModeExclude));
}

inline Status 
Region::Exclude(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeExclude));
}

inline Status
Region::Exclude(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                               region->nativeRegion, 
                                                         CombineModeExclude));
}

inline Status 
Region::Complement(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeComplement));
}

inline Status 
Region::Complement(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeComplement));
}

inline Status 
Region::Complement(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion,
                                                path->nativePath, 
                                                CombineModeComplement));
}

inline Status 
Region::Complement(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                                  region->nativeRegion, 
                                                         CombineModeComplement));
}

inline Status 
Region::Translate(IN REAL dx, 
                  IN REAL dy)
{
    return SetStatus(DllExports::GdipTranslateRegion(nativeRegion, dx, dy));
}

inline Status 
Region::Translate(IN INT dx, 
                  IN INT dy)
{
    return SetStatus(DllExports::GdipTranslateRegionI(nativeRegion, dx, dy));
}

inline Status 
Region::Transform(IN const Matrix* matrix)
{
    return SetStatus(DllExports::GdipTransformRegion(nativeRegion, 
                                                     matrix->nativeMatrix));
}

inline Status 
Region::GetBounds(OUT RectF* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBounds(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline Status 
Region::GetBounds(OUT Rect* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBoundsI(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline HRGN
Region::GetHRGN(IN const Graphics* g) const
{
    HRGN hrgn;

    SetStatus(DllExports::GdipGetRegionHRgn(nativeRegion,
                                            g->nativeGraphics,
                                            &hrgn));

    return hrgn;
}

inline BOOL 
Region::IsEmpty(IN const Graphics *g) const
{
    BOOL booln = FALSE;
   
    SetStatus(DllExports::GdipIsEmptyRegion(nativeRegion,
                                            g->nativeGraphics,
                                            &booln));

    return booln;
}

inline BOOL 
Region::IsInfinite(IN const Graphics *g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsInfiniteRegion(nativeRegion,
                                                 g->nativeGraphics,
                                                 &booln));

    return booln;
}

inline BOOL 
Region::Equals(IN const Region* region, 
               IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsEqualRegion(nativeRegion,
                                              region->nativeRegion,
                                              g->nativeGraphics,
                                              &booln));
    return booln;
}

// Get the size of the buffer needed for the GetData method
inline UINT 
Region::GetDataSize() const
{
    UINT     bufferSize = 0;
    
    SetStatus(DllExports::GdipGetRegionDataSize(nativeRegion, &bufferSize));
    
    return bufferSize;
}

// buffer     - where to put the data
// bufferSize - how big the buffer is (should be at least as big as GetDataSize())
// sizeFilled - if not NULL, this is an OUT param that says how many bytes
//              of data were written to the buffer.
inline Status 
Region::GetData(OUT BYTE* buffer, 
                IN UINT bufferSize, 
                OUT UINT* sizeFilled) const
{
    return SetStatus(DllExports::GdipGetRegionData(nativeRegion, buffer, 
                                                   bufferSize, sizeFilled));
}

/**
 * Hit testing operations
 */
inline BOOL 
Region::IsVisible(IN const PointF& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionPoint(nativeRegion,
                                     point.X, point.Y, 
                                     (g == NULL) ? NULL : g->nativeGraphics,
                                     &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const RectF& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRect(nativeRegion, rect.X,
                                                    rect.Y, rect.Width,
                                                    rect.Height,
                                                    (g == NULL) ?
                                                      NULL : g->nativeGraphics,
                                                    &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Point& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;


    SetStatus(DllExports::GdipIsVisibleRegionPointI(nativeRegion,
                                                   point.X,
                                                   point.Y,
                                                   (g == NULL) 
                                                    ? NULL : g->nativeGraphics,
                                                   &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Rect& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRectI(nativeRegion,
                                                  rect.X,
                                                  rect.Y,
                                                  rect.Width,
                                                  rect.Height,
                                                  (g == NULL) 
                                                    ? NULL : g->nativeGraphics,
                                                  &booln));
    return booln;
}

inline UINT 
Region::GetRegionScansCount(IN const Matrix* matrix) const
{
    UINT count = 0;

    SetStatus(DllExports::GdipGetRegionScansCount(nativeRegion,
                                                  &count,
                                                  matrix->nativeMatrix));
    return count;
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
// The rects are returned in the units specified by the matrix
// (which is typically a world-to-device transform).
// Note that the number of rects returned can vary, depending on the
// matrix that is used.

inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT RectF* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScans(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

inline Status
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT Rect* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScansI(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

inline Region::Region(GpRegion* nativeRegion)
{
    SetNativeRegion(nativeRegion);
}

inline VOID Region::SetNativeRegion(GpRegion* nativeRegion)
{
    this->nativeRegion = nativeRegion;
}

inline Status Region::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

#endif // !_GDIPLUSREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\16bpp\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

#define IDB_BITMAPCMYKTEST  0x9001

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\16bpp\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
/*        if (!InitializeEngine())
        {
            MessageBox(0, _T("Engine didn't initialize"), _T("Uh oh"), MB_OK);
        }
*/
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
//        UninitializeEngine();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\anitest\anitest.cpp ===
//
// Simple test program for imaging library
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <urlmon.h>
#include <commdlg.h>

#include <imaging.h>
#include <initguid.h>
#include <imgguids.h>

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
IImagingFactory* imgfact;   // pointer to IImageingFactory object
IImage* curimage;           // pointer to IImage object
CHAR curFilename[MAX_PATH]; // current image filename
IImageDecoder *decoder;
IBitmapImage *bitmap;
ImageInfo imageinfo;
BOOL hastimedimension, loopingset, viewagain;
UINT numframes, lastsuccframe, currentframe, delay;
INT loopcount;


//
// Display an error message dialog
//

BOOL
CheckHRESULT(
    HRESULT hr,
    INT line
    )
{
    if (SUCCEEDED(hr))
        return TRUE;

    CHAR buf[1024];

    sprintf(buf, "Error on line %d: 0x%x\n", line, hr);
    MessageBoxA(hwndMain, buf, programName, MB_OK);

    return FALSE;
}

#define CHECKHR(hr) CheckHRESULT(hr, __LINE__)
#define LASTWIN32HRESULT HRESULT_FROM_WIN32(GetLastError())

#if DBG
#define VERBOSE(args) printf args
#else
#define VERBOSE(args)
#endif


//
// Helper class to convert ANSI strings to Unicode strings
//

inline BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(
                CP_ACP,
                0,
                ansiStr,
                -1,
                unicodeStr,
                unicodeSize) > 0;
}


class UnicodeStrFromAnsi
{
public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            valid = TRUE;
            unicodeStr = NULL;
        }
        else
        {
            // NOTE: we only handle strings with length < MAX_PATH.

            valid = AnsiToUnicodeStr(ansiStr, buf, MAX_PATH);
            unicodeStr = valid ? buf : NULL;
        }
    }

    BOOL IsValid() const
    {
        return valid;
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    BOOL valid;
    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};


//
// Convert current image to a bitmap image
//

IBitmapImage*
ConvertImageToBitmap(
    IImage* image,
    INT width = 0,
    INT height = 0,
    PixelFormatID pixfmt = PIXFMT_DONTCARE,
    InterpolationHint hint = INTERP_DEFAULT
    )
{
    if (!image)
        return NULL;

    HRESULT hr;
    IBitmapImage* bmp;

    hr = image->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        SIZE size;
        PixelFormatID fmt;

        // Current image is already a bitmap image and
        //  its dimension and pixel format are already as expected

        hr = bmp->GetSize(&size);
        if (!CHECKHR(hr))
            return NULL;

        hr = bmp->GetPixelFormatID(&fmt);
        if (!CHECKHR(hr))
            return NULL;

        if ((width == 0 || size.cx == width) &&
            (height == 0 || size.cy == height) &&
            (pixfmt == PIXFMT_DONTCARE || pixfmt == fmt))
        {
            return bmp;
        }

        bmp->Release();
    }

    // Convert the current image to a bitmap image

    if (width == 0 && height == 0)
    {
        ImageInfo imageInfo;
        hr = image->GetImageInfo(&imageInfo);

        // If the source image is scalable, then compute
        // the appropriate pixel dimension for the bitmap

        if (SUCCEEDED(hr) && (imageInfo.Flags & IMGFLAG_SCALABLE))
        {
            width = (INT) (96.0 * imageInfo.Width / imageInfo.Xdpi + 0.5);
            height = (INT) (96.0 * imageInfo.Height / imageInfo.Ydpi + 0.5);
        }
    }

    hr = imgfact->CreateBitmapFromImage(
                        image,
                        width, 
                        height, 
                        pixfmt,
                        hint,
                        &bmp);

    return SUCCEEDED(hr) ? bmp : NULL;
}


//
// Get pixel format strings
//

const CHAR*
GetPixelFormatStr(
    PixelFormatID pixfmt
    )
{
    switch (pixfmt)
    {
    case PIXFMT_8BPP_INDEXED:       return "8bpp indexed";
    case PIXFMT_16BPP_GRAYSCALE:    return "16bpp grayscale";
    case PIXFMT_16BPP_RGB555:       return "16bpp RGB 5-5-5";
    case PIXFMT_16BPP_RGB565:       return "16bpp RGB 5-6-5";
    case PIXFMT_16BPP_ARGB1555:     return "16bpp ARGB 1-5-5-5";
    case PIXFMT_24BPP_RGB:          return "24bpp RGB";
    case PIXFMT_32BPP_RGB:          return "32bpp RGB";
    case PIXFMT_32BPP_ARGB:         return "32bpp ARGB";
    case PIXFMT_32BPP_PARGB:        return "32bpp premultiplied ARGB";
    case PIXFMT_48BPP_RGB:          return "48bpp RGB";
    case PIXFMT_64BPP_ARGB:         return "64bpp ARGB";
    case PIXFMT_64BPP_PARGB:        return "64bpp premultiplied ARGB";
    case PIXFMT_UNDEFINED:
    default:                        return "Unknown";
    }
}

//
// Force a refresh of the image window
//

inline VOID RefreshImageDisplay()
{
    InvalidateRect(hwndMain, NULL, FALSE);

    // Update window title

    CHAR title[2*MAX_PATH];
    CHAR* p = title;

    strcpy(p, curFilename);

    SetWindowText(hwndMain, title);
}


//
// Decodes the specified frame and sets it up for drawing
//
HRESULT
DrawFrame(UINT frame)
{
    HRESULT hresult;

    if (hastimedimension)
    {
        if (numframes != -1 && frame > numframes)
        {
            return IMGERR_NOFRAME;
        }

        GUID guid = FRAMEDIM_TIME;
        hresult = decoder->SelectActiveFrame(&guid, frame);
        if (FAILED(hresult))
            return hresult;
        
        lastsuccframe = frame;
        
        IPropertySetStorage *propsetstorage;
        hresult = decoder->GetProperties(&propsetstorage);
        if (FAILED(hresult))
            propsetstorage = NULL;

        IPropertyStorage *propstorage;
        if (propsetstorage)
        {
            hresult = propsetstorage->Open(FMTID_ImageInformation, STGM_READ | 
                STGM_SHARE_EXCLUSIVE, &propstorage);
            if (FAILED(hresult))
                propstorage = NULL;
        }
        
        if (propstorage)
        {
            PROPSPEC propspec[2];
            PROPVARIANT propvariant[2];

            propspec[0].ulKind = PRSPEC_LPWSTR;
            propspec[0].lpwstr = L"Frame delay";
            propspec[1].ulKind = PRSPEC_LPWSTR;
            propspec[1].lpwstr = L"Loop count";

            hresult = propstorage->ReadMultiple(2, propspec, propvariant);
            propstorage->Release();
            if (SUCCEEDED(hresult))
            {
                if (propvariant[0].vt != VT_EMPTY)
                    delay = propvariant[0].uiVal;
                else
                    delay = 0;

                if (!loopingset)
                {
                    if (propvariant[1].vt != VT_EMPTY)
                    {
                        loopcount = propvariant[1].iVal;
                    }
                    else
                    {
                        loopcount = 0;
                    }
                    loopingset = TRUE;
                }
            }
            else
            {
                delay = 0;
            }
        }
    }
    IImageSink *sink;
    bitmap->QueryInterface(IID_IImageSink, (void**)&sink);

    hresult = decoder->BeginDecode(sink, NULL);
    sink->Release();
    if (FAILED(hresult))
        return hresult;

    hresult = decoder->Decode();
    if (FAILED(hresult))
        return hresult;

    hresult = decoder->EndDecode(S_OK);
    if (FAILED(hresult))
        return hresult;

    if (curimage)
    {
        curimage->Release();
        curimage = NULL;
    }

    bitmap->QueryInterface(IID_IImage, (void**)&curimage);

    return S_OK;
}


//
// Sets us the app for decompressing multiple frames
//

VOID
SetCurrentImage()
{
    HRESULT hresult;

    hresult = decoder->GetImageInfo(&imageinfo);
    if (FAILED(hresult))
        return;

    if (bitmap)
    {
        bitmap->Release();
        bitmap = NULL;
    }

    imgfact->CreateNewBitmap(imageinfo.Width, imageinfo.Height, PIXFMT_32BPP_ARGB, &bitmap);
    
    UINT count;
    GUID *dimensions;

    hastimedimension = FALSE;

    hresult = decoder->QueryFrameDimensions(&count, &dimensions);
    if (SUCCEEDED(hresult))
    {
        for (UINT i=0;i<count;i++)
        {
            if (dimensions[i] == FRAMEDIM_TIME)
            {
                hastimedimension = TRUE;
            }
        }
    } else if (hresult != E_NOTIMPL) {
        return;
    }

    DrawFrame(0);
    SetTimer(hwndMain, 0, delay*10, NULL);

    RefreshImageDisplay();
}


//
// Resize the window so it fits the image
//

#define MINWINWIDTH     200
#define MINWINHEIGHT    100
#define MAXWINWIDTH     1024
#define MAXWINHEIGHT    768

VOID
DoSizeWindowToFit(
    HWND hwnd,
    BOOL strict = FALSE
    )
{
    HRESULT hr;
    IBitmapImage* bmp;
    SIZE size;

    // Check if the current image is a bitmap image
    //  in that case, we'll get the pixel dimension

    hr = curimage->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->GetSize(&size);
        bmp->Release();
    }

    // Otherwise, try to get device-independent image dimension

    if (FAILED(hr))
    {
        hr = curimage->GetPhysicalDimension(&size);
        if (FAILED(hr))
            return;

        size.cx = (INT) (size.cx * 96.0 / 2540.0 + 0.5);
        size.cy = (INT) (size.cy * 96.0 / 2540.0 + 0.5);
    }

    if (SUCCEEDED(hr))
    {
        // Figure out window border dimensions

        RECT r1, r2;
        INT w, h;

        w = size.cx;
        h = size.cy;

        if (!strict)
        {
            if (w < MINWINWIDTH)
                w = MINWINWIDTH;
            else if (w > MAXWINWIDTH)
                w = MAXWINWIDTH;

            if (h < MINWINHEIGHT)
                h = MINWINHEIGHT;
            else if (h > MAXWINHEIGHT)
                h = MAXWINHEIGHT;
        }

        GetWindowRect(hwnd, &r1);
        GetClientRect(hwnd, &r2);

        w += (r1.right - r1.left) - (r2.right - r2.left);
        h += (r1.bottom - r1.top) - (r2.bottom - r2.top);

        // Resize the window

        do
        {
            SetWindowPos(
                hwnd,
                NULL,
                0, 0,
                w, h,
                SWP_NOMOVE | SWP_NOZORDER);

            GetClientRect(hwnd, &r2);
            h += GetSystemMetrics(SM_CYMENU);
        }
        while (r2.bottom == 0);
    }
}


//
// Create an image object from a file
//

VOID
OpenImageFile(
    const CHAR* filename
    )
{
    HRESULT hr;
    IStream* stream;

    // Use URLMON.DLL to turn file into stream

    CHAR fullpath[MAX_PATH];
    CHAR* p;

    if (!GetFullPathName(filename, MAX_PATH, fullpath, &p))
        return;

    hr = URLOpenBlockingStreamA(NULL, fullpath, &stream, 0, NULL);

    if (!CHECKHR(hr))
        return;

    if (decoder)
    {
        decoder->TerminateDecoder();
        decoder->Release();
        decoder = NULL;
    }

    hr = imgfact->CreateImageDecoder(stream, DECODERINIT_NONE, &decoder);
    stream->Release();

    // Set the new image as the current image

    if (CHECKHR(hr))
    {
        SetCurrentImage();
        DoSizeWindowToFit(hwndMain);
    }
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    DWORD timer;
    HRESULT hr = E_FAIL;

    hdc = BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rect);

    SetStretchBltMode(hdc, COLORONCOLOR);

    timer = GetTickCount();

    IBitmapImage* bmp;

    bmp = ConvertImageToBitmap(
                curimage,
                rect.right,
                rect.bottom,
                PIXFMT_32BPP_ARGB,
                INTERP_BICUBIC);

    if (!bmp)
        goto endPaint;

    //VERBOSE(("Stretch time: %dms, ", GetTickCount() - timer));

    IImage* image;

    hr = bmp->QueryInterface(IID_IImage, (VOID**) &image);
    bmp->Release();

    if (FAILED(hr))
        goto endPaint;
    
    //timer = GetTickCount();
    hr = image->Draw(hdc, &rect, NULL);
    //VERBOSE(("GDI time: %dms\n", GetTickCount() - timer));

    image->Release();

endPaint:

    if (FAILED(hr))
        FillRect(hdc, &rect, (HBRUSH) GetStockObject(BLACK_BRUSH));

    EndPaint(hwnd, &ps);
}


//
// Compose a file type filter string given an array of
// ImageCodecInfo structures
//

#define SizeofWSTR(s) (sizeof(WCHAR) * (wcslen(s) + 1))
#define SizeofSTR(s) (strlen(s) + 1)

CHAR*
MakeFilterFromCodecs(
    UINT count,
    const ImageCodecInfo* codecs,
    BOOL open
    )
{
    static const CHAR allFiles[] = "All Files\0*.*\0";

    // Figure out the total size of the filter string

    UINT index, size;

    for (index=size=0; index < count; index++)
    {
        size += SizeofWSTR(codecs[index].FormatDescription) +
                SizeofWSTR(codecs[index].FilenameExtension);
    }

    if (open)
        size += sizeof(allFiles);
    
    size += sizeof(CHAR);

    // Allocate memory

    CHAR *filter = (CHAR*) malloc(size);
    CHAR* p = filter;
    const WCHAR* ws;

    if (!filter)
        return NULL;

    for (index=0; index < count; index++)
    {
        ws = codecs[index].FormatDescription;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;

        ws = codecs[index].FilenameExtension;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;
    }

    if (index < count)
    {
        free(filter);
        return NULL;
    }

    if (open)
    {
        size = sizeof(allFiles);
        memcpy(p, allFiles, size);
        p += size;
    }

    *((CHAR*) p) = '\0';
    return filter;
}


//
// Open image file
//

VOID
DoOpen(
    HWND hwnd
    )
{
    OPENFILENAME ofn;
    CHAR filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = appInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    filename[0] = '\0';

    // Make up the file type filter string

    HRESULT hr;
    ImageCodecInfo* codecs;
    UINT count;

    hr = imgfact->GetInstalledDecoders(&count, &codecs);

    if (!CHECKHR(hr))
        return;

    CHAR* filter = MakeFilterFromCodecs(count, codecs, TRUE);

    if (codecs)
        CoTaskMemFree(codecs);

    if (!filter)
    {
        CHECKHR(LASTWIN32HRESULT);
        return;
    }

    ofn.lpstrFilter = filter;
    
    // Present the file/open dialog

    if (GetOpenFileName(&ofn))
        OpenImageFile(filename);

    free(filter);
}


//
//Figures out which frame to draw next and draws it.
//

void
NextFrame()
{
    BOOL tryagain = TRUE;
    while (tryagain)
    {
        tryagain = FALSE;
        HRESULT hresult = DrawFrame(currentframe);
        if (SUCCEEDED(hresult))
        {
            if (viewagain)
                currentframe++;
        }
        else if (hresult == IMGERR_NOFRAME)
        {
            if (currentframe > 0)
            {
                if (loopcount != 0)
                {
                    if (loopcount > 0)
                        loopcount--;
                    currentframe = 0;
                    tryagain = TRUE;
                }
                else
                {
                    currentframe--;
                    tryagain = TRUE;
                    viewagain = FALSE;
                }
            }
            else
            {
                printf("No frames are displayable.\n");
                exit(1);
            }
        }
    }
}

//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (uMsg)
    {
    case WM_KEYDOWN:
        //For debugging
        //NextFrame();

        //RefreshImageDisplay();
        break;
    
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_TIMER:
        {
        KillTimer(hwndMain, 0);
        
        NextFrame();
        
        RefreshImageDisplay();

        if (viewagain)
            SetTimer(hwndMain, 0, delay*10, NULL);
        break;
        }
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

#define MYWNDCLASSNAME "AniTest"

VOID
CreateMainWindow(
    VOID
    )
{
    //
    // Register window class
    //

    WNDCLASS wndClass =
    {
        CS_HREDRAW|CS_VREDRAW,
        MyWindowProc,
        0,
        0,
        appInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        NULL,
        NULL,
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (!hwndMain)
    {
        CHECKHR(HRESULT_FROM_WIN32(GetLastError()));
        exit(-1);
    }
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )
{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);
    CoInitialize(NULL);

    bitmap = NULL;
    decoder = NULL;    
    numframes = -1;
    lastsuccframe = -1;
    currentframe = 0;
    loopingset = FALSE;
    viewagain = TRUE;
    
    //
    // Create an IImagingFactory object
    //
    
    HRESULT hr;

    hr = CoCreateInstance(
            CLSID_ImagingFactory,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IImagingFactory,
            (VOID**) &imgfact);

    if (!CHECKHR(hr))
        exit(-1);

    //
    // Create the main application window
    //

    CreateMainWindow();

    //
    // Create a test image
    //

    if (argc != 0)
        OpenImageFile(*argv);
    
    if (!curimage)
        exit(-1);

    DoSizeWindowToFit(hwndMain);
    ShowWindow(hwndMain, SW_SHOW);

    //
    // Main message loop
    //

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    imgfact->Release();

    CoUninitialize();
    return (INT)(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\afxres.h ===
//
//      Copyright(c) 1996 - 1999. Microsoft Corporation.
//

// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplusstringformat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusStringFormat.h
*
* Abstract:
*
*   GDI+ StringFormat class
*
\**************************************************************************/

#ifndef _GDIPLUSSTRINGFORMAT_H
#define _GDIPLUSSTRINGFORMAT_H

class StringFormat : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;


    StringFormat(
        IN INT     formatFlags = 0,
        IN LANGID  language = LANG_NEUTRAL
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCreateStringFormat(
            formatFlags,
            language,
            &nativeFormat
        );
    }

    static const StringFormat *GenericDefault();
    static const StringFormat *GenericTypographic();

    StringFormat(
        IN const StringFormat *format
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            format ? format->nativeFormat : NULL,
            &nativeFormat
        );
    }

    StringFormat *Clone() const
    {
        GpStringFormat *clonedStringFormat = NULL;

        lastError = DllExports::GdipCloneStringFormat(
            nativeFormat,
            &clonedStringFormat
        );

        if (lastError == Ok)
            return new StringFormat(clonedStringFormat, lastError);
        else
            return NULL;
    }

    ~StringFormat()
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
    }

    Status SetFormatFlags(IN INT flags)
    {
        return SetStatus(DllExports::GdipSetStringFormatFlags(
            nativeFormat,
            flags
        ));
    }

    INT GetFormatFlags() const
    {
        INT flags;
        SetStatus(DllExports::GdipGetStringFormatFlags(nativeFormat, &flags));
        return flags;
    }

    Status SetAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetLineAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatLineAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetLineAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatLineAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetHotkeyPrefix(IN HotkeyPrefix hotkeyPrefix)
    {
        return SetStatus(DllExports::GdipSetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT)hotkeyPrefix
        ));
    }

    HotkeyPrefix GetHotkeyPrefix() const
    {
        HotkeyPrefix hotkeyPrefix;
        SetStatus(DllExports::GdipGetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT*)&hotkeyPrefix
        ));
        return hotkeyPrefix;
    }

    Status SetTabStops(
        IN REAL    firstTabOffset,
        IN INT     count,
        IN const REAL    *tabStops
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatTabStops(
            nativeFormat,
            firstTabOffset,
            count,
            tabStops
        ));
    }

    INT GetTabStopCount() const
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatTabStopCount(nativeFormat, &count));
        return count;
    }

    Status GetTabStops(
        IN INT     count,
        OUT REAL   *firstTabOffset,
        OUT REAL   *tabStops
    ) const
    {
        return SetStatus(DllExports::GdipGetStringFormatTabStops(
            nativeFormat,
            count,
            firstTabOffset,
            tabStops
        ));
    }

    Status SetDigitSubstitution(
        IN LANGID                language,
        IN StringDigitSubstitute substitute
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatDigitSubstitution(
            nativeFormat,
            language,
            substitute
        ));
    }

    LANGID GetDigitSubstitutionLanguage(
    ) const
    {
        LANGID language;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,
            &language,
            NULL
        ));
        return language;
    }

    StringDigitSubstitute GetDigitSubstitutionMethod(
    ) const
    {
        StringDigitSubstitute substitute;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,
            NULL,
            &substitute
        ));
        return substitute;
    }

    Status SetTrimming(IN StringTrimming trimming)
    {
        return SetStatus(DllExports::GdipSetStringFormatTrimming(
            nativeFormat,
            trimming
        ));
    }

    StringTrimming StringFormat::GetTrimming() const
    {
        StringTrimming trimming;
        SetStatus(DllExports::GdipGetStringFormatTrimming(
            nativeFormat,
            &trimming
        ));
        return trimming;
    }

    Status SetMeasurableCharacterRanges(
        IN INT                  rangeCount,
        IN const CharacterRange *ranges
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatMeasurableCharacterRanges(
            nativeFormat,
            rangeCount,
            ranges
        ));
    }

    INT GetMeasurableCharacterRangeCount()
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatMeasurableCharacterRangeCount(
            nativeFormat,
            &count
        ));
        return count;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastError;
        lastError = Ok;

        return lastStatus;
    }

protected:

    Status SetStatus(GpStatus newStatus) const
    {
        if (newStatus == Ok)
        {
            return Ok;
        }
        else
        {
            return lastError = newStatus;
        }
    }

    StringFormat(const StringFormat &source)
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
    }

    StringFormat& operator=(const StringFormat &source)
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
        return *this;
    }

    StringFormat(GpStringFormat * clonedStringFormat, Status status)
    {
        lastError = status;
        nativeFormat = clonedStringFormat;

    }

    GpStringFormat *nativeFormat;
    mutable Status  lastError;
};

static BYTE GenericTypographicStringFormatBuffer[sizeof(StringFormat)] = {0};
static BYTE GenericDefaultStringFormatBuffer[sizeof(StringFormat)] = {0};

inline const StringFormat *StringFormat::GenericDefault()
{
    StringFormat * genericDefaultStringFormat =
        (StringFormat*)GenericDefaultStringFormatBuffer;

    genericDefaultStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericDefault(
            &(genericDefaultStringFormat->nativeFormat)
        );

    return genericDefaultStringFormat;
}

inline const StringFormat *StringFormat::GenericTypographic()
{
    StringFormat * genericTypographicStringFormat =
        (StringFormat*)GenericTypographicStringFormatBuffer;

    genericTypographicStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericTypographic(
            &genericTypographicStringFormat->nativeFormat
        );

    return genericTypographicStringFormat;
}

#endif // !_GDIPLUSSTRINGFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sdkinc\gdiplustypes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusTypes.h
*
* Abstract:
*
*   GDI+ Types
*
\**************************************************************************/

#ifndef _GDIPLUSTYPES_H
#define _GDIPLUSTYPES_H

//--------------------------------------------------------------------------
// Callback functions
//--------------------------------------------------------------------------

extern "C" {
typedef BOOL (CALLBACK * ImageAbort)(VOID *);
typedef ImageAbort DrawImageAbort;
typedef ImageAbort GetThumbnailImageAbort;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      WMF, EMF, or EMF+ record type
//      flags           (always 0 for WMF/EMF records)
//      dataSize        size of the record data (in bytes), or 0 if no data
//      data            pointer to the record data, or NULL if no data
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the
// record that was just enumerated.  If this method  returns
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C" {
typedef BOOL (CALLBACK * EnumerateMetafileProc)(EmfPlusRecordType,UINT,UINT,const BYTE*,VOID*);
}

//--------------------------------------------------------------------------
// Primitive data types
//
// NOTE:
//  Types already defined in standard header files:
//      INT8
//      UINT8
//      INT16
//      UINT16
//      INT32
//      UINT32
//      INT64
//      UINT64
//
//  Avoid using the following types:
//      LONG - use INT
//      ULONG - use UINT
//      DWORD - use UINT32
//--------------------------------------------------------------------------

typedef float REAL;

#define REAL_MAX            FLT_MAX
#define REAL_MIN            FLT_MIN
#define REAL_TOLERANCE     (FLT_MIN * 100)
#define REAL_EPSILON        1.192092896e-07F        /* FLT_EPSILON */

//--------------------------------------------------------------------------
// Forward declarations of common classes
//--------------------------------------------------------------------------

class Size;
class SizeF;
class Point;
class PointF;
class Rect;
class RectF;
class CharacterRange;

//--------------------------------------------------------------------------
// Status return values from GDI+ methods
//--------------------------------------------------------------------------

enum Status
{
    Ok = 0,
    GenericError = 1,
    InvalidParameter = 2,
    OutOfMemory = 3,
    ObjectBusy = 4,
    InsufficientBuffer = 5,
    NotImplemented = 6,
    Win32Error = 7,
    WrongState = 8,
    Aborted = 9,
    FileNotFound = 10,
    ValueOverflow = 11,
    AccessDenied = 12,
    UnknownImageFormat = 13,
    FontFamilyNotFound = 14,
    FontStyleNotFound = 15,
    NotTrueTypeFont = 16,
    UnsupportedGdiplusVersion = 17,
    GdiplusNotInitialized = 18,
    PropertyNotFound = 19,
    PropertyNotSupported = 20
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class SizeF
{
public:
    SizeF()
    {
        Width = Height = 0.0f;
    }

    SizeF(IN const SizeF& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    SizeF(IN REAL width,
          IN REAL height)
    {
        Width = width;
        Height = height;
    }

    SizeF operator+(IN const SizeF& sz) const
    {
        return SizeF(Width + sz.Width,
                     Height + sz.Height);
    }

    SizeF operator-(IN const SizeF& sz) const
    {
        return SizeF(Width - sz.Width,
                     Height - sz.Height);
    }

    BOOL Equals(IN const SizeF& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0.0f && Height == 0.0f);
    }

public:

    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Size
{
public:
    Size()
    {
        Width = Height = 0;
    }

    Size(IN const Size& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    Size(IN INT width,
         IN INT height)
    {
        Width = width;
        Height = height;
    }

    Size operator+(IN const Size& sz) const
    {
        return Size(Width + sz.Width,
                    Height + sz.Height);
    }

    Size operator-(IN const Size& sz) const
    {
        return Size(Width - sz.Width,
                    Height - sz.Height);
    }

    BOOL Equals(IN const Size& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0 && Height == 0);
    }

public:

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class PointF
{
public:
   PointF()
   {
       X = Y = 0.0f;
   }

   PointF(IN const PointF &point)
   {
       X = point.X;
       Y = point.Y;
   }

   PointF(IN const SizeF &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   PointF(IN REAL x,
          IN REAL y)
   {
       X = x;
       Y = y;
   }

   PointF operator+(IN const PointF& point) const
   {
       return PointF(X + point.X,
                     Y + point.Y);
   }

   PointF operator-(IN const PointF& point) const
   {
       return PointF(X - point.X,
                     Y - point.Y);
   }

   BOOL Equals(IN const PointF& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    REAL X;
    REAL Y;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Point
{
public:
   Point()
   {
       X = Y = 0;
   }

   Point(IN const Point &point)
   {
       X = point.X;
       Y = point.Y;
   }

   Point(IN const Size &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   Point(IN INT x,
         IN INT y)
   {
       X = x;
       Y = y;
   }

   Point operator+(IN const Point& point) const
   {
       return Point(X + point.X,
                    Y + point.Y);
   }

   Point operator-(IN const Point& point) const
   {
       return Point(X - point.X,
                    Y - point.Y);
   }

   BOOL Equals(IN const Point& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    INT X;
    INT Y;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class RectF
{
public:

    RectF()
    {
        X = Y = Width = Height = 0.0f;
    }

    RectF(IN REAL x,
          IN REAL y,
          IN REAL width,
          IN REAL height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    RectF(IN const PointF& location,
          IN const SizeF& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    RectF* Clone() const
    {
        return new RectF(X, Y, Width, Height);
    }

    VOID GetLocation(OUT PointF* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT SizeF* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT RectF* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    REAL GetLeft() const
    {
        return X;
    }

    REAL GetTop() const
    {
        return Y;
    }

    REAL GetRight() const
    {
        return X+Width;
    }

    REAL GetBottom() const
    {
        return Y+Height;
    }

    BOOL IsEmptyArea() const
    {
        return (Width <= REAL_EPSILON) || (Height <= REAL_EPSILON);
    }

    BOOL Equals(IN const RectF & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN REAL x,
                  IN REAL y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const PointF& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN const RectF& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN REAL dx,
                 IN REAL dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const PointF& point)
    {
        Inflate(point.X, point.Y);
    }

    BOOL Intersect(IN const RectF& rect)
    {
        return Intersect(*this, *this, rect);
    }

    static BOOL Intersect(OUT RectF& c,
                          IN const RectF& a,
                          IN const RectF& b)
    {
        REAL right = min(a.GetRight(), b.GetRight());
        REAL bottom = min(a.GetBottom(), b.GetBottom());
        REAL left = max(a.GetLeft(), b.GetLeft());
        REAL top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    BOOL IntersectsWith(IN const RectF& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT RectF& c,
                      IN const RectF& a,
                      IN const RectF& b)
    {
        REAL right = max(a.GetRight(), b.GetRight());
        REAL bottom = max(a.GetBottom(), b.GetBottom());
        REAL left = min(a.GetLeft(), b.GetLeft());
        REAL top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const PointF& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN REAL dx,
                IN REAL dy)
    {
        X += dx;
        Y += dy;
    }

public:

    REAL X;
    REAL Y;
    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Rect
{
public:

    Rect()
    {
        X = Y = Width = Height = 0;
    }

    Rect(IN INT x,
         IN INT y,
         IN INT width,
         IN INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    Rect(IN const Point& location,
         IN const Size& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    Rect* Clone() const
    {
        return new Rect(X, Y, Width, Height);
    }

    VOID GetLocation(OUT Point* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT Size* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT Rect* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }

    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    BOOL IsEmptyArea() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    BOOL Equals(IN const Rect & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN INT x,
                  IN INT y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const Point& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN Rect& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN INT dx,
                 IN INT dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const Point& point)
    {
        Inflate(point.X, point.Y);
    }

    BOOL Intersect(IN const Rect& rect)
    {
        return Intersect(*this, *this, rect);
    }

    static BOOL Intersect(OUT Rect& c,
                          IN const Rect& a,
                          IN const Rect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    BOOL IntersectsWith(IN const Rect& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT Rect& c,
                      IN const Rect& a,
                      IN const Rect& b)
    {
        INT right = max(a.GetRight(), b.GetRight());
        INT bottom = max(a.GetBottom(), b.GetBottom());
        INT left = min(a.GetLeft(), b.GetLeft());
        INT top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const Point& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN INT dx,
                IN INT dy)
    {
        X += dx;
        Y += dy;
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

class PathData
{
public:
    PathData()
    {
        Count = 0;
        Points = NULL;
        Types = NULL;
    }

    ~PathData()
    {
        if (Points != NULL)
        {
            delete Points;
        }

        if (Types != NULL)
        {
            delete Types;
        }
    }

private:
    PathData(const PathData &);
    PathData& operator=(const PathData &);

public:
    INT Count;
    PointF* Points;
    BYTE* Types;
};

class CharacterRange
{
public:
    CharacterRange(
        INT first,
        INT length
    ) :
        First   (first),
        Length  (length)
    {}

    CharacterRange() : First(0), Length(0)
    {}

    CharacterRange & operator = (const CharacterRange &rhs)
    {
        First  = rhs.First;
        Length = rhs.Length;
        return *this;
    }

    INT First;
    INT Length;
};

#endif // !_GDIPLUSTYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\16bpp\16bpp.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46          
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include <stdio.h>
#include "wndstuff.h"

#include <gdiplus.h>

using namespace Gdiplus;

enum SurfaceFormat {
    SurfaceFormatUnknown,
    SurfaceFormat565,
    SurfaceFormat555
};

/**************************************************************************\
* GetSurfaceFormat
* 
* Returns:
*   Returns the display mode, or
*   SurfaceFormatUnknown if unknown or on error.
*
*   Only recognizes 555 and 565.
*
\**************************************************************************/

SurfaceFormat
GetSurfaceFormat(
    HDC hdc
    )
{
    HBITMAP hbm;
    SurfaceFormat ret = SurfaceFormatUnknown;
    
    BYTE bmi_buf[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) bmi_buf;
    
    memset(bmi_buf, 0, sizeof(bmi_buf));
    
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        // Call first time to fill in BITMAPINFO header.

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        // First handle the 'simple' case of indexed formats.
        
        if (   (pbmi->bmiHeader.biBitCount == 16)
            && ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
            DWORD redMask = 0;
            DWORD greenMask = 0;
            DWORD blueMask = 0;
            
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".

            GetDIBits(
                hdc, 
                hbm, 
                0, 
                pbmi->bmiHeader.biHeight, 
                NULL, 
                pbmi,
                DIB_RGB_COLORS
            );
                      
            DWORD* masks = reinterpret_cast<DWORD*>(&pbmi->bmiColors[0]);

            redMask = masks[0];
            greenMask = masks[1];
            blueMask = masks[2];          
            
            if ((redMask   == 0x0000f800) &&
                (greenMask == 0x000007e0) &&
                (blueMask  == 0x0000001f) &&
                (pbmi->bmiHeader.biBitCount == 16))
            {
                ret = SurfaceFormat565;
            }
            if ((redMask   == 0x00007c00) &&
                (greenMask == 0x000003e0) &&
                (blueMask  == 0x0000001f) &&
                (pbmi->bmiHeader.biBitCount == 16))
            {
                ret = SurfaceFormat555;
            }
        }

        DeleteObject(hbm);
    }

    return ret;
}


static HBITMAP CreateMyDIB(HDC hdcin, PVOID *ppvBits) {
    // these combined give BITMAPINFO structure.
    struct {
        BITMAPINFOHEADER bmih;
        RGBQUAD rgbquad16[3];
    } bmi;

    bmi.bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmih.biWidth = 8;
    bmi.bmih.biHeight = 8;
    bmi.bmih.biPlanes = 1;
    bmi.bmih.biBitCount = 16;
    bmi.bmih.biCompression = BI_BITFIELDS;
    bmi.bmih.biSizeImage = 0;
    bmi.bmih.biXPelsPerMeter = 0;
    bmi.bmih.biYPelsPerMeter = 0;
    bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
    bmi.bmih.biClrImportant = 0;

    RGBQUAD rgbQuad16[3] = { { 0, 0xf8, 0, 0 }, { 0xe0, 07, 0, 0 }, { 0x1f, 0, 0, 0 } };

    memcpy(bmi.rgbquad16, rgbQuad16, sizeof(rgbQuad16));
    
    HBITMAP hbitmap;
    
    hbitmap = CreateDIBSection(
        hdcin,
        (BITMAPINFO*)&bmi,
        DIB_RGB_COLORS,
        ppvBits,
        NULL,
        0);
        
    return hbitmap;
}

static int sysColorNum[4] = {
    COLOR_3DSHADOW,
    COLOR_3DFACE,
    COLOR_3DHIGHLIGHT,
    COLOR_DESKTOP
};

static void DumpBitmap(FILE *fp, WORD *pBits) {
    WORD * pBits2 = pBits;

    WORD col = *pBits2++;
    int count;
    for (count = 1;count < 64; count++) {
        if (col != *pBits2++) break;
    }
    if (count == 64) {
        fprintf(fp, "      Solid %04x\n\n", col);
    } else {
        int i,j;
        for (i=0;i<8;i++) {
            fprintf(fp, "      ");
            for (j=0;j<8;j++) {
                fprintf(fp, "%04x ", *pBits++);
            }
            fprintf(fp, "\n");
        }
        fprintf(fp, "\n");
    }
}

static void DumpColor(FILE *fp, Color &c) {
    fprintf(fp, "(%02x, %02x, %02x)", c.GetRed(), c.GetGreen(), c.GetBlue());
}

VOID
Test(
    HWND hwnd
    )
{
    HDC hdc = NULL;
    Graphics *g = NULL;
    HBITMAP hbm = NULL;
    HDC hdcOffscreen = NULL;
    HBITMAP bmOld = NULL;
    PVOID pvBits = NULL;
    FILE *fp = NULL;
    SurfaceFormat format = SurfaceFormatUnknown;
    
    Rect rect1(
        0, 
        40, 
        8,
        8
    );
    
    Rect rect2(
        0, 
        0, 
        8,
        8
    );
    
    hdc = GetDC(hwnd);
    g = new Graphics(hdc);
    
    {
        HDC h = g->GetHDC();
        format = GetSurfaceFormat(h);
    
        if (   (format == SurfaceFormat555)
            || (format == SurfaceFormat565)) {
            
            hbm = CreateMyDIB(h, &pvBits);
            hdcOffscreen = CreateCompatibleDC(h);
            bmOld = (HBITMAP) SelectObject(hdcOffscreen, hbm);
        } else {
            printf("Error: Display doesn't seem to be in 16bpp\n");
            g->ReleaseHDC(h);
            goto ErrorOut;
        }
        g->ReleaseHDC(h);
    }
    
    fp = fopen("output.txt", "w");
    fprintf(fp, 
        "The 16bpp mode on this machine is in %s format.\n\n"
        "This is test output for examining rendering to 16bpp (555/565) destinations,\n"
        "and comparing Win9x with NT output.\n"
        "Related bugs: #294433, #292492, #298264, #298283, #351610, #321960.\n"
        "We use 3*256 test colors; for each channel, one test color for each possible\n"
        "0-255 level.\n"
        "This output has 2 sections.\n\n"

        "--------------------------------------------------------------------------------\n"
        "SECTION 1: GetNearestColor\n"
        "Shows the result of calling GetNearestColor on that color. For section 2, we\n"
        "also remember which colors were the result of a GetNearestColor call.\n"
        "\n",
        (format == SurfaceFormat555) ? "555" : "565"
    );
    
    int num;
    
    const int numColors = 256 * 3;
    
    BYTE colors[numColors][3];
    BOOL isNearest[numColors];

    for (num=0; num < numColors; num++) {
        isNearest[num] = FALSE;
    }
    
    for (num=0; num < numColors; num++) {
        colors[num][0] = 0;
        colors[num][1] = 0;
        colors[num][2] = 0;
        
        int chnum = num / 256;
        
        colors[num][chnum] = (BYTE) (num % 256);
        
        Color color(colors[num][0], colors[num][1], colors[num][2]);
        Color color2(colors[num][0], colors[num][1], colors[num][2]);
        g->GetNearestColor(&color2);
        
        BYTE nc[3];
        nc[0] = color2.GetRed();
        nc[1] = color2.GetGreen();
        nc[2] = color2.GetBlue();
        
        int nearestIdx = nc[chnum] + 256*chnum;
        nc[chnum] = 0;
        if ((nc[0] != 0) ||
            (nc[1] != 0) ||
            (nc[2] != 0) ||
            (nearestIdx < 0) ||
            (nearestIdx >= numColors))
        {
            fprintf(fp, "UNEXPECTED: ");
        }
        else
        {
            isNearest[nearestIdx] = TRUE;
        }
        fprintf(fp, "GetNearestColor(");
        DumpColor(fp, color);
        fprintf(fp, ") == ");
        DumpColor(fp, color2);
        fprintf(fp, "\n");
    }

    fprintf(fp, 
        "\n--------------------------------------------------------------------------------\n"
        "SECTION 2: FillRect\n"
        "Shows the result of calling FillRectangle of an 8x8 rectangle using the input\n"
        "color. If all 64 pixels are the same, we say \"Solid xxxx\" with the resulting\n"
        "16-bit value. Otherwise, all 64 pixels are reported.\n"
        "\n"
        "* next to the color means that GetNearestColor can return this color.\n"
        "\n"
    );
    
    for (num=0; num < numColors; num++) {
        Color color(colors[num][0], colors[num][1], colors[num][2]);
        
        fprintf(fp, "%sColor: ", isNearest[num]?"* ":"  ");
        DumpColor(fp, color);
        fprintf(fp, "\n");
        
        SolidBrush solidBrush1(color);
        
        fprintf(fp, "    GDI+ FillRectangle to screen (uses GDI CreateSolidBrush & PatBlt):\n");
        
        {
            g->FillRectangle(&solidBrush1, rect1);
            HDC hdcGraphics = g->GetHDC();
            BitBlt(hdcOffscreen, 0, 0, rect1.Width, rect1.Height, hdcGraphics, rect1.X, rect1.Y, SRCCOPY);
            g->ReleaseHDC(hdcGraphics);
        }

        DumpBitmap(fp, (WORD *) pvBits);
        
        fprintf(fp, "    GDI+ FillRectangle to DIBSection (uses GDI+ dithering):\n");
        
        {
            Graphics g2(hdcOffscreen);
            g2.FillRectangle(&solidBrush1, rect2);
        }

        DumpBitmap(fp, (WORD *) pvBits);
    }
    
ErrorOut:
    if (fp) fclose(fp);
    
    if (bmOld) SelectObject(hdcOffscreen, bmOld);                  
    if (hdcOffscreen) DeleteDC(hdcOffscreen);
    if (hbm) DeleteObject(hbm);

    delete g;
        
    if (hdc) ReleaseDC(hwnd, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\brush.cpp ===
////    brush.cpp - brush type tests
//
//


#include "precomp.hpp"
#include "global.h"
#include "gdiplus.h"




/////   Brush tests
//
//      Test combinations of foreground background and rotation that
//      affect rendering codepaths.


INT BrushTest::GetPageCount()
{
    return 5;
}




void BrushTest::GetPageTitle(INT pageNumber, WCHAR *title)
{
    title[0] = 0;

    wcscat(title, L"AutoText brush test, page settings: ");

    switch (pageNumber)
    {
    case 0: wcscat(title, L"1bpp Grid fit.");                 break;
    case 1: wcscat(title, L"1bpp.");                          break;
    case 2: wcscat(title, L"Anti alias grid fit.");           break;
    case 3: wcscat(title, L"Anti alias.");                    break;
    case 4: wcscat(title, L"ClearType compatible grid fit."); break;
    }
}


///     DrawPage - draw one page of the test
//
//

void BrushTest::DrawPage(
    IN Graphics *graphics,
    IN INT       pageNumber,
    IN REAL      pageWidth,
    IN REAL      pageHeight
)
{
    PageLayout pageLayout(pageWidth, pageHeight, 10, 10);

    SolidBrush solidBlack (Color(0x00, 0x00, 0x00));
    SolidBrush solidDark  (Color(0x80, 0x80, 0x80));
    SolidBrush solidLight (Color(0xc0, 0xc0, 0xc0));
    SolidBrush solidWhite (Color(0xf0, 0xf0, 0xf0));
    SolidBrush lucentBlack(Color(0x80, 0x00, 0x00, 0x00));
    SolidBrush lucentDark (Color(0x80, 0x80, 0x80, 0x80));
    SolidBrush lucentLight(Color(0x80, 0xc0, 0xc0, 0xc0));
    SolidBrush lucentWhite(Color(0x80, 0xf0, 0xf0, 0xf0));

    Pen blackPen(&solidBlack, 1.0);

    Font titleFont(
        &FontFamily(L"Microsoft Sans Serif"),
        9,
        0,
        UnitPoint
    );


    // Set page rendering hint

    switch (pageNumber)
    {
    case 0: graphics->SetTextRenderingHint(TextRenderingHintSingleBitPerPixelGridFit); break;
    case 1: graphics->SetTextRenderingHint(TextRenderingHintSingleBitPerPixel);        break;
    case 2: graphics->SetTextRenderingHint(TextRenderingHintAntiAliasGridFit);         break;
    case 3: graphics->SetTextRenderingHint(TextRenderingHintAntiAlias);                break;
    case 4: graphics->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);         break;
    }


    // Page title

    WCHAR title[200];
    RectF titleRect;
    StringFormat titleFormat(StringFormat::GenericDefault());
    titleFormat.SetAlignment(StringAlignmentCenter);
    titleFormat.SetLineAlignment(StringAlignmentCenter);

    pageLayout.GetFooterRect(&titleRect);

    Font pageTitleFont(L"Microsoft Sans Serif", 12, FontStyleBold);

    GetPageTitle(pageNumber, title);
    graphics->DrawString(
        title,
        -1,
        &pageTitleFont,
        titleRect,
        &titleFormat,
        &solidBlack
    );

    // Column titles

    for (INT column=0; column<10; column++)
    {
        // Row title

        title[0] = 0;
        switch (column)
        {
        case 0: wcscat(title, L"solid black foregrnd");  break;
        case 1: wcscat(title, L"solid dark foregrnd");   break;
        case 2: wcscat(title, L"solid light foregrnd");  break;
        case 3: wcscat(title, L"solid white foregrnd");  break;
        case 4: wcscat(title, L"solid grdnt foregrnd");  break;
        case 5: wcscat(title, L"lucent black foregrnd"); break;
        case 6: wcscat(title, L"lucent dark foregrnd");  break;
        case 7: wcscat(title, L"lucent light foregrnd"); break;
        case 8: wcscat(title, L"lucent white foregrnd"); break;
        case 9: wcscat(title, L"lucent grdnt foregrnd"); break;
        }

        pageLayout.GetColumnTitleRect(column, &titleRect);
        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &solidBlack
        );
    }

    Font font(
        &FontFamily(L"Times New Roman"),
        9,
        0,
        UnitPoint
    );



    // The test rows

    for (INT row=0; row<10; row++)
    {
        Brush *background;

        switch (row)
        {
        // Solid brushes

        case 0: background = &solidBlack; break;
        case 1: background = &solidDark;  break;
        case 2: background = &solidLight; break;
        case 3: background = &solidWhite; break;

        // 50% alpha brushes

        case 5: background = &lucentBlack; break;
        case 6: background = &lucentDark;  break;
        case 7: background = &lucentLight; break;
        case 8: background = &lucentWhite; break;

        // Linear gradient brushes created separately for each item
        }


        // Row title

        title[0] = 0;
        switch (row)
        {
        case 0: wcscat(title, L"solid black backgrnd");  break;
        case 1: wcscat(title, L"solid dark backgrnd");   break;
        case 2: wcscat(title, L"solid light backgrnd");  break;
        case 3: wcscat(title, L"solid white backgrnd");  break;
        case 4: wcscat(title, L"solid grdnt backgrnd");  break;
        case 5: wcscat(title, L"lucent black backgrnd"); break;
        case 6: wcscat(title, L"lucent dark backgrnd");  break;
        case 7: wcscat(title, L"lucent light backgrnd"); break;
        case 8: wcscat(title, L"lucent white backgrnd"); break;
        case 9: wcscat(title, L"lucent grdnt backgrnd"); break;
        }

        pageLayout.GetRowTitleRect(row, &titleRect);
        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &solidBlack
        );

        for (INT column=0; column<10; column++)
        {
            RectF itemRect;
            pageLayout.GetItemRect(column, row, &itemRect);

            switch (row)
            {
            // Linear gradient brushes

            case 4:
                background = new LinearGradientBrush(
                    itemRect,
                    Color(0x00, 0x00, 0x00),
                    Color(0xff, 0xff, 0xff),
                    LinearGradientModeVertical
                );
                break;

            case 9:
                background = new LinearGradientBrush(
                    itemRect,
                    Color(0x80, 0x00, 0x00, 0x00),
                    Color(0x80, 0xff, 0xff, 0xff),
                    LinearGradientModeVertical
                );
                break;
            }


            Brush *foreground;

            switch (column)
            {
            // Solid brushes

            case 0: foreground = &solidBlack; break;
            case 1: foreground = &solidDark;  break;
            case 2: foreground = &solidLight; break;
            case 3: foreground = &solidWhite; break;

            // 50% alpha brushes

            case 5: foreground = &lucentBlack; break;
            case 6: foreground = &lucentDark;  break;
            case 7: foreground = &lucentLight; break;
            case 8: foreground = &lucentWhite; break;

            // Linear gradient brushes

            case 4:
                foreground = new LinearGradientBrush(
                    itemRect,
                    Color(0x00, 0x00, 0x00),
                    Color(0xff, 0xff, 0xff),
                    LinearGradientModeHorizontal
                );
                break;

            case 9:
                foreground = new LinearGradientBrush(
                    itemRect,
                    Color(0x80, 0x00, 0x00, 0x00),
                    Color(0x80, 0xff, 0xff, 0xff),
                    LinearGradientModeHorizontal
                );
                break;
            }


            graphics->FillRectangle(background, itemRect);
            graphics->DrawRectangle(&blackPen, itemRect);

            graphics->DrawString(
                L"There was an Old Man of the Coast\n\
Who placidly sat on a post;\n\
But when it was cold,\n\
He relinquished his hold,\n\
And called for some hot buttered toast.\n",
                -1,
                &font,
                itemRect,
                NULL,
                foreground
            );

            switch (row)
            {
            case 4: case 9: delete background;
            }
            switch (column)
            {
            case 4: case 9: delete foreground;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\family.cpp ===
////    family.cpp - String format tests
//
//


#include "precomp.hpp"
#include "global.h"
#include "gdiplus.h"




/////   Family tests
//
//      Test combinations of style with each family
//
//      2 rows for each family using all style combinations
//
//      6 families per page


void GetInstalledFamilies()
{
    InstalledFontCollection installedFonts;

    G.InstalledFamilyCount = installedFonts.GetFamilyCount();

    G.InstalledFamilies = new FontFamily[G.InstalledFamilyCount];
    installedFonts.GetFamilies(
        G.InstalledFamilyCount,
        G.InstalledFamilies,
        &G.InstalledFamilyCount
    );
}

void ReleaseInstalledFamilies()
{
    G.InstalledFamilyCount = 0;
    delete [] G.InstalledFamilies;
}


INT FamilyTest::GetPageCount()
{
    return (G.InstalledFamilyCount + 5) / 6;
}


void FamilyTest::GetPageTitle(INT pageNumber, WCHAR *title)
{
    title[0] = 0;
    wcscat(title, L"AutoText family test.");
}


Font *GetItemFont(INT page, INT row, INT column)
{
    INT familyIndex = page*6 + row/2;

    if (familyIndex < G.InstalledFamilyCount)
    {
        return new Font(
            G.InstalledFamilies + familyIndex,
            9,
            FontStyle(((row & 1) << 4) + column),
            UnitPoint
        );
    }
    else
    {
        return NULL;
    }
}




///     DrawPage - draw one page of the test
//
//

void FamilyTest::DrawPage(
    IN Graphics *graphics,
    IN INT       page,
    IN REAL      pageWidth,
    IN REAL      pageHeight
)
{
    PageLayout pageLayout(pageWidth, pageHeight, 8, 12);

    SolidBrush blackBrush(Color(0, 0, 0));
    Pen        blackPen(&blackBrush, 1.0);


    // Display title at bottom of page

    StringFormat titleFormat(StringFormat::GenericDefault());
    titleFormat.SetAlignment(StringAlignmentCenter);
    titleFormat.SetLineAlignment(StringAlignmentCenter);

    RectF titleRect;
    pageLayout.GetFooterRect(&titleRect);

    Font pageTitleFont(L"Microsoft Sans Serif", 12, FontStyleBold);

    WCHAR title[200];

    GetPageTitle(page, title);

    graphics->DrawString(
        title,
        -1,
        &pageTitleFont,
        titleRect,
        &titleFormat,
        &blackBrush
    );


    // Display row titles

    Font titleFont(
        &FontFamily(L"Microsoft Sans Serif"),
        9,
        0,
        UnitPoint
    );

    for (INT i=0; i<12; i++)
    {
        pageLayout.GetRowTitleRect(i, &titleRect);

        Font *rowFont = GetItemFont(page, i, 3);    // bold/italic available if any are!
        if (rowFont)
        {
            FontFamily rowFamily;
            rowFont->GetFamily(&rowFamily);
            delete rowFont;

            rowFamily.GetFamilyName(title);

            graphics->DrawString(
                title,
                -1,
                &titleFont,
                titleRect,
                &titleFormat,
                &blackBrush
            );
        }
    }


    // Display column titles


    for (INT i=0; i<8; i++)
    {
        pageLayout.GetColumnTitleRect(i, &titleRect);

        title[0] = 0;

        if (i==0)
        {
            wcscat(title, L"regular");
        }
        else
        {
            if (i & 1)
            {
                wcscat(title, L"bold ");
            }

            if (i & 2)
            {
                wcscat(title, L"italic ");
            }

            if (i & 4)
            {
                wcscat(title, L"underline ");
            }
        }

        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &blackBrush
        );
    }


    // Prepare common string format for this page

    StringFormat stringFormat(StringFormat::GenericDefault());


    // The tests themselves

    for (INT row=0; row<12; row++)
    {
        for (INT column=0; column<8; column++)
        {
            Font *itemFont = GetItemFont(page, row, column);

            if (itemFont)
            {
                RectF itemRect;
                pageLayout.GetItemRect(column, row, &itemRect);
                graphics->DrawRectangle(&blackPen, itemRect);


                graphics->DrawString(
                    L"There was an Old Man of the Coast\n\
Who placidly sat on a post;\n\
But when it was cold,\n\
He relinquished his hold,\n\
And called for some hot buttered toast.\n",
                    -1,
                    itemFont,
                    itemRect,
                    &stringFormat,
                    &blackBrush
                );

                delete itemFont;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\autotext.cpp ===
/////   autoText.cpp - gdiplus text test harness
//
//


#include "precomp.hpp"

#define GLOBALS_HERE 1
#include "global.h"

#include "../gpinit.inc"

///     ProcessCommandLine
//
//      -d  - Do display regression tests then exit
//      -p  - Do print regeression tests then exit
//
//      ProcessCommandLine returns FALSE if the program should not continue.


void SkipBlanks(const char **p)
{
    while (**p  &&  **p == ' ')
    {
        (*p)++;
    }
}

void SkipNonBlank(const char **p)
{
    while (**p  &&  **p != ' ')
    {
        (*p)++;
    }
}

void ProcessParameter(const char **p)
{
    if (    **p == '-'
        ||  **p == '/')
    {
        (*p)++;

        while (**p  &&  **p != ' ')
        {
            switch (**p)
            {
            case 'd':
                G.AutoDisplayRegress = TRUE;
                break;

            case 'p':
                G.AutoPrintRegress = TRUE;
                break;

            case 'h':
            default:
                G.Help = TRUE;
                break;
            }

            (*p)++;
        }

    }
    else
    {
        SkipNonBlank(p);
        G.Help = TRUE;
    }
}

BOOL ProcessCommandLine(const char *command)
{
    const char *p = command;

    SkipBlanks(&p);

    while (*p)
    {
        ProcessParameter(&p);
        SkipBlanks(&p);
    }

    if (G.Help)
    {
        MessageBoxA(
            NULL,
            "-d  - Regress display and exit\n\
-p  - Regress printing and exit\n\
-h  - Help",
            "autoText - text regression tests",
            MB_OK
        );

        return FALSE;
    }

    if (G.AutoDisplayRegress)
    {
        G.RunAllTests = TRUE;
    }
    return TRUE;
}





////    WinMain - Application entry point and dispatch loop
//
//


int APIENTRY WinMain(
    HINSTANCE   hInst,
    HINSTANCE   hPrevInstance,
    char       *pCmdLine,
    int         nCmdShow) {

    MSG         msg;
    HACCEL      hAccelTable;
    RECT        rc;
    RECT        rcMain;


    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
   
   G.Instance = hInst;  // Global hInstance

   G.PSLevel2 = TRUE;

   G.ghPrinter = 0;
   
    if (!ProcessCommandLine(pCmdLine))
    {
        return 1;
    }


    GetInstalledFamilies();


    // Create main text window

    G.Window = CreateTextWindow();


    ShowWindow(G.Window, SW_SHOWNORMAL);
    UpdateWindow(G.Window);


    // Main message loop

    if (G.Unicode)
    {
        hAccelTable = LoadAcceleratorsW(G.Instance, APPNAMEW);

        while (GetMessageW(&msg, (HWND) NULL, 0, 0) > 0)
        {
            if (!TranslateAcceleratorA(G.Window, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
    }
    else
    {
        hAccelTable = LoadAcceleratorsA(G.Instance, APPNAMEA);

        while (GetMessageA(&msg, (HWND) NULL, 0, 0) > 0)
        {
            if (!TranslateAcceleratorA(G.Window, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
    }


    ReleaseInstalledFamilies();

    return (int)msg.wParam;


    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by autoText.rc
//
#define IDM_EXIT                        40001
#define ID_FILE_PRINTALLTESTS           40002
#define ID_FIRST_FAMILY                 40003
#define ID_FIRST_BRUSH                  40004
#define ID_FILE_PRINT_CURRENT_TEST      40019
#define ID_NEXT_TEST                    40020
#define ID_PREV_TEST                    40021
#define ID_FIRST_FORMAT                 40022
#define ID_FILE_REGRESS                 40023
#define ID_FILE_PRINT_FIRST_PAGE        40024
#define ID_PS_LEVEL1                    40025
#define ID_PS_LEVEL2                    40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           10001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\precomp.hpp ===
////    precomp.hxx
//


// Private StringFormatFlags

const int StringFormatFlagsPrivateNoGDI                = 0x80000000;
const int StringFormatFlagsPrivateAlwaysUseFullImager  = 0x40000000;




#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\format.cpp ===
////    format.cpp - String format tests
//
//


#include "precomp.hpp"
#include "global.h"
#include "gdiplus.h"




/////   Formatting tests
//
//      Test combinations of StringFormat that affect layout




INT FormatTest::GetPageCount()
{
    return 6;
}


void FormatTest::GetPageTitle(INT pageNumber, WCHAR *title)
{
    title[0] = 0;

    wcscat(title, L"AutoText format test. Page settings: ");

    if (pageNumber & 1)
    {
        wcscat(title, L"Right-to-Left, ");
    }
    else
    {
        wcscat(title, L"Left-To-Right, ");
    }

    switch (pageNumber / 2)
    {
    case 0:
        wcscat(title, L"near");
        break;

    case 1:
        wcscat(title, L"center");
        break;

    case 2:
        wcscat(title, L"far");
        break;

    }
}



///     DrawPage - draw one page of the test
//
//

void FormatTest::DrawPage(
    IN Graphics *graphics,
    IN INT       pageNumber,
    IN REAL      pageWidth,
    IN REAL      pageHeight
)
{
    PageLayout pageLayout(pageWidth, pageHeight, 8, 12);

    SolidBrush blackBrush(Color(0, 0, 0));
    Pen        blackPen(&blackBrush, 1.0);


    // Display title at bottom of page

    StringFormat titleFormat(StringFormat::GenericDefault());
    titleFormat.SetAlignment(StringAlignmentCenter);
    titleFormat.SetLineAlignment(StringAlignmentCenter);

    RectF titleRect;
    pageLayout.GetFooterRect(&titleRect);

    Font pageTitleFont(L"Microsoft Sans Serif", 12, FontStyleBold);

    WCHAR title[200];

    GetPageTitle(pageNumber, title);

    graphics->DrawString(
        title,
        -1,
        &pageTitleFont,
        titleRect,
        &titleFormat,
        &blackBrush
    );


    // Display row titles

    Font titleFont(
        &FontFamily(L"Microsoft Sans Serif"),
        9,
        0,
        UnitPoint
    );

    for (INT i=0; i<12; i++)
    {
        pageLayout.GetRowTitleRect(i, &titleRect);

        title[0] = 0;

        if (i < 6)
        {
            wcscat(title, L"horz,");
        }
        else
        {
            wcscat(title, L"vert,");
        }

        switch (i % 6)
        {
        case 0: wcscat(title, L"trim- none "); break;
        case 1: wcscat(title, L"trim- char "); break;
        case 2: wcscat(title, L"trim- word "); break;
        case 3: wcscat(title, L"trim- ch... "); break;
        case 4: wcscat(title, L"trim- wd... "); break;
        case 5: wcscat(title, L"trim- uri... "); break;
        }

        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &blackBrush
        );
    }


    // Display column titles


    for (INT i=0; i<8; i++)
    {
        pageLayout.GetColumnTitleRect(i, &titleRect);

        title[0] = 0;

        if (i & 1)
        {
            wcscat(title, L"LineLimit, ");
        }
        else
        {
            wcscat(title, L"NoLineLimit, ");
        }

        if (i & 2)
        {
            wcscat(title, L"NoWrap, ");
        }
        else
        {
            wcscat(title, L"Wrap, ");
        }

        if (i & 4)
        {
            wcscat(title, L"NoClip");
        }
        else
        {
            wcscat(title, L"Clip");
        }

        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &blackBrush
        );
    }


    // Prepare common string format for this page

    StringFormat stringFormat(StringFormat::GenericDefault());

    INT pageFormatFlags = 0;

    if (pageNumber & 1)
    {
        pageFormatFlags |= StringFormatFlagsDirectionRightToLeft;
    }

    switch (pageNumber / 2)
    {
    case 0:
        stringFormat.SetAlignment(StringAlignmentNear);
        break;

    case 1:
        stringFormat.SetAlignment(StringAlignmentCenter);
        break;

    case 2:
        stringFormat.SetAlignment(StringAlignmentFar);
        break;
    }

    Font font(
        &FontFamily(L"Times New Roman"),
        9,
        0,
        UnitPoint
    );


    // The tests themselves

    INT testNumber = 0;
    while (testNumber < 96)
    {
        INT formatFlags = pageFormatFlags;


        if (testNumber & 1)
        {
            formatFlags |= StringFormatFlagsLineLimit;
        }

        if (testNumber & 2)
        {
            formatFlags |= StringFormatFlagsNoWrap;
        }

        if (testNumber & 4)
        {
            formatFlags |= StringFormatFlagsNoClip;
        }

        switch ((testNumber/8) % 6)
        {
        case 0: stringFormat.SetTrimming(StringTrimmingNone);              break;
        case 1: stringFormat.SetTrimming(StringTrimmingCharacter);         break;
        case 2: stringFormat.SetTrimming(StringTrimmingWord);              break;
        case 3: stringFormat.SetTrimming(StringTrimmingEllipsisCharacter); break;
        case 4: stringFormat.SetTrimming(StringTrimmingEllipsisWord);      break;
        case 5: stringFormat.SetTrimming(StringTrimmingEllipsisPath);      break;
        }

        if (testNumber >= 48)
        {
            formatFlags |= StringFormatFlagsDirectionVertical;
        }

        stringFormat.SetFormatFlags(formatFlags);

        RectF itemRect;
        pageLayout.GetItemRect(testNumber%8, testNumber/8, &itemRect);
        graphics->DrawRectangle(&blackPen, itemRect);

        RectF itemGutterRect;
        pageLayout.GetItemGutterRect(testNumber%8, testNumber/8, &itemGutterRect);
        graphics->SetClip(itemGutterRect);

        graphics->DrawString(
            L"There was an Old Man of the Coast\n\
Who placidly sat on a post;\n\
But when it was cold,\n\
He relinquished his hold,\n\
And called for some hot buttered toast.\n",
            -1,
            &font,
            itemRect,
            &stringFormat,
            &blackBrush
        );

        graphics->ResetClip();

        testNumber++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\window.cpp ===
////    window.cpp
//
//      Maintains the text display panel



#include "precomp.hpp"
#include "global.h"
#include "winspool.h"
#include <Tchar.h>
#include "commdlg.h"


INT GetTotalPageCount()
{
    return   FamilyTest().GetPageCount()
           + FormatTest().GetPageCount()
           + BrushTest().GetPageCount();
}



void DrawTestPage(Graphics *graphics, INT page, REAL width, REAL height)
{
    if (page < FamilyTest().GetPageCount())
    {
        FamilyTest().DrawPage(
            graphics,
            page,
            width,
            height
        );
    }
    else
    {
        page -= FamilyTest().GetPageCount();

        if (page < BrushTest().GetPageCount())
        {
            BrushTest().DrawPage(
                graphics,
                page,
                width,
                height
            );
        }
        else
        {
            page -= BrushTest().GetPageCount();

            if (page < FormatTest().GetPageCount())
            {
                FormatTest().DrawPage(
                    graphics,
                    page,
                    width,
                    height
                );
            }
            else
            {
                page -= FormatTest().GetPageCount();
            }
        }
    }
}



////    Print tests
//
//


HDC StartPrintDoc(DWORD flags)
{
    PRINTDLG printDialog;

    memset(&printDialog, 0, sizeof(printDialog));

    printDialog.lStructSize = sizeof(printDialog);
    printDialog.Flags = flags | PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION ;

    if (PrintDlg(&printDialog))
    {
        HDC dc = printDialog.hDC;

        DEVMODE * dv;

        dv = (DEVMODE *) GlobalLock(printDialog.hDevMode);

        if (G.PSLevel2)
            OpenPrinter((LPSTR) &dv->dmDeviceName[0], &G.ghPrinter, NULL);
        
        if (dc != NULL)
        {
            DOCINFO documentInfo;
            documentInfo.cbSize       = sizeof(documentInfo);
            documentInfo.lpszDocName  = _T("autoText gdiPlus test");
            documentInfo.lpszOutput   = NULL;
            documentInfo.lpszDatatype = NULL;
            documentInfo.fwType       = 0;

            if (StartDoc(dc, &documentInfo))
            {
                return dc;
            }
            else
            {
                DeleteDC(dc);
            }
        }
    }

    return FALSE;
}


void PrintAllTests()
{
    HDC dc = StartPrintDoc(0);

    if (dc)
    {
        INT page      = 0;
        INT pageCount = GetTotalPageCount();

        while (page < pageCount)
        {
            if (StartPage(dc) > 0)
            {
                HANDLE h = 0;
                
                if (G.PSLevel2)
                    h = G.ghPrinter;

                Graphics graphics(dc, h);
                    
                graphics.SetPageUnit(UnitPixel);
                DrawTestPage(
                    &graphics,
                    page,
                    REAL(GetDeviceCaps(dc, HORZRES)),
                    REAL(GetDeviceCaps(dc, VERTRES))
                );
                EndPage(dc);
            }

            page++;
        }

        EndDoc(dc);
        DeleteDC(dc);

        if (G.PSLevel2)
        {
            ClosePrinter(G.ghPrinter);
            G.ghPrinter = 0;
        }
    }

    
}




void PrintTest(INT pageNumber)
{
    HDC dc = StartPrintDoc(0);

    if (dc)
    {
        if (StartPage(dc) > 0)
        {
            HANDLE h = 0;
                
            if (G.PSLevel2)
                h = G.ghPrinter;

            Graphics graphics(dc, h);
                
            graphics.SetPageUnit(UnitPixel);
            DrawTestPage(
                &graphics,
                pageNumber,
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }
        EndDoc(dc);
        DeleteDC(dc);

        if (G.PSLevel2)
        {
            ClosePrinter(G.ghPrinter);
            G.ghPrinter = 0;
        }
    }
}



void PrintFirstPages(DWORD flags)
{
    HDC dc = StartPrintDoc(flags);

    if (dc)
    {
        HANDLE h = 0;
                
        if (G.PSLevel2)
            h = G.ghPrinter;

        Graphics graphics(dc, h);
            
        graphics.SetPageUnit(UnitPixel);

        if (StartPage(dc) > 0)
        {
            DrawTestPage(
                &graphics,
                0,
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }

        if (StartPage(dc) > 0)
        {
            DrawTestPage(
                &graphics,
                FamilyTest().GetPageCount(),
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }

        if (StartPage(dc) > 0)
        {
            DrawTestPage(
                &graphics,
                  FamilyTest().GetPageCount()
                + FormatTest().GetPageCount(),
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }

        EndDoc(dc);
        DeleteDC(dc);

        if (G.PSLevel2)
        {
            ClosePrinter(G.ghPrinter);
            G.ghPrinter = 0;
        }
    }
}



////    Paint - redraw part or all of client area
//
//


void PaintWindow(HWND hWnd) {

    PAINTSTRUCT  ps;
    HDC          hdc;

    hdc = BeginPaint(hWnd, &ps);

    Graphics graphics(hdc);

    RectF clip(
        REAL(ps.rcPaint.left),
        REAL(ps.rcPaint.top),
        REAL(ps.rcPaint.right-ps.rcPaint.left),
        REAL(ps.rcPaint.bottom-ps.rcPaint.top)
    );

    if (ps.fErase)
    {
        graphics.FillRectangle(
            &SolidBrush(Color(0xff, 0xff, 0xff)),
            clip
        );
    }

    RECT rcWnd;
    GetClientRect(hWnd, &rcWnd);

    if (G.RunAllTests)
    {
        for (INT i=0; i<GetTotalPageCount(); i++)
        {
            G.TestPage = i;
            DrawTestPage(
                &graphics,
                G.TestPage,
                REAL(rcWnd.right - rcWnd.left),
                REAL(rcWnd.bottom - rcWnd.top)
            );

            graphics.FillRectangle(
                &SolidBrush(Color(0xff, 0xff, 0xff)),
                RectF(
                    REAL(rcWnd.left),
                    REAL(rcWnd.top),
                    REAL(rcWnd.right-ps.rcPaint.left),
                    REAL(rcWnd.bottom-ps.rcPaint.top)
                )
            );
        }
        G.RunAllTests = FALSE;
    }
    else
    {
        DrawTestPage(
            &graphics,
            G.TestPage,
            REAL(rcWnd.right - rcWnd.left),
            REAL(rcWnd.bottom - rcWnd.top)
        );
    }

    EndPaint(hWnd, &ps);



    if (G.AutoPrintRegress)
    {
        PrintFirstPages(PD_RETURNDEFAULT);
    }



    if (    G.AutoDisplayRegress
        ||  G.AutoPrintRegress)
    {
        SendMessage(hWnd, WM_CLOSE, 0, 0);
    }
}




////    TextWndProc - Main window message handler and dispatcher
//
//


LRESULT CALLBACK TextWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    HDC hdc;

    switch (message) {

    case WM_ERASEBKGND:
        return 0;       // Leave Paint to erase the background


    case WM_PAINT:
        PaintWindow(hWnd);
        break;


    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;


    case WM_COMMAND:
        //INT  command = LOWORD(wParam);
        //INT  notify  = HIWORD(wParam);
        //HWND item    = HWND(lParam);
        switch (LOWORD(wParam))
        {
        case ID_NEXT_TEST:
            G.TestPage++;
            if (G.TestPage >= GetTotalPageCount())
            {
                G.TestPage = 0;
            }
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_PREV_TEST:
            G.TestPage--;
            if (G.TestPage < 0)
            {
                G.TestPage = GetTotalPageCount()-1;
            }
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_PS_LEVEL1:
            G.PSLevel2 = FALSE;
            break;

        case ID_PS_LEVEL2:
            G.PSLevel2 = TRUE;
            break;
            
        case ID_FIRST_FAMILY:
            G.TestPage = 0;
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FIRST_BRUSH:
            G.TestPage = FamilyTest().GetPageCount();
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FIRST_FORMAT:
            G.TestPage = FamilyTest().GetPageCount() + BrushTest().GetPageCount();
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FILE_REGRESS:
            G.TestPage = 0;
            G.RunAllTests = TRUE;
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FILE_PRINT_CURRENT_TEST:
            PrintTest(G.TestPage);
            break;

        case ID_FILE_PRINT_FIRST_PAGE:
            PrintFirstPages(0);
            break;

        case ID_FILE_PRINTALLTESTS:
            PrintAllTests();
            break;

        case IDM_EXIT:
            SendMessage(hWnd, WM_CLOSE, 0, 0);
            break;
        }

        // Validate current test page number

        if (G.TestPage < 0)
        {
            G.TestPage = 0;
        }
        else
        {
            if (G.TestPage >= GetTotalPageCount())
            {
                G.TestPage = GetTotalPageCount()-1;
            }
        }
        return 0;


    default:
        if (G.Unicode) {
            return DefWindowProcW(hWnd, message, wParam, lParam);
        } else {
            return DefWindowProcA(hWnd, message, wParam, lParam);
        }
    }

    return 0;
}






////    CreateTextWindow - create window class and window
//
//      Attempts to use a Unicode window, if this fails uses an ANSI
//      window.
//
//      For example the Unicode window will succeed on Windows NT and
//      Windows CE, but fail on Windows 9x.


HWND CreateTextWindow() {

    WNDCLASSA  wcA;
    WNDCLASSW  wcW;
    HWND       hWnd;

    // Try registering as a Unicode window

    wcW.style         = CS_HREDRAW | CS_VREDRAW;
    wcW.lpfnWndProc   = TextWndProc;
    wcW.cbClsExtra    = 0;
    wcW.cbWndExtra    = 0;
    wcW.hInstance     = G.Instance;
    wcW.hIcon         = LoadIconW(G.Instance, APPNAMEW);
    wcW.hCursor       = LoadCursorW(NULL, (WCHAR*)IDC_ARROW);
    wcW.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wcW.lpszMenuName  = L"MAINMENU";
    wcW.lpszClassName = APPNAMEW;

    if (RegisterClassW(&wcW)) {

        // Use a Unicode window

        G.Unicode = TRUE;

        hWnd  = CreateWindowW(
            APPNAMEW, APPTITLEW,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            G.Instance,
            NULL);


        return hWnd;

    } else {

        // Must use an ANSI window.

        wcA.style         = CS_HREDRAW | CS_VREDRAW;
        wcA.lpfnWndProc   = TextWndProc;
        wcA.cbClsExtra    = 0;
        wcA.cbWndExtra    = 0;
        wcA.hInstance     = G.Instance;
        wcA.hIcon         = LoadIconA(G.Instance, APPNAMEA);
        wcA.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wcA.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcA.lpszMenuName  = "MAINMENU";
        wcA.lpszClassName = APPNAMEA;

        if (!RegisterClassA(&wcA)) {
            return NULL;
        }

        G.Unicode = FALSE;

        hWnd  = CreateWindowA(
            APPNAMEA, APPTITLEA,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            G.Instance,
            NULL);
    };


    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\autotext\global.h ===
////    GLOBAL.H - Global variables for CSSAMP
//
//





////    Constants
//
//


#define APPNAMEA   "autoText"
#define APPTITLEA  "autoText - GdipPlus Text support (Text+) regression test"
#define APPNAMEW   L"autoText"
#define APPTITLEW  L"autoText - GdipPlus Text support (Text+) regression test"






////    Global variables
//
//


struct GlobalVariables
{
    HINSTANCE    Instance;
    HWND         Window;
    BOOL         Unicode;
    INT          TestPage;    // Selected with test menu
    BOOL         RunAllTests; // When set, cycles through all test pages
    FontFamily  *InstalledFamilies;
    INT          InstalledFamilyCount;

    // Parameter flags
    BOOL         Help;
    BOOL         AutoDisplayRegress;
    BOOL         AutoPrintRegress;
    HANDLE       ghPrinter;
    BOOL         PSLevel2;
};

extern HANDLE ghPrinter;

#ifdef GLOBALS_HERE

    GlobalVariables G = {0};

#else

    extern GlobalVariables G;

#endif


void GetInstalledFamilies();
void ReleaseInstalledFamilies();


class TextTest
{
public:
    virtual INT GetPageCount() = 0;
    virtual void GetPageTitle(INT i, WCHAR *title) = 0;
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    ) = 0;
};



class FormatTest: public TextTest
{
public:
    virtual INT GetPageCount();
    virtual void GetPageTitle(INT i, WCHAR *title);
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    );
};


class BrushTest: public TextTest
{
public:
    virtual INT GetPageCount();
    virtual void GetPageTitle(INT i, WCHAR *title);
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    );
};


class FamilyTest: public TextTest
{
public:
    virtual INT GetPageCount();
    virtual void GetPageTitle(INT i, WCHAR *title);
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    );
};








HWND CreateTextWindow();
void DrawFormatPage(
    IN Graphics *graphics,
    IN INT       pageNumber,
    IN REAL      pageWidth,
    IN REAL      pageHeight
);





/////   PageLayout - All the page coordinate calculations in one place
//
//      The PageLayout constructor takes page dimensions and required
//      layout.
//
//      Pagelayout functions return item and title rectangles.


class PageLayout
{
public:
    PageLayout(
        IN  REAL  pageWidth,
        IN  REAL  pageHeight,
        IN  INT   columnCount = 8,
        IN  INT   rowCount    = 12,
        IN  REAL  pageMargin  = -1,
        IN  REAL  gutter      = -1,
        IN  REAL  columnTitle = -1,
        IN  REAL  rowTitle    = -1,
        IN  REAL  footer      = -1
    ) :
    PageWidth    (pageWidth),
    PageHeight   (pageHeight),
    ColumnCount  (columnCount),
    RowCount     (rowCount),
    PageMargin   (pageMargin),
    Gutter       (gutter),
    ColumnTitle  (columnTitle),
    RowTitle     (rowTitle),
    Footer       (footer)
    {
        if (pageMargin < 0)   PageMargin = REAL(PageWidth  / 32);
        if (gutter < 0)       Gutter     = REAL(PageWidth  / 128);
        if (columnTitle < 0)  ColumnTitle= REAL(PageHeight / 20);
        if (rowTitle < 0)     RowTitle   = REAL(PageWidth  / 20);
        if (footer < 0)       Footer     = REAL(PageHeight / 20);
    }


    void GetItemSize(SizeF *item)
    {
        item->Width  = ((PageWidth  - (RowTitle           + 2*PageMargin + ColumnCount*Gutter)) / ColumnCount);
        item->Height = ((PageHeight - (ColumnTitle+Footer + 2*PageMargin + RowCount*Gutter))    / RowCount);
    }

    void GetItemRect(
        IN  INT    column,
        IN  INT    row,
        OUT RectF *item
    )
    {
        SizeF itemSize;
        GetItemSize(&itemSize);

        item->X = PageMargin + RowTitle    + Gutter + column * (itemSize.Width + Gutter);
        item->Y = PageMargin + ColumnTitle + Gutter + row * (itemSize.Height + Gutter);
        item->Width  = itemSize.Width;
        item->Height = itemSize.Height;
    }

    void GetItemGutterRect(
        IN  INT    column,
        IN  INT    row,
        OUT RectF *gutterRect
    )
    {
        RectF item;
        GetItemRect(column, row, &item);

        gutterRect->X      = item.X      - Gutter;
        gutterRect->Y      = item.Y      - Gutter;
        gutterRect->Width  = item.Width  + 2*Gutter;
        gutterRect->Height = item.Height + 2*Gutter;
    }

    void GetColumnTitleRect(
        IN  INT    column,
        OUT RectF *title
    )
    {
        RectF item;
        GetItemRect(column, 0, &item);

        title->X      = item.X;
        title->Y      = PageMargin;
        title->Width  = item.Width;
        title->Height = ColumnTitle;
    }


    void GetRowTitleRect(
        IN  INT    row,
        OUT RectF *title
    )
    {
        RectF item;
        GetItemRect(0, row, &item);

        title->X      = PageMargin;
        title->Y      = item.Y;
        title->Width  = RowTitle;
        title->Height = item.Height;
    }


    void GetFooterRect(
        OUT RectF *footer
    )
    {
        footer->X      = PageMargin;
        footer->Y      = PageHeight - (PageMargin + Footer);
        footer->Width  = PageWidth - 2 * PageMargin;
        footer->Height = Footer;
    }


private:
    REAL PageWidth;
    REAL PageHeight;
    INT  ColumnCount;
    INT  RowCount;
    REAL PageMargin;
    REAL Gutter;
    REAL ColumnTitle;
    REAL RowTitle;
    REAL Footer;
    REAL ItemWidth;
    REAL ItemHeight;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\comtest.cpp ===
#include "precomp.hpp"

#include "comtest.h"
#include "ComBase.hpp"
#include "HelloWorld.hpp"

#include <initguid.h>
#include "comtest_i.c"

HINSTANCE globalInstanceHandle = NULL;
LONG globalComponentCount = 0;


// 
// DLL entrypoint
//

extern "C" BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    VOID* lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);
        globalInstanceHandle = hInstance;
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}


//
// Determine whether the DLL can be safely unloaded
//

STDAPI
DllCanUnloadNow()
{
    return (globalComponentCount == 0) ? S_OK : S_FALSE;
}


//
// Return a class factory object
//

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    VOID** ppv
    )
{
    if (rclsid != CLSID_HelloWorld)
        return CLASS_E_CLASSNOTAVAILABLE;

    CHelloWorldFactory* factory = new CHelloWorldFactory();

    if (factory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = factory->QueryInterface(riid, ppv);
    factory->Release();

    return hr;
}


//
// Register our component
//

static const ComponentRegData compRegData =
{
    &CLSID_HelloWorld,
    L"Skeleton COM Component",
    L"comtest.HelloWorld.1",
    L"comtest.HelloWorld"
};

STDAPI
DllRegisterServer()
{
    return RegisterComponent(compRegData, TRUE);
}


//
// Unregister our component
//

STDAPI
DllUnregisterServer()
{
    return RegisterComponent(compRegData, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\comtest_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Thu Feb 04 17:08:08 1999
 */
/* Compiler settings for comtest.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHelloWorld = {0xFEE1509A,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const IID LIBID_COMTESTLib = {0xECE5BCF2,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const CLSID CLSID_HelloWorld = {0x0B7E1310,0xBC90,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Thu Feb 04 17:08:09 1999
 */
/* Compiler settings for comtest.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHelloWorld = {0xFEE1509A,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const IID LIBID_COMTESTLib = {0xECE5BCF2,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const CLSID CLSID_HelloWorld = {0x0B7E1310,0xBC90,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\combase.hpp ===
#ifndef _COMBASE_HPP
#define _COMBASE_HPP


//
// Macros for incrementing or decrementing global component count
//

extern HINSTANCE globalInstanceHandle;
extern LONG globalComponentCount;

#define IncrementGlobalComponentCount() \
        InterlockedIncrement(&globalComponentCount)
    
#define DecrementGlobalComponentCount() \
        InterlockedDecrement(&globalComponentCount)


//
// Template for implementing IUnknown interface
//
// NOTES:
// 1. We can only handle objects that one interface other than IUnknown.
// 2. We do not support aggregation.
//

template <class I> class IUnknownBase : public I
{
public:

    // Constructor: notice that when an object is first
    // created, its reference count is set to 1.

    IUnknownBase<I>()
    {
        refCount = 1;
    }

    // Query interface: note that we can only handle
    // objects that one interface other than IUnknown.

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv)
    {
        if (riid == IID_IUnknown)
            *ppv = static_cast<IUnknown*>(this);
        else if (riid == __uuidof(I))
            *ppv = static_cast<I*>(this);
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&refCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&refCount);

        if (count == 0)
            delete this;

        return count;
    }

private:

    LONG refCount;
};


//
// Template for implementing IClassFactory interface
//

template <class T> class IFactoryBase
    : public IUnknownBase<IClassFactory>
{
public:

    // NOTE: We don't count class factory objects in globalComponentCount.
    // This means that the existence of a running class factory is not
    // guaranteed to keep a server loaded in memory.

    // Create a new instance of the component

    STDMETHOD(CreateInstance)(IUnknown* outer, REFIID riid, VOID** ppv)
    {
        // We don't support aggregation

        if (outer != NULL)
            return CLASS_E_NOAGGREGATION;

        // Instantiate a new object

        T* obj = new T;

        if (obj == NULL)
            return E_OUTOFMEMORY;

        // Get the requested interface

        HRESULT hr = obj->QueryInterface(riid, ppv);
        obj->Release();

        return hr;
    }

    // Lock/unlock the component server DLL

    STDMETHOD(LockServer)(BOOL lock)
    {
        if (lock)
        {
            IncrementGlobalComponentCount();
        }
        else
        {
            DecrementGlobalComponentCount();
        }

        return S_OK;
    }
};


//
// Helper function for registering and unregistering a component
//

struct ComponentRegData
{
    const CLSID* clsid;
    const WCHAR* compName;
    const WCHAR* progID;
    const WCHAR* progIDNoVer;
};

HRESULT
RegisterComponent(
    const ComponentRegData& regdata,
    BOOL registerIt
    );

#endif // !_COMBASE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\comtest.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Thu Feb 04 17:08:08 1999
 */
/* Compiler settings for comtest.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comtest_h__
#define __comtest_h__

/* Forward Declarations */ 

#ifndef __IHelloWorld_FWD_DEFINED__
#define __IHelloWorld_FWD_DEFINED__
typedef interface IHelloWorld IHelloWorld;
#endif 	/* __IHelloWorld_FWD_DEFINED__ */


#ifndef __HelloWorld_FWD_DEFINED__
#define __HelloWorld_FWD_DEFINED__

#ifdef __cplusplus
typedef class HelloWorld HelloWorld;
#else
typedef struct HelloWorld HelloWorld;
#endif /* __cplusplus */

#endif 	/* __HelloWorld_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IHelloWorld_INTERFACE_DEFINED__
#define __IHelloWorld_INTERFACE_DEFINED__

/* interface IHelloWorld */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHelloWorld;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FEE1509A-BC8F-11D2-9D5E-0000F81EF32E")
    IHelloWorld : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Print( 
            /* [in] */ BSTR message) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHelloWorldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHelloWorld __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHelloWorld __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHelloWorld __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Print )( 
            IHelloWorld __RPC_FAR * This,
            /* [in] */ BSTR message);
        
        END_INTERFACE
    } IHelloWorldVtbl;

    interface IHelloWorld
    {
        CONST_VTBL struct IHelloWorldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHelloWorld_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHelloWorld_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHelloWorld_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHelloWorld_Print(This,message)	\
    (This)->lpVtbl -> Print(This,message)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHelloWorld_Print_Proxy( 
    IHelloWorld __RPC_FAR * This,
    /* [in] */ BSTR message);


void __RPC_STUB IHelloWorld_Print_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHelloWorld_INTERFACE_DEFINED__ */



#ifndef __COMTESTLib_LIBRARY_DEFINED__
#define __COMTESTLib_LIBRARY_DEFINED__

/* library COMTESTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_COMTESTLib;

EXTERN_C const CLSID CLSID_HelloWorld;

#ifdef __cplusplus

class DECLSPEC_UUID("0B7E1310-BC90-11D2-9D5E-0000F81EF32E")
HelloWorld;
#endif
#endif /* __COMTESTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\helloworld.hpp ===
#ifndef _HELLOWORLD_HPP
#define _HELLOWORLD_HPP

//
// Class that implements our component
//

class CHelloWorld : public IUnknownBase<IHelloWorld>
{
public:

    CHelloWorld()
    {
        IncrementGlobalComponentCount();
    }

    ~CHelloWorld()
    {
        DecrementGlobalComponentCount();
    }

    STDMETHOD(Print)(BSTR message)
    {
        printf("%S\n", message);
        return S_OK;
    }
};

//
// The class factory for our component
//

typedef IFactoryBase<CHelloWorld> CHelloWorldFactory;

#endif // !_HELLOWORLD_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\precomp.hpp ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\comtest\combase.cpp ===
#include "precomp.hpp"
#include "combase.hpp"


//
// Create a new registry key and set its default value
//

BOOL
SetRegKeyValue(
    HKEY parentKey,
    const WCHAR* keyname,
    const WCHAR* value,
    HKEY* retkey
    )
{
    HKEY hkey;

    // Create or open the specified registry key

    if (RegCreateKeyEx(parentKey,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       NULL,
                       &hkey,
                       NULL) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Set the default value for the new key

    INT size = sizeof(WCHAR) * (wcslen(value)+1);

    if (RegSetValueEx(hkey,
                      NULL,
                      0,
                      REG_SZ,
                      (const BYTE*) value,
                      size) != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        return FALSE;
    }

    // Check if the caller is interested in the handle to the new key

    if (retkey != NULL)
        *retkey = hkey;
    else
        RegCloseKey(hkey);

    return TRUE;
}


//
// Delete a registry key and everything below it.
//

BOOL
DeleteRegKey(
    HKEY parentKey,
    const WCHAR* keyname
    )
{
    HKEY hkey;

    // Open the specified registry key

    if (RegOpenKeyEx(parentKey,
                     keyname,
                     0,
                     KEY_ALL_ACCESS,
                     &hkey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Enumerate all subkeys

    WCHAR childname[256];
    DWORD childlen = 256;
    FILETIME filetime;
    
    while (RegEnumKeyEx(hkey,
                        0,
                        childname,
                        &childlen,
                        NULL,
                        NULL,
                        NULL,
                        &filetime) == ERROR_SUCCESS)
    {
        // Recursively delete subkeys

        if (!DeleteRegKey(hkey, childname))
        {
            RegCloseKey(hkey);
            return FALSE;
        }

        childlen = 256;
    }

    // Close the specified key and then delete it

    RegCloseKey(hkey);
    return RegDeleteKey(parentKey, keyname) == ERROR_SUCCESS;
}


//
// Register or unregister a component depending on the value
// of registerIt parameter:
//  TRUE = register it
//  FALSE = unregister it
//

HRESULT
RegisterComponent(
    const ComponentRegData& regdata,
    BOOL registerIt
    )
{
    static const WCHAR CLSID_KEYSTR[] = L"CLSID";
    static const WCHAR INPROCSERVER32_KEYSTR[] = L"InProcServer32";
    static const WCHAR PROGID_KEYSTR[] = L"ProgID";
    static const WCHAR PROGIDNOVER_KEYSTR[] = L"VersionIndependentProgID";
    static const WCHAR CURVER_KEYSTR[] = L"CurVer";

    // compose class ID string

    WCHAR clsidStr[64];
    StringFromGUID2(*regdata.clsid, clsidStr, 64);

    // open registry key HKEY_CLASSES_ROOT\CLSID

    BOOL success;
    HKEY clsidKey;

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
                     CLSID_KEYSTR,
                     0,
                     KEY_ALL_ACCESS,
                     &clsidKey) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    if (registerIt)
    {
        // Register the component

        HKEY hkey;
        WCHAR fullpath[MAX_PATH];

        // HKEY_CLASSES_ROOT
        //  <Version-independent ProgID> - component friendly name
        //      CLSID - current version class ID
        //      CurVer - current version ProgID

        if (!GetModuleFileName(globalInstanceHandle, fullpath, MAX_PATH) ||
            !SetRegKeyValue(HKEY_CLASSES_ROOT,
                            regdata.progIDNoVer,
                            regdata.compName,
                            &hkey))
        {
            success = FALSE;
            goto regcompExit;
        }

        success = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL)
               && SetRegKeyValue(hkey, CURVER_KEYSTR, regdata.progID, NULL);

        RegCloseKey(hkey);

        if (!success)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  <ProgID> - friendly component name
        //      CLSID - class ID

        if (!SetRegKeyValue(HKEY_CLASSES_ROOT,
                            regdata.progID,
                            regdata.compName,
                            &hkey))
        {
            success = FALSE;
            goto regcompExit;
        }

        success = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL);
        RegCloseKey(hkey);

        if (!success)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  CLSID
        //      <class ID> - friendly component name
        //          InProcServer32 - full pathname to component DLL
        //          ProgID - current version ProgID
        //          VersionIndependentProgID - ...

        if (!SetRegKeyValue(clsidKey, clsidStr, regdata.compName, &hkey))
        {
            success = FALSE;
            goto regcompExit;
        }
        
        success = SetRegKeyValue(hkey, INPROCSERVER32_KEYSTR, fullpath, NULL)
               && SetRegKeyValue(hkey, PROGID_KEYSTR, regdata.progID, NULL)
               && SetRegKeyValue(hkey, PROGIDNOVER_KEYSTR, regdata.progIDNoVer, NULL);

        RegCloseKey(hkey);
    }
    else
    {
        // Unregister the component

        success = DeleteRegKey(clsidKey, clsidStr)
               && DeleteRegKey(HKEY_CLASSES_ROOT, regdata.progIDNoVer)
               && DeleteRegKey(HKEY_CLASSES_ROOT, regdata.progID);
    }

regcompExit:

    RegCloseKey(clsidKey);
    return success ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\cycloid.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Main cycloid canvas paint procedure
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#pragma once

#include "precomp.hpp"

class HypoCycloid :public DrawingObject {
    INT a;
    INT b;
    
    public: 
    
    HypoCycloid(int a_, int b_) {
        a=a_;
        b=b_;
    }
    
    virtual void Draw(Graphics *g, int x, int y, int width, int height);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\drawcycloid.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Main cycloid computation and drawing routines
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _DRAWCYCLOID_HPP
#define _DRAWCYCLOID_HPP

#include "precomp.hpp"

void DrawTestCycloid(Graphics *g, int a, int b, int width, int height);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\manipulator.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Manipulator ancestor
*
* Abstract:
*
*   This is the root of the manipulator object heirarchy
*
*
* Created:
*
*   06/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _MANIPULATOR_HPP
#define _MANIPULATOR_HPP

#include "precomp.hpp"

class Manipulator {

    public:
    Manipulator() {}
    
    // Process this message
    virtual void DoMessage(Message &msg) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\crop\crop.cxx ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Program Name:
*
*   Crop
*
*   This is a sample application that loads an image and shrinks it down
*   to 128x96 using the HighQualityBicubic resampling filter. It crops the
*   image to preserve the aspect ratio.
*
*   This app is particularly useful for creating a set of thumbnail images
*   from a directory of pictures for use in a web page index.
*
*   This example will produce a directory (idx) containing 128x96 jpeg
*   thumbnails for all the jpeg files in the pictures directory:
*       cd pictures
*       md idx
*       for %i in (*.jpg) do crop %~nxi idx\%~nxi
*
* Usage (command line):
*
*   Crop input_filename output_filename
*
* Created:
*
*   06/25/2000 asecchia
*      Created it.
*   03/16/2001 minliu
*       add -w, -h, -? -s, -q switches support. New ValidateArguments() and
*       USAGE() function
*   05/10/2001 gillesk
*       added -a to crop the excess of the file and keep the w and h
*
**************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>

#include "../gpinit.inc"

INT AsciiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
)
{
    return( MultiByteToWideChar(
        CP_ACP,
        0,
        ansiStr,
        -1,
        unicodeStr,
        unicodeSize
    ) > 0 );
}

int round(float f) { return (int) (f+0.5); }

const int k_xsize = 128;    // default thumbnail size
const int k_ysize = 96;

int     g_xsize = k_xsize;
int     g_ysize = k_ysize;
float   g_scale = 1;
int     g_quality = 5;
int     g_compression = 70;
BOOL    g_HasSetScaleFactor = FALSE;
BOOL    g_KeepAspectRation = FALSE;
BOOL    g_GotFileNames = FALSE;
WCHAR   filename[1024];
WCHAR   outfilename[1024];

#define Fail() goto cleanup

void
USAGE()
{
    printf("******************************************************\n");
    printf("Usage: crop [-?] [-w width] [-h height] [-s factor] srcImg dstImg\n");
    printf("-w----Specify the thumbnail image width. Default is 128\n");
    printf("-h----Specify the thumbnail image height. Default is 96\n");
    printf("-s----Specify the scale factor\n");
    printf("-q----Specify the render quality [1-5] where 5(default) is the best\n");
    printf("-a----Keep the apsect ratio and crop the excess of the image\n");
    printf("-c----Set the compression factor [0-100] where 100 is least compressed\n");
    printf("-?----Print this usage message\n");
    printf("Note: If scale factor is specified, then width and height you specified are ignored\n\n\n");
    printf("Sample usage:\n");
    printf("    crop -w 200 -h 300 foo.jpg thumb.jpg\n");
    printf("    crop -s 0.5 foo.jpg thumb.jpg\n");
    printf("    crop foo.jpg thumb.jpg\n");
}// USAGE()

void
ValidateArguments(int   argc,
                  char* argv[])
{
    argc--;
    argv++; // Filter out program name

    while ( argc > 0 )
    {
        if ( strcmp(*argv, "-w") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_xsize = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-h") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_ysize = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-s") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_scale = (float)atof(*argv++);
            g_HasSetScaleFactor = TRUE;
            argc--;
        }
        else if ( strcmp(*argv, "-q") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_quality = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-a") == 0 )
        {
            g_KeepAspectRation = TRUE;
            argc--;
            argv++;
        }
        else if ( strcmp(*argv, "-c") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_compression = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-?") == 0 )
        {
            USAGE();
            exit(1);
        }
        else
        {
            // source and dest image name

            if ( argc < 2 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            AsciiToUnicodeStr(*argv++, filename, 1024);
            argc--;
            AsciiToUnicodeStr(*argv++, outfilename, 1024);
            argc--;
            g_GotFileNames = TRUE;
        }
    }// while ( argc > 0 )

    if ( g_GotFileNames == FALSE )
    {
        // No input file name yet, bail out

        USAGE();
        exit(1);
    }
}// ValidateArguments()

void _cdecl
main(int argc,
     char **argv
     )
{
    if (!gGdiplusInitHelper.IsValid())
    {
        printf("error - GDI+ initialization failed\n");
        return;
    }

    // Parse input parameters

    ValidateArguments(argc, argv);

    using namespace Gdiplus;

    Status status = Ok;

    ImageCodecInfo* codecs = NULL;
    UINT count;
    UINT cbCodecs;

    // Open the source image
    
    Bitmap* dstBmp = NULL;
    Graphics *gdst = NULL;
    RectF srcRect;

    Bitmap *srcBmp = new Bitmap(filename, TRUE);
    if ( (srcBmp == NULL) || (srcBmp->GetLastStatus() != Ok) )
    {
        printf("Error opening image %s\n", filename);
        Fail();
    }

    // Ask the source image for it's size.

    int width = srcBmp->GetWidth();
    int height = srcBmp->GetHeight();

    srcRect = RectF(0.0f, 0.0f, (REAL)width, (REAL)height);

    printf("Input image is %d x %d\n", width, height);

    // Compute the optimal scale factor without changing the aspect ratio
    if ( g_HasSetScaleFactor == FALSE )
    {
        float scalex = (float)g_xsize / width;
        float scaley = (float)g_ysize / height;
        g_scale = min(scalex, scaley);
    }

    // If we want to keep the aspect ratio, then we need to crop the srcBmp

    UINT    dstWidth = (UINT)(width * g_scale + 0.5);
    UINT    dstHeight = (UINT)(height * g_scale + 0.5);

    if ( g_KeepAspectRation == TRUE )
    {
        float scalex = (float)g_xsize / width;
        float scaley = (float)g_ysize / height;
        g_scale = max(scalex, scaley);
        srcRect = RectF((REAL)width/2.0f, (REAL)height/2.0f, 0.0f, 0.0f);
        srcRect.Inflate(g_xsize/g_scale/2.0f, g_ysize/g_scale/2.0f);
        dstWidth = g_xsize;
        dstHeight = g_ysize;
    }
    

    // Create a destination image to draw onto
    
    dstBmp = new Bitmap(dstWidth, dstHeight, PixelFormat32bppPARGB);
    if ( (dstBmp == NULL) || (dstBmp->GetLastStatus() != Ok) )
    {
        printf("Error create temp Bitmap with size %d x %x\n", dstWidth,
               dstHeight);
        Fail();
    }
    
    gdst = new Graphics(dstBmp);
    if ( (gdst == NULL) || (gdst->GetLastStatus() != Ok) )
    {
        printf("Error create graphics\n");
        Fail();
    }
    
    // Make up a dest rect that we need image to draw to

    {
        RectF    dstRect(0.0f, 0.0f, (REAL)dstWidth, (REAL)dstHeight);

        // Set the resampling quality to the bicubic filter

        switch ( g_quality )
        {
        case 1:
            gdst->SetInterpolationMode(InterpolationModeBilinear);
            break;

        case 2:
            gdst->SetInterpolationMode(InterpolationModeNearestNeighbor);
            break;

        case 3:
            gdst->SetInterpolationMode(InterpolationModeBicubic);
            break;
        
        case 4:
            gdst->SetInterpolationMode(InterpolationModeHighQualityBilinear);
            break;

        case 5:
        default:
            gdst->SetInterpolationMode(InterpolationModeHighQualityBicubic);
            break;
        }

        // Set the compositing quality to copy source pixels rather than
        // alpha blending. This will preserve any alpha in the source image.

        gdst->SetCompositingMode(CompositingModeSourceCopy);

        // Draw the source image onto the destination with the correct scale
        // and quality settings.

        status = gdst->DrawImage(srcBmp, 
                                 dstRect, 
                                 srcRect.X,
                                 srcRect.Y,
                                 srcRect.Width,
                                 srcRect.Height,
                                 UnitPixel
                                 );

        if (status != Ok)
        {
            printf("Error drawing the image\n");
            Fail();
        }
    }

    // Now start finding a codec to output the image.

    cbCodecs = 0;
    GetImageEncodersSize(&count, &cbCodecs);

    // Allocate space for the codec list

    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));

    if (codecs == NULL)
    {
        printf("error: failed to allocate memory for codecs\n");
        Fail();
    }

    // Get the list of encoders

    status = GetImageEncoders(count, cbCodecs, codecs);

    if (status != Ok)
    {
        printf("Error: GetImageEncoders returned %d\n", status);
        Fail();
    }

    // Search the codec list for the JPEG codec.
    // Use the Mime Type field to specify the correct codec.

    for(UINT i=0; i<count; i++) {
        if(wcscmp(codecs[i].MimeType, L"image/jpeg")==0) {break;}
    }

    if(i>=count)
    {
        fprintf(stderr, "failed to find the codec\n");
        Fail();
    }

    // Output the image to disk.

    CLSID tempClsID;
    tempClsID = codecs[i].Clsid;
    EncoderParameters params;
    params.Count = 1;

    params.Parameter[0].Guid = EncoderCompression;
    params.Parameter[0].NumberOfValues = 1;
    params.Parameter[0].Type = EncoderParameterValueTypeLong;
    params.Parameter[0].Value = (void*) &g_compression;

    status = dstBmp->Save(
        outfilename,
        &tempClsID,
        &params
    );

    if (status != Ok)
    {
        fprintf(stderr, "SaveImage--Save() failed\n");
        Fail();
    }

    printf("Create new image at %d x %d\n", dstWidth, dstHeight);
    
    // We're golden - everything worked.

    printf("Done\n");


    // Clean up the objects we used.

    cleanup:

    free(codecs);
    delete gdst;
    delete dstBmp;
    delete srcBmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\drawcycloid.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Cycloid Drawing.
*
* Abstract:
*
*   Routines for computing and drawing cycloids.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "drawcycloid.hpp"

/**************************************************************************
*
* Function Description:
*
*   Test function to draw an example cycloid.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

void DrawTestCycloid(Graphics *g, int a, int b, int width, int height)
{
    #define _2PI 2*3.141592653689
    

    // Compute the center point for the cycle.

    float fXo=static_cast<float>(width)/2.0f;
    float fYo=static_cast<float>(height)/2.0f;
    
    float ScaleX = fXo/( (a>b)?a:a+b );
    float ScaleY = fYo/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    int Num = cycle*30;
    
    PointF *points = new PointF[Num];

    // Compute the points tracking the cycloid path.

    for(int i=0; i<Num; i++) 
    {
        float t = (float)(cycle*_2PI*i/Num);
        points[i].X = 10+(float)(fXo+ScaleX*((a-b)*cos(t)+b*cos((a-b)*t/b)));
        points[i].Y = 10+(float)(fYo+ScaleY*((a-b)*sin(t)-b*sin((a-b)*t/b)));
    }
    
    Color PenColor(0xffff0000);   
    Pen myPen(PenColor, 2.0f);    
    myPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&myPen, points, Num);

    #undef _2PI
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\cycloid.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Main cycloid canvas paint procedure
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "cycloid.hpp"
#include "wndstuff.h"

void HypoCycloid::Draw(Graphics *g, int x, int y, int width, int height)
{
    #define _2PI 2*3.141592653689
    
    // Compute the center point for the cycle.

    float fXo=static_cast<float>(width)/2.0f;
    float fYo=static_cast<float>(height)/2.0f;
    
    float ScaleX = fXo/( (a>b)?a:a+b );
    float ScaleY = fYo/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    int Num = cycle*30;
    
    PointF *points = new PointF[Num];

    // Compute the points tracking the cycloid path.

    for(int i=0; i<Num; i++) 
    {
        float t = (float)(cycle*_2PI*i/Num);
        points[i].X = x+(float)(fXo+ScaleX*((a-b)*cos(t)+b*cos((a-b)*t/b)));
        points[i].Y = y+(float)(fYo+ScaleY*((a-b)*sin(t)-b*sin((a-b)*t/b)));
    }
    
    Color PenColor(0xffff0000);   
    Pen myPen(PenColor, 2.0f);    
    myPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&myPen, points, Num);

    #undef _2PI
}

VOID
PaintWindow(
    HDC hdc
    )
{
    // Clear the window
      
    HGDIOBJ hbrush = GetStockObject(WHITE_BRUSH);
    HGDIOBJ holdBrush = SelectObject(hdc, hbrush);
    PatBlt(hdc, -10000, -10000, 20000, 20000, PATCOPY);
    SelectObject(hdc, holdBrush);
    DeleteObject(hbrush);

  
    Graphics *g = new Graphics(hdc);
    
    g->SetCompositingQuality(CompositingQualityGammaCorrected);
    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    // Do some stuff

    HypoCycloid *h = new HypoCycloid(52, 16);
    h->Draw(g, 10, 10, 400, 100);
    delete h;
    
    delete g;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\message.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Messages
*
* Abstract:
*
*   Simple class that encapsulates the necessary information to propagate
*   a basic object message
*
* Created:
*
*   06/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _MESSAGE_HPP
#define _MESSAGE_HPP

#include "precomp.hpp"

class Message {
    public: 
    INT TheMessage;
    WPARAM WParam;
    LPARAM LParam;
    
    public:
    Message(INT msg, WPARAM w, LPARAM l) {
        TheMessage = msg;
        WParam = w;
        LParam = l;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\object.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Object ancestor
*
* Abstract:
*
*   Ancestor class for all drawing objects
*
* Created:
*
*   06/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _OBJECT_HPP
#define _OBJECT_HPP

#include "precomp.hpp"

class DrawingObject {
    public:
    DrawingObject() {}
    
    // Tell the object to draw itself on this graphics, 
    // given a set of dimensions
    virtual void Draw(Graphics *g, int x, int y, int width, int height) = 0;
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\prime.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   prime.hpp
*
* Abstract:
*
*   Routines dealing with prime numbers and factorization.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _PRIME_HPP
#define _PRIME_HPP

#include "precomp.hpp"

// An array of the first 1000 prime numbers.

extern int PrimeNumbers[1000];

// Greatest Common Factor

int gcf(int a, int b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\precomp.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Header files included in this program 
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _PRECOMP_HPP
#define _PRECOMP_HPP

#include "global.h"
#include "prime.hpp"
#include "drawcycloid.hpp"
#include "message.hpp"
#include "object.hpp"
#include "manipulator.hpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
\***************************************************************************/
#pragma once

#include <windows.h>
#include <winuser.h>
#include <commdlg.h>

#define DONTUSE(x) (x)

#define IDM_OPENFILE         40000
#define IDM_QUIT             40001

VOID PaintWindow(HDC hdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* Menu driven test environment.
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include "wndstuff.h"

HINSTANCE ghInstance;
HWND ghwndMain;
HBRUSH ghbrWhite;

AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return (
        MultiByteToWideChar(
            CP_ACP,
            0,
            ansiStr,
            -1,
            unicodeStr,
            unicodeSize
        ) > 0
    );
}


void OpenFileProc(HWND hwnd)
{

    char locFileName[MAX_PATH];
    OPENFILENAME    ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = ghInstance;
    ofn.lpstrFile = locFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    locFileName[0] = '\0';

    // Present the file/open dialog

    if(GetOpenFileName(&ofn)) 
    {
        //AnsiToUnicodeStr(locFileName, FileName, MAX_PATH);
    }
}



/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;
    HDC hdc;

    switch (message)
    {
    
    case WM_CREATE:
        break;

    case WM_SIZE:
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        PaintWindow(hdc);
        ReleaseDC(hwnd, hdc);
        break;


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        
        case IDM_OPENFILE:
            OpenFileProc(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);        
        break;

        case IDM_QUIT:
            exit(0);
        break;
          
        default:
            // The user selected an unimplemented menu item.
            MessageBox(hwnd,
                _T("This is an unimplemented feature."), 
                _T(""),
                MB_OK
            );
        break;

        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes the app.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    // not quite so white background brush.
    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");

    if(!RegisterClass(&wc)) { return FALSE; }

    ghwndMain = CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL
    );

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return TRUE;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[]
)
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    ghInstance = GetModuleHandle(NULL);
    if(!bInitApp()) { return 0; }

    while(GetMessage (&msg, NULL, 0, 0))
    {
      if((ghwndMain == 0) || !IsDialogMessage(ghwndMain, &msg)) {
        TranslateMessage(&msg) ;
        DispatchMessage(&msg) ;
      }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dciperf\dciperf.c ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
* Dependencies:
*
\**************************************************************************/

#include <windows.h>

#include <stdio.h>
#include <commdlg.h>

#include <dciman.h>
#include <ddraw.h>
#include <limits.h>

VOID _fastcall KniNt128Write(VOID*);
VOID _fastcall Kni128Read(VOID*);

LPDIRECTDRAW        lpDD;
LPDIRECTDRAWSURFACE lpSurface;
DDSURFACEDESC       ddsd;
BOOL                gbWarned;

#define BYTE_OPS 1
#define MMX 1

#define WRITE_ITERATIONS    10000
#define READ_ITERATIONS     1000
#define NUM_BYTES           (8 * 1024)
#define WRITE_MEGS          ((WRITE_ITERATIONS * NUM_BYTES) / 1000.f)
#define READ_MEGS           ((READ_ITERATIONS * NUM_BYTES) / 1000.f)

/******************************Public*Routine******************************\
* vTestRegular
*
* Test regular IA instructions
*
\**************************************************************************/

VOID vTestRegular(
    PVOID pvBits
    )
{
    DWORD   dwStart;
    ULONG   i;
    ULONG   j;
    ULONG   ul;
    volatile BYTE*   pj;
    volatile USHORT* pus;
    volatile ULONG*  pul;
    BYTE    uchars;
    USHORT  ushorts;
    ULONG   ulongs;
    DWORD   dwTimeWritesConsecutiveBytes = LONG_MIN;
    DWORD   dwTimeWritesConsecutiveWords = LONG_MIN;
    DWORD   dwTimeWritesConsecutiveDwords = LONG_MIN;
    DWORD   dwTimeReadsConsecutiveBytes = LONG_MIN;
    DWORD   dwTimeReadsConsecutiveWords = LONG_MIN;
    DWORD   dwTimeReadsConsecutiveDwords = LONG_MIN;
    DWORD   dwTimeReadWritesConsecutiveBytes = LONG_MIN;
    DWORD   dwTimeReadWritesConsecutiveWords = LONG_MIN;
    DWORD   dwTimeReadWritesConsecutiveDwords = LONG_MIN;
    DWORD   dwTimeReadWritesBatchedBytes = LONG_MIN;
    DWORD   dwTimeReadWritesBatchedWords = LONG_MIN;
    DWORD   dwTimeReadWritesBatchedDwords = LONG_MIN;
    DWORD   dwTimeWritesInplaceBytes = LONG_MIN;
    DWORD   dwTimeWritesInplaceWords = LONG_MIN;
    DWORD   dwTimeWritesInplaceDwords = LONG_MIN;
    DWORD   dwTimeReadsInplaceBytes = LONG_MIN;
    DWORD   dwTimeReadsInplaceWords = LONG_MIN;
    DWORD   dwTimeReadsInplaceDwords = LONG_MIN;
    DWORD   dwTimeWritesRandomBytes = LONG_MIN;
    DWORD   dwTimeWritesRandomWords = LONG_MIN;
    DWORD   dwTimeWritesRandomDwords = LONG_MIN;
    DWORD   dwTimeReadsRandomBytes = LONG_MIN;
    DWORD   dwTimeReadsRandomWords = LONG_MIN;
    DWORD   dwTimeReadsRandomDwords = LONG_MIN;
    DWORD   dwTimeWritesUnalignedWords = LONG_MIN;
    DWORD   dwTimeWritesUnalignedDwords = LONG_MIN;
    DWORD   dwTimeReadsUnalignedWords = LONG_MIN;
    DWORD   dwTimeReadsUnalignedDwords = LONG_MIN;
    //
    // Consecutive writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj++ = (BYTE) i;
        }
    }
    dwTimeWritesConsecutiveBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus++ = (USHORT) i;
        }
    }
    dwTimeWritesConsecutiveWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul++ = (ULONG) i;
        }
    }
    dwTimeWritesConsecutiveDwords = GetTickCount() - dwStart;

    //
    // Consecutive reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj++;
        }
    }
    dwTimeReadsConsecutiveBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus++;
        }
    }
    dwTimeReadsConsecutiveWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul++;
        }
    }
    dwTimeReadsConsecutiveDwords = GetTickCount() - dwStart;

    //
    // Consecutive read/writes
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj;
            *pj = uchars;
            pj++;
        }
    }
    dwTimeReadWritesConsecutiveBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus;
            *pus = ushorts;
            pus++;
        }
    }
    dwTimeReadWritesConsecutiveWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul;
            *pul = ulongs;
            pul++;
        }
    }
    dwTimeReadWritesConsecutiveDwords = GetTickCount() - dwStart;

    //
    // Batched read/writes
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj++;
        }
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj++ = (BYTE) i;
        }
    }
    dwTimeReadWritesBatchedBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus++;
        }
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus++ = (USHORT) i;
        }
    }
    dwTimeReadWritesBatchedWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul++;
        }
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul++ = (ULONG) i;
        }
    }
    dwTimeReadWritesBatchedDwords = GetTickCount() - dwStart;

    //
    // Inplace writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj = (BYTE) i;
        }
    }
    dwTimeWritesInplaceBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus = (USHORT) i;
        }
    }
    dwTimeWritesInplaceWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul = (ULONG) i;
        }
    }
    dwTimeWritesInplaceDwords = GetTickCount() - dwStart;

    //
    // Inplace reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj;
        }
    }
    dwTimeReadsInplaceBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus;
        }
    }
    dwTimeReadsInplaceWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul;
        }
    }
    dwTimeReadsInplaceDwords = GetTickCount() - dwStart;

    //
    // Random writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj = (BYTE) i;
            pj += 64;
        }
    }
    dwTimeWritesRandomBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus = (USHORT) i;
            pus += 32;
        }
    }
    dwTimeWritesRandomWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul = (ULONG) i;
            pul += 16;
        }
    }
    dwTimeWritesRandomDwords = GetTickCount() - dwStart;

    //
    // Random reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj;
            pj += 64;
        }
    }
    dwTimeReadsRandomBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus;
            pus += 32;
        }
    }
    dwTimeReadsRandomWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul;
            pul += 16;
        }
    }
    dwTimeReadsRandomDwords = GetTickCount() - dwStart;

    //
    // Unaligned writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = (USHORT*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus++ = (USHORT) i;
        }
    }
    dwTimeWritesUnalignedWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = (ULONG*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul++ = (ULONG) i;
        }
    }
    dwTimeWritesUnalignedDwords = GetTickCount() - dwStart;

    //
    // Unaligned reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = (USHORT*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus++;
        }
    }
    dwTimeReadsUnalignedWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = (ULONG*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul++;
        }
    }
    dwTimeReadsUnalignedDwords = GetTickCount() - dwStart;

    lpSurface->lpVtbl->Unlock(lpSurface, ddsd.lpSurface);

    printf("Regular\n  Consecutive Writes: \t%2.2f, %2.2f, %2.2f\n  Consecutive Reads: \t%2.2f, %2.2f, %2.2f\n  Reads/writes: \t%2.2f, %2.2f, %2.2f\n  Batched reads/writes:\t%2.2f, %2.2f, %2.2f\n  Inplace Writes: \t%2.2f, %2.2f, %2.2f\n  Inplace Reads: \t%2.2f, %2.2f, %2.2f\n  Random Writes: \t%2.2f, %2.2f, %2.2f\n  Random Reads: \t%2.2f, %2.2f, %2.2f\n  Unaligned Writes: \t-, %2.2f, %2.2f\n  Unaligned Reads: \t-, %2.2f, %2.2f\n", 
        WRITE_MEGS / (FLOAT) dwTimeWritesConsecutiveBytes,
        WRITE_MEGS / (FLOAT) dwTimeWritesConsecutiveWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesConsecutiveDwords,
        READ_MEGS / (FLOAT) dwTimeReadsConsecutiveBytes,
        READ_MEGS / (FLOAT) dwTimeReadsConsecutiveWords,
        READ_MEGS / (FLOAT) dwTimeReadsConsecutiveDwords,
        READ_MEGS / (FLOAT) dwTimeReadWritesConsecutiveBytes,
        READ_MEGS / (FLOAT) dwTimeReadWritesConsecutiveWords,
        READ_MEGS / (FLOAT) dwTimeReadWritesConsecutiveDwords,
        READ_MEGS / (FLOAT) dwTimeReadWritesBatchedBytes,
        READ_MEGS / (FLOAT) dwTimeReadWritesBatchedWords,
        READ_MEGS / (FLOAT) dwTimeReadWritesBatchedDwords,
        WRITE_MEGS / (FLOAT) dwTimeWritesInplaceBytes,
        WRITE_MEGS / (FLOAT) dwTimeWritesInplaceWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesInplaceDwords,
        READ_MEGS / (FLOAT) dwTimeReadsInplaceBytes,
        READ_MEGS / (FLOAT) dwTimeReadsInplaceWords,
        READ_MEGS / (FLOAT) dwTimeReadsInplaceDwords,
        WRITE_MEGS / (FLOAT) dwTimeWritesRandomBytes,
        WRITE_MEGS / (FLOAT) dwTimeWritesRandomWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesRandomDwords,
        READ_MEGS / (FLOAT) dwTimeReadsRandomBytes,
        READ_MEGS / (FLOAT) dwTimeReadsRandomWords,
        READ_MEGS / (FLOAT) dwTimeReadsRandomDwords,
        WRITE_MEGS / (FLOAT) dwTimeWritesUnalignedWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesUnalignedDwords,
        READ_MEGS / (FLOAT) dwTimeReadsUnalignedWords,
        READ_MEGS / (FLOAT) dwTimeReadsUnalignedDwords);
}

/******************************Public*Routine******************************\
* vTestMmx
*
* Test MMX instructions
*
\**************************************************************************/

VOID vTestMmx(
    PVOID pvBits
    )
{

#if defined(_X86_)

    DWORD   dwStart;
    DWORD   dwTimeWritesMmxQwords = LONG_MIN;
    DWORD   dwTimeReadsMmxQwords = LONG_MIN;
    DWORD   dwTimeUnalignedWritesMmxQwords = LONG_MIN;
    DWORD   dwTimeUnalignedReadsMmxQwords = LONG_MIN;
    DWORD   dwTimeRandomWritesMmxQwords = LONG_MIN;
    DWORD   dwTimeRandomReadsMmxQwords = LONG_MIN;
    
    if (!IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
    {
        printf("MMX not detected.\n");
    }
    else
    {
        //
        // Mmx writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        MmxOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxInnerWrite:
            movq    [edi], mm0
            add     edi,8
            dec     ecx
            jnz     MmxInnerWrite
            dec     eax
            jnz     MmxOuterWrite
            emms
        }
        dwTimeWritesMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        MmxOuterRead:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxInnerRead:
            movq    mm0, [edi]
            add     edi,8
            dec     ecx
            jnz     MmxInnerRead
            dec     eax
            jnz     MmxOuterRead
            emms
        }
        dwTimeReadsMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx unaligned writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        MmxUnalignedOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
            inc     edi
        MmxUnalignedInnerWrite:
            movq    [edi], mm0
            add     edi,8
            dec     ecx
            jnz     MmxUnalignedInnerWrite
            dec     eax
            jnz     MmxUnalignedOuterWrite
            emms
        }
        dwTimeUnalignedWritesMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx unaligned reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        MmxUnalignedOuterRead:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
            inc     edi
        MmxUnalignedInnerRead:
            movq    mm0, [edi]
            add     edi,8
            dec     ecx
            jnz     MmxUnalignedInnerRead
            dec     eax
            jnz     MmxUnalignedOuterRead
            emms
        }

        dwTimeUnalignedReadsMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx random writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        MmxRandomOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxRandomInnerWrite:
            movq    [edi], mm0
            add     edi,64
            dec     ecx
            jnz     MmxRandomInnerWrite
            dec     eax
            jnz     MmxRandomOuterWrite
            emms
        }
        dwTimeRandomWritesMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx random reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        MmxRandomOuterRead:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxRandomInnerRead:
            movq    mm0, [edi]
            add     edi,64
            dec     ecx
            jnz     MmxRandomInnerRead
            dec     eax
            jnz     MmxRandomOuterRead
            emms
        }
        dwTimeRandomReadsMmxQwords = GetTickCount() - dwStart;

        printf("MMX\n  Consecutive Writes: \t%2.2f\n  Consecutive Reads: \t%2.2f\n  Unaligned Writes: \t%2.2f\n  Unaligned Reads: \t%2.2f\n  Random Writes: \t%2.2f\n  Random Reads: \t%2.2f\n",
            WRITE_MEGS / (FLOAT) dwTimeWritesMmxQwords,
            READ_MEGS / (FLOAT) dwTimeReadsMmxQwords,
            WRITE_MEGS / (FLOAT) dwTimeUnalignedWritesMmxQwords,
            READ_MEGS / (FLOAT) dwTimeUnalignedReadsMmxQwords,
            WRITE_MEGS / (FLOAT) dwTimeRandomWritesMmxQwords,
            READ_MEGS / (FLOAT) dwTimeRandomReadsMmxQwords);
    }

#endif

}

/******************************Public*Routine******************************\
* vTestKni
*
* Test Kni instructions
*
\**************************************************************************/

VOID vTestKni(
    PVOID pvBits
    )
{
    DWORD dwStart;
    DWORD dwTime;

#if defined(_X86_)

    if (!IsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE))
    {
        printf("SIMD instructions not detected.\n");
    }
    else
    {
        printf("SIMD\n");

        dwStart = GetTickCount();
        KniNt128Write(pvBits);
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit NT writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);

        dwStart = GetTickCount();
        Kni128Read(pvBits);
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit reads: \t%2.2f\n", READ_MEGS / (FLOAT) dwTime);

#if 0
    
        //
        // 64-bit non-temporal writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        Kni64NtOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        Kni64NtInnerWrite:
            asdfasdf [edi], mm0

            // movntq  [edi], mm0
            add     edi,8
            dec     ecx
            jnz     Kni64NtInnerWrite
            dec     eax
            sfence
            jnz     Kni64NtOuterWrite
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  64-bit non-temporal writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);
    
        //
        // 128-bit non-temporal writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        Kni128NtOuterWrite:
            mov     ecx, (NUM_BYTES / 16)
            mov     edi, pvBits
        Kni128NtInnerWrite:
            movntps [edi], xmm0
            add     edi,16
            dec     ecx
            jnz     Kni128NtInnerWrite
            dec     eax
            sfence
            jnz     Kni128NtOuterWrite
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit non-temporal writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);
    
        //
        // 128-bit normal writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        Kni128OuterWrite:
            mov     ecx, (NUM_BYTES / 16)
            mov     edi, pvBits
        Kni128InnerWrite:
            movps   [edi], xmm0
            add     edi,16
            dec     ecx
            jnz     Kni128InnerWrite
            dec     eax
            sfence
            jnz     Kni128OuterWrite
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit normal writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);
    
        //
        // 128-bit normal reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        Kni128OuterRead:
            mov     ecx, (NUM_BYTES / 16)
            mov     edi, pvBits
        Kni128InnerRead:
            movps   [edi], xmm0
            add     edi,16
            dec     ecx
            jnz     Kni128InnerRead
            dec     eax
            sfence
            jnz     Kni128OuterRead
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit normal reads: \t%2.2f\n", READ_MEGS / (FLOAT) dwTime);

        //
        // 32-bit reads with prefetch...
        //

        dwStart = GetTickCount();
        for (j = READ_ITERATIONS; j != 0; j--)
        {
            pul = pvBits;
            for (i = NUM_BYTES / 4; i != 0; i--)
            {
                ulongs |= *pul++;
            }
        }
        dwTime = GetTickCount() - dwStart;

        printf("  32-bit reads with prefetch: \t%2.2f\n", READ_MEGS / (FLOAT) dwTime);
    
#endif
    }

#endif

}

/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/


void
vTest(
    HWND hwnd
    )
{
    HDC     hdcScreen;
    VOID*   pvBits;
    ULONG   i;
    ULONG   j;
    ULONG   ul;
    volatile BYTE*   pj;
    volatile USHORT* pus;
    volatile ULONG*  pul;
    DWORD   dwStart;
    DWORD   dwTime;
    RECT    rect;

    if (lpSurface == NULL)
    {
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

        if ((DirectDrawCreate(NULL, &lpDD, NULL) != DD_OK) ||
            (lpDD->lpVtbl->SetCooperativeLevel(lpDD, hwnd, DDSCL_NORMAL) != DD_OK) ||
            (lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpSurface, NULL) != DD_OK))
        {
            MessageBox(0, "Initialization failure", "Uh oh", MB_OK);
            return;
        }
    }

    rect.left = 0;
    rect.top  = 0;
    rect.right  = 0;
    rect.bottom = 0;

    if (lpSurface->lpVtbl->Lock(lpSurface, &rect, &ddsd, DDLOCK_WAIT, NULL) != DD_OK)
    {
        if (!gbWarned)
        {
            MessageBox(0, "Driver not DirectDraw accelerated", "Uh oh", MB_OK);
        }

        return;
    }

    printf("Frame buffer performance test started.  Expect to see garbage at\n");
    printf("the top of your screen...\n\n");

    pvBits = ddsd.lpSurface;

    vTestRegular(pvBits);
    vTestMmx(pvBits);
    vTestKni(pvBits);

    lpSurface->lpVtbl->Unlock(lpSurface, ddsd.lpSurface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\cycloid\prime.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   prime.cpp
*
* Abstract:
*
*   Routines dealing with prime numbers and factorization.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "prime.hpp"

// An array of the first 1000 prime numbers.

int PrimeNumbers[1000] = {
      2,     3,     5,     7,    11,    13,    17,    19,    23,    29,
     31,    37,    41,    43,    47,    53,    59,    61,    67,    71,
     73,    79,    83,    89,    97,   101,   103,   107,   109,   113,
    127,   131,   137,   139,   149,   151,   157,   163,   167,   173,
    179,   181,   191,   193,   197,   199,   211,   223,   227,   229,
    233,   239,   241,   251,   257,   263,   269,   271,   277,   281,
    283,   293,   307,   311,   313,   317,   331,   337,   347,   349,
    353,   359,   367,   373,   379,   383,   389,   397,   401,   409,
    419,   421,   431,   433,   439,   443,   449,   457,   461,   463,
    467,   479,   487,   491,   499,   503,   509,   521,   523,   541,
    547,   557,   563,   569,   571,   577,   587,   593,   599,   601,
    607,   613,   617,   619,   631,   641,   643,   647,   653,   659,
    661,   673,   677,   683,   691,   701,   709,   719,   727,   733,
    739,   743,   751,   757,   761,   769,   773,   787,   797,   809,
    811,   821,   823,   827,   829,   839,   853,   857,   859,   863,
    877,   881,   883,   887,   907,   911,   919,   929,   937,   941,
    947,   953,   967,   971,   977,   983,   991,   997,  1009,  1013,
   1019,  1021,  1031,  1033,  1039,  1049,  1051,  1061,  1063,  1069,
   1087,  1091,  1093,  1097,  1103,  1109,  1117,  1123,  1129,  1151,
   1153,  1163,  1171,  1181,  1187,  1193,  1201,  1213,  1217,  1223,
   1229,  1231,  1237,  1249,  1259,  1277,  1279,  1283,  1289,  1291,
   1297,  1301,  1303,  1307,  1319,  1321,  1327,  1361,  1367,  1373,
   1381,  1399,  1409,  1423,  1427,  1429,  1433,  1439,  1447,  1451,
   1453,  1459,  1471,  1481,  1483,  1487,  1489,  1493,  1499,  1511,
   1523,  1531,  1543,  1549,  1553,  1559,  1567,  1571,  1579,  1583,
   1597,  1601,  1607,  1609,  1613,  1619,  1621,  1627,  1637,  1657,
   1663,  1667,  1669,  1693,  1697,  1699,  1709,  1721,  1723,  1733,
   1741,  1747,  1753,  1759,  1777,  1783,  1787,  1789,  1801,  1811,
   1823,  1831,  1847,  1861,  1867,  1871,  1873,  1877,  1879,  1889,
   1901,  1907,  1913,  1931,  1933,  1949,  1951,  1973,  1979,  1987,
   1993,  1997,  1999,  2003,  2011,  2017,  2027,  2029,  2039,  2053,
   2063,  2069,  2081,  2083,  2087,  2089,  2099,  2111,  2113,  2129,
   2131,  2137,  2141,  2143,  2153,  2161,  2179,  2203,  2207,  2213,
   2221,  2237,  2239,  2243,  2251,  2267,  2269,  2273,  2281,  2287,
   2293,  2297,  2309,  2311,  2333,  2339,  2341,  2347,  2351,  2357,
   2371,  2377,  2381,  2383,  2389,  2393,  2399,  2411,  2417,  2423,
   2437,  2441,  2447,  2459,  2467,  2473,  2477,  2503,  2521,  2531,
   2539,  2543,  2549,  2551,  2557,  2579,  2591,  2593,  2609,  2617,
   2621,  2633,  2647,  2657,  2659,  2663,  2671,  2677,  2683,  2687,
   2689,  2693,  2699,  2707,  2711,  2713,  2719,  2729,  2731,  2741,
   2749,  2753,  2767,  2777,  2789,  2791,  2797,  2801,  2803,  2819,
   2833,  2837,  2843,  2851,  2857,  2861,  2879,  2887,  2897,  2903,
   2909,  2917,  2927,  2939,  2953,  2957,  2963,  2969,  2971,  2999,
   3001,  3011,  3019,  3023,  3037,  3041,  3049,  3061,  3067,  3079,
   3083,  3089,  3109,  3119,  3121,  3137,  3163,  3167,  3169,  3181,
   3187,  3191,  3203,  3209,  3217,  3221,  3229,  3251,  3253,  3257,
   3259,  3271,  3299,  3301,  3307,  3313,  3319,  3323,  3329,  3331,
   3343,  3347,  3359,  3361,  3371,  3373,  3389,  3391,  3407,  3413,
   3433,  3449,  3457,  3461,  3463,  3467,  3469,  3491,  3499,  3511,
   3517,  3527,  3529,  3533,  3539,  3541,  3547,  3557,  3559,  3571,
   3581,  3583,  3593,  3607,  3613,  3617,  3623,  3631,  3637,  3643,
   3659,  3671,  3673,  3677,  3691,  3697,  3701,  3709,  3719,  3727,
   3733,  3739,  3761,  3767,  3769,  3779,  3793,  3797,  3803,  3821,
   3823,  3833,  3847,  3851,  3853,  3863,  3877,  3881,  3889,  3907,
   3911,  3917,  3919,  3923,  3929,  3931,  3943,  3947,  3967,  3989,
   4001,  4003,  4007,  4013,  4019,  4021,  4027,  4049,  4051,  4057,
   4073,  4079,  4091,  4093,  4099,  4111,  4127,  4129,  4133,  4139,
   4153,  4157,  4159,  4177,  4201,  4211,  4217,  4219,  4229,  4231,
   4241,  4243,  4253,  4259,  4261,  4271,  4273,  4283,  4289,  4297,
   4327,  4337,  4339,  4349,  4357,  4363,  4373,  4391,  4397,  4409,
   4421,  4423,  4441,  4447,  4451,  4457,  4463,  4481,  4483,  4493,
   4507,  4513,  4517,  4519,  4523,  4547,  4549,  4561,  4567,  4583,
   4591,  4597,  4603,  4621,  4637,  4639,  4643,  4649,  4651,  4657,
   4663,  4673,  4679,  4691,  4703,  4721,  4723,  4729,  4733,  4751,
   4759,  4783,  4787,  4789,  4793,  4799,  4801,  4813,  4817,  4831,
   4861,  4871,  4877,  4889,  4903,  4909,  4919,  4931,  4933,  4937,
   4943,  4951,  4957,  4967,  4969,  4973,  4987,  4993,  4999,  5003,
   5009,  5011,  5021,  5023,  5039,  5051,  5059,  5077,  5081,  5087,
   5099,  5101,  5107,  5113,  5119,  5147,  5153,  5167,  5171,  5179,
   5189,  5197,  5209,  5227,  5231,  5233,  5237,  5261,  5273,  5279,
   5281,  5297,  5303,  5309,  5323,  5333,  5347,  5351,  5381,  5387,
   5393,  5399,  5407,  5413,  5417,  5419,  5431,  5437,  5441,  5443,
   5449,  5471,  5477,  5479,  5483,  5501,  5503,  5507,  5519,  5521,
   5527,  5531,  5557,  5563,  5569,  5573,  5581,  5591,  5623,  5639,
   5641,  5647,  5651,  5653,  5657,  5659,  5669,  5683,  5689,  5693,
   5701,  5711,  5717,  5737,  5741,  5743,  5749,  5779,  5783,  5791,
   5801,  5807,  5813,  5821,  5827,  5839,  5843,  5849,  5851,  5857,
   5861,  5867,  5869,  5879,  5881,  5897,  5903,  5923,  5927,  5939,
   5953,  5981,  5987,  6007,  6011,  6029,  6037,  6043,  6047,  6053,
   6067,  6073,  6079,  6089,  6091,  6101,  6113,  6121,  6131,  6133,
   6143,  6151,  6163,  6173,  6197,  6199,  6203,  6211,  6217,  6221,
   6229,  6247,  6257,  6263,  6269,  6271,  6277,  6287,  6299,  6301,
   6311,  6317,  6323,  6329,  6337,  6343,  6353,  6359,  6361,  6367,
   6373,  6379,  6389,  6397,  6421,  6427,  6449,  6451,  6469,  6473,
   6481,  6491,  6521,  6529,  6547,  6551,  6553,  6563,  6569,  6571,
   6577,  6581,  6599,  6607,  6619,  6637,  6653,  6659,  6661,  6673,
   6679,  6689,  6691,  6701,  6703,  6709,  6719,  6733,  6737,  6761,
   6763,  6779,  6781,  6791,  6793,  6803,  6823,  6827,  6829,  6833,
   6841,  6857,  6863,  6869,  6871,  6883,  6899,  6907,  6911,  6917,
   6947,  6949,  6959,  6961,  6967,  6971,  6977,  6983,  6991,  6997,
   7001,  7013,  7019,  7027,  7039,  7043,  7057,  7069,  7079,  7103,
   7109,  7121,  7127,  7129,  7151,  7159,  7177,  7187,  7193,  7207,
   7211,  7213,  7219,  7229,  7237,  7243,  7247,  7253,  7283,  7297,
   7307,  7309,  7321,  7331,  7333,  7349,  7351,  7369,  7393,  7411,
   7417,  7433,  7451,  7457,  7459,  7477,  7481,  7487,  7489,  7499,
   7507,  7517,  7523,  7529,  7537,  7541,  7547,  7549,  7559,  7561,
   7573,  7577,  7583,  7589,  7591,  7603,  7607,  7621,  7639,  7643,
   7649,  7669,  7673,  7681,  7687,  7691,  7699,  7703,  7717,  7723,
   7727,  7741,  7753,  7757,  7759,  7789,  7793,  7817,  7823,  7829,
   7841,  7853,  7867,  7873,  7877,  7879,  7883,  7901,  7907,  7919
};



/**************************************************************************
*
* Function Description:
*
*   gcf(a,b) returns the greatest common factor of two integers.
*   Example: 24=2.2.2.3, 20=2.2.5, gcf(24,20)=4=2.2
*
* Arguments:
*
*   [IN] a, b  - the two numbers
*
*
* Return Value:
*
*   return value is the greatest common factor of a and b
*
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

int gcf(int a, int b) {
  int gcftot=1;
  int minab = min(a,b);
  int limit = (int) sqrt((float)minab);
  int pf;

  int i=0;
  pf = PrimeNumbers[i];
  do {
    if( (a % pf == 0) &&                 //does this prime number divide into
        (b % pf == 0) ) {                //what we have left?
      a /= pf;                           //remove this common factor
      b /= pf;
      gcftot *= pf;                      //remember this common factor
    } else {
      pf = PrimeNumbers[++i];            //start on the next prime number
    }
  } while ((i<1000) && (pf<=limit));

  return gcftot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dciperf\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: hello.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

BOOL bInitApp(VOID);
VOID vTest(HWND);
LRESULT lMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

#define MY_WINDOWSTYLE_FLAGS       \
            (                      \
                WS_OVERLAPPED   |  \
                WS_CAPTION      |  \
                WS_BORDER       |  \
                WS_THICKFRAME   |  \
                WS_MAXIMIZEBOX  |  \
                WS_MINIMIZEBOX  |  \
                WS_CLIPCHILDREN |  \
                WS_VISIBLE      |  \
                WS_SYSMENU         \
            )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dlltest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

#define IDB_BITMAPCMYKTEST  0x9001

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dciperf\wndstuff.c ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.c
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wndstuff.h"

HANDLE  ghInstance;
HWND    ghwndMain;
HBRUSH  ghbrWhite;

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HANDLE haccel;

    DONTUSE(argc);
    DONTUSE(argv);

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = "MainMenu";
    wc.lpszClassName    = "TestClass";
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        "TestClass",
        "Win32 Test",
        MY_WINDOWSTYLE_FLAGS,
        80,
        70,
        400,
        300,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return(TRUE);
}

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL gbOn = FALSE;
POINTL ptlWindow;
SIZEL sizlWindow;

LRESULT
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (message)
    {
    case WM_CREATE:

        vTest(hwnd);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    case WM_DESTROY:

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:

        return(DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dciperf\i386\kni.asm ===
title  "KNI Performance Test"
;++
;
; Copyright (c) 1998  Microsoft Corporation
;
; Module Name:
;
;    kni.asm
;
; Abstract:
;
;    Test KNI performance for video memory.  Based on PeterJ's zero.asm.
;
; Environment:
;
;    x86
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc
        .list

;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

;
; Define SIMD instructions used in this module.
;

if 0

; these remain for reference only.   In theory the stuff following
; should generate the right code.

xorps_xmm0_xmm0 macro
                db      0FH, 057H, 0C0H
                endm

movntps_edx     macro   Offset
                db      0FH, 02BH, 042H, Offset
                endm

movaps_esp_xmm0 macro
                db      0FH, 029H, 004H, 024H
                endm

movaps_xmm0_esp macro
                db      0FH, 028H, 004H, 024H
                endm

endif

xorps           macro   XMMReg1, XMMReg2
                db      0FH, 057H, 0C0H + (XMMReg1 * 8) + XMMReg2
                endm

movntps         macro   GeneralReg, Offset, XMMReg
                db      0FH, 02BH, 040H + (XmmReg * 8) + GeneralReg, Offset
                endm
                
movaps_toreg    macro   GeneralReg, Offset, XMMReg
                db      0Fh, 028H, 040H + (XmmReg * 8) + GeneralReg, Offset
                endm
                
emms            macro
                db      0FH, 077H
                endm
                
sfence          macro
                db      0FH, 0AEH, 0F8H
                endm

movaps_load     macro   XMMReg, GeneralReg
                db      0FH, 028H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm

movaps_store    macro   GeneralReg, XMMReg
                db      0FH, 029H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm


;
; NPX Save and Restore
;

fxsave          macro   Register
                db      0FH, 0AEH, Register
                endm

fxrstor         macro   Register
                db      0FH, 0AEH, 8+Register
                endm

;
; Test constants
;

WRITE_ITERATIONS        equ     10000
READ_ITERATIONS         equ     1000
NUM_BYTES               equ     (8 * 1024)


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; KniNt128Write(
;     PVOID Address
;     )
;
; Routine Description:
;
;     64-bit non-temporal writes...
;
; Arguments:
;
;     (ecx) Address    Address to be written to
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KniNt128Write,1
cPublicFpo 0, 0

        push    edi
        mov     eax, WRITE_ITERATIONS
        
KniNt128WriteOuter::
        mov     edx, (NUM_BYTES / 16)
        mov     edi, ecx
        
KniNt128WriteInner::
        movntps rEDI, 0, 0                      ; store xmm0 at [edi]
        add     edi, 16
        dec     edx
        jnz     KniNt128WriteInner
        dec     eax
        sfence
        jnz     KniNt128WriteOuter
        emms

        pop     edi                             ; restore edi and return
        fstRET  KniNt128Write

fstENDP KniNt128Write

cPublicFastCall Kni128Read,1
cPublicFpo 0, 0

        push    edi
        mov     eax, READ_ITERATIONS
        
Kni128ReadOuter::
        mov     edx, (NUM_BYTES / 16)
        mov     edi, ecx
        
Kni128ReadInner::
        movaps_toreg rEDI, 0, 0                 ; read xmm0 from [edi]
        add     edi, 16
        dec     edx
        jnz     Kni128ReadInner
        dec     eax
        jnz     Kni128ReadOuter

        pop     edi                             ; restore edi and return
        fstRET  Kni128Read

fstENDP Kni128Read

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dlltest\dlltest.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46          
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include "wndstuff.h"
#include "debug.h"

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

#ifndef ASSERT
    #define ASSERT(cond)    if (!(cond)) { DebugBreak(); }
#endif

/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

class RectI
{
public:
    INT X;
    INT Y;
    INT Width;
    INT Height;
};

VOID TestRotatedLine(Graphics *g);
VOID TestLineWithTexture(Graphics *g);
VOID TestRegionExcludeClip(Graphics *g);
VOID TestRegionXorClip(Graphics *g);
VOID TestContainerClip(Graphics *g);
VOID TestContainer(Graphics *g);
VOID TestPolygons(Graphics *g);
VOID TestPaths(Graphics *g);
VOID TestPathIterators(Graphics *g);
VOID TestDashes(Graphics *g);
VOID TestWideningAndWarping(Graphics *g);
VOID TestRegions(Graphics *g);
VOID TestGradients(Graphics* g);
VOID TestHatches(Graphics* g);
VOID TestBitmaps(Graphics* g);
VOID TestPrimitives(Graphics *g);
VOID TestMixedObjects(Graphics *g);
VOID TestTexts(Graphics* g);
VOID TestTextAlongPath(Graphics *g);
VOID TestDerive(HWND hwnd);
VOID TestImaging(Graphics* g);
VOID TestBitmapGraphics(Graphics* g);
VOID TestDibsection(Graphics* g);
VOID TestCompoundLines(Graphics *g);
VOID TestImageSampling(Graphics *g);
VOID TestIcon(Graphics *g);

VOID TestWmfs(Graphics *g);
VOID TestMetaGetDC(Graphics *g, HWND hwnd);
VOID TestMetafileEnumeration(Graphics *g);
VOID TestMetafileTextureBrush(Graphics *g);
VOID TestGetHemf(HDC hdc);
VOID TestLargeMetafileObject(Graphics* g, HDC hdc);
VOID TestTextToMetafile(Graphics *g, HDC hdc);
VOID TestCmykSeparation(Graphics *g);
VOID TestDownLevelBitmapTransparency(Graphics *g, HDC hdc);
VOID DrawHatches(Graphics * g);


VOID
Test(
    HWND hwnd
    )
{
    HDC hdc = GetDC(hwnd);

    // Select in the halftone palette for 256-color display mode testing
    HPALETTE hpal = Graphics::GetHalftonePalette();
    SelectPalette(hdc, hpal, FALSE);
    RealizePalette(hdc);

    Graphics *g = new Graphics(hdc);

    TestMetaGetDC(g, hwnd); // this has to be the first test!

    // Test GetNearestColor
    Color c(0x32, 0x67, 0x98);
    g->GetNearestColor(&c);

    TestDownLevelBitmapTransparency(g, hdc);
    TestTextToMetafile(g, hdc);
    TestLargeMetafileObject(g, hdc);
    TestGetHemf(hdc);
    TestMetafileEnumeration(g);
    TestMetafileTextureBrush(g);
    TestRotatedLine(g);
    TestWmfs(g);

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    // Scale everything up by scale
    REAL scale = (REAL) 1.2;
    g->SetPageUnit(UnitDisplay);
    g->SetPageScale(scale);
    g->RotateTransform(10);

    {
        HDC     hdc = GetDC(hwnd);
        {
            Metafile recording(L"TestEmfP.Emf", hdc);
            Graphics gMeta(&recording);

            gMeta.SetSmoothingMode(SmoothingModeAntiAlias);
            TestRegionExcludeClip(&gMeta);
            TestRegionXorClip(&gMeta);
            TestBitmaps(&gMeta);
            gMeta.RotateTransform(30);
            gMeta.SetSmoothingMode(SmoothingModeAntiAlias);
            TestContainer(&gMeta);
        }

        {
            Metafile playback(L"TestEmfP.Emf");
            g->DrawImage(&playback, 0, 0);
        }
        ReleaseDC(hwnd, hdc);
    }

    TestContainerClip(g);
    TestPolygons(g);
//    TestPaths(g);
    TestPathIterators(g);   // Identical to TestPaths except for using iterators.
    TestRegions(g);
    TestBitmaps(g);
    TestPrimitives(g);
    TestMixedObjects(g);
    TestGradients(g);
    TestHatches(g);
    TestTexts(g);
    TestDerive(hwnd);
    TestDashes(g);
    TestWideningAndWarping(g);
    TestImaging(g);
    TestBitmapGraphics(g);
    TestLineWithTexture(g);
    TestDibsection(g);
    TestCompoundLines(g);
    TestImageSampling(g);
    TestIcon(g);
    TestCmykSeparation(g);
    DrawHatches(g);

    {
        Metafile recordDown(L"Hatches.emf", hdc, EmfTypeEmfOnly);
        {
            Graphics    gMeta(&recordDown);
            
            DrawHatches(&gMeta);
        }
        g->DrawImage(&recordDown, 330, 0);
    }

    delete g;
    ReleaseDC(hwnd, hdc);
    DeleteObject(hpal);
}

VOID DrawHatches(Graphics * g)
{
    HatchBrush  h1 (HatchStyleHorizontal, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h2 (HatchStyleVertical, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h3 (HatchStyleForwardDiagonal, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h4 (HatchStyleBackwardDiagonal, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h5 (HatchStyleCross, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h6 (HatchStyleDiagonalCross, Color(255, 0, 0), Color(0, 255, 255));

    g->FillEllipse(&h1, 0, 0, 100, 100);
    g->FillEllipse(&h2, 110, 0, 100, 100);
    g->FillEllipse(&h3, 220, 0, 100, 100);
    g->FillEllipse(&h4, 0, 110, 100, 100);
    g->FillEllipse(&h5, 110, 110, 100, 100);
    g->FillEllipse(&h6, 220, 110, 100, 100);
}

VOID TestDownLevelBitmapTransparency(Graphics *g, HDC hdc)
{
    Metafile recordDown(L"DownLevelBm.emf", hdc, EmfTypeEmfOnly);
    {
        Graphics    gMeta(&recordDown);
        Bitmap      bm(50, 50, PixelFormat32bppARGB);
        {
            Graphics    gBitmap(&bm);
            gBitmap.Clear(Color(128, 255, 0, 0));
        }

        GraphicsPath    path;
    
        Rect    r(0,0,50,50);
        path.AddRectangle(r);
        SolidBrush  sb(Color(0, 0xFF, 0));
    
        gMeta.FillPath(&sb, &path);
        gMeta.DrawImage(&bm, 25, 25);
    }
    g->DrawImage(&recordDown, 200, 200);
}

VOID TestLargeMetafileObject(Graphics* g, HDC hdc)
{
    Metafile recording(L"Large.emf", hdc);
    {
        Image image(L"..\\data\\real3.jpg");
        TextureBrush textureBrush(&image, WrapModeTile);
        Matrix matrix;
        matrix.Scale(.2f, .2f);
        textureBrush.SetTransform(&matrix);
        Graphics gMeta(&recording);
        gMeta.FillRectangle(&textureBrush, 0, 0, 800, 600);
        Pen pen(&textureBrush, 40.0);
        pen.SetLineJoin(LineJoinMiter);
        PointF  spiralPoints[12] = {
            PointF(540.0f, 550.0f),
            PointF(540.0f,  75.0f),
            PointF( 60.0f,  75.0f),
            PointF( 60.0f, 460.0f),
            PointF(460.0f, 460.0f),
            PointF(460.0f, 140.0f),
            PointF(140.0f, 140.0f),
            PointF(140.0f, 400.0f),
            PointF(380.0f, 400.0f),
            PointF(380.0f, 190.0f),
            PointF(260.0f, 190.0f),
            PointF(260.0f, 350.0f),
            };

         gMeta.DrawLines(&pen, spiralPoints, 12);
    }
    g->DrawImage(&recording, 20, 300, 600, 400);
}

VOID TestGetHemf(HDC hdc)
{
    Metafile recording(L"Abcdefg.Emf", hdc);
    {
        Graphics gMeta(&recording);
        SolidBrush  sb(Color(0xFF, 0, 0));
        gMeta.FillRectangle(&sb, 0, 0, 20, 20);
    }
    HENHMETAFILE    hemf;
    hemf = recording.GetHENHMETAFILE();
    DeleteEnhMetaFile(hemf);
}

VOID TestMetafileTextureBrush(Graphics *g)
{
    Metafile m1(L"..\\data\\agree.emf");
    Rect r(0, 0, 50, 50);
    TextureBrush textureBrush(&m1, WrapModeTile, r);
    g->FillRectangle(&textureBrush, 0, 0, 800, 800);
}

extern "C"
BOOL CALLBACK
MyPlayMetafileRecordCallback(
    EmfPlusRecordType       recordType,
    UINT                    recordFlags,
    UINT                    recordDataSize,
    const BYTE *            recordData,
    VOID *                  callbackData
    )
{
    ((Metafile *)callbackData)->PlayRecord(recordType, recordFlags, recordDataSize, recordData);
    return TRUE;
}

VOID TestMetafileEnumeration(Graphics *g)
{
    Metafile m1(L"..\\data\\agree.emf");
    g->EnumerateMetafile(&m1, Rect(50, 10, 800, 500), MyPlayMetafileRecordCallback, &m1);

    Metafile m2(L"..\\data\\tiger.wmf");
    g->EnumerateMetafile(&m2, Rect(50, 10, 800, 500), MyPlayMetafileRecordCallback, &m2);
}

VOID DrawContainer(Graphics * g, ARGB * argb, INT count)
{
    Matrix    mymatrix;
    g->SetPageUnit(UnitInch);

    RectF clipRect(0,0,5,5);
    g->SetClip(clipRect);

    mymatrix.Translate(2.5, 2.5);
    mymatrix.Rotate(15);
    mymatrix.Translate(-2.5, -2.5);
    g->SetTransform(&mymatrix);

    Color   color(*argb++);
    SolidBrush contBrush(color);
    g->FillRectangle(&contBrush, 0, 0, 5, 5);
    if (--count == 0)
    {
        return;
    }
    RectF     destRect(.5, .5, 4, 4);
    RectF     srcRect(0, 0, 5, 5);
    INT id = g->BeginContainer(destRect, srcRect, UnitInch);
    g->ResetClip();
    DrawContainer (g, argb, count);
    g->EndContainer(id);
}

VOID TestContainerClip(Graphics *g)
{
    ARGB     colors[5];

    colors[0] = Color::MakeARGB(255, 255, 0, 0);
    colors[1] = Color::MakeARGB(255, 0, 255, 0);
    colors[2] = Color::MakeARGB(255, 0, 0, 255);
    colors[3] = Color::MakeARGB(255, 255, 255, 0);
    colors[4] = Color::MakeARGB(255, 0, 255, 255);

    GraphicsState s = g->Save();
    DrawContainer(g, colors, 5);
    g->Restore(s);
}

GraphicsPath      circlePath;
RectF        circleRect(0,0,4,4);
BOOL              circleInitialized = FALSE;

#define ROOT    0
#define LEFT    1
#define RIGHT   2
#define TOP     3
#define BOTTOM  4



VOID DrawFractal(Graphics * g, BYTE gray, INT side, INT count)
{
    ARGB        argb;

    switch (count % 3)
    {
    case 0:
        argb = Color::MakeARGB(255, 0, 0, gray);
        break;
    case 1:
        argb = Color::MakeARGB(255, 0, gray, 0);
        break;
    case 2:
        argb = Color::MakeARGB(255, gray, 0, 0);
        gray -= 60;
        break;
    }
    Color   color(argb);
    SolidBrush contBrush(color);
    g->SetPageUnit(UnitInch);
    g->FillPath(&contBrush, &circlePath);

    if (--count == 0)
    {
        return;
    }

    RectF               destRect;
    GraphicsContainer   cstate;

    if (side != LEFT)
    {
        destRect = RectF(4, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, RIGHT, count);
        g->EndContainer(cstate);
    }
    if (side != TOP)
    {
        destRect = RectF(1, 4, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, BOTTOM, count);
        g->EndContainer(cstate);
    }
    if (side != RIGHT)
    {
        destRect = RectF(-2, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, LEFT, count);
        g->EndContainer(cstate);
    }
    if (side != BOTTOM)
    {
        destRect = RectF(1, -2, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, TOP, count);
        g->EndContainer(cstate);
    }
}

VOID TestContainer(Graphics * g)
{
    if(!circleInitialized)
    {
        circlePath.AddEllipse(circleRect);
        circleInitialized = TRUE;
    }

    INT id = g->Save();
    g->TranslateTransform(5, 4);
    DrawFractal(g, 245, ROOT, 8);
    g->Restore(id);
}

/**************************************************************************\
* TestPolygons
*
* A test for drawing and filling of rectangles and polygons.
*
\**************************************************************************/

VOID TestPolygons(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, 20, 20, 50, 50);

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, 10, 10, 40, 40);

    PointF points[4];
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}


/**************************************************************************\
* TestPaths
*
* A test for general paths.
*
\**************************************************************************/

VOID TestPaths(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
//    blackPen.SetEndCap(LineCapSquare);
    blackPen.SetEndCap(LineCapArrowAnchor);
    Region * region = new Region(path);
    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}


/**************************************************************************\
* TestPaths
*
* A test for general paths.
*
\**************************************************************************/

VOID TestPathIterators(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
//    blackPen.SetEndCap(LineCapSquare);
    blackPen.SetEndCap(LineCapArrowAnchor);


    // Test for Path data getter and setter.

    INT count = path->GetPointCount();
    if(count > 0)
    {
        // Allocate points and types buffers.

        PathData pathData1;
        pathData1.Points = new PointF[count];
        pathData1.Types = new BYTE[count];

        if(pathData1.Points && pathData1.Types)
        {
            pathData1.Count = count;

            // Get the path data.

            if(path->GetPathData(&pathData1) == Ok)
            {
                GraphicsPath* path1 = new GraphicsPath(pathData1.Points,
                                                       pathData1.Types,
                                                       pathData1.Count,
                                                       FillModeAlternate);
                if(path1)
                {
                    g->FillPath(&yellowBrush, path1);
                }

                delete path1;
            }
        }
    }

    // Test for Path Iterator.

    GraphicsPathIterator iter(path);

    if(iter.GetLastStatus() == Ok)
    {
        count = iter.GetCount();

        PointF* newPts = new PointF[count];
        BYTE* newTypes = new BYTE[count];

        if(newPts && newTypes && count > 0)
        {
            // Get the path's points and types data by using
            // an enumeration method.

            INT resultCount = iter.Enumerate(newPts, newTypes, count);
            if (resultCount > 0)
            {
                GraphicsPath* path2 = new GraphicsPath(newPts,
                                                       newTypes,
                                                       resultCount,
                                                       FillModeAlternate);

                if(path2 && resultCount > 0)
                {
                    g->DrawPath(&blackPen, path2);

                    delete path2;
                }
            }
        }

        delete[] newPts;
        delete[] newTypes;
    }

    delete path;
}

/**************************************************************************\
* TestDashes
*
* A test for drawing dashed lines.
*
\**************************************************************************/

VOID TestDashes(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen pen1(&blackBrush, width);
    pen1.SetDashStyle(DashStyleDashDotDot);
    pen1.SetDashCap(DashCapRound);
    g->DrawPath(&pen1, path);

    // Create a multiple segment with a closed segment.

    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;

    path->Reset();
    path->AddLines(points, 4);
    path->CloseFigure();

    points[0].X = 150;
    points[0].Y = 60;
    points[1].X = 200;
    points[1].Y = 150;
    path->AddLines(points, 2);
    path->Transform(&matrix);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);

    width = 5;
    Pen pen2(&blueBrush, width);
    pen2.SetDashStyle(DashStyleDashDotDot);
    g->DrawPath(&pen2, path);

    delete path;
}

/**************************************************************************\
* TestWideningAndWarping
*
* A test for widening and warping paths.
*
\**************************************************************************/

VOID TestWideningAndWarping(Graphics *g)
{
    REAL width;         // Pen width
    RectF rect;

    rect.X = 250;
    rect.Y = -30;
    rect.Width = 150;
    rect.Height = 150;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddRectangle(rect);

    rect.Y = 70;
    path->AddEllipse(rect);

    Matrix matrix;

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);

    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
    blackPen.SetEndCap(LineCapSquare);

    path->Widen(&blackPen, &matrix);

    RectF bounds;

    path->GetBounds(&bounds);

    PointF destPoints[4];

    destPoints[0].X = bounds.X + bounds.Width/4;
    destPoints[0].Y = bounds.Y;
    destPoints[1].X = bounds.X + 3*bounds.Width/4;
    destPoints[1].Y = bounds.Y;
    destPoints[2].X = bounds.X;
    destPoints[2].Y = bounds.Y + bounds.Height;
    destPoints[3].X = bounds.X + bounds.Width;
    destPoints[3].Y = bounds.Y + bounds.Height;

    path->Warp(&destPoints[0], 4, bounds);

    g->FillPath(&yellowBrush, path);

    width = 0.05f;
    blackPen.SetWidth(width);
    g->DrawPath(&blackPen, path);
    delete path;
}

/**************************************************************************\
* TestRegions
*
* A test for region fill.
*
\**************************************************************************/

VOID TestRegions(Graphics *g)
{
    REAL width = 2;     // Pen width
    PointF points[5];

    REAL s, c, theta;
    REAL pi = 3.1415926535897932f;
    REAL scale = 30;
    PointF orig(200, 140);

    theta = -pi/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        points[i].X = scale*c + orig.X;
        points[i].Y = scale*s + orig.Y;
        theta += 0.8f*pi;
    }

    Color orangeColor(128, 255, 180, 0);

    SolidBrush orangeBrush(orangeColor);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
//    Path* path = new GraphicsPath(Winding);
    path->AddPolygon(points, 5);

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    Region * region = new Region(path);

    Matrix m;
    g->GetTransform(&m);
    INT rectCount;
    rectCount = region->GetRegionScansCount(&m);
    Rect *  rects = new Rect[rectCount];
    region->GetRegionScans(&m, rects, &rectCount);
    delete rects;

    g->FillRegion(&orangeBrush, region);  // There is a BUG!
//    g->FillGraphicsPath(&orangeBrush, path);  // Fill path works fine.

    blackPen.SetLineJoin(LineJoinMiter);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}

GraphicsPath* CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();

    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}


/**************************************************************************\
* TestGradients
*
* A test for rectangle and radial gradients.
*
\**************************************************************************/

VOID TestGradients(Graphics* g)
{
    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

// !! No longer used
//    RectangleGradientBrush rectGrad(brushRect, (Color*) &colors, WrapModeTile);

    // Rotate a brush.
    GpMatrix xForm;
    xForm.Rotate(30);
//    rectGrad.SetTransform(&xForm);

    // Change the wrapping mode and fill.

//    rectGrad.SetWrapMode(WrapModeTileFlipXY);
// !! No longer used
//    g->FillRectangle(&rectGrad, 350, 20, 100, 80);

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    brushRect.Width = 60;
    brushRect.Height = 32;
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;
    xForm.Reset();
    xForm.RotateAt(-30, center, MatrixOrderAppend);
// !! No longer used
//    RadialGradientBrush radGrad(brushRect, centerColor,
//                                boundaryColor, WrapModeClamp);
//    radGrad.SetTransform(&xForm);
//    g->FillRectangle(&radGrad, 320, 120, 120, 100);

//    Pen gradPen(&rectGrad, width);
//    g->DrawRectangle(&gradPen, 320, 120, 120, 100);

    // Triangle gradient.

    PointF points[7];
    points[0].X = 50;
    points[0].Y = 10;
    points[1].X = 200;
    points[1].Y = 20;
    points[2].X = 100;
    points[2].Y = 100;
    points[3].X = 30;
    points[3].Y = 120;

    Color colors1[5] = {
        Color(255, 255, 255, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

// !! No longer used
//    TriangleGradientBrush triGrad(points, (Color*) &colors);
//    g->FillPolygon(&triGrad, points, 3);
    RectF triRect;
//    triGrad.GetRectangle(triRect);
//    g->FillRectangle(&triGrad, triRect);

    points[0].X = 200;
    points[0].Y = 300;
    points[1].X = 280;
    points[1].Y = 350;
    points[2].X = 220;
    points[2].Y = 420;
    points[3].X = 160;
    points[3].Y = 440;
    points[4].X = 120;
    points[4].Y = 370;

    PathGradientBrush polyGrad(points, 5);

    REAL blend[10];
    Color presetColors[10];
    REAL positions[10];
    INT count;
    INT i;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    INT colorset = 5;
    polyGrad.SetSurroundColors(&colors1[0], &colorset);
    
//    g->FillPolygon(&polyGrad, points, 5);
    RectF polyRect;
    polyGrad.GetRectangle(&polyRect);
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = 300;
    rect.Y = 300;
    rect.Width = 150;
    rect.Height = 150;
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;
    pathGrad.SetCenterColor(centerColor);
    INT colorsset = 5;
    colors1[0] = Color(255, 255, 0, 0);
    pathGrad.SetSurroundColors(&colors1[0], &colorsset);
    pathGrad.GetRectangle(&polyRect);

    // Set the rect focus.

    PointF centerPt;

    pathGrad.GetCenterPoint(&centerPt);
    centerPt.X -= 15;
    centerPt.Y += 30;
    pathGrad.SetCenterPoint(centerPt);
    REAL xScale, yScale;
    pathGrad.GetFocusScales(&xScale, &yScale);
    xScale = 0.4f;
    yScale = 0.3f;
    pathGrad.SetFocusScales(xScale, yScale);

    g->FillRectangle(&pathGrad, polyRect);

    // Test for LineGradientBrush.

    RectF lineRect(120, -20, 200, 60);
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

    LinearGradientBrush lineGrad(lineRect, color1, color1,
                        LinearGradientModeForwardDiagonal);

    // Test for preset colors

    presetColors[0] = Color(200, 0, 255, 255);
    presetColors[1] = Color(200, 255, 255, 0);
    presetColors[2] = Color(200, 0, 255, 0);
    lineGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);

    g->FillRectangle(&lineGrad, lineRect);
}


/**************************************************************************\
* TestHatches
*
* A test for hatch brushes
*
\**************************************************************************/

VOID TestHatches(Graphics* g)
{
    Color foreColor(0, 0, 0);
    Color backColor(255, 255, 255);

    int x, y;
    
    x = 0; y = 0;
    
    for (int i = HatchStyleMin; i <= HatchStyleMax; i++)
    {
        if ((i > 0) && ((i & 7) == 0))
        {
            x = 0;
            y += 100;
        }
        HatchBrush hatch((HatchStyle)i, foreColor, backColor);
        g->FillRectangle(&hatch, x, y, 100, 100);
        x += 100;
    }
}

/**************************************************************************\
* TestBitmaps
*
* A test for texture filling and DrawImage.
*
\**************************************************************************/

VOID TestBitmaps(Graphics* g)
{
    Point points[4];
    REAL width = 4;     // Pen width


    WCHAR filename[256];
    wcscpy(filename, L"../data/brick.jpg");
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 0;
    copyRect.Y = 0;
    copyRect.Width = 40;
    copyRect.Height = 30;

    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                         copyRect.Width, copyRect.Height,
                                         PixelFormat32bppARGB);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        //copiedBitmap->Dispose();

        // Create a radial gradient pen.

        Color redColor(255, 0, 0);

        SolidBrush redBrush(redColor);
        Pen redPen(&redBrush, width);

        GraphicsPath *path;

        points[0].X = 100;
        points[0].Y = 60;
        points[1].X = -50;
        points[1].Y = 60;
        points[2].X = 150;
        points[2].Y = 250;
        points[3].X = 200;
        points[3].Y = 120;
        path = new GraphicsPath(FillModeAlternate);
        path->AddBeziers(points, 4);
        g->FillPath(&textureBrush, path);
        g->DrawPath(&redPen, path);

        delete path;
        delete copiedBitmap;
    }

    delete bitmap;

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;

    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);

    delete bitmap;

    destPoints[0].X = 30;
    destPoints[0].Y = 200;
    destPoints[1].X = 200;
    destPoints[1].Y = 200;
    destPoints[2].X = 200;
    destPoints[2].Y = 420;

    wcscpy(filename, L"../data/dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);

    delete bitmap;

    Color color(100, 128, 255, 0);

    SolidBrush brush(color);

    Point pts[10];
    INT count = 4;

    pts[0].X = 150;
    pts[0].Y = 60;
    pts[1].X = 100;
    pts[1].Y = 230;
    pts[2].X = 250;
    pts[2].Y = 260;
    pts[3].X = 350;
    pts[3].Y = 100;

    g->FillClosedCurve(&brush, pts, count);

    wcscpy(filename, L"../data/ballmer.jpg");
    bitmap = new Bitmap(filename);
    RectF destRect(220, 50, 180, 120);
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;
    g->DrawImage(bitmap, destRect, srcRect.X, srcRect.Y,
        srcRect.Width, srcRect.Height, UnitPixel);

    g->DrawImage(bitmap, pts, 3, (INT) srcRect.X, (INT) srcRect.Y,
       (INT) srcRect.Width, (INT) srcRect.Height, UnitPixel);

    delete bitmap;
}

/**************************************************************************\
* TestPrimitives
*
* A test for ellipse, arc, pie, curve, and closed curve.
*
\**************************************************************************/

VOID
TestPrimitives(
    Graphics* g
    )
{
    RectF rect;

    rect.X = 250;
    rect.Y = 230;
    rect.Width = 150;
    rect.Height = 100;

    Color color(128, 128, 255, 0);

    SolidBrush brush(color);

    REAL width = 1;

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen pen(&blackBrush, width);

//    g->FillEllipse(&brush, rect);
//    g->DrawEllipse(&pen, rect);
    REAL startAngle = 0;
    REAL sweepAngle = 240;
    g->FillPie(&brush, rect, startAngle, sweepAngle);
    g->DrawPie(&pen, rect, startAngle, sweepAngle);

    PointF pts[10];
    INT count = 4;

    pts[0].X = 200;
    pts[0].Y = 160;
    pts[1].X = 150;
    pts[1].Y = 230;
    pts[2].X = 200;
    pts[2].Y = 260;
    pts[3].X = 300;
    pts[3].Y = 200;

    g->FillClosedCurve(&brush, pts, count);
    g->DrawClosedCurve(&pen, pts, count);
}


/**************************************************************************\
* TestMixedObjects
*
* A test for different brushes and pens.
*
\**************************************************************************/

VOID TestMixedObjects(Graphics* g)
{
    PointF points[10];
    REAL width = 4;     // Pen width

    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                            copyRect.Width, copyRect.Height,
                                            PixelFormat32bppPARGB);

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);
    Color colors[4] = {
       Color(255, 255, 255, 255),
       Color(255, 255, 0, 0),
       Color(255, 0, 255, 0),
       Color(255, 0, 0, 255)
    };
// !! No longer supported
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);
    width = 8;
//    Pen gradPen(&rectGrad, width);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        delete copiedBitmap;

        // Create a radial gradient pen.

        points[3].X = 50;
        points[3].Y = 300;
        points[2].X = 100;
        points[2].Y = 300;
        points[1].X = 120;
        points[1].Y = 370;
        points[0].X = 50;
        points[0].Y = 350;

//        gradPen.SetLineJoin(LineJoinMiter);
        g->FillPolygon(&textureBrush, points, 4);
//        g->DrawPolygon(&gradPen, points, 4);
    }

    delete bitmap;
}

/**************************************************************************\
* TestTexts
*
* A test for drawing texts.
*
\**************************************************************************/

VOID TestTexts(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF     rectf(20, 0, 300, 200);
    GraphicsPath  path;

    // Solid color text.

    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 60,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.

    WCHAR filename[256];
    wcscpy(filename, L"../data/marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.X = 200;
    rectf.Y = 20;
    path.AddString(L"Texture", 7, &ff, 0, 60, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.

    rectf.X = 40;
    rectf.Y = 80;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 60, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test

    REAL charHeight = 60;
    REAL topMargin = - 5;
    rectf.X = 0;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
                                        // of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.

    REAL tx = 180, ty = 200;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.

    Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/

}

#ifdef TEXTV2
// We don't support text along a path in v1

VOID TestTextAlongPath(Graphics *g)
{
    Point points[4];

    points[3].X = 100;
    points[3].Y = 10;
    points[2].X = -50;
    points[2].Y = 50;
    points[1].X = 150;
    points[1].Y = 200;
    points[0].X = 200;
    points[0].Y = 70;

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color textColor(180, 200, 0, 200);
    SolidBrush textBrush(textColor);

    WCHAR text[] = L"Windows 2000";

    REAL offset = 60;

    g->DrawString(text, 12, NULL, path, NULL, textBrush, offset);

    delete path;
}

#endif

/**************************************************************************\
* TestDerive
*
* Test
* A test for derivation support.
*
\**************************************************************************/

VOID
TestDerive(
    HWND hwnd
    )
{
    HDC hdcScreen = GetDC(hwnd);
    HRGN hrgn = CreateEllipticRgn(10, 10, 300, 300);

    SetMapMode(hdcScreen, MM_TWIPS);
    SelectClipRgn(hdcScreen, hrgn);
    HBRUSH hbrushRed = CreateSolidBrush(RGB(255, 0, 0));
    SelectObject(hdcScreen, hbrushRed);
    Rectangle(hdcScreen, 0, 0, 3000, -3000);

    {
        Graphics g(hdcScreen);
        SolidBrush solidBrush(Color(0, 255, 0));
        g.FillRectangle(&solidBrush, 0, -3000, 3000, 3000);
    }

    HBITMAP hbmBitmap = CreateCompatibleBitmap(hdcScreen, 50, 50);
    HDC hdcBitmap = CreateCompatibleDC(hdcScreen);
    SelectObject(hdcBitmap, hbmBitmap);
    SetWindowOrgEx(hdcBitmap, 40, 80, NULL);

    SelectObject(hdcBitmap, hbrushRed);
    Rectangle(hdcBitmap, 40, 80, 50, 50);

    {
        POINT point;
        Graphics g(hdcBitmap);
        SolidBrush solidBrush(Color(0, 0, 255));
        g.FillRectangle(&solidBrush, 40, 80, 90, 130);

        // The DC that we get back should have the same transform set
        // as that which we originally passed in:

        HDC hdcGet = g.GetHDC();
        point.x = 0;
        point.y = 0;
        DPtoLP(hdcGet, &point, 1);

        ASSERT((hdcGet != NULL) && (point.x == 40) && (point.y == 80));

        g.ReleaseHDC(hdcGet);
    }

    // The DC should have beeen returned to the top save level:

    INT saveLevel = SaveDC(hdcBitmap);
    ASSERT(saveLevel == 1);

    // The DC should have had its transform restored:

    POINT oldPoint;
    SetWindowOrgEx(hdcBitmap, 0, 0, &oldPoint);

    ASSERT((oldPoint.x == 40) && (oldPoint.y == 80));

    // Blt the (hopefully) blue square to the screen.  But first,
    // reset our transform on 'hdcScreen' the lazy way:

    ReleaseDC(hwnd, hdcScreen);
    hdcScreen = GetDC(hwnd);
    BitBlt(hdcScreen, 0, 0, 50, 50, hdcBitmap, 0, 0, SRCCOPY);
    ReleaseDC(hwnd, hdcScreen);

    // Test two equivalent methods.  This should result in two grey
    // squares, one on top of the other, each inset by a red circle
    // and the text "Ack!".

    hdcScreen = GetDC(hwnd);
    {
        // First:

        {
            Graphics g(hdcScreen);
            SolidBrush fillBrush(Color(128, 128, 128));
            g.FillRectangle(&fillBrush, 200, 200, 80, 80);
        }
        TextOutA(hdcScreen, 220, 230, "Ack!", 4);
        {
            Graphics g(hdcScreen);
            SolidBrush strokeBrush(Color(255, 0, 0));
            Pen pen(&strokeBrush, 0);
            g.DrawEllipse(&pen, 200, 200, 80, 80);
        }

        // Second:

        {
            Graphics g(hdcScreen);
            SolidBrush fillBrush(Color(128, 128, 128));
            g.FillRectangle(&fillBrush, 200, 300, 80, 80);

            HDC hdcNew = g.GetHDC();
            ASSERT(hdcNew != NULL);
            SetViewportOrgEx(hdcScreen, 220, 230, NULL);
            TextOutA(hdcNew, 0, 100, "Ack!", 4);
            SetViewportOrgEx(hdcScreen, 0, 0, NULL);
            g.ReleaseHDC(hdcNew);

            SolidBrush strokeBrush(Color(255, 0, 0));
            Pen pen(&strokeBrush, 0);
            g.DrawEllipse(&pen, 200, 300, 80, 80);
        }
    }
    ReleaseDC(hwnd, hdcScreen);
}

VOID TestRegionExcludeClip(Graphics *g)
{
    Gdiplus::Status     status;
    RectF               rect(100, 100, 500, 500);
    Gdiplus::Region     region(rect);

    rect.X = 50; rect.Y = 25; rect.Width = 100; rect.Height = 100;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 250;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 550;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 50; rect.Y = 150;  rect.Height = 75;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 550;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 300; rect.Y = 300; rect.Height = 125;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 550; rect.Y = 250; rect.Height = 75;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 375;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 550;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 350;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 50;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 450;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 315;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

//    g->SetPageTransform(UnitDisplay, 0.5f);
    status = g->SetClip(&region);
    ASSERT(status == Ok);
    status = g->TranslateClip(-50.0f, -50.0f);
    ASSERT(status == Ok);

    Gdiplus::SolidBrush b(Gdiplus::Color::Purple);
    status = g->FillRectangle(&b, 0, 0, 800, 800);
    ASSERT(status == Ok);
    g->ResetClip();
//    g->SetPageTransform(UnitDisplay, 1.0f);
}

VOID TestRegionXorClip(Graphics *g)
{
    Gdiplus::Status     status;
    PointF              bez1[7];
    GraphicsPath *      pathBez1 = new GraphicsPath();
    ASSERT(pathBez1 != NULL);

    bez1[0].X = 200; bez1[0].Y = 275;
    bez1[1].X = 200; bez1[1].Y = 225;
    bez1[2].X = 300; bez1[2].Y = 225;
    bez1[3].X = 300; bez1[3].Y = 275;
    bez1[4].X = 300; bez1[4].Y = 325;
    bez1[5].X = 200; bez1[5].Y = 325;
    bez1[6].X = 200; bez1[6].Y = 275;

    status = pathBez1->AddBeziers(bez1, 7);
    ASSERT(status == Ok);

    PointF              bez2[7];
    GraphicsPath *      pathBez2 = new GraphicsPath();
    ASSERT(pathBez2 != NULL);

    bez2[0].X =  50; bez2[0].Y = 250;
    bez2[1].X =  50; bez2[1].Y =   0;
    bez2[2].X = 450; bez2[2].Y =   0;
    bez2[3].X = 450; bez2[3].Y = 250;
    bez2[4].X = 450; bez2[4].Y = 500;
    bez2[5].X =  50; bez2[5].Y = 500;
    bez2[6].X =  50; bez2[6].Y = 250;

    status = pathBez2->AddBeziers(bez2, 7);
    ASSERT(status == Ok);

    PointF              star[10];
    GraphicsPath *      pathStar = new GraphicsPath();
    ASSERT(pathStar != NULL);

    star[0].X =  12; star[0].Y = 192;
    star[1].X = 193; star[1].Y = 192;
    star[2].X = 250; star[2].Y =  20;
    star[3].X = 306; star[3].Y = 192;
    star[4].X = 487; star[4].Y = 192;
    star[5].X = 340; star[5].Y = 299;
    star[6].X = 396; star[6].Y = 472;
    star[7].X = 250; star[7].Y = 365;
    star[8].X = 103; star[8].Y = 472;
    star[9].X = 159; star[9].Y = 299;

    status = pathStar->AddPolygon(star, 10);
    ASSERT(status == Ok);

    RectF               regionRect(100, 100, 300, 300);
    Gdiplus::Region     region(pathStar);

    status = region.Xor(regionRect);
    ASSERT(status == Ok);

    status = region.Union(pathBez1);
    ASSERT(status == Ok);

    status = region.Xor(pathBez2);
    ASSERT(status == Ok);

    UINT    regionDataSize = region.GetDataSize();
    BYTE *  regionData = new BYTE[regionDataSize];
    ASSERT(regionData);

    region.GetData(regionData, regionDataSize, &regionDataSize);

    Gdiplus::Region region2(regionData, regionDataSize);

    delete [] regionData;

    status = g->SetClip(&region2);
    ASSERT(status == Ok);

    PointF      pointsRect[4];

    pointsRect[0].X = 0;
    pointsRect[0].Y = 0;
    pointsRect[1].X = 600;
    pointsRect[1].Y = 0;
    pointsRect[2].X = 600;
    pointsRect[2].Y = 600;
    pointsRect[3].X = 0;
    pointsRect[3].Y = 600;

    Gdiplus::SolidBrush alphaBrush(Color(128, 0, 255, 0));
    status = g->FillPolygon(&alphaBrush, pointsRect, 4);
    ASSERT(status == Ok);

    g->ResetClip();

    delete pathStar;
    delete pathBez1;
    delete pathBez2;
}

/**************************************************************************\
* TestImaging
*
* A test for imaging and DrawImage.
*
\**************************************************************************/

VOID RemapBlackAndWhiteMatrix(ColorMatrix *matrix, Color replaceBlack, Color replaceWhite)
{
    // Normalize the colors to 1.0.

    REAL normBlackRed   = ((REAL)replaceBlack.GetRed()  )/(REAL)255.0;
    REAL normBlackGreen = ((REAL)replaceBlack.GetGreen())/(REAL)255.0;
    REAL normBlackBlue  = ((REAL)replaceBlack.GetBlue() )/(REAL)255.0;
    REAL normBlackAlpha = ((REAL)replaceBlack.GetAlpha())/(REAL)255.0;

    REAL normWhiteRed   = ((REAL)replaceWhite.GetRed()  )/(REAL)255.0;
    REAL normWhiteGreen = ((REAL)replaceWhite.GetGreen())/(REAL)255.0;
    REAL normWhiteBlue  = ((REAL)replaceWhite.GetBlue() )/(REAL)255.0;
    REAL normWhiteAlpha = ((REAL)replaceWhite.GetAlpha())/(REAL)255.0;

    // Setup a matrix that will map white to transparent black and
    // black to the specified color.
    //
    //      | -B  -B  -B  -B   0 |
    //      |   r   g   b   a    |
    //      |                    |
    //      |  W   W   W   W   0 |
    //      |   r   g   b   a    |
    //      |                    |
    //      |  0   0   0   0   0 |
    //      |                    |
    //      |                    |
    //      |  0   0   0   0   0 |
    //      |                    |
    //      |                    |
    //      |  B   B   B   B   1 |
    //      |   r   g   b   a    |

    memset(matrix, 0, sizeof(ColorMatrix));

    matrix->m[0][0] = -normBlackRed;
    matrix->m[0][1] = -normBlackGreen;
    matrix->m[0][2] = -normBlackBlue;
    matrix->m[0][3] = -normBlackAlpha;

    matrix->m[1][0] =  normWhiteRed;
    matrix->m[1][1] =  normWhiteGreen;
    matrix->m[1][2] =  normWhiteBlue;
    matrix->m[1][3] =  normWhiteAlpha;

    matrix->m[4][0] =  normBlackRed;
    matrix->m[4][1] =  normBlackGreen;
    matrix->m[4][2] =  normBlackBlue;
    matrix->m[4][3] =  normBlackAlpha;
    matrix->m[4][4] =  1.0;
}

VOID NextDestRect(INT xRef, INT yRef, Rect *rect)
{
    rect->Y += rect->Height;

    if (rect->Y >= (yRef + (4 * rect->Height)))
    {
        rect->X += rect->Width;
        rect->Y = yRef;
    }
}

BOOL CALLBACK MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    //LBprintf("MyDrawImageAbort: %ld", *count);

    return FALSE;
}

VOID TestImaging(Graphics* g)
{
    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";

    Image *image = new Image(filename);

    // Get information on the image.

    UINT imageWidth = image->GetWidth();
    UINT imageHeight = image->GetHeight();

    // Source clip but preserve aspect ratio (destination is a square).

    if (imageWidth < imageHeight)
    {
        imageWidth  = (INT) ((REAL)imageWidth * (REAL).7);
        imageHeight = imageWidth;
    }
    else
    {
        imageHeight = (INT) ((REAL)imageHeight * (REAL).7);
        imageWidth  = imageHeight;
    }

    // Try to save thumbnail

    WCHAR *thumbfile = L"thumb256.bmp";

    CLSID _BmpCodecClsID_ =
    {
        0x557cf400,
        0x1a04,
        0x11d3,
        {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
    };

    UINT abortCount = 0;

    ImageAttributes imgAttrib;

    Rect destRect(50, 10, 100, 100);

    // Make near-white to white transparent

#ifdef TESTOUTCROP
    g->DrawImage(image, destRect, -20, -20, imageOutCrop.Width+20, imageOutCrop.Height+20,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
#else
    Color c1(200, 200, 200);
    Color c2(255, 255, 255);
    imgAttrib.SetColorKey(c2, c2);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
#endif
    NextDestRect(50, 10, &destRect);

    ColorMatrix greyMatrix = {.25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              (REAL).1, (REAL).1, (REAL).1, 0, 1};

    imgAttrib.ClearColorKey();
    imgAttrib.SetColorMatrix(&greyMatrix);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    ColorMatrix pinkMatrix = {(REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    imgAttrib.SetColorMatrix(&pinkMatrix, ColorMatrixFlagsSkipGrays);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    ColorMatrix darkMatrix = {.75, 0, 0, 0, 0,
                              0, .75, 0, 0, 0,
                              0, 0, .75, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    imgAttrib.SetColorMatrix(&darkMatrix);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    imgAttrib.ClearColorMatrix();
    imgAttrib.SetGamma(3.0);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    imgAttrib.SetThreshold(0.5);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    // red->blue, green->red, blue->green, alpha = 0.75
    ColorMatrix swapMatrix = {0, 0, 1, 0, 0,
                              1, 0, 0, 0, 0,
                              0, 1, 0, 0, 0,
                              0, 0, 0, .75, 0,
                              0, 0, 0, 0, 1};

    imgAttrib.SetColorMatrix(&swapMatrix);
    imgAttrib.ClearGamma();
    imgAttrib.ClearThreshold();

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    // red->blue, green->red, blue->green, alpha = 0.9
    ColorMatrix swapMatrix2 = {0, 0, 1, 0, 0,
                               1, 0, 0, 0, 0,
                               0, 1, 0, 0, 0,
                               0, 0, 0, 0, 0,
                               0, 0, 0, (REAL).9, 1};

    imgAttrib.SetNoOp();
    imgAttrib.SetColorMatrix(&swapMatrix2);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    imgAttrib.ClearNoOp();

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    {
        Bitmap* bitmap = new Bitmap(imageWidth, imageHeight, g);
        if (bitmap)
        {
            Graphics *bitmapGraphics = Graphics::FromImage(bitmap);
            if (bitmapGraphics)
            {
                imgAttrib.ClearNoOp();
                imgAttrib.ClearColorMatrix();
                imgAttrib.ClearColorKey();
                imgAttrib.ClearGamma();
                imgAttrib.SetThreshold(0.5);

                Rect rect(0, 0, imageWidth, imageHeight);
                bitmapGraphics->DrawImage(image, rect,
                                          0, 0, imageWidth, imageHeight,
                                          UnitPixel, &imgAttrib,
                                          MyDrawImageAbort, (VOID*)&abortCount);

                delete bitmapGraphics;
            }
            else
                LBprintf("TestImaging: graphics from image");

            imgAttrib.ClearThreshold();

            ColorMatrix remapBlackAndWhite;

            RemapBlackAndWhiteMatrix(&remapBlackAndWhite, Gdiplus::Color::Maroon, 0);
            imgAttrib.SetColorMatrix(&remapBlackAndWhite);

            g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight,
                         UnitPixel, &imgAttrib,
                         MyDrawImageAbort, (VOID*)&abortCount);
            NextDestRect(50, 10, &destRect);

            RemapBlackAndWhiteMatrix(&remapBlackAndWhite, 0, Gdiplus::Color::Green);
            imgAttrib.SetColorMatrix(&remapBlackAndWhite);

            g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight,
                         UnitPixel, &imgAttrib,
                         MyDrawImageAbort, (VOID*)&abortCount);
            NextDestRect(50, 10, &destRect);

            Color blackRemap(128, 0xff, 0x00, 0x00);
            Color whiteRemap(128, 0x00, 0xff, 0x00);
            RemapBlackAndWhiteMatrix(&remapBlackAndWhite, blackRemap, whiteRemap);
            imgAttrib.SetColorMatrix(&remapBlackAndWhite);

            g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight,
                         UnitPixel, &imgAttrib,
                         MyDrawImageAbort, (VOID*)&abortCount);
            NextDestRect(50, 10, &destRect);

            delete bitmap;
        }
        else
            LBprintf("TestImaging: bitmap creation failed");
    }

    g->Flush();

    delete image;
}

VOID TestBitmapGraphics(Graphics* g)
{
    INT bitmapSize = 500;

    WCHAR *filename = L"../data/apple1.png";
    Bitmap *bitmap = new Bitmap(filename);

    UINT imageWidth = bitmap->GetWidth();
    UINT imageHeight = bitmap->GetHeight();

    Graphics *bitmapGraphics = Graphics::FromImage(bitmap);

    if ((!bitmapGraphics) || (bitmapGraphics->GetLastStatus() != Ok))
        LBprintf("Bitmap.GetGraphics() failed");

    TestRegionExcludeClip(bitmapGraphics);
    TestRegionXorClip(bitmapGraphics);
    TestContainerClip(bitmapGraphics);
    TestContainer(bitmapGraphics);
    TestPolygons(bitmapGraphics);
    TestPaths(bitmapGraphics);
    TestRegions(bitmapGraphics);
    TestGradients(bitmapGraphics);
    TestHatches(bitmapGraphics);
    TestBitmaps(bitmapGraphics);
    TestPrimitives(bitmapGraphics);
    TestMixedObjects(bitmapGraphics);
    TestTexts(bitmapGraphics);
    TestImaging(bitmapGraphics);

    HDC hdc = bitmapGraphics->GetHDC();

    if (!hdc)
        LBprintf("Graphics.GetHdc() failed");

    LPSTR testString = "Hello, Boo-Boo!";
    TextOutA(hdc, 20, 20, testString, strlen(testString));
    SetBkMode(hdc, TRANSPARENT);
    TextOutA(hdc, 20, 200, testString, strlen(testString));

    bitmapGraphics->ReleaseHDC(hdc);

    delete bitmapGraphics;

    Rect destRect(100, 100, imageWidth, imageHeight);

    g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight, UnitPixel);

    delete bitmap;
}

VOID TestWmfs(Graphics *g)
{
    GraphicsState s = g->Save();
    Metafile * playback = new Metafile(L"Globe.wmf");
//    Metafile * playback = new Metafile(L"..\\data\\Flower.wmf");
//    Metafile * playback = new Metafile(L"..\\\\radt\\vbssdb\\VbTests\\shadow\\WFCClientRuntime\\Libs\\WFCTestLib\\Util\\Images\\Flower.wmf");

    g->SetPageUnit(UnitInch);
    g->SetPageScale(1.0f);
    g->DrawImage(playback, 0.5f, 0.5f, 4.0f, 4.0f);
    delete playback;
    g->Restore(s);
}

Matrix * GetTransformFromHdc(HDC hdc);

VOID TestMetaGetDC(Graphics *g, HWND hwnd)
{
    {
        GpRectF     frameRect(0, 0, 100, 100);
        HDC hDC = GetDC ( hwnd );
        Gdiplus::Metafile emf ( L"test1.emf", hDC, frameRect, Gdiplus::MetafileFrameUnitPixel );
        ReleaseDC(hwnd, hDC);
        {
            Gdiplus::Graphics graphics ( &emf );
            HDC gDC = graphics.GetHDC ();
            SetWindowOrgEx(gDC, 100, 100, NULL);
            Matrix * m = GetTransformFromHdc(gDC);
            graphics.ReleaseHDC ( gDC );
            graphics.SetTransform(m);
            delete m;

            Gdiplus::Pen p ( Gdiplus::Color::Black, 1);
            graphics.DrawRectangle ( &p, 100, 100, 100, 100 );

            graphics.SetRenderingOrigin(10,3);
            gDC = graphics.GetHDC ();
            HBRUSH brush = CreateSolidBrush ( 0x00FF00 );
            HBRUSH prev  = ( HBRUSH ) SelectObject ( gDC, brush );
            ExtFloodFill(gDC, 170, 170, 0xffffff, FLOODFILLSURFACE);
            SelectObject ( gDC, prev );
            DeleteObject ( brush );
            graphics.ReleaseHDC ( gDC );
        }
    }

    Gdiplus::Metafile emf ( L"test1.emf" );
    g->DrawImage ( &emf, 10, 10 );
}

#define LTOF(x)         (static_cast<REAL>(x))
Matrix * GetTransformFromHdc(HDC hdc)
{
    POINT       points[3];
    PointF      destPoints[3];
    RectF       srcRect;
    RectF       destRect;

    // It would take a lot of time to call all the Win32 APIs to query
    // the transform: we would minimally have to call GetMapMode,
    // GetWindowOrgEx, and GetViewportOrgEx; and maximally also have to
    // call GetWorldTransform, GetViewportExtEx, and GetWindowExtEx.
    //
    // We cheat a little by making a single call to LPtoDP with a
    // parallelogram, and then inferring the result.  Note that we do
    // run the risk of some error, and on Win9x of overflow, since Win9x
    // only supports 16-bit coordinates.  To counteract this, we try to
    // choose large values that won't overflow.

    points[0].x = 0;
    points[0].y = 0;
    points[1].x = 8192;
    points[1].y = 0;
    points[2].x = 0;
    points[2].y = 8192;

    if (!LPtoDP(hdc, points, 3))
    {
        return NULL;
    }

    srcRect.X      = 0.0f;
    srcRect.Y      = 0.0f;
    srcRect.Width  = 8192.0f;
    srcRect.Height = 8192.0f;

    destPoints[0].X = LTOF(points[0].x);
    destPoints[0].Y = LTOF(points[0].y);
    destPoints[1].X = LTOF(points[1].x);
    destPoints[1].Y = LTOF(points[1].y);
    destPoints[2].X = LTOF(points[2].x);
    destPoints[2].Y = LTOF(points[2].y);

    return new Matrix(srcRect, destPoints);
}

VOID TestLineWithTexture(Graphics *g)
{
    Bitmap          andrew(L"Gio.jpg");
    TextureBrush    textureBrush(&andrew, WrapModeTile);
    Pen             pen(&textureBrush, 40.0);

    pen.SetLineJoin(LineJoinMiter);

    PointF  spiralPoints[12] = {
        PointF(540.0f, 550.0f),
        PointF(540.0f,  75.0f),
        PointF( 60.0f,  75.0f),
        PointF( 60.0f, 460.0f),
        PointF(460.0f, 460.0f),
        PointF(460.0f, 140.0f),
        PointF(140.0f, 140.0f),
        PointF(140.0f, 400.0f),
        PointF(380.0f, 400.0f),
        PointF(380.0f, 190.0f),
        PointF(260.0f, 190.0f),
        PointF(260.0f, 350.0f),
        };

     g->DrawLines(&pen, spiralPoints, 12);
}

VOID TestRotatedLine(Graphics *g)
{
    INT             i;
    SolidBrush      blueBrush(Color(128, 0, 0, 255));
    Pen             pen(&blueBrush, 10.0);
    GraphicsState   gState = g->Save();
    PointF          points[3];

    pen.SetDashStyle(DashStyleDot);
    pen.SetEndCap(LineCapRound);

    points[0].X = 200; points[0].Y = 200;
    points[1].X = 340; points[1].Y = 200;
    points[2].X = 340; points[2].Y = 345;

#define MYDEGREES     45
    for (i = 0; i < 360; i += MYDEGREES)
    {
        g->TranslateTransform(200, 200);
        g->RotateTransform(MYDEGREES);
        g->TranslateTransform(-200, -200);

        g->DrawLines(&pen, points, 3);
        g->Flush();
    }
    g->Restore(gState);
}

/**************************************************************************\
* TestDibsection
*
* This is a quick visual test for verifying that GDI+ properly draws
* to both top-down and bottom-up DIBSections.  A red square should
* appear in the upper-left corner of both black squares.
*
\**************************************************************************/

VOID TestDibsection(Graphics *g)
{
    BITMAPINFO bmi;
    HBITMAP hbm;
    HDC hdc;
    HDC hdcScreen;
    HBITMAP hbmOld;

    hdcScreen = g->GetHDC();
    hdc = CreateCompatibleDC(hdcScreen);
    SolidBrush blackBrush(Color::Black);
    SolidBrush redBrush(Color::Red);

    //////////////////////////////////////////////////////
    // First, create the DIB-section as bottom-up:

    RtlZeroMemory(&bmi, sizeof(bmi));

    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = 31;
    bmi.bmiHeader.biHeight      = 31;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbm = CreateDIBSection(hdcScreen, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);
    hbmOld = (HBITMAP) SelectObject(hdc, hbm);

    {
        Graphics bitmap(hdc);

        bitmap.FillRectangle(&blackBrush, 0, 0, 31, 31);
        bitmap.FillRectangle(&redBrush, 0, 0, 8, 8);

        BitBlt(hdcScreen, 0, 0, 31, 31, hdc, 0, 0, SRCCOPY);
    }

    SelectObject(hdc, hbmOld);
    DeleteObject(hbm);

    //////////////////////////////////////////////////////
    // Now, create the DIB-section as top-down:

    bmi.bmiHeader.biHeight = -31;

    hbm = CreateDIBSection(hdcScreen, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);
    hbmOld = (HBITMAP) SelectObject(hdc, hbm);

    {
        Graphics bitmap(hdc);

        bitmap.FillRectangle(&blackBrush, 0, 0, 31, 31);
        bitmap.FillRectangle(&redBrush, 0, 0, 8, 8);

        BitBlt(hdcScreen, 40, 0, 31, 31, hdc, 0, 0, SRCCOPY);
    }

    SelectObject(hdc, hbmOld);
    DeleteObject(hbm);

    //////////////////////////////////////////////////////

    g->ReleaseHDC(hdcScreen);
    DeleteObject(hdc);
}

/**************************************************************************\
* TestCompoundLines
*
* A test for compound lines.
*
\**************************************************************************/

VOID TestCompoundLines(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    points[0].X = 260;
    points[0].Y = 20;
    path->AddLines(points, 1);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);
    matrix.Translate(0, 30);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);

    REAL* compoundArray = new REAL[6];
    compoundArray[0] = 0.0f;
    compoundArray[1] = 0.2f;
    compoundArray[2] = 0.4f;
    compoundArray[3] = 0.6f;
    compoundArray[4] = 0.8f;
    compoundArray[5] = 1.0f;
    blackPen.SetCompoundArray(&compoundArray[0], 6);
    blackPen.SetDashStyle(DashStyleDash);

    blackPen.SetStartCap(LineCapDiamondAnchor);
    blackPen.SetEndCap(LineCapArrowAnchor);

    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
}

VOID TestImageSampling(Graphics* g)
{
    // Load bmp files.

    WCHAR *filename = L"..\\data\\3x3.bmp";

    Image *image = new Image(filename);

    // Get information on the image.

    if (image && (image->GetLastStatus() == Ok))
    {
        UINT imageWidth = image->GetWidth();
        UINT imageHeight = image->GetHeight();

        if (image->GetLastStatus() == Ok)
        {
            if (imageHeight >= 2 && imageWidth >= 2)
            {
                // Draw the whole image

                Rect destRect(50, 10, 100, 100);
                g->DrawImage(image, destRect,
                             0, 0, imageWidth, imageHeight,
                             UnitPixel);

                // Stretch pixel (1, 1)

                NextDestRect(50, 10, &destRect);
                g->DrawImage(image, destRect,
                             1, 1, 1, 1,
                             UnitPixel);
            }
            else
                LBprintf("Image is %ldx%ld, 2x2 image or greater required",
                         imageWidth, imageHeight);
        }
    }
    else
        LBprintf("Failed to load image file %ws", filename);

    delete image;
}

VOID TestIcon(Graphics* g)
{
    Rect destRect(50, 10, 8, 8);

    // Load bmp files.

    //WCHAR *filename = L"..\\data\\nyt.ico";
    //WCHAR *filename = L"..\\data\\pos.ico";
    //WCHAR *filename = L"..\\data\\signl.ico";
    WCHAR *filename = L"..\\data\\wbros.ico";

    Image *image = new Image(filename);

    // Get information on the image.

    if (image)
    {
        if (image->GetLastStatus() == Ok)
        {
            UINT imageWidth = image->GetWidth();
            UINT imageHeight = image->GetHeight();

            if (image->GetLastStatus() == Ok)
            {
                LBprintf("icon size: %ld x %ld", imageWidth, imageHeight);

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 12;
                destRect.Height = 12;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 16;
                destRect.Height = 16;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 24;
                destRect.Height = 24;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 32;
                destRect.Height = 32;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 48;
                destRect.Height = 48;

                g->DrawImage(image, destRect,
                             0, 0, imageWidth, imageHeight,
                             UnitPixel
                             );
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 64;
                destRect.Height = 64;

                g->DrawImage(image, destRect,
                             0, 0, imageWidth, imageHeight,
                             UnitPixel
                             );
                g->Flush();
            }
            else
                LBprintf("Failed to get image width/height");
        }

        delete image;
    }
    else
        LBprintf("Failed to load image file %ws", filename);

    HICON hicon = LoadIcon(NULL, IDI_ERROR);

    if (hicon)
    {
        Bitmap *icon = new Bitmap(hicon);

        if (icon)
        {
            NextDestRect(50, 10, &destRect);
            destRect.Width = 32;
            destRect.Height = 32;

            g->DrawImage(icon, destRect);

            delete icon;
        }
        else
            LBprintf("Failed to create Bitmap from HICON");

        WCHAR *iconfile = L"..\\data\\pos.ico";

        Bitmap* bitmap = new Bitmap(iconfile);

        if (bitmap)
        {
            HDC hdc = g->GetHDC();
            if (hdc)
            {
                HICON hicon2;

                if (bitmap->GetHICON(&hicon2) == Ok)
                {
                    DrawIcon(hdc, 100, 100, hicon2);

                    DestroyIcon(hicon2);
                }
                else
                    LBprintf("Bitmap::GetHICON failed");

                g->ReleaseHDC(hdc);
            }

            delete bitmap;
        }
        else
            LBprintf("Failed to load %ws", iconfile);

        DestroyIcon(hicon);
    }
    else
        LBprintf("Failed to load Win32 icon IDI_ERROR");
}

VOID TestTextToMetafile(Graphics *g, HDC hdc)
{
    FontFamily  ff(L"Arial");
    RectF     rectf(20, 0, 300, 200);
    Font    font(&ff, 20, FontStyleBold, UnitPixel);
    SolidBrush brush(Color(128, 100, 0, 200));

    g->DrawString(L"The quick brown fox jumped over the lazy dog", -1,
                         &font, rectf, NULL, &brush);

    g->Flush();

    Metafile metaFile(L"Text.emf", hdc);
    {
        Graphics gMeta(&metaFile);
        gMeta.DrawString(L"ABCDEFG", 7,
                         &font, rectf, NULL, &brush);
    }
    g->DrawImage(&metaFile, 100, 100);
    g->Flush();
}

VOID TestCmykSeparation(Graphics *g)
{
    HINSTANCE hinst = GetModuleHandle(NULL);

    if (hinst)
    {
        Bitmap *bitmap = new Bitmap(hinst, MAKEINTRESOURCE(IDB_BITMAPCMYKTEST));

        // Get information on the bitmap.

        if (bitmap)
        {
            if (bitmap->GetLastStatus() == Ok)
            {
                UINT width = bitmap->GetWidth();
                UINT height = bitmap->GetHeight();

                if (bitmap->GetLastStatus() == Ok)
                {
                    Rect destRect(150, 10, 100, 100);

                    ImageAttributes imgAttrib;

                    imgAttrib.SetOutputChannelColorProfile(L"..\\data\\mswopallp8.icm");
                    imgAttrib.SetOutputChannel(ColorChannelFlagsC);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsM);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsY);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsK);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannelColorProfile(L"..\\data\\mswopintent.icm");
                    imgAttrib.SetOutputChannel(ColorChannelFlagsC);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsM);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsY);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsK);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.ClearOutputChannelColorProfile();
                    imgAttrib.SetOutputChannel(ColorChannelFlagsC);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsM);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsY);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsK);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);


                    imgAttrib.ClearOutputChannel();
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);
                }
            }

            delete bitmap;
        }
        else
            LBprintf("Failed to bitmap resource");
    }
    else
        LBprintf("Failed to get module handle");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dlltest\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\dlltest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
/*        if (!InitializeEngine())
        {
            MessageBox(0, _T("Engine didn't initialize"), _T("Uh oh"), MB_OK);
        }
*/
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
//        UninitializeEngine();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\drawimage\drawimage.cpp ===
/******************************Module*Header*******************************\
* Module Name: drawimage.cpp
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999,Microsoft Corporation
*
* This is the DrawImage unit test.
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos

// Define away IStream
#define IStream int

#include <gdiplus.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "drawimage.hpp"
#include "wndstuff.h"

using namespace Gdiplus;
#define USE_NEW_APIS 1
#define USE_NEW_APIS2 1


ImageAttributes *Img = NULL;

/***************************************************************************\
* DrawXXXX
*
* These routines are all the individual tests that this test
* suite will use.
\***************************************************************************/

// No fancy stuff - just put the whole image in the window.
// No rotation, stretching, etc.

#if 0
// cached bitmap in animated infinite loop

VOID DrawSimple(Graphics *g)
{
  unsigned short filename[1024];

  CachedBitmap *frame[32];
  Bitmap *temp;
  Graphics *gbmp;

  Unit u;
  RectF r;


  for(int i=0; i<32; i++) {
      wsprintf(filename, L"T%d.bmp", i);
      temp = new Bitmap(filename);
      temp->GetBounds(&r, &u);
//      r.Width *=2;
//      r.Height *=2;

      frame[i] = new CachedBitmap(temp, g);

//      gbmp = new Graphics(frame[i]);

//      gbmp->SetInterpolationMode(InterpolationModeHighQualityBilinear);

/*      Matrix *m = new Matrix(1.0f, 0.0f,
                             0.0f, -1.0f,
                             0.0f, r.Height);
      gbmp->SetTransform(m);
  */
//      gbmp->DrawImage(temp, 0, 0, (INT)r.Width, (INT)r.Height);

//      delete gbmp;
      delete temp;
//      delete m;
  }
  RectF s = r;

  i = 0;
  int j;

  while(++i) {

//    for(j=0; j<3; j++)
//    g->DrawImage(frame[i % 32], s, r.X, r.Y, r.Width, r.Height, UnitPixel);
      g->DrawCachedBitmap(frame[i % 32], 10, 10);
  }

}

#endif

VOID DrawSimple(Graphics *g)
{

    Bitmap *image = new Bitmap(FileName);

    Unit u;
    RectF r;

    image->GetBounds(&r, &u);

    RectF s = r;

    s.X = 31;
    s.Y = 27;
    
    s.Width *= 0.7f;
    s.Height *= 0.7f;

    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel);
    g->SetClip(Rect(50, 70, 100, 10));
    
    ImageAttributes img;
    ColorMatrix flipRedBlue = {
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    };
    img.SetColorMatrix(&flipRedBlue);
    
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, &img);
    g->ResetClip();

    delete image;
}

VOID DrawSpecialRotate(Graphics *g)
{
    Bitmap *image = new Bitmap(FileName);
    
    Unit u;
    RectF r;
    image->GetBounds(&r, &u);
    RectF s = r;

    ImageAttributes img;
    
    ColorMatrix flipRedBlue = {
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    };
    img.SetColorMatrix(&flipRedBlue);
    
    g->SetCompositingQuality(CompositingQualityGammaCorrected);

    Rect dstRect(0, 0, 50, 100);
    Rect srcRect(12, -14, 50, 100);
    
    g->TranslateTransform(s.Height, 0.0f);
    g->RotateTransform(90);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Height, s.Width);
    g->RotateTransform(270);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Width, s.Height+s.Width);
    g->RotateTransform(180);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Width+2*s.Height, 0.0f);
    g->ScaleTransform(-1.0, 1.0);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();
    
    g->TranslateTransform(2*s.Height, s.Height*2);
    g->ScaleTransform(1.0, -1.0);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Width+2*s.Height, 0.0f);
    g->ScaleTransform(-1.0, 1.0);
    g->RotateTransform(90);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();
    
    g->TranslateTransform(s.Width+3*s.Height, 2*s.Width);
    g->ScaleTransform(-1.0, 1.0);
    g->RotateTransform(270);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();
    
    
    
    //Rot180
    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(180);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(180);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();
    
    //ID
    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(0);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(0);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot270FlipX
    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot270
    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot90FlipX
    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot90
    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    // FlipX
    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    // FlipY
    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(1.0f, -1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(1.0f, -1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    delete image;
}




VOID DrawCachedBitmap(Graphics *g)
{
    Bitmap *image = new Bitmap(FileName);
    
    Bitmap *bmp = new Bitmap(100, 100, PixelFormat32bppPARGB);
    Graphics *gfx = new Graphics(bmp);
    gfx->DrawImage(image, Rect(0,0,100,100), 0,0,100,100, UnitPixel);
    gfx->SetCompositingMode(CompositingModeSourceCopy);
    SolidBrush brush(Color(0x7f0000ff));
    gfx->FillEllipse(&brush, 0, 0, 100, 100);
    brush.SetColor(Color(0x00000000));
    gfx->FillEllipse(&brush, 25, 25, 50, 50);

    delete image;
    delete gfx;
        
    CachedBitmap *cb = new CachedBitmap(bmp, g);

    int x;
    for(int i=0; i<=40; i++)
    {
        x = i-20;
        g->DrawCachedBitmap(cb, x*x, i*10);
    }

    delete cb;
    delete bmp;
}


// Slightly rotated stretch.
VOID DrawStretchRotation(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 20;
  dst[0].Y = 0;
  dst[1].X = 900;
  dst[1].Y = 20;
  dst[2].X = 0;
  dst[2].Y = 700;

  g->DrawImage(image, dst, 3);
  delete image;
}

// Slightly rotated stretch.
VOID DrawShrinkRotation(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];

  dst[0].X = 14.1521f;
  dst[0].Y = 11.0205f;
  dst[1].X = 25.4597f;
  dst[1].Y = 10.5023f;
  dst[2].X = 14.5403f;
  dst[2].Y = 19.4908f;


  g->DrawImage(image, dst, 3);
  delete image;
}

// Rotated stretch with source cropping.
VOID DrawCropRotation(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 20;
  dst[0].Y = 0;
  dst[1].X = 180;
  dst[1].Y = 20;
  dst[2].X = 0;
  dst[2].Y = 140;

  g->DrawImage(image, dst, 3, 0, 0, 488, 400, UnitPixel);
  delete image;
}

// Draw multiple copybits with different source cropping and
// destination positions.
// Little squares are drawn in reverse order from their source position and
// only alternate squares from a checkerboard pattern are drawn.
// Note outcropping can occur along the bottom and right edge of the source -
// which would be the top and left row of squares in the output.
VOID DrawCopyCrop(Graphics *g)
{
  Image *image = new Bitmap(FileName);
  const INT xs = 10;
  const INT ys = 6;
  const INT step = 50;
  Rect s(0,0,step,step);
  for(int i=0; i<xs; i++) for(int j=0; j<ys; j++) {
      if(((i+j) & 0x1)==0x1) {
          s.X = i*step-15;
          s.Y = j*step-15;
          g->DrawImage(image, s,
                       (xs-i-1)*step, (ys-j-1)*step, step, step, UnitPixel);
      }
  }

  delete image;
}


// Pixel centering test. This test should show
// the correct pixel centering. The top left should be green and the bottom
// and right should be blending in the blend color
VOID DrawPixelCenter(Graphics *g)
{
  WCHAR *filename = L"../data/3x3.bmp";
  Image *image = new Bitmap(filename);


  Color black(0xff,0,0,0);
  Pen linepen(black, 1);

  RectF r(100.0f, 100.0f, 300.0f, 300.0f);

  for(int i=0; i<6; i++) {
      g->DrawLine(&linepen, 100*i, 0, 100*i, 600);
      g->DrawLine(&linepen, 0, 100*i, 600, 100*i);
  }

  g->DrawImage(image, r, 0.0f, 0.0f, 3.0f, 3.0f, UnitPixel, Img);
  delete image;
}

// Draw with palette modification.

VOID DrawPalette(Graphics *g)
{
    Image *image = new Bitmap(FileName, uICM==IDM_ICM);

    Unit u;
    RectF r;
    image->GetBounds(&r, &u);
    RectF s = r;
    s.X = 21;
    s.Y = 30;

    ColorPalette *palette = NULL;
    INT size;
    Status status;

    // Whack the first entry in the palette.

    size = image->GetPaletteSize();
    if(size > 0) {
        palette = (ColorPalette *)malloc(size);
        if(palette) {
            status = image->GetPalette(palette, size);
            if(status == Ok) {
                palette->Entries[0] = 0x7fff0000;
                status = image->SetPalette(palette);
            }
        }
    }

    g->DrawImage(image, r, r.X, r.Y, r.Width, r.Height, UnitPixel);

    free(palette);
    delete image;
}


// Specify source rectangle crop area not at the origin.
// Draw off the top of the window (negative destination).
VOID DrawICM(Graphics *g)
{
  Bitmap *image = new Bitmap(FileName, uICM==IDM_ICM);
  
  // Our ICM profile is hacked to flip the red and blue color channels
  // Apply a recolor matrix to flip them back so that if something breaks
  // ICM, the picture will look blue instead of the familiar colors.
  ColorMatrix flipRedBlue =
       {0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
  /*img->SetColorMatrix(&flipRedBlue);*/
        Unit u;
        RectF r;
        image->GetBounds(&r, &u);
        RectF s = r;
        s.X = 21;
        s.Y = 30;
  g->DrawImage(image, r, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);

/*  CachedBitmap *cb = new CachedBitmap(image, g);
  g->DrawCachedBitmap(cb, 100, 100);
  delete cb;*/
  delete image;
}

// Draw a non rotated outcropped image.
VOID DrawOutCrop(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  g->DrawImage(image, Rect(0,0,500,500), -500,-500,1500,1500, UnitPixel, Img);
  delete image;
}

// Do a non-trivial crop with a world transform applied.
VOID DrawCropWT(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  g->TranslateTransform(0, 100.0f);
  g->DrawImage(image, 0, 0, 100,100,600,400, UnitPixel);
  g->ResetTransform();
  delete image;
}

// Non-trivial cropping combined with a horizontal flip and a world transform
VOID DrawHFlip(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 400;
  dst[0].Y = 200;
  dst[1].X = 0;
  dst[1].Y = 200;
  dst[2].X = 400;
  dst[2].Y = 500;

  g->TranslateTransform(0, 100.0f);
  g->DrawImage(image, dst, 3, 100, 100, 600, 400, UnitPixel);
  g->ResetTransform();

  delete image;
}

// Non-trivial cropping combined with a vertical flip and a world transform
VOID DrawVFlip(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 0;
  dst[0].Y = 500;
  dst[1].X = 400;
  dst[1].Y = 500;
  dst[2].X = 0;
  dst[2].Y = 200;

  g->TranslateTransform(0, 100.0f);
  g->DrawImage(image, dst, 3, 100, 100, 600, 400, UnitPixel);
  g->ResetTransform();

  delete image;
}


// Draw stretched image.
VOID DrawStretchS(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  RectF r;

  for(int i=6; i<15; i++)
  {
      g->DrawImage(image, (i+1)*i*10/2-200, 300, i*10, i*10);
  }

  g->DrawImage(image, 0, 0, 470, 200);
  g->DrawImage(image, 500, 100, 300, 300);
  g->DrawImage(image, 100, 500, 400, 300);
  g->DrawImage(image, 500, 500, 300, 80);
  delete image;
}

// Draw stretched image.
VOID DrawStretchB(Graphics *g)
{
  Image *image = new Bitmap(FileName);
  g->DrawImage(image, 100, 100, 603, 603);
  delete image;
}


// Draw a rotated outcropped image.
VOID DrawOutCropR(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 20;
  dst[0].Y = 0;
  dst[1].X = 180;
  dst[1].Y = 20;
  dst[2].X = 0;
  dst[2].Y = 140;

  g->DrawImage(image, dst, 3, -50,-50,600,400, UnitPixel);
  delete image;
}

// Simple no rotation, origin based source clip.
VOID DrawTest2(Graphics *g)
{
  Image *image = new Bitmap(FileName);
  g->DrawImage(image, 0, 0, 0, 0,100,100, UnitPixel);
  delete image;
}

/***************************************************************************\
* DoTest
*
* Sets up the graphics according to the selected parameters on the menu
* and then invokes the appropriate test routine from above.
\***************************************************************************/

VOID
DoTest(
    HWND hwnd
    )
{
  // Create a Graphics in the window.
//  Graphics *g = Graphics::GetFromHwnd(hwnd, uICMBack==IDM_ICM_BACK);

  HDC hdc = GetDC(hwnd);
  SetICMMode(hdc, (uICMBack==IDM_ICM_BACK)?ICM_ON:ICM_OFF);
  Graphics *g = new Graphics(hdc);

  g->SetSmoothingMode(SmoothingModeNone);

  // Choose the resampling mode.
  switch(uResample) {
  case IDM_BILINEAR:
      g->SetInterpolationMode(InterpolationModeBilinear);
  break;
  case IDM_BICUBIC:
      g->SetInterpolationMode(InterpolationModeBicubic);
  break;
  case IDM_NEARESTNEIGHBOR:
      g->SetInterpolationMode(InterpolationModeNearestNeighbor);
  break;
  case IDM_HIGHBILINEAR:
      g->SetInterpolationMode(InterpolationModeHighQualityBilinear);
  break;
  case IDM_HIGHBICUBIC:
      g->SetInterpolationMode(InterpolationModeHighQualityBicubic);
  break;
  default:
  break;
  }

  g->SetPixelOffsetMode(bPixelMode?PixelOffsetModeHalf:PixelOffsetModeNone);

  Img = new ImageAttributes();
  switch(uWrapMode)
  {
      case IDM_WRAPMODETILE: 
          Img->SetWrapMode(WrapModeTile, Color(0), FALSE);
      break;
      case IDM_WRAPMODEFLIPX:
          Img->SetWrapMode(WrapModeTileFlipX, Color(0), FALSE);
      break;
      case IDM_WRAPMODEFLIPY:
          Img->SetWrapMode(WrapModeTileFlipY, Color(0), FALSE);
      break;
      case IDM_WRAPMODEFLIPXY:
          Img->SetWrapMode(WrapModeTileFlipXY, Color(0), FALSE);
      break;
      case IDM_WRAPMODECLAMP0:
          Img->SetWrapMode(WrapModeClamp, Color(0), FALSE);
      break;
      case IDM_WRAPMODECLAMPFF:      
          Img->SetWrapMode(WrapModeClamp, Color(0xffff0000), FALSE);
      break;
  }
  // Choose the test to run
  switch(uCategory) {
  case IDM_ALL:
      DrawSimple(g);
      DrawStretchRotation(g);
      DrawShrinkRotation(g);
      DrawCropRotation(g);
      DrawCopyCrop(g);
      DrawICM(g);
      DrawTest2(g);
      DrawOutCrop(g);
      DrawOutCropR(g);
      DrawCropWT(g);
      DrawHFlip(g);
      DrawVFlip(g);
      DrawStretchB(g);
      DrawCachedBitmap(g);
      DrawStretchS(g);
      DrawPalette(g);
      DrawPixelCenter(g);
      DrawSpecialRotate(g);
  break;

  case IDM_OUTCROPR:
      DrawOutCropR(g);
  break;
  case IDM_OUTCROP:
      DrawOutCrop(g);
  break;
  case IDM_SIMPLE:
      DrawSimple(g);
  break;
  case IDM_STRETCHROTATION:
      DrawStretchRotation(g);
  break;
  case IDM_SHRINKROTATION:
      DrawShrinkRotation(g);
  break;
  case IDM_CROPROTATION:           //who says programmers don't do real work??
      DrawCropRotation(g);
  break;
  case IDM_PIXELCENTER:
      DrawPixelCenter(g);
  break;
  case IDM_COPYCROP:
      DrawCopyCrop(g);
  break;
  case IDM_DRAWPALETTE:
      DrawPalette(g);
  break;
  case IDM_DRAWICM:
      DrawICM(g);
  break;
  case IDM_DRAWIMAGE2:
      DrawTest2(g);
  break;
  case IDM_STRETCHB:
      DrawStretchB(g);
  break;
  case IDM_STRETCHS:
      DrawStretchS(g);
  break;
  case IDM_CACHEDBITMAP:
      DrawCachedBitmap(g);
  break;
  case IDM_CROPWT:
      DrawCropWT(g);
  break;
  case IDM_HFLIP:
      DrawHFlip(g);
  break;
  case IDM_VFLIP:
      DrawVFlip(g);
  break;
  case IDM_SPECIALROTATE:
      DrawSpecialRotate(g);
  break;


  default:
  break;
  }

  delete Img;
  Img = NULL;
  delete g;
  ReleaseDC(hwnd, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\drawimage\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* Menu driven test environment.
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <objbase.h>

#include "wndstuff.h"

HINSTANCE ghInstance;
HWND ghwndMain;
HBRUSH ghbrWhite;
WCHAR FileName[MAX_PATH]=L"winnt256.bmp";

#include <gdiplus.h>

#include "../gpinit.inc"

// Store the user requested state for the DrawImage test.
UINT uCategory;
UINT uResample;
UINT uRotation;
UINT uICM;
UINT uICMBack;
BOOL bPixelMode = FALSE;
UINT uWrapMode = 0;


ULONG _cdecl
DbgPrint(
    CHAR* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);

    char buf[1024];

    _vsnprintf(buf, 1024, format, arglist);
    buf[1024-1]=0;

    OutputDebugStringA(buf);

    va_end(arglist);
    return 0;
}



/***************************************************************************\
* SetXXXX
*
* These routines set the state for the test. When the user selects
* an option from the menu, we store the state and mark the selection
* in the menu text.
* The DoTest routine queries the global variables (above) to determine
* which test to run and set the environment for the test.
\***************************************************************************/

VOID SetCategory(HWND hwnd, UINT uNewCategory)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 2);
    CheckMenuItem(hmenu2, uCategory, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewCategory, MF_BYCOMMAND | MF_CHECKED);
    uCategory = uNewCategory;
}

VOID SetResample(HWND hwnd, UINT uNewResample)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 3);
    CheckMenuItem(hmenu2, uResample, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewResample, MF_BYCOMMAND | MF_CHECKED);
    uResample = uNewResample;
}

VOID SetICM(HWND hwnd, UINT uNewICM)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 5);
    CheckMenuItem(hmenu2, uICM, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewICM, MF_BYCOMMAND | MF_CHECKED);
    uICM = uNewICM;
}

VOID SetICMBack(HWND hwnd, UINT uNewICM)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 5);
    CheckMenuItem(hmenu2, uICMBack, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewICM, MF_BYCOMMAND | MF_CHECKED);
    uICMBack = uNewICM;
}

VOID SetRotation(HWND hwnd, UINT uNewRotation)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 6);
    CheckMenuItem(hmenu2, uRotation, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewRotation, MF_BYCOMMAND | MF_CHECKED);
    uRotation = uNewRotation;
}

VOID SetPixelOffsetMode(HWND hwnd, UINT uPixelMode)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 4);
    bPixelMode = !bPixelMode;
    CheckMenuItem(hmenu2, uPixelMode, MF_BYCOMMAND | (bPixelMode?MF_CHECKED:MF_UNCHECKED));
}


VOID SetWrapMode(HWND hwnd, UINT uNewWrapMode)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 4);
    CheckMenuItem(hmenu2, uNewWrapMode, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItem(hmenu2, uWrapMode, MF_BYCOMMAND | MF_UNCHECKED);
    uWrapMode = uNewWrapMode;
}


inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(CP_ACP,
                               0,
                               ansiStr,
                               -1,
                               unicodeStr,
                               unicodeSize) > 0;
}


void OpenFileProc(HWND hwnd)
{

    char locFileName[MAX_PATH];
    OPENFILENAME    ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = ghInstance;
    ofn.lpstrFile = locFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    locFileName[0] = '\0';

    // Present the file/open dialog

    if(GetOpenFileName(&ofn))
    {
        AnsiToUnicodeStr(locFileName, FileName, MAX_PATH);
    }
}



/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {

    case WM_DEVMODECHANGE:
        DbgPrint("Devmode change\n");
        break;

    case WM_DEVICECHANGE:
        DbgPrint("Device change\n");
        break;

    case WM_DISPLAYCHANGE:
        DbgPrint("Display change\n");
        break;

    case WM_CREATE:
        break;

    case WM_SIZE:
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        DoTest(hwnd);
        EndPaint(hwnd, &ps);
        break;


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {

        case IDM_OPENFILE:
            OpenFileProc(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_TEST:
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Choose the test.
        case IDM_ALL:
        case IDM_OUTCROP:
        case IDM_OUTCROPR:
        case IDM_SIMPLE:
        case IDM_STRETCHROTATION:
        case IDM_SHRINKROTATION:
        case IDM_CROPROTATION:
        case IDM_COPYCROP:
        case IDM_DRAWICM:
        case IDM_DRAWPALETTE:
        case IDM_DRAWIMAGE2:
        case IDM_STRETCHB:
        case IDM_STRETCHS:
        case IDM_PIXELCENTER:
        case IDM_CACHEDBITMAP:
        case IDM_CROPWT:
        case IDM_HFLIP:
        case IDM_VFLIP:
        case IDM_SPECIALROTATE:
            SetCategory(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Choose the world to device transformation
        case IDM_ROT0:
        case IDM_ROT10:
        case IDM_ROT30:
        case IDM_ROT45:
        case IDM_ROT60:
        case IDM_ROT90:
            SetRotation(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_ICM:
        case IDM_NOICM:
            SetICM(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_ICM_BACK:
        case IDM_ICM_NOBACK:
            SetICMBack(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;


        // Choose the resample mode
        case IDM_BILINEAR:
        case IDM_BICUBIC:
        case IDM_NEARESTNEIGHBOR:
        case IDM_HIGHBILINEAR:
        case IDM_HIGHBICUBIC:
            SetResample(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Set the PixelOffsetMode
        case IDM_PIXELMODE:
            SetPixelOffsetMode(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Set the WrapMode
        case IDM_WRAPMODETILE:
        case IDM_WRAPMODEFLIPX:
        case IDM_WRAPMODEFLIPY:
        case IDM_WRAPMODEFLIPXY:
        case IDM_WRAPMODECLAMP0:
        case IDM_WRAPMODECLAMPFF:
            SetWrapMode(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_QUIT:
            exit(0);
        break;

        default:
            // The user selected an unimplemented menu item.
            MessageBox(hwnd,
                _T("Help me! - I've fallen and I can't get up!!!"),
                _T(""),
                MB_OK
            );
        break;

        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes the app.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    // not quite so white background brush.
    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");

    if(!RegisterClass(&wc)) { return FALSE; }

    ghwndMain = CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_BORDER       |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL
    );

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return TRUE;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    ghInstance = GetModuleHandle(NULL);
    if(!bInitApp()) { return 0; }

    // Initialize the default menu selection.
    SetCategory(ghwndMain, IDM_DRAWICM);
    SetRotation(ghwndMain, IDM_ROT0);
    SetResample(ghwndMain, IDM_BICUBIC);
    SetICM(ghwndMain, IDM_NOICM);
    SetPixelOffsetMode(ghwndMain, IDM_PIXELMODE);
    SetICMBack(ghwndMain, IDM_ICM_NOBACK);
    SetWrapMode(ghwndMain, IDM_WRAPMODETILE);

    while(GetMessage (&msg, NULL, 0, 0))
    {
      if((ghwndMain == 0) || !IsDialogMessage(ghwndMain, &msg)) {
        TranslateMessage(&msg) ;
        DispatchMessage(&msg) ;
      }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\drawimage\drawimage.hpp ===
/****************************** Module Header ******************************\
* Module Name: drawimage.hpp
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
\***************************************************************************/

#pragma once

extern UINT uCategory;
extern UINT uResample;
extern UINT uRotation;
extern UINT uICM;
extern UINT uICMBack;
extern BOOL bPixelMode;
extern WCHAR FileName[MAX_PATH];
extern UINT uWrapMode;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\drawimage\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
\***************************************************************************/
#pragma once

#include <windows.h>
#include <winuser.h>
#include <commdlg.h>

#define DONTUSE(x) (x)

#define IDM_TEST                        40000

// tests
#define IDM_ALL                         40100
#define IDM_SIMPLE                      40101
#define IDM_DRAWICM                     40102
#define IDM_DRAWIMAGE2                  40103
#define IDM_STRETCHROTATION             40104
#define IDM_CROPROTATION                40105
#define IDM_COPYCROP                    40106
#define IDM_OUTCROP                     40107
#define IDM_OUTCROPR                    40108
#define IDM_STRETCHB                    40109
#define IDM_STRETCHS                    40110
#define IDM_SHRINKROTATION              40111
#define IDM_PIXELCENTER                 40112
#define IDM_DRAWPALETTE                 40113
#define IDM_CACHEDBITMAP                40114
#define IDM_CROPWT                      40115
#define IDM_HFLIP                       40116
#define IDM_VFLIP                       40117
#define IDM_SPECIALROTATE               40118



// Resample mode
#define IDM_BILINEAR                    40200
#define IDM_BICUBIC                     40201
#define IDM_NEARESTNEIGHBOR             40202
#define IDM_HIGHBILINEAR                40203
#define IDM_HIGHBICUBIC                 40204
#define IDM_PIXELMODE                   40205
#define IDM_WRAPMODETILE                40206
#define IDM_WRAPMODEFLIPX               40207
#define IDM_WRAPMODEFLIPY               40208
#define IDM_WRAPMODEFLIPXY              40209
#define IDM_WRAPMODECLAMP0              40210
#define IDM_WRAPMODECLAMPFF             40211

#define IDM_QUIT                        40300

#define IDM_ROT0                        40400
#define IDM_ROT10                       40401
#define IDM_ROT30                       40402
#define IDM_ROT45                       40403
#define IDM_ROT60                       40404
#define IDM_ROT90                       40405

#define IDM_ICM                         40500
#define IDM_NOICM                       40501
#define IDM_ICM_BACK                    40502
#define IDM_ICM_NOBACK                  40503

#define IDM_OPENFILE                    40600


ULONG _cdecl
DbgPrint(
    CHAR* format,
    ...
    );



VOID DoTest(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCEA(240)
#define RT_TOOLBAR  MAKEINTRESOURCEA(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cextra.cpp ===
// Include all the primitives (classes derived from CPrimitive)
#include "CPaths.h"
#include "CBanding.h"
#include "CPrinting.h"
#include "CExtra.h"

// Create global objects for each individual primitive
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CPaths   g_Paths(true);
CBanding g_Banding(true);


void ExtraInitializations()
{
    g_Paths.Init();
    g_Banding.Init();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cbanding.h ===
/******************************Module*Header*******************************\
* Module Name: CBanding.h
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBanding_H
#define __CBanding_H

#include "CPrimitive.h"

class CBanding : public CPrimitive  
{
public:
	CBanding(BOOL bRegression);
	virtual ~CBanding();

	void Draw(Graphics *g);

	VOID TestBanding(Graphics* g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cbanding.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBanding.cpp
*
\**************************************************************************/
#include "CBanding.h"
#include <limits.h>

extern HWND g_hWndMain;

CBanding::CBanding(BOOL bRegression)
{
	strcpy(m_szName,"Banding");
	m_bRegression=bRegression;
}

CBanding::~CBanding()
{
}

void CBanding::Draw(Graphics *g)
{
    TestBanding(g);
}

VOID CBanding::TestBanding(Graphics *g)
{

    Unit     u;
    RectF    rect;
    REAL     width = 10;
    RectF    copyRect;
    RECT     crect;
    WCHAR    filename[256];
    GraphicsPath *path;

    HINSTANCE hInst=GetModuleHandleA(NULL);

    Bitmap *bitmap = new Bitmap(hInst, L"MARBLE_BMP");

    bitmap->GetBounds(&copyRect, &u);

    GetClientRect(g_hWndMain, &crect);
    rect.X = (30.0f/450.0f*crect.right);
    rect.Y = (30.0f/450.0f*crect.bottom);
    rect.Width = (crect.right-(70.0f/450.0f*crect.right));
    rect.Height = (crect.bottom-(70.0f/450.0f*crect.bottom));

    path = new GraphicsPath(FillModeAlternate);

    path->AddRectangle(rect);

    // Our ICM profile is hacked to flip the red and blue color channels
    // Apply a recolor matrix to flip them back so that if something breaks
    // ICM, the picture will look blue instead of the familiar colors.

    ImageAttributes *img = new ImageAttributes();

    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    ColorMatrix flipRedBlue =
       {0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
    img->SetColorMatrix(&flipRedBlue);
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    TextureBrush textureBrush(bitmap, copyRect, img);

    g->FillPath(&textureBrush, path);

    Color blackColor(128, 0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawPath(&blackPen, path);

    delete img;
    delete path;
    delete bitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cextra.h ===
VOID ExtraInitializations();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cfunctest.h ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFUNCTEST_H
#define __CFUNCTEST_H

#include "Global.h"
#include "CPrimitive.h"
#include "CSetting.h"
#include "COutput.h"

class CFuncTest  
{
public:
	CFuncTest();
	~CFuncTest();

	BOOL Init(HWND hWndParent);								// Initializes functest
	void RunSamples();										// Toggles option dialog
	static INT_PTR CALLBACK DlgProc(HWND hWndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

	BOOL AddPrimitive(CPrimitive *pPrimitive);				// Add a primitive to test list
	BOOL AddOutput(COutput *pOutput);						// Add a graphics output to test list
	BOOL AddSetting(CSetting *pSetting);					// Add a graphics setting to test list

	RECT GetTestRect(int nCol,int nRow);					// Gets the test area located at nCol/nRow
	void RunTest(COutput *pOutput,CPrimitive *pPrimitive);	// Runs a specific test on a specific output
	void InitRun();											// Must be called before running a series of tests
	void EndRun();											// Must be called after running a series of tests
	void Run();												// Run the selected tests
	void RunRegression();									// Run regression tests

	void ClearAllSettings();								// Sets all settings in the list box to m_bUseSetting=false

	HWND m_hWndMain;										// Main window
	HWND m_hWndDlg;											// Dialog window
	BOOL m_bUsePageDelay;									// Use page delay or page pause
	BOOL m_bEraseBkgd;										// Erase old test background
	BOOL m_bDriverHacks;									// Enable printer driver hacks in GDIPlus
	BOOL m_bAppendTest;										// Appends test to previous tests
	int m_nPageDelay;										// Delay after each graphics page
	int m_nPageRow;											// Row to draw next test
	int m_nPageCol;											// Column to draw next test
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cfunctest.cpp ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include "CFuncTest.h"
#include "Resource.h"
#include "CHDC.h"
#include "windows.h"

void EnableGDIPlusDriverHacks(BOOL);
extern LPFNGDIPLUS glpfnDisplayPaletteWindowNotify;
extern HWND g_hWndMain;

extern CFuncTest g_FuncTest;        // Initialized in Main.cpp
extern HBRUSH g_hbrBackground;      // Initialized in Main.cpp
extern CHDC g_HDC;                  // Initialized in Main.cpp
extern int g_nResult;               // Initialized in Main.cpp
extern int gnPaths;

CFuncTest::CFuncTest()
{
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
    m_bUsePageDelay=true;           // Default use page delay or page pause
    m_bEraseBkgd=true;              // Default erace background
    m_bAppendTest=false;            // Default append test
    m_bDriverHacks=false;           // Default enable printer driver hacks
    m_nPageDelay=1000;              // Default page delay
    m_nPageRow=0;
    m_nPageCol=0;
}

CFuncTest::~CFuncTest()
{
    EndDialog(m_hWndDlg,0);
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
}

BOOL CFuncTest::Init(HWND hWndParent)
// Initializes functest
{
    HWND hWnd;
    char szDelay[10];
    char szNumPaths[10];

    m_hWndMain=hWndParent;

    // Create options dialog box
    m_hWndDlg=CreateDialogA(GetModuleHandleA(NULL),MAKEINTRESOURCEA(IDD_FUNCTEST),hWndParent,&DlgProc);
    if (m_hWndDlg==NULL)
        return false;

/*
    // Set default options in dialog box using defaults in constructor
    if (m_bUsePageDelay)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    else
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEPAUSE);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }

    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)_itoa(m_nPageDelay,szDelay,10));
*/

    hWnd=GetDlgItem(m_hWndDlg,IDC_NUMPATHS);
    SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)_itoa(gnPaths,szNumPaths,10));

    if (m_bEraseBkgd)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }

    if (m_bDriverHacks)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_DRIVERHACKS);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumEnablePrnOpts);
    }
/*
    if (m_bAppendTest)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
 