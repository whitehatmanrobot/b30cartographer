Download()
{
    ICDNet* pICDNet = NULL;
    if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&pICDNet)))
    {
        pICDNet->CancelDownload();
        pICDNet->Release();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * EndDownloadThreads
// Kills the download threads on shutdown
////////////////////////////////////////////////////////////////////////////////////////////
void EndDownloadThreads()
{
    //optimization: don't bother if CDNET.DLL is not loaded
    if (GetModuleHandle(TEXT("CDNET.DLL")))
    {
        if (IsDownloading())
        {
            CancelDownload();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * MenuButtonTimerProc
// Big ol' hack to make the menus that drop down from button seem like real menus ...
// if the user hits the button before the timeout time, we don't redisplay the menu
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK MenuButtonTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    //single-shot timer turns off the "block menu" flag
    fBlockMenu = FALSE;
    nLastMenu = 0;
    KillTimer(hwnd,idEvent);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * BlockMenu
// Turns on the button/menu hack
////////////////////////////////////////////////////////////////////////////////////////////
void BlockMenu(HWND hwnd)
{
    fBlockMenu = TRUE;
    SetTimer(hwnd,nLastMenu,MENU_TIMER_RATE,(TIMERPROC)MenuButtonTimerProc);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * NormalizeNameForMenuDisplay
//    This function turns a string like "Twist & Shout" into
//    "Twist && Shout" because otherwise it will look like
//    "Twist _Shout" in the menu due to the accelerator char
//
//  Defined in cdplayer.lib
//
////////////////////////////////////////////////////////////////////////////////////////////
extern "C" void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen);

////////////////////////////////////////////////////////////////////////////////////////////
// * DrawButton
// Response to WM_DRAWITEM on buttons
////////////////////////////////////////////////////////////////////////////////////////////
void DrawButton(UINT idCtl, LPDRAWITEMSTRUCT lpdis)
{
    CMButton* pButton = GetMButtonFromID(hwndMain,idCtl);

    if (pButton!=NULL)
    {
	    pButton->Draw(lpdis);
    }

    //special case ... if the button is one of the scanner buttons,
    //forward this message to the component
    if ((idCtl==IDB_REW) || (idCtl==IDB_FFWD))
    {
        switch (idCtl)
        {
            case IDB_REW  : idCtl = IDM_PLAYBAR_SKIPBACK; break;
            case IDB_FFWD : idCtl = IDM_PLAYBAR_SKIPFORE; break;
        }
        lpdis->CtlID = idCtl;
        SendMessage(hwndCurrentComp,WM_DRAWITEM,idCtl,(LPARAM)lpdis);
    }

    if (
        (idCtl == IDB_OPTIONS) ||
        (idCtl == IDB_MODE) ||
        (idCtl == IDB_TRACK) ||
        (idCtl == IDB_NET) ||
        (idCtl == IDB_DISC)
       )
    {
        if (lpdis->itemState & ODS_SELECTED)
        {
            if ((fBlockMenu) && (nLastMenu == idCtl))
            {
                return;
            }

            HWND hwnd = hwndMain;
	        RECT rect;
            AllocCustomMenu(&g_pMenu);
            CustomMenu* pSearchSubMenu = NULL;
            CustomMenu* pProviderSubMenu = NULL;

            if (!g_pMenu)
            {
                return;
            }

            if (idCtl == IDB_OPTIONS)
            {
                g_pMenu->AppendMenu(IDM_OPTIONS,hInst,IDM_OPTIONS);
                g_pMenu->AppendMenu(IDM_PLAYLIST,hInst,IDM_PLAYLIST);
                g_pMenu->AppendSeparator();

                if (!IsNetOK(hwnd))
                {
                    EnableMenuItem(g_pMenu->GetMenuHandle(),
                                    IDM_PLAYLIST,
                                    MF_BYCOMMAND | MF_GRAYED);
                }

                if (g_nViewMode == VIEW_MODE_NORMAL)
                {
                    g_pMenu->AppendMenu(IDM_TINY,hInst,IDM_TINY);
                }
                else
                {
                    g_pMenu->AppendMenu(IDM_NORMAL,hInst,IDM_NORMAL);
                }

                g_pMenu->AppendSeparator();

                g_pMenu->AppendMenu(IDM_HELP,hInst,IDM_HELP);
                g_pMenu->AppendMenu(IDM_ABOUT,hInst,IDM_ABOUT);

                g_pMenu->AppendSeparator();

                g_pMenu->AppendMenu(IDM_EXIT,hInst,IDM_EXIT);
            } //end if options

            if (idCtl == IDB_NET)
            {
                AllocCustomMenu(&pSearchSubMenu);
                AllocCustomMenu(&pProviderSubMenu);

		        MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
		        pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                pAuto->Release();

                BOOL fContinue = TRUE;

                //append static menu choices
                if (IsDownloading())
                {
                    g_pMenu->AppendMenu(IDM_NET_CANCEL,hInst,IDM_NET_CANCEL);
                }
                else
                {
                    g_pMenu->AppendMenu(IDM_NET_UPDATE,hInst,IDM_NET_UPDATE);
                    if (mmMedia.dwMediaID == 0)
                    {
                        //need to gray out menu
                        MENUITEMINFO mmi;
                        mmi.cbSize = sizeof(mmi);
                        mmi.fMask = MIIM_STATE;
                        mmi.fState = MFS_GRAYED;
                        HMENU hMenu = g_pMenu->GetMenuHandle();
                        SetMenuItemInfo(hMenu,IDM_NET_UPDATE,FALSE,&mmi);
                    }
                }
	            
                //if networking is not allowed, gray it out ...
                //don't worry about cancel case, it won't be there
                if (!IsNetOK(hwnd))
                {
                    EnableMenuItem(g_pMenu->GetMenuHandle(),
                                    IDM_NET_UPDATE,
                                    MF_BYCOMMAND | MF_GRAYED);
                }

                //don't allow searching if title isn't available
                LPCDDATA pData = GetCDData();
                if (pData)
                {
                    if (pData->QueryTitle(mmMedia.dwMediaID))
                    {
                        pSearchSubMenu->AppendMenu(IDM_NET_BAND,hInst,IDM_NET_BAND);
                        pSearchSubMenu->AppendMenu(IDM_NET_CD,hInst,IDM_NET_CD);
                        pSearchSubMenu->AppendMenu(IDM_NET_ROLLINGSTONE_ARTIST,hInst,IDM_NET_ROLLINGSTONE_ARTIST);
                        pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ARTIST,hInst,IDM_NET_BILLBOARD_ARTIST);
                        pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ALBUM,hInst,IDM_NET_BILLBOARD_ALBUM);
                        g_pMenu->AppendMenu(hInst,IDM_NET_SEARCH_HEADING,pSearchSubMenu);
                    }
                } //end if pdata

                //display any provider home pages
                DWORD i = 0;
                LPCDOPT pOpt = GetCDOpt();
                if( pOpt )
                {
                    LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

                    LPCDPROVIDER pProviderList = pCDOpts->pProviderList;

                    while (pProviderList!=NULL)
                    {
                        TCHAR szProviderMenu[MAX_PATH];
                        TCHAR szHomePageFormat[MAX_PATH/2];
                        LoadString(hInst,IDS_HOMEPAGEFORMAT,szHomePageFormat,sizeof(szHomePageFormat)/sizeof(TCHAR));
                        wsprintf(szProviderMenu,szHomePageFormat,pProviderList->szProviderName);
    
                        pProviderSubMenu->AppendMenu(IDM_HOMEMENU_BASE+i,szProviderMenu);

                        pProviderList = pProviderList->pNext;
                        i++;
                    } //end while

                    g_pMenu->AppendMenu(hInst,IDM_NET_PROVIDER_HEADING,pProviderSubMenu);
                } //end home pages

                //display internet-loaded disc menus
                if (pData)
                {
                    if (pData->QueryTitle(mmMedia.dwMediaID))
                    {
                        LPCDTITLE pCDTitle = NULL;
                        hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                        if (SUCCEEDED(hr))
                        {
                            for (i = 0; i < pCDTitle->dwNumMenus; i++)
                            {
                                if (i==0)
                                {
                                    g_pMenu->AppendSeparator();
                                }

                                TCHAR szDisplayNet[MAX_PATH];
                                NormalizeNameForMenuDisplay(pCDTitle->pMenuTable[i].szMenuText,szDisplayNet,sizeof(szDisplayNet));
            	                g_pMenu->AppendMenu(i + IDM_NETMENU_BASE,szDisplayNet);
                            }

                            pData->UnlockTitle(pCDTitle,FALSE);
                        }
                    } //end if query title
                }
            } //end if net

            if (idCtl == IDB_MODE)
            {
                g_pMenu->AppendMenu(IDM_MODE_NORMAL,hInst,IDI_MODE_NORMAL,IDM_MODE_NORMAL);
                g_pMenu->AppendMenu(IDM_MODE_RANDOM,hInst,IDI_MODE_RANDOM,IDM_MODE_RANDOM);
                g_pMenu->AppendMenu(IDM_MODE_REPEATONE,hInst,IDI_MODE_REPEATONE,IDM_MODE_REPEATONE);
                g_pMenu->AppendMenu(IDM_MODE_REPEATALL,hInst,IDI_MODE_REPEATALL,IDM_MODE_REPEATALL);
                g_pMenu->AppendMenu(IDM_MODE_INTRO,hInst,IDI_MODE_INTRO,IDM_MODE_INTRO);
                g_pMenu->SetMenuDefaultItem(nCDMode,FALSE);
            } //end if mode

            if (idCtl==IDB_TRACK)
            {
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	            {
                    int i = 0;
                    while (SUCCEEDED(hr))
                    {
		                MMTRACKORDISC mmTrack;
                        mmTrack.nNumber = i++;
                        hr = pAuto->OnAction(MMACTION_GETTRACKINFO,&mmTrack);
                        if (SUCCEEDED(hr))
                        {
                            g_pMenu->AppendMenu(mmTrack.nID + IDM_TRACKLIST_BASE, mmTrack.szName);
                            if (mmTrack.fCurrent)
                            {
                                g_pMenu->SetMenuDefaultItem(mmTrack.nID + IDM_TRACKLIST_BASE,FALSE);
                            } //end if current
                        } //end if ok
                    } //end while
                    pAuto->Release();
                }
            } //end if track

            if (idCtl == IDB_DISC)
            {
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	            {
                    int i = 0;
                    while (SUCCEEDED(hr))
                    {
		                MMTRACKORDISC mmDisc;
                        mmDisc.nNumber = i++;
                        hr = pAuto->OnAction(MMACTION_GETDISCINFO,&mmDisc);
                        if (SUCCEEDED(hr))
                        {
                            g_pMenu->AppendMenu(mmDisc.nID + IDM_DISCLIST_BASE, mmDisc.szName);
                            if (mmDisc.fCurrent)
                            {
                                g_pMenu->SetMenuDefaultItem(mmDisc.nID + IDM_DISCLIST_BASE,FALSE);
                            } //end if current
                        }
                    }
                    pAuto->Release();
                }
            } //end if disc

            //push down to under button
            HWND hwndButton = pButton->GetHWND();
	        GetClientRect(hwndButton,&rect);

	        //convert whole rect to screen coordinates
            ClientToScreen(hwndButton,(LPPOINT)&rect);
            ClientToScreen(hwndButton,((LPPOINT)&rect)+1);

            KillTimer(hwnd,nLastMenu);
            nLastMenu = idCtl;
            fBlockMenu = TRUE;
            pButton->SetMenuingState(TRUE);
            if (g_pMenu)
            {
                g_pMenu->TrackPopupMenu(0,rect.left,rect.bottom,hwnd,&rect);
            }
            else
            {
                BlockMenu(hwnd);
            }
            pButton->SetMenuingState(FALSE);
    
            if (g_pMenu)
            {
                g_pMenu->Destroy();
                g_pMenu = NULL;
            }
    
            if (pProviderSubMenu)
            {
                pProviderSubMenu->Destroy();
                pProviderSubMenu = NULL;
            }
            if (pSearchSubMenu)
            {
                pSearchSubMenu->Destroy();
                pSearchSubMenu = NULL;
            }
        } //end if selected
    } //end if right button

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OnNCHitTest
// How we pretend that we have a real caption
////////////////////////////////////////////////////////////////////////////////////////////
UINT OnNCHitTest(HWND hwnd, short x, short y, BOOL fButtonDown)
{
    UINT ht = HTCLIENT;

    if (!fButtonDown)
    {
        ht = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc );
    }

    RECT rect;
    GetClientRect(hwnd,&rect);
    rect.bottom = rect.top + TITLEBAR_HEIGHT +
                    (g_nViewMode == VIEW_MODE_NORMAL ? TITLEBAR_YOFFSET_LARGE :
                                                       TITLEBAR_YOFFSET_SMALL);

    POINT pt;
    pt.x = (LONG)x;
    pt.y = (LONG)y;

    ScreenToClient(hwnd,&pt);

    if (PtInRect(&rect,pt))
    {
        ht = HTCAPTION;
    }

    rect.left = SYSMENU_XOFFSET;
    rect.right = SYSMENU_XOFFSET + SYSMENU_WIDTH;
    //check for a system-menu hit.
    if (PtInRect(&rect,pt))
    {
        ht = HTSYSMENU;
    }

    //always a caption hit in small mode or nobar mode
    if (g_nViewMode >= VIEW_MODE_SMALL)
    {
        ht = HTCAPTION;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, ht);

    return (ht);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * FillGradient
// from kernel's caption.c
// Allows us to have the cool gradient caption bar that you get for free otherwise
////////////////////////////////////////////////////////////////////////////////////////////
void FillGradient(HDC hdc, LPCRECT prc, COLORREF rgbLeft, COLORREF rgbRight)
{
    TRIVERTEX avert[2];
    static GRADIENT_RECT auRect[1] = {0,1};
    #define GetCOLOR16(RGB, clr) ((COLOR16)(Get ## RGB ## Value(clr) << 8))

    avert[0].Red = GetCOLOR16(R, rgbLeft);
    avert[0].Green = GetCOLOR16(G, rgbLeft);
    avert[0].Blue = GetCOLOR16(B, rgbLeft);

    avert[1].Red = GetCOLOR16(R, rgbRight);
    avert[1].Green = GetCOLOR16(G, rgbRight);
    avert[1].Blue = GetCOLOR16(B, rgbRight);

    avert[0].x = prc->left;
    avert[0].y = prc->top;
    avert[1].x = prc->right;
    avert[1].y = prc->bottom;

    //only load once, when needed.  Freed in "CleanUp" call
    if (hmImage == NULL)
    {
        hmImage = LoadLibrary(TEXT("MSIMG32.DLL"));
        if (hmImage!=NULL)
        {
	        fnGradient = (GRADIENTPROC)GetProcAddress(hmImage,"GradientFill");
        }
    }

	if (fnGradient!=NULL)
	{
		fnGradient(hdc, avert, 2, (PUSHORT)auRect, 1, 0x00000000);
        return;
	}

    BOOL fActiveWindow = FALSE;

    if (hwndMain == GetForegroundWindow())
    {
	    fActiveWindow = TRUE;
    }

	HBRUSH hbrush = CreateSolidBrush(GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION));
	FillRect(hdc,prc,hbrush);
	DeleteObject(hbrush);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DrawTitleBar
// Blits the title bar to the screen
////////////////////////////////////////////////////////////////////////////////////////////
void DrawTitleBar(HDC hdc, HWND hwnd, BOOL fActiveWindow, BOOL fExludeRect)
{
    if (g_nViewMode >= VIEW_MODE_SMALL)
    {
        return; //no title bar in these views
    }

    RECT rect;
    HBRUSH hbrush;

    //convert the client rect of the minimize button into the rect within the
    //main display area
    RECT minButtonRect;
    RECT mainWndRect;
    GetWindowRect(hwnd,&mainWndRect);
    
    HWND hwndButton = GetDlgItem(hwnd,IDB_MINIMIZE);

    if (!hwndButton)
    {
        return; //must have been called before button was created
    }

    GetWindowRect(hwndButton,&minButtonRect);
    
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP hbmp = CreateCompatibleBitmap(hdc,
					  (g_nViewMode == VIEW_MODE_NORMAL ? bmMain.bmWidth : bmMainRestore.bmWidth),
					  (g_nViewMode == VIEW_MODE_NORMAL ? bmMain.bmHeight : bmMainRestore.bmHeight));
    HBITMAP holdbmp = (HBITMAP)SelectObject(memDC, hbmp);

    BOOL fGradient = FALSE;
    SystemParametersInfo(SPI_GETGRADIENTCAPTIONS,0,&fGradient,0);

    //we just need the left-hand side.
    //to get it, we take the width of the window and subtract the offset
    //from the right of the window
    minButtonRect.left = (mainWndRect.right - mainWndRect.left) -
                         (mainWndRect.right - minButtonRect.left);

    rect.left = SYSMENU_XOFFSET + SYSMENU_WIDTH + 1;
    rect.right = minButtonRect.left - (GetXOffset()*2) - 1;

    rect.top = (g_nViewMode == VIEW_MODE_NORMAL ? TITLEBAR_YOFFSET_LARGE :
                                                  TITLEBAR_YOFFSET_SMALL);

    rect.bottom = rect.top + TITLEBAR_HEIGHT;

    if (fGradient)
    {
	    DWORD dwStartColor = GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION);
	    DWORD dwFinishColor = GetSysColor(fActiveWindow ? COLOR_GRADIENTACTIVECAPTION : COLOR_GRADIENTINACTIVECAPTION);
	    FillGradient(memDC,&rect,dwStartColor,dwFinishColor);
    }
    else
    {
	    hbrush = CreateSolidBrush(GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION));
	    FillRect(memDC,&rect,hbrush);
	    DeleteObject(hbrush);
    }

    TCHAR s[MAX_PATH];
    GetWindowText(hwnd,s,MAX_PATH-1);

    SetBkMode(memDC,TRANSPARENT);
    SetTextColor(memDC, GetSysColor(fActiveWindow ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT));

    //create title bar font
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    if (IS_DBCS_CHARSET(metrics.lfCaptionFont.lfCharSet))
    {
	metrics.lfCaptionFont.lfHeight = (-9 * STANDARD_PIXELS_PER_INCH) / 72;
    } else {
	metrics.lfCaptionFont.lfHeight = (-8 * STANDARD_PIXELS_PER_INCH) / 72;
    }

    HFONT hTitleFont = CreateFontIndirect(&metrics.lfCaptionFont);

    HFONT hOrgFont = (HFONT)SelectObject(memDC, hTitleFont);

    ExtTextOut( memDC, rect.left + 3, rect.top, 0, NULL, s, _tcslen(s), NULL );

    SelectObject(memDC,hOrgFont);

    BitBlt(hdc,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top-1,memDC,rect.left,rect.top,SRCCOPY);

    if (fExludeRect)
    {
        ExcludeClipRect(hdc,rect.left,rect.top,rect.right,rect.bottom-1);        
    }

    SelectObject(memDC, holdbmp);
    DeleteObject(hbmp);
    SelectObject(memDC, hOrgFont);
    DeleteDC(memDC);
    if (hTitleFont)
        DeleteObject(hTitleFont);
}
    
////////////////////////////////////////////////////////////////////////////////////////////
// * DrawVolume
// Tells the cdplayer to start showing the volume setting
////////////////////////////////////////////////////////////////////////////////////////////
void DrawVolume(DWORD level)
{
    //we just have the led window draw it
    HWND ledWnd = GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW);

    MMONVOLCHANGED mmVolChange;
    mmVolChange.dwNewVolume = level;
    mmVolChange.fMuted = FALSE;
    mmVolChange.szLineName = szLineName;

    SendMessage(ledWnd,WM_LED_INFO_PAINT,0,(LPARAM)&mmVolChange);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OnToolTipNotify
// Called from tool tips to get the text they need to display
////////////////////////////////////////////////////////////////////////////////////////////
VOID OnToolTipNotify(LPARAM lParam)
{     
    LPTOOLTIPTEXT lpttt;     
    HWND hwndCtrl;  

    if ((((LPNMHDR) lParam)->code) == TTN_NEEDTEXT) 
    { 
        hwndCtrl = (HWND)((LPNMHDR)lParam)->idFrom; 
        lpttt = (LPTOOLTIPTEXT) lParam;

        if (hwndCtrl == GetDlgItem(hwndMain,IDB_VOLUME))
        {
            GetWindowText(hwndCtrl,g_tooltext,sizeof(g_tooltext)/sizeof(TCHAR));
        }
        else
        {
            CMButton* pButton = GetMButtonFromHWND(hwndCtrl);
            if (pButton)
            {
                LoadString(hInst,pButton->GetToolTipID(),g_tooltext,sizeof(g_tooltext)/sizeof(TCHAR));
            }
        }
        lpttt->lpszText = g_tooltext;
    } 	
    return;
} 

////////////////////////////////////////////////////////////////////////////////////////////
// * GetNumBatchedTitles
// Get the number of titles currently in the batch queue
////////////////////////////////////////////////////////////////////////////////////////////
DWORD GetNumBatchedTitles()
{
    LPCDDATA pData = GetCDData();
    DWORD dwReturn = 0;

    if (pData)
    {
        dwReturn = pData->GetNumBatched();
    }

    return (dwReturn);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleBadServiceProvider
// Put up message box if the provider did not pass validation
////////////////////////////////////////////////////////////////////////////////////////////
void HandleBadServiceProvider(HWND hwndParent)
{
    TCHAR szError[MAX_PATH];
    LoadString(hInst,IDS_BADPROVIDER,szError,sizeof(szError)/sizeof(TCHAR));
    MessageBox(hwndParent,szError,szAppName,MB_ICONEXCLAMATION|MB_OK);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * NormalizeNameForURL
// Changes a name to a "normalized" name for URL
////////////////////////////////////////////////////////////////////////////////////////////
void NormalizeNameForURL(LPCTSTR szName, LPTSTR szOutput, DWORD cbOutputLen)
{
	typedef BOOL (PASCAL *CANPROC)(LPCTSTR, LPTSTR, LPDWORD, DWORD);
    CANPROC canProc = NULL;
    
    _tcscpy(szOutput,szName); //init URL with passed-in value

    //if possible, canonicalize the URL
    HMODULE hNet = LoadLibrary(TEXT("WININET.DLL"));
    if (hNet!=NULL)
    {
	    canProc = (CANPROC)GetProcAddress(hNet,CANONFUNCTION);
        if (canProc!=NULL)
        {
            BOOL f = canProc(szName,szOutput,&cbOutputLen,0);
        }
        FreeLibrary(hNet);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OpenBrowserURL
// Opens a URL in the default browser
////////////////////////////////////////////////////////////////////////////////////////////
void OpenBrowserURL(TCHAR* szURL)
{
    ShellExecute(NULL,_TEXT("open"),szURL,NULL,_TEXT(""),SW_NORMAL);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ProgressDlgProc
// Main proc for download progress dialog
// bugbug: Put in own file
////////////////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fReturnVal = TRUE;
    static HWND hwndAnimate = NULL;
    static HANDLE hLogo = NULL;
    static LPCDOPT pOpts = NULL;
    static fOneDownloaded = FALSE;
    static LPCDPROVIDER pCurrent = NULL;
		
    switch (msg) 
    { 
    	default:
			fReturnVal = FALSE;
		break;
		
        case WM_INITDIALOG:
        {
            fOneDownloaded = FALSE;
            BOOL fSingle = FALSE;
            DWORD dwDiscID = (DWORD)-1; //use batch

            if (lParam == 0)
            {
                if (!pSingleTitle)
                {
                    EndDialog(hDlg,-1);
                    return FALSE;
                }

                fSingle = TRUE;
                dwDiscID = pSingleTitle->dwTitleID;
                lParam = 1;
            }

            if (IsDownloading())
            {
                //if we're downloading on the Main UI, put up a "waiting" message for now
                TCHAR szWaiting[MAX_PATH];
                LoadString(hInst,IDS_WAITINGFORDOWNLOAD,szWaiting,sizeof(szWaiting)/sizeof(TCHAR));
                SendDlgItemMessage(hDlg,IDC_STATIC_INFO,WM_SETTEXT,0,(LPARAM)szWaiting);
            }

            //set the range
        	SendDlgItemMessage(hDlg, IDC_METER, PBM_SETRANGE, 0, MAKELPARAM(0, lParam));
            SendDlgItemMessage(hDlg, IDC_METER, PBM_SETPOS, 0, 0);

            //proceed with the download
            MMNET mmNet;
            mmNet.discid = dwDiscID;
            mmNet.hwndCallback = hDlg; //call back to this guy
            mmNet.fForceNet = fSingle;
            mmNet.pData = (void*)GetCDData();
            if (fSingle)
            {
                mmNet.pData2 = (void*)pSingleTitle;
            }
            else
            {
                mmNet.pData2 = NULL;
            }
            SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);

            pOpts = GetCDOpt();
            
            if (!hLogo)
            {
                //get the path to the vendor logo file
                if (pOpts)
                {
                    LPCDOPTIONS pOptions = NULL;
                    pOptions = pOpts->GetCDOpts();

                    if (pOptions)
                    {
                        if (pOptions->pCurrentProvider!=NULL)
                        {
                            hLogo = OpenDIB(pOptions->pCurrentProvider->szProviderLogo,(HFILE)-1);
                            pCurrent = pOptions->pCurrentProvider;
                        } //end if current provider ok
                    } //end if poptions ok
                } //end if popts created
            }

            fReturnVal = TRUE; 
        }		
		break;

        case WM_PAINT :
        {
	        HDC hdc;
	        PAINTSTRUCT ps;

	        hdc = BeginPaint( hDlg, &ps );
    
            RECT progressrect, mainrect;
            GetWindowRect(GetDlgItem(hDlg,IDC_METER),&progressrect);
            GetWindowRect(hDlg,&mainrect);
            mainrect.top = mainrect.top + GetSystemMetrics(SM_CYCAPTION);

            //turn on animation if it is not visible
            if (!hwndAnimate)
            {
                hwndAnimate = Animate_Create(hDlg,
                                            IDI_ICON_ANI_DOWN,
                                            WS_CHILD|ACS_TRANSPARENT,
                                            hInst);

                //headers don't have Animate_OpenEx yet,
                //so just do the straight call
                SendMessage(hwndAnimate,ACM_OPEN,(WPARAM)hInst,
                        (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_DOWN));

                //move to the top/left of the window, equidistant from top and progress indicator
                RECT anirect;
                GetWindowRect(hwndAnimate,&anirect);
                MoveWindow(hwndAnimate,
                     progressrect.left - mainrect.left - 3,
                     ((progressrect.top - mainrect.top)
                        - (anirect.bottom - anirect.top)) - LOGO_Y_OFFSET,
                     anirect.right - anirect.left,
                     anirect.bottom - anirect.top,
                     FALSE);

                Animate_Play(hwndAnimate,0,-1,-1);
                ShowWindow(hwndAnimate,SW_SHOW);

                //move "info" window                
                MoveWindow(GetDlgItem(hDlg,IDC_STATIC_INFO),
                          (progressrect.left - mainrect.left) + (anirect.right - anirect.left) + 3,
                          ((progressrect.top - mainrect.top)
                                - (anirect.bottom - anirect.top)) - LOGO_Y_OFFSET,
                          ((progressrect.right - mainrect.left) - VENDORLOGO_WIDTH - 3)
                                - ((progressrect.left - mainrect.left) + (anirect.right - anirect.left) + 3),
                          anirect.bottom - anirect.top,
                          FALSE);
            }

            if (hLogo)
            {
                DibBlt(hdc,
                        (progressrect.right - mainrect.left) - (VENDORLOGO_WIDTH + 5),
                        ((progressrect.top - mainrect.top)
                            - VENDORLOGO_HEIGHT) - LOGO_Y_OFFSET,
                        -1, 
                        -1, 
                        hLogo,
                        0,0,
                        SRCCOPY,0);
            }

	        EndPaint(hDlg,&ps);
            return 0;
        }
        break;

        //try to launch provider home page
        case WM_LBUTTONUP :
        {
            if ((hLogo) && (pCurrent))
            {
                RECT progressrect, mainrect;
                GetWindowRect(GetDlgItem(hDlg,IDC_METER),&progressrect);
                GetWindowRect(hDlg,&mainrect);
                mainrect.top = mainrect.top + GetSystemMetrics(SM_CYCAPTION);

                RECT logoRect;
                SetRect(&logoRect,
                        (progressrect.right - mainrect.left) - VENDORLOGO_WIDTH,
                        ((progressrect.top - mainrect.top)
                            - VENDORLOGO_HEIGHT) - LOGO_Y_OFFSET,
                        (progressrect.right - mainrect.left),
                        (progressrect.top - mainrect.top) - LOGO_Y_OFFSET);

                POINT pt;
                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam);
        
                if (PtInRect(&logoRect,pt))
                {
                    OpenBrowserURL(pCurrent->szProviderHome);
                }
            }
        }
        break;

        case WM_DESTROY :
        {
            if (hwndAnimate)
            {
                DestroyWindow(hwndAnimate);
                hwndAnimate = NULL;
            }

            if (hLogo)
            {
                GlobalFree(hLogo);
                hLogo = NULL;
            }
        }
        break;

        case WM_NET_DB_UPDATE_BATCH :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DownLoadCompletion(0,NULL);
            }
        }
        break;

        case WM_NET_DB_UPDATE_DISC :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DiscChanged((LPCDUNIT)lParam);
            }
        }
        break;

        case WM_NET_CHANGEPROVIDER :
        {
            LPCDPROVIDER pProv = (LPCDPROVIDER)lParam;
            if (pProv!=NULL)
            {
                pCurrent = pProv;

                if (hLogo)
                {
                    GlobalFree(hLogo);
                    hLogo = NULL;
                }

                hLogo = OpenDIB(pCurrent->szProviderLogo,(HFILE)-1);
                InvalidateRect(hDlg,NULL,FALSE);
                UpdateWindow(hDlg);
            } //end if provider ok
        }
        break;

        case WM_NET_STATUS :
        {
            //until at least one title is downloaded, we need to do
            //something to entertain the user, so go ahead and show the
            //downloading text
            if (!fOneDownloaded)
            {
                TCHAR progstr[MAX_PATH];
                LoadString((HINSTANCE)wParam,(UINT)lParam,progstr,sizeof(progstr)/sizeof(TCHAR));
                SendDlgItemMessage(hDlg,IDC_STATIC_INFO,WM_SETTEXT,0,(LPARAM)progstr);
            }
        }
        break;

        case WM_NET_DONE :
        {
            fOneDownloaded = TRUE;

            if (lParam == (LPARAM)-1)
            {
                HandleBadServiceProvider(hDlg);
                EndDialog(hDlg,0);
                break;
            }

            if (lParam == 0)
            {
                EndDialog(hDlg,0);
                break;
            }
            else
            {
                MMNET mmNet;
                mmNet.discid = (DWORD)lParam;
                mmNet.hwndCallback = hDlg;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);

                LPCDDATA pData = GetCDData();
                                
                //try to display that we found a title
                if (!pData)
                {
                    break;
                }
                
                //
                // Try to read in title from the options database
                //

                if (!pData->QueryTitle((DWORD)(lParam)))
                {
                    break;
                }

                //
                // We found an entry for this disc, so copy all the information
                // from the title database

                LPCDTITLE pCDTitle = NULL;

                if (FAILED(pData->LockTitle(&pCDTitle,(DWORD)(lParam))))
                {
                    break;
                }

                TCHAR foundstr[MAX_PATH];
                TCHAR formatstr[MAX_PATH];
                LoadString(hInst,IDS_FOUND,formatstr,sizeof(formatstr)/sizeof(TCHAR));
                wsprintf(foundstr,formatstr,pCDTitle->szTitle,pCDTitle->szArtist);
                SendDlgItemMessage(hDlg,IDC_STATIC_INFO,WM_SETTEXT,0,(LPARAM)foundstr);
            }
        }
        break;

        case WM_NET_INCMETER :
        {
            LRESULT dwPos = SendDlgItemMessage(hDlg,IDC_METER,PBM_GETPOS,0,0);
            SendDlgItemMessage(hDlg, IDC_METER, PBM_SETPOS, (WPARAM)++dwPos, 0);
        }
        break;

        case WM_NET_DB_FAILURE :
        {
            TCHAR szDBError[MAX_PATH];
            LoadString(hInst,IDS_DB_FAILURE,szDBError,sizeof(szDBError)/sizeof(TCHAR));
            MessageBox(hDlg,szDBError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_NET_NET_FAILURE :
        {
            TCHAR szNetError[MAX_PATH];
            LoadString(hInst,IDS_NET_FAILURE,szNetError,sizeof(szNetError)/sizeof(TCHAR));
            MessageBox(hDlg,szNetError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_COMMAND :
        {
            if (LOWORD(wParam) == IDCANCEL)
            {
                CancelDownload();
                EndDialog(hDlg,-1);
            }
        }
    }

    return fReturnVal;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleDiscsNotFound
// Ask the user if they want to nuke unfound batched titles, or save them for another time
////////////////////////////////////////////////////////////////////////////////////////////
void HandleDiscsNotFound(HWND hwndParent)
{
    DWORD dwNumNotFound =  GetNumBatchedTitles();

    if (dwNumNotFound == 0)
    {
        return;
    }

    TCHAR szNotFound[MAX_PATH];

    if (dwNumNotFound > 1)
    {
        TCHAR szFormat[MAX_PATH];
        LoadString(hInst,IDS_NOTFOUND,szFormat,sizeof(szFormat)/sizeof(TCHAR));

        wsprintf(szNotFound,szFormat,dwNumNotFound);
    }
    else
    {
        LoadString(hInst,IDS_NOTFOUND1,szNotFound,sizeof(szNotFound)/sizeof(TCHAR));
    }

    int nAnswer = MessageBox(hwndParent,szNotFound,szAppName,MB_YESNO|MB_ICONQUESTION);

    if (nAnswer == IDNO)
    {
        LPCDDATA pData = GetCDData();
        if (pData)
        {
            pData->DumpBatch();
        }
    } //if said "no" to keeping batch
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OptionsDownloadCallback
// Called from the options dialog to do batches or single downloads
////////////////////////////////////////////////////////////////////////////////////////////
DWORD CALLBACK OptionsDownloadCallback(LPCDTITLE pTitle, LPARAM lParam, HWND hwndParent)
{
    if (pTitle == NULL)
    {
        DWORD dwNumBatched = GetNumBatchedTitles();

        if (dwNumBatched > 0)
        {
            DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_DOWNLOADPROGRESS),
                           hwndParent,ProgressDlgProc,dwNumBatched);
        }

        HandleDiscsNotFound(hwndParent);

        //refresh the number of batched titles
        return GetNumBatchedTitles();
    }
    else
    {
        pSingleTitle = pTitle;
        INT_PTR status = DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_DOWNLOADPROGRESS),
                       hwndParent,ProgressDlgProc,0);

        //update the UI
        LPCDOPT pOpts = GetCDOpt();
        if (pOpts)
        {
            LPCDUNIT pUnit = pOpts->GetCDOpts()->pCDUnitList;

            while (pUnit!=NULL)
            {
                if (pUnit->dwTitleID == pSingleTitle->dwTitleID)
                {
                    pUnit->fDownLoading = FALSE;
                    pOpts->DiscChanged(pUnit);
                    break;
                }
                pUnit = pUnit->pNext;
            }
        }

        //if download wasn't canceled, check for disc id in database
        if (status != -1)
        {
            LPCDDATA pData = GetCDData();
            if (!pData->QueryTitle(pSingleTitle->dwTitleID))
            {
                TCHAR szNotFound[MAX_PATH];
                LoadString(hInst,IDS_TITLE_NOT_FOUND,szNotFound,sizeof(szNotFound)/sizeof(TCHAR));
                MessageBox(hwndParent,szNotFound,szAppName,MB_ICONINFORMATION|MB_OK);
            }
            else
            {
                if (pOpts)
                {
                    LPCDOPTIONS pCDOpts = pOpts->GetCDOpts();
                    pCDOpts->dwBatchedTitles = GetNumBatchedTitles();
                    pOpts->DownLoadCompletion(1,&(pSingleTitle->dwTitleID));
                } //end if OK to update batch number
            }
        }

        return 0;
    }
    
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OptionsApply
// Called from the options dialog when appy is hit, or by main UI when OK is hit
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK OptionsApply(LPCDOPTIONS pCDOpts)
{
    if (!pCDOpts)
    {
        return;
    }
    
    //tell the CD player to rescan its settings ... 
    //most of the settings are for it
	IMMComponentAutomation* pAuto = NULL;
	HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	if ((SUCCEEDED(hr)) && (pAuto != NULL))
	{
		pAuto->OnAction(MMACTION_READSETTINGS,pCDOpts->pCDData);
        pAuto->Release();
    }

    LPCDUNIT pUnit = pCDOpts->pCDUnitList;
    LPCDDATA pData = GetCDData();

    while (pUnit!=NULL)
    {
        BOOL fRemove = FALSE;
        if (pData)
        {
            fRemove = !(pData->QueryTitle(pUnit->dwTitleID));
        }

        if ((pUnit->fChanged) || (fRemove))
        {
            if ((pUnit->dwTitleID != 0) && (pUnit->dwTitleID != (DWORD)-1))
            {
                //tell the cd player that a title was updated, perhaps the ones in the drive
                MMNET mmNet;
                mmNet.discid = pUnit->dwTitleID;
                mmNet.hwndCallback = hwndMain;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);
            }
        }
        pUnit = pUnit->pNext;
    }

    SetWindowPos(hwndMain,
                 pCDOpts->pCDData->fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,
                 0,0,0,0,
                 SWP_NOMOVE|SWP_NOSIZE);

    //may have changed cd volume line
    if (InitCDVol(hwndMain, pCDOpts))
    {
        //when the volume line changes, we need to update the knob
        DWORD dwVol = GetVolume();
        CKnob* pKnob = GetKnobFromID(hwndMain,IDB_VOLUME);
        if (pKnob!=NULL)
        {
            pKnob->SetPosition(dwVol,TRUE);
        }

        SendMessage(GetDlgItem(hwndMain,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
        SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
    } //if vol line changed

    //may have turned on/off shell mode
    //we only care if the main UI is visible (i.e. not in shell-only mode)
    if (IsWindowVisible(hwndMain))
    {
        if (fShellMode != pCDOpts->pCDData->fTrayEnabled)
        {
            fShellMode = pCDOpts->pCDData->fTrayEnabled;
            if (fShellMode)
            {
                CreateShellIcon(hInst,hwndMain,pNodeCurrent,szAppName);
            }
            else
            {
                DestroyShellIcon();
            } //end shellmode
        } //end if shellmode changed in options
    } //end main ui visible
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleMixerControlChange
// Updates UI when sndvol32 or other apps change our mixerline
////////////////////////////////////////////////////////////////////////////////////////////
void HandleMixerControlChange(DWORD dwLineID)
{
    if (dwLineID == mixerlinedetails.dwControlID)
    {
        DWORD dwVol = GetVolume();
	    CKnob* pKnob = GetKnobFromID(hwndMain,IDB_VOLUME);
        //possible to get this change before knob is up
        if (pKnob!=NULL)
        {
            pKnob->SetPosition(dwVol,TRUE);
        }
    }

    if (dwLineID == mutelinedetails.dwControlID)
    {
        SendMessage(GetDlgItem(hwndMain,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
        SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ChildPaletteProc
// Updates child windows when palette changes
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ChildPaletteProc(HWND hwnd, LPARAM lParam)
{
    InvalidateRect(hwnd,NULL,FALSE);
    UpdateWindow(hwnd);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandlePaletteChange
// Updates window when palette changes
////////////////////////////////////////////////////////////////////////////////////////////
int HandlePaletteChange()
{
    HDC hdc = GetDC(hwndMain);
    HPALETTE hOldPal = SelectPalette(hdc,hpalMain,FALSE);
    UINT i = RealizePalette(hdc);
    if (i)
    {
        //update child windows "by hand", since they are clipped
        EnumChildWindows(hwndMain,ChildPaletteProc,0);

        //update main window
        InvalidateRect(hwndMain,NULL,FALSE);
        UpdateWindow(hwndMain);
    }
    SelectPalette(hdc,hOldPal,TRUE);
    RealizePalette(hdc);
    ReleaseDC(hwndMain,hdc);
    return i;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleDisplayChange
// Figures out if we need to recalc all bitmaps and does so ...
////////////////////////////////////////////////////////////////////////////////////////////
void HandleDisplayChange()
{
    int nOrgColorMode = g_nColorMode;

    DetermineColorMode();

    //only do anythhing if they changed modes
    if (g_nColorMode != nOrgColorMode)
    {
        //nuke all child windows
        for (int i = 0; i < NUM_BUTTONS; i++)
        {
            DestroyWindow(GetDlgItem(hwndMain,biButtons[i].id));
        }

        DestroyWindow(GetDlgItem(hwndMain,IDB_MUTE));
        DestroyWindow(GetDlgItem(hwndMain,IDB_VOLUME));
	    UninitMButtons();

        //nuke the bitmaps
	    GlobalFree(hbmpMain);
	    GlobalFree(hbmpMainRestore);
        GlobalFree(hbmpMainSmall);
        GlobalFree(hbmpMainNoBar);
	    DeleteObject(hpalMain);

    	hpalMain = SetPalette();

        //rebuild the bitmaps
        BuildFrameworkBitmaps();

        //recreate the windows
	    CreateButtonWindows(hwndMain);
	    CreateVolumeKnob(hwndMain);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DoPaint
// Handles the WM_PAINT for the main UI, actually a multimon paint callback
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK DoPaint(HMONITOR hmonitor, HDC hdc, LPRECT lprcMonitor, LPARAM lData)
{
	HWND hwnd = (HWND)lData;

    HPALETTE hpalOld = SelectPalette(hdc, hpalMain, FALSE);
	RealizePalette(hdc);

	BOOL fActiveWindow = FALSE;
    if (hwnd == GetForegroundWindow())
    {
	    fActiveWindow = TRUE;
    }

	DrawTitleBar(hdc, hwnd, fActiveWindow, TRUE);

    HANDLE hbmpView;
    BITMAP* pBM = &bmMain;
    switch (g_nViewMode)
    {
        case VIEW_MODE_NORMAL  :
        {
            hbmpView = hbmpMain; 
        }
        break;
    
        case VIEW_MODE_RESTORE :
        {
            hbmpView = hbmpMainRestore; 
            pBM = &bmMainRestore;
        }
        break;

        case VIEW_MODE_SMALL :
        {
            hbmpView = hbmpMainSmall;
            pBM = &bmMainSmall;
        }
        break;

        case VIEW_MODE_NOBAR :
        {
            hbmpView = hbmpMainNoBar;
            pBM = &bmMainNoBar;
        }
        break;
    }

    DibBlt(hdc,
        0,
        0,
        -1, 
        -1, 
        hbmpView,
        0,0,
        SRCCOPY,0);

    //reset the clipping region that was set in DrawTitleBar for reverse paint
    RECT rcParent;
    GetClientRect( hwnd, &rcParent );
    
    HRGN region = CreateRectRgn(rcParent.left,rcParent.top,rcParent.right,rcParent.bottom);

    SelectClipRgn(hdc, region);
    DeleteObject(region);

	SelectPalette(hdc, hpalOld, TRUE);
	RealizePalette(hdc);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetPlayButtonState
// Handles the play button's icon
////////////////////////////////////////////////////////////////////////////////////////////
void SetPlayButtonState(BOOL fIntroMode)
{
    CMButton* pButton = GetMButtonFromID(hwndMain,IDB_PLAY);

    if (pButton)
    {
        if ((fPlaying) && (fIntroMode))
        {
            pButton->SetIcon(IDI_MODE_INTRO);
            pButton->SetToolTipID(IDB_TT_INTRO);
        }

        if ((fPlaying) && (fIntro) && (!fIntroMode))
        {
            pButton->SetIcon(IDI_ICON_PAUSE);
            pButton->SetToolTipID(IDB_TT_PAUSE);
        }
    }

    fIntro = fIntroMode;

    //need to save playback mode at this point
    LPCDOPT pOpt = GetCDOpt();

    if(pOpt)
    {
        LPCDOPTIONS pOptions = pOpt->GetCDOpts();
        LPCDOPTDATA pOptionData = pOptions->pCDData;
        pOptionData->dwPlayMode = nCDMode;
        pOpt->UpdateRegistry();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetSearchURL
// Returns the standard IE "autosearch" URL
////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetSearchURL(TCHAR* szSearchURL)
{
    BOOL fRet = FALSE;
    HKEY hKeySearch = NULL;

	long lResult = ::RegOpenKeyEx( HKEY_CURRENT_USER,
							  REG_KEY_SEARCHURL,
							  0, KEY_READ, &hKeySearch );

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwCbData = MAX_PATH;
        DWORD dwType = REG_SZ;
        lResult  = ::RegQueryValueEx( hKeySearch, TEXT(""), NULL,
						          &dwType, (LPBYTE)szSearchURL, &dwCbData );

        if (lResult == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        if ((_tcslen(szSearchURL) < 1) || (lResult != ERROR_SUCCESS))
        {
            _tcscpy(szSearchURL,TEXT("http://home.microsoft.com/access/autosearch.asp?p=%s"));
            fRet = TRUE;
        }

        RegCloseKey(hKeySearch);
    }

    return (fRet);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleCommand
// Handles all WM_COMMAND message for the main app
////////////////////////////////////////////////////////////////////////////////////////////
void HandleCommand(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    //handle system commands
    if ((LOWORD(wParam) >= SC_SIZE) && (LOWORD(wParam) <= SC_CONTEXTHELP))
    {
        SendMessage(hwnd,WM_SYSCOMMAND,(WPARAM)LOWORD(wParam),0);
        return;
    }

	switch (LOWORD(wParam))
	{
		case IDM_EXIT :
		{
            //if the shell icon is showing, then closing the app means hiding it
		    if (fShellMode)
            {
                ShowWindow(hwnd,SW_HIDE);
            }
            else
            {
                SendMessage(hwnd, WM_CLOSE, 0, 0);
            }
		    return;
		} //end exit
        break;

        case IDM_EXIT_SHELL :
        {
            //if the shell icon wanted us to shut down, but the main ui is visible, just
            //nuke shell mode
            if (IsWindowVisible(hwnd))
            {
                DestroyShellIcon();
                fShellMode = FALSE;
            }
            else
            {
                SendMessage(hwnd, WM_CLOSE, 0, 0);
            }
            return;
        }
        break;
	}

	IMMComponentAutomation* pAuto = NULL;
	HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	if ((SUCCEEDED(hr)) && (pAuto != NULL))
	{
        if ((LOWORD(wParam) >= IDM_TRACKLIST_BASE) && (LOWORD(wParam) < IDM_TRACKLIST_SHELL_BASE))
        {
            MMCHANGETRACK mmTrack;
            mmTrack.nNewTrack = LOWORD(wParam) - IDM_TRACKLIST_BASE;
            pAuto->OnAction(MMACTION_SETTRACK,&mmTrack);
        }

        if ((LOWORD(wParam) >= IDM_TRACKLIST_SHELL_BASE) && (LOWORD(wParam) < IDM_DISCLIST_BASE))
        {
            MMCHANGETRACK mmTrack;
            mmTrack.nNewTrack = LOWORD(wParam) - IDM_TRACKLIST_SHELL_BASE;
            pAuto->OnAction(MMACTION_SETTRACK,&mmTrack);

            //play it if we're not playing
            if (!fPlaying)
            {
                pAuto->OnAction(MMACTION_PLAY,NULL);
            }
        }

        if ((LOWORD(wParam) >= IDM_DISCLIST_BASE) && (LOWORD(wParam) < IDM_NET_UPDATE))
        {
            MMCHANGEDISC mmDisc;
            mmDisc.nNewDisc = LOWORD(wParam) - IDM_DISCLIST_BASE;
            pAuto->OnAction(MMACTION_SETDISC,&mmDisc);
        }

        if ((LOWORD(wParam) >= IDM_HOMEMENU_BASE) && (LOWORD(wParam) < IDM_NETMENU_BASE))
        {
            int i = LOWORD(wParam) - IDM_HOMEMENU_BASE;

            LPCDOPT pOpt = GetCDOpt();
            if( pOpt )
            {
                LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

                LPCDPROVIDER pProviderList = pCDOpts->pProviderList;

                for (int x = 0; x < i; x++)
                {
                    pProviderList = pProviderList->pNext;
                }

                OpenBrowserURL(pProviderList->szProviderHome);
            }
        }

        if ((LOWORD(wParam) >= IDM_NETMENU_BASE) && (LOWORD(wParam) < IDM_OPTIONS))
        {
            MMMEDIAID mmMedia;
            mmMedia.nDrive = -1;
	        pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
            LPCDDATA pData = GetCDData();

            if (!pData)
            {
                return;
            }

            if (!pData->QueryTitle(mmMedia.dwMediaID))
            {
                return;
            }

            LPCDTITLE pCDTitle = NULL;
            hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

            if (FAILED(hr))
            {
                return;
            }

            LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[LOWORD(wParam)-IDM_NETMENU_BASE]);

            if (pCDMenu->szMenuQuery)
            {
                OpenBrowserURL(pCDMenu->szMenuQuery);
            }

            pData->UnlockTitle(pCDTitle,FALSE);
        }

        switch (LOWORD(wParam))
        {
            case IDM_NET_UPDATE :
            {
                MMNET mmNet;
                mmNet.discid = 0; //use current disc
                mmNet.hwndCallback = hwnd;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);
            }
            break;

            case IDM_NET_CANCEL :
            {
                CancelDownload();
            }
            break;

            case IDM_NET_ROLLINGSTONE_ARTIST :
            case IDM_NET_BILLBOARD_ALBUM :
            case IDM_NET_BILLBOARD_ARTIST :
            {            
	            MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
                TCHAR szQuery[MAX_PATH*4];

                LPCDDATA pData = GetCDData();

                if (!pData)
                {
	                break;
                }

                if (!pData->QueryTitle(mmMedia.dwMediaID))
                {
                    return;
                }

                LPCDTITLE pCDTitle = NULL;
                hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (FAILED(hr))
                {
                    break;
                }

                //normalize (canonize) the title and artist names
                TCHAR szArtist[CDSTR*3];
                TCHAR szTitle[CDSTR*3];
                NormalizeNameForURL(pCDTitle->szArtist,szArtist,sizeof(szArtist));
                NormalizeNameForURL(pCDTitle->szTitle,szTitle,sizeof(szTitle));

                pData->UnlockTitle(pCDTitle,FALSE);

                if ((LOWORD(wParam) == IDM_NET_BILLBOARD_ARTIST))
                {
                    TCHAR szFormat[MAX_PATH];
                    LoadString(hInst,IDS_BILLBOARD_FORMAT_ARTIST,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                    wsprintf(szQuery,szFormat,szArtist);
                }
                else if ((LOWORD(wParam) == IDM_NET_ROLLINGSTONE_ARTIST))
                {
                    TCHAR szFormat[MAX_PATH];
                    LoadString(hInst,IDS_ROLLINGSTONE_FORMAT_ARTIST,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                    wsprintf(szQuery,szFormat,szArtist);
                }
                else
                {
                    TCHAR szFormat[MAX_PATH];
                    LoadString(hInst,IDS_BILLBOARD_FORMAT_ALBUM,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                    wsprintf(szQuery,szFormat,szArtist,szTitle);
                }

                OpenBrowserURL(szQuery);
            }
            break;

            case IDM_NET_CD :
            {
	            MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
                TCHAR szQuery[MAX_PATH*4];

                LPCDDATA pData = GetCDData();

                if (!pData)
                {
	                break;
                }

                if (!pData->QueryTitle(mmMedia.dwMediaID))
                {
                    return;
                }

                LPCDTITLE pCDTitle = NULL;
                hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (FAILED(hr))
                {
                    break;
                }

                TCHAR szSearchURL[MAX_PATH];
                if (!GetSearchURL(szSearchURL))
                {
                    break;
                }

                TCHAR szTemp[MAX_PATH*2];
                TCHAR szTemp2[MAX_PATH*2];

                wsprintf(szTemp,TEXT("%s %s"),pCDTitle->szArtist,pCDTitle->szTitle);
                NormalizeNameForURL(szTemp,szTemp2,sizeof(szTemp2));
                wsprintf(szQuery,szSearchURL,szTemp2);

                pData->UnlockTitle(pCDTitle,FALSE);

                OpenBrowserURL(szQuery);
            }
            break;

            case IDM_NET_BAND :
            {
	            MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
                TCHAR szQuery[MAX_PATH*3];

                LPCDDATA pData = GetCDData();

                if (!pData)
                {
	                break;
                }

                if (!pData->QueryTitle(mmMedia.dwMediaID))
                {
                    return;
                }

                LPCDTITLE pCDTitle = NULL;
                hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (FAILED(hr))
                {
                    break;
                }

                TCHAR szSearchURL[MAX_PATH];
                if (!GetSearchURL(szSearchURL))
                {
                    break;
                }

                TCHAR szArtist[CDSTR*3];
                NormalizeNameForURL(pCDTitle->szArtist,szArtist,sizeof(szArtist));

                wsprintf(szQuery,szSearchURL,szArtist);

                pData->UnlockTitle(pCDTitle,FALSE);

                OpenBrowserURL(szQuery);
            }
            break;

            case IDM_MODE_NORMAL :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_NORMAL,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_NORMAL);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_REPEATONE :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_REPEAT_SINGLE,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_REPEATONE);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_REPEATALL :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_CONTINUOUS,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_REPEATALL);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_RANDOM :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_RANDOM,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
    	            pButton->SetIcon(IDI_MODE_RANDOM);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_INTRO :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_INTRO,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_INTRO);
                }
                SetPlayButtonState(TRUE);
            }
            break;

            case IDM_HELP :
            {
                char chDst[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, HELPFILENAME, 
									            -1, chDst, MAX_PATH, NULL, NULL); 
	            HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
            }
            break;

            case IDM_ABOUT :
            {
                ShellAbout( hwnd, szAppName, TEXT(""), LoadIcon(hInst, MAKEINTRESOURCE(IDI_MMFW)));
            }
            break;

            case IDM_NORMAL :
            {
                SetNormalMode(hwnd);
            }
            break;

            case IDM_TINY :
            {
                SetRestoredMode(hwnd);
            }
            break;

            case IDB_MUTE :
            {
                //fix for bug 220 ... if mute button is set from "SetMute" during a button
                //click, it will get ANOTHER button click when it's focus is killed, so we
                //need to make sure it stays in the right state at the right time
                if (GetFocus()==GetDlgItem(hwndMain,IDB_MUTE))
                {
                    SetMute();
                }
                else
                {
                    SendMessage(GetDlgItem(hwndMain,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
                }
            }
            break;

            case IDM_PLAYLIST :         
            case IDM_OPTIONS :
            {
                CDOPT_PAGE  nStartSheet = CDOPT_PAGE_PLAY;

                if (LOWORD(wParam) == IDM_PLAYLIST)
                {
                    nStartSheet = CDOPT_PAGE_PLAYLIST;
                }

                LPCDOPT pOpt = GetCDOpt();
                if( pOpt )
                {
                    LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

                    LPCDDATA pData = GetCDData();

                    if( pData )
                    {
                        //go through and set media ids for each drive
                        LPCDUNIT pUnit = pCDOpts->pCDUnitList;
                        int nCurrDrive = 0;
    
                        while (pUnit!=NULL)
                        {
			                MMMEDIAID mmMedia;
                            mmMedia.nDrive = nCurrDrive;
			                pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

                            MMNETQUERY mmNetQuery;
                            mmNetQuery.nDrive = nCurrDrive++;
                            mmNetQuery.szNetQuery = pUnit->szNetQuery;
                            pAuto->OnAction(MMACTION_GETNETQUERY,&mmNetQuery);

                            pUnit->dwTitleID = mmMedia.dwMediaID;
                            pUnit->dwNumTracks = mmMedia.dwNumTracks;
                            if (IsDownloading())
                            {
                                pUnit->fDownLoading = TRUE;
                            }
                            else
                            {
                                pUnit->fDownLoading = FALSE;
                            }
                            pUnit = pUnit->pNext;
                        }

                        //set the number of batched titles and the callback functions
                        pCDOpts->dwBatchedTitles = GetNumBatchedTitles();
                        pCDOpts->pfnDownloadTitle = OptionsDownloadCallback;
                        pCDOpts->pfnOptionsCallback = OptionsApply;

                        fOptionsDlgUp = TRUE;
                        HRESULT hr = pOpt->OptionsDialog(hwnd, pData, nStartSheet);
                        fOptionsDlgUp = FALSE;

                        if (hr == S_OK) //don't use succeeded macro here, S_FALSE is also valid
                        {
                            OptionsApply(pCDOpts);
                        }
                    } //if pdata
                }
            }
            break;

            case IDB_PLAY :
            {
	            if (fPlaying)
	            {
                    if (fIntro)
                    {
                        //set to normal mode
                        SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDM_MODE_NORMAL,0),0);
                        //set button back to regular icon
                        CMButton* pButton = GetMButtonFromID(hwnd,IDB_PLAY);
                        if (pButton)
                        {
                            pButton->SetIcon(IDI_ICON_PAUSE);
                            pButton->SetToolTipID(IDB_TT_PAUSE);
                        }
                    }
                    else
                    {
		                pAuto->OnAction(MMACTION_PAUSE,NULL);
                    }
	            }
	            else
	            {
		            pAuto->OnAction(MMACTION_PLAY,NULL);
	            }
            }
            break;

            case IDB_EJECT :
            {
	            pAuto->OnAction(MMACTION_UNLOADMEDIA,NULL);
            }
            break;

            case IDB_FFWD :
            {
	            pAuto->OnAction(MMACTION_FFWD,NULL);
            }
            break;

            case IDB_NEXTTRACK :
            {
                pAuto->OnAction(MMACTION_NEXTTRACK,NULL);
            }
            break;

            case IDB_PREVTRACK :
            {
	            pAuto->OnAction(MMACTION_PREVTRACK,NULL);
            }
            break;

            case IDB_REW :
            {
	            pAuto->OnAction(MMACTION_REWIND,NULL);
            }
            break;

            case IDB_STOP :
            {
	            pAuto->OnAction(MMACTION_STOP,NULL);
            }
            break;

            case IDB_MINIMIZE :
            {
                ShowWindow(hwnd,SW_MINIMIZE);
                //see \\redrum\slmro\proj\win\src\CORE\user\mssyscmd.c
                PlaySound(TEXT("Minimize"),NULL,SND_ALIAS|SND_NODEFAULT|SND_ASYNC|SND_NOWAIT|SND_NOSTOP);
            }
            break;

            case IDB_SET_NORMAL_MODE :
            {
                SetNormalMode(hwnd);
            }
            break;

            case IDB_SET_TINY_MODE :
            {
                SetRestoredMode(hwnd);
            }
            break;

            case IDB_CLOSE :
            {
                //if the shell icon is showing, then closing the app means hiding it
		        if (fShellMode)
                {
                    ShowWindow(hwnd,SW_HIDE);
                }
                else
                {
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                }
            }
            break;
        }

        if (pAuto)
        {
            pAuto->Release();
	        pAuto = NULL;
        }
	}
}

////////////////////////
// Handles device change message from WinMM, All we need to do here is close any open
// Mixer Handles, re-compute mixer ID and control ID's and re-Open appropriately
//
void WinMMDeviceChangeHandler(HWND hWnd)
{
    LPCDOPT pOpt = GetCDOpt();

    if (hmix)                           // Close open mixer handle
    {
        mixerClose((HMIXER)hmix);
        hmix = NULL;
    }

    if(pOpt)
    {
        LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

        pOpt->MMDeviceChanged();

        InitCDVol(hwndMain,pCDOpts);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandlePowerBroadcast
// On VxD drivers, you can't "suspend" with an open mixer device.  Bug 1132.
//
// If lParam == 1, this is a device remove
//
////////////////////////////////////////////////////////////////////////////////////////////
BOOL HandlePowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;
    
    switch (wParam)
    {
        case PBT_APMQUERYSTANDBY:
	    case PBT_APMQUERYSUSPEND:
        {
            if (hmix)
	        {
    		    mixerClose((HMIXER)hmix);
                hmix = NULL;
	        }
        } //end case power off
	    break;

        case PBT_APMSTANDBY :
        case PBT_APMSUSPEND :
        {
            //actually suspending, go ahead and stop the cd
            if (fPlaying)
            {
	            IMMComponentAutomation* pAuto = NULL;
                if (pNodeCurrent)
                {
	                HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	                if ((SUCCEEDED(hr)) && (pAuto != NULL))
	                {
                        //at this point, we can actually stop the CD
                        pAuto->OnAction(MMACTION_STOP,NULL);        
                        //release the automation object        
                        pAuto->Release();
                    }
                } //end if pnodecurrent
            } //end if playing
        }
        break;

	    case PBT_APMQUERYSTANDBYFAILED:
        case PBT_APMRESUMESTANDBY:
        case PBT_APMQUERYSUSPENDFAILED:
	    case PBT_APMRESUMESUSPEND:
        {
            WinMMDeviceChangeHandler(hWnd);
        } //end case power on
	    break;
    } //end switch

    return fRet;
}


////////////////////////////////////////////////////////////////////////////////////////////
// * HandleSysMenuInit
// Make sure the system menu only shows the correct choices
////////////////////////////////////////////////////////////////////////////////////////////
void HandleSysMenuInit(HWND hwnd, HMENU hmenu)
{
    //always gray out
    EnableMenuItem(hmenu,SC_SIZE,    MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenu,SC_MAXIMIZE,MF_BYCOMMAND|MF_GRAYED);

    //always enable
    EnableMenuItem(hmenu,SC_CLOSE,MF_BYCOMMAND|MF_ENABLED);

    //enable or gray based on minimize state
    if (IsIconic(hwnd))
    {
        EnableMenuItem(hmenu,SC_RESTORE, MF_BYCOMMAND|MF_ENABLED);
        EnableMenuItem(hmenu,SC_MOVE,    MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hmenu,SC_MINIMIZE,MF_BYCOMMAND|MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hmenu,SC_RESTORE, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hmenu,SC_MOVE,    MF_BYCOMMAND|MF_ENABLED);
        EnableMenuItem(hmenu,SC_MINIMIZE,MF_BYCOMMAND|MF_ENABLED);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SysMenuTimerProc
// Make sure the system menu only shows on a single click
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK SysMenuTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    KillTimer(hwnd,idEvent);

    POINTS pts;
    RECT rect;

    //make sure the menu shows up in a good-looking place
    GetClientRect(hwnd,&rect);
    rect.left = SYSMENU_XOFFSET;
    rect.right = SYSMENU_XOFFSET + SYSMENU_WIDTH;
    rect.bottom = rect.top + TITLEBAR_HEIGHT +
                    (g_nViewMode == VIEW_MODE_NORMAL ? TITLEBAR_YOFFSET_LARGE :
                                                       TITLEBAR_YOFFSET_SMALL);

    ClientToScreen(hwnd,(LPPOINT)&rect);
    ClientToScreen(hwnd,((LPPOINT)&rect)+1);
    pts.x = (short)rect.left;
    pts.y = (short)rect.bottom;

    HMENU hSysMenu = GetSystemMenu(hwnd,FALSE);

    TPMPARAMS tpm;
    tpm.cbSize = sizeof(tpm);
    memcpy(&(tpm.rcExclude),&rect,sizeof(RECT));
    TrackPopupMenuEx(hSysMenu,0,pts.x,pts.y,hwnd,&tpm);
}



BOOL HandleKeyboardAppCommand(HWND hwnd, short cmd)
{
    BOOL fHandled = FALSE;

    switch (cmd)
    {
        case APPCOMMAND_VOLUME_MUTE :
        {
            SetMute();
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_VOLUME_DOWN :
        {
            SendMessage(GetDlgItem(hwnd,IDB_VOLUME),WM_KEYDOWN,VK_DOWN,0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_VOLUME_UP :
        {
            SendMessage(GetDlgItem(hwnd,IDB_VOLUME),WM_KEYDOWN,VK_UP,0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_NEXTTRACK :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_NEXTTRACK,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_PREVIOUSTRACK :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_PREVTRACK,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_STOP :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_STOP,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_PLAY_PAUSE :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_PLAY,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        default:
        {
            fHandled = FALSE;
        }
        break;
    } //end switch

    return fHandled;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * MainWndProc
// Main window's message switcher
////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
	    //we're being created, start up
        case WM_CREATE :
	    {
            hwndMain = hwnd;

            g_uTaskbarRestart = RegisterWindowMessage(TEXT("TaskbarCreated"));
            giVolDevChange    = RegisterWindowMessage(TEXT("winmm_devicechange"));

            CreateToolTips(hwnd);
	        InitComponents(hwnd);
	        CreateButtonWindows(hwnd);
	        CreateVolumeKnob(hwnd);

            //if no disc in player, gray out the track button
	        IMMComponentAutomation* pAuto = NULL;
	        HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	        if ((SUCCEEDED(hr)) && (pAuto != NULL))
	        {
                MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
                pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                pAuto->Release();
                if (mmMedia.dwMediaID == 0)
                {
                    EnableWindow(GetDlgItem(hwnd,IDB_TRACK),FALSE);
                }
            }
	    }
        break;

        case SHELLMESSAGE_CDICON :
        {
            return (ShellIconHandeMessage(lParam));
        }
        break;

        //called from sndvol32 or other apps that change mixer
        case MM_MIXM_CONTROL_CHANGE :
        {
            HandleMixerControlChange((DWORD)lParam);
        }
        break;

        //palette changed
        case WM_PALETTECHANGED :
        case WM_QUERYNEWPALETTE :
	    {
            return (HandlePaletteChange());
	    }
	    break;

        //autoplay copied command line when second instance running
        case WM_COPYDATA :
        {
            SendMessage(hwndCurrentComp,WM_COPYDATA,wParam,lParam);
        }
        break;

        //new keyboard interface
        case WM_APPCOMMAND :
        {
            BOOL fHandled = HandleKeyboardAppCommand(hwnd,GET_APPCOMMAND_LPARAM(lParam));

            if (fHandled)
            {
                return fHandled;
            }
            
            //otherwise will go to defwindowproc
        }
        break;
	    
	    //activation/deactivation -- need to repaint title
        case WM_ACTIVATE :
        {
            HDC hdc = GetDC(hwnd);
            DrawTitleBar(hdc,hwnd,LOWORD(wParam),FALSE);
	        ReleaseDC(hwnd,hdc);
        }
        break;

        //check for switch to tiny mode
        case WM_NCLBUTTONDBLCLK :
        case WM_LBUTTONDBLCLK :
        {
            KillTimer(hwnd,SYSTIMERID);

            if (((int)wParam == HTSYSMENU) && (iMsg == WM_NCLBUTTONDBLCLK))
            {
                break; //don't allow this on a sys menu double-click
            }
            
            switch (g_nViewMode)
            {
                case VIEW_MODE_NORMAL  : SetNoBarMode(hwnd);    break;
                case VIEW_MODE_NOBAR   : SetNormalMode(hwnd);   break;
                case VIEW_MODE_RESTORE : SetSmallMode(hwnd);    break;
                case VIEW_MODE_SMALL   : SetRestoredMode(hwnd); break;
            } //end switch on view mode
        }
        break;

        //handle left click on system menu
        //need to set timer to handle double-click
        case WM_NCLBUTTONDOWN :
        {
            if ((int)wParam == HTSYSMENU)
            {
                SetTimer(hwnd,SYSTIMERID,GetDoubleClickTime()+100,(TIMERPROC)SysMenuTimerProc);
            }
        }
        break;

        //handle right click on system menu or caption
        //no need for timer on double-click
        case WM_NCRBUTTONDOWN :
        {
            if (((int)wParam == HTCAPTION) || ((int)wParam == HTSYSMENU))
            {
                POINTS pts = MAKEPOINTS(lParam);
                HMENU hSysMenu = GetSystemMenu(hwnd,FALSE);
                TrackPopupMenu(hSysMenu,0,pts.x,pts.y,0,hwnd,NULL);
            }
        }
        break;

        case WM_INITMENU :
        {
            HandleSysMenuInit(hwnd,(HMENU)wParam);
        }
        break;

        case WM_POWERBROADCAST:
        {
            return (HandlePowerBroadcast(hwnd,wParam,0));
        }
        break;

	    //check for mouse in title bar
        case WM_NCHITTEST :
        {
            return (OnNCHitTest(hwnd, LOWORD(lParam), HIWORD(lParam),FALSE));
        }
        break;

        case WM_NET_DB_UPDATE_BATCH :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DownLoadCompletion(0,NULL);
            }
        }
        break;

        case WM_NET_DB_UPDATE_DISC :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DiscChanged((LPCDUNIT)lParam);
            }
        }
        break;

        //download finished on a disc
        case WM_NET_INCMETER : //download finished on discid <lparam>
        {
            //lparam == -1 means the provider failed the validation check
            if (lParam == (LPARAM)-1)
            {
                SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_DOWNLOAD,0,(LPARAM)FALSE);
                HandleBadServiceProvider(hwnd);
                break;
            }

            if (lParam != 0) 
            {
                MMNET mmNet;
                mmNet.discid = (DWORD)(lParam);
                mmNet.hwndCallback = hwnd;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);

                LPCDOPT pOpt = GetCDOpt();
                if (pOpt)
                {
                    LPCDUNIT pUnit = pOpt->GetCDOpts()->pCDUnitList;
                    int nCurrDrive = 0;
                
                    while (pUnit!=NULL)
                    {
                        if (pUnit->dwTitleID == mmNet.discid)
                        {
                            pUnit->fDownLoading = FALSE;
                            break;
                        }
                        pUnit = pUnit->pNext;
                    }
                    
                    LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();
                    pCDOpts->dwBatchedTitles = GetNumBatchedTitles();

                    pOpt->DownLoadCompletion(1,&(mmNet.discid));
                }

                //put up a message box if the title still isn't available
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	            {
                    MMMEDIAID mmMedia;
                    mmMedia.nDrive = -1;
                    pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                    pAuto->Release();

                    if (mmNet.discid == mmMedia.dwMediaID)
                    {
                        LPCDDATA pData = GetCDData();
                        if (!pData->QueryTitle(mmNet.discid))
                        {
                            TCHAR szNotFound[MAX_PATH];
                            LoadString(hInst,IDS_TITLE_NOT_FOUND,szNotFound,sizeof(szNotFound)/sizeof(TCHAR));
                            MessageBox(hwnd,szNotFound,szAppName,MB_ICONINFORMATION|MB_OK);
                        }
                    } //end if disc is same as what is showing in player
                } //end if pauto ok
            }
        }
        break;

        case WM_NET_DB_FAILURE :
        {
            TCHAR szDBError[MAX_PATH];
            LoadString(hInst,IDS_DB_FAILURE,szDBError,sizeof(szDBError)/sizeof(TCHAR));
            MessageBox(hwnd,szDBError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_NET_NET_FAILURE :
        {
            TCHAR szNetError[MAX_PATH];
            LoadString(hInst,IDS_NET_FAILURE,szNetError,sizeof(szNetError)/sizeof(TCHAR));
            MessageBox(hwnd,szNetError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_NET_DONE :
        {
            if (lParam == 0)
            {
                //if lparam is 0, download is done ... nuke the animation
                SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_DOWNLOAD,0,(LPARAM)FALSE);
            }
        }
        break;

        //Network status callback
        case WM_NET_STATUS : //download information string in <lparam>
        {
            //we basically just ignore the string messages and start
            //the animation if one isn't going already
            SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_DOWNLOAD,0,(LPARAM)TRUE);
        }
        break;

        case WM_NET_CHANGEPROVIDER :
        {
            SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_NET_CHANGEPROVIDER,wParam,lParam);
        }
        break;

        //change the title bar contents
        case WM_SIZE :
        {
            if (wParam != SIZE_MINIMIZED)
            {
                TCHAR szText[MAX_PATH];
                _tcscpy(szText,szAppName);
                if (pNodeCurrent)
                {            
                    if (_tcslen(pNodeCurrent->szTitle) > 0)
                    {
                        wsprintf(szText,TEXT("%s - %s"),pNodeCurrent->szTitle,szAppName);
                    }
                }
            
                SetWindowText(hwnd,szText);
            }
        }
        break;

        //notification that the current disc drive is different
        case WM_DISCCHANGED :
        {
            LPCDOPT pOpt = GetCDOpt();
            if( pOpt )
            {
                LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();
                if (InitCDVol(hwnd,pCDOpts))
                {
                    DWORD dwVol = GetVolume();
                    CKnob* pKnob = GetKnobFromID(hwndMain,IDB_VOLUME);
                    if (pKnob!=NULL)
                    {
                        pKnob->SetPosition(dwVol,(BOOL)lParam);
                    }

                    SendMessage(GetDlgItem(hwnd,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
                    SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
                }
            } //end if popt

            //if no disc in player, gray out the track button
	        IMMComponentAutomation* pAuto = NULL;
	        HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	        if ((SUCCEEDED(hr)) && (pAuto != NULL))
	        {
                MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
                pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                pAuto->Release();
                if (mmMedia.dwMediaID == 0)
                {
                    EnableWindow(GetDlgItem(hwnd,IDB_TRACK),FALSE);
                }
            }
        }
        break;
    
	    case WM_SYSCOLORCHANGE :
        case WM_DISPLAYCHANGE :
        {
            //user may have turned on high-contrast mode,
            //or changed the display depth.  Either way,
            //it may be time to change bitmaps
            HandleDisplayChange();
        }
        break;
        
        case WM_ERASEBKGND :
        {
            EnumDisplayMonitors((HDC)wParam, NULL, DoPaint, (LPARAM)hwnd);
            return TRUE;
        }
        break;

        case WM_SETCURSOR :
        {
            if ((HWND)wParam == GetDlgItem(hwnd,IDB_MUTE))
            {
                if (hCursorMute)
                {
                    SetCursor(hCursorMute);
                    return TRUE;
                }
            }
        }
        break;

        case WM_HELP :
        {
            char chDst[MAX_PATH];
            WideCharToMultiByte(CP_ACP, 0, HELPFILENAME, 
								            -1, chDst, MAX_PATH, NULL, NULL); 
            HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
        }
        break;

        case WM_CLOSE :
        {
            if ((fShellMode) && IsWindowVisible(hwnd))
            {
                ShowWindow(hwnd,SW_HIDE);
                return 0;
            }
        }
        break;

        case WM_PAINT :
	    {
            //multi-mon paint
	        HDC hdc;
	        PAINTSTRUCT ps;
	        hdc = BeginPaint( hwnd, &ps );
            EnumDisplayMonitors(hdc, NULL, DoPaint, (LPARAM)hwnd);
            EndPaint(hwnd, &ps);
            return 0;
	    }
        break;

        //default push putton handler
        case DM_SETDEFID :
        {
            wDefButtonID = (WORD)wParam;
        }
        break;

        case DM_GETDEFID :
        {
            return (MAKELRESULT(wDefButtonID,DC_HASDEFID));
        }
        break;

        //custom menu accel handler
        case WM_MENUCHAR :
        {
            if (g_pMenu)
            {
                return (g_pMenu->MenuChar((TCHAR)LOWORD(wParam),(UINT)HIWORD(wParam),(HMENU)lParam));
            }
        }
        break;
        
        //custom menu handler
        case WM_MEASUREITEM :
        {
	        if (lParam == 0) return (0);

            if (g_pMenu)
            {
                g_pMenu->MeasureItem(hwnd,(LPMEASUREITEMSTRUCT)lParam);
            }
        }
        break;

        //custom menu/button handler
	    case WM_DRAWITEM :
	    {
	        if (lParam == 0) return (0);

            if (wParam == 0)
            {
                if (g_pMenu)
                {
                    g_pMenu->DrawItem(hwnd,(LPDRAWITEMSTRUCT)lParam);
                    return (1);
                }
            }
            else
            {
    	        DrawButton((UINT)wParam,(LPDRAWITEMSTRUCT)lParam);
                return (1);
            }

	        return (0);
	    }

        //notify is either from tool tip or volume knob	    
        case WM_NOTIFY :
	    {
            if ((((LPNMHDR)lParam)->code) == TTN_NEEDTEXT)
            {
                OnToolTipNotify(lParam);
            }
            else
            {
	            if ((int)wParam == IDB_VOLUME)
	            {
		            CKnob* pKnob = GetKnobFromID(hwnd,IDB_VOLUME);

		            DWORD dwNewVol = pKnob->GetPosition();

		            DrawVolume(pKnob->GetPosition());

		            if ((((LPNMHDR)lParam)->code) == TRUE)
                    {
                        SetVolume(dwNewVol);
                    }

		            //reset timer to repaint client area
		            KillTimer(hwnd,VOLUME_PERSIST_TIMER_EVENT);
		            SetTimer(hwnd,VOLUME_PERSIST_TIMER_EVENT,VOLUME_PERSIST_TIMER_RATE,(TIMERPROC)VolPersistTimerProc);
	            } //end if knob
            } //end else
	    }
	    break;
	    
	    //menu going away
        case WM_EXITMENULOOP :
        {
            BlockMenu(hwnd);
        }
        break;
        
        //command message
        case WM_COMMAND :
	    {
            HandleCommand(hwnd, iMsg, wParam, lParam);
	    }
	    break;

	    case WM_DEVICECHANGE :
	    {
            Volume_DeviceChange(hwnd, wParam, lParam);
	    }
        break;

        case WM_WININICHANGE :
        {
	        return (SendMessage(hwndCurrentComp,WM_WININICHANGE,wParam,lParam));
        }

	    //we're done
        case WM_ENDSESSION :
        case WM_DESTROY :
	    {
            if ((iMsg == WM_ENDSESSION) && (!wParam))
            {
                return 0;
            }

            if (hMutex)
            {
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
                hMutex = NULL;
            }

            //if playing and we don't want to be, stop it
            //BE VERY PARANOID and check all variables, this is an RTMCRIT bug fix
            LPCDOPT pOpt = GetCDOpt();
            if (pOpt)
            {
                LPCDOPTIONS pOptions = pOpt->GetCDOpts();
                if (pOptions)
                {
                    LPCDOPTDATA pOptionData = pOptions->pCDData;
                    if (pOptionData)
                    {
	                    if (pOptionData->fExitStop)
                        {
	                        IMMComponentAutomation* pAuto = NULL;
                            if (pNodeCurrent)
                            {
	                            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	                            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	                            {
                                    //at this point, we can actually stop the CD
                                    pAuto->OnAction(MMACTION_STOP,NULL);        
                                    //release the automation object        
                                    pAuto->Release();
                                }
                            } //end if pnodecurrent
                        } //end if "stop on exit"
                    } //end if option data ok
                } //end if options OK
            } //end if opt OK

            //make sure we're not downloading
            EndDownloadThreads();

			//Unregister the WM_DEVICECHANGE notification
			Volume_DeviceChange_Cleanup();
            
	        //close the volume mixer
            mixerClose((HMIXER)hmix);

            //delete any GDI objects
	        GlobalFree(hbmpMain);
	        GlobalFree(hbmpMainRestore);
            GlobalFree(hbmpMainSmall);
            GlobalFree(hbmpMainNoBar);
	        DeleteObject(hpalMain);

	        //shut down the button class
	        UninitMButtons();

	        //save window state
            if (!IsIconic(hwnd))
            {
                RECT rect;
	            GetWindowRect(hwnd,&rect);
	            SetSettings(rect.left,rect.top);
            }
	        
	        PostQuitMessage(0);
	        return (0);
	    }
    }

    if (iMsg == g_uTaskbarRestart)
    {
        if (fShellMode)
        {
            CreateShellIcon(hInst,hwndMain,pNodeCurrent,szAppName);
        }
    }

    if (iMsg == giVolDevChange)
    {
        WinMMDeviceChangeHandler(hwnd);
    }

    return (DefWindowProc(hwnd, iMsg, wParam, lParam));
}

////////////////////////////////////////////////////////////////////////////////////////////
// * LoadComponents
// Load registered componets from registry
// This code modified from the original MFC-based "Jazz" implementation, with blessings
// from todorfay <g>
////////////////////////////////////////////////////////////////////////////////////////////
BOOL LoadComponents( void )
{
	BOOL      fSuccess = FALSE;
	IMMComponent* pIComponent = NULL;
	TCHAR     szError[MAX_PATH];

	if( SUCCEEDED(CDPLAY_CreateInstance(NULL, IID_IMMComponent, (void**)&pIComponent)) )
	{
		fSuccess = TRUE;
        AddComponent(pIComponent);
	}
	else
	{
		TCHAR strMsg[MAX_PATH];
    	LoadString(hInst,IDS_ERRORLOADINGCOMP,szError,sizeof(szError)/sizeof(TCHAR));
        TCHAR strReinstall[MAX_PATH];
    	LoadString(hInst,IDS_REINSTALL,strReinstall,sizeof(strReinstall)/sizeof(TCHAR));
		wsprintf(strMsg,TEXT("%s\n\n%s"), szError, strReinstall);
		MessageBox(NULL, strMsg, szAppName, MB_OK|MB_ICONERROR );
	}

	return fSuccess;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * AddComponent
// Add a component to the list of comps
////////////////////////////////////////////////////////////////////////////////////////////
void AddComponent(IMMComponent* pComponent)
{
	pCompListTail->pComp = pComponent;
	pCompListTail->pSink = new CFrameworkNotifySink(pCompListTail);
    pCompListTail->pSink->AddRef();

	PCOMPNODE pNew = new COMPNODE;
	pNew->pComp = NULL;
	pNew->pNext = NULL;
	pNew->hwndComp = NULL;
	pNew->pSink = NULL;
	pNew->szTitle[0] = '\0';

	pCompListTail->pNext = pNew;
	pCompListTail = pNew;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CleanUp
// Get rid of anything that might have been around, like linked list, mutex, bitmaps, etc.
////////////////////////////////////////////////////////////////////////////////////////////
void CleanUp(void)
{
    if (pCompList)
    {
        while (pCompList->pNext != NULL)
        {
	        PCOMPNODE pTemp = pCompList;
	        pCompList = pTemp->pNext;
	        if (pTemp->pComp)
	        {
	            pTemp->pComp->Release();
	            pTemp->pSink->Release();
	        }
	        delete pTemp;
        }
    
        delete pCompList;
        pCompList = NULL;
    }

    if (g_pOptions)
    {
        g_pOptions->Release();
    }

    if (g_pData)
    {
        g_pData->Release();
    }

    if (g_hhk)
    {
        UnhookWindowsHookEx(g_hhk);
        g_hhk = NULL;
    }

    if (hmImage)
    {
        FreeLibrary(hmImage);
    }

    if (fShellMode)
    {
        DestroyShellIcon();
    }

    CDNET_Uninit();
}

////////////////////////////////////////////////////////////////////////////////////////////
// * InitComponents
// Initialize components by calling their INIT functions and setting their window sizes
////////////////////////////////////////////////////////////////////////////////////////////
void InitComponents(HWND hwnd)
{
    PCOMPNODE pList = pCompList;

    RECT rect;
    while (pList->pNext!=NULL)
    {
	    IMMComponent* pComp = pList->pComp;
	    if (pComp)
	    {
	        nNumComps++;
	        
	        pComp->Init(pList->pSink,hwnd,&rect,&(pList->hwndComp),&(pList->hmenuComp));

            CalculateDispAreaOffset(pComp);

            switch (g_nViewMode)
            {
                case VIEW_MODE_NORMAL :
                {
                    SetRect(&rect,24,32,455,88+nDispAreaOffset);
                }
                break;

                case VIEW_MODE_RESTORE :
                {
                    SetRect(&rect,303,24,384,41);
                }
                break;

                case VIEW_MODE_SMALL :
                {
                    SetRect(&rect,303,12,384,29);
                }
                break;

                case VIEW_MODE_NOBAR :
                {
                    SetRect(&rect,24,16,455,72+nDispAreaOffset);
                }
                break;
            }

	        SetWindowPos(pList->hwndComp,
		         hwnd,
		         rect.left,
		         rect.top,
		         rect.right - rect.left,
		         rect.bottom - rect.top,
		         SWP_NOZORDER|SWP_NOACTIVATE);

            //size ledwindow to maximum size
            HWND hwndLED = GetDlgItem(pList->hwndComp,IDC_LEDWINDOW);
            if (hwndLED)
            {
                SetRect(&rect,24,32,455,88+nDispAreaOffset);
	            SetWindowPos(hwndLED,
		             pList->hwndComp,
		             0,
		             0,
		             rect.right - rect.left,
		             rect.bottom - rect.top,
		             SWP_NOZORDER|SWP_NOACTIVATE);

                InvalidateRect(hwndLED,NULL,FALSE);
                UpdateWindow(hwndLED);
            }

	        if (!hwndCurrentComp)
	        {
		        ShowNewComponentWindow(pList, hwnd);
	        }
	    } //end if comp ok

	    pList = pList->pNext;
    } //end while
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetToolTipMsgProc
// Msg hook for tool tips so they know when to pop up
////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK GetToolTipMsgProc(int nCode, WPARAM wParam, LPARAM lParam)
{ 
    MSG *lpmsg;
    lpmsg = (MSG *) lParam;
     
    if (nCode < 0 || !(IsChild(hwndMain, lpmsg->hwnd)))
    {
        return (CallNextHookEx(g_hhk, nCode, wParam, lParam));  
    }

    switch (lpmsg->message)
    {
        case WM_MOUSEMOVE: 
        case WM_LBUTTONDOWN:         
        case WM_LBUTTONUP: 
        case WM_RBUTTONDOWN:         
        case WM_RBUTTONUP: 
            if (g_hwndTT != NULL)
            {                 
                MSG msg;  
                msg.lParam = lpmsg->lParam; 
                msg.wParam = lpmsg->wParam; 
                msg.message = lpmsg->message;                 
                msg.hwnd = lpmsg->hwnd; 
                
                SendMessage(g_hwndTT, TTM_RELAYEVENT, 0, 
                    (LPARAM) (LPMSG) &msg);             
            }             
            break; 
        
        default: break;     
    } 

    return (CallNextHookEx(g_hhk, nCode, wParam, lParam));
} 
    
////////////////////////////////////////////////////////////////////////////////////////////
// * CreateToolTips
// Common control setup code to init tool tips
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CreateToolTips(HWND hwnd)
{  
    InitCommonControls(); 

    g_hwndTT = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL, 
        TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
        CW_USEDEFAULT, hwnd, (HMENU) NULL, hInst, NULL);
          
    if (g_hwndTT == NULL)
        return FALSE;  

    // Install a hook procedure to monitor the message stream for mouse 
    // messages intended for the controls in main window
    g_hhk = SetWindowsHookEx(WH_GETMESSAGE, GetToolTipMsgProc, 
        (HINSTANCE) NULL, GetCurrentThreadId());  

    if (g_hhk == NULL)
        return FALSE;
        
    return TRUE; 	
} 


//WM_DEVICECHANGE support/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

void Volume_DeviceChange_Cleanup()
{
   if (DeviceEventContext) 
   {
       UnregisterDeviceNotification(DeviceEventContext);
       DeviceEventContext = 0;
   }
}

/*
**************************************************************************************************
	Volume_GetDeviceHandle()

	given a mixerID this functions opens its corresponding device handle. This handle can be used 
	to register for DeviceNotifications.

	dwMixerID -- The mixer ID
	phDevice -- a pointer to a handle. This pointer will hold the handle value if the function is
				successful
	
	return values -- If the handle could be obtained successfully the return vlaue is TRUE.

**************************************************************************************************
*/
BOOL Volume_GetDeviceHandle(DWORD dwMixerID, HANDLE *phDevice)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage((HMIXER)ULongToPtr(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return FALSE;
		}

		mmr = mixerMessage((HMIXER)ULongToPtr(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	//Get an handle on the device interface name.
	*phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	GlobalFreePtr(szInterfaceName);
	if(INVALID_HANDLE_VALUE == *phDevice)
	{
		return FALSE;
	}

	return TRUE;
}


/*	Volume_DeviceChange_Init()
*	First time initialization for WM_DEVICECHANGE messages
*	
*	On NT 5.0, you have to register for device notification
*/
void Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{

	DEV_BROADCAST_HANDLE DevBrodHandle;
	HANDLE hMixerDevice=NULL;

	//If we had registered already for device notifications, unregister ourselves.
	Volume_DeviceChange_Cleanup();

	//If we get the device handle register for device notifications on it.
	if(Volume_GetDeviceHandle(dwMixerID, &hMixerDevice))
	{
		memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

		DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
		DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
		DevBrodHandle.dbch_handle = hMixerDevice;

		DeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, 
													DEVICE_NOTIFY_WINDOW_HANDLE);

		if(hMixerDevice)
		{
			CloseHandle(hMixerDevice);
			hMixerDevice = NULL;
		}
	}
}


void Volume_DeviceChange(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    //if plug-and-play sends this, pass it along to the component
    PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

    //If we have an handle on the device then we get a DEV_BROADCAST_HDR structure as the lParam.
    //Or else it means that we have registered for the general audio category KSCATEGORY_AUDIO.
	    
    if(!DeviceEventContext || !bh || bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
    {
        SendMessage(hwndCurrentComp,WM_DEVICECHANGE,wParam,lParam);
    }
    else
    {
        //Handle device changes to the mixer device.
        switch(wParam)
        {
	        //send "1" in lparam to indicate that this is a device remove and not a power request

	        case DBT_DEVICEQUERYREMOVE:
                HandlePowerBroadcast(hwndMain, PBT_APMQUERYSUSPEND, (LPARAM)1);
		        break;
	        
	        case DBT_DEVICEQUERYREMOVEFAILED:
		        HandlePowerBroadcast(hwndMain, PBT_APMQUERYSUSPENDFAILED, (LPARAM)1);
		        break;
        }
    }
}

//WM_DEVICECHANGE support ends////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\mmenu.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMENU.CPP: Defines custom menu interface for multimedia applet
//
// Copyright (c) Microsoft Corporation 1998
//    
// 1/28/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "windows.h"
#include "mmenu.h"
#include "tchar.h"
#include "resource.h"

#define ICON_SPACING 3

extern HINSTANCE hInst;

typedef struct ownermenu
{
    TCHAR szText[MAX_PATH];
    HICON hIcon;
} OWNERMENU, *LPOWNERMENU;

HRESULT AllocCustomMenu(CustomMenu** ppMenu)
{
    *ppMenu = new CCustomMenu();
    
    if (*ppMenu==NULL)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

CCustomMenu::CCustomMenu()
{
    m_hMenu = CreatePopupMenu();

    //get system font for any owner drawing
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    m_hFont = CreateFontIndirect(&metrics.lfMenuFont);

    if (metrics.lfMenuFont.lfCharSet == ANSI_CHARSET)
    {
        metrics.lfMenuFont.lfWeight = FW_BOLD;
    }
       
    m_hBoldFont = CreateFontIndirect(&metrics.lfMenuFont);

    if (IsBiDiLocalizedSystem(NULL)) 
    {
        m_bRTLMenu = TRUE;
    } 
    else 
    {
        m_bRTLMenu = FALSE;
    }
}

CCustomMenu::~CCustomMenu()
{
    //clean up string data in menus
    int x  = GetMenuItemCount(m_hMenu);

    for (int i = 0; i < x; i++)
    {
        MENUITEMINFO mii;
        ZeroMemory(&mii,sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA|MIIM_TYPE;
        GetMenuItemInfo(m_hMenu,i,TRUE,&mii);

        if ((mii.dwItemData!=0) && (mii.fType & MFT_OWNERDRAW))
        {
            OWNERMENU* pMenu = (OWNERMENU*)mii.dwItemData;
            if (pMenu)
            {
                DestroyIcon(pMenu->hIcon);
                delete [] pMenu;
            }
        }
    }

    DestroyMenu(m_hMenu);
    DeleteObject(m_hFont);
    DeleteObject(m_hBoldFont);
}

void CCustomMenu::Destroy()
{
    delete this;
}

BOOL CCustomMenu::AppendMenu(HINSTANCE hInst, int nStringID, CustomMenu* pMenu)
{
    TCHAR szMenu[MAX_PATH];
    LoadString(hInst,nStringID,szMenu,sizeof(szMenu)/sizeof(TCHAR));

    return ::AppendMenu(m_hMenu,MF_STRING|MF_POPUP,(UINT_PTR)pMenu->GetMenuHandle(),szMenu);
}

BOOL CCustomMenu::AppendMenu(int nMenuID, TCHAR* szMenu)
{
    return ::AppendMenu(m_hMenu,MF_STRING,nMenuID,szMenu);
}

BOOL CCustomMenu::AppendMenu(int nMenuID, HINSTANCE hInst, int nStringID)
{
    TCHAR szMenu[MAX_PATH];
    LoadString(hInst,nStringID,szMenu,sizeof(szMenu)/sizeof(TCHAR));

    return ::AppendMenu(m_hMenu,MF_STRING,nMenuID,szMenu);
}

BOOL CCustomMenu::AppendSeparator()
{
    return ::AppendMenu(m_hMenu,MF_SEPARATOR,0,0);
}

BOOL CCustomMenu::AppendMenu(int nMenuID, HINSTANCE hInst, int nIconID, int nStringID)
{
    OWNERMENU* pMenu = new OWNERMENU;

    if (!pMenu)
    {
        return FALSE;
    }

    LoadString(hInst,nStringID,pMenu->szText,sizeof(pMenu->szText)/sizeof(TCHAR));

    int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

    pMenu->hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(nIconID), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);

    BOOL fAppend = ::AppendMenu(m_hMenu,MF_OWNERDRAW,nMenuID,(LPTSTR)pMenu);

    if (fAppend)
    {
        //this code allows the owner-draw menu to have text that can be read
        //by narrator and other apps that help with accessibility.
        MENUITEMINFO mii;
        memset(&mii, 0, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask  = MIIM_STRING;
        mii.dwTypeData = pMenu->szText;
        mii.cch =  sizeof (pMenu->szText) / sizeof(TCHAR);

        ::SetMenuItemInfo(m_hMenu,nMenuID,FALSE,&mii);
    }

    return (fAppend);
}

BOOL CCustomMenu::TrackPopupMenu(UINT uFlags, int x, int y, HWND hwnd, CONST RECT* pRect)
{
    TPMPARAMS tpm;
    tpm.cbSize = sizeof(tpm);
    memcpy(&(tpm.rcExclude),pRect,sizeof(RECT));
    // if m_bRTLMenu then make the menu is right aligned and RTL reading.
    if (m_bRTLMenu) {
        MENUITEMINFO mii;
        TCHAR szMenuString[MAX_PATH];

        memset(&mii, 0, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask  = MIIM_TYPE;
        mii.dwTypeData = szMenuString;
        mii.cch =  sizeof (szMenuString) / sizeof(TCHAR);
        if ((mii.fType != MFT_OWNERDRAW) && (mii.fType != MFT_BITMAP)) {
            if(GetMenuItemInfo(m_hMenu, 0, TRUE, &mii)) {
                mii.fType  |= (MFT_RIGHTORDER | MFT_RIGHTJUSTIFY);
                SetMenuItemInfo(m_hMenu, 0, TRUE, &mii);
            }
        }
    }
    return ::TrackPopupMenuEx(m_hMenu,uFlags,x,y,hwnd,&tpm);
}

BOOL CCustomMenu::SetMenuDefaultItem(UINT uItem, UINT fByPos)
{
    return ::SetMenuDefaultItem(m_hMenu,uItem,fByPos);
}

void CCustomMenu::MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pMeasure)
{
    OWNERMENU* szMenu = (OWNERMENU*)pMeasure->itemData;

    int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

    HDC hdc = GetDC(hwnd);

    HFONT hOrgFont = (HFONT)SelectObject(hdc,m_hBoldFont);
    SIZE size;

    GetTextExtentPoint32(hdc, szMenu->szText, _tcslen(szMenu->szText), &size );

    pMeasure->itemWidth = size.cx + cxMiniIcon + (ICON_SPACING*2);
    pMeasure->itemHeight = max(cyMiniIcon,size.cy);

    SelectObject(hdc,hOrgFont);
    ReleaseDC(hwnd,hdc);
}

void CCustomMenu::DrawItem(HWND hwnd, LPDRAWITEMSTRUCT pDraw)
{
    OWNERMENU* szMenu = (OWNERMENU*)pDraw->itemData;
    HDC hdc = pDraw->hDC;

    COLORREF colorFill = GetSysColor(COLOR_MENU);
    COLORREF colorText = GetSysColor(COLOR_MENUTEXT);

    if (pDraw->itemState & ODS_SELECTED)
    {
        colorFill = GetSysColor(COLOR_HIGHLIGHT);
        colorText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    }

    HBRUSH hbrBack = CreateSolidBrush(GetSysColor(COLOR_MENU));

    //blit the icon, always with menu color background
    int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

    // if m_bRTLMenu then draw the icon on the right hand side.
    if (m_bRTLMenu) {
        DrawIconEx(hdc,pDraw->rcItem.right - cxMiniIcon,pDraw->rcItem.top,szMenu->hIcon,cxMiniIcon,cyMiniIcon,0,hbrBack,DI_NORMAL);
    } else {
        DrawIconEx(hdc,pDraw->rcItem.left,pDraw->rcItem.top,szMenu->hIcon,cxMiniIcon,cyMiniIcon,0,hbrBack,DI_NORMAL);
    }

    DeleteObject(hbrBack);
    hbrBack = CreateSolidBrush(colorFill);

    HFONT hOrgFont;
        
    if (pDraw->itemState & ODS_DEFAULT)
    {
        hOrgFont = (HFONT)SelectObject(hdc,m_hBoldFont);
    }
    else
    {
        hOrgFont = (HFONT)SelectObject(hdc,m_hFont);
    }

    if (m_bRTLMenu) {
        pDraw->rcItem.right -= (cxMiniIcon + ICON_SPACING);
    } else {
        pDraw->rcItem.left += (cxMiniIcon + ICON_SPACING);
    }

    FillRect(hdc,&pDraw->rcItem,hbrBack);
    
    DeleteObject(hbrBack);

    if (m_bRTLMenu) {
        pDraw->rcItem.right -= ICON_SPACING;
    } else {
        pDraw->rcItem.left += ICON_SPACING;
    }

    SetBkMode(hdc,TRANSPARENT);
    SetTextColor(hdc,colorText);
    // if m_bRTLMenu then draw the text right aligned and RTL reading.
    if (m_bRTLMenu) {
        DrawText(hdc, szMenu->szText, -1, &pDraw->rcItem, DT_SINGLELINE | DT_RIGHT | DT_RTLREADING);
    } else {
        DrawText(hdc, szMenu->szText, -1, &pDraw->rcItem, DT_SINGLELINE);
    }

    SelectObject(hdc,hOrgFont);
}

LRESULT CCustomMenu::MenuChar(TCHAR tChar, UINT fuFlag, HMENU hMenu)
{
    //go through the menus one-by-one looking for the accel key
    int nReturn = 0;
    int nCode = MNC_IGNORE;

    int x  = GetMenuItemCount(m_hMenu);

    TCHAR teststr[3];
    wsprintf(teststr,TEXT("&%c"),tChar);
    _tcsupr(teststr);

    for (int i = 0; i < x; i++)
    {
        MENUITEMINFO mii;
        ZeroMemory(&mii,sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA|MIIM_TYPE;
        GetMenuItemInfo(m_hMenu,i,TRUE,&mii);

        if ((mii.dwItemData!=0) && (mii.fType & MFT_OWNERDRAW))
        {
            OWNERMENU* szMenu = (OWNERMENU*)mii.dwItemData;
            TCHAR* pMenu = new TCHAR[_tcslen(szMenu->szText)+sizeof(TCHAR)];
            _tcscpy(pMenu,szMenu->szText);

            _tcsupr(pMenu);

            if (_tcsstr(pMenu,teststr)!=NULL)
            {
                nReturn = i;
                nCode = MNC_EXECUTE;
                if (pMenu)
                {
                    delete [] pMenu;
                    pMenu = NULL;
                }
                break;
            }

            if (pMenu)
            {
                delete [] pMenu;
                pMenu = NULL;
            }
        } //end if not separator
    }

    return (MAKELRESULT(nReturn, nCode));
}


/***************************************************************************\
* ConvertHexStringToInt
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToInt( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;


    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* IsBiDiLocalizedSystem
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystem( LANGID *pLangID )
{
    HKEY          hKey;
    DWORD         dwType;
    CHAR          szResourceLocale[12];
    DWORD         dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
       if (bRet && pLangID)
       {
           *pLangID = langID;
       }
       return bRet;
    }

    bRet = FALSE;
#ifdef UNICODE
   /*
    * Need to use NT5 detection method (Multiligual UI ID)
    */
   langID = GetUserDefaultUILanguage();

   if( langID )
   {
       WCHAR wchLCIDFontSignature[16];
       iLCID = MAKELCID( langID , SORT_DEFAULT );

       /*
        * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string,
        * convert to decimal value and call GetLocaleInfo afterwards.
        * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
        */

       if( GetLocaleInfoW( iLCID ,
                           LOCALE_FONTSIGNATURE ,
                           (WCHAR *) &wchLCIDFontSignature[0] ,
                           (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
       {

           /* Let's verify the bits we have a BiDi UI locale */
           if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
           {
               bRet = TRUE;
           }
       }
   }
#else
   /*
    * Check if BiDi-Memphis is running with Lozalized Resources (
    * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
    */
   if(GetSystemMetrics(SM_MIDEASTENABLED))
   {

       if( RegOpenKeyExA( HKEY_CURRENT_USER ,
                          "Control Panel\\Desktop\\ResourceLocale" ,
                          0,
                          KEY_READ, &hKey) == ERROR_SUCCESS)
       {
           RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
           szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

           RegCloseKey(hKey);

           if( ConvertHexStringToInt( szResourceLocale , &iLCID ) )
           {
               iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
               if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
               {
                   bRet = TRUE;
                   langID = LANGIDFROMLCID(iLCID);
               }
           }
       }
   }
#endif
    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\sink.h ===
// FrameworkNotifySink.h: interface for the CFrameworkNotifySink class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FRAMEWORKNOTIFYSINK_H__E5927148_521E_11D1_9B97_00C04FA3B60C__INCLUDED_)
#define AFX_FRAMEWORKNOTIFYSINK_H__E5927148_521E_11D1_9B97_00C04FA3B60C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "mmfw.h"
#include "..\cdopt\cdopt.h"

#define WM_DISCCHANGED WM_USER + 1500

typedef struct CompNode
{
    IMMComponent*       pComp;
    HWND                hwndComp;
    HMENU               hmenuComp;
    IMMFWNotifySink*    pSink;
    struct CompNode*    pNext;
    TCHAR                szTitle[MAX_PATH*2];
} COMPNODE, *PCOMPNODE;

LPCDOPT GetCDOpt();
LPCDDATA GetCDData();

class CFrameworkNotifySink : public IMMFWNotifySink  
{
public:
	CFrameworkNotifySink(PCOMPNODE pNode);
	virtual ~CFrameworkNotifySink();

    STDMETHOD (QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

	STDMETHOD (OnEvent)(MMEVENTS mmEventID, LPVOID pEvent);
    STDMETHOD_(void*,GetCustomMenu)();
    STDMETHOD_(HPALETTE,GetPalette)();
    STDMETHOD_(void*,GetOptions)();
    STDMETHOD_(void*,GetData)();

public:
    static HWND m_hwndTitle;

private:
	DWORD m_dwRef;
    PCOMPNODE m_pNode;
    TCHAR m_szAppName[MAX_PATH/2];
};

#endif // !defined(AFX_FRAMEWORKNOTIFYSINK_H__E5927148_521E_11D1_9B97_00C04FA3B60C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\mmfw.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains Multimedia Framework Interfaces and Prototypes
//
//	Copyright (c) Microsoft Corporation	1997
//    
//	10/31/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MMFRAMEWORK_PUBLICINTEFACES_
#define _MMFRAMEWORK_PUBLICINTEFACES_

#include "mmsystem.h"
#include "objbase.h"

#ifdef __cplusplus
extern "C" {
#endif

//literals the app needs to know
#define REG_KEY_NEW_FRAMEWORK TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD")
#define REG_KEY_FRAMEWORK_COMPONENTS REG_KEY_NEW_FRAMEWORK TEXT("\\Components")
#define FRAMEWORK_CLASS TEXT("MMFRAME_MAIN")
#define MENU_INIFILE_ENTRY TEXT("MENU%i")
#define URL_SEPARATOR TEXT("::")
#define WEBCD_MUTEX TEXT("WEBCD_MUTEX")
#define HELPFILENAME TEXT("DELUXCD.CHM")

//color modes
#define COLOR_VERYHI     0
#define COLOR_256        1
#define COLOR_16         2
#define COLOR_HICONTRAST 3

// Allocator functions for the LIBs that used to be DLLs
void    WINAPI CDNET_Init(HINSTANCE hInst);
void    WINAPI CDNET_Uninit(void);
HRESULT WINAPI CDNET_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj);
HRESULT WINAPI CDPLAY_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj);
HRESULT WINAPI CDOPT_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
// Defines the GUIDs / IIDs for this project:
//
// IID_IMMFWNotifySink, IMMComponent, IMMComponentAutomation
//
// These are the three interfaces for Framework / Component communications.
// All other interfaces should be private to the specific project.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lMMFWIIDFirst			0xb2cd5bbb
#define DEFINE_MMFWIID(name, x)	DEFINE_GUID(name, lMMFWIIDFirst + x, 0x5221,0x11d1,0x9b,0x97,0x0,0xc0,0x4f,0xa3,0xb6,0xc)

DEFINE_MMFWIID(IID_IMMFWNotifySink,	    	0);
DEFINE_MMFWIID(IID_IMMComponent,	    	1);
DEFINE_MMFWIID(IID_IMMComponentAutomation,  2);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface IMMFWNotifySink	    	IMMFWNotifySink;
typedef IMMFWNotifySink*	    			LPMMFWNOTIFYSINK;

typedef interface IMMComponent  			IMMComponent;
typedef IMMComponent*   					LPMMCOMPONENT;

typedef interface IMMComponentAutomation    IMMComponentAutomation;
typedef IMMComponentAutomation*             LPMMCOMPONENTAUTOMATION;

#ifndef LPUNKNOWN
typedef IUnknown*   						LPUNKNOWN;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	HRESULT Return Codes
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

// Success Codes

#define MM_S_FIRST			(OLE_S_FIRST + 9000)

#define S_FINISHED          (S_OK)
#define	S_CONTINUE			(MM_S_FIRST + 1)
#define S_CHECKMENU         (MM_S_FIRST + 2)

// Error Codes

#define MM_E_FIRST				(OLE_E_FIRST + 9000)

#define E_NOTINITED             (MM_E_FIRST + 1)
#define E_INCOMPATIBLEDLL		(MM_E_FIRST + 2)
#define E_GRAYMENU              (MM_E_FIRST + 3)


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Common enums
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMEVENTS = Event notifications that should be send to the framework via the NotifySink.
//            This allows the framework to do things like fire events to a web browser's script language
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMEVENTS
{
	MMEVENT_SETTITLE	    = 0,    //change title of playing media
	MMEVENT_CHANGEUIELEMENT	= 1,	//indicates major change in display, transport, or menu (i.e. handle is now different)
	MMEVENT_ONPLAY		    = 2,    //begin playing media
	MMEVENT_ONSTOP			= 3,    //stop media
    MMEVENT_ONPAUSE         = 4,    //pause media
	MMEVENT_ONUSERNOTIFY	= 5,    //use instead of putting up your own message boxes ... framework may have alternative display method
    MMEVENT_ONMEDIALOADED   = 6,    //media has been loaded
    MMEVENT_ONMEDIAUNLOADED = 7,    //media has been unloaded
    MMEVENT_ONTRACKCHANGED  = 8,    //media track changed
    MMEVENT_ONDISCCHANGED   = 9,    //disc changed
    MMEVENT_ONSETVOLUME     = 10,    //device volume changed
    MMEVENT_ONERROR         = 11    //error occurred
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMACTIONS = Commands sent to IMMComponentAutomation.
//             This allows the framework to drive the component without UI (i.e. in a web script)
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMACTIONS
{
	MMACTION_PLAY		    = 0,	
	MMACTION_STOP	    	= 1,	
	MMACTION_SETPOSITION	= 2,
	MMACTION_LOADMEDIA      = 3,
   	MMACTION_UNLOADMEDIA    = 4,
    MMACTION_NEXTTRACK      = 5,
    MMACTION_PREVTRACK      = 7,
    MMACTION_PAUSE          = 8,
    MMACTION_REWIND         = 9,
    MMACTION_FFWD           = 10,
    MMACTION_NEXTMEDIA      = 11,
    MMACTION_GETMEDIAID     = 12,
    MMACTION_READSETTINGS   = 13,
    MMACTION_GETTRACKINFO   = 14,
    MMACTION_GETDISCINFO    = 15,
    MMACTION_SETTRACK       = 16,
    MMACTION_SETDISC        = 17,
    MMACTION_GETNETQUERY    = 18,
}; 

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMICONSIZES =  The various sizes for icons the framework can request.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMICONSIZES
{
    MMICONSIZE_16BY16       = 16,
    MMICONSIZE_32BY32       = 32,
    MMICONSIZE_48BY48       = 48
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMINFOTEXT = Different types of text requested in IMMComponent::GetText.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMINFOTEXT
{
    MMINFOTEXT_TITLE        = 0,
    MMINFOTEXT_ARTIST       = 1,
    MMINFOTEXT_MEDIATYPE    = 2,
    MMINFOTEXT_DESCRIPTION  = 3,
    MMINFOTEXT_MENULABEL    = 4,
    MMINFOTEXT_MENUPROMPT   = 5,
    MMINFOTEXT_MEDIAID      = 6
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMUIELEMENTS = FLAGS for use with MMEVENT_CHANGEUIELEMENT
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMUIELEMENTS
{
    MMUIELEMENT_DISPLAY      = 1,
    MMUIELEMENT_TRANSPORT    = 2,
    MMUIELEMENT_MENU         = 4
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMPOSTYPE = Indicator of type of positioning scheme used.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMPOSTYPE
{
    MMPOSTYPE_SAMPLES        = 0,
    MMPOSTYPE_MILLISECONDS   = 1,
    MMPOSTYPE_BYTES          = 2,
    MMPOSTYPE_SMPTE          = 3,
    MMPOSTYPE_CDFRAMES       = 4
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Type definitions
//
// Structs for Events and Actions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
				
typedef struct MMNET
{
    DWORD discid;
    BOOL  fForceNet;
    HWND  hwndCallback;
    void* pData;
    void* pData2;
} MMNET, *LPMMNET;

typedef struct MMSETTITLE
{
    MMINFOTEXT      mmInfoText;
    LPTSTR          szTitle;
} MMSETTITLE, *LPMMSETTITLE;

typedef struct MMCHANGEUIELEMENT
{
    MMUIELEMENTS    mmElementFlag;
    HANDLE          hElement;
} MMCHANGEUIELEMENT, *LPMMCHANGEUIELEMENT;

typedef struct MMONSTOP
{
    int             nReason;
    DWORD           dwPosition;
} MMONSTOP, *LPMMONSTOP;

typedef struct MMONUSERNOTIFY
{
    LPTSTR          szNotification;
    UINT            uType; //see MessageBox API in Win32 SDK
} MMONUSERNOTIFY, *LPMMONUSERNOTIFY;

typedef struct MMONMEDIALOADED
{
    LPTSTR          szMediaName;
} MMONMEDIALOADED, *LPMMONMEDIALOADED;

typedef struct MMONTRACKCHANGED
{
    int             nNewTrack;
} MMONTRACKCHANGED, *LPMMONTRACKCHANGED;

typedef struct MMONDISCCHANGED
{
    int             nNewDisc;
    BOOL            fDisplayVolChange;
} MMONDISCCHANGED, *LPMMONDISCCHANGED;

typedef struct MMONVOLCHANGED
{
    DWORD           dwNewVolume;
    BOOL            fMuted;
    TCHAR*          szLineName;
} MMONVOLCHANGED, *LPMMONVOLCHANGED;

typedef struct MMONERROR
{
    MMRESULT        mmrErrorCode;
    LPTSTR          szErrorString;
} MMONERROR, *LPMMONERROR;

typedef struct MMSETPOSITION
{
    MMPOSTYPE       mmPosType;
    DWORD           dwPosition;
} MMSETPOSITION, *LPMMSETPOSITION;

typedef struct MMLOADMEDIA
{
    LPTSTR          szMedia;
} MMLOADMEDIA, *LPMMLOADMEDIA;

typedef struct MMCHANGETRACK
{
    int             nNewTrack;
} MMCHANGETRACK, *LPMMCHANGETRACK;

typedef struct MMCHANGEDISC
{
    int             nNewDisc;
} MMCHANGEDISC, *LPMMCHANGEDISC;

typedef struct MMTRACKORDISC
{
    int     nNumber;  //input to call: sequential number of track or disc we are requesting
    BOOL    fCurrent; //returned from call to say that track or disc request is current
    int     nID;      //unique ID of track or disc returned from call
    TCHAR   szName[MAX_PATH]; //name of track or disc returned from call
} MMTRACKORDISC, *LPMMTRACKORDISC;

typedef struct MMMEDIAID
{
    int     nDrive; //-1 means "use current"
    DWORD   dwMediaID;
    DWORD   dwNumTracks;
    TCHAR   szMediaID[MAX_PATH];
    TCHAR   szTitle[MAX_PATH];
    TCHAR   szTrack[MAX_PATH];
    TCHAR   szArtist[MAX_PATH];
} MMMEDIAID, *LPMMMEDIAID;

typedef struct MMNETQUERY
{
    int     nDrive; //-1 means "use current"
    TCHAR*  szNetQuery;
} MMNETQUERY, *LPMMNETQUERY;

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IMMFWNotifySink
DECLARE_INTERFACE_(IMMFWNotifySink, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IMMFWNotifySink methods--- 

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::OnEvent

    This is the component's primary method of communication back to the framework.
    
    It is used to indicate that something has changed so that the framework can update its
    UI or fire an event through to the web scripting language, etc.  The component
    should not expect that the framework will actually do anything with any notification.

    mmEventID = Event enum indicating type of event
    pEvent = Pointer to structure of type associated with mmEventID

    return values = S_OK, E_FAIL
                    Except for MMEVENT_ONUSERNOTIFY, hr = MessageBox response value
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
	STDMETHOD (OnEvent) 				(THIS_	MMEVENTS mmEventID, 
												LPVOID pEvent) PURE;
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetCustomMenu

    Returns the custom menu object for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(void*,GetCustomMenu)       (THIS) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetPalette

    Returns the custom palette handle for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(HPALETTE,GetPalette)       (THIS) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetOptions

    Returns the options object for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(void*,GetOptions)       (THIS) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetData

    Returns the data object for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(void*,GetData)       (THIS) PURE;
};

/*
*****************************************************************************
About Registering Components

Components should be registered under:

HKCU\Software\Microsoft\MediaFramework\Components\<component guid>
    Default = "Friendly Name"
    HandlesExtensions = "File extensions (without periods) that this handles" (optional)
    HandlesTypes = "Media types supported, such as 'cdaudio' or 'wave'"
    Command = "Command line that will trigger this component to be shown by default, just text, no slashes"

The component's class factory should be registered like an inproc server:

HKCR\CLSID\<component guid>
    Default = "Name"
    \InprocServer32
        Default = "DLL_Full_Path.DLL"
        ThreadingModel = "Apartment"

The following is an example .RGS script file for the Active Template Library:

    HKCR
    {
	    ExampleComp.ExampleComp.1 = s 'ExampleComp Class'
	    {
		    CLSID = s '{E5927147-521E-11D1-9B97-00C04FA3B60C}'
	    }
	    ExampleComp.ExampleComp = s 'ExampleComp Class'
	    {
		    CurVer = s 'ExampleComp.ExampleComp.1'
	    }
	    NoRemove CLSID
	    {
		    ForceRemove {E5927147-521E-11D1-9B97-00C04FA3B60C} = s 'ExampleComp Class'
		    {
			    ProgID = s 'ExampleComp.ExampleComp.1'
			    VersionIndependentProgID = s 'ExampleComp.ExampleComp'
			    InprocServer32 = s '%MODULE%'
			    {
				    val ThreadingModel = s 'Apartment'
			    }
		    }
	    }
    }
    HKCU
    {
	    'Software'
	    {
		    'Microsoft'
		    {
			    'MediaFramework'
			    {
				    'Components'
				    {
					    ForceRemove {E5927147-521E-11D1-9B97-00C04FA3B60C} = s 'Example Component'
                        {
                            HandlesExtensions = s 'wav mid'
                            HandlesTypes = s 'cdaudio'
                            Command = s 'cd'
                        }
				    }
			    }
		    }
	    }
    }

*****************************************************************************
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Component enlistment structure
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_NAME 50

typedef struct MMCOMPDATA
{
    DWORD                   dwSize;             //size in bytes of structure
    HICON                   hiconSmall;         //16 by 16 icon
    HICON                   hiconLarge;         //32 by 32 icon
    int                     nAniResID;          //resource id of animated icon
    HINSTANCE               hInst;              //instance handle
    TCHAR                   szName[MAX_NAME];   //name of component
    BOOL                    fVolume;            //supports volume?
    BOOL                    fPan;               //supports pan?
    RECT                    rect;               //suggested rect for display window
} MMCOMPDATA, *LPMMCOMPDATA;

#undef INTERFACE
#define INTERFACE IMMComponent
DECLARE_INTERFACE_(IMMComponent, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IMMComponent methods--- 
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMComponent::GetInfo

    This function fills in an MMCOMPDATA structure supplied by the framework.

    The framework will call this function before calling Init.  It is used to
    figure out how to display your component on the switchbar.

    mmCompData = pointer to MMCOMPDATA structure from the framework
    
    return values = S_OK, E_FAIL
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD (GetInfo)                 (THIS_ MMCOMPDATA* mmCompData) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMComponent::Init

    This function is called when the framework actually wants you to create your
    display window and be ready to play back media.

    If at all possible, you should delay loading anything that will increase your
    memory footprint (i.e. support DLLs) until this call is made.  That will allow
    the framework to load much more quickly and only take the hit if the user actually
    decides to use your component.  Once the Init call is made, however, you will not
    be asked to unload until this object's refcount is 0, which may or may not be when
    the framework itself unloads.

    pSink = pointer to framework notification sink
    hwndMain = handle to main framework window for DirectX calls and others that require it
    pRect = main size and position rect for your window
    phwndComp = out parameter ... store your main window handle here.  All other windows in the
                component should be child windows of this one, so when the framework calls
                show / hide on this main window, all of your childen will show / hide as well
                This window should be created as a child of the "main" window sent into this
                function, and it should be created without the WS_VISIBLE flag set.
    phMenu = out parameter ... store your custom menu handler here, or NULL if not applicable.
    
    return values = S_OK, E_FAIL
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD (Init)                    (THIS_ IMMFWNotifySink* pSink, HWND hwndMain, RECT* pRect, HWND* phwndComp, HMENU* phMenu) PURE;
};

#undef INTERFACE
#define INTERFACE IMMComponentAutomation
DECLARE_INTERFACE_(IMMComponentAutomation, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

    //---  IMMComponentAutomation methods--- 
	
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMComponentAutomation::OnAction

    If the component supports IMMComponentAutomation, it is able to respond to transport
    control requests without having its UI pressed.  This is handy to allow the user to
    script the component via VBScript or JavaScript on a web page.  The framework will
    handle all of the necessary details; the component just needs to respond appropriately
    to this method.

    mmActionID = Action type indicator
    pAction = Pointer to action structure of type indicated by mmActionID

    return value = S_OK, E_FAIL
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
	STDMETHOD (OnAction)				(THIS_	MMACTIONS mmActionID, 
												LPVOID pAction) PURE;
};

#ifdef __cplusplus
};
#endif

#endif  //_MMFRAMEWORK_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\multimon.h ===
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)

//=============================================================================
//
// MULTIMON
// stub module that fakes multiple monitor apis on pre Memphis Win32 OSes
//
// By using this header your code will work unchanged on Win95,
// you will get back default values from GetSystemMetrics() for new metrics
// and the new APIs will act like only one display is present.
//
// exactly one source must include this with COMPILE_MULTIMON_STUBS defined
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// if we are building on Win95/NT4 headers we need to declare this stuff ourselves
//
#ifndef SM_CMONITORS

#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81

DECLARE_HANDLE(HMONITOR);

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

#define MONITORINFOF_PRIMARY        0x00000001

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#define CCHDEVICENAME 32

#ifdef __cplusplus
typedef struct tagMONITORINFOEX : public tagMONITORINFO
{
    TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#else
typedef struct
{
    MONITORINFO;
    TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#endif

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

#endif  // SM_CMONITORS

#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors

//
// define this to compile the stubs
// otherwise you get the declarations
//
#ifdef COMPILE_MULTIMON_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

int      (WINAPI* g_pfnGetSystemMetrics)(int);
HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, BOOL);
HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, BOOL);
HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, BOOL);
BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO);
BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM);

BOOL InitMultipleMonitorStubs(void)
{
    HMODULE hUser32;
    static BOOL fInitDone;

    if (fInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
        (*(FARPROC*)&g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &&
        (*(FARPROC*)&g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoW")) &&
#else
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) &&
#endif
        //
        // Old builds of Memphis had different indices for these metrics, and
        // some of the APIs and structs have changed since then, so validate that
        // the returned metrics are not totally messed up.  (for example on an old
        // Memphis build, the new index for SM_CYVIRTUALSCREEN will fetch 0)
        //
        // If this is preventing you from using the shell on secondary monitors
        // under Memphis then upgrade to a new Memphis build that is in sync with
        // the current version of the multi-monitor APIs.
        //
        (GetSystemMetrics(SM_CXVIRTUALSCREEN) >= GetSystemMetrics(SM_CXSCREEN)) &&
        (GetSystemMetrics(SM_CYVIRTUALSCREEN) >= GetSystemMetrics(SM_CYSCREEN)) )
    {
        fInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnGetSystemMetrics    = NULL;
        g_pfnMonitorFromWindow   = NULL;
        g_pfnMonitorFromRect     = NULL;
        g_pfnMonitorFromPoint    = NULL;
        g_pfnGetMonitorInfo      = NULL;
        g_pfnEnumDisplayMonitors = NULL;

        fInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// fake implementations of Monitor APIs that work with the primary display
// no special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------

int WINAPI
xGetSystemMetrics(int nIndex)
{
    if (InitMultipleMonitorStubs())
        return g_pfnGetSystemMetrics(nIndex);

    switch (nIndex)
    {
    case SM_CMONITORS:
    case SM_SAMEDISPLAYFORMAT:
        return 1;

    case SM_XVIRTUALSCREEN:
    case SM_YVIRTUALSCREEN:
        return 0;

    case SM_CXVIRTUALSCREEN:
        nIndex = SM_CXSCREEN;
        break;

    case SM_CYVIRTUALSCREEN:
        nIndex = SM_CYSCREEN;
        break;
    }

    return GetSystemMetrics(nIndex);
}

#define xPRIMARY_MONITOR ((HMONITOR)0x42)

HMONITOR WINAPI
xMonitorFromRect(LPCRECT lprcScreenCoords, UINT uFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromRect(lprcScreenCoords, uFlags);

    if ((uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((lprcScreenCoords->right > 0) &&
        (lprcScreenCoords->bottom > 0) &&
        (lprcScreenCoords->left < GetSystemMetrics(SM_CXSCREEN)) &&
        (lprcScreenCoords->top < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromPoint(POINT ptScreenCoords, UINT uFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromPoint(ptScreenCoords, uFlags);

    if ((uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((ptScreenCoords.x >= 0) &&
        (ptScreenCoords.x < GetSystemMetrics(SM_CXSCREEN)) &&
        (ptScreenCoords.y >= 0) &&
        (ptScreenCoords.y < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromWindow(HWND hWnd, UINT uFlags)
{
    RECT rc;

    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromWindow(hWnd, uFlags);

    if (uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))
        return xPRIMARY_MONITOR;

    if (GetWindowRect(hWnd, &rc))
        return xMonitorFromRect(&rc, uFlags);

    return NULL;
}

BOOL WINAPI
xGetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpMonitorInfo)
{
    RECT rcWork;

    if (InitMultipleMonitorStubs())
        return g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);

    if ((hMonitor == xPRIMARY_MONITOR) && lpMonitorInfo &&
        (lpMonitorInfo->cbSize >= sizeof(MONITORINFO)) &&
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0))
    {
        lpMonitorInfo->rcMonitor.left = 0;
        lpMonitorInfo->rcMonitor.top  = 0;
        lpMonitorInfo->rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);
        lpMonitorInfo->rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);
        lpMonitorInfo->rcWork = rcWork;
        lpMonitorInfo->dwFlags = MONITORINFOF_PRIMARY;

        if (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX))
            lstrcpy(((MONITORINFOEX*)lpMonitorInfo)->szDevice, TEXT("DISPLAY"));

        return TRUE;
    }

    return FALSE;
}

BOOL WINAPI
xEnumDisplayMonitors(HDC hdcOptionalForPainting,
    LPCRECT lprcEnumMonitorsThatIntersect, MONITORENUMPROC lpfnEnumProc,
    LPARAM lData)
{
    RECT rcCallback, rcLimit;

    if (InitMultipleMonitorStubs())
        return g_pfnEnumDisplayMonitors(hdcOptionalForPainting,
            lprcEnumMonitorsThatIntersect, lpfnEnumProc, lData);
    
    if (!lpfnEnumProc)
        return FALSE;

    rcLimit.left   = 0;
    rcLimit.top    = 0;
    rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);
    rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

    if (hdcOptionalForPainting)
    {
        RECT rcClip;
        HWND hWnd;

        if ((hWnd = WindowFromDC(hdcOptionalForPainting)) == NULL)
            return FALSE;

        switch (GetClipBox(hdcOptionalForPainting, &rcClip))
        {
        default:
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rcLimit, 2);
            if (IntersectRect(&rcCallback, &rcClip, &rcLimit))
                break;
            //fall thru
        case NULLREGION:
             return TRUE;
        case ERROR:
             return FALSE;
        }

        rcLimit = rcCallback;
    }

    if (!lprcEnumMonitorsThatIntersect ||
        IntersectRect(&rcCallback, lprcEnumMonitorsThatIntersect, &rcLimit))
    {
        lpfnEnumProc(xPRIMARY_MONITOR, hdcOptionalForPainting, &rcCallback,
            lData);
    }

    return TRUE;
}

#undef xPRIMARY_MONITOR
#undef COMPILE_MULTIMON_STUBS

#else	// COMPILE_MULTIMON_STUBS

extern int	WINAPI xGetSystemMetrics(int);
extern HMONITOR WINAPI xMonitorFromWindow(HWND, UINT);
extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, UINT);
extern HMONITOR WINAPI xMonitorFromPoint(POINT, UINT);
extern BOOL	WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);
extern BOOL	WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);

#endif	// COMPILE_MULTIMON_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define GetSystemMetrics    xGetSystemMetrics
#define MonitorFromWindow   xMonitorFromWindow
#define MonitorFromRect     xMonitorFromRect
#define MonitorFromPoint    xMonitorFromPoint
#define GetMonitorInfo      xGetMonitorInfo
#define EnumDisplayMonitors xEnumDisplayMonitors

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\sink.cpp ===
// FrameworkNotifySink.cpp: implementation of the CFrameworkNotifySink class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include "sink.h"
#include "mbutton.h"
#include "resource.h"
#include "mmenu.h"
#include "shellico.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

HWND CFrameworkNotifySink::m_hwndTitle = NULL;
extern BOOL fPlaying;
extern BOOL fIntro;
extern BOOL fShellMode;
extern HPALETTE hpalMain; //main palette of app
extern LPCDOPT g_pOptions;
extern LPCDDATA g_pData;
extern HWND hwndMain;

CFrameworkNotifySink::CFrameworkNotifySink(PCOMPNODE pNode)
{
    m_dwRef = 0;
    m_pNode = pNode;

   LoadString(NULL,IDS_APPNAME,m_szAppName,sizeof(m_szAppName)/sizeof(TCHAR));
}

CFrameworkNotifySink::~CFrameworkNotifySink()
{
}

HRESULT CFrameworkNotifySink::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return S_OK;
}

ULONG CFrameworkNotifySink::AddRef()
{
    return (m_dwRef++);
}

ULONG CFrameworkNotifySink::Release()
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}

HRESULT CFrameworkNotifySink::OnEvent(MMEVENTS mmEventID, LPVOID pEvent)
{
    HRESULT hr = S_OK;

    switch (mmEventID)
    {
        case (MMEVENT_SETTITLE) :
        {
            MMSETTITLE* pSetTitle = (MMSETTITLE*)pEvent;
            if (pSetTitle->mmInfoText == MMINFOTEXT_TITLE)
            {
                if (m_hwndTitle)
                {
                    _tcscpy(m_pNode->szTitle,pSetTitle->szTitle);
                    TCHAR szText[MAX_PATH];
                    wsprintf(szText,TEXT("%s - %s"),pSetTitle->szTitle,m_szAppName);

                    //only do this if the titles don't match
                    TCHAR szOrgTitle[MAX_PATH];
                    GetWindowText(m_hwndTitle,szOrgTitle,sizeof(szOrgTitle)/sizeof(TCHAR));
                    if (_tcscmp(szOrgTitle,szText)!=0)
                    {
                        SetWindowText(m_hwndTitle,szText);
                        RedrawWindow(m_hwndTitle,NULL,NULL,RDW_FRAME|RDW_INVALIDATE);

                        if (fShellMode)
                        {
                            ShellIconSetTooltip();
                        } //end if shell mode
                    }
                } //end if window ok
            } //end if title

            if (pSetTitle->mmInfoText == MMINFOTEXT_DESCRIPTION)
            {
                if (IsIconic(m_hwndTitle))
                {
                    TCHAR szText[MAX_PATH];
                    wsprintf(szText,TEXT("%s - %s"),pSetTitle->szTitle,m_szAppName);
                    SetWindowText(m_hwndTitle,szText);
                }

                if (fShellMode)
                {
                    ShellIconSetTooltip();
                }
            } //end if description
        }
        break;
           
        case (MMEVENT_ONPLAY) :
        {
			CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
			    if (fIntro)
                {
                    pButton->SetIcon(IDI_MODE_INTRO);
                    pButton->SetToolTipID(IDB_TT_INTRO);
                }
                else
                {
                    pButton->SetIcon(IDI_ICON_PAUSE);
                    pButton->SetToolTipID(IDB_TT_PAUSE);
                }
            }

            if (fShellMode)
            {
                ShellIconSetState(PAUSE_ICON);
            } //end if shell mode

			SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS);
            
            fPlaying = TRUE;
        }
        break;

        case (MMEVENT_ONSTOP) :
        {
            CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
                pButton->SetIcon(IDI_ICON_PLAY);
                pButton->SetToolTipID(IDB_TT_PLAY);
            }

			SetThreadExecutionState(ES_CONTINUOUS);

            fPlaying = FALSE;
            if (fShellMode)
            {
                ShellIconSetState(PLAY_ICON);
            } //end if shell mode
        }
        break;

        case (MMEVENT_ONPAUSE) :
        {
            CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
                pButton->SetIcon(IDI_ICON_PLAY);
                pButton->SetToolTipID(IDB_TT_PLAY);
            }

			SetThreadExecutionState(ES_CONTINUOUS);

            fPlaying = FALSE;
            if (fShellMode)
            {
                ShellIconSetState(PLAY_ICON);
            } //end if shell mode
        }
        break;

        case (MMEVENT_ONMEDIAUNLOADED) :
        {
            CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
                pButton->SetIcon(IDI_ICON_PLAY);
                pButton->SetToolTipID(IDB_TT_PLAY);
            }

			SetThreadExecutionState(ES_CONTINUOUS);

            fPlaying = FALSE;
            if (fShellMode)
            {
                ShellIconSetState(NODISC_ICON);
            } //end if shell mode
        }
        break;

        case (MMEVENT_ONUSERNOTIFY) :
        {
        }
        break;

        case (MMEVENT_ONDISCCHANGED) :
        {
            MMONDISCCHANGED* pDisc = (MMONDISCCHANGED*)pEvent;
            SendMessage(m_hwndTitle,WM_DISCCHANGED,pDisc->nNewDisc,pDisc->fDisplayVolChange);
        }
        break;
    }

    return hr;
}

void* CFrameworkNotifySink::GetCustomMenu()
{
    CustomMenu* pMenu = NULL;
    AllocCustomMenu(&pMenu);

    return (pMenu);
}

HPALETTE CFrameworkNotifySink::GetPalette()
{
    return hpalMain;
}

void* CFrameworkNotifySink::GetOptions()
{
    return ((void*)GetCDOpt());
}

void* CFrameworkNotifySink::GetData()
{
    return ((void*)GetCDData());
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetCDOpt
// Creates or returns the global CDOpt
////////////////////////////////////////////////////////////////////////////////////////////
LPCDOPT GetCDOpt()
{
    if (g_pOptions == NULL)
    {
        CDOPT_CreateInstance(NULL, IID_ICDOpt, (void**)&g_pOptions);
    }

    return g_pOptions;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetCDData
// Creates or returns the global CDOpt
////////////////////////////////////////////////////////////////////////////////////////////
LPCDDATA GetCDData()
{
    if (g_pData == NULL)
    {
        HRESULT hr = CDOPT_CreateInstance(NULL, IID_ICDData, (void**)&g_pData);
    }

    return g_pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmfw.rc
//
#define IDD_DOWNLOADPROGRESS            100
#define IDI_MMFW                        101
#define IDR_MMFW                        102
#define IDB_BACKGRND                    103
#define IDB_PLAY                        104
#define IDB_STOP                        105
#define IDB_EJECT                       106
#define IDB_REW                         107
#define IDB_FFWD                        108
#define IDB_PREVTRACK                   109
#define IDB_NEXTTRACK                   110
#define IDB_NDISC                       111
#define IDB_FRAME_TOOLKIT               112
#define IDB_CLOSE                       124
#define IDB_TRACK                       127
#define IDB_COVER                       128
#define IDB_NET                         129
#define IDB_DVDMAIN                     137
#define IDB_ALLTRANS                    140
#define IDB_DISC                        141
#define IDB_HELP                        142
#define IDB_OPTIONS                     143
#define IDB_MODE                        144
#define IDB_VOLUME_MINUS                145
#define IDB_VOLUME_PLUS                 146
#define IDB_VOLUME                      147
#define IDB_ALLTRANS_DOWN               148
#define IDB_ALLTRANS_HIGHLIGHT          150
#define IDB_MINIMIZE                    151
#define IDB_SET_TINY_MODE               152
#define IDB_SET_NORMAL_MODE             153
#define IDB_BUTTON_TOOLKIT              154
#define IDB_KNOB                        155
#define IDB_KNOB_LIGHT                  156
#define IDB_KNOB_LIGHTMASK              157
#define IDB_NOTCH                       158
#define IDB_KNOB_LIGHT_DIM              159
#define IDB_KNOB_TABSTATE               160
#define IDB_MUTE                        161
#define IDC_STATIC_INFO                 198
#define IDB_BUTTON_OVERLAYS             200
#define IDI_ICON_STOP                   202
#define IDI_ICON_EJECT                  203
#define IDI_ICON_REW                    204
#define IDI_ICON_FFWD                   205
#define IDI_ICON_PREV                   206
#define IDI_ICON_NEXT                   208
#define IDI_ICON_MODE                   209
#define IDI_ICON_COVER                  210
#define IDI_ICON_VMINUS                 212
#define IDI_ICON_VPLUS                  213
#define IDI_ICON_SYSTEM                 214
#define IDI_ICON_MINIMIZE               215
#define IDI_ICON_PAUSE                  216
#define IDI_ICON_PLAY                   217
#define IDC_VOLHAND                     219
#define IDC_VOLVERT                     220
#define IDC_VOLHORZ                     221
#define IDC_VOLDPOS                     222
#define IDC_VOLDNEG                     223
#define IDC_MUTE                        224

#define IDB_FRAME_TOOLKIT_16            300
#define IDB_BUTTON_TOOLKIT_16           301
#define IDB_KNOB_LIGHT_16               302
#define IDB_KNOB_LIGHT_DIM_16           303
#define IDB_KNOB_16                     304
#define IDB_KNOB_TABSTATE_16            305
#define IDB_NOTCH_16                    306

#define IDB_FRAME_TOOLKIT_HI            400
#define IDB_BUTTON_TOOLKIT_HI           401
#define IDB_KNOB_LIGHT_HI               402
#define IDB_KNOB_LIGHT_DIM_HI           403
#define IDB_KNOB_HI                     404
#define IDB_KNOB_TABSTATE_HI            405
#define IDB_NOTCH_HI                    406
#define IDI_MODE_NORMAL                 500
#define IDI_MODE_REPEATONE              501
#define IDI_MODE_REPEATALL              502
#define IDI_MODE_RANDOM                 503
#define IDI_MODE_INTRO                  504
#define IDI_SHELL_PLAY                  505
#define IDI_SHELL_PAUSE                 506
#define IDI_SHELL_NODISC                507

//note: do not use 10000 - 20000 for menu ids
#define IDM_NET_UPDATE                  30000
#define IDM_NET_CANCEL                  30001
#define IDM_NET_BAND                    30002
#define IDM_NET_CD                      30003
#define IDM_NET_BILLBOARD_ARTIST        30004
#define IDM_NET_BILLBOARD_ALBUM         30005
#define IDM_NET_ROLLINGSTONE_ARTIST     30006
#define LAST_SEARCH_MENU_ID             IDM_NET_ROLLINGSTONE_ARTIST
#define IDM_OPTIONS                     35000
#define IDM_PLAYLIST                    35001
#define IDM_HELP                        35002
#define IDM_ABOUT                       35003
#define IDM_NORMAL                      35004
#define IDM_TINY                        35005
#define IDM_EXIT                        35006
#define IDM_EXIT_SHELL                  35007
#define IDM_MODE_NORMAL                 36005
#define IDM_MODE_REPEATONE              36006
#define IDM_MODE_REPEATALL              36007
#define IDM_MODE_RANDOM                 36008
#define IDM_MODE_INTRO                  36009
#define IDC_METER                       45001
#define IDS_MBUTTON_FONT                57602
#define IDS_APPNAME                     57603
#define IDS_NOCOMPREGISTERED            57604
#define IDS_BADCOMPREGISTERED           57605
#define IDS_ERRORLOADINGCOMP            57606
#define IDS_NOTHINGREGISTERED           57607
#define IDS_HOMEPAGEFORMAT              57608
#define IDS_FOUND                       57609
#define IDS_NOTFOUND1                   57610
#define IDS_NOTFOUND                    57611
#define IDS_BADPROVIDER                 57612
#define IDS_BILLBOARD_FORMAT_ARTIST     57613
#define IDS_BILLBOARD_FORMAT_ALBUM      57614
#define IDS_TITLE_NOT_FOUND             57615
#define IDS_DB_FAILURE                  57616
#define IDS_REINSTALL                   57617
#define IDS_WAITINGFORDOWNLOAD          57618
#define IDS_ROLLINGSTONE_FORMAT_ARTIST  57619
#define IDS_NET_FAILURE                 57620
#define IDB_TT_PLAY                     58000
#define IDB_TT_PAUSE                    58001
#define IDB_TT_STOP                     58002
#define IDB_TT_EJECT                    58003
#define IDB_TT_REW                      58004
#define IDB_TT_FFWD                     58005
#define IDB_TT_PREVTRACK                58006
#define IDB_TT_NEXTTRACK                58007
#define IDB_TT_NDISC                    58008
#define IDB_TT_CLOSE                    58009
#define IDB_TT_TRACK                    58010
#define IDB_TT_MUTE                     58011
#define IDB_TT_NET                      58012
#define IDB_TT_DISC                     58013
#define IDB_TT_OPTIONS                  58014
#define IDB_TT_HELP                     58015
#define IDB_TT_MODE                     58016
#define IDB_TT_VOLUME                   58017
#define IDB_TT_MINIMIZE                 58018
#define IDB_TT_RESTORE                  58019
#define IDB_TT_MAXIMIZE                 58020
#define IDB_TT_INTRO                    58021
#define IDM_NET_SEARCH_HEADING          58030
#define IDM_NET_PROVIDER_HEADING        58040
#define IDS_SH_TRANS                    58050
#define IDS_SH_TRACK                    58051
#define IDS_SH_NET                      58052
#define IDS_SH_DISC                     58053
#define IDS_SH_OPTIONS                  58054
#define IDS_SH_MODE                     58055
#define IDS_SH_PLAY                     58056
#define IDS_SH_STOP                     58057
#define IDS_SH_PAUSE                    58058
#define IDS_SH_EJECT                    58059
#define IDS_SH_PREVTRACK                58060
#define IDS_SH_NEXTTRACK                58061
                   
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        218
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\shellico.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SHELLICO.CPP
//
//      Shell tray icon handler
//
//      Copyright (c) Microsoft Corporation     1998
//    
//      3/15/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include <shellapi.h>
#include "shellico.h"
#include "mmenu.h"
#include "resource.h"

#define IDM_HOMEMENU_BASE               (LAST_SEARCH_MENU_ID + 1)
#define IDM_NETMENU_BASE                (LAST_SEARCH_MENU_ID + 100)
#define IDM_DISCLIST_BASE               20000
#define SHELLTIMERID                    1500

//file-global variables
PCOMPNODE g_pNode = NULL;
IMMComponentAutomation* g_pAuto = NULL;
HWND g_hwnd = NULL;
HINSTANCE g_hInst = NULL;
BOOL g_fShellIconCreated = FALSE;

//icon
HICON hIconPlay = NULL;
HICON hIconPause = NULL;
HICON hIconNoDisc = NULL;

extern fOptionsDlgUp;
extern nCDMode;
extern BOOL fPlaying;
extern BOOL IsDownloading();
extern CustomMenu* g_pMenu;
extern "C" void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen);

void CheckDiscState()
{
    if (g_fShellIconCreated)
    {
        MMMEDIAID mmMedia;
        mmMedia.nDrive = -1;
        g_pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

        if (mmMedia.dwMediaID != 0)
        {
            ShellIconSetState(fPlaying ? PAUSE_ICON : PLAY_ICON);
        }
        else
        {
            ShellIconSetState(NODISC_ICON);
        }
    }
}

BOOL CreateShellIcon(HINSTANCE hInst, HWND hwndOwner, PCOMPNODE pNode, TCHAR* sztip)
{
    BOOL retval = FALSE;
    g_hInst = hInst;

	HRESULT hr = pNode->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&g_pAuto);
    if (SUCCEEDED(hr))
    {
        g_pNode = pNode;

        //load all of the icon images
        hIconPlay = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SHELL_PLAY), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        hIconPause = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SHELL_PAUSE), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        hIconNoDisc = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SHELL_NODISC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

        //now, create the tray icon
        g_hwnd = hwndOwner;
        NOTIFYICONDATA nData;
        nData.cbSize = sizeof(nData);
        nData.hWnd = hwndOwner;
        nData.uID = SHELLMESSAGE_CDICON;
        nData.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        nData.uCallbackMessage = SHELLMESSAGE_CDICON;
        nData.hIcon = hIconPlay;
        _tcscpy(nData.szTip,sztip);

        retval = Shell_NotifyIcon(NIM_ADD,&nData);

        if (!retval)
        {
            g_pAuto->Release();
            g_pAuto = NULL;
        }
        else
        {
            g_fShellIconCreated = TRUE;
            CheckDiscState();
        }
    }

    return (retval);
}

void DestroyShellIcon()
{
    g_fShellIconCreated = FALSE;

    if (g_pAuto)
    {
        //g_pAuto was addref'ed when we qi'ed for it.
        g_pAuto->Release();
    }

    NOTIFYICONDATA nData;
    nData.cbSize = sizeof(nData);
    nData.uID = SHELLMESSAGE_CDICON;
    nData.hWnd = g_hwnd;
    Shell_NotifyIcon(NIM_DELETE,&nData);

    //kill the icons
    DestroyIcon(hIconPlay);
    DestroyIcon(hIconPause);
    DestroyIcon(hIconNoDisc);

    hIconPlay = NULL;
    hIconPause = NULL;
    hIconNoDisc = NULL;
}

//works around bug in all Windows versions
//where ampersands are stripped from tooltips on shell icon
void EscapeTooltip(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen)
{
    ZeroMemory(szOutput,cbLen);
    WORD index1 = 0;
    WORD index2 = 0;
    for (; ((index1 < _tcslen(szInput)) && (index2 < ((cbLen/sizeof(TCHAR))-1))); index1++)
    {
        szOutput[index2] = szInput[index1];
        if (szOutput[index2] == TEXT('&'))
        {
            szOutput[++index2] = TEXT('&');
            szOutput[++index2] = TEXT('&');
        }
        index2++;
    }
}

void ShellIconSetTooltip()
{
    if (g_fShellIconCreated)
    {
        NOTIFYICONDATA nData;
        nData.cbSize = sizeof(nData);
        nData.hWnd = g_hwnd;
        nData.uID = SHELLMESSAGE_CDICON;
        nData.uFlags = NIF_TIP;

        MMMEDIAID mmMedia;
        mmMedia.nDrive = -1;
        mmMedia.szTrack[0] = TEXT('\0');
        g_pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

        TCHAR szTempTip[MAX_PATH+sizeof(TCHAR)];
        TCHAR szEscapeTip[MAX_PATH+sizeof(TCHAR)];

        if ((mmMedia.dwMediaID != 0) || (_tcslen(mmMedia.szTrack)!=0))
        {
            //128 + 128 + 4 = 260 ... that's max_path
            wsprintf(szTempTip,TEXT("%s (%s)"),mmMedia.szTitle,mmMedia.szTrack);
        }
        else
        {
            _tcscpy(szTempTip,mmMedia.szTitle);
        }
        
        //escape out & symbols if they are in the string
        if (_tcschr(szTempTip,TEXT('&')))
        {
            EscapeTooltip(szTempTip,szEscapeTip,sizeof(szEscapeTip));
            _tcscpy(szTempTip,szEscapeTip);
        }

        //truncate long tip to size of tooltip
        szTempTip[(sizeof(nData.szTip)/sizeof(TCHAR))-1] = TEXT('\0');
        _tcscpy(nData.szTip,szTempTip);

        Shell_NotifyIcon(NIM_MODIFY,&nData);

        //bit of a hack, but if we're getting a new tool tip, then we might be need to turn
        //on or off the "nodisc" state
        CheckDiscState();
    }
}

void CreateTransportMenu(CustomMenu* pMenu, CustomMenu* pTransMenu)
{
    //play or pause
    if (fPlaying)
    {
        pTransMenu->AppendMenu(IDB_PLAY,g_hInst,IDS_SH_PAUSE);
    }
    else
    {
        pTransMenu->AppendMenu(IDB_PLAY,g_hInst,IDS_SH_PLAY);
    }

    //stop
    pTransMenu->AppendMenu(IDB_STOP,g_hInst,IDS_SH_STOP);

    //eject
    pTransMenu->AppendMenu(IDB_EJECT,g_hInst,IDS_SH_EJECT);

    //previous track
    pTransMenu->AppendMenu(IDB_PREVTRACK,g_hInst,IDS_SH_PREVTRACK);

    //next track
    pTransMenu->AppendMenu(IDB_NEXTTRACK,g_hInst,IDS_SH_NEXTTRACK);

    pMenu->AppendMenu(g_hInst,IDS_SH_TRANS,pTransMenu);
}

void CreateOptionsMenu(CustomMenu* pMenu, CustomMenu* pOptionsMenu)
{
    pOptionsMenu->AppendMenu(IDM_OPTIONS,g_hInst,IDM_OPTIONS);
    pOptionsMenu->AppendMenu(IDM_PLAYLIST,g_hInst,IDM_PLAYLIST);
    pOptionsMenu->AppendSeparator();

//do not bother graying out the playlist menu, it causes too much delay in odbc load
/*
    LPCDDATA pData = GetCDData();
    if (pData)
    {
        if (FAILED(pData->CheckDatabase(g_hwnd)))
        {
            EnableMenuItem(pOptionsMenu->GetMenuHandle(),
                            IDM_PLAYLIST,
                            MF_BYCOMMAND | MF_GRAYED);
        }
    }
*/

    pOptionsMenu->AppendMenu(IDM_HELP,g_hInst,IDM_HELP);

    pMenu->AppendMenu(g_hInst,IDS_SH_OPTIONS,pOptionsMenu);
}

void CreateModeMenu(CustomMenu* pMenu, CustomMenu* pModeMenu)
{
    pModeMenu->AppendMenu(IDM_MODE_NORMAL,g_hInst,IDI_MODE_NORMAL,IDM_MODE_NORMAL);
    pModeMenu->AppendMenu(IDM_MODE_RANDOM,g_hInst,IDI_MODE_RANDOM,IDM_MODE_RANDOM);
    pModeMenu->AppendMenu(IDM_MODE_REPEATONE,g_hInst,IDI_MODE_REPEATONE,IDM_MODE_REPEATONE);
    pModeMenu->AppendMenu(IDM_MODE_REPEATALL,g_hInst,IDI_MODE_REPEATALL,IDM_MODE_REPEATALL);
    pModeMenu->AppendMenu(IDM_MODE_INTRO,g_hInst,IDI_MODE_INTRO,IDM_MODE_INTRO);
    pModeMenu->SetMenuDefaultItem(nCDMode,FALSE);

    pMenu->AppendMenu(g_hInst,IDS_SH_MODE,pModeMenu);
}

void CreateNetMenu(CustomMenu* pMenu, CustomMenu* pNetMenu, CustomMenu* pSearchSubMenu, CustomMenu* pProviderSubMenu)
{
	MMMEDIAID mmMedia;
    mmMedia.nDrive = -1;
	g_pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

    BOOL fContinue = TRUE;

    //append static menu choices
    if (IsDownloading())
    {
        pNetMenu->AppendMenu(IDM_NET_CANCEL,g_hInst,IDM_NET_CANCEL);
    }
    else
    {
        pNetMenu->AppendMenu(IDM_NET_UPDATE,g_hInst,IDM_NET_UPDATE);
        if (mmMedia.dwMediaID == 0)
        {
            //need to gray out menu
            MENUITEMINFO mmi;
            mmi.cbSize = sizeof(mmi);
            mmi.fMask = MIIM_STATE;
            mmi.fState = MFS_GRAYED;
            HMENU hMenu = pNetMenu->GetMenuHandle();
            SetMenuItemInfo(hMenu,IDM_NET_UPDATE,FALSE,&mmi);
        }
    }
	
    //if networking is not allowed, gray it out ...
    //don't worry about cancel case, it won't be there
    LPCDDATA pData = GetCDData();
    if (mmMedia.dwMediaID != 0)
    {
        //don't allow searching if title isn't available
        if (pData)
        {
            if (pData->QueryTitle(mmMedia.dwMediaID))
            {
                pSearchSubMenu->AppendMenu(IDM_NET_BAND,g_hInst,IDM_NET_BAND);
                pSearchSubMenu->AppendMenu(IDM_NET_CD,g_hInst,IDM_NET_CD);
                pSearchSubMenu->AppendMenu(IDM_NET_ROLLINGSTONE_ARTIST,g_hInst,IDM_NET_ROLLINGSTONE_ARTIST);
                pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ARTIST,g_hInst,IDM_NET_BILLBOARD_ARTIST);
                pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ALBUM,g_hInst,IDM_NET_BILLBOARD_ALBUM);
                pNetMenu->AppendMenu(g_hInst,IDM_NET_SEARCH_HEADING,pSearchSubMenu);
            }
        } //end if pdata
    }

    //display any provider home pages
    DWORD i = 0;
    LPCDOPT pOpt = GetCDOpt();
    if( pOpt )
    {
        LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

        LPCDPROVIDER pProviderList = pCDOpts->pProviderList;

        while (pProviderList!=NULL)
        {
            TCHAR szProviderMenu[MAX_PATH];
            TCHAR szHomePageFormat[MAX_PATH/2];
            LoadString(g_hInst,IDS_HOMEPAGEFORMAT,szHomePageFormat,sizeof(szHomePageFormat)/sizeof(TCHAR));
            wsprintf(szProviderMenu,szHomePageFormat,pProviderList->szProviderName);

            pProviderSubMenu->AppendMenu(IDM_HOMEMENU_BASE+i,szProviderMenu);

            pProviderList = pProviderList->pNext;
            i++;
        } //end while

        pNetMenu->AppendMenu(g_hInst,IDM_NET_PROVIDER_HEADING,pProviderSubMenu);
    } //end home pages

    //display internet-loaded disc menus
    if (mmMedia.dwMediaID != 0)
    {
        if (pData)
        {
            if (pData->QueryTitle(mmMedia.dwMediaID))
            {
                LPCDTITLE pCDTitle = NULL;
                HRESULT hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (SUCCEEDED(hr))
                {
                    for (i = 0; i < pCDTitle->dwNumMenus; i++)
                    {
                        if (i==0)
                        {
                            pNetMenu->AppendSeparator();
                        }

                        TCHAR szDisplayNet[MAX_PATH];
                        NormalizeNameForMenuDisplay(pCDTitle->pMenuTable[i].szMenuText,szDisplayNet,sizeof(szDisplayNet));
            	        pNetMenu->AppendMenu(i + IDM_NETMENU_BASE,szDisplayNet);
                    }

                    pData->UnlockTitle(pCDTitle,FALSE);
                }
            } //end if query title
        }
    }

    pMenu->AppendMenu(g_hInst,IDS_SH_NET,pNetMenu);
}

void CreateTrackMenu(CustomMenu* pMenu, CustomMenu* pTrackMenu)
{
    int i = 0;
    HRESULT hr = S_OK;
    while (SUCCEEDED(hr))
    {
		MMTRACKORDISC mmTrack;
        mmTrack.nNumber = i++;
        hr = g_pAuto->OnAction(MMACTION_GETTRACKINFO,&mmTrack);
        if (SUCCEEDED(hr))
        {
            pTrackMenu->AppendMenu(mmTrack.nID + IDM_TRACKLIST_SHELL_BASE, mmTrack.szName);
            if (mmTrack.fCurrent)
            {
                pTrackMenu->SetMenuDefaultItem(mmTrack.nID + IDM_TRACKLIST_SHELL_BASE,FALSE);
            } //end if current
        } //end if ok
    } //end while

    pMenu->AppendMenu(g_hInst,IDS_SH_TRACK,pTrackMenu);
}

void CreateDiscMenu(CustomMenu* pMenu, CustomMenu* pDiscMenu)
{
    int i = 0;
    HRESULT hr = S_OK;
    while (SUCCEEDED(hr))
    {
        MMTRACKORDISC mmDisc;
        mmDisc.nNumber = i++;
        hr = g_pAuto->OnAction(MMACTION_GETDISCINFO,&mmDisc);
        if (SUCCEEDED(hr))
        {
            pDiscMenu->AppendMenu(mmDisc.nID + IDM_DISCLIST_BASE, mmDisc.szName);
            if (mmDisc.fCurrent)
            {
                pDiscMenu->SetMenuDefaultItem(mmDisc.nID + IDM_DISCLIST_BASE,FALSE);
            } //end if current
        }
    }

    pMenu->AppendMenu(g_hInst,IDS_SH_DISC,pDiscMenu);
}

void CALLBACK lButtonTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    KillTimer(hwnd,idEvent);

    if (fPlaying)
    {
        g_pAuto->OnAction(MMACTION_PAUSE,NULL);
        //ShellIconSetState(PLAY_ICON);
    }
    else
    {
        g_pAuto->OnAction(MMACTION_PLAY,NULL);
        //ShellIconSetState(PAUSE_ICON);
    }
}

LRESULT ShellIconHandeMessage(LPARAM lParam)
{
    switch (lParam)
    {
        case (WM_LBUTTONDOWN) :
        {
            SetTimer(g_hwnd,SHELLTIMERID,GetDoubleClickTime()+100,(TIMERPROC)lButtonTimerProc);
        }
        break;

        case (WM_LBUTTONDBLCLK) :
        {
            KillTimer(g_hwnd,SHELLTIMERID);
            
            if ((IsWindowVisible(g_hwnd)) && (!IsIconic(g_hwnd)))
            {
                ShowWindow(g_hwnd,SW_HIDE);
            }
            else
            {
                if (IsIconic(g_hwnd))
                {
                    ShowWindow(g_hwnd,SW_RESTORE);
                }

                ShowWindow(g_hwnd,SW_SHOW);
		        BringWindowToTop(g_hwnd);
		        SetForegroundWindow(g_hwnd);
            }
        }
        break;

        case (WM_RBUTTONUP) :
        {
            if (!fOptionsDlgUp)
            {
                CustomMenu* pTrackMenu = NULL;
                CustomMenu* pDiscMenu = NULL;
                CustomMenu* pOptionsMenu = NULL;
                CustomMenu* pNetMenu = NULL;
                CustomMenu* pSearchSubMenu = NULL;
                CustomMenu* pProviderSubMenu = NULL;
                CustomMenu* pModeMenu = NULL;
                CustomMenu* pTransMenu = NULL;

                AllocCustomMenu(&g_pMenu);
                AllocCustomMenu(&pTrackMenu);
                AllocCustomMenu(&pDiscMenu);
                AllocCustomMenu(&pOptionsMenu);
                AllocCustomMenu(&pNetMenu);
                AllocCustomMenu(&pSearchSubMenu);
                AllocCustomMenu(&pProviderSubMenu);
                AllocCustomMenu(&pModeMenu);
                AllocCustomMenu(&pTransMenu);

                if (g_pMenu)
                {
                    g_pMenu->AppendMenu(IDM_ABOUT,g_hInst,IDM_ABOUT);
                    g_pMenu->AppendSeparator();

                    CreateTransportMenu(g_pMenu,pTransMenu);
                    CreateOptionsMenu(g_pMenu,pOptionsMenu);
                    CreateNetMenu(g_pMenu,pNetMenu,pSearchSubMenu,pProviderSubMenu);
                    CreateModeMenu(g_pMenu,pModeMenu);
                    CreateDiscMenu(g_pMenu,pDiscMenu);
                    CreateTrackMenu(g_pMenu,pTrackMenu);

                    g_pMenu->AppendSeparator();
                    g_pMenu->AppendMenu(IDM_EXIT_SHELL,g_hInst,IDM_EXIT);

                    POINT mouse;
                    GetCursorPos(&mouse);
                    RECT rect;
                    SetRect(&rect,0,0,0,0);
                    SetForegroundWindow(g_hwnd);
                    g_pMenu->TrackPopupMenu(0,mouse.x,mouse.y,g_hwnd,&rect);

                    pTrackMenu->Destroy();
                    pDiscMenu->Destroy();
                    pOptionsMenu->Destroy();
                    pNetMenu->Destroy();
                    pSearchSubMenu->Destroy();
                    pProviderSubMenu->Destroy();
                    pModeMenu->Destroy();
                    pTransMenu->Destroy();
                }

                if (g_pMenu)
                {
                    g_pMenu->Destroy();
                    g_pMenu = NULL;
                }
            } //end if ok to do
            else
            {
                MessageBeep(0);
            }
        } //end right-button up
        break;
    }

    return 0;
}

void ShellIconSetState(int nIconType)
{
    if (g_fShellIconCreated)
    {
        int iID = IDI_SHELL_PLAY;
        HICON hIcon = hIconPlay;
    
        switch(nIconType)
        {
            case PAUSE_ICON : 
            {
                iID = IDI_SHELL_PAUSE;
                hIcon = hIconPause;
            }
            break;

            case NODISC_ICON :
            {
                iID = IDI_SHELL_NODISC;
                hIcon = hIconNoDisc;
            }
            break;
        }
   
        NOTIFYICONDATA nData;
        nData.cbSize = sizeof(nData);
        nData.hWnd = g_hwnd;
        nData.uID = SHELLMESSAGE_CDICON;
        nData.uFlags = NIF_ICON;
        nData.hIcon = hIcon;

        Shell_NotifyIcon(NIM_MODIFY,&nData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:    DPlay.DLL initialization
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *
 ***************************************************************************/
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>

/*
 * list of processes attached to DLL
 */
HINSTANCE               hModule;

CRITICAL_SECTION g_critSection = {0};

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    hModule = hmod;

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
	DisableThreadLibraryCalls( hmod );

	InitializeCriticalSection( &g_critSection ); 
	break;

    case DLL_PROCESS_DETACH:
	break;

	DeleteCriticalSection(&g_critSection);
    default:
	break;
    }

    return TRUE;

} /* DllMain */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dpcreate.cpp ===
// =================================================================
//
//  MODULE: Direct Play Interface Routines
//
//  DESCRIPTION:
//  Functions to create and enumerate the Direct Connect services
//  available.
//
//  FILENAME: dpcreate.cpp
//
// =================================================================

//** include files **
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>

#include "dplayi.h"
#include "dpimp.h"
#include <logit.h>


#define MAX_NUMBER_SP   32
typedef struct
{
    GUID    guid;
    char    chShortName[MAX_PATH];
    char    chPathName[MAX_PATH];
    char    chDescription[MAX_PATH];
} ENUM_ELEMENT;

ENUM_ELEMENT eeList[MAX_NUMBER_SP];
int iFound = 0;



// -----------------------------------------------------------------
//  DirectConnectCreate - load DCO service and return pointer to
//  function table.
// -----------------------------------------------------------------

HRESULT WINAPI DirectPlayCreate( LPGUID lpGuid, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter )
{
    int ii;
    HRESULT     hr;


    TSHELL_INFO(TEXT("DirectPlayCreate called."));


    if (pUnkOuter != NULL)
    {
        return(CLASS_E_NOAGGREGATION);
    }

    if (   ! lplpDP
        || IsBadWritePtr(lplpDP, sizeof(LPDIRECTPLAY))
        || ! lpGuid
        || IsBadWritePtr(lpGuid, sizeof(GUID)))
        {
            TSHELL_INFO(TEXT("Random Error"));
            return(DPERR_INVALIDPARAM);
        }

    if (iFound == 0)
    {
        // Someone didn't call enumerate first.  We do that here with
        // a null callback.
        DirectPlayEnumerate( NULL, NULL);
    }


    for (ii = 0; ii < iFound; ii++)
        if (IsEqualGUID((REFGUID) eeList[ii].guid, (REFGUID) *lpGuid))
        {
            TSHELL_INFO(TEXT("Open SP."));
            _try
            {
                hr = CImpIDirectPlay::NewCImpIDirectPlay(lpGuid, lplpDP,
                        eeList[ii].chPathName);
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                TSHELL_INFO(TEXT("Exception encountered in SP create."));
                hr = DPERR_EXCEPTION;
                *lplpDP = NULL;
            }
#ifdef DEBUG
            if (hr == DP_OK)
                TSHELL_INFO(TEXT("We are returning success."));
#endif

            return(hr);
        }

    TSHELL_INFO(TEXT("No Matches"));
    return(DPERR_UNAVAILABLE);
}

// -----------------------------------------------------------------
//  DirectConnectEnumerate - envoke a callback routine with the name
//  of each DCO service provider.
// -----------------------------------------------------------------


int GetDigit(LPSTR lpStr)
{
    char ch = *lpStr;

    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
void StringToGUID(LPSTR lpStr, LPBYTE lpb)
{
    DWORD ii, jj;

    jj = 1;
    for (ii = 0; ii < 16; ii++, jj += 2)
    {
        lpb[ii] = GetDigit(&lpStr[jj]) * 16 + GetDigit(&lpStr[jj + 1]);
    }
}
void GUIDToString(LPBYTE lpb, LPSTR lpStr)
{
    DWORD jj;

    lpStr[ 0]  = '{';

    for (jj = 0; jj < 16; jj++)
    {
        wsprintf( &lpStr[(2*jj)+1], "%2x", lpb[jj]);
        if (lpStr[(2*jj)+1] == ' ')
            lpStr[(2*jj)+1] = '0';
        if (lpStr[(2*jj)+2] == ' ')
            lpStr[(2*jj)+2] = '0';
    }
    lpStr[33] = '}';
    lpStr[34] = 0x00;
}

HRESULT WINAPI DirectPlayEnumerate( LPDPENUMDPCALLBACK lpCallback, LPVOID lpContext )
{
    BOOL    bReg = FALSE;
    HKEY    hkRoot;
    HKEY    hkService;
    int     ii;
    FILETIME ft;
    DWORD   cb, cbGuid, cbPath, cbDesc;
    LONG            lReturn;
    BOOL    bCont = TRUE;
    HRESULT hr = DP_OK;
    char    chPath[MAX_PATH];
    DWORD   dwType;

    iFound = 0;

    cb             = MAX_PATH;
    cbGuid         = sizeof(GUID);
    cbPath         = MAX_PATH;
    cbDesc         = MAX_PATH;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, DPLAY_SERVICE, 0, KEY_READ, &hkRoot ) == ERROR_SUCCESS )
    {
        ii = 0;
        while (   bCont && (lReturn =
                               RegEnumKeyEx(hkRoot,
                                            ii,
                                            eeList[iFound].chShortName,
                                            &cb,
                                            NULL, NULL, NULL, &ft))
                                            == ERROR_SUCCESS)
        {
            ii++;
            TSHELL_INFO(TEXT("Enumeration success."));
            if (RegOpenKeyEx( hkRoot, eeList[iFound].chShortName, 0, KEY_READ, &hkService) == ERROR_SUCCESS)
            {

                DBG_INFO((DBGARG,TEXT("Open %s Succeeded.. Element %d"),
                            eeList[iFound].chShortName, iFound));

                if (  (RegQueryValueEx( hkService, DPLAY_PATH, NULL, &dwType,
                                        (UCHAR *) eeList[iFound].chPathName,
                                        &cbPath) == ERROR_SUCCESS)
                   && (RegQueryValueEx( hkService, DPLAY_DESC, NULL, NULL,
                                        (UCHAR *) eeList[iFound].chDescription,
                                        &cbDesc) == ERROR_SUCCESS)
                   )
                {
                    if (dwType == REG_EXPAND_SZ)
                    {
                        lstrcpy( chPath, eeList[iFound].chPathName);

                        ExpandEnvironmentStrings( chPath, eeList[iFound].chPathName,
                            MAX_PATH);

                        DBG_INFO(( DBGARG, TEXT("Path (%s)"), eeList[iFound].chPathName));
                    }

                    StringToGUID(eeList[iFound].chShortName, (LPBYTE) &eeList[iFound].guid);
                    iFound++;
                    if (lpCallback)
                    {
                        _try
                        {
                            bCont = (*lpCallback)( &eeList[iFound -1].guid, eeList[iFound -1].chDescription,
                                DPVERSION_MAJOR, DPVERSION_MINOR, lpContext );
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            TSHELL_INFO(TEXT("Exception encountered in session callback."));
                            bCont = FALSE;
                            hr = DPERR_EXCEPTION;
                        }
                    }
                    DBG_INFO(( DBGARG, TEXT("Name (%s), Description(%s)"),
                            eeList[iFound -1].chShortName, eeList[iFound -1].chDescription));
                }
#ifdef DEBUG
                else
                {
                    TSHELL_INFO(TEXT("Error, no Callback"));
                    if (   (RegQueryValueEx( hkService, DPLAY_GUID, NULL, NULL,
                                        (UCHAR *) &eeList[iFound].guid,
                                        &cbGuid) != ERROR_SUCCESS))

                    {
                        DBG_INFO((DBGARG, TEXT("Didn't Read %s L %d"), DPLAY_GUID, cbGuid));
                    }
                    if ((RegQueryValueEx( hkService, DPLAY_PATH, NULL, NULL,
                                        (UCHAR *) eeList[iFound].chPathName,
                                        &cbPath) != ERROR_SUCCESS))
                    {
                        DBG_INFO((DBGARG, TEXT("Didn't Read %s L %d"), DPLAY_PATH, cbGuid));
                    }

                    if (RegQueryValueEx( hkService, DPLAY_DESC, NULL, NULL,
                                        (UCHAR *) eeList[iFound].chDescription,
                                        &cbDesc) != ERROR_SUCCESS)
                    {
                        DBG_INFO((DBGARG, TEXT("Didn't Read %s L %d"), DPLAY_DESC, cbGuid));
                    }
                }
#endif
               RegCloseKey(hkService);
           }
           else
           {
               DBG_INFO((DBGARG, TEXT("Open %s Failed. Element %d"),
                    eeList[iFound].chShortName, iFound));
           }

           cb             = MAX_PATH;
           cbGuid         = sizeof(GUID);
           cbPath         = MAX_PATH;
           cbDesc         = MAX_PATH;
           if (iFound >= MAX_NUMBER_SP)
               bCont = FALSE;
        }
        DBG_INFO((DBGARG, TEXT("End Enumeration at %d providers. Return %d"), ii, lReturn));
        RegCloseKey(hkRoot);
        return(hr);
    }
    else
    {
        return(DPERR_GENERIC);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dpspimp.h ===
// Direct Play object class implementation

#ifndef _DP_SPIMP_H
#define _DP_SPIMP_H

#include <winsock.h>
#include "dplay.h"

// Begin: declaration of main implementation class for IDirectPlay


typedef struct
{
    IDirectPlaySP  *pThis;
    LPDPSESSIONDESC lpSDesc;
} SRV_START;


class CImpIDP_SP : public IDirectPlaySP {
public:
    // IUnknown methods
    // IDirectPlay methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID iid, LPVOID *ppvObj );
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
    virtual ULONG STDMETHODCALLTYPE Release( void );

    virtual HRESULT STDMETHODCALLTYPE AddPlayerToGroup(
                                            DPID dwDPIDGroup,
                                            DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE Close(void);
    virtual HRESULT STDMETHODCALLTYPE CreatePlayer(
                                        LPDPID pPlayerID,
                                        LPSTR pNickName,
                                        LPSTR pFullName,
                                        LPHANDLE lpReceiveEvent,
                                        BOOL     bPlayer);

    virtual HRESULT STDMETHODCALLTYPE   DeletePlayerFromGroup(
                                        DPID DPid,
                                        DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE DestroyPlayer( DPID pPlayerID, BOOL );
    virtual HRESULT STDMETHODCALLTYPE EnumPlayers(
                                      DWORD dwSessionID,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumSessions(
                                       LPDPSESSIONDESC,
                                       LPDPENUMSESSIONSCALLBACK EnumCallback,
                                       LPVOID,
                                       DWORD);

    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetMessageCount(DPID pidPlayer, LPDWORD lpdwCount);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerCaps(
                                        DPID dwDPId,
                                        LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerName(DPID dpID,
                          LPSTR lpFriendlyName,          // buffer to hold name
                          LPDWORD pdwFriendlyNameLength, // length of name buffer
                          LPSTR lpFormalName,
                          LPDWORD pdwFormalNameLength
                          );


    virtual HRESULT STDMETHODCALLTYPE InvitePlayer(DWORD dwEnumPlayerID,
                                                   DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE Open(
                        LPDPSESSIONDESC lpSDesc, HANDLE hEvent);

    virtual HRESULT STDMETHODCALLTYPE Receive(
                                LPDPID from,
                                LPDPID to,
                                DWORD  dwReceiveFlags,
                                LPVOID,
                                LPDWORD);

    virtual HRESULT STDMETHODCALLTYPE SavePlayer(DPID dwPlayerID);
    virtual HRESULT STDMETHODCALLTYPE SaveSession();

    virtual HRESULT STDMETHODCALLTYPE Send(
                                DPID from,
                                DPID to,
                                DWORD dwFlags,
                                LPVOID lpvMsg,
                                DWORD dwLength);
    virtual HRESULT STDMETHODCALLTYPE SetPlayerName(
                                DPID from,
                                LPSTR lpFriendlyName,          
                                LPSTR lpFormalName,
                                BOOL  bPlayer);



   static CImpIDP_SP* NewCImpIDP_SP();

   DWORD  NameServer(LPDPSESSIONDESC lpSDesc);


protected:
    void Lock();
    void Unlock();

private:
    CImpIDP_SP(void);
   ~CImpIDP_SP(void);
    int              m_refCount;
    CRITICAL_SECTION m_critSection;
    DPCAPS           m_dpcaps;
    SRV_START        m_Srv;
    HANDLE           m_hNameThread;

};

// End  : declaration of main implementation class for IDirectPlay


/****************************************************************************
 *
 * DIRECTPLAY MESSAGES
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/





typedef USHORT SPID, FAR *LPSPID;
typedef USHORT FAR *LPUSHORT;

#define SYS_MSG     0x8000
typedef struct
{
    USHORT  usCookie;       // Either particular game ID (random)
                            // Well known value (Enum Current Games)
    union
    {
        struct
        {
            SPID    from;
            SPID    to;
            
        } playerMsg;
        struct
        {
            USHORT usType;
            SPID   from;
        } sysMsg;
    } u;
    USHORT  fMsg;
    union
    {
        USHORT  uscBuffer;
        SPID    pid;
        USHORT  usCount;
    };
} DPHDR;

#define SP_ENUM_COOKIE     0x794b

#define SPT_ENUM           0x6172  // '4b797261' == 'Kyra' Born 10/21/94
#define SPT_OPEN           0x0001

typedef struct
{
    DPHDR           dpHdr;
    DPSESSIONDESC   dpSessionDesc;
} SPMSG_ENUM;

#define SPT_ENUM_REPLY     0x0002

typedef struct
{
    DPHDR           dpHdr;
    USHORT          usPort;
} SPMSG_ENUM_REPLY;



#define SPT_ADDPLAYER      0x0003
#define SPT_ENUMPLAYER     0x0008
#define SPT_GETPLAYER      0x0009
#define SPT_SETPLAYER      0x000f

typedef struct
{
    DPHDR           dpHdr;
    BOOL            bGroup;
    SPID            pid;
    char            chLongName[50];
    char            chShortName[20];
} SPMSG_ADDPLAYER;

#define SPT_REJECTPLAYER   0x0004
#define SPT_DELETEPLAYER   0x0005  // also group, use DPHDR.
#define SPT_PLAYERCOUNT    0x0006  // use DPHDR, usCount
#define SPT_ADDPLAYERTOGRP 0x0007
#define SPT_ENUMGROUP      0x000b

typedef struct
{
    DPHDR   dpHdr;
    SPID    pidGroup;
    SPID    pidPlayer;
} SPMSG_GROUPADD;

#define SPT_PING           0x000c  // DPHDR back at player.

#define SPT_INVITE         0x000e

typedef struct
{
    DPHDR   dpHdr;
    GUID    guid;
} SPMSG_INVITE;


#define SPT_GETPLAYERCAPS  0x000f

typedef struct
{
    DPHDR   dpHdr;
    DPCAPS  dpCaps;
} SPMSG_GETPLAYERCAPS;





// Enumeration Messages



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dplayi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:    DirectPlay include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ============
 *   07-jul-95  johnhall Making Program Management Dreams a Reality.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAYI_INCLUDED__
#define __DPLAYI_INCLUDED__

#include "dplay.h"

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct IDirectPlaySP;
typedef struct IDirectPlaySP    FAR *LPDIRECTPLAYSP;
#else                  
typedef struct IDirectPlaySP    FAR *LPDIRECTPLAYSP;
#endif
/*
 * IDirectPlaySP
 */
#undef INTERFACE
#define INTERFACE IDirectPlaySP
#ifdef _WIN32
DECLARE_INTERFACE_( IDirectPlaySP, IUnknown )
{
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS_ DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE,BOOL) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID,BOOL) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC, HANDLE) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPVOID, LPDWORD) PURE;
    STDMETHOD(SetPrevPlayer)        (THIS_ LPSTR, LPVOID, DWORD) PURE;
    STDMETHOD(SetPrevSession)       (THIS_ LPSTR, LPVOID, DWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR, BOOL) PURE;
};
#endif

#define DPOPEN_RSVP                 0x00000004 // Internal
#define DPOPEN_ENUM_ALL             0x00000008 // Internal
#define DPOPEN_ENUM_AVAIL           0x00000010 // Internal

#define DPSYS_OPEN                    0x0000  // Internal.
#define DPSYS_ENUM_REPLY              0x0002  // Internal.
#define DPSYS_REJECTPLAYER            0x0004  // Internal.
#define DPSYS_PLAYERCOUNT             0x0006  // Internal use DPHDR, usCount
#define DPSYS_ENUMPLAYER              0x0008  // Internal
#define DPSYS_GETPLAYER               0x0009  // Internal
#define DPSYS_ENUMGROUP               0x000b  // Internal
#define DPSYS_PING                    0x000c  // Internal
#define DPSYS_SETPLAYER               0x000f  // Internal
#define DPSYS_SENDDESC                0x0010  // Internal
#define DPSYS_ENABLEPLAYER            0x0023  // Internal
#define DPSYS_GETPLAYERCAPS           0x0024  // Internal
#define DPSYS_ENUMALLPLAYERS          0x0025  // Internal
#define DPSYS_ENUMPLAYERRESP          0x0026  // Internal
#define DPSYS_SETGROUPPLAYER          0x0029
#define DPSYS_REJECT                  0x0030  // Internal
#define DPSYS_FINISHCONNECTION        0x0031
#define DPSYS_CONNECT_DONE            0x0032


                                    // All Internal, for completeness
#define DPSYS_ENUM                    0x6172  // '4b797261' == 'Kyra' Born 10/21/94
#define DPSYS_KYRA                    0x6172794b
#define DPSYS_HALL                    0x6c6c6148
#define DPSYS_SYS                     0x484b  // KH
#define DPSYS_USER                    0x4841  // AH
#define DPSYS_HIGH                    0x484a  // JH

IDirectPlaySP * _cdecl CreateNewDirectPlay( LPGUID lpGuid );
typedef IDirectPlaySP *( _cdecl * CREATEPROC ) ( LPGUID lpGuid);

//
//
//
//
#define DPLAY_SERVICE    "Software\\Microsoft\\DirectPlay\\Services"
#define DPLAY_PATH       "Path"
#define DPLAY_DESC       "Description"
#define DPLAY_GUID       "Guid"
#define DPLAY_SESSION    "Sessions"
#define DPLAY_PLAYERS    "Players"

#define DPLAY_CLOSE_USER        0x00000000
#define DPLAY_CLOSE_INTERNAL    0x80000000


#define DPVERSION_MAJOR              0x0001
#define DPVERSION_MINOR              0x0001


#define DPENUMPLAYERS_NOPLAYERS     0x80000000

#define DPSEND_ALLFLAGS             (  DPSEND_GUARANTEE \
                                     | DPSEND_HIGHPRIORITY \
                                     | DPSEND_TRYONCE)

#define DPRECEIVE_ALLFLAGS          (  DPRECEIVE_ALL          \
                                     | DPRECEIVE_TOPLAYER     \
                                     | DPRECEIVE_FROMPLAYER   \
                                     | DPRECEIVE_PEEK )     


#define DPERR_INVALIDPID                DPERR_INVALIDPLAYER

/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

#ifdef __cplusplus
};
#endif

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dpimp.h ===
// Direct Play object class implementation

#ifndef _DPIMP_H
#define _DPIMP_H

#include <winsock.h>
#include "dplayi.h"

#define MAGIC 0x4b797261

// Begin: declaration of main implementation class for IDirectPlay

class CImpIDirectPlay : public IDirectPlay {
public:
    // IUnknown methods
    // IDirectPlay methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID iid, LPVOID *ppvObj );
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
    virtual ULONG STDMETHODCALLTYPE Release( void );

    virtual HRESULT STDMETHODCALLTYPE AddPlayerToGroup(
                                            DPID dwDPIDGroup,
                                            DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE Close(void);
    virtual HRESULT STDMETHODCALLTYPE CreatePlayer(
                                        LPDPID pPlayerID,
                                        LPSTR pNickName,
                                        LPSTR pFullName,
                                        LPHANDLE lpReceiveEvent);
    virtual HRESULT STDMETHODCALLTYPE CreateGroup(
                                        LPDPID lpDPid,
                                        LPSTR  lpGrpFriendly,
                                        LPSTR  lpGroupFromal);
    virtual HRESULT STDMETHODCALLTYPE   DeletePlayerFromGroup(
                                        DPID DPid,
                                        DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE DestroyPlayer( DPID pPlayerID );
    virtual HRESULT STDMETHODCALLTYPE DestroyGroup( DPID pPlayerID );
    virtual HRESULT STDMETHODCALLTYPE EnumGroupPlayers(
                                      DWORD dwGroupPid,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumGroups(
                                      DWORD dwSessionID,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumPlayers(
                                      DWORD dwSessionID,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumSessions(
                                       LPDPSESSIONDESC,
                                       DWORD,
                                       LPDPENUMSESSIONSCALLBACK EnumCallback,
                                       LPVOID,
                                       DWORD);

    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetMessageCount(DPID pidPlayer, LPDWORD lpdwCount);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerCaps(
                                        DPID dwDPId,
                                        LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerName(DPID dpID,
                          LPSTR lpFriendlyName,          // buffer to hold name
                          LPDWORD pdwFriendlyNameLength, // length of name buffer
                          LPSTR lpFormalName,
                          LPDWORD pdwFormalNameLength
                          );


    virtual HRESULT STDMETHODCALLTYPE Open(
                        LPDPSESSIONDESC lpSDesc);

    virtual HRESULT STDMETHODCALLTYPE Receive(
                                LPDPID from,
                                LPDPID to,
                                DWORD  dwReceiveFlags,
                                LPVOID,
                                LPDWORD);

    virtual HRESULT STDMETHODCALLTYPE SaveSession(LPSTR lpName);

    virtual HRESULT STDMETHODCALLTYPE Send(
                                DPID from,
                                DPID to,
                                DWORD dwFlags,
                                LPVOID lpvMsg,
                                DWORD dwLength);
    virtual HRESULT STDMETHODCALLTYPE SetPlayerName(
                                DPID from,
                                LPSTR lpFriendlyName,          
                                LPSTR lpFormalName);
    virtual HRESULT STDMETHODCALLTYPE EnableNewPlayers(BOOL bEnable);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPGUID lpguid);

    HRESULT SetupEnumPrevPlayers();                                
    HRESULT SetupEnumPrevSessions();                                
    VOID    CleanupObject();


    static HRESULT NewCImpIDirectPlay(LPGUID lpGuid, LPDIRECTPLAY FAR *lplpDP,
                LPSTR lpPath);

   void *operator new( size_t size );
   void operator delete( void *ptr );


private:
    CImpIDirectPlay(void);
    ~CImpIDirectPlay(void);

    int              m_refCount;
    DPCAPS           m_dpcaps;
    IDirectPlaySP   *m_pSP;
    HMODULE          m_hLib;
    DWORD            m_Magic;
    GUID             m_guid;

};

// End  : declaration of main implementation class for IDirectPlay



#define ISINVALID_CImpIDirectPlay() \
           (   !this \
            || !m_pSP \
            || IsBadWritePtr(this,sizeof(CImpIDirectPlay)) \
            || m_Magic != MAGIC)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dpimp.cpp ===
// =================================================================
//
//  Direct Play Network Methods
//
//  Functions to manage communications over a network.
//
//
// =================================================================
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <winsock.h>

#define INITGUID
#include <objbase.h>
#include <initguid.h>

#ifndef _MT
#define _MT
#endif
#include <process.h>
#include <string.h>

#include "dpimp.h"
#include <logit.h>

#include "resource.h"

#define malloc(a)  LocalAlloc(LMEM_FIXED, (a))
#define free(a)    LocalFree((HLOCAL)(a))


extern "C" CRITICAL_SECTION g_critSection;

#define Lock()   EnterCriticalSection( &g_critSection )
#define Unlock() LeaveCriticalSection( &g_critSection )


void *CImpIDirectPlay::operator new( size_t size )
{
    return(LocalAlloc(LMEM_FIXED, size));
}
void CImpIDirectPlay::operator delete( void *ptr )
{
    LocalFree((HLOCAL)ptr);
}


HRESULT CImpIDirectPlay::Initialize(LPGUID lpguid)
{
    TSHELL_INFO(TEXT("Already Initialized."));
    return(DPERR_ALREADYINITIALIZED);
}

extern "C" VOID _cdecl CleanupObject(LPDWORD lpdw)
{
    CImpIDirectPlay *pIDP = (CImpIDirectPlay *) lpdw;

    if (pIDP)
	pIDP->CleanupObject();

    *lpdw = NULL;
}

VOID CImpIDirectPlay::CleanupObject()
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return;
    }

    while (Release());
    Unlock();
}

extern "C" HINSTANCE hModule;

//
// lplpDP validated memory from dpcreate.cpp call.
//
HRESULT CImpIDirectPlay::NewCImpIDirectPlay(LPGUID lpGuid,
					    LPDIRECTPLAY FAR *lplpDP,
					    LPSTR lpPath)
{

    CREATEPROC pfnCreate;
    HINSTANCE hLib;
    TCHAR chBuffer[256];
    IDirectPlaySP   *pSP = NULL;
    CImpIDirectPlay *pDP = NULL;

    Lock();

    pDP = new CImpIDirectPlay;


    if (   pDP
	&& lplpDP
	&& ! IsBadWritePtr(lplpDP, sizeof(LPDIRECTPLAY))
	&& ( hLib = LoadLibrary( lpPath ) ) != NULL
	&& (pfnCreate = ( CREATEPROC ) GetProcAddress( hLib, TEXT("CreateNewDirectPlay") ))
	&& (pSP = ( *pfnCreate ) ( lpGuid)))
    {
	pDP->m_pSP  = pSP;
	pDP->m_hLib = hLib;
	*lplpDP = (LPDIRECTPLAY) pDP;
	pDP->m_guid = *lpGuid;
	Unlock();
	return(DP_OK);
    }
    else
    {
	delete pDP;

	TCHAR   achTitle[MAX_PATH];
	TCHAR   achMsg[MAX_PATH];

	LoadString(hModule, IDS_DPLAY, achTitle, sizeof(achTitle));
	LoadString(hModule, IDS_LOCATION, achMsg, sizeof(achMsg));


	wsprintf( chBuffer, achMsg, lpPath);
	MessageBox(NULL, chBuffer, achTitle, MB_OK );

#ifdef DEBUG
	if (hLib == NULL)
	    TSHELL_INFO(TEXT("hLib was NULL"));
	if (pfnCreate == NULL)
	    TSHELL_INFO(TEXT("pfnCreate was NULL"));
#endif
	Unlock();
	return(DPERR_GENERIC);
    }
}


// Begin: IUnknown interface implementation
HRESULT CImpIDirectPlay::QueryInterface(
    REFIID iid,
    LPVOID *ppvObj
)
{
    HRESULT retVal = DPERR_GENERIC;

    Lock();

    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (!ppvObj || IsBadWritePtr(ppvObj, 4))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    if( IsEqualIID(iid, (REFIID) IID_IUnknown) ||
	IsEqualIID(iid, (REFIID) IID_IDirectPlay ) )
    {
	AddRef();
	*ppvObj = this;
	Unlock();
	return(DP_OK);
    }

    Unlock();
    return(E_NOINTERFACE);

}

ULONG CImpIDirectPlay::AddRef( void)
{
    ULONG newRefCount;

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(0);
    }

    if (m_pSP)
	m_pSP->AddRef();

    m_refCount++;
    newRefCount = m_refCount;
    Unlock();

    DBG_INFO(( DBGARG, TEXT("newRefCount = %lu"), newRefCount));

    return( newRefCount );
}

ULONG CImpIDirectPlay::Release( void )
{
    LONG newRefCount;

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(0);
    }

    m_refCount--;
    newRefCount = (LONG) m_refCount;

    if (m_pSP)
	m_pSP->Release();

    if (newRefCount <= 0)
    {
	newRefCount = 0;
	m_Magic = 0;
	Unlock();
	delete this;
    }
    else
    {
	Unlock();
    }

    DBG_INFO((DBGARG, TEXT("newRefCount = %lu"), newRefCount));

    return( newRefCount );
}

// End  : IUnknown interface implementation


// ----------------------------------------------------------
//      CImpIDirectPlay constructor - create a new DCO object
//      along with a queue of receive buffers.
// ----------------------------------------------------------
CImpIDirectPlay::CImpIDirectPlay()
{

    // Initialize ref count
    m_refCount = 1;

    //
    //  BUGBUG This will need to be gotten from SP later.
    //
    memset(&m_dpcaps, 0x00, sizeof(DPCAPS));
    m_dpcaps.dwSize          = sizeof(DPCAPS);
    m_dpcaps.dwFlags         = DPCAPS_NAMESERVICE;
    m_dpcaps.dwMaxQueueSize  = 64;
    m_dpcaps.dwMaxPlayers    = 16;
    m_dpcaps.dwHundredBaud   = 0;
    m_dpcaps.dwLatency       = 0;

    m_pSP   = NULL;
    m_hLib  = NULL;
    m_Magic = MAGIC;
}


// ----------------------------------------------------------
// CImpDirectPlay destructor -
// ----------------------------------------------------------
CImpIDirectPlay::~CImpIDirectPlay()
{
}




// ----------------------------------------------------------
// GetCaps - return info about the connection media (TBD)
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::GetCaps(
	LPDPCAPS lpDPCaps       // buffer to receive capabilities
	)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (   !lpDPCaps
	|| IsBadWritePtr(lpDPCaps, sizeof(DPCAPS))
	|| lpDPCaps->dwSize != sizeof(DPCAPS))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    HRESULT hr;

    hr = m_pSP->GetCaps(lpDPCaps);
    Unlock();
    return(hr);
}


// ----------------------------------------------------------
//      Connect - establishes communications with underlying transport,
//    and initializes name services and network entities
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::Open(
	LPDPSESSIONDESC lpSDesc
)
{

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (   !lpSDesc
	|| IsBadWritePtr(lpSDesc, sizeof(DPSESSIONDESC))
	|| lpSDesc->dwSize != sizeof(DPSESSIONDESC))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    HRESULT hr;

    hr = m_pSP->Open(lpSDesc, NULL);
    Unlock();

    return(hr);
}


// ----------------------------------------------------------
// CreatePlayer - registers new player, N.B. may fail if
// not currently connected to name server
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::CreatePlayer(
    LPDPID pPlayerID,
    LPSTR pNickName,
    LPSTR pFullName,
    LPHANDLE lpEvent)
{
    char chLong[DPLONGNAMELEN];
    char chShort[DPSHORTNAMELEN];
    BOOL bExcept = FALSE;
    HRESULT hr;


    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (   !pNickName
	|| !pFullName
	|| (lpEvent && IsBadWritePtr(lpEvent, sizeof(HANDLE))))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    _try
    {
	lstrcpyn( chLong,  pFullName, sizeof(chLong) -1);
	lstrcpyn( chShort, pNickName, sizeof(chShort) -1);
	chLong[ sizeof(chLong)  -1] = 0x00;
	chShort[sizeof(chShort) -1] = 0x00;
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
	bExcept = TRUE;
    }

    if (bExcept)
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    hr = m_pSP->CreatePlayer(pPlayerID, pNickName, pFullName, lpEvent, TRUE);
    Unlock();
    return(hr);
}


// ----------------------------------------------------------
// DestroyPlayer
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::DestroyPlayer( DPID playerID )
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    HRESULT hr;
    hr = m_pSP->DestroyPlayer(playerID, TRUE);
    Unlock();

    return(hr);
}


// ----------------------------------------------------------
// Close - close the connection
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::Close( void )
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    HRESULT hr;

    hr = m_pSP->Close(DPLAY_CLOSE_USER);
    Unlock();
    return(hr);
}

// ----------------------------------------------------------
// GetName -
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::GetPlayerName(
    DPID    dpID,
    LPSTR   pNickName,   // buffer to hold name
    LPDWORD pcNickName, // length of name buffer
    LPSTR   pFullName,
    LPDWORD pcFullName
)
{
    char    chLong[DPLONGNAMELEN];
    char    chShort[DPSHORTNAMELEN];
    BOOL    bExcept = FALSE;
    HRESULT hr;
    DWORD   dwLong  = DPLONGNAMELEN;
    DWORD   dwShort = DPSHORTNAMELEN;
    DWORD   dwTmp;

    TSHELL_INFO(TEXT("Dplay enter GetPlayerName."));

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    //
    // If they give us length pointers, they must be valid.
    //
    if (   pcFullName
	&& IsBadWritePtr(pcFullName, sizeof(DWORD)))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    if (   pcNickName
	&& IsBadWritePtr(pcNickName, sizeof(DWORD)))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    //
    // If they gave us strings and length pointers, the strings
    // must be valid for the entire length they claimed if the length
    // isn't zero.
    //

    if (   pFullName
	&& pcFullName
	&& *pcFullName
	&& IsBadWritePtr(pFullName, *pcFullName))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    if (   pNickName
	&& pcNickName
	&& *pcNickName
	&& IsBadWritePtr(pNickName, *pcNickName))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    //
    // If they gave us a pointer to a count that was zero, they
    // don't get strings back under any circumstances.
    //
    if (pcNickName && !*pcNickName)
    {
	pNickName = NULL;
    }

    if (pcFullName && !*pcFullName)
    {
	pFullName = NULL;
    }

    //
    // These lengths are set.  If we get an invalid buffer length from
    // the SP then the SP is wrong.
    //

    if ((hr = m_pSP->GetPlayerName(dpID, chShort, &dwShort,
				    chLong,  &dwLong)) != DP_OK)
    {
	Unlock();
	return(hr);
    }

    dwLong  = lstrlen(chLong)  +1;
    dwShort = lstrlen(chShort) +1;

    if (pcNickName)
    {
	dwTmp = *pcNickName;
	if (   dwTmp != 0
	    && dwTmp < dwShort)
	{
	    hr = DPERR_BUFFERTOOSMALL;
	}
	else
	{
	    dwTmp = dwShort;
	}
	*pcNickName = dwShort;
	dwShort     = dwTmp;
    }

    if (pcFullName)
    {
	dwTmp = *pcFullName;
	if (   dwTmp != 0
	    && dwTmp < dwLong)
	{
	    hr = DPERR_BUFFERTOOSMALL;
	}
	else
	{
	    dwTmp = dwLong;
	}
	*pcFullName = dwLong;
	dwLong     = dwTmp;
    }

    if (pNickName)
    {
	lstrcpyn(pNickName, chShort, dwShort);
	pNickName[dwShort -1] = 0x00;
    }

    if (pFullName)
    {
	lstrcpyn(pFullName, chLong, dwLong);
	pFullName[dwLong -1] = 0x00;
    }

    Unlock();
    return(hr);
}

// ----------------------------------------------------------
// EnumPlayers - return info on peer connections.
// ----------------------------------------------------------


HRESULT CImpIDirectPlay::EnumGroupPlayers(
	  DPID dwGroupPid,
	  LPDPENUMPLAYERSCALLBACK EnumCallback,
	  LPVOID pContext,
	  DWORD dwFlags)
{
    HRESULT hr;

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (dwFlags & DPENUMPLAYERS_PREVIOUS)
    {
	Unlock();
	return(DPERR_INVALIDFLAGS);
    }

    _try
    {
	hr = m_pSP->EnumGroupPlayers(dwGroupPid, EnumCallback, pContext, dwFlags);
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
	hr = DPERR_EXCEPTION;
    }
    Unlock();
    return(hr);
}


extern void GUIDToString(LPBYTE lpb, LPSTR lpStr);
HRESULT CImpIDirectPlay::SetupEnumPrevPlayers()
{
    HRESULT hr;

    DWORD   dwSize = 0;
    HKEY    hkRoot = NULL;
    HKEY    hkService = NULL;
    HKEY    hkPlayers = NULL;
    char    chName[256];
    char    chValue[512];
    DWORD   cbName = 256;
    DWORD   cbValue = 512;

    DWORD   ii = 0;
    DWORD   dw;
    char    chProvider[256];

    Lock();
    GUIDToString((LPBYTE) &m_guid, chProvider);

    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (   RegOpenKeyEx( HKEY_LOCAL_MACHINE, DPLAY_SERVICE, 0, NULL, &hkRoot ) == ERROR_SUCCESS
	&& RegOpenKeyEx( hkRoot, chProvider, 0, NULL, &hkService ) == ERROR_SUCCESS
	&& RegOpenKeyEx( hkService, DPLAY_PLAYERS, 0, NULL, &hkPlayers)  == ERROR_SUCCESS)
    {
	while (RegEnumValue( hkPlayers, ii, chName, &cbName, NULL, &dw, (UCHAR *)chValue,
		&cbValue) == ERROR_SUCCESS)
	{
	    if ((hr = m_pSP->SetPrevPlayer(chName, chValue, cbValue)) != DP_OK)
	    {
		goto abort;
	    }
	    cbName  = 256;
	    cbValue = 256;
	}

	hr = DP_OK;
    }
    else
    {
	hr = DPERR_GENERIC;
    }

abort:
    if (hkRoot)
	RegCloseKey(hkRoot);
    if (hkService)
	RegCloseKey(hkService);
    if (hkPlayers)
	RegCloseKey(hkPlayers);

    Unlock();
    return(hr);
}
HRESULT CImpIDirectPlay::SetupEnumPrevSessions()
{
    HRESULT hr;

    DWORD   dwSize = 0;
    HKEY    hkRoot = NULL;
    HKEY    hkService = NULL;
    HKEY    hkPlayers = NULL;
    char    chName[256];
    char    chValue[512];
    DWORD   cbName = 256;
    DWORD   cbValue = 512;

    DWORD   ii = 0;
    DWORD   dw;
    char    chProvider[256];

    GUIDToString((LPBYTE) &m_guid, chProvider);

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (   RegOpenKeyEx( HKEY_LOCAL_MACHINE, DPLAY_SERVICE, 0, NULL, &hkRoot ) == ERROR_SUCCESS
	&& RegOpenKeyEx( hkRoot, chProvider, 0, NULL, &hkService ) == ERROR_SUCCESS
	&& RegOpenKeyEx( hkService, DPLAY_SESSION, 0, NULL, &hkPlayers)  == ERROR_SUCCESS)
    {
	TSHELL_INFO(TEXT("Main keys open."));

	while (RegEnumValue( hkPlayers, ii, chName, &cbName, NULL, &dw, (UCHAR *) chValue,
		&cbValue) == ERROR_SUCCESS)
	{


	    DBG_INFO((DBGARG, TEXT("Set PrevSession Name %s, Value size %d"), chName, cbValue));

	    if ((hr = m_pSP->SetPrevSession(chName, chValue, cbValue)) != DP_OK)
	    {
		TSHELL_INFO(TEXT("SetPrevSession failure"));
		goto abort;
	    }
	    cbName  = 256;
	    cbValue = 256;
	    ii++;
	}

	hr = DP_OK;
    }
    else
    {
	TSHELL_INFO(TEXT("Didn't find everything."));
	hr = DPERR_GENERIC;
    }

abort:
    if (hkRoot)
	RegCloseKey(hkRoot);
    if (hkService)
	RegCloseKey(hkService);
    if (hkPlayers)
	RegCloseKey(hkPlayers);

    Unlock();

    return(hr);
}

HRESULT CImpIDirectPlay::EnumGroups(
	  DWORD dwSessionId,
	  LPDPENUMPLAYERSCALLBACK EnumCallback,
	  LPVOID pContext,
	  DWORD dwFlags)
{
    HRESULT hr;

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    hr = EnumPlayers(dwSessionId, EnumCallback, pContext,
	dwFlags | DPENUMPLAYERS_GROUP
		| DPENUMPLAYERS_NOPLAYERS);

    Unlock();
    return(hr);

}

HRESULT CImpIDirectPlay::EnumPlayers(
	  DWORD dwSessionId,
	  LPDPENUMPLAYERSCALLBACK EnumCallback,
	  LPVOID pContext,
	  DWORD dwFlags)
{
    HRESULT hr;

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (dwFlags & DPENUMPLAYERS_PREVIOUS)
    {
	hr = SetupEnumPrevPlayers();
	if (hr != DP_OK)
	{
	    Unlock();
	    return(hr);
	}
    }

    //
    // BUGBUG.  These checks must be made in the SP level.
    // We have no way of checking valid dwSessionId, and the EnumCallback
    // should be made in a try/except block.
    //

    _try
    {
	hr = m_pSP->EnumPlayers(dwSessionId, EnumCallback, pContext, dwFlags);
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
	hr = DPERR_EXCEPTION;
    }
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::EnumSessions(
	       LPDPSESSIONDESC lpSDesc,
	       DWORD    dwTimeout,
	       LPDPENUMSESSIONSCALLBACK EnumCallback,
	       LPVOID lpvContext,
	       DWORD dwFlags)
{
    HRESULT hr;

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    TSHELL_INFO(TEXT("In EnumSessions"));
    if (   !lpSDesc
	|| IsBadWritePtr(lpSDesc, sizeof(DPSESSIONDESC))
	|| lpSDesc->dwSize != sizeof(DPSESSIONDESC))
    {
#ifdef DEBUG
	if (lpSDesc->dwSize != sizeof(DPSESSIONDESC))
	{
	    DBG_INFO((DBGARG, TEXT("bad size got %d expected %d"),
		lpSDesc->dwSize, sizeof(DPSESSIONDESC)));
	}
#endif

	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    if (dwFlags & DPENUMSESSIONS_PREVIOUS)
    {
	TSHELL_INFO(TEXT("Enumerate Previous sessions."));
	hr = SetupEnumPrevSessions();
	if (hr != DP_OK)
	{
	    Unlock();
	    return(hr);
	}
    }

    hr = m_pSP->EnumSessions(lpSDesc, dwTimeout, EnumCallback, lpvContext, dwFlags);
    Unlock();
    return(hr);
}


// ----------------------------------------------------------
// Send - transmit data over socket.
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::Send(
	DPID    from,
	DPID    to,
	DWORD   dwFlags,
	LPVOID  lpvBuffer,
	DWORD   dwBuffSize)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    //
    // BUGBUG check parameters (from, to)
    //
    if (    dwFlags & ~(DPSEND_ALLFLAGS)
	|| ((dwFlags & (DPSEND_GUARANTEE)) && (dwFlags & (DPSEND_TRYONCE)))
	|| !lpvBuffer
	|| IsBadWritePtr(lpvBuffer, dwBuffSize))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    HRESULT hr;
    hr = m_pSP->Send(from, to, dwFlags, lpvBuffer, dwBuffSize);
    Unlock();
    return(hr);
}

// ----------------------------------------------------------
//  Receive - receive message
// ----------------------------------------------------------
HRESULT CImpIDirectPlay::Receive(
	LPDPID   pidfrom,
	LPDPID   pidto,
	DWORD    dwFlags,
	LPVOID   lpvBuffer,
	LPDWORD  lpdwSize)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    //
    // BUGBUG check parameters (from, to)
    //
    if (dwFlags == 0)
	dwFlags = DPRECEIVE_ALL;

    if (    dwFlags & ~(DPRECEIVE_ALLFLAGS)
	|| ((dwFlags & (DPRECEIVE_ALL)) &&
		(dwFlags & (DPRECEIVE_TOPLAYER | DPRECEIVE_FROMPLAYER)))
	|| !pidfrom
	|| !pidto
	|| IsBadWritePtr(pidfrom, sizeof(DPID))
	|| IsBadWritePtr(pidto, sizeof(DPID))
	|| !lpdwSize
	|| IsBadWritePtr(lpdwSize, sizeof(DPID))
	|| (lpvBuffer && IsBadWritePtr(lpvBuffer, *lpdwSize)))

    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }


    //
    // SP checking required:
    // if ToPlayer or FromPlayer then pids must be valid
    // if buffer not large enough, return size in lpdwSize.
    //
    HRESULT hr;
    hr = m_pSP->Receive(pidfrom, pidto, dwFlags, lpvBuffer, lpdwSize);
    Unlock();
    return(hr);
}


HRESULT CImpIDirectPlay::AddPlayerToGroup(
			DPID pidGroup,
			DPID pidPlayer)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    HRESULT hr;
    hr = m_pSP->AddPlayerToGroup(pidGroup, pidPlayer);
    Unlock();
    return(hr);
}
HRESULT CImpIDirectPlay::CreateGroup(
		    LPDPID lppid,
		    LPSTR  lpGrpFriendly,
		    LPSTR  lpGrpFormal)
{
    BOOL bExcept = FALSE;
    DWORD dw1;
    DWORD dw2;


    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (!lppid)
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    _try
    {
	dw1 = lstrlen(lpGrpFriendly);
	dw2 = lstrlen(lpGrpFormal);
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
	bExcept = TRUE;
    }

    if (bExcept)
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }


    HRESULT hr;
    hr = m_pSP->CreatePlayer(lppid, lpGrpFriendly, lpGrpFormal, NULL, FALSE);
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::DeletePlayerFromGroup(
		    DPID pidGroup,
		    DPID pidPlayer)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    //
    // pid validation
    //
    HRESULT hr;
    hr = m_pSP->DeletePlayerFromGroup(pidGroup, pidPlayer);
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::DestroyGroup(DPID pid )
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    //
    // pid validation
    //
    HRESULT hr;
    hr = m_pSP->DestroyPlayer(pid, FALSE);
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::GetMessageCount(DPID pid, LPDWORD lpdw )
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    //
    // pid validation
    //
    if (   !lpdw
	|| IsBadWritePtr(lpdw, sizeof(DWORD)))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    HRESULT hr;
    hr = m_pSP->GetMessageCount(pid, lpdw);
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::GetPlayerCaps(
		    DPID pid,
		    LPDPCAPS lpDPCaps)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (   !lpDPCaps
	|| IsBadWritePtr(lpDPCaps, sizeof(DPCAPS))
	|| lpDPCaps->dwSize != sizeof(DPCAPS))
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    HRESULT hr;
    hr = m_pSP->GetPlayerCaps(pid, lpDPCaps);
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::SaveSession(LPSTR lpName)
{
    HRESULT hr;
    LPVOID  lpv;
    DWORD   dwSize = 0;
    HKEY    hkRoot = NULL;
    HKEY    hkService = NULL;
    HKEY    hkSession = NULL;
    char    chProvider[256];

    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    if (! lpName)
    {
	Unlock();
	return(DPERR_INVALIDPARAM);
    }

    GUIDToString((LPBYTE) &m_guid, chProvider);

    if (   RegOpenKeyEx( HKEY_LOCAL_MACHINE, DPLAY_SERVICE, 0, NULL, &hkRoot ) == ERROR_SUCCESS
	&& RegOpenKeyEx( hkRoot, chProvider, 0, NULL, &hkService ) == ERROR_SUCCESS
	&& RegOpenKeyEx( hkService, DPLAY_SESSION, 0, NULL, &hkSession)  == ERROR_SUCCESS)
    {
	hr = m_pSP->SaveSession(NULL, &dwSize);
	
	if (hr != DPERR_BUFFERTOOSMALL)
	{
	    DBG_INFO(( DBGARG, TEXT("Unexpected error %8x"), hr));
	}
	else
	{
	
	    lpv = malloc(dwSize);
	    if (! lpv)
	    {
		hr = DPERR_NOMEMORY;
	    }
	    else
	    {
		
		hr = m_pSP->SaveSession(lpv, &dwSize);

		if (hr == DP_OK)
		{
		    if (RegSetValueEx(hkSession, lpName, NULL, REG_BINARY, (UCHAR *) lpv, dwSize)
			    == ERROR_SUCCESS)
		    {
		       hr = DP_OK;
		    }
		    else
			hr = DPERR_GENERIC;
		}
		else
		{
		    DBG_INFO(( DBGARG, TEXT("Unexpected error %8x"), hr));
		}
		free(lpv);
		lpv = NULL;
	    }
	}
    }
    else
    {
	hr = DPERR_GENERIC;
    }


    if (hkRoot)
	RegCloseKey(hkRoot);
    if (hkSession)
	RegCloseKey(hkSession);
    if (hkService)
	RegCloseKey(hkService);

    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::EnableNewPlayers(BOOL bEnable)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    HRESULT hr;
    hr = m_pSP->EnableNewPlayers(bEnable);
    Unlock();
    return(hr);
}

HRESULT CImpIDirectPlay::SetPlayerName(
		DPID  pid,
		LPSTR lpFriendlyName,
		LPSTR lpFormalName)
{
    Lock();
    if (ISINVALID_CImpIDirectPlay())
    {
	Unlock();
	return(DPERR_INVALIDOBJECT);
    }

    HRESULT hr;
    hr = m_pSP->SetPlayerName(pid, lpFriendlyName, lpFormalName, TRUE);
    Unlock();
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\resource.h ===
#define IDS_DPLAY                       2001
#define IDS_LOCATION                    2002


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dplay\dplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplay.h
 *  Content:    DirectPlay include file
 *
 ***************************************************************************/

#ifndef __DPLAY_INCLUDED__
#define __DPLAY_INCLUDED__
#ifdef _WIN32
/* for DECLARE_INTERFACE and HRESULT. */
#include <ole2.h>
#endif

#define _FACDP  0x877
#define MAKE_DPHRESULT( code )    MAKE_HRESULT( 1, _FACDP, code )

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 1)


/*============================================================================
 *
 * DirectPlay Structures
 *
 * Various structures used to invoke DirectPlay.
 *
 *==========================================================================*/

#ifdef __cplusplus
/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct IDirectPlay;
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#else                  
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#endif

typedef DWORD DPID, FAR *LPDPID;

typedef struct _DPCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwMaxBufferSize;
    DWORD   dwMaxQueueSize;             // Function of DPlay, not SP.
    DWORD   dwMaxPlayers;
    DWORD   dwHundredBaud;              // 24 is 2400, 96 is 9600, etc.
    DWORD   dwLatency;
} DPCAPS;

typedef DPCAPS        FAR *LPDPCAPS;

#define DPLONGNAMELEN           52
#define DPSHORTNAMELEN          20
#define DPSESSIONNAMELEN        32
#define DPPASSWORDLEN           16
#define DPUSERRESERVED          16

typedef struct
{
    DWORD   dwSize;
    GUID    guidSession;                  // Id for Game.  Null is all games.
    DWORD   dwSession;                    // session identifier
    DWORD   dwMaxPlayers;                 // Maximum players allowed in game.
    DWORD   dwCurrentPlayers;             // Current  players in Game.
    DWORD   dwFlags;                      // DPOPEN_* flags
    char    szSessionName[DPSESSIONNAMELEN];// Human readable name for Game
    char    szUserField[DPUSERRESERVED];
    DWORD   dwReserved1;                  // Reserved for future MS use.
    char    szPassword[DPPASSWORDLEN];    // Password to be allowed into game.
    DWORD   dwReserved2;                  // Reserved for future MS use. 
    DWORD   dwUser1;
    DWORD   dwUser2;
    DWORD   dwUser3;
    DWORD   dwUser4;
} DPSESSIONDESC;
typedef DPSESSIONDESC FAR *LPDPSESSIONDESC;


/*
 * Create API
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACK)(
    LPGUID              lpSPGuid,
    LPSTR               lpFriendlyName,
    DWORD               dwMajorVersion,
    DWORD               dwMinorVersion,
    LPVOID              lpContext);

typedef BOOL (FAR PASCAL * LPDPENUMSESSIONSCALLBACK)(
    LPDPSESSIONDESC     lpDPSGameDesc,
    LPVOID              lpContext,
    LPDWORD             lpdwTimeOut,
    DWORD               dwFlags);



extern HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnk);
extern HRESULT WINAPI DirectPlayEnumerate( LPDPENUMDPCALLBACK, LPVOID );


/* Player enumeration callback prototype */
typedef BOOL (FAR PASCAL *LPDPENUMPLAYERSCALLBACK)(
    DPID    dpId,
    LPSTR   lpFriendlyName,
    LPSTR   lpFormalName,
    DWORD   dwFlags,
    LPVOID  lpContext );

/*
 * IDirectPlay
 */
#undef INTERFACE
#define INTERFACE IDirectPlay
#ifdef _WIN32
DECLARE_INTERFACE_( IDirectPlay, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPSTR,LPSTR) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPSTR) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR) PURE;
};
#endif




/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           0
#define DPERR_ALREADYINITIALIZED        MAKE_DPHRESULT(   5 )
#define DPERR_ACCESSDENIED              MAKE_DPHRESULT(  10 )
#define DPERR_ACTIVEPLAYERS             MAKE_DPHRESULT(  20 )
#define DPERR_BUFFERTOOSMALL            MAKE_DPHRESULT(  30 )
#define DPERR_CANTADDPLAYER             MAKE_DPHRESULT(  40 )
#define DPERR_CANTCREATEGROUP           MAKE_DPHRESULT(  50 )
#define DPERR_CANTCREATEPLAYER          MAKE_DPHRESULT(  60 )
#define DPERR_CANTCREATESESSION         MAKE_DPHRESULT(  70 )
#define DPERR_CAPSNOTAVAILABLEYET       MAKE_DPHRESULT(  80 )
#define DPERR_EXCEPTION                 MAKE_DPHRESULT(  90 )
#define DPERR_GENERIC                   E_FAIL

#define DPERR_INVALIDFLAGS              MAKE_DPHRESULT( 120 )
#define DPERR_INVALIDOBJECT             MAKE_DPHRESULT( 130 )
#define DPERR_INVALIDPARAM              E_INVALIDARG
#define DPERR_INVALIDPARAMS             DPERR_INVALIDPARAM
#define DPERR_INVALIDPLAYER             MAKE_DPHRESULT( 150 )
#define DPERR_NOCAPS                    MAKE_DPHRESULT( 160 )
#define DPERR_NOCONNECTION              MAKE_DPHRESULT( 170 )
#define DPERR_NOMEMORY                  E_OUTOFMEMORY
#define DPERR_OUTOFMEMORY               DPERR_NOMEMORY
#define DPERR_NOMESSAGES                MAKE_DPHRESULT( 190 )
#define DPERR_NONAMESERVERFOUND         MAKE_DPHRESULT( 200 )
#define DPERR_NOPLAYERS                 MAKE_DPHRESULT( 210 )
#define DPERR_NOSESSIONS                MAKE_DPHRESULT( 220 )
#define DPERR_SENDTOOBIG                MAKE_DPHRESULT( 230 )
#define DPERR_TIMEOUT                   MAKE_DPHRESULT( 240 )
#define DPERR_UNAVAILABLE               MAKE_DPHRESULT( 250 )
#define DPERR_UNSUPPORTED               E_NOTIMPL
#define DPERR_BUSY                      MAKE_DPHRESULT( 270 )
#define DPERR_USERCANCEL                MAKE_DPHRESULT( 280 ) 


#define DPOPEN_OPENSESSION          0x00000001
#define DPOPEN_CREATESESSION        0x00000002

#define DPSEND_GUARANTEE            0x00000001
#define DPSEND_HIGHPRIORITY         0x00000002
#define DPSEND_TRYONCE              0x00000004

#define DPRECEIVE_ALL               0x00000001
#define DPRECEIVE_TOPLAYER          0x00000002
#define DPRECEIVE_FROMPLAYER        0x00000004
#define DPRECEIVE_PEEK              0x00000008

#define DPCAPS_NAMESERVICE          0x00000001 // A name server is supported.
#define DPCAPS_NAMESERVER           0x00000002 // You are the name server.
#define DPCAPS_GUARANTEED           0x00000004 // SP's don't have to implement guarantees.

#define DPENUMSESSIONS_AVAILABLE    0x00000001 // All games that match password (if given)
                                               // and have openings.
#define DPENUMSESSIONS_ALL          0x00000002
#define DPENUMSESSIONS_PREVIOUS     0x00000004

#define DPENUMPLAYERS_ALL           0x00000000
#define DPENUMPLAYERS_PREVIOUS      0x00000004
#define DPENUMPLAYERS_LOCAL         0x00000008
#define DPENUMPLAYERS_REMOTE        0x00000010
#define DPENUMPLAYERS_GROUP         0x00000020
#define DPENUMPLAYERS_SESSION       0x00000080

//
// This flag is set on the enumsessions callback when the time out has occured.
// This means that there is no session data for this callback.
// If lpdwTimeOut is set to a non-zero value and the EnumSessionsCallback returns
// TRUE then EnumSessions will continue until the next timeout occurs.
// Timeouts are in milliseconds.
 
#define DPESC_TIMEDOUT              0x00000001


//
// System message structures and types.
//
// System messages have a leading 4 byte type code to identify the message.
// an app knows it is a system message because it is addressed 'To' player 0.
//

                                    
#define DPSYS_ADDPLAYER               0x0003  // DPMSG_ADDPLAYER
#define DPSYS_DELETEPLAYER            0x0005  // DPMSG_DELETEPLAYER

#define DPSYS_ADDPLAYERTOGROUP        0x0007  // DPMSG_GROUPADD

#define DPSYS_INVITE                  0x000e  // DPMSG_INVITE, Net only.

#define DPSYS_DELETEGROUP             0x0020  // DPMSG_DELETEPLAYER
#define DPSYS_DELETEPLAYERFROMGRP     0x0021  // DPMSG_GROUPDELETE
#define DPSYS_SESSIONLOST             0x0031

#define DPSYS_CONNECT                 0x484b  // DPMSG_GENERIC



typedef struct
{
    DWORD       dwType;
    DWORD       dwPlayerType;
    DPID        dpId;
    char        szLongName[DPLONGNAMELEN];
    char        szShortName[DPSHORTNAMELEN];
    DWORD       dwCurrentPlayers;
}   DPMSG_ADDPLAYER;

typedef DPMSG_ADDPLAYER DPMSG_ADDGROUP;

typedef struct
{
    DWORD       dwType;
    DPID        dpIdGroup;
    DPID        dpIdPlayer;
} DPMSG_GROUPADD;

typedef DPMSG_GROUPADD DPMSG_GROUPDELETE;
typedef struct
{
    DWORD       dwType;
    DPID        dpId;
} DPMSG_DELETEPLAYER;

typedef struct
{
    DWORD           dwType;
    DPSESSIONDESC   dpsDesc;
} DPMSG_INVITE;



typedef struct
{
    DWORD           dwType;
} DPMSG_GENERIC;

#pragma pack(pop)


DEFINE_GUID( IID_IDirectPlay, 0x5454e9a0, 0xdb65, 0x11ce, 0x92, 0x1c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72);



#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\commcode.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
// PURPOSE:
//    Contains public declarations for the CommCode module.
//

BOOL StartComm(HANDLE hNewCommFile);
void StopComm();
BOOL WriteCommString(LPVOID pszStringToWrite, DWORD nSizeofStringToWrite);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	DPLAY.DLL initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *
 ***************************************************************************/

#include "windows.h"

/*
 * DllMain
 */
extern VOID InternalCleanUp();
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        #ifdef DEBUG
            OutputDebugString(TEXT("DPWSOCK Attaching\r\n"));
        #endif
        break;

    case DLL_PROCESS_DETACH:
        #ifdef DEBUG
            OutputDebugString(TEXT("DPWSOCK Dettaching\r\n"));
        #endif
        InternalCleanUp();
        break;
    }

    return TRUE;
} /* DllMain */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\dpspimp.cpp ===
// =================================================================
//
//  Direct Play Network Methods
//
//  Functions to manage communications over a network.
//
//
// =================================================================
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <winsock.h>
#ifndef _MT
#define _MT
#endif
#include <process.h>
#include <string.h>

#include "dpspimp.h"
#include "logit.h"

#define lmalloc(a)  LocalAlloc(LMEM_FIXED, (a))
#define lfree(a)      LocalFree((HLOCAL)(a))

CImpIDP_SP *pDirectPlayObject = NULL; // We only allow one object
                                             // to be created currently - see below.

HANDLE hOnlyOneTCP = NULL;
HANDLE hOnlyOneIPX = NULL;

extern "C" VOID InternalCleanUp()
{
    if (pDirectPlayObject)
        pDirectPlayObject->Close(DPLAY_CLOSE_INTERNAL);

    pDirectPlayObject = NULL;
}

extern BOOL CreateQueue(DWORD dwElements, DWORD dwmaxMsg, DWORD dwMaxPlayers);
extern BOOL DeleteQueue();

GUID DPLAY_NETWORK_TCP = { /* 8cab4650-b1b6-11ce-920c-00aa006c4972 */
    0x8cab4650,
    0xb1b6,
    0x11ce,
    {0x92, 0x0c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72}
  };
GUID DPLAY_NETWORK_IPX = { /* 8cab4651-b1b6-11ce-920c-00aa006c4972 */
    0x8cab4651,
    0xb1b6,
    0x11ce,
    {0x92, 0x0c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72}
  };

GUID NULL_GUID = {
    0x00000000,
    0x0000,
    0x0000,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  };
extern BOOL bNetIsUp;



HRESULT CImpIDP_SP::Initialize(LPGUID lpguid)
{
    TSHELL_INFO(TEXT("Already Initialized."));
    return(DPERR_ALREADYINITIALIZED);
}

void *CImpIDP_SP::operator new( size_t size )
{
    return(LocalAlloc(LMEM_FIXED, size));
}
void CImpIDP_SP::operator delete( void *ptr )
{
    LocalFree((HLOCAL)ptr);
}



// ----------------------------------------------------------
// CImpIDP_SP constructor - create a new DCO object
// along with a queue of receive buffers.
// ----------------------------------------------------------
USHORT CImpIDP_SP::NextSequence()
{
    m_usSeq %= 51001;
    m_usSeq++;
    return(m_usSeq);
}

USHORT CImpIDP_SP::UpdateSequence(USHORT us)
{
    if (us > m_usSeq)
        m_usSeq = us;

    return(NextSequence());
}


CImpIDP_SP::CImpIDP_SP()
{
    m_bConnected             = FALSE;
    m_bPlayer0               = FALSE;

    m_dwPingSent             = 0;
    m_hBlockingEvent         = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_hEnumBlkEventMain      = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_hEnumBlkEventRead      = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_hPlayerBlkEventMain    = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_hPlayerBlkEventRead    = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_dwNextPlayer           = 1;
    m_bEnablePlayerAdd       = TRUE;

    m_fpEnumSessions         = NULL;
    m_bRunEnumReceiveLoop    = FALSE;
    m_fpEnumPlayers          = NULL;
    m_lpvSessionContext      = NULL;
    m_lpvPlayersContext      = NULL;
    memset( m_aPlayer, 0x00, sizeof(PLAYER_RECORD) * MAX_PLAYERS);
    m_iPlayerIndex           = -1;
    memset(&m_dpDesc, 0x00, sizeof(DPSESSIONDESC));

    // Initialize ref count
    m_refCount = 1;
    InitializeCriticalSection( &m_critSection );
    InitializeCriticalSection( &m_critSectionPlayer );
    InitializeCriticalSection( &m_critSectionParanoia );
    memset(&m_dpcaps, 0x00, sizeof(DPCAPS));
    m_dpcaps.dwSize          = sizeof(DPCAPS);
    m_dpcaps.dwFlags         = 0;
    m_dpcaps.dwMaxQueueSize  = 64;
    m_dpcaps.dwMaxPlayers    = MAX_PLAYERS;
    m_dpcaps.dwHundredBaud   = 100000;

    m_hNewPlayerEvent        = NULL;
    m_ppSessionArray         = 0;
    m_dwSessionPrev          = 0;
    m_dwSessionAlloc         = 0;
    m_af                     = 0;

    m_remoteaddrlen          = 0;
    m_chComputerName[0]      = '\0';
    m_bShutDown              = FALSE;
    m_hNSThread              = NULL;
    m_dwNSId                 = 0;
    m_usGamePort             = 0;
    m_usGameCookie           = 0;
    m_hClientThread          = NULL;
    m_dwClientId             = 0;
    m_hEnumThread            = NULL;
    m_dwEnumId               = 0;

    m_ServerSocket           = INVALID_SOCKET;
    m_bClientSocket          = FALSE; m_EnumSocket   = INVALID_SOCKET;
    m_bEnumSocket            = FALSE; m_ClientSocket = INVALID_SOCKET;

    m_dwSession              = 0;
    memset( (LPVOID) &m_NSSockAddr, 0x00, sizeof(SOCKADDR));
    m_SessionAddrLen         = 0;
    memset( (LPVOID) &m_GameSockAddr, 0x00, sizeof(SOCKADDR));

    m_usSeq                  = 1;
    m_usSeqSys               = 0;

    m_aMachineAddr           = NULL;
    m_cMachines              = 0;
    m_dwUnique               = 1;

    memset( (LPVOID) &m_spmsgEnum, 0x00, sizeof(SPMSG_ENUM));
    memset( (LPVOID) &m_spmsgAddPlayer, 0x00, sizeof(SPMSG_ADDPLAYER));
}

DWORD WINAPI StartClientThreadProc(LPVOID lpvParam)
{
    CImpIDP_SP *pIDP = (CImpIDP_SP *) lpvParam;

    return(pIDP->ClientThreadProc());
}


CImpIDP_SP *CImpIDP_SP::NewCImpIDP_SP(int af)
{
    CImpIDP_SP *pImp    = NULL;
    HANDLE hEvent       = NULL;


    if (InitializeWinSock() != 0)
    {
        TSHELL_INFO( TEXT("DPWsock failed initializing winsock."));
        return(NULL);
    }


    if (!CreateQueue(64, MAX_MSG, MAX_PLAYERS))
    {
        TSHELL_INFO(TEXT("Couldn't initialize queue."));
        return(NULL);
    }

    pImp = new CImpIDP_SP;

    if (!pImp)
        return(NULL);

    pImp->m_dpcaps.dwMaxBufferSize = 512;
    pImp->m_af                     = af;

    return(pImp);
}


// ----------------------------------------------------------
// CreateNewDirectPlay - DCO object creation entry point
// called by the DCO interface functions to create a new
// DCO object.
// ----------------------------------------------------------
IDirectPlaySP * _cdecl CreateNewDirectPlay( LPGUID lpGuid )
{

    int af;

    //
    // One object at a time, please.
    //
    if (pDirectPlayObject != NULL)
    {
        TSHELL_INFO(TEXT("We already have an object."));
        return(NULL);
    }


    if      (IsEqualGUID((REFGUID) DPLAY_NETWORK_TCP, (REFGUID) *lpGuid))
        af = AF_INET;
    else if (IsEqualGUID((REFGUID) DPLAY_NETWORK_IPX, (REFGUID) *lpGuid))
        af = AF_IPX;
    else
        return(NULL);


    pDirectPlayObject = CImpIDP_SP::NewCImpIDP_SP(af);

    if (!pDirectPlayObject)
        return(NULL);
    else
        return(pDirectPlayObject);
}


// Begin: IUnknown interface implementation
HRESULT CImpIDP_SP::QueryInterface(
    REFIID iid,
    LPVOID *ppvObj
)
{
    HRESULT retVal = DPERR_GENERIC;

    //
    // BUGBUG
    //
    if (ppvObj && ! IsBadWritePtr(ppvObj, 4))
        {
        AddRef();
        *ppvObj = this;
        return(DP_OK);
        }
    else
        return(DPERR_INVALIDPARAM);

}

ULONG CImpIDP_SP::AddRef( void)
{
    ULONG newRefCount;

    m_refCount++;
    newRefCount = m_refCount;

    DBG_INFO((DBGARG, TEXT("newRefCount = %lu"), newRefCount));

    return( newRefCount );
}

ULONG CImpIDP_SP::Release( void )
{
    ULONG newRefCount;

    m_refCount--;
    newRefCount = m_refCount;

    if (newRefCount == 0)
        {
        Close(DPLAY_CLOSE_INTERNAL);
        delete this;
        }

    DBG_INFO((DBGARG, TEXT("newRefCount = %lu"), newRefCount));

    return( newRefCount );
}

// End  : IUnknown interface implementation



// ----------------------------------------------------------
// CImpDirectPlay destructor -
// ----------------------------------------------------------
CImpIDP_SP::~CImpIDP_SP()
{

    DWORD ii;

    if (m_ppSessionArray)
    {
        for (ii = 0; ii < m_dwSessionPrev; ii++)
            lfree(m_ppSessionArray[ii]);
        lfree(m_ppSessionArray);
        m_dwSessionPrev  = 0;
        m_dwSessionAlloc = 0;
    }

    if (m_aMachineAddr)
        lfree(m_aMachineAddr);

    DeleteCriticalSection( &m_critSection );
    DeleteCriticalSection( &m_critSectionPlayer );
    DeleteCriticalSection( &m_critSectionParanoia );
    CloseHandle(m_hBlockingEvent);
    CloseHandle(m_hEnumBlkEventMain);
    CloseHandle(m_hEnumBlkEventRead);
    CloseHandle(m_hPlayerBlkEventMain);
    CloseHandle(m_hPlayerBlkEventRead);
    ShutdownWinSock();
    pDirectPlayObject = NULL;
    DeleteQueue();
}


void CImpIDP_SP::EnumDataLock( void )
{
    EnterCriticalSection( &m_critSection );
}

void CImpIDP_SP::EnumDataUnlock( void )
{
    LeaveCriticalSection( &m_critSection );
}

void CImpIDP_SP::PlayerDataLock( void )
{
    EnterCriticalSection( &m_critSectionPlayer );
}

void CImpIDP_SP::PlayerDataUnlock( void )
{
    LeaveCriticalSection( &m_critSectionPlayer );
}

void CImpIDP_SP::ParanoiaLock( void )
{
    EnterCriticalSection( &m_critSectionParanoia );
}

void CImpIDP_SP::ParanoiaUnlock( void )
{
    LeaveCriticalSection( &m_critSectionParanoia );
}

DWORD WINAPI StartServerThreadProc(LPVOID lpvParam)
{
    CImpIDP_SP *pIDP = (CImpIDP_SP *) lpvParam;

    return(pIDP->ServerThreadProc());
}


BOOL  CImpIDP_SP::GetSockAddress(SOCKADDR *pSAddr,
                                 LPINT pSAddrLen,
                                 USHORT usPort,
                                 SOCKET *pSocket,
                                 BOOL bBroadcast
                                 )
{
    PSOCKADDR_IN    pSockAddrIn;
    PSOCKADDR_IPX   pSockAddrIPX;
    UINT            uErr;

    memset(pSAddr, 0, sizeof(SOCKADDR));
    pSAddr->sa_family = (USHORT)m_af;

    switch (m_af)
    {
    case AF_INET:

        pSockAddrIn             = (PSOCKADDR_IN) pSAddr;
        pSockAddrIn->sin_port   = htons(usPort);
        if (bBroadcast)
            pSockAddrIn->sin_addr.s_addr = INADDR_BROADCAST;
        break;

    case AF_IPX:

        pSockAddrIPX            = (PSOCKADDR_IPX) pSAddr;
        pSockAddrIPX->sa_socket = htons(usPort);
        if (bBroadcast)
            memset(&pSockAddrIPX->sa_nodenum, 0xff, sizeof(pSockAddrIPX->sa_nodenum));
        break;

    default:

        return (FALSE);

    }

    if (!bBroadcast)
    {
        *pSAddrLen = sizeof(SOCKADDR);
        if ((uErr = InitializeSocket(m_af, pSAddr, pSAddrLen, pSocket)) != 0)
        {
            DBG_INFO((DBGARG, TEXT("Init Socket Failed %8x"), uErr));
            return(FALSE);
        }
    }

    return(TRUE);
}


DWORD CImpIDP_SP::ClientThreadProc()
{
    HRESULT         hr = DP_OK;
    char            chRBuffer[2048];
    SOCKADDR        SockAddr;
    UINT            BufferLen;
    INT             SockAddrLen;
    BOOL            bNoConnection = TRUE;
    DPHDR          *pHdr = (DPHDR *) chRBuffer;
    UINT            err;
    const char ttl = 32;

    TSHELL_INFO(TEXT("Client Thread starts."));


    memset(&SockAddr, 0, sizeof(SOCKADDR));
    SockAddr.sa_family = (USHORT)m_af;

    if (m_fpEnumSessions == NULL && m_usGamePort == 0)
        return(0);

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    if (m_usGamePort)
    {

        if (GetSockAddress(&SockAddr, &SockAddrLen, m_usGamePort, (SOCKET *)&m_ClientSocket, FALSE))
        {
            m_bClientSocket = TRUE;
        }
        else
        {
            TSHELL_INFO(TEXT("Thread Exit."));
            SetEvent(m_hBlockingEvent);
            return(0);
        }

        SetEvent(m_hBlockingEvent);
        TSHELL_INFO(TEXT("Client Thread with game port looping."));
        while (!m_bShutDown)
        {
            //
            // Do a blocking receive from anyone.  Once we return from here,
            // we could either have a real request in our buffer, or our
            // socket's been closed in which case we'll have an error in err.
            //

            BufferLen = sizeof(chRBuffer);

            if (!(ReceiveAny(m_ClientSocket, &SockAddr, &SockAddrLen, chRBuffer, &BufferLen)))
            {

                // TSHELL_INFO(TEXT("Got a message in Client Game thread."));


                if (   pHdr->dwConnect1 == DPSYS_KYRA
                    && pHdr->dwConnect2 == DPSYS_HALL)
                {
                    UpdateSequence(pHdr->usSeq);
                    // TSHELL_INFO(TEXT("Handle connect message."));
                    HandleConnect(pHdr, (DWORD) BufferLen, &SockAddr, SockAddrLen);
                }
                else if (   pHdr->usCookie == DPSYS_USER
                         || pHdr->usCookie == DPSYS_SYS
                         || pHdr->usCookie == DPSYS_HIGH)
                {
                    UpdateSequence(pHdr->usSeq);
                    TSHELL_INFO(TEXT("Handle server message Client Thread."));
                    HandleMessage(pHdr, (DWORD) BufferLen, &SockAddr, SockAddrLen);
                }
            }
        }
        ParanoiaLock();
        if (m_ClientSocket != INVALID_SOCKET)
            CloseSocket(m_ClientSocket, 2);
        m_ClientSocket = INVALID_SOCKET;
        TSHELL_INFO(TEXT("Client Thread Exit."));
        ParanoiaUnlock();
    }
    else
    {

        if ((err = InitializeSocket(m_af, NULL, NULL, (SOCKET *) &m_EnumSocket)) != 0)
        {
            DBG_INFO((DBGARG, TEXT("THREAD EXIT on ENUM INIT %d."), err));
            SetEvent(m_hBlockingEvent);
            return(0);
        }
        else
            m_bEnumSocket = TRUE;

        // if (setsockopt(m_EnumSocket, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl)))
        // {
        //     DBG_INFO((DBGARG, TEXT("SetSocket Option for multicast failed. %d"), GetLastError()));
        // }

        SetEvent(m_hBlockingEvent);
        // TSHELL_INFO(TEXT("Looping in EnumThread."));

        SockAddrLen = sizeof(SockAddr);
        getsockname(m_EnumSocket, &SockAddr, &SockAddrLen);

        while (m_bRunEnumReceiveLoop)
        {
            BufferLen = sizeof(chRBuffer);
            SockAddrLen = sizeof(SockAddr);
            if (!(ReceiveAny(m_EnumSocket, &SockAddr, &SockAddrLen, chRBuffer, &BufferLen)))
            {
                // TSHELL_INFO(TEXT("Message in EnumThread."));
                if (   pHdr->dwConnect1 == DPSYS_KYRA
                    && pHdr->dwConnect2 == DPSYS_HALL)
                {
                    UpdateSequence(pHdr->usSeq);
                    // TSHELL_INFO(TEXT("Handle connect message."));
                    HandleConnect((LPVOID) pHdr, (DWORD) BufferLen, &SockAddr, SockAddrLen);
#ifdef DEBUG
                    if (!m_fpEnumSessions)
                        TSHELL_INFO(TEXT("m_fpEnumSessions is NULL."));
#endif
                }
                else if (   pHdr->usCookie == DPSYS_SYS
                         && pHdr->usCount  == SIZE_ADDPLAYER
                         && ((SPMSG_GENERIC *)pHdr)->sMsg.dwType == DPSYS_ENUMPLAYERRESP)
                {
                    HandleMessage(pHdr, (DWORD) BufferLen, &SockAddr, SockAddrLen);
                }
                else
                {
                    TSHELL_INFO(TEXT("Enum function got an illegal non-connect message."));
                    DBG_INFO((DBGARG,  TEXT("Non-connect was %8x %8x Length %d"),
                        pHdr->dwConnect1,
                        pHdr->dwConnect2,
                        BufferLen));
                }
            }

        }

        EnumDataLock();

        if (m_EnumSocket != INVALID_SOCKET)
            CloseSocket(m_EnumSocket, 2);
        m_EnumSocket = INVALID_SOCKET;

        EnumDataUnlock();

        TSHELL_INFO(TEXT("Enum Thread Exit."));
    }




    return(hr);

}

DWORD CImpIDP_SP::ServerThreadProc()
{
    SOCKADDR        SockAddr;
    HRESULT         hr = DP_OK;
    DWORD           dw;
    UINT BufferLen;
    INT             SockAddrLen;
    char            chRBuffer[2048];
    DWORD           dwTicks;
    DWORD           dwCountIt;
    DWORD           ii;
    LPBYTE          lpByte;
    DPHDR          *pHdr = (DPHDR *) chRBuffer;
    UINT            err;


    TSHELL_INFO(TEXT("Server Thread Starts."));

    m_bPlayer0 = FALSE;

    memset(&SockAddr, 0, sizeof(SOCKADDR));
    SockAddr.sa_family = (USHORT)m_af;

    if (! GetSockAddress(&SockAddr, &SockAddrLen, DPNS_PORT, (SOCKET *) &m_ServerSocket, FALSE))
    {
        hr = DPERR_GENERIC;
        m_hNSThread = NULL;
        SetEvent(m_hBlockingEvent);
        goto abort;
    }


    //
    // Now let's initialize our SDB structure for use in the future.
    // This includes stuff like computer name, address length, etc.
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    m_remoteaddrlen = sizeof(SOCKADDR);
    dw = sizeof(m_chComputerName);
    GetComputerName(m_chComputerName, &dw);

    SockAddrLen = m_remoteaddrlen;

    m_bPlayer0    = TRUE;

    lpByte    = (LPBYTE) &m_dpDesc;
    dwCountIt = 0;
    for (ii = 0; ii < sizeof(m_dpDesc); ii++)
        dwCountIt += lpByte[ii] & 0x000000ff;

    dwTicks = GetCurrentTime();
    m_usGamePort   = (USHORT) (2000 + (((dwCountIt % 75) + 1) * ((dwTicks % 75) + 1)));
    m_usGameCookie = (USHORT) (((dwCountIt % 235) + 1) * ((dwTicks % 235) + 1));

    GetSockAddress(&m_GameSockAddr, NULL, m_usGamePort, NULL, TRUE);

    // Let create function go ...
    //

    SetEvent(m_hBlockingEvent);

    TSHELL_INFO(TEXT("Server Thread Looping."));
    while (!m_bShutDown)
    {
        //
        // Do a blocking receive from anyone.  Once we return from here,
        // we could either have a real request in our buffer, or our
        // socket's been closed in which case we'll have an error in err.
        //

        BufferLen = sizeof(chRBuffer);

        if (!(err = ReceiveAny(m_ServerSocket, &SockAddr, &SockAddrLen, chRBuffer, &BufferLen)))
        {

            TSHELL_INFO(TEXT("Got a NS message."));


            if (   pHdr->dwConnect1 == DPSYS_KYRA
                && pHdr->dwConnect2 == DPSYS_HALL)
            {
                UpdateSequence(pHdr->usSeq);
                TSHELL_INFO(TEXT("Handle connect message."));
                HandleConnect(pHdr, (DWORD) BufferLen, &SockAddr, SockAddrLen);
            }
            else if (   pHdr->usCookie == DPSYS_USER
                     || pHdr->usCookie == DPSYS_SYS
                     || pHdr->usCookie == DPSYS_HIGH)
            {
                UpdateSequence(pHdr->usSeq);
                TSHELL_INFO(TEXT("Handle server message."));
                HandleMessage(pHdr, (DWORD) BufferLen, &SockAddr, SockAddrLen);
            }
        }
        else
        {
            m_bShutDown = TRUE;
            ParanoiaLock();
            DBG_INFO((DBGARG, TEXT("Server closeing down with value %d"), err));
            if( m_ServerSocket == INVALID_SOCKET )
            {
                CloseSocket(m_ServerSocket, 2);
            }
            m_ServerSocket = INVALID_SOCKET;
            ParanoiaUnlock();

        }
    }

    //
    // Clean up everything related to this thread and return
    // to caller which will implicitly call ExitThread.
    //

abort:

    return(hr);

}





// ----------------------------------------------------------
// GetCaps - return info about the connection media
// ----------------------------------------------------------

//
// Return our caps immediately if we have a valid latency value.
// if we haven't gotten latency yet, send a DPSYS_PING.  Latency is
// the time it takes to get a response DPSYS_PING / 2.
//
HRESULT CImpIDP_SP::GetCaps(
                            LPDPCAPS lpDPCaps // buffer to receive capabilities
                            )
{
    *lpDPCaps = m_dpcaps;

    if (m_dpcaps.dwLatency == 0)
        SendPing();

    return(DP_OK);
}

// ----------------------------------------------------------
//    Connect - establishes communications with underlying transport,
//    and initializes name services and network entities
// ----------------------------------------------------------
BOOL    CImpIDP_SP::SetSession(DWORD dw)
{
        return(FALSE);
}

DWORD CImpIDP_SP::BlockNicely(DWORD dwTimeout)
{
    DWORD dwStart;
    DWORD dwEnd;
    DWORD dwNow;
    DWORD dwRet;
    MSG   msg;

    if (m_hBlockingEvent)
    {
        dwStart = GetTickCount();
        dwEnd   = dwStart + dwTimeout;
        dwNow = GetTickCount();

        do
        {
            dwRet = MsgWaitForMultipleObjects(1,
                                &m_hBlockingEvent,
                                FALSE,
                                dwEnd - dwNow,
                                QS_ALLINPUT);
            switch (dwRet)
            {
            case WAIT_OBJECT_0:
                {
                    ResetEvent(m_hBlockingEvent);
                    return(WAIT_OBJECT_0);
                }

            case WAIT_TIMEOUT:
                return(WAIT_TIMEOUT);

            case WAIT_OBJECT_0 + 1:
                {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                    if (dwEnd <  (dwNow = GetTickCount()))
                    {
                        return(WAIT_TIMEOUT);
                    }
                }

                }
            }
            dwNow = GetTickCount();
        } while (dwNow < dwEnd);
        dwRet = WaitForSingleObject(m_hBlockingEvent, 0);
        ResetEvent(m_hBlockingEvent);
        return(dwRet);
    }
    else
    {
        return(WAIT_ABANDONED);
    }
}

HRESULT CImpIDP_SP::Open(
                        LPDPSESSIONDESC lpSDesc, HANDLE lpHandle
)
{

    TSHELL_INFO(TEXT("SP Open"));
    DWORD   ii;


    if (m_hEnumThread)
    {
        m_bRunEnumReceiveLoop = FALSE;
        SetThreadPriority(m_hEnumThread, THREAD_PRIORITY_NORMAL);
        TSHELL_INFO(TEXT("EnumSessions:: Closing Socket."));

        EnumDataLock();

        if (m_EnumSocket)
            CloseSocket(m_EnumSocket, 2);

        m_EnumSocket = INVALID_SOCKET;

        EnumDataUnlock();

        TSHELL_INFO(TEXT("EnumSessions:: Socket Closed."));

        if (WaitForSingleObject(m_hEnumThread, 4000) == WAIT_TIMEOUT)
            TerminateThread(m_hEnumThread, 0);
        m_bEnumSocket = FALSE;
        m_hEnumThread = NULL;
    }


    if (lpSDesc->dwFlags & DPOPEN_CREATESESSION)
    {
        if (hOnlyOneTCP || hOnlyOneIPX)
        {
            TSHELL_INFO(TEXT("We already have a server active!"));
            return(DPERR_GENERIC);
        }
        else
        {
            if (m_af == AF_INET)
            {
                hOnlyOneTCP = CreateEvent(NULL, TRUE, TRUE, "KyraHallTCP");

                if (hOnlyOneTCP == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
                {
                    if (hOnlyOneTCP)
                        CloseHandle(hOnlyOneTCP);

                    hOnlyOneTCP = NULL;
                    return(DPERR_GENERIC);

                }
            }
            else
            {
                hOnlyOneIPX = CreateEvent(NULL, TRUE, TRUE, "KyraHallIPX");

                if (hOnlyOneIPX == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
                {
                    if (hOnlyOneIPX)
                        CloseHandle(hOnlyOneIPX);

                    hOnlyOneIPX = NULL;
                    return(DPERR_GENERIC);
                }
            }

        }

        if (m_hNSThread || m_aMachineAddr)
        {
            TSHELL_INFO(TEXT("Globals indicate we already have opened a game."));
            return(DPERR_GENERIC);
        }

        m_aMachineAddr = (SOCKADDR *) lmalloc(sizeof(SOCKADDR) * MAX_PLAYERS);
        m_cMachines    = 0;

        memcpy( &m_dpDesc, lpSDesc, sizeof(m_dpDesc));
        m_dpDesc.dwCurrentPlayers = 0;
        m_dpDesc.dwReserved1      = 0;
        m_dpDesc.dwReserved2      = 0;

        ResetEvent(m_hBlockingEvent);

        m_hNSThread = CreateThread(NULL, 0, StartServerThreadProc,
                        (LPVOID) this, 0, &m_dwNSId);

        if (m_hNSThread == NULL)
        {
            TSHELL_INFO(TEXT("StartServerThreadProc failed."));
            return(DPERR_GENERIC);
        }

        if (WaitForSingleObject(m_hBlockingEvent, INFINITE) == WAIT_TIMEOUT)
        {
            TSHELL_INFO(TEXT("INFINITITY Reached.  Notify Nobel Committee."));
            return(DPERR_GENERIC);
        }

        ResetEvent(m_hBlockingEvent);

        if (m_bPlayer0 != TRUE)
        {
            TSHELL_INFO(TEXT("We aren't player 0 for some reason."));
            return(DPERR_GENERIC);
        }

        m_hClientThread = CreateThread(NULL, 0, StartClientThreadProc,
                            (LPVOID) this, 0, &m_dwClientId);

        return(DP_OK);
    }
    else if (lpSDesc->dwFlags & DPOPEN_OPENSESSION)
    {
        if (GetSessionData(lpSDesc->dwSession))
        {
            SPMSG_ENUM  Msg;
            UINT            BufferLen;

            if (m_bPlayer0 || m_usGamePort == 0)
                return(DPERR_GENERIC);

            ResetEvent(m_hBlockingEvent);

            m_hClientThread = CreateThread(NULL, 0, StartClientThreadProc,
                                (LPVOID) this, 0, &m_dwClientId);

            if (WaitForSingleObject(m_hBlockingEvent, 9000) == WAIT_TIMEOUT)
                return(DPERR_GENERIC);

            Msg.dpHdr.dwConnect1    = DPSYS_KYRA;
            Msg.dpHdr.dwConnect2    = DPSYS_HALL;
            Msg.dpHdr.usSeq         = NextSequence();
            Msg.dwType              = DPSYS_OPEN;
            Msg.dpSessionDesc       = *lpSDesc;
            Msg.usPort              = m_usGamePort;
            Msg.dwUnique            = m_dwUnique;
            Msg.usVerMajor          = DPVERSION_MAJOR;
            Msg.usVerMinor          = DPVERSION_MINOR;

            BufferLen = sizeof(SPMSG_ENUM);

            ResetEvent(m_hBlockingEvent);
            if (SendTo(m_ClientSocket, &m_NSSockAddr,
                    m_SessionAddrLen, (char *) &Msg, &BufferLen) != 0)
            {
                TSHELL_INFO(TEXT("Enum SendTo failed."));
            }

            if (WaitForSingleObject(m_hBlockingEvent, 9000) == WAIT_TIMEOUT)
            {
                TSHELL_INFO(TEXT("We timed out."));
            }


            EnumDataLock();

            if (m_ppSessionArray)
            {
                for (ii = 0; ii < m_dwSessionPrev; ii++)
                    lfree(m_ppSessionArray[ii]);
                lfree(m_ppSessionArray);
                m_ppSessionArray = NULL;
                m_dwSessionPrev  = 0;
                m_dwSessionAlloc = 0;
            }

            EnumDataUnlock();

            if (m_bConnected == FALSE)
                return(DPERR_GENERIC);



            return(DP_OK);
        }
        else
        {
            return(DPERR_UNAVAILABLE);
        }
    }
    else
    {
        TSHELL_INFO(TEXT("Unhandled Open flags."));
        return(DPERR_UNSUPPORTED);
    }
}


// ----------------------------------------------------------
// CreatePlayer - registers new player, N.B. may fail if
// not currently connected to name server
// ----------------------------------------------------------
LONG    CImpIDP_SP::FindInvalidIndex()
{
    DWORD   ii;

    ParanoiaLock();
    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (m_aPlayer[ii].bValid == FALSE)
        {
            ParanoiaUnlock();
            return(ii);
        }

    ParanoiaUnlock();
    return(-1);
}
VOID CImpIDP_SP::LocalMsg(LONG iIndex, LPVOID lpv, DWORD dwSize)
{

    LONG ii;

    ParanoiaLock();
    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (   ii != iIndex
            && m_aPlayer[ii].bValid
            && m_aPlayer[ii].bLocal
            && m_aPlayer[ii].bPlayer)
                AddMessage(lpv, dwSize, m_aPlayer[ii].pid, 0, 0);

    ParanoiaUnlock();
}

//
// Obsolete? [johnhall]
//
VOID CImpIDP_SP::RemoteMsg(LONG iIndex, LPVOID lpv, DWORD dwSize)
{
    SPMSG_GENERIC Msg;
    DWORD dwTotal = dwSize + sizeof(DPHDR);
    DWORD         ii;


    if (!m_bConnected)
        return;

    Msg.dpHdr.usCookie = DPSYS_SYS;
    Msg.dpHdr.to       = 0;
    Msg.dpHdr.from     = 0;
    Msg.dpHdr.usCount  = (USHORT) dwSize;
    Msg.dpHdr.usGame   = (USHORT) m_usGameCookie;
    Msg.dpHdr.usSeq    = NextSequence();
    memcpy( (LPVOID) &Msg.sMsg, lpv, dwSize);

    ParanoiaLock();
    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (   ii != (DWORD) iIndex
            && m_aPlayer[ii].bValid
            && m_aPlayer[ii].bLocal == FALSE
            && m_aPlayer[ii].bPlayer)
            {
                PostPlayerMessage( (LONG) ii, (LPVOID) &Msg, dwTotal);
                TSHELL_INFO(TEXT("Post Player Message in RemoteMsg."));
            }
    ParanoiaUnlock();
}

BOOL CImpIDP_SP::PostGameMessage(LPVOID lpv, DWORD dw)
{

    DWORD ii;

    ParanoiaLock();
    for (ii = 0; ii < m_cMachines; ii++)
        if (SendTo(m_ClientSocket, &m_aMachineAddr[ii], sizeof(SOCKADDR), (char *) lpv, (LPUINT) &dw) != 0)
        {
            TSHELL_INFO(TEXT("Send Failed"));
        }
        else
        {
            LPDWORD lpdw = (LPDWORD) &m_aMachineAddr[ii];

            DBG_INFO((DBGARG, TEXT("Machine %d  Addr %8x %8x %8x %8x"), ii,
                    lpdw[0], lpdw[1], lpdw[2], lpdw[3]));
        }

    ParanoiaUnlock();
    return(TRUE);
}

BOOL CImpIDP_SP::PostPlayerMessage(LONG iIndex, LPVOID lpv, DWORD dw)
{
    UINT err;

    if ((err = SendTo(m_ClientSocket, &m_aPlayer[iIndex].sockaddr, sizeof(SOCKADDR), (char *) lpv, (LPUINT) &dw)) != 0)
    {
        DBG_INFO((DBGARG, TEXT("Send Failed %d"), err));
        return(FALSE);
    }
    return(TRUE);
}

BOOL CImpIDP_SP::PostNSMessage(LPVOID lpv, DWORD dw)
{
    if (SendTo(m_ClientSocket, &m_NSSockAddr, sizeof(SOCKADDR), (char *) lpv, (LPUINT) &dw) != 0)
    {
        TSHELL_INFO(TEXT("Send Failed"));
        return(FALSE);
    }
    return(TRUE);
}
extern BOOL SetupLocalPlayer(DPID pid, HANDLE hEvent);
HRESULT CImpIDP_SP::CreatePlayer(
    LPDPID pPlayerID,
    LPSTR pNickName,
    LPSTR pFullName,
    LPHANDLE lpReceiveEvent,
    BOOL  bPlayer
)
{
    DWORD jj;
    SPMSG_ADDPLAYER *pMsg;
    HANDLE  hEvent = NULL;
    BOOL    bb     = TRUE;
    HRESULT hr     = DP_OK;
    LONG    iIndex;
    DPMSG_ADDPLAYER dpAdd;
    SPMSG_ADDPLAYER spmsg_addplayer;
    USHORT          usLocalSeq;

    // TSHELL_INFO(TEXT("Enter Create Player"));

    if (m_bConnected == FALSE)
        if (m_bPlayer0 != TRUE)
            return(DPERR_NOCONNECTION);

    if (m_bEnablePlayerAdd == FALSE && bPlayer == TRUE)
        return(DPERR_CANTCREATEPLAYER);

    if (m_dpDesc.dwMaxPlayers <= m_dpDesc.dwCurrentPlayers)
    {
        DBG_INFO((DBGARG, TEXT("CreatePlayer: at max players already. %d"),
            m_dpDesc.dwMaxPlayers));
        return(DPERR_CANTADDPLAYER);
    }

    if (m_iPlayerIndex != -1)
    {
        TSHELL_INFO(TEXT("Player index not -1, create already in progress."));
        return(DPERR_GENERIC);
    }

    if (m_hNewPlayerEvent)
        return(DPERR_GENERIC);

    if (!(hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        TSHELL_INFO(TEXT("CreatePlayer: CreateEvent failure."));
        return(DPERR_GENERIC);
    }
    else
    {
        ; // DBG_INFO((DBGARG, TEXT("CreatePlayer %8x Event"), hEvent));
    }

    ParanoiaLock();
    iIndex = FindInvalidIndex();

    if (iIndex == -1)
    {
        ParanoiaUnlock();
        return(DPERR_GENERIC);
    }

    dpAdd.dwType = DPSYS_ADDPLAYER;
    dpAdd.dwPlayerType = bPlayer;
    dpAdd.dpId     = 0;
    dpAdd.dwCurrentPlayers = m_dpDesc.dwCurrentPlayers;
    lstrcpy( dpAdd.szShortName, pNickName);
    lstrcpy( dpAdd.szLongName , pFullName);


    pMsg = &spmsg_addplayer;
    usLocalSeq = NextSequence();
    pMsg->dpHdr.usCookie = DPSYS_SYS;
    pMsg->dpHdr.to       = 0;
    pMsg->dpHdr.from     = 0;
    pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
    pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
    pMsg->dpHdr.usSeq    = usLocalSeq;
    pMsg->dwUnique       = m_dwUnique;
    memset(&pMsg->sockaddr, 0x00, sizeof(SOCKADDR));

    if (m_bPlayer0)
    {
        if (!bPlayer)
        {
            m_aPlayer[iIndex].aGroup = (DPID *) lmalloc(sizeof(DPID) * MAX_PLAYERS);
            if (m_aPlayer[iIndex].aGroup == NULL)
            {
                ParanoiaUnlock();
                return(DPERR_NOMEMORY);
            }
            else
                memset(m_aPlayer[iIndex].aGroup, 0x00, sizeof(DPID) * MAX_PLAYERS);
        }
        m_dpDesc.dwCurrentPlayers++;

        m_aPlayer[iIndex].pid = (DPID) m_dwNextPlayer++;
        lstrcpy( m_aPlayer[iIndex].chNickName, pNickName);
        lstrcpy( m_aPlayer[iIndex].chFullName, pFullName);
        m_aPlayer[iIndex].bValid  = TRUE;
        m_aPlayer[iIndex].bPlayer = bPlayer;
        m_aPlayer[iIndex].hEvent  = hEvent;
        m_aPlayer[iIndex].bLocal  = TRUE;
        memset(&m_aPlayer[iIndex].sockaddr, 0x00, sizeof(SOCKADDR));



        dpAdd.dpId              = m_aPlayer[iIndex].pid;
        dpAdd.dwCurrentPlayers = m_dpDesc.dwCurrentPlayers;

        LocalMsg( iIndex, (LPVOID) &dpAdd, sizeof(DPMSG_ADDPLAYER));
        memcpy( (LPVOID) &pMsg->sMsg, &dpAdd, sizeof(DPMSG_ADDPLAYER));
        PostGameMessage((LPVOID) pMsg, sizeof(SPMSG_ADDPLAYER));

        hEvent = NULL;
        *pPlayerID = m_aPlayer[iIndex].pid;
        if (lpReceiveEvent)
            *lpReceiveEvent = m_aPlayer[iIndex].hEvent;
        SetupLocalPlayer(m_aPlayer[iIndex].pid, m_aPlayer[iIndex].hEvent);
        ParanoiaUnlock();
        return(DP_OK);
    }

    ParanoiaUnlock();

    m_hNewPlayerEvent = hEvent;
    //
    // BUGBUG for now, try once in Net provider.
    //
    for (jj = 0; jj < 1; jj++)
    {

        TSHELL_INFO(TEXT("Post AddPlayer message from a Client"));
        memcpy( (LPVOID) &pMsg->sMsg, &dpAdd, sizeof(DPMSG_ADDPLAYER));
        PostNSMessage( (LPVOID) pMsg, sizeof(SPMSG_ADDPLAYER));
        pMsg = NULL;

        if (WaitForSingleObject(m_hNewPlayerEvent, 1500) != WAIT_TIMEOUT)
        {
            if (m_iPlayerIndex != -1)
            {
                SetupLocalPlayer(m_aPlayer[m_iPlayerIndex].pid, m_hNewPlayerEvent);
                m_aPlayer[m_iPlayerIndex].hEvent = m_hNewPlayerEvent;
                if (lpReceiveEvent)
                    *lpReceiveEvent = m_aPlayer[m_iPlayerIndex].hEvent;
                m_hNewPlayerEvent = NULL;
                *pPlayerID = m_aPlayer[m_iPlayerIndex].pid;
                m_iPlayerIndex = -1;

                DBG_INFO((DBGARG, TEXT("Player Index %d Pid %d Current %d"),
                    iIndex, m_aPlayer[iIndex].pid, m_dpDesc.dwCurrentPlayers));

                return(DP_OK);
            }
        }

        ResetEvent(m_hNewPlayerEvent);
    }


    hr = DPERR_CANTADDPLAYER;


    m_hNewPlayerEvent = NULL;

    if (pMsg)
        lfree((HLOCAL) pMsg);
    if (hEvent)
        CloseHandle(hEvent);

    return(hr);

}

LONG CImpIDP_SP::GetPlayerIndex(DPID playerID)
{
    DWORD ii;
    DPID  pid = playerID;

    ParanoiaLock();

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid)
            if (m_aPlayer[ii].pid == pid)
            {
                ParanoiaUnlock();
                return(ii);
            }
    }

    ParanoiaUnlock();
    return(-1);
}


// ----------------------------------------------------------
// DestroyPlayer
// ----------------------------------------------------------
HRESULT CImpIDP_SP::DestroyPlayer( DPID playerID, BOOL bPlayer)
{
    LONG    iIndex;
    DWORD   ii, jj;

    DPMSG_GETPLAYER  dpGet;

    SPMSG_GETPLAYER  spmsg_getplayer;
    SPMSG_GETPLAYER *pMsg;
    HANDLE  hEvent = NULL;
    HRESULT hr     = DP_OK;

    ParanoiaLock();

    if (    (iIndex = GetPlayerIndex(playerID)) == -1
         || m_aPlayer[iIndex].bPlayer != bPlayer)
    {
        ParanoiaUnlock();
        return(DPERR_INVALIDPLAYER);
    }

    if (bPlayer)
    {
        dpGet.dwType     = DPSYS_DELETEPLAYER;
    }
    else
    {
        dpGet.dwType     = DPSYS_DELETEGROUP;
    }

    dpGet.dpId        = m_aPlayer[iIndex].pid;

    if (m_aPlayer[iIndex].bLocal)
    {
        CloseHandle(m_aPlayer[iIndex].hEvent);
        FlushQueue(playerID);
    }

    m_aPlayer[iIndex].bValid = FALSE;
    m_dpDesc.dwCurrentPlayers--;
    if (m_aPlayer[iIndex].aGroup)
        lfree(m_aPlayer[iIndex].aGroup);


    LocalMsg(iIndex, (LPVOID) &dpGet, sizeof(DPMSG_GETPLAYER));
    pMsg = &spmsg_getplayer;
    pMsg->dpHdr.usCookie = DPSYS_SYS;
    pMsg->dpHdr.to       = 0;
    pMsg->dpHdr.from     = 0;
    pMsg->dpHdr.usCount  = sizeof(DPMSG_GETPLAYER);
    pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
    memcpy( (LPVOID) &pMsg->sMsg, (LPVOID) &dpGet, sizeof(DPMSG_GETPLAYER));

    if (m_bPlayer0)
    {
        PostGameMessage((LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
    }
    else
    {
        PostNSMessage( (LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
    }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (   m_aPlayer[ii].bValid  == TRUE
            && m_aPlayer[ii].bPlayer == FALSE
            && m_aPlayer[ii].aGroup)
        {
            for (jj = 0; jj < MAX_PLAYERS; jj++)
            {
                if (m_aPlayer[ii].aGroup[jj] == playerID)
                {
                    m_aPlayer[ii].aGroup[jj] = 0;
                    break;
                }
            }

        }
    }


    ParanoiaUnlock();
    return(DP_OK);

}


// ----------------------------------------------------------
// Close - close the connection
// ----------------------------------------------------------
HRESULT CImpIDP_SP::Close( DWORD dwFlag)
{
    DWORD ii;
    DWORD dwTickBegin;

    dwTickBegin = GetTickCount();

    ParanoiaLock();

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid)
        {
            if ( ( m_aPlayer[ii].bLocal && m_aPlayer[ii].bPlayer == TRUE))
            {
                DestroyPlayer(m_aPlayer[ii].pid, TRUE);
            }
            m_aPlayer[ii].bValid = FALSE;
        }
    }


    m_bShutDown  = TRUE;
    m_bConnected = FALSE;
    m_bPlayer0   = FALSE;
    m_fpEnumSessions = NULL;
    m_bRunEnumReceiveLoop = FALSE;
    m_fpEnumPlayers  = NULL;

    TSHELL_INFO(TEXT("Close:: Closing Socket."));
    if (m_hNSThread && m_ServerSocket != INVALID_SOCKET)
        CloseSocket(m_ServerSocket, 2);

    m_ServerSocket = INVALID_SOCKET;

    if (m_hClientThread && m_ClientSocket != INVALID_SOCKET)
        CloseSocket(m_ClientSocket, 2);

    m_ClientSocket = INVALID_SOCKET;

    TSHELL_INFO(TEXT("Close:: Socket Closed."));
    ParanoiaUnlock();

    if (m_aMachineAddr)
    {
        lfree(m_aMachineAddr);
        m_aMachineAddr = NULL;
        m_cMachines    = 0;
    }

    if (m_hNSThread)
    {
        if (WaitForSingleObject(m_hNSThread, 4000) == WAIT_TIMEOUT)
        {
            TSHELL_INFO(TEXT("Terminating m_hNSThread"));
            TerminateThread(m_hNSThread, 0);
        }
        m_hNSThread = NULL;
    }

    if (m_hEnumThread)
    {
        SetThreadPriority(m_hEnumThread, THREAD_PRIORITY_NORMAL);
        TSHELL_INFO(TEXT("EnumSessions:: Closing Socket."));

        EnumDataLock();

        if (m_EnumSocket)
            CloseSocket(m_EnumSocket, 2);

        m_EnumSocket = INVALID_SOCKET;

        EnumDataUnlock();

        TSHELL_INFO(TEXT("EnumSessions:: Socket Closed."));

        if (WaitForSingleObject(m_hEnumThread, 4000) == WAIT_TIMEOUT)
            TerminateThread(m_hEnumThread, 0);
        m_bEnumSocket = FALSE;
        m_hEnumThread = NULL;
    }

    if (m_hClientThread)
    {
        SetThreadPriority(m_hClientThread, THREAD_PRIORITY_NORMAL);
        if (WaitForSingleObject(m_hClientThread, 4000) == WAIT_TIMEOUT)
        {
            TSHELL_INFO(TEXT("Terminating m_hClientThread"));
            TerminateThread(m_hClientThread, 0);
        }
        m_bClientSocket = FALSE;
        m_hClientThread = NULL;
    }

    ShutdownWinSock();

    _try
    {
        if (hOnlyOneTCP)
        {
            CloseHandle(hOnlyOneTCP);
        }

        if (hOnlyOneIPX)
        {
            CloseHandle(hOnlyOneIPX);
        }
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
        TSHELL_INFO(TEXT("Exception closing handle."));
    }

    hOnlyOneTCP = NULL;
    hOnlyOneIPX = NULL;

    if (dwFlag == DPLAY_CLOSE_USER)
    {
        InitializeWinSock();
        m_bShutDown  = FALSE;
    }

    DBG_INFO((DBGARG, TEXT("Close Took %d Ticks"), GetTickCount() - dwTickBegin));

    return(DP_OK);
}

// ----------------------------------------------------------
// GetName -
// ----------------------------------------------------------
HRESULT CImpIDP_SP::GetPlayerName(
    DPID dpID,
    LPSTR lpNickName,          // buffer to hold name
    LPDWORD pdwNickNameLength, // length of name buffer
    LPSTR lpFullName,
    LPDWORD pdwFullNameLength
)
{
    LONG    iIndex;

    HRESULT hr     = DP_OK;
    DPID    pid = (DPID) dpID;

    ParanoiaLock();
    if ((iIndex = GetPlayerIndex(dpID)) != -1)
    {
        if (m_aPlayer[iIndex].pid == dpID)
        {
            lstrcpy( lpNickName, m_aPlayer[iIndex].chNickName);
            lstrcpy( lpFullName, m_aPlayer[iIndex].chFullName);
            *pdwNickNameLength = lstrlen(lpNickName) + 1;
            *pdwFullNameLength = lstrlen(lpFullName) + 1;
        }
        else
            hr = DPERR_INVALIDPID;

    }
    else
    {
        hr = DPERR_INVALIDPID;
    }

    ParanoiaUnlock();

    return(hr);
}


HRESULT CImpIDP_SP::EnumGroupPlayers(
                              DPID dwGroupPid,
                              LPDPENUMPLAYERSCALLBACK EnumCallback,
                              LPVOID pContext,
                              DWORD dwFlags)
{

    DWORD   ii;
    HRESULT hr     = DP_OK;
    LONG    iIndexG;
    LONG    iIndexP;
    DPID    pid;

    ParanoiaLock();

    iIndexG = GetPlayerIndex(dwGroupPid);

    if (iIndexG == -1 || m_aPlayer[iIndexG].pid != dwGroupPid)
        hr = DPERR_INVALIDPID;

    if (m_aPlayer[iIndexG].bPlayer)
        hr = DPERR_INVALIDPID;

    if (hr == DP_OK)
        for (ii = 0; ii < MAX_PLAYERS; ii++)
        {
            if ((pid = m_aPlayer[iIndexG].aGroup[ii]) != 0)
            {
                iIndexP = GetPlayerIndex(pid);
                if (iIndexP != -1)
                {
                    (EnumCallback)((DPID) m_aPlayer[iIndexP].pid,
                        m_aPlayer[iIndexP].chNickName,
                        m_aPlayer[iIndexP].chFullName,
                          ((m_aPlayer[iIndexP].bLocal  ) ? DPENUMPLAYERS_LOCAL : DPENUMPLAYERS_REMOTE)
                        | ((!m_aPlayer[iIndexP].bPlayer) ? DPENUMPLAYERS_GROUP : 0),
                        pContext);
                }
                else
                {
                    m_aPlayer[iIndexG].aGroup[ii] = 0;
                }
            }
        }

    ParanoiaUnlock();
    return(hr);
}

// ----------------------------------------------------------
// EnumPlayers - return info on peer connections.
// ----------------------------------------------------------
HRESULT CImpIDP_SP::EnumPlayers(
                              DWORD dwSessionId,
                              LPDPENUMPLAYERSCALLBACK EnumCallback,
                              LPVOID pContext,
                              DWORD dwFlags)
{

    DWORD   ii;
    HRESULT hr     = DP_OK;
    BOOL    bDone  = FALSE;
    BOOL    bFound = FALSE;
    DWORD   dwTimeout;

    if (dwFlags & DPENUMPLAYERS_PREVIOUS)
    {
        return(DPERR_UNSUPPORTED);
    }

    if (dwFlags & DPENUMPLAYERS_SESSION)
    {
        //
        // We can't let them call us inside a enumsessions callback anymore.
        //
        if (m_bConnected || m_fpEnumSessions || m_bPlayer0 )
        {
            TSHELL_INFO(TEXT("EnumPlayers: Unsupported."));
            return(DPERR_UNSUPPORTED);
        }

        if (GetSessionData(dwSessionId))
        {
            SPMSG_GENERIC pMsg;
            UINT          BufferLen = sizeof(SPMSG_GENERIC);

            TSHELL_INFO(TEXT("We are trying to retrieve player info."));

            m_fpEnumPlayers = EnumCallback;
            m_lpvPlayersContext = pContext;

            pMsg.dpHdr.usCookie = DPSYS_SYS;
            pMsg.dpHdr.to       = 0;
            pMsg.dpHdr.from     = 0;
            pMsg.dpHdr.usCount  = (USHORT) sizeof(DPMSG_GENERIC);
            pMsg.dpHdr.usGame   = 0;
            pMsg.dpHdr.usSeq    = NextSequence();
            pMsg.sMsg.dwType    = DPSYS_ENUMALLPLAYERS;

            if (SendTo(m_EnumSocket, &m_NSSockAddr,
                    m_SessionAddrLen, (char *) &pMsg, &BufferLen) != 0)
            {
                TSHELL_INFO(TEXT("Enum SendTo failed."));
            }


            memset( (LPVOID) &m_spmsgAddPlayer, 0x00, sizeof(SPMSG_ADDPLAYER));
            ResetEvent(m_hPlayerBlkEventMain);
            ResetEvent(m_hPlayerBlkEventRead);

            //
            // Hard code timeout.
            //
            dwTimeout = 1000;
            while (!bDone)
            {
                DWORD   dwRet;


                //
                // Wait for DPSYS_ENUMPLAYERRESP to wake us up.
                //
                dwRet = WaitForSingleObject(m_hPlayerBlkEventMain, dwTimeout);

                //
                // Prevent another DPSYS_ENUMPLAYERRESP before we've processed this one.
                //
                PlayerDataLock();

                //
                // Reset our wait, and tell DPSYS_ENUMPLAYERRESP it can continue and
                // pick another reply packet up.
                //
                ResetEvent(m_hPlayerBlkEventMain);
                SetEvent(m_hPlayerBlkEventRead);

                //
                // Only process if our enum sessions is still valid.
                //
                if (m_fpEnumPlayers)
                {
                    if( dwRet == WAIT_TIMEOUT)
                    {
                        m_fpEnumPlayers = NULL;
                        bDone = TRUE;
                        TSHELL_INFO(TEXT("End EnumPlayers on Timeout."));
                    }
                    else
                    {
                        bFound = TRUE;
                        TSHELL_INFO(TEXT("Found a remote player."));

                        _try
                        {
                            if ((m_fpEnumPlayers)(m_spmsgAddPlayer.sMsg.dpId,
                                                  (LPSTR) m_spmsgAddPlayer.sMsg.szShortName,
                                                  (LPSTR) m_spmsgAddPlayer.sMsg.szLongName,
                                                  0,
                                                  m_lpvPlayersContext) == FALSE)
                            {
                                m_fpEnumPlayers = NULL;
                                bDone = TRUE;
                                TSHELL_INFO(TEXT("End EnumPlayers."));
                            }
                            else
                                dwTimeout = 250;

                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            m_fpEnumPlayers = NULL;
                            bDone = TRUE;
                            TSHELL_INFO(TEXT("End EnumPlayers."));
                        }

                    }
                }
                else
                {
                    bDone = TRUE;
                }

                PlayerDataUnlock();

            }




            return(DP_OK);
        }
        else
        {
            TSHELL_INFO(TEXT("EnumPlayers: bad session ID"));
            return(DPERR_INVALIDOBJECT);
        }

    }

    ParanoiaLock();
    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (m_aPlayer[ii].bValid
            && (   (m_aPlayer[ii].bPlayer == FALSE &&  (dwFlags & DPENUMPLAYERS_GROUP))
                || (m_aPlayer[ii].bPlayer == TRUE  && !(dwFlags & DPENUMPLAYERS_NOPLAYERS))))
        {

            if ((EnumCallback)((DPID) m_aPlayer[ii].pid,
                                      m_aPlayer[ii].chNickName,
                                      m_aPlayer[ii].chFullName,
                  ((m_aPlayer[ii].bLocal  ) ? DPENUMPLAYERS_LOCAL : DPENUMPLAYERS_REMOTE)
                | ((!m_aPlayer[ii].bPlayer) ? DPENUMPLAYERS_GROUP : 0),
                pContext) == FALSE)
            {
                break;
            }
        }

    ParanoiaUnlock();

    return(DP_OK);
}

HRESULT CImpIDP_SP::EnumSessions(

                                       LPDPSESSIONDESC lpSDesc,
                                       DWORD           dwTimeout,
                                       LPDPENUMSESSIONSCALLBACK EnumCallback,
                                       LPVOID lpvContext,
                                       DWORD dwFlags)
{
    SPMSG_ENUM  Msg;
    UINT BufferLen;
    SOCKADDR SockAddr;
    DWORD   dwTimeBegin = GetTickCount();
    DWORD   dwTimeNow;
    BOOL    bFound = FALSE;
    BOOL    bDone  = FALSE;
    DWORD   ii;

    if (dwFlags & DPENUMSESSIONS_PREVIOUS)
        return(DPERR_UNSUPPORTED);

    if (m_bConnected || m_bPlayer0)
        return(DPERR_UNSUPPORTED);


    EnumDataLock();

    if (m_ppSessionArray)
    {
        for (ii = 0; ii < m_dwSessionPrev; ii++)
            lfree(m_ppSessionArray[ii]);
        lfree(m_ppSessionArray);
        m_ppSessionArray = NULL;
        m_dwSessionPrev  = 0;
        m_dwSessionAlloc = 0;
    }

    if (m_bRunEnumReceiveLoop == FALSE)
    {
        m_usGamePort = 0;
        memset(&m_NSSockAddr, 0x00, sizeof(SOCKADDR));

        ResetEvent(m_hBlockingEvent);

        m_fpEnumSessions        = EnumCallback;
        m_bRunEnumReceiveLoop   = TRUE;
        m_lpvSessionContext     = lpvContext;

        m_dwSession = 1;


        m_hEnumThread = CreateThread(NULL, 0, StartClientThreadProc,
                            (LPVOID) this, 0, &m_dwEnumId);


        if (   WaitForSingleObject(m_hBlockingEvent, 9000) == WAIT_TIMEOUT
            || !m_bEnumSocket)
        {
            EnumDataUnlock();
            return(DPERR_GENERIC);
        }
    }
    else
    {
        m_fpEnumSessions        = EnumCallback;
        m_lpvSessionContext     = lpvContext;
    }
    EnumDataUnlock();


    Msg.dpHdr.dwConnect1    = DPSYS_KYRA;
    Msg.dpHdr.dwConnect2    = DPSYS_HALL;
    Msg.dwType              = DPSYS_ENUM;
    Msg.dpSessionDesc       = *lpSDesc;
    Msg.usPort              = 0;
    Msg.dwUnique            = 0;
    Msg.usVerMajor          = DPVERSION_MAJOR;
    Msg.usVerMinor          = DPVERSION_MINOR;

    memset(&SockAddr, 0, sizeof(SOCKADDR));

    // Depending on the address family specified, we'll try to find the
    // Name Server just a little differently.
    //
    if (GetSockAddress(&SockAddr, NULL, DPNS_PORT, NULL, TRUE))
    {
        BufferLen = sizeof(SPMSG_ENUM);

        memset( (LPVOID) &m_spmsgEnum, 0x00, sizeof(SPMSG_ENUM));
        ResetEvent(m_hEnumBlkEventMain);
        ResetEvent(m_hEnumBlkEventRead);

        if (SendTo(m_EnumSocket, &SockAddr, sizeof(SockAddr), (char *) &Msg, &BufferLen) != 0)
        {
            TSHELL_INFO(TEXT("Enum SendTo failed."));
        }

        // TSHELL_INFO(TEXT("Enum SendTo success."));
    }
    else
    {
        TSHELL_INFO(TEXT("Didn't get a proper sock address."));
        return(DPERR_GENERIC);
    }

    while(!bDone)
    {
        DWORD            dwRet;
        //
        // Wait for DPSYS_ENUM_REPLY to wake us up.
        //
        dwRet = WaitForSingleObject(m_hEnumBlkEventMain, dwTimeout);

        //
        // Prevent another DPSYS_ENUM_REPLY before we've processed this one.
        //
        EnumDataLock();
        DBG_INFO((DBGARG, TEXT("Tick %d"), GetTickCount()));

        //
        // Reset our wait, and tell DPSYS_ENUM_REPLY it can continue and
        // pick another reply packet up.
        //
        ResetEvent(m_hEnumBlkEventMain);
        SetEvent(m_hEnumBlkEventRead);


        //
        // Only process if our enum sessions is still valid.
        //
        if (m_fpEnumSessions)
        {
            if( dwRet == WAIT_TIMEOUT)
            {
                memset( (LPVOID) &m_spmsgEnum, 0x00, sizeof(SPMSG_ENUM));
                _try
                {
                    if ((m_fpEnumSessions)(NULL, m_lpvSessionContext, &dwTimeout, DPESC_TIMEDOUT) == FALSE)
                    {
                        m_fpEnumSessions = NULL;
                        bDone = TRUE;
                        TSHELL_INFO(TEXT("End EnumSessions."));
                    }
                    else
                    {
                        dwTimeBegin = GetTickCount();
                    }

                }
                _except(EXCEPTION_EXECUTE_HANDLER)
                {
                    m_fpEnumSessions = NULL;
                    bDone = TRUE;
                    TSHELL_INFO(TEXT("Exception encountered."));
                }

            }
            else
            {
                bFound = TRUE;

                DBG_INFO((DBGARG, TEXT("Session %d Name %s"),
                    m_spmsgEnum.dpSessionDesc.dwSession,
                    m_spmsgEnum.dpSessionDesc.szSessionName));

                _try
                {
                    if ((m_fpEnumSessions)((LPDPSESSIONDESC) &m_spmsgEnum.dpSessionDesc,
                            m_lpvSessionContext, NULL, 0 ) == FALSE)
                    {
                        m_fpEnumSessions = NULL;
                        bDone = TRUE;
                        TSHELL_INFO(TEXT("End EnumSessions."));
                    }
                    else
                    {
                        if (dwTimeout != 0xffffffff)
                        {
                            dwTimeNow = GetTickCount();
                            if ( (dwTimeNow - dwTimeBegin) > dwTimeout)
                                dwTimeout = 0;
                            else
                            {
                                dwTimeout -= (dwTimeNow - dwTimeBegin);
                                dwTimeBegin = dwTimeNow;
                            }
                        }
                    }

                }
                _except(EXCEPTION_EXECUTE_HANDLER)
                {
                    m_fpEnumSessions = NULL;
                    bDone = TRUE;
                    TSHELL_INFO(TEXT("Exception encountered."));
                }
            }
        }
        else
        {
            bDone = TRUE;
        }

        EnumDataUnlock();
        DBG_INFO((DBGARG, TEXT("Tick %d"), GetTickCount()));
    }

    return((bFound) ? DP_OK : DPERR_NOSESSIONS);
}

VOID CImpIDP_SP::ISend(
        LONG    iFrom,
        LONG    iTo,
        DWORD   dwFlags,
        LPVOID  lpvBuffer,
        DWORD   dwBuffSize)
{

    MSG_BUILDER *pMsg;
    DWORD        ii;
    LONG         iIndexT;

    ParanoiaLock();

    if (m_aPlayer[iTo].bPlayer == FALSE)
    {
        for (ii = 0; ii < MAX_PLAYERS; ii++)
        {
            if (m_aPlayer[iTo].aGroup[ii])
            {
                if ((iIndexT = GetPlayerIndex(m_aPlayer[iTo].aGroup[ii])) != -1)
                    ISend(iFrom, iIndexT, dwFlags, lpvBuffer, dwBuffSize);
            }
        }
    }
    else
    {
        if (m_aPlayer[iTo].bLocal)
        {
            AddMessage(lpvBuffer,
                       dwBuffSize,
                       m_aPlayer[iTo].pid,
                       m_aPlayer[iFrom].pid,
                       dwFlags & DPSEND_HIGHPRIORITY);

        }
        else
        {
            char chBuffer[MAX_MSG];

            pMsg = (MSG_BUILDER *) chBuffer;
            pMsg->dpHdr.usCookie = (dwFlags & DPSEND_HIGHPRIORITY) ? DPSYS_HIGH : DPSYS_USER;
            pMsg->dpHdr.to       = (USHORT) m_aPlayer[iTo].pid;
            pMsg->dpHdr.from     = (USHORT) m_aPlayer[iFrom].pid;
            pMsg->dpHdr.usCount  = (USHORT) dwBuffSize;
            pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
            memcpy( pMsg->chMsgCompose, lpvBuffer, dwBuffSize);
            PostPlayerMessage( iTo, (LPVOID) pMsg, sizeof(DPHDR) + dwBuffSize);
        }
    }

    ParanoiaUnlock();

}

// ----------------------------------------------------------
// Send - transmit data over socket.
// ----------------------------------------------------------
HRESULT CImpIDP_SP::Send(
        DPID    from,
        DPID    to,
        DWORD   dwFlags,
        LPVOID  lpvBuffer,
        DWORD   dwBuffSize)
{
    DWORD        ii;
    LONG         iFrom;
    BOOL         bSent = FALSE;

    if (from == 0)
    {
        return(DPERR_INVALIDPID);
    }

    if (dwBuffSize > MAX_MSG)
        return(DPERR_SENDTOOBIG);

    ParanoiaLock();
    iFrom = GetPlayerIndex(from);

#ifdef DEBUG
    DBG_INFO((DBGARG, TEXT("Send From Pid %d Player Index %d"), from, iFrom));

        if (iFrom == -1)
            for (ii = 0; ii < MAX_PLAYERS; ii++)
            {
                DBG_INFO((DBGARG, TEXT("Index %d Valid %d Pid %d Local %d"),
                    ii,
                    m_aPlayer[ii].bValid,
                    m_aPlayer[ii].pid,
                    m_aPlayer[ii].bLocal));
            }
#endif


    if (iFrom == -1 || ! m_aPlayer[iFrom].bLocal)
    {
        ParanoiaUnlock();
        return(DPERR_INVALIDPID);
    }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (m_aPlayer[ii].bValid && m_aPlayer[ii].pid != from)
        {
            if (   (to == 0 && m_aPlayer[ii].bPlayer == TRUE)
                || m_aPlayer[ii].pid == to)
            {
                ISend(iFrom, ii, dwFlags, lpvBuffer, dwBuffSize);
                bSent = TRUE;
            }
        }

    ParanoiaUnlock();

    return(bSent ? DP_OK : DPERR_INVALIDPID);
}

// ----------------------------------------------------------
//  Receive - receive message
// ----------------------------------------------------------
HRESULT CImpIDP_SP::Receive(
        LPDPID   pidfrom,
        LPDPID   pidto,
        DWORD    dwFlags,
        LPVOID   lpvBuffer,
        LPDWORD  lpdwSize)
{
    HRESULT hr;
    LONG    iIndex;
    BOOL    bb;

    ParanoiaLock();

    bb = TRUE;

    if (dwFlags & DPRECEIVE_TOPLAYER)
    {
        iIndex = GetPlayerIndex(*pidto);

        if (iIndex == -1 || m_aPlayer[iIndex].bPlayer == FALSE)
            bb = FALSE;
    }

    if ((dwFlags & DPRECEIVE_FROMPLAYER) && *pidfrom != 0)
    {
        iIndex = GetPlayerIndex(*pidfrom);

        if (iIndex == -1 || m_aPlayer[iIndex].bPlayer == FALSE)
            bb = FALSE;
    }

    ParanoiaUnlock();

    if (bb == FALSE)
    {
        return(DPERR_INVALIDPID);
    }

    hr = GetQMessage(lpvBuffer, lpdwSize, pidto, pidfrom, dwFlags,
                        dwFlags & DPRECEIVE_PEEK);
    return(hr);
}


HRESULT CImpIDP_SP::SetPlayerName(
                DPID  pid,
                LPSTR lpFriendlyName,
                LPSTR lpFormalName,
                BOOL  bPlayer)
{
    SPMSG_ADDPLAYER spmsg_addplayer;
    SPMSG_ADDPLAYER *pMsg;


    //
    // Send DPSYS_SETPLAYER to nameserver.
    //

    ParanoiaLock();
    LONG iIndex = GetPlayerIndex(pid);

    if (iIndex == -1 || m_aPlayer[iIndex].bPlayer != bPlayer)
    {
        ParanoiaUnlock();
        return(DPERR_INVALIDPLAYER);
    }


    lstrcpyn( m_aPlayer[iIndex].chNickName, lpFriendlyName, DPSHORTNAMELEN);
    lstrcpyn( m_aPlayer[iIndex].chFullName, lpFormalName  , DPLONGNAMELEN);

    pMsg = &spmsg_addplayer;

    pMsg->dpHdr.usCookie = DPSYS_SYS;
    pMsg->dpHdr.to       = 0;
    pMsg->dpHdr.from     = 0;
    pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
    pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
    pMsg->sMsg.dwType         = DPSYS_SETPLAYER;
    pMsg->sMsg.dwPlayerType        = bPlayer;
    pMsg->sMsg.dpId            = m_aPlayer[iIndex].pid;
    pMsg->sMsg.dwCurrentPlayers = m_dpDesc.dwCurrentPlayers;

    lstrcpy( pMsg->sMsg.szShortName, lpFriendlyName);
    lstrcpy( pMsg->sMsg.szLongName,  lpFormalName);
    memcpy( &pMsg->sockaddr, &m_aPlayer[iIndex].sockaddr, sizeof(SOCKADDR));

    if (m_bPlayer0)
    {
        LocalMsg( iIndex, (LPVOID) pMsg, sizeof(DPMSG_ADDPLAYER));
        PostGameMessage(  (LPVOID) pMsg, sizeof(SPMSG_ADDPLAYER));
    }
    else
    {
        PostNSMessage( pMsg, sizeof(SPMSG_ADDPLAYER));
    }

    ParanoiaUnlock();
    return(DP_OK);
}

HRESULT CImpIDP_SP::SaveSession(LPVOID lpv, LPDWORD lpdw)
{
    return(DPERR_UNSUPPORTED);
}


HRESULT CImpIDP_SP::SetPrevSession(LPSTR lpName, LPVOID lpv, DWORD dw)
{
    return(DPERR_UNSUPPORTED);
}


HRESULT CImpIDP_SP::SetPrevPlayer(LPSTR lpName, LPVOID lpv, DWORD dw)
{
    //
    //
    // This doesn't make sense for a serial point to point SP.
    //
    TSHELL_INFO( TEXT("not currently supported") );
    return(DPERR_UNSUPPORTED);
}

HRESULT CImpIDP_SP::EnableNewPlayers(BOOL bEnable)
{
    //
    // Implementation not set, and won't follow this calling convention.
    // ignore for now.
    //
    SPMSG_ENABLEPLAYER  spmsg_enableplayer;
    SPMSG_ENABLEPLAYER *pMsg = &spmsg_enableplayer;

    m_bEnablePlayerAdd = bEnable;
    pMsg->dpHdr.usCookie = DPSYS_SYS;
    pMsg->dpHdr.to       = 0;
    pMsg->dpHdr.from     = 0;
    pMsg->dpHdr.usCount  = sizeof(DPMSG_ENABLEPLAYER);
    pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
    pMsg->sMsg.dwType    = DPSYS_ENABLEPLAYER;
    pMsg->sMsg.bEnable   = bEnable;

    if (! m_bPlayer0)
        PostNSMessage( pMsg, sizeof(SPMSG_ENABLEPLAYER));
    else
        PostGameMessage( pMsg, sizeof(SPMSG_ENABLEPLAYER));


    return(DP_OK);
}

HRESULT CImpIDP_SP::GetPlayerCaps(
                    DPID pid,
                    LPDPCAPS lpDPCaps)
{
    LONG iIndex = GetPlayerIndex(pid);

    if (iIndex == -1 || m_aPlayer[iIndex].bPlayer == FALSE)
        return(DPERR_INVALIDPID);

    *lpDPCaps = m_dpcaps;
    if (m_aPlayer[iIndex].bLocal)
        lpDPCaps->dwLatency = 1;

    return(DP_OK);
}

HRESULT CImpIDP_SP::GetMessageCount(DPID pid, LPDWORD lpdw )
{
    //
    // Return count for this pid, if it is a local player we have
    // been tracking with Interlock calls.
    //
    LONG iIndex = GetPlayerIndex((DPID) pid);

    if (iIndex == -1 || m_aPlayer[iIndex].bPlayer == FALSE)
        return(DPERR_INVALIDPLAYER);

    if (m_aPlayer[iIndex].bLocal == FALSE)
        return(DPERR_INVALIDPLAYER);

    *lpdw = GetPlayerCount((DPID) pid);
    return(DP_OK);

}
HRESULT CImpIDP_SP::AddPlayerToGroup(
                        DPID dpIdGroup,
                        DPID dpIdPlayer)
{
    DPMSG_GROUPADD dpGAdd;
    LONG           iIndexG;
    LONG           iIndexP;
    DWORD          ii;
    SPMSG_GROUPADD spmsg_groupadd;
    SPMSG_GROUPADD *pMsg = &spmsg_groupadd;

    ParanoiaLock();

    iIndexG = GetPlayerIndex(dpIdGroup);
    iIndexP = GetPlayerIndex(dpIdPlayer);

    if (   iIndexG == -1
        || m_aPlayer[iIndexG].bPlayer == TRUE
        || iIndexP == -1
        || m_aPlayer[iIndexP].bPlayer == FALSE)
        {
        ParanoiaUnlock();
        return(DPERR_INVALIDPID);
        }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[iIndexG].aGroup[ii] == m_aPlayer[iIndexP].pid)
        {
            ParanoiaUnlock();
            return(DPERR_INVALIDPID);
        }
    }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[iIndexG].aGroup[ii] == 0)
        {
            dpGAdd.dwType    = DPSYS_ADDPLAYERTOGROUP;
            dpGAdd.dpIdGroup  = m_aPlayer[iIndexG].pid;
            dpGAdd.dpIdPlayer = m_aPlayer[iIndexP].pid;

            ParanoiaUnlock();

            pMsg->dpHdr.usCookie = DPSYS_SYS;
            pMsg->dpHdr.to       = 0;
            pMsg->dpHdr.from     = 0;
            pMsg->dpHdr.usCount  = sizeof(DPMSG_GROUPADD);
            pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;

            memcpy( (LPVOID) &pMsg->sMsg, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));

            if (m_bPlayer0)
            {
                m_aPlayer[iIndexG].aGroup[ii] = m_aPlayer[iIndexP].pid;
                LocalMsg(iIndexG, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));
                PostGameMessage(  (LPVOID) pMsg, sizeof(SPMSG_GROUPADD));
            }
            else
            {
                PostNSMessage( pMsg, sizeof(SPMSG_GROUPADD));
            }
            return(DP_OK);
        }
    }

    ParanoiaUnlock();
    return(DPERR_GENERIC);
}

HRESULT CImpIDP_SP::DeletePlayerFromGroup(
                    DPID dpIdGroup,
                    DPID dpIdPlayer)
{
    DPMSG_GROUPADD dpGAdd;
    LONG           iIndexG;
    LONG           iIndexP;
    DWORD          ii;
    SPMSG_GROUPADD spmsg_groupadd;
    SPMSG_GROUPADD *pMsg = &spmsg_groupadd;

    ParanoiaLock();

    iIndexG = GetPlayerIndex(dpIdGroup);
    iIndexP = GetPlayerIndex(dpIdPlayer);

    if (   iIndexG == -1
        || m_aPlayer[iIndexG].bPlayer == TRUE
        || iIndexP == -1
        || m_aPlayer[iIndexP].bPlayer == FALSE)
        {
        ParanoiaUnlock();
        return(DPERR_INVALIDPID);
        }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[iIndexG].aGroup[ii] == m_aPlayer[iIndexP].pid)
        {
            dpGAdd.dwType    = DPSYS_DELETEPLAYERFROMGRP;
            dpGAdd.dpIdGroup  = m_aPlayer[iIndexG].pid;
            dpGAdd.dpIdPlayer = m_aPlayer[iIndexP].pid;

            m_aPlayer[iIndexG].aGroup[ii] = 0;

            ParanoiaUnlock();

            pMsg->dpHdr.usCookie = DPSYS_SYS;
            pMsg->dpHdr.to       = 0;
            pMsg->dpHdr.from     = 0;
            pMsg->dpHdr.usCount  = sizeof(DPMSG_GROUPADD);
            pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;

            memcpy( (LPVOID) &pMsg->sMsg, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));

            if (m_bPlayer0)
            {
                LocalMsg(iIndexG, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));
                PostGameMessage(  (LPVOID) pMsg, sizeof(SPMSG_GROUPADD));
            }
            else
            {
                PostNSMessage( pMsg, sizeof(SPMSG_GROUPADD));
            }
            return(DP_OK);
        }
    }
    ParanoiaUnlock();
    return(DPERR_INVALIDPID);
}

VOID CImpIDP_SP::HandleMessage(LPVOID lpv, DWORD dwSize, SOCKADDR *pSAddr, INT SockAddrLen)
{
    DPHDR *pHdr;
    BOOL   bHigh = FALSE;
    DPID   pidTo, pidFrom;
    DWORD  ii;
    SPMSG_ADDPLAYER *pAddPlayer;
    LONG   iIndex;

    pHdr = (DPHDR *) lpv;


    // TSHELL_INFO(TEXT("HandleMessage entered."));

    switch(pHdr->usCookie)
    {
    default:
        TSHELL_INFO(TEXT("Unknown message value"));
        break;

    case DPSYS_HIGH:
        bHigh = TRUE;
        //
        // Fall Through!
        //
    case DPSYS_USER:
        pidTo   = 0x00ff & ((DPID) pHdr->to);
        pidFrom = 0x00ff & ((DPID) pHdr->from);
        dwSize  = (DWORD)  ((DPID) pHdr->usCount);

        iIndex = GetPlayerIndex(pidTo);

        if (   pidTo == 0
            || iIndex != -1)
        {
            AddMessage((LPVOID) (((LPBYTE) lpv) + sizeof(DPHDR)), dwSize,
                pidTo, pidFrom, bHigh);
        }

        iIndex = GetPlayerIndex(pidFrom);

        if (   pidFrom != 0
            && (iIndex == -1))
            {
                SPMSG_GETPLAYER spmsg_getplayer;
                SPMSG_GETPLAYER *pMsg = &spmsg_getplayer;
                pMsg->dpHdr.usCookie = DPSYS_SYS;
                pMsg->dpHdr.to       = 0;
                pMsg->dpHdr.from     = 0;
                pMsg->dpHdr.usCount  = sizeof(DPMSG_GETPLAYER);
                pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
                pMsg->sMsg.dwType = DPSYS_GETPLAYER;
                pMsg->sMsg.dpId    = pidFrom;
                PostNSMessage((LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
            }
        break;

    case DPSYS_SYS:
        TSHELL_INFO(TEXT("HandleMessage System Message."));
        switch(((SPMSG_GENERIC *)lpv)->sMsg.dwType)
        {
        default:

            DBG_INFO((DBGARG, TEXT("Unknown Type %x"), ((SPMSG_GENERIC *)lpv)->sMsg.dwType));
            break;

        case DPSYS_ENABLEPLAYER:
            {
            SPMSG_ENABLEPLAYER *pMsg;

            pMsg = (SPMSG_ENABLEPLAYER *) lpv;
            if (pMsg->dpHdr.usCount == sizeof(DPMSG_ENABLEPLAYER))
            {
                if (m_bPlayer0 && m_bEnablePlayerAdd != pMsg->sMsg.bEnable)
                    PostGameMessage( (LPVOID) pMsg, sizeof(SPMSG_ENABLEPLAYER));

                m_bEnablePlayerAdd = pMsg->sMsg.bEnable;
            }
            }
            break;

        case DPSYS_DELETEPLAYERFROMGRP:
        case DPSYS_ADDPLAYERTOGROUP:
        case DPSYS_SETGROUPPLAYER:
            {
            SPMSG_GROUPADD *pMsg;
            LONG           iIndexG;
            LONG           iIndexP;

            pMsg = (SPMSG_GROUPADD *) lpv;
            if (pMsg->dpHdr.usCount == sizeof(DPMSG_GROUPADD))
            {
                ParanoiaLock();
                iIndexG = GetPlayerIndex(pMsg->sMsg.dpIdGroup);
                iIndexP = GetPlayerIndex(pMsg->sMsg.dpIdPlayer);
                if (   iIndexG == -1
                    || m_aPlayer[iIndexG].bPlayer == TRUE
                    || iIndexP == -1
                    || m_aPlayer[iIndexP].bPlayer == FALSE)
                {
                    TSHELL_INFO(TEXT("Invalid GroupAdd message."));
                }
                else
                {
                    if (    pMsg->sMsg.dwType == DPSYS_ADDPLAYERTOGROUP
                         || pMsg->sMsg.dwType == DPSYS_SETGROUPPLAYER)
                    {
                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                            if (m_aPlayer[iIndexG].aGroup[ii] == 0)
                            {
                                m_aPlayer[iIndexG].aGroup[ii] = m_aPlayer[iIndexP].pid;
                                break;
                            }
                    }
                    else
                    {
                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                            if (m_aPlayer[iIndexG].aGroup[ii] == m_aPlayer[iIndexP].pid)
                            {
                                m_aPlayer[iIndexG].aGroup[ii] = 0;
                            }
                    }


                    if (pMsg->sMsg.dwType != DPSYS_SETGROUPPLAYER)
                    {
                        LocalMsg(iIndexG, (LPVOID) &pMsg->sMsg, sizeof(DPMSG_GROUPADD));

                        if (m_bPlayer0)
                        {
                            PostGameMessage(  (LPVOID) pMsg, sizeof(SPMSG_GROUPADD));
                        }
                    }

                }

                ParanoiaUnlock();
            }
            else
            {
                TSHELL_INFO(TEXT("Invalid size on system message"));
            }


            }
            break;



        case DPSYS_SENDDESC:
            {
                SPMSG_SENDDESC *pMsg;

                pMsg = (SPMSG_SENDDESC *) lpv;
                if (pMsg->dpHdr.usCount == SIZE_SENDDESC)
                {
                    memcpy( (LPVOID) &m_dpDesc, (LPVOID) &pMsg->sMsg.dpDesc, sizeof(m_dpDesc));
                    // DBG_INFO((DBGARG, TEXT("New Description. Current Players %d"),
                    //                   m_dpDesc.dwCurrentPlayers));
                }
            }
            break;

        case DPSYS_PING:
            {
                SPMSG_PING *pMsg;

                pMsg = (SPMSG_PING *) lpv;
                if (pMsg->dpHdr.usCount == SIZE_PING)
                {
                    if (pMsg->dwTicks == m_dwPingSent)
                    {
                        m_dpcaps.dwLatency = (GetTickCount() - m_dwPingSent) /2;
                        m_dwPingSent = 0;
                        // TSHELL_INFO(TEXT("Latency Accepted from our Ping."));
                    }
                    else
                    {
                        SPMSG_PING  spmsg_ping;
                        SPMSG_PING *pMsg2 = &spmsg_ping;
                        UINT        uiSize = sizeof(SPMSG_PING);

                        memcpy( (LPVOID) pMsg2, (LPVOID) pMsg, sizeof(SPMSG_PING));
                        SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)pMsg2, &uiSize);
                        // TSHELL_INFO(TEXT("Return Ping."));

                    }
                TSHELL_INFO(TEXT("Ping Recieved."));
                }
            }
            break;

        case DPSYS_SETPLAYER:
            {
            SPMSG_SETPLAYER *pSetPlayer;

            pSetPlayer  = (SPMSG_SETPLAYER *) lpv;

            TSHELL_INFO(TEXT("Received SETPLAYER message"));
            if (pSetPlayer->dpHdr.usCount == SIZE_SETPLAYER)
            {
                ParanoiaLock();
                iIndex = GetPlayerIndex(pSetPlayer->sMsg.dpId);
                if (iIndex != -1)
                {
                    if (m_aPlayer[iIndex].bPlayer == (BOOL) pSetPlayer->sMsg.dwPlayerType)
                    {
                        lstrcpyn( m_aPlayer[iIndex].chNickName, pSetPlayer->sMsg.szShortName, DPSHORTNAMELEN);
                        lstrcpyn( m_aPlayer[iIndex].chFullName, pSetPlayer->sMsg.szLongName , DPLONGNAMELEN);
                        m_dpDesc.dwCurrentPlayers = pSetPlayer->sMsg.dwCurrentPlayers;
                    }
                    TSHELL_INFO(TEXT("Name change through SETPLAYER"));


                }
                else if (   !m_bPlayer0
                         && ((iIndex = FindInvalidIndex()) != -1))
                {
                    if (!pSetPlayer->sMsg.dwPlayerType)
                    {
                        m_aPlayer[iIndex].aGroup = (DPID *) lmalloc(sizeof(DPID) * MAX_PLAYERS);
                        if (m_aPlayer[iIndex].aGroup != NULL)
                            memset(m_aPlayer[iIndex].aGroup, 0x00, sizeof(DPID) * MAX_PLAYERS);
                        else
                            pSetPlayer->sMsg.dwPlayerType = TRUE; // Critical failure.
                    }

                    lstrcpy( m_aPlayer[iIndex].chNickName, pSetPlayer->sMsg.szShortName);
                    lstrcpy( m_aPlayer[iIndex].chFullName, pSetPlayer->sMsg.szLongName);
                    m_aPlayer[iIndex].bValid  = TRUE;
                    m_aPlayer[iIndex].bPlayer = pSetPlayer->sMsg.dwPlayerType;
                    m_aPlayer[iIndex].bLocal  = FALSE;
                    memcpy(&m_aPlayer[iIndex].sockaddr, pSAddr, sizeof(SOCKADDR));

                    m_aPlayer[iIndex].pid = pSetPlayer->sMsg.dpId;
                    m_dpDesc.dwCurrentPlayers = pSetPlayer->sMsg.dwCurrentPlayers;

                    TSHELL_INFO(TEXT("Remote player updated with SETPLAYER."));
                }

                if (iIndex != -1)
                {
                    if (pSetPlayer->sockaddr.sa_family == 0)
                        memcpy(&m_aPlayer[iIndex].sockaddr, &m_NSSockAddr, sizeof(SOCKADDR));
                    else
                        memcpy(&m_aPlayer[iIndex].sockaddr, &pSetPlayer->sockaddr, sizeof(SOCKADDR));

                }

                ParanoiaUnlock();
            }
            }
                break;

        case DPSYS_ADDPLAYER:
            {
            pAddPlayer = (SPMSG_ADDPLAYER *) lpv;

            if (pAddPlayer->dpHdr.usCount == SIZE_ADDPLAYER)
            {
                if (m_bEnablePlayerAdd == FALSE && pAddPlayer->sMsg.dwPlayerType == TRUE)
                    break;

                if (m_bPlayer0)
                {

                    if (pAddPlayer->dpHdr.usSeq == m_usSeqSys)
                    {
                        TSHELL_INFO(TEXT("We have seen this before."));
                        //
                        // BUGBUG, search our list and try to find a player
                        // we have already created and give them that.
                        //
                        break;
                    }

                    ParanoiaLock();

                    TSHELL_INFO(TEXT("Begin AddPlayer Processing Player 0."));
                    if (   m_dpDesc.dwMaxPlayers >= m_dpDesc.dwCurrentPlayers
                        && pAddPlayer->sMsg.dpId == 0
                        && ((iIndex = FindInvalidIndex()) != -1))
                    {

                        SPMSG_ADDPLAYER spmsg_addplayer;
                        SPMSG_ADDPLAYER *pReplyMsg = &spmsg_addplayer;

                        if (!pAddPlayer->sMsg.dwPlayerType)
                        {
                            m_aPlayer[iIndex].aGroup = (DPID *) lmalloc(sizeof(DPID) * MAX_PLAYERS);
                            if (m_aPlayer[iIndex].aGroup != NULL)
                                memset(m_aPlayer[iIndex].aGroup, 0x00, sizeof(DPID) * MAX_PLAYERS);
                            else
                                pAddPlayer->sMsg.dwPlayerType = TRUE; // Critical failure.
                        }

                        pAddPlayer->sMsg.dwCurrentPlayers = ++m_dpDesc.dwCurrentPlayers;
                        m_aPlayer[iIndex].pid = (DPID) m_dwNextPlayer++;
                        lstrcpy( m_aPlayer[iIndex].chNickName, pAddPlayer->sMsg.szShortName);
                        lstrcpy( m_aPlayer[iIndex].chFullName, pAddPlayer->sMsg.szLongName);
                        m_aPlayer[iIndex].bValid  = TRUE;
                        m_aPlayer[iIndex].bPlayer = pAddPlayer->sMsg.dwPlayerType;
                        m_aPlayer[iIndex].bLocal  = FALSE;
                        memcpy(&m_aPlayer[iIndex].sockaddr, pSAddr, sizeof(SOCKADDR));
                        memcpy(&pAddPlayer->sockaddr, pSAddr, sizeof(SOCKADDR));


                        pAddPlayer->sMsg.dpId = m_aPlayer[iIndex].pid;

                        TSHELL_INFO(TEXT("Replying to AddPlayer message."));
                        m_usSeqSys = pAddPlayer->dpHdr.usSeq;
                        pAddPlayer->dpHdr.usSeq = NextSequence();
                        memcpy((LPVOID) pReplyMsg, (LPVOID) pAddPlayer,
                                sizeof(SPMSG_ADDPLAYER));

                        PostGameMessage( (LPVOID) pReplyMsg, sizeof(SPMSG_ADDPLAYER));

                        LocalMsg(iIndex, &pAddPlayer->sMsg, sizeof(DPMSG_ADDPLAYER));

                    }
                    else
                    {
                        TSHELL_INFO(TEXT("Ignoring message, it will timeout."));
                    }
                    ParanoiaUnlock();

                }
                //
                // Ignore it it we already know about this player.
                //
                else if (GetPlayerIndex(pAddPlayer->sMsg.dpId) == -1)
                {
                    TSHELL_INFO(TEXT("Begin AddPlayer Processing Remote."));

                    ParanoiaLock();

#ifdef DEBUG
                    if (m_dpDesc.dwCurrentPlayers != pAddPlayer->sMsg.dwCurrentPlayers)
                    {
                        DBG_INFO((DBGARG, TEXT("Adjusting local count of players from %d to %d"),
                            m_dpDesc.dwCurrentPlayers,
                            pAddPlayer->sMsg.dwCurrentPlayers));
                    }
#endif


                    m_dpDesc.dwCurrentPlayers = pAddPlayer->sMsg.dwCurrentPlayers;

                    iIndex = FindInvalidIndex();

                    if ((iIndex = FindInvalidIndex()) != -1)
                    {
                        if (!pAddPlayer->sMsg.dwPlayerType)
                        {
                            m_aPlayer[iIndex].aGroup = (DPID *) lmalloc(sizeof(DPID) * MAX_PLAYERS);
                            if (m_aPlayer[iIndex].aGroup != NULL)
                                memset(m_aPlayer[iIndex].aGroup, 0x00, sizeof(DPID) * MAX_PLAYERS);
                            else
                                pAddPlayer->sMsg.dwPlayerType = TRUE; // Critical failure.
                        }

                        lstrcpy( m_aPlayer[iIndex].chNickName, pAddPlayer->sMsg.szShortName);
                        lstrcpy( m_aPlayer[iIndex].chFullName, pAddPlayer->sMsg.szLongName);
                        m_aPlayer[iIndex].bValid  = TRUE;
                        m_aPlayer[iIndex].bPlayer = pAddPlayer->sMsg.dwPlayerType;

                        if (pAddPlayer->sockaddr.sa_family == 0)
                            memcpy(&m_aPlayer[iIndex].sockaddr, &m_NSSockAddr, sizeof(SOCKADDR));
                        else
                            memcpy(&m_aPlayer[iIndex].sockaddr, &pAddPlayer->sockaddr, sizeof(SOCKADDR));

                        m_aPlayer[iIndex].pid = pAddPlayer->sMsg.dpId;

                        if (m_hNewPlayerEvent && pAddPlayer->dwUnique == m_dwUnique)
                        {
                            m_aPlayer[iIndex].bLocal  = TRUE;
                            m_iPlayerIndex = iIndex;
                            SetEvent(m_hNewPlayerEvent);
                        }
                        else
                        {
                            m_aPlayer[iIndex].bLocal  = FALSE;
                        }
                        LocalMsg(iIndex, &pAddPlayer->sMsg, sizeof(DPMSG_ADDPLAYER));
                    }
                    ParanoiaUnlock();
                }
            }
            else
            {
                TSHELL_INFO(TEXT("Invalid size on system message ADDPLAYER"));
            }
            }
            break;

        case DPSYS_DELETEGROUP:
        case DPSYS_DELETEPLAYER:
            {
            SPMSG_GETPLAYER *pMsg;
            SPMSG_GETPLAYER spmsg_getplayer;
            SPMSG_GETPLAYER *pMsg2 = &spmsg_getplayer;

            pMsg = (SPMSG_GETPLAYER *) lpv;

            TSHELL_INFO(TEXT("Got Delete"));
            if (pMsg->dpHdr.usCount == SIZE_GETPLAYER)
            {
                ParanoiaLock();
                if ((iIndex = GetPlayerIndex(pMsg->sMsg.dpId)) != -1)
                {
                    if (m_bPlayer0)
                    {
                        TSHELL_INFO(TEXT("Player 0 Pings Delete."));
                        memcpy( (LPVOID) pMsg2, (LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
                        PostGameMessage( (LPVOID) pMsg2, sizeof(SPMSG_GETPLAYER));
                    }

                    m_dpDesc.dwCurrentPlayers--;
                    if (m_aPlayer[iIndex].bLocal)
                    {
                        CloseHandle(m_aPlayer[iIndex].hEvent);
                        FlushQueue(m_aPlayer[iIndex].pid);
                    }
                    m_aPlayer[iIndex].bValid = FALSE;
                    if (m_aPlayer[iIndex].aGroup)
                        lfree(m_aPlayer[iIndex].aGroup);
                    LocalMsg(iIndex, (LPVOID) &pMsg->sMsg, sizeof(DPMSG_GETPLAYER));

                    if (pMsg->sMsg.dwType == DPSYS_DELETEPLAYER)
                    {
                        DWORD ii, jj;

                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                        {
                            if (   m_aPlayer[ii].bValid  == TRUE
                                && m_aPlayer[ii].bPlayer == FALSE
                                && m_aPlayer[ii].aGroup)
                            {
                                for (jj = 0; jj < MAX_PLAYERS; jj++)
                                {
                                    if (m_aPlayer[ii].aGroup[jj] == pMsg->sMsg.dpId)
                                    {
                                        m_aPlayer[ii].aGroup[jj] = 0;
                                        break;
                                    }
                                }

                            }
                        }
                    }
                }

                ParanoiaUnlock();
            }
            else
            {
                TSHELL_INFO(TEXT("Invalid size on system message"));
            }
            }
            break;

        case DPSYS_GETPLAYER:
            {
            DPID             pid = ((SPMSG_GETPLAYER *) lpv)->sMsg.dpId;
            BOOL             bFound = FALSE;

            if (m_bPlayer0)
            {

                ParanoiaLock();
                if ((iIndex = GetPlayerIndex((DPID) pid)) != -1)
                {
                    SPMSG_ADDPLAYER spmsg_addplayer;
                    SPMSG_ADDPLAYER *pMsg = &spmsg_addplayer;

                    pMsg->dpHdr.usCookie = DPSYS_SYS;
                    pMsg->dpHdr.to       = 0;
                    pMsg->dpHdr.from     = 0;
                    pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
                    pMsg->sMsg.dwType         = DPSYS_SETPLAYER;
                    pMsg->sMsg.dwPlayerType        = m_aPlayer[iIndex].bPlayer;
                    pMsg->sMsg.dpId            = pid;
                    pMsg->sMsg.dwCurrentPlayers = m_dpDesc.dwCurrentPlayers;
                    lstrcpy( pMsg->sMsg.szShortName, m_aPlayer[iIndex].chNickName);
                    lstrcpy( pMsg->sMsg.szLongName,  m_aPlayer[iIndex].chFullName);

                    dwSize = sizeof(SPMSG_SETPLAYER);
                    SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)pMsg, (LPUINT) &dwSize);
                }
                ParanoiaUnlock();
            }

            }
            break;

        case DPSYS_ENUMPLAYERRESP:
            {

            SPMSG_ADDPLAYER *pMsg;

            pMsg = (SPMSG_ADDPLAYER *) lpv;

            TSHELL_INFO(TEXT("Got a remote Player."));
            PlayerDataLock();

            if (m_fpEnumPlayers)
            {
                memcpy( (LPVOID) &m_spmsgAddPlayer, pMsg, sizeof(SPMSG_ADDPLAYER));

                SetEvent(m_hPlayerBlkEventMain);

                TSHELL_INFO(TEXT("Player should be processing in main thread shortly."));
                PlayerDataUnlock();

                WaitForSingleObject(m_hPlayerBlkEventRead, 5000);
                ResetEvent(m_hPlayerBlkEventRead);

            }
            else
            {
                TSHELL_INFO(TEXT("Ignore remote player because callback null."));
                PlayerDataUnlock();
            }

            }
            break;

        case DPSYS_ENUMALLPLAYERS:
            {
            if (m_bPlayer0)
            {

                SPMSG_ADDPLAYER spmsg_addplayer;
                SPMSG_ADDPLAYER *pMsg = &spmsg_addplayer;

                pMsg->dpHdr.usCookie = DPSYS_SYS;
                pMsg->dpHdr.to       = 0;
                pMsg->dpHdr.from     = 0;
                pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
                pMsg->sMsg.dwType         = DPSYS_ENUMPLAYERRESP;
                pMsg->sMsg.dwPlayerType        = TRUE;
                pMsg->sMsg.dwCurrentPlayers = m_dpDesc.dwCurrentPlayers;

                ParanoiaLock();
                for (ii = 0; ii < MAX_PLAYERS; ii++)
                {
                    if (m_aPlayer[ii].bValid && m_aPlayer[ii].bPlayer)
                    {
                        pMsg->sMsg.dpId            = m_aPlayer[ii].pid;
                        lstrcpy( pMsg->sMsg.szShortName, m_aPlayer[ii].chNickName);
                        lstrcpy( pMsg->sMsg.szLongName,  m_aPlayer[ii].chFullName);

                        dwSize = sizeof(SPMSG_SETPLAYER);
                        SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)pMsg, (LPUINT) &dwSize);
                    }
                }
                ParanoiaUnlock();
            }

            }


            break;
        }
    }
}

VOID CImpIDP_SP::SendPing()
{

    if (!m_bConnected)
    {
        return;
    }

    if (   m_dwPingSent
        && (GetTickCount() < (m_dwPingSent + 2000)))
        {
        return;
        }
    else
        m_dwPingSent = 0;

    SPMSG_PING spmsg_ping;
    SPMSG_PING *pMsg = &spmsg_ping;

    pMsg->dpHdr.usCookie = DPSYS_SYS;
    pMsg->dpHdr.to       = 0;
    pMsg->dpHdr.from     = 0;
    pMsg->dpHdr.usCount  = SIZE_PING;
    pMsg->dpHdr.usGame   = (USHORT) m_usGameCookie;
    pMsg->dwType         = DPSYS_PING;
    pMsg->dwTicks        = m_dwPingSent = GetTickCount();
    PostNSMessage( (LPVOID) pMsg, sizeof(SPMSG_PING));

}
VOID CImpIDP_SP::ConnectPlayers(SOCKADDR *pSAddr, INT SockAddrLen)
{

    DWORD ii;
    DWORD jj;
    SPMSG_ADDPLAYER Msg;
    DPMSG_ADDPLAYER dpAdd;
    DWORD   dwSize = sizeof(SPMSG_ADDPLAYER);

    SPMSG_GROUPADD  MsgG;
    DPMSG_GROUPADD  dpGAdd;
    DWORD   dwGSize = sizeof(SPMSG_GROUPADD);

    dpAdd.dwType   = DPSYS_SETPLAYER;
    dpAdd.dpId     = 0;

    dpGAdd.dwType = DPSYS_SETGROUPPLAYER;


    ParanoiaLock();
    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid )
        {
            dpAdd.dpId     = m_aPlayer[ii].pid;
            dpAdd.dwPlayerType = m_aPlayer[ii].bPlayer;
            lstrcpy( dpAdd.szShortName, m_aPlayer[ii].chNickName);
            lstrcpy( dpAdd.szLongName , m_aPlayer[ii].chFullName);
            dpAdd.dwCurrentPlayers = m_dpDesc.dwCurrentPlayers;

            Msg.dpHdr.usCookie = DPSYS_SYS;
            Msg.dpHdr.to       = (USHORT) m_aPlayer[ii].pid;
            Msg.dpHdr.from     = 0;
            Msg.dpHdr.usCount  = SIZE_SETPLAYER;
            Msg.dpHdr.usGame   = m_usGameCookie;
            Msg.dpHdr.usSeq    = NextSequence();
            memcpy( (LPVOID) &Msg.sMsg, &dpAdd, sizeof(DPMSG_ADDPLAYER));
            memcpy( (LPVOID) &Msg.sockaddr, &m_aPlayer[ii].sockaddr, sizeof(SOCKADDR));
            SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)&Msg, (LPUINT) &dwSize);
        }
    }
    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (   m_aPlayer[ii].bValid
            && m_aPlayer[ii].bPlayer == FALSE
            && m_aPlayer[ii].aGroup)
        {
            for (jj = 0; jj < MAX_PLAYERS; jj++)
            {
                if (m_aPlayer[ii].aGroup[jj] != 0)
                {
                    MsgG.dpHdr.usCookie = DPSYS_SYS;
                    MsgG.dpHdr.to       = 0;
                    MsgG.dpHdr.from     = 0;
                    MsgG.dpHdr.usCount  = SIZE_GROUPADD;
                    MsgG.dpHdr.usGame   = m_usGameCookie;
                    MsgG.dpHdr.usSeq    = NextSequence();
                    dpGAdd.dpIdGroup    = m_aPlayer[ii].pid;
                    dpGAdd.dpIdPlayer   = m_aPlayer[ii].aGroup[jj];
                    memcpy( (LPVOID) &MsgG.sMsg, &dpGAdd, sizeof(DPMSG_GROUPADD));
                    SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)&MsgG, (LPUINT) &dwGSize);
                }
            }
        }
    }

    ParanoiaUnlock();
}


VOID CImpIDP_SP::DeleteRemotePlayers()
{

    DWORD ii;
    DPMSG_DELETEPLAYER dpDel;

    dpDel.dwType = DPSYS_DELETEPLAYER;

    ParanoiaLock();
    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid && m_aPlayer[ii].bLocal == FALSE)
        {
            m_aPlayer[ii].bValid = FALSE;
            if (m_aPlayer[ii].aGroup)
                lfree(m_aPlayer[ii].aGroup);

            m_dpDesc.dwCurrentPlayers--;
            dpDel.dpId = m_aPlayer[ii].pid;
            LocalMsg(-1, (LPVOID) &dpDel, sizeof(DPMSG_DELETEPLAYER));
        }
    }
    ParanoiaUnlock();

}

BOOL CImpIDP_SP::CompareSessions(DWORD dwType, LPDPSESSIONDESC lpSDesc)
{

    if (   dwType == DPSYS_OPEN
        && IsEqualGUID((REFGUID) m_dpDesc.guidSession, (REFGUID) lpSDesc->guidSession)
        && m_bEnablePlayerAdd == TRUE
        && m_dpDesc.dwCurrentPlayers < m_dpDesc.dwMaxPlayers
        && (   m_dpDesc.szPassword[0] == 0x00
            || lstrcmp(m_dpDesc.szPassword, lpSDesc->szPassword) == 0))
        return(TRUE);

    if (   dwType == DPSYS_ENUM
        && m_cMachines < MAX_PLAYERS
        && (   IsEqualGUID((REFGUID)  m_dpDesc.guidSession, (REFGUID) lpSDesc->guidSession)
            || IsEqualGUID((REFGUID) NULL_GUID, (REFGUID) lpSDesc->guidSession))
        && (   lpSDesc->dwFlags & DPENUMSESSIONS_ALL
            || (    m_dpDesc.dwCurrentPlayers < m_dpDesc.dwMaxPlayers
                 && m_bEnablePlayerAdd == TRUE
                 && (   m_dpDesc.szPassword[0] == 0x00
                     || lstrcmp(m_dpDesc.szPassword, lpSDesc->szPassword) == 0))))
        return(TRUE);

    return(FALSE);
}


BOOL CImpIDP_SP::GetSessionData(DWORD dwSession)
{
    DWORD ii;
    NS_SESSION_SAVE *pns;

    for (ii = 0; ii < m_dwSessionPrev; ii++)
    {
        pns = (NS_SESSION_SAVE *) m_ppSessionArray[ii];
        if (pns->dpDesc.dwSession == dwSession)
        {
            memcpy(&m_NSSockAddr, &pns->sockaddr, sizeof(SOCKADDR));
            m_usGamePort = pns->usGamePort;
            m_dwUnique   = pns->dwUnique;
            return(TRUE);
        }
    }
    return(FALSE);
}
VOID CImpIDP_SP::SaveSessionData(NS_SESSION_SAVE *pnsSave)
{
    //
    //
    //
    if (m_dwSessionAlloc == m_dwSessionPrev)
    {
        char **ppTmp;

        m_dwSessionAlloc += 16;
        ppTmp = (char **) lmalloc(sizeof(char *) * m_dwSessionAlloc);
        if (ppTmp)
        {
            if (m_ppSessionArray)
            {
                memcpy( ppTmp, m_ppSessionArray, m_dwSessionPrev * sizeof(char *));
                lfree(m_ppSessionArray);
            }
        }
        else
        {
            m_dwSessionAlloc -= 16;
            return;
        }
        m_ppSessionArray = ppTmp;

    }
    m_ppSessionArray[m_dwSessionPrev] = (char *) lmalloc(sizeof(NS_SESSION_SAVE));
    if (m_ppSessionArray[m_dwSessionPrev])
    {
        *((NS_SESSION_SAVE *)m_ppSessionArray[m_dwSessionPrev++]) = *pnsSave;
        return;
    }
    else
    {
        return;
    }

    return;
}

VOID CImpIDP_SP::HandleConnect(LPVOID lpv, DWORD dwSize, SOCKADDR *pSAddr, INT SockAddrLen)
{

    DWORD   ii;

    // TSHELL_INFO(TEXT("Handle Connect"));

    SPMSG_ENUM  *pMsg = (SPMSG_ENUM *) lpv;

    if (dwSize != sizeof(SPMSG_ENUM))
    {
        TSHELL_INFO(TEXT("Connect message wrong size."));
        return;
    }

    if (m_bPlayer0)
    {

        switch (pMsg->dwType)
        {
        case DPSYS_ENUM_REPLY:
            TSHELL_INFO(TEXT("Player 0 got an enum reply, this is bogus."));
            return;

        default:
            TSHELL_INFO(TEXT("Player 0 got an unknown type connection msg, this is bogus."));
            return;

        case DPSYS_ENUM:
            {
                TSHELL_INFO(TEXT("HandleConnect:Player 0 ENUM."));
                if (   pMsg->usVerMajor == DPVERSION_MAJOR
                    && pMsg->usVerMinor == DPVERSION_MINOR
                    && CompareSessions(pMsg->dwType, &pMsg->dpSessionDesc))
                {
                    pMsg->dwType        = DPSYS_ENUM_REPLY;
                    pMsg->dpSessionDesc = m_dpDesc;
                    memset(pMsg->dpSessionDesc.szPassword, 0x00, DPSHORTNAMELEN);
                    pMsg->usPort        = m_usGamePort;
                    pMsg->dwUnique      = ++m_dwUnique;
                    pMsg->dpHdr.usSeq   = NextSequence();
                    if (SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)pMsg, (LPUINT) &dwSize) != 0)
                    {
                        TSHELL_INFO(TEXT("ENUM SendTo failed."));
                    }
                    else
                    {
                        TSHELL_INFO(TEXT("Enum SendTo succeeded."));
                    }
                }
                else
                {
                    TSHELL_INFO(TEXT("Compare Sessions Failed."));
                }
            }
            break;

        case DPSYS_OPEN:
                TSHELL_INFO(TEXT("HandleConnect:Player 0 OPEN."));
                pMsg->usPort  = m_usGamePort;
                if (pMsg->usPort != m_usGamePort)
                {
                    TSHELL_INFO(TEXT("Attempt to open from wrong port."));
                    return;
                }

                if (CompareSessions(pMsg->dwType, &pMsg->dpSessionDesc))
                {
                    pMsg->dwType        = DPSYS_CONNECT;
                    pMsg->dpSessionDesc = m_dpDesc;
                    SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)pMsg, (LPUINT) &dwSize);

                    if (m_dpDesc.dwCurrentPlayers != 0)
                    {
                        TSHELL_INFO(TEXT("Send current players."));
                        ConnectPlayers(pSAddr, SockAddrLen);
                    }

                    for (ii = 0; ii < m_cMachines; ii++)
                        if (memcmp(&m_aMachineAddr[ii], pSAddr, sizeof(SOCKADDR)) == 0)
                            return;

                    memcpy( &m_aMachineAddr[m_cMachines++], pSAddr, sizeof(SOCKADDR));
                }
                else
                {
                    pMsg->dwType        = DPSYS_REJECT;
                    pMsg->dpSessionDesc = m_dpDesc;
                    pMsg->dpHdr.usSeq   = NextSequence();
                    SendTo(m_ClientSocket, pSAddr, SockAddrLen, (char *)pMsg, (LPUINT) &dwSize);
                }

            break;

        }
    }
    else
    {

        switch (pMsg->dwType)
        {
        default:
            TSHELL_INFO(TEXT("Player x got an unknown type connection msg, this is bogus."));
            return;

        case DPSYS_ENUM_REPLY:
            TSHELL_INFO(TEXT("HandleConnect:Player N Reply."));

            EnumDataLock();

            if (m_fpEnumSessions)
            {
                NS_SESSION_SAVE ns;

                m_dwSession++;
                m_SessionAddrLen    = SockAddrLen;
                m_usGamePort        = pMsg->usPort;

                memcpy( &m_NSSockAddr, pSAddr, m_SessionAddrLen);

                pMsg->dpSessionDesc.dwSession = m_dwSession;

                ns.dpDesc           = pMsg->dpSessionDesc;
                memcpy( &ns.sockaddr, pSAddr, m_SessionAddrLen);
                ns.usGamePort       = pMsg->usPort;
                ns.dwUnique         = pMsg->dwUnique;

                SaveSessionData(&ns);

                DBG_INFO((DBGARG, TEXT("Session %d Name %s"),
                     pMsg->dpSessionDesc.dwSession,
                     pMsg->dpSessionDesc.szSessionName));

                memcpy( (LPVOID) &m_spmsgEnum, pMsg, sizeof(SPMSG_ENUM));

                DBG_INFO((DBGARG, TEXT("Tick %d"), GetTickCount()));
                SetEvent(m_hEnumBlkEventMain);

                EnumDataUnlock();
                DBG_INFO((DBGARG, TEXT("Tick %d"), GetTickCount()));


                WaitForSingleObject(m_hEnumBlkEventRead, 5000);
                ResetEvent(m_hEnumBlkEventRead);
                DBG_INFO((DBGARG, TEXT("Tick %d"), GetTickCount()));
            }
            else
                EnumDataUnlock();

            break;

        case DPSYS_CONNECT:
            TSHELL_INFO(TEXT("HandleConnect:Player N Connect."));
            m_bConnected = TRUE;
            m_usGamePort = pMsg->usPort;
            m_SessionAddrLen = SockAddrLen;
            memcpy( &m_NSSockAddr, pSAddr, m_SessionAddrLen);
            memcpy( &m_dpDesc, &pMsg->dpSessionDesc, sizeof(m_dpDesc));

            DBG_INFO((DBGARG, TEXT("Current Players from connect %d"),
                pMsg->dpSessionDesc.dwCurrentPlayers));

            GetSockAddress(&m_GameSockAddr, NULL, m_usGamePort, NULL, TRUE);
            SetEvent(m_hBlockingEvent);
            return;

        case DPSYS_REJECT:
            TSHELL_INFO(TEXT("HandleConnect:Player N Reject."));
            TSHELL_INFO(TEXT("We have been rejected for Open."));
            SetEvent(m_hBlockingEvent);
            return;
        }

    }

    // TSHELL_INFO(TEXT("Leave Connect"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\dpspimp.h ===
// Direct Play object class implementation

#ifndef _DP_SPIMP_H
#define _DP_SPIMP_H

#include "..\dplay\dplayi.h"

#include "socket.h"

// Begin: declaration of main implementation class for IDirectPlay


#define MAX_MSG      (512 + sizeof(DPHDR))
#define MAX_PLAYERS  256

typedef struct
{
    DPID     pid;
    char     chNickName[DPSHORTNAMELEN];
    char     chFullName[DPLONGNAMELEN ];
    HANDLE   hEvent;
    BOOL     bPlayer;
    BOOL     bValid;
    BOOL     bLocal;
    DPID     *aGroup;
    SOCKADDR sockaddr;
} PLAYER_RECORD;


typedef struct
{
    DPSESSIONDESC   dpDesc;
    SOCKADDR        sockaddr;
    DWORD           dwUnique;
    USHORT          usGamePort;
} NS_SESSION_SAVE;

/****************************************************************************
 *
 * DIRECTPLAY MESSAGES
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/



#pragma pack(push, 1)



#define SYS_MSG     0x8000
typedef struct
{
    union
    {
        DWORD dwConnect1;
        struct
        {
            USHORT  usCookie;
            USHORT  usGame;
        };
    };
    union
    {
        DWORD dwConnect2;
        struct
        {
            USHORT  to;
            USHORT  from;
        };
    };
    union
    {
        DWORD dwConnect3;
        struct
        {
            USHORT  usSeq;
            USHORT  usCount;
        };
    };
} DPHDR;

typedef struct
{
    DPHDR dpHdr;
    char chMsgCompose[1000];
} MSG_BUILDER;

#define SP_ENUM_COOKIE     0x794b



typedef struct
{
    DPHDR           dpHdr;
    DPMSG_GENERIC   sMsg;
} SPMSG_GENERIC;


#define SIZE_GENERIC (sizeof(SPMSG_GENERIC) - sizeof(DPHDR))


typedef struct
{
    DWORD  dwType;
    DPID   dpId;
} DPMSG_GETPLAYER;

typedef struct
{
    DPHDR           dpHdr;
    DPMSG_GETPLAYER sMsg;
} SPMSG_GETPLAYER;
#define SIZE_GETPLAYER  (sizeof(SPMSG_GETPLAYER) - sizeof(DPHDR))


typedef struct
{
    DPHDR           dpHdr;
    DPMSG_ADDPLAYER sMsg;
    SOCKADDR        sockaddr;
    DWORD           dwUnique;
} SPMSG_ADDPLAYER;

#define SIZE_ADDPLAYER (sizeof(SPMSG_ADDPLAYER) - sizeof(DPHDR))

typedef SPMSG_ADDPLAYER SPMSG_SETPLAYER;

#define SIZE_SETPLAYER (sizeof(SPMSG_SETPLAYER) - sizeof(DPHDR))
typedef struct
{
    DPHDR   dpHdr;
    DPMSG_GROUPADD sMsg;
} SPMSG_GROUPADD;

#define SIZE_GROUPADD (sizeof(SPMSG_GROUPADD) - sizeof(DPHDR))

typedef struct
{
    DPHDR   dpHdr;
    DWORD   dwType;
    DWORD   dwTicks;
} SPMSG_PING;

#define SIZE_PING (sizeof(SPMSG_PING) - sizeof(DPHDR))



typedef struct
{
    DPHDR   dpHdr;
    DWORD          dwType;
    GUID    guid;
} SPMSG_INVITE;



typedef struct
{
    DPHDR       dpHdr;
    DWORD      dwType;
    DPCAPS      dpCaps;
} SPMSG_GETPLAYERCAPS;

#define SIZE_GETPLAYERCAPS (sizeof(SPMSG_GETPLAYERCAPS) - sizeof(DPHDR))

typedef struct
{
    DWORD          dwType;
    DPSESSIONDESC   dpDesc;
} DPMSG_SENDDESC;


typedef struct
{
    DPHDR           dpHdr;
    DPMSG_SENDDESC  sMsg;
} SPMSG_SENDDESC;

#define SIZE_SENDDESC (sizeof(SPMSG_SENDDESC) - sizeof(DPHDR))

typedef struct
{
    DWORD      dwType;
    BOOL        bEnable;
} DPMSG_ENABLEPLAYER;
typedef struct
{
    DPHDR               dpHdr;
    DPMSG_ENABLEPLAYER  sMsg;
} SPMSG_ENABLEPLAYER;



typedef struct
{
    DPHDR           dpHdr;
    DWORD           dwType;
    DPSESSIONDESC   dpSessionDesc;
    DWORD           dwUnique;
    USHORT          usPort;
    USHORT          usVerMajor;
    USHORT          usVerMinor;
} SPMSG_ENUM;

#pragma pack(pop, 1)

class CImpIDP_SP : public IDirectPlaySP {
public:
    // IUnknown methods
    // IDirectPlay methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID iid, LPVOID *ppvObj );
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
    virtual ULONG STDMETHODCALLTYPE Release( void );

    virtual HRESULT STDMETHODCALLTYPE AddPlayerToGroup(
                                            DPID dwDPIDGroup,
                                            DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE Close(DWORD);
    virtual HRESULT STDMETHODCALLTYPE CreatePlayer(
                                        LPDPID pPlayerID,
                                        LPSTR pNickName,
                                        LPSTR pFullName,
                                        LPHANDLE lpReceiveEvent,
                                        BOOL     bPlayer);

    virtual HRESULT STDMETHODCALLTYPE   DeletePlayerFromGroup(
                                        DPID DPid,
                                        DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE DestroyPlayer( DPID pPlayerID, BOOL );
    virtual HRESULT STDMETHODCALLTYPE EnumGroupPlayers(
                                      DPID dwGroupPid,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumPlayers(
                                      DWORD dwSessionID,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumSessions(
                                       LPDPSESSIONDESC,
                                       DWORD dwTimeout,
                                       LPDPENUMSESSIONSCALLBACK EnumCallback,
                                       LPVOID,
                                       DWORD);

    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetMessageCount(DPID pidPlayer, LPDWORD lpdwCount);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerCaps(
                                        DPID dwDPId,
                                        LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerName(DPID dpID,
                          LPSTR lpFriendlyName,          // buffer to hold name
                          LPDWORD pdwFriendlyNameLength, // length of name buffer
                          LPSTR lpFormalName,
                          LPDWORD pdwFormalNameLength
                          );


    virtual HRESULT STDMETHODCALLTYPE Initialize(LPGUID lpguid);
    virtual HRESULT STDMETHODCALLTYPE Open(
                        LPDPSESSIONDESC lpSDesc, HANDLE hEvent);

    virtual HRESULT STDMETHODCALLTYPE Receive(
                                LPDPID from,
                                LPDPID to,
                                DWORD  dwReceiveFlags,
                                LPVOID,
                                LPDWORD);

    virtual HRESULT STDMETHODCALLTYPE SaveSession(LPVOID lpv, LPDWORD lpdw);

    virtual HRESULT STDMETHODCALLTYPE SetPrevPlayer(LPSTR lpName, LPVOID lpv, DWORD dw);

    virtual HRESULT STDMETHODCALLTYPE SetPrevSession(LPSTR lpName, LPVOID lpv, DWORD dw);

    virtual HRESULT STDMETHODCALLTYPE EnableNewPlayers(BOOL bEnable);

    virtual HRESULT STDMETHODCALLTYPE Send(
                                DPID from,
                                DPID to,
                                DWORD dwFlags,
                                LPVOID lpvMsg,
                                DWORD dwLength);
    virtual HRESULT STDMETHODCALLTYPE SetPlayerName(
                                DPID from,
                                LPSTR lpFriendlyName,          
                                LPSTR lpFormalName,
                                BOOL  bPlayer);



   static CImpIDP_SP* NewCImpIDP_SP(int af);


    DWORD ServerThreadProc();
    DWORD ClientThreadProc();
    BOOL CompareSessions(DWORD dwType, LPDPSESSIONDESC lpSDesc);

    VOID HandleConnect(LPVOID lpv, DWORD dwSize, SOCKADDR *pSAddr, INT SockAddrLen);
    VOID HandleMessage(LPVOID lpv, DWORD dwSize, SOCKADDR *pSAddr, INT SockAddrLen);
    VOID PulseBlock() {PulseEvent(m_hBlockingEvent);}
    VOID SetBlock() {SetEvent(m_hBlockingEvent);}
    DWORD BlockNicely(DWORD dwTimeout);
    VOID SendDesc(LPDPSESSIONDESC);
    VOID SendPing();
    VOID ISend(LONG, LONG, DWORD, LPVOID, DWORD);
    VOID LocalMsg(LONG, LPVOID, DWORD);
    VOID RemoteMsg(LONG, LPVOID, DWORD);
    LONG FindInvalidIndex();
    VOID ConnectPlayers(SOCKADDR *pSAddr, INT SockAddrLen);
    VOID DeleteRemotePlayers();
    VOID ResetSessionDesc() {memset(&m_dpDesc, 0x00, sizeof(DPSESSIONDESC));}
    BOOL GetSockAddress(SOCKADDR *pSAddr, LPINT pSAddrLen, USHORT usPort,
                SOCKET *pSocket, BOOL bBroadcast);
    BOOL PostGameMessage(LPVOID lpv, DWORD dw);
    BOOL PostPlayerMessage(LONG iIndex, LPVOID lpv, DWORD dw);
    BOOL PostNSMessage(LPVOID lpv, DWORD dw);
    USHORT NextSequence();
    USHORT UpdateSequence(USHORT us);
    VOID    SaveSessionData(NS_SESSION_SAVE *lpSDesc);
    BOOL    GetSessionData(DWORD dwSession);


    BOOL             m_bConnected;
    BOOL             m_bPlayer0;            // If I created the call, I am player
                                            // zero.
   void *operator new( size_t size );
   void operator delete( void *ptr );

protected:
    void EnumDataLock();
    void EnumDataUnlock();
    void PlayerDataLock();
    void PlayerDataUnlock();
    void ParanoiaLock();
    void ParanoiaUnlock();

private:
    LONG GetPlayerIndex(DPID);
    BOOL SetSession(DWORD dw);
    CImpIDP_SP(void);
   ~CImpIDP_SP(void);

    DWORD            m_dwPingSent;
    HANDLE           m_hBlockingEvent;
    HANDLE           m_hEnumBlkEventMain;  // User Thread can run.
    HANDLE           m_hEnumBlkEventRead;  // Enum Thread can read again.
    HANDLE           m_hPlayerBlkEventMain;  // User Thread can run.
    HANDLE           m_hPlayerBlkEventRead;  // Enum Thread can read again.
    DWORD            m_dwNextPlayer;
    BOOL             m_bEnablePlayerAdd;


    volatile LPDPENUMSESSIONSCALLBACK m_fpEnumSessions;
    volatile BOOL                     m_bRunEnumReceiveLoop;
    LPDPENUMPLAYERSCALLBACK  m_fpEnumPlayers;
    LPVOID           m_lpvSessionContext;
    LPVOID           m_lpvPlayersContext;
    PLAYER_RECORD    m_aPlayer[MAX_PLAYERS];
    LONG             m_iPlayerIndex;
    DPSESSIONDESC    m_dpDesc;

    int              m_refCount;
    CRITICAL_SECTION m_critSection;
    CRITICAL_SECTION m_critSectionPlayer;
    CRITICAL_SECTION m_critSectionParanoia;
    DPCAPS           m_dpcaps;
    HANDLE           m_hNewPlayerEvent;

    char           **m_ppSessionArray;
    DWORD            m_dwSessionPrev;
    DWORD            m_dwSessionAlloc;
    int              m_af;


    DWORD            m_remoteaddrlen;
    char             m_chComputerName[64];
    BOOL             m_bShutDown;
    HANDLE           m_hNSThread;
    DWORD            m_dwNSId;
    USHORT           m_usGamePort;
    USHORT           m_usGameCookie;
    HANDLE           m_hClientThread;
    DWORD            m_dwClientId;
    volatile HANDLE  m_hEnumThread;
    DWORD            m_dwEnumId;

    volatile SOCKET           m_ServerSocket;
    volatile SOCKET           m_ClientSocket;
    volatile SOCKET           m_EnumSocket;
    BOOL             m_bEnumSocket;
    BOOL             m_bClientSocket;

    DWORD            m_dwSession;
    SOCKADDR         m_NSSockAddr;
    INT              m_SessionAddrLen;
    SOCKADDR         m_GameSockAddr;

    USHORT           m_usSeq;
    USHORT           m_usSeqSys;

    SOCKADDR        *m_aMachineAddr;
    DWORD            m_cMachines;
    DWORD            m_dwUnique;
    volatile SPMSG_ENUM         m_spmsgEnum;
    volatile SPMSG_ADDPLAYER    m_spmsgAddPlayer;

};


BOOL SetIDP_SP( CImpIDP_SP *pSP);


// End  : declaration of main implementation class for IDirectPlay





extern BOOL AddMessage(LPVOID lpvMsg, DWORD dwSize, DPID pidTo, DPID pidFrom, BOOL bHigh);
extern HRESULT GetQMessage(LPVOID lpvMsg, LPDWORD pdwSize, DPID *ppidTo, DPID *ppidFrom,
                DWORD dwFlags, BOOL bPeek);
extern VOID  FlushQueue(DPID pid);
extern DWORD GetPlayerCount(DPID spid);

#define DPSYS_JOHN    0x6e686f4a


// Enumeration Messages

//
// Thread Messages
//
#define PWM_BASE        0x00007000
#define PWM_COMMWRITE   PWM_BASE    +1
#define PWM_SETIDP      PWM_BASE    +2
#define PWM_HANGUP      PWM_BASE    +3
#define PWM_CLOSE       PWM_BASE    +4


#define DPNS_PORT   8787

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\wsnetbs.h ===
/*
 *   wsnetbs.h
 *
 *   Windows Sockets include file for NETBIOS.  This file contains all
 *   standardized NETBIOS information.  Include this header file after
 *   winsock.h.
 *
 */

#ifndef _WSNETBS_
#define _WSNETBS_

/*
 *   This is the structure of the SOCKADDR structure for NETBIOS.
 *
 */

#define NETBIOS_NAME_LENGTH 16

typedef struct sockaddr_nb {
    short   snb_family;
    u_short snb_type;
    char    snb_name[NETBIOS_NAME_LENGTH];
} SOCKADDR_NB, *PSOCKADDR_NB,FAR *LPSOCKADDR_NB;

/*
 * Bit values for the snb_type field of SOCKADDR_NB.
 *
 */

#define NETBIOS_GROUP_NAME      0x80
#define NETBIOS_UNIQUE_NAME     0x00
#define NETBIOS_REGISTERING     0x00
#define NETBIOS_REGISTERED      0x04
#define NETBIOS_DEREGISTERED    0x05
#define NETBIOS_DUPLICATE       0x06
#define NETBIOS_DUPLICATE_DEREG 0x07

/*
 * A macro convenient for setting up NETBIOS SOCKADDRs.
 *
 */

#define SET_NETBIOS_SOCKADDR(_snb,_type,_name,_port)                          \
    {                                                                         \
        int _i;                                                               \
        (_snb)->snb_family = AF_NETBIOS;                                      \
        (_snb)->snb_type = (_type);                                           \
        for (_i=0; _i<NETBIOS_NAME_LENGTH-1; _i++) {                          \
            (_snb)->snb_name[_i] = ' ';                                       \
        }                                                                     \
        for (_i=0; *((_name)+_i) != '\0' && _i<NETBIOS_NAME_LENGTH-1; _i++) { \
            (_snb)->snb_name[_i] = *((_name)+_i);                             \
        }                                                                     \
        (_snb)->snb_name[NETBIOS_NAME_LENGTH-1] = (_port);                    \
    }

/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 *
 */

#define NBPROTO_NETBEUI  17001

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\socket.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

	socket.h

Abstract:

	This file contains definitions and prototypes used in socket.c

Author:

	Shaun Pierce (shaunp) 15-Jun-1995

Environment:

	User Mode -Win32 (Win95 flavor)

Revision History:


--*/

#ifndef __SOCKET_H
#define __SOCKET_H


#include <windows.h>
#include <winerror.h>
#include <winsock.h>
#include <wsipx.h>
#include "wsnetbs.h"
#include <nspapi.h>

#ifndef LPUINT
typedef UINT *LPUINT;
#endif


//
// Definitions
//



//
// Function prototypes
//

UINT InitializeWinSock();

BOOL OpenSocket(
    IN  INT iAddressFamily,
    IN  INT iProtocol,
    OUT SOCKET *pSocket
    );

UINT BindSocket(
    IN SOCKET Socket,
    IN INT iAddressFamily,
    IN INT iPort,
    IN PSOCKADDR pSockAddr,
    IN LPINT pSockAddrLen
    );

UINT GetSocketAddr(
    IN  SOCKET Socket,
    OUT PSOCKADDR pAddress,
    IN  PUINT pAddressLen
    );

BOOL CloseSocket(
    IN SOCKET Socket,
    IN USHORT interval
    );

UINT InitializeSocket(
    IN INT iAddressFamily, 
    IN PSOCKADDR pSockAddr,
    IN LPINT pSockAddrLen,
    OUT SOCKET *pSocket
    );

UINT GetProtocolInfo(
    OUT    PUSHORT pTotalProtocols,
    OUT    PUSHORT pConnectionlessCount,
    OUT    PUSHORT pConnectionlessMask,
    IN OUT PPROTOCOL_INFO pInfoBuffer,
    IN OUT PUSHORT pBufferLength
    );

UINT ReceiveAny(
    IN     SOCKET Socket,
    IN OUT PSOCKADDR pSockAddr,
    IN     LPINT pSockAddrLen,
    IN OUT PCHAR pBuffer,
    IN OUT LPUINT pBufferLen
    );

UINT SendTo(
    IN     SOCKET Socket,
    IN OUT PSOCKADDR pSockAddr,
    IN     UINT SockAddrLen,
    IN OUT PCHAR pBuffer,
    IN OUT LPUINT pBufferLen
    );

extern "C" UINT ShutdownWinSock();


//
// External functions
//

extern UINT CountBits(
    IN DWORD x
    );





#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\globals.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
// PURPOSE:
//
//  Contains declarations for all globally scoped names in the program
//

//-------------------------------------------------------------------------
//  About dialog defines.

#define IDD_VERFIRST    100
#define IDD_VERLAST     104


// -----------------------------------------------------------------------
// Global Variable declarations
//

extern HINSTANCE hInst;     // The current instance
#define IDM_HANGUPCALL     1011


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TapiComm.RC
//
#define IDC_COUNTRYCODE                 1000
#define IDC_TAPILINE                    1001
#define IDC_CONFIGURELINE               1002
#define IDC_DIALINGPROPERTIES           1003
#define IDC_PHONENUMBER                 1004
#define IDC_DIAL                        1005
#define IDC_AREACODE                    1006
#define IDC_CALLINGCARD                 1007
#define IDC_USEDIALINGRULES             1008
#define IDC_LOCATION                    1009
#define IDC_CANONICALNUMBER             1010
#define IDC_DISPLAYABLENUMBER           1011
#define IDC_DIALABLENUMBER              1012
#define IDC_STATICCOUNTRYCODE           1013
#define IDC_STATICAREACODE              1014
#define IDC_STATICPHONENUMBER           1015
#define IDC_STATICLOCATION              1016
#define IDC_STATICCALLINGCARD           1017
#define IDC_STATICTAPILINE              1018
#define IDC_STATICCANONICAL             1019
#define IDC_STATICDIALABLE              1020
#define IDC_STATICDISPLAYABLE           1021
#define IDC_LINEICON                    1022

#define IDC_NOHELPCONTROLS              1101
#define IDC_STATICWHERETODIAL           1102
#define IDC_STATICHOWTODIAL             1103
#define IDC_STATICCONNECTUSING          1104
#define IDC_STATICPHONENUMBERS          1105

#define IDC_CONFIGURATIONCHANGED        1201
#define IDC_LINECREATE                  1202

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1301
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\misc\logit.cpp ===
#ifndef  WIN32_LEAN_AND_MEAN
#define  WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "logit.h"


/*
 * lpf
 */
void cdecl lpf( LPSTR szFormat, ...)
{
    char    szStr[256];
    va_list ap;
    va_start(ap,szFormat);


    wvsprintf( szStr, szFormat, ap);
    lstrcat( szStr, "\r\n");
    OutputDebugString(szStr);

    va_end(ap);
} /* lpf */

void LogIt(char *chMsg, char *chFile, UINT uiLine, LOG_TYPE log)
{
    char *achLog;
    char  chBuffer[256];

    chBuffer[0] = 0x00;

    switch(log)
	{
	case LOG:
	    achLog = "Log";
	    break;
	case ABORT:
	    achLog = "Abort";
	    break;
	case EXIT:
	    achLog = "Exit";
	    break;
	case INFO:
	    achLog = "Info";
	    break;

	default:
	    achLog = "UNKNOWN";
	}

    wsprintf( chBuffer, "%s %s(%d): %s\r\n", chFile, achLog, uiLine, chMsg);
    OutputDebugString(chBuffer);
}

void LogIt2(char *chFile, UINT uiLine, LOG_TYPE log, LPSTR szFormat, ...)
{
    char *achLog;
    char  chBuffer[256];

    chBuffer[0] = 0x00;

    switch(log)
	{
	case LOG:
	    achLog = "Log";
	    break;
	case ABORT:
	    achLog = "Abort";
	    break;
	case EXIT:
	    achLog = "Exit";
	    break;
	case INFO:
	    achLog = "Info";
	    break;

	default:
	    achLog = "UNKNOWN";
	}

    wsprintf( chBuffer, "%s %s(%d): ", chFile, achLog, uiLine);
    OutputDebugString(chBuffer);

    va_list ap;
    va_start(ap,szFormat);


    wvsprintf( chBuffer, szFormat, ap);
    lstrcat( chBuffer, "\r\n");
    OutputDebugString(chBuffer);

    va_end(ap);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\misc\logit.h ===
#ifndef __LOG_IT__
#define __LOG_IT__

typedef enum
{
    LOG,
    ABORT,
    EXIT,
    INFO
} LOG_TYPE;

extern void cdecl lpf(LPSTR szFormat, ...);

#ifdef DEBUG
#define TSHELL_LOG(a)   LogIt((a), __FILE__, __LINE__, LOG)  ; bb = FALSE
#define TSHELL_INFO(a)  LogIt((a), __FILE__, __LINE__, INFO)  
#define TSHELL_ABORT(a) LogIt((a), __FILE__, __LINE__, ABORT); bb = FALSE; goto abort 
#define TSHELL_EXIT(a)  LogIt((a), __FILE__, __LINE__, EXIT); return(FALSE)

#define DBGARG         __FILE__, __LINE__, INFO
#define DBG_INFO(a)    LogIt2 a

#else
#define TSHELL_LOG(a)   bb = FALSE
#define TSHELL_INFO(a)  
#define TSHELL_ABORT(a) bb = FALSE; goto abort 
#define TSHELL_EXIT(a)  return(FALSE)

#define DBG_INFO(a)    

#endif

void LogIt(char *chMsg, char *chFile, UINT uiLine, LOG_TYPE log);
void LogIt2(char *chFile, UINT uiLine, LOG_TYPE log, LPSTR szFormat, ...);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\dpwsock\socket.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

	socket.c

Abstract:

	This file contains socket initialization functions, as well as open,
    close, bind, enumeration types of functions using WinSock.

Author:

	Shaun Pierce (shaunp) 15-Jun-1995

Environment:

	User Mode -Win32 (Win95 flavor)

Revision History:


--*/

#include <windows.h>
#include <winerror.h>
#include <winsock.h>
#include <wsipx.h>
#include "wsnetbs.h"
#include <nspapi.h>
// #include "dpwssp.h"
#include "socket.h"


#define PORT_DONT_CARE  0

//
// Global Variables:
//


BOOL bNetIsUp;


/*=============================================================================

    CountBits - Counts the number of bits in a number

    Description:

        Counts the number of bits in a DWORD value passed to the function

    Arguments:

        x - DWORD value to count the number of bits within

    Return Value:

        Returns the number of bits within the argument x

-----------------------------------------------------------------------------*/
UINT CountBits(
    IN DWORD x
    )

{

    UINT i;

    //
    // Go until we've rotated everything off the right side.
    //

    for (i=0; x != 0; x >>= 1) {

        if (x & 01) {

            //
            // The bit in position 0 is ON!  Count it!!!
            //

            i++;

        }

    }

    //
    // i now contains how many bits we counted while rotating
    //

    return (i);

}




/*=============================================================================

    InitializeWinSock - Locate, bind, and initialize to the WinSock library

    Description:

        This function attemps to load the WinSock library (wsock32.dll),
        extract function pointers, and then initialize to a 1.1 version
        of WinSock.

    Arguments:

        None.

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents initialization, it returns an appropriate Win32 error.

-----------------------------------------------------------------------------*/
UINT InitializeWinSock()

{

    UINT err;
    WSADATA wsaData;


    //
    // Preset global bNetIsUp variable to false
    //

    bNetIsUp = FALSE;

    //
    // Attempt to load the wsock32.dll library.  We do this rather than
    // statically binding to wsock32.dll because the game may not have
    // any WinSock components present.  If we statically bind and there
    // are no WinSock components around, the user wont be able to fire up
    // their game without the damned dialog boxed coming up.  This would
    // force them to have WinSock stuff on their machine even if they want
    // to play the game by themselves.
    //
    // BUGBUG: Nice idea, might come back to it. C++ is stricter on checking
    // types, though.  [johnhall]
    //


    //
    // Get addresses of all the WinSock functions we'll be using.  All
    // of these variables are globals and shouldn't be modified after
    // initially getting these values out of this function.
    //


    //
    // Fire up Winsock
    //

    err = WSAStartup(MAKEWORD(1,1), &wsaData);

    if (err) {

        //
        // Some kind of Error occurred out of WinSock.  They can't use the
        // WSAGetLastError function yet, so we've gotta report it back to
        // the caller
        //

        return (err);

    }

    //
    // Set global Boolean variable to indicate we've "bound" to the WinSock
    // library, and return no error occurred.
    //

    bNetIsUp = TRUE;
    return (NO_ERROR);

}


/*=============================================================================

    OpenSocket - Opens a socket in the family and protocol specified.

    Description:

        This function opens a socket on the family and protocol specified,
        but it doesn't bind to the socket in question.  Once the open has
        completed successfully, the socket must be set to reuse local
        addresses and enter broadcast mode in order to return a value
        of TRUE which signifies success for the entire operation.

    Arguments:

        iAddressFamily - The address format specification.

        iProtocol - The protocol to use within the address family.

        pSocket - Pointer to a variable to receive a socket descriptor.

    Return Value:

        Returns TRUE if the function was able to open the socket and set
        the options needed.  Otherwise, return FALSE.  Caller can get the
        error thru GetLastError().

-----------------------------------------------------------------------------*/
BOOL OpenSocket(
    IN  INT iAddressFamily,
    IN  INT iProtocol,
    OUT SOCKET *pSocket
    )

{

    UINT err;
    BOOL bTrue = TRUE;


    //
    // Make sure we've at least initialized with the WinSock library
    //

    if (!bNetIsUp) {

        SetLastError(WSANOTINITIALISED);
        return (FALSE);

    }

    //
    // If the socket provided is already open, fail.
    //

    if (*pSocket != INVALID_SOCKET) {

        SetLastError(WSAEADDRINUSE);
        return (FALSE);

    }

    //
    // Attempt to create the socket based on what the caller wants.  No
    // validation here on type or family.  It is assumed that an enumeration
    // was done prior to this
    //

    *pSocket = socket(iAddressFamily, SOCK_DGRAM, iProtocol);

    if (*pSocket == INVALID_SOCKET) {

        return (FALSE);

    }

    //
    // Enable socket for broadcast and allow reuse of local addresses
    //

    err = setsockopt(*pSocket, SOL_SOCKET, SO_BROADCAST, (LPSTR) &bTrue, sizeof(bTrue));

    if (err == SOCKET_ERROR) {

        //
        // For some reason, WinSock wouldn't let us set the socket
        // to allow transmission of broadcast messages.  Got no choice
        // but to return failure.  We'll trap here on debug builds to try
        // and see what is going on.
        //

        err = GetLastError();
        CloseSocket(*pSocket, 0);
        return (FALSE);

    }

    //
    // Both socket options worked, return TRUE to caller to inform them
    // of the success of the entire operation
    //

    return (TRUE);

}


/*=============================================================================

    BindSocket - Binds an already existing socket to a family address

    Description:

        This function binds an already existing socket to an address via
        the port, and family specified.  Currently, only IP and IPX are
        supported.  So support binding to new types of families, simply
        add to the switch statement below and fill in the necessary
        address specific details.

        The last two parameters, (pSockAddr and pSockAddrLen), are
        optional.  If these two parameters are NULL, this function binds
        to the family and port specified.  If these two parameters are
        NON NULL, then these two parameters are taken as gospel and
        the socket will be bound to them.

    Arguments:

        Socket - socket to be bound

        iAddressFamily - The address format specification.

        iPort - Requested port wanted on this particular address

        pSockAddr - Optional pointer to well known address to bind to

        nSockAddrLen - Optional pointer to length of pSockAddr

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents binding to the address type specified, an appropriate
        Win32 error is returned.

-----------------------------------------------------------------------------*/
UINT BindSocket(
    IN SOCKET Socket,
    IN INT iAddressFamily,
    IN INT iPort,
    IN PSOCKADDR pSockAddr,
    IN LPINT pSockAddrLen
    )

{

    UINT err;
    SOCKADDR SockAddr;
    PSOCKADDR_IN  pIPAddr;
    PSOCKADDR_IPX pIPXAddr;


    //
    // Lets at least make sure we're binding a real socket here
    //

    if (Socket == INVALID_SOCKET) {

        SetLastError(WSAENOTSOCK);
        return (FALSE);

    }

    //
    // Here's where we check to see if pSockAddr and pSockAddrLen
    // are NULL.  If NON NULL, use address specified and bind to it.
    //

    if ((pSockAddr) && (pSockAddrLen)) {

        //
        // Both ponters are NON NULL, so just use what they provided.
        //

        err = bind(Socket, pSockAddr, *pSockAddrLen);

        if (err == SOCKET_ERROR) {

            //
            // Couldn't bind socket to this address
            //

            return (GetLastError());

        }

        return (NO_ERROR);


    }

    //
    // Zero out the socket address structure and dispatch based on the
    // address family.  If you want this function to handle additional
    // types of families, this is the place to add the functionality.
    //

    memset(&SockAddr, 0, sizeof(SOCKADDR));

    switch (iAddressFamily) {

        case AF_INET:

            //
            // Setup IP specific pointer and fill in the appropriate fields
            //

            pIPAddr = (PSOCKADDR_IN) &SockAddr;
            pIPAddr->sin_family = (SHORT)iAddressFamily;
            pIPAddr->sin_port = htons((USHORT)iPort);
            err = bind(Socket, (SOCKADDR *) pIPAddr, sizeof(SOCKADDR_IN));

            if (err == SOCKET_ERROR) {

                //
                // Couldn't bind socket to this address
                //

                return (GetLastError());

            }

            return (NO_ERROR);

        case AF_IPX:

            //
            // Setup IPX specific pointer and fill in the appropriate fields
            //

            pIPXAddr = (PSOCKADDR_IPX) &SockAddr;
            pIPXAddr->sa_family = (SHORT)iAddressFamily;
            pIPXAddr->sa_socket = htons((USHORT)iPort);
            err = bind((SOCKET) Socket, (SOCKADDR *) pIPXAddr, sizeof(SOCKADDR_IPX));

            if (err == SOCKET_ERROR) {

                //
                // Couldn't bind socket to this address
                //

                return (GetLastError());

            }

            return (NO_ERROR);

        default:

            return (ERROR_NOT_SUPPORTED);

    }

}


/*=============================================================================

    GetSocketAddr - Gets the address for a particular bound socket

    Description:

        This function gets the address for a particular socket.  Although
        this routine just uses WinSock to get the address, I'm attempting
        to centralize the WinSock specific calls in one location so we can
        do extra validation on parameters, or perhaps use new types of
        sockets in the future that don't use WinSock.

    Arguments:

        Socket - Socket from which to receive address

        pAddress - Pointer to buffer to receive address description

        pAddressLen - Pointer to address of length of address buffer

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents getting the address, an appropriate Win32 error
        is returned.

-----------------------------------------------------------------------------*/
UINT GetSocketAddr(
    IN  SOCKET Socket,
    OUT PSOCKADDR pAddress,
    IN  PINT pAddressLen
    )

{

    UINT err;


    //
    // Lets at least make sure we're binding a real socket here
    //

    if (Socket == INVALID_SOCKET) {

        SetLastError(WSAENOTSOCK);
        return (FALSE);

    }

    //
    // Seems to be a legitimate socket.  Call WinSock to get address
    //

    err = getsockname(Socket, pAddress, pAddressLen);

    if (err == SOCKET_ERROR) {

        //
        // For some reason, WinSock wouldn't let us get the address.
        // Return the error.  This case is so rare we should trap here on
        // debug builds to try and see what is going on.
        //

        return (GetLastError());

    }

    return (NO_ERROR);

}


/*=============================================================================

    CloseSocket - Closes a socket with the interval specified.

    Description:

        This function closes the socket with timeout interval specified.
        Depending on the interval being zero or non zero, the close of
        the socket will be a hard or graceful disconnect.

        Interval        Type of Close       Wait for close?
        --------        -------------       ---------------
        Zero            Hard                No
        Non-zero        Graceful            Yes

    Arguments:

        Socket - socket to be closed

        interval - timeout interval (in seconds) which decides the behavior
                   of the close

    Return Value:

        Returns TRUE if the function was able to close the socket.
        Otherwise, return FALSE.  Caller can get the real error thru
        GetLastError().

-----------------------------------------------------------------------------*/
BOOL CloseSocket(
    IN SOCKET Socket,
    IN USHORT interval
    )

{

    UINT err;
    LINGER linger;


    //
    // Lets at least make sure we're shutting down a real socket here
    //

    if (Socket == INVALID_SOCKET) {

        SetLastError(WSAENOTSOCK);
        return (FALSE);

    }

    //
    // Seems to be a legitimate socket.  Let's set some socket options
    // in order to manage how the socket is closed.
    //

    linger.l_onoff = TRUE;
    linger.l_linger = interval;

    //
    // We don't care if this fails or not, as we're gonna try to close
    // the socket anyway.
    //

    setsockopt(Socket, SOL_SOCKET, SO_LINGER, (CHAR FAR *) &linger, sizeof(linger));

    err = closesocket(Socket);

    if (err == SOCKET_ERROR) {

        //
        // For some reason, WinSock wouldn't let us close the socket.
        // Got no choice but to return failure.  We'll trap here on
        // debug builds to try and see what is going on.
        //
        err = GetLastError();
        return (FALSE);

    }

    return (TRUE);

}


/*=============================================================================

    InitializeSocket - Creates and binds the Socket specified

    Description:

        This function creates a socket and binds to an address.  The
        address may be passed in, or if pSockAddr and pSockAddrLen are
        NULL, then we let WinSock give us an Address.

    Arguments:

        iAddressFamily - The address format specification.

        pSockAddr - Pointer to address to bind to (Optional)

        pSockAddrLen - Pointer to length of address (Optional)

        pSocket - Pointer to a variable to receive a socket descriptor.

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents initializing the socket provided, an appropriate Win32
        error is returned.

-----------------------------------------------------------------------------*/
UINT InitializeSocket(
    IN INT iAddressFamily,
    IN PSOCKADDR pSockAddr,
    IN LPINT pSockAddrLen,
    OUT SOCKET *pSocket
    )

{

    UINT err;
    PSOCKADDR_IN pSockAddrIn;
    PSOCKADDR_IPX pSockAddrIPX;


    //
    // Let's see if the caller provided an address, or do we need to
    // let WinSock pick one for us.
    //

    if ((pSockAddr) && (pSockAddrLen)) {

        //
        // Yes, they supplied an address.  Use it to open a socket and
        // then bind to it.
        //

        switch (iAddressFamily) {

            case AF_INET:

                //
                // Use the IP information provided in pSockAddr.  Assume UDP
                //

                pSockAddrIn = (PSOCKADDR_IN) pSockAddr;
                if (!(OpenSocket(pSockAddrIn->sin_family, IPPROTO_UDP, pSocket))) {

                    //
                    // Couldn't open the socket for whatever reason.
                    // Return the real error to the caller.
                    //

                    return (GetLastError());

                }

                err = BindSocket(*pSocket, 0, 0, (PSOCKADDR) pSockAddrIn, pSockAddrLen);

                if (err) {

                    //
                    // Couldn't bind to that address for whatever reason
                    // Return the error to the caller.
                    //

                    return (err);

                }

                break;

            case AF_IPX:

                //
                // Use the IPX information provided in pSockAddr.  Assume IPX
                //

                pSockAddrIPX = (PSOCKADDR_IPX) pSockAddr;
                if (!(OpenSocket(pSockAddrIPX->sa_family, NSPROTO_IPX, pSocket))) {

                    //
                    // Couldn't open the socket for whatever reason.
                    // Return the real error to the caller.
                    //

                    return (GetLastError());

                }

                err = BindSocket(*pSocket, 0, 0, (PSOCKADDR) pSockAddrIPX, pSockAddrLen);

                if (err) {

                    //
                    // Couldn't bind to that address for whatever reason
                    // Return the error to the caller.
                    //

                    return (err);

                }

                break;

            default:

                //
                // Don't know about this Address Family
                //

                return (ERROR_NOT_SUPPORTED);

        }

        //
        // If we've made it to here, everything must have worked ok.
        // Return without error.
        //

        return (NO_ERROR);

    }

    //
    // No address and address length specified.  This means we'll let
    // WinSock figure it out for us.
    //

    switch (iAddressFamily) {

        case AF_INET:

            //
            // Use AddressFamily provided, and assume UDP
            //

            if (!(OpenSocket(iAddressFamily, IPPROTO_UDP, pSocket))) {

                //
                // Couldn't open the socket for whatever reason.
                // Return the real error to the caller.
                //

                return (GetLastError());

            }

            err = BindSocket(*pSocket, iAddressFamily, PORT_DONT_CARE, NULL, NULL);

            if (err) {

                //
                // Couldn't bind to that address for whatever reason
                // Return the error to the caller.
                //

                return (err);

            }

            break;

        case AF_IPX:

            //
            // Use AddressFamily provided, and assume IPX
            //

            if (!(OpenSocket(iAddressFamily, NSPROTO_IPX, pSocket))) {

                //
                // Couldn't open the socket for whatever reason.
                // Return the real error to the caller.
                //

                return (GetLastError());

            }

            err = BindSocket(*pSocket, iAddressFamily, PORT_DONT_CARE, NULL, NULL);

            if (err) {

                //
                // Couldn't bind to that address for whatever reason
                // Return the error to the caller.
                //

                return (err);

            }

            break;

        default:

            //
            // Don't know about this Address Family
            //

            return (ERROR_NOT_SUPPORTED);

    }

    //
    // If we've made it to here, everything must have worked ok.  Return
    // without error.
    //

    return (NO_ERROR);

}


/*=============================================================================

    GetProtocolInfo - Get information about the protocols beneath WinSock

    Description:

        This function enumerates all the protocols residing under WinSock
        into the prot_info global structure array.  It also returns the
        total number of protocols available underneath WinSock, detailing
        how many of these are connnectionless type of protocols, as well as
        a bitmask of the connectionless protocols in the prot_info array.

        For performance reasons, we're most interested in the connectionless,
        (i.e. datagram driven) protocols.  If it turns out that we find
        two connectionless protocols in the same address family, we'll
        pick the one with more capabilities.

    Arguments:

        pTotalProtocols - Pointer to variable to receive total number of
        installed protocols under WinSock.

        pConnectionlessCount - Pointer to variable to receive the number of
        installed connectionless protocols under WinSock.

        pConnectionlessMask - Pointer to a variable to receive bitmask of
        where the connectionless protocols fall in the global prot_info array.

        pInfoBuffer - Pointer to buffer to receive the PROTOCOL_INFO structs

        pBufferLength - Pointer to variable holding the length of pInfoBuffer

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents returning the specified data, it returns an appropriate
        Win32 error.

-----------------------------------------------------------------------------*/
UINT GetProtocolInfo(
    OUT    PUSHORT pTotalProtocols,
    OUT    PUSHORT pConnectionlessCount,
    OUT    PUSHORT pConnectionlessMask,
    IN OUT PPROTOCOL_INFO pInfoBuffer,
    IN OUT LPDWORD pBufferLength
    )

{

    INT TempFamily;
    UINT i;
    UINT j;
    UINT err;
    UINT TempBits;
    DWORD TempCaps;
    USHORT TempMask;
    PPROTOCOL_INFO pTempBuffer;

    //
    // All of the known protocols we want to enumerate are defined here
    //

    INT KnownProts[] = { IPPROTO_ICMP, IPPROTO_GGP, IPPROTO_TCP, IPPROTO_PUP,
                         IPPROTO_UDP,  IPPROTO_IDP, IPPROTO_ND,  IPPROTO_RAW,
                         IPPROTO_MAX,  NSPROTO_IPX, NSPROTO_SPX, NSPROTO_SPXII,
                         NBPROTO_NETBEUI, 0 };


    //
    // Preset arguments to be zero, in case we hit an error along the way
    //

    *pTotalProtocols = 0;
    *pConnectionlessCount = 0;
    *pConnectionlessMask = 0;

    //
    // Make sure we've at least initialized with the WinSock library
    //

    if (!bNetIsUp) {

        SetLastError(WSANOTINITIALISED);
        return (FALSE);

    }

    //
    // We need a big enough buffer to handle however many protocols are
    // installed underneath WinSock.  If it's not big enough, WinSock
    // doesn't even try to tell you how many protocols are there, it
    // just bitches and says buffer not big enough.
    //

    pTempBuffer = pInfoBuffer;
    memset(pInfoBuffer, 0, *pBufferLength);
    err = EnumProtocols(KnownProts, pInfoBuffer, pBufferLength);

    //
    // If EnumProtocols really came back with an error, the error will be
    // SOCKET_ERROR.  From there, you've gotta call GetLastError to figure
    // out what happened.  Otherwise, the return value is actually the
    // number of installed transports underneath WinSock.
    //

    if (err == SOCKET_ERROR) {

        //
        // If the error is buffer was not big enough, the size needed
        // will already be in the users buffer length variable.
        //

        return (GetLastError());

    }

    //
    // No error, fill in callers total count field.
    //

    *pTotalProtocols = (USHORT)err;

    //
    // Start enumerating the number of connectionless protocols underneath
    // WinSock.  We're only interested in connectionless protocols from
    // different address families.
    //

    for (i=0; i < err; i++, pInfoBuffer++) {

        if (pInfoBuffer->dwServiceFlags & XP_CONNECTIONLESS) {

            //
            // Found one!  We'll go ahead and increment up the number
            // of connectionless transports we've found, and turn on
            // this position in the bitmask.  However, before we accept
            // this as gospel, let's take a look and see if we've
            // ever seen anything better from this family before.
            //

            (*pConnectionlessCount)++;
            TempMask = *pConnectionlessMask;
            *pConnectionlessMask |= 1 << i;

            //
            // Chew backwards thru the bitmask looking for relatives
            //

            j = i-1;
            TempCaps = pInfoBuffer->dwServiceFlags;
            TempBits = CountBits(pInfoBuffer->dwServiceFlags);
            TempFamily = pInfoBuffer->iAddressFamily;

            //
            // As long as there's somebody turned on in the bitmask,
            // we gotta check it out.
            //

            while (TempMask) {

                //
                // Must have seen some kindof connectionless protocol before
                //

                if (TempMask & (1 << j)) {

                    //
                    // Found a representative of the best connectionless
                    // protocol within its particular family.  If his
                    // family and mine are the same, then I've gotta
                    // check to see if I'm better than him.
                    //

                    if (TempFamily == pTempBuffer[j].iAddressFamily) {

                        //
                        // We are from the same family.  So who's better?
                        // Since there's two of us from the same family,
                        // we've gotta decrement the count no matter what.
                        //

                        UINT PreviousBits;
                        DWORD PreviousCaps;

                        (*pConnectionlessCount)--;
                        PreviousCaps = pTempBuffer[j].dwServiceFlags;
                        PreviousBits = CountBits(pTempBuffer[j].dwServiceFlags);

                        if (TempBits > PreviousBits) {

                            //
                            // We got more bits than previous one.  Turn him
                            // off (Previous), then break out of this loop.
                            //

                            *pConnectionlessMask &= ~(1 << j);
                            break;

                        }

                        else if (TempBits < PreviousBits) {

                            //
                            // Previous one is better than me.  Turn myself
                            // off (Temp), and break out of this loop.
                            //

                            *pConnectionlessMask &= ~(1 << i);
                            break;

                        }

                        //
                        // TempBits must be equal to PreviousBits.  So we've
                        // got equal bits, lets see whos got the newer
                        // capabilities (if any).
                        //

                        else if (TempCaps >= PreviousCaps) {

                            //
                            // We'll say that the latter one in the
                            // Enumeration chain is better (Temp).
                            // Turn off Previous, and break out of this loop.
                            //

                            *pConnectionlessMask &= ~(1 << j);
                            break;

                        }

                        else {

                            //
                            // Previous one is better than me.  Turn myself
                            // off (Temp), and break out of this loop.
                            //

                            *pConnectionlessMask &= ~(1 << i);
                            break;

                        }

                    }

                }

                //
                // Clear the jth bit in the TempMask, and then decrement
                // j in order to goto the previous bit position.
                //

                TempMask &= ~(1 << j);
                j--;

            }

        }

    }

    return (NO_ERROR);

}


/*=============================================================================

    ReceiveAny - Do a blocking receive from anyone.

    Description:

        This function does a blocking recvfrom() to WinSock.
        On input, pBufferLen says how big pBuffer is, but on
        output this function will fill in the amount of data
        that was received.

    Arguments:

        Socket - socket to be receive from

        pSockAddr - Pointer to buffer where the senders address will be put

        pSockAddrLen - Pointer to variable containing length of pSockAddr

        pBuffer - Pointer to buffer where receive data will be placed

        pBufferLen - On input, points to length of pBuffer.  On output,
        the length of the received data will be filled in.

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents receving the specified data, it returns an appropriate
        Win32 error.

-----------------------------------------------------------------------------*/
UINT ReceiveAny(
    IN     SOCKET Socket,
    IN OUT PSOCKADDR pSockAddr,
    IN     LPINT pSockAddrLen,
    IN OUT PCHAR pBuffer,
    IN OUT LPUINT pBufferLen
    )

{

    UINT err;


    //
    // We'll do a recvfrom() using the parameters provided to us
    //

    err = recvfrom(Socket, pBuffer, *pBufferLen, 0, pSockAddr, pSockAddrLen);

    //
    // We've come back from the receive, lets check to see if we really
    // received something, or is this just an error.
    //

    if (err == SOCKET_ERROR) {

        //
        // This is some kind of error.  Get the real error and return it
        // to the caller.
        //

        return (GetLastError());

    }

    //
    // Nope, this is a legitimate receive.  Now let's fill in how much
    // we received and return with No Error.
    //

    *pBufferLen = err;
    return (NO_ERROR);

}


/*=============================================================================

    SendTo - Do a blocking send to someone

    Description:

        This function does a blocking sendto() to WinSock.
        On input, pBufferLen says how big pBuffer is, but on
        output this function will fill in the amount of data
        that was sent.

    Arguments:

        Socket - socket to send from

        pSockAddr - Pointer to destination address structure

        SockAddrLen - Length of destination address structure

        pBuffer - Pointer to buffer where receive data will be placed

        pBufferLen - On input, points to length of pBuffer.
                     On output, how much data was sent will be filled in

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents sending the specified data, it returns an appropriate
        Win32 error.

-----------------------------------------------------------------------------*/
UINT SendTo(
    IN     SOCKET Socket,
    IN OUT PSOCKADDR pSockAddr,
    IN     UINT SockAddrLen,
    IN OUT PCHAR pBuffer,
    IN OUT LPUINT pBufferLen
    )

{

    UINT err;

    //
    // We'll do a sendto() using the parameters provided to us
    //

    err = sendto(Socket, pBuffer, *pBufferLen, 0, pSockAddr, SockAddrLen);

    //
    // We've come back from the send, lets check to see if we really
    // sent something, or is this just an error.
    //

    if (err == SOCKET_ERROR) {

        //
        // This is some kind of error.  Get the real error and return it
        // to the caller.
        //

        return (GetLastError());

    }

    //
    // Nope, it sent the data.  Now let's fill in how much we actually
    // sent so the caller knows and return with No Error.
    //

    *pBufferLen = err;
    return (NO_ERROR);


}


/*=============================================================================

    ShutdownWinSock - Terminate use of WinSock library

    Description:

        This function cleans up the use of WinSock library (wsock32.dll)

    Arguments:

        None.

    Return Value:

        Returns NO_ERROR if everything goes ok, else if anything occurred
        that prevents cleaning up, it returns an appropriate Win32 error.

-----------------------------------------------------------------------------*/
extern "C" UINT ShutdownWinSock()

{

     UINT err;


    //
    // Make sure we've at least initialized with the WinSock library
    //

    if (!bNetIsUp) {

        SetLastError(WSANOTINITIALISED);
        return (FALSE);

    }

    err = WSACleanup();

    if (err == SOCKET_ERROR) {

        //
        // Some kind of Error occurred out of WinSock.  Return the
        // real error back to the caller.
        //

        return (GetLastError());

    }

    //
    // Set global Boolean variable to indicate we've shutdown now.
    //

    bNetIsUp = FALSE;
    return (NO_ERROR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\commcode.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
// PURPOSE:
//    Contains public declarations for the CommCode module.
//

BOOL _cdecl StartComm(HANDLE hNewCommFile, HANDLE);
void _cdecl StopComm(HANDLE);
BOOL WriteCommString(LPVOID pszStringToWrite, DWORD nSizeofStringToWrite);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	DPLAY.DLL initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *
 ***************************************************************************/

#include "windows.h"

/*
 * DllMain
 */
HINSTANCE hInst;

BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    hInst = hmod;

    return TRUE;
} /* DllMain */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\misc\queue.cpp ===
#ifndef  WIN32_LEAN_AND_MEAN
#define  WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <winsock.h>
#ifndef _MT
#define _MT
#endif

#include <dplay.h>
#include <logit.h>


DWORD dwMsgSeq   = 1;
DWORD dwQMsgs     = 0;
DWORD dwMsgIndx  = 0;
DWORD dwMaxMsgs;
static CRITICAL_SECTION q_Section;

typedef struct
{
    DWORD   dwSeq;
    DWORD   dwSize;
    BOOL    bValid;
    DWORD   dwIndex;
    DPID    pidTo;
    DPID    pidFrom;
} MSG_ARRAY;

typedef struct
{
    DWORD   dwCount;
    DPID    pid;
    HANDLE  hEvent;
} PLAYER_NOTIFY;

char            *pmsgElements = NULL;
MSG_ARRAY       *pmsgArray    = NULL;
PLAYER_NOTIFY   *aNotify      = NULL;
HANDLE           hSystemMsg   = NULL;


#define malloc(a)  LocalAlloc(LMEM_FIXED, (a))
#define free(a)      LocalFree((HLOCAL)(a))
#define min(a,b)     (((a) < (b)) ? (a) : (b))
#define max(a,b)     (((a) > (b)) ? (a) : (b))

DWORD g_maxMsg     = 0;
DWORD g_maxPlayers = 0;

BOOL CreateQueue(DWORD dwElements, DWORD dwmaxMsg, DWORD dwmaxPlayers)
{
    DWORD   ii;

    if (pmsgElements)
        return(FALSE);

    pmsgElements = (char *)          malloc(dwElements * dwmaxMsg);
    pmsgArray    = (MSG_ARRAY   *)   malloc(dwElements * sizeof(MSG_ARRAY));
    aNotify      = (PLAYER_NOTIFY *) malloc(dwmaxPlayers * sizeof(PLAYER_NOTIFY));

    if (!pmsgElements || !pmsgArray || !aNotify)
    {
        if (pmsgElements)
            free(pmsgElements);
        if (pmsgArray)
            free(pmsgArray);
        if (aNotify)
            free(aNotify);

        pmsgElements = NULL;
        pmsgArray    = NULL;
        aNotify      = NULL;

        return(FALSE);
    }

    for (ii = 0; ii < dwmaxPlayers; ii++)
    {
        aNotify[ii].dwCount = 0;
        aNotify[ii].pid     = 0;
        aNotify[ii].hEvent  = 0;
    }

    for (ii = 0; ii < dwElements; ii++)
    {
        pmsgArray[ii].dwSeq   = 0;
        pmsgArray[ii].bValid  = FALSE;
        pmsgArray[ii].dwIndex = ii;
        pmsgArray[ii].pidTo   = 0;
        pmsgArray[ii].pidFrom = 0;
    }

    dwMaxMsgs = dwElements;

    dwMsgSeq   = 1;
    dwQMsgs     = 0;
    dwMsgIndx  = 0;

    g_maxMsg     = dwmaxMsg;
    g_maxPlayers = dwmaxPlayers;

    InitializeCriticalSection( &q_Section );

    return(TRUE);
}


BOOL DeleteQueue()
{
    if (pmsgElements)
        free(pmsgElements);
    if (pmsgArray)
        free(pmsgArray);
    if (aNotify)
        free(aNotify);

    pmsgElements = NULL;
    pmsgArray    = NULL;
    aNotify      = NULL;

    DeleteCriticalSection( &q_Section );
    return(TRUE);
}

BOOL AddMessage(LPVOID lpvMsg, DWORD dwSize, DPID pidTo, DPID pidFrom, BOOL bHigh)
{
    DWORD dwSeq;
    DWORD dwIndex;
    DWORD ii;
    DPID  pid;


    if (dwSize > g_maxMsg)
        return(FALSE);

    // DBG_INFO((DBGARG, "AddMessage.  Seq %d Current %d", dwMsgSeq, dwQMsgs));

    EnterCriticalSection( &q_Section );
    dwMsgSeq++;
    if (dwQMsgs == dwMaxMsgs)
    {
        TSHELL_INFO("Queue over-run, start dumping old messages");
        dwSeq = 0xffffffff;
        for (ii = 0; ii < dwMaxMsgs; ii++)
        {
            dwSeq = min(dwSeq, pmsgArray[ii].dwSeq);
            if (dwSeq == pmsgArray[ii].dwSeq)
                dwIndex = ii;
        }
        pid = pmsgArray[dwIndex].pidTo;
        pmsgArray[dwIndex].bValid = FALSE;
            for (ii = 0; ii < g_maxPlayers; ii++)
                if (aNotify[ii].pid == pid)
                    aNotify[ii].dwCount--;
        dwQMsgs--;
    }
    else
    {
        dwQMsgs++;
        for (ii = 0;    ii < dwMaxMsgs
                     && (pmsgArray[dwMsgIndx].bValid == TRUE); ii++)
        {
            dwMsgIndx++;
            dwMsgIndx %= dwMaxMsgs;
        }
        dwIndex = dwMsgIndx;
    }

    if (pmsgArray[dwIndex].bValid == TRUE)
    {
        TSHELL_INFO("Invalid Message State!");
    }

    // DBG_INFO((DBGARG, "Message index %d", dwIndex));

    pmsgArray[dwIndex].dwSeq   = dwMsgSeq;
    pmsgArray[dwIndex].dwSize  = dwSize;
    pmsgArray[dwIndex].bValid  = TRUE;
    pmsgArray[dwIndex].pidTo   = pidTo;
    pmsgArray[dwIndex].pidFrom = pidFrom;
    if (bHigh)
    {
        pmsgArray[dwIndex].dwSeq += 0x80000000;
    }

    memcpy( pmsgElements + (dwIndex * g_maxMsg), lpvMsg, dwSize);

    // TSHELL_INFO("Message in buffer, now handle increments and events");
    // DBG_INFO((DBGARG, "pidTo %d pidFrom %d", pidTo, pidFrom));

    if (pidTo != 0)
    {
        for (ii = 0; ii < g_maxPlayers; ii++)
            if (aNotify[ii].pid == pidTo)
            {
    //             TSHELL_INFO("Increment");
                InterlockedIncrement((LONG *) &(aNotify[ii].dwCount));
                if (aNotify[ii].hEvent)
                {
    //                 TSHELL_INFO("Set Event");
                    SetEvent(aNotify[ii].hEvent);
    //                 DBG_INFO((DBGARG, "Signal Event %8x", aNotify[ii].hEvent));
                }
                else
                {
                    TSHELL_INFO("No Event to Signal.");
                }
                break;
            }
    }

    LeaveCriticalSection( &q_Section );
    return(TRUE);        
}

HRESULT GetQMessage(LPVOID lpvMsg, LPDWORD pdwSize, DPID *ppidTo, DPID *ppidFrom,
    DWORD dwFlags, BOOL bPeek)
{
    DWORD dwSeq;
    DWORD dwIndex;
    DWORD dwSeqH;
    DWORD dwIndexH;
    DWORD ii;
    HRESULT hr = DP_OK;

//    TSHELL_INFO("Retrieve Messages.");
    if (dwQMsgs == 0)
        return(DPERR_NOMESSAGES);

    if (!lpvMsg && !pdwSize)
        return(DPERR_INVALIDPARAM);

    EnterCriticalSection( &q_Section );

    dwSeq    = 0xffffffff;
    dwIndex  = 0xffffffff;
    dwSeqH   = 0xffffffff;
    dwIndexH = 0xffffffff;

    for (ii = 0; ii < dwMaxMsgs; ii++)
    {
        if (pmsgArray[ii].bValid)
        {
            if (    (dwFlags & DPRECEIVE_ALL)
                || ((dwFlags & DPRECEIVE_TOPLAYER) &&
                    (pmsgArray[ii].pidTo == *ppidTo))
                || ((dwFlags & DPRECEIVE_FROMPLAYER) &&
                    (pmsgArray[ii].pidFrom == *ppidFrom)))
            {
//                DBG_INFO((DBGARG, "Msg %d Seq %x valid and meets criteria.",
//                        ii, pmsgArray[ii].dwSeq));

                if (0x80000000 & pmsgArray[ii].dwSeq)
                {
                    if (dwSeqH > pmsgArray[ii].dwSeq)
                    {
                        dwSeqH   = pmsgArray[ii].dwSeq;
                        dwIndexH = ii;
                    }
                }
                else
                {
                    if (dwSeq > pmsgArray[ii].dwSeq)
                    {
                        dwSeq   = pmsgArray[ii].dwSeq;
                        dwIndex = ii;
                    }
                }
            }
            else
            {
                DBG_INFO((DBGARG, "Msg %d valid but doesn't meet criteria. for Flags %8x", ii, dwFlags));
            }
        }
    }
    if (dwIndexH != 0xffffffff)
    {
        dwIndex = dwIndexH;
    }

    if (dwIndex != 0xffffffff)
    {
//        TSHELL_INFO("Return a message.");
        if (lpvMsg == NULL || (*pdwSize < pmsgArray[dwIndex].dwSize))
        {
            *pdwSize = pmsgArray[dwIndex].dwSize;
            hr = DPERR_BUFFERTOOSMALL;
        }
        else
        {
            memcpy( lpvMsg, pmsgElements + (dwIndex * g_maxMsg),
                            pmsgArray[dwIndex].dwSize);
            *pdwSize  = pmsgArray[dwIndex].dwSize;
            *ppidTo   = pmsgArray[dwIndex].pidTo;
            *ppidFrom = pmsgArray[dwIndex].pidFrom;

            if (!(dwFlags & DPRECEIVE_PEEK))
            {
                dwQMsgs--;
                pmsgArray[dwIndex].bValid = FALSE;
                for (ii = 0; ii < g_maxPlayers; ii++)
                    if (aNotify[ii].pid == pmsgArray[dwIndex].pidTo)
                    {
                        InterlockedDecrement((LONG *) &aNotify[ii].dwCount);
                        if (aNotify[ii].dwCount == 0 && aNotify[ii].hEvent)
                            ResetEvent(aNotify[ii].hEvent);
                    }
            }
        }
    }
    else
    {
        TSHELL_INFO("No messages found.");
        hr = DPERR_NOMESSAGES;
    }

//    TSHELL_INFO("LeaveGetQMessage.");
    LeaveCriticalSection( &q_Section );
    return(hr);

}

VOID FlushQueue(DPID pid)
{
    HRESULT hr = DP_OK;
    DWORD   ii;

    EnterCriticalSection( &q_Section );

    for (ii = 0; ii < g_maxPlayers; ii++)
    {
        if (aNotify[ii].pid == pid)
        {
            aNotify[ii].dwCount = 0;
            if (aNotify[ii].hEvent)
                aNotify[ii].hEvent = NULL;
        }
    }

    for (ii = 0; ii < dwMaxMsgs; ii++)
    {
        if (pmsgArray[ii].bValid && pmsgArray[ii].pidTo == pid)
        {
            dwQMsgs--;
            pmsgArray[ii].bValid = FALSE;
        }
    }


    LeaveCriticalSection( &q_Section );
}

BOOL SetupLocalPlayer(DPID pid, HANDLE hEvent)
{
    DWORD ii;

    if (pid == 0)
        return(FALSE);

    for (ii = 0; ii < g_maxPlayers; ii++)
    {
        if (aNotify[ii].pid == 0)
        {
            aNotify[ii].pid = pid;
            aNotify[ii].hEvent = hEvent;
            // DBG_INFO((DBGARG, "Pid %d index %d in Queue with event %8x",
            //     pid, ii, hEvent));
            return(TRUE);
        }
    }
    return(FALSE);
}

DWORD GetPlayerCount(DPID spid)
{
    DWORD ii;

    for (ii = 0; ii < g_maxPlayers; ii++)
        if (aNotify[ii].pid == spid)
            return(aNotify[ii].dwCount);

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\commcode.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: CommCode.c
//
//  PURPOSE: Handles all the COMM routines for TapiComm.
//
//  EXPORTED FUNCTIONS:  These functions are for use by other modules.
//    StartComm        - Start communications.
//    StopComm         - Stop Communications.
//    WriteCommString  - Write a string to the Comm port.
//
//  INTERNAL FUNCTION:  These functions are for this module only.
//    CloseReadThread  - Close the Read Thread.
//    CloseWriteThread - Close the Write Thread.
//
//    StartReadThreadProc    - Starting function for the Read Thread.
//    StartWriteThreadProc   - Starting function for the Write Thread.
//
//    - Write Thread helper function
//    HandleWriteData - Actually does the work of writing a string to comm.
//
//    - Read Thread helper functions
//    SetupReadEvent  - Sets up the overlapped ReadFile
//    HandleReadEvent - Gets the results from the overlapped ReadFile
//    HandleReadData  - Handles data returned from the ReadFile
//
//    HandleCommEvent - Sets up the CommEvent event.
//    SetupCommEvent  - Handles CommEvent events (if they occur).
//


#include <windows.h>
#include <string.h>
#include "TapiCode.h"
#include "CommCode.h"
#include "globals.h"
#include "TapiInfo.h"
#include "dpspimp.h"
#include "logit.h"

// This is the message posted to the WriteThread
// When we have something to write.

// Default size of the Input Buffer used by this code.
#define INPUTBUFFERSIZE 2048

//*****************************************
// Global variables.
//*****************************************

volatile BOOL g_bIgnoreReads = FALSE;
volatile BOOL g_bRecovery    = FALSE;

HANDLE g_hCommFile = NULL;

DWORD g_dwIOThreadID  = 0;
HANDLE g_hIOThread  = NULL;

HANDLE g_hCloseEvent  = NULL;
HANDLE g_hDummyEvent1 = NULL;
HANDLE g_hDummyEvent2 = NULL;
HANDLE g_hReadEvent   = NULL;
HANDLE g_hWriteEvent1 = NULL;
HANDLE g_hWriteEvent0 = NULL;
HANDLE g_hCommEvent   = NULL;

CImpIDP_SP *g_IDP     = NULL;

DWORD  dwMsgs = 0;
typedef struct
{
    BOOL    bValid;
    LPVOID  lpv;
    DWORD   dwSize;
} WRITE_WAIT;

WRITE_WAIT  writewait[2];

MSG_BUILDER msg_Building;

//*****************************************
// CommCode internal Function Prototypes
//*****************************************

void CloseReadThread();
void CloseWriteThread();

DWORD WINAPI StartIOThreadProc(LPVOID lpvParam);


BOOL HandleWriteData(LPOVERLAPPED lpOverlappedWrite,
        LPCSTR lpszStringToWrite, DWORD dwNumberOfBytesToWrite);


BOOL SetupReadEvent(LPOVERLAPPED lpOverlappedRead,
        LPSTR lpszInputBuffer, DWORD dwSizeofBuffer,
        LPDWORD lpnNumberOfBytesRead);
BOOL HandleReadEvent(LPOVERLAPPED lpOverlappedRead,
        LPSTR lpszInputBuffer, DWORD dwSizeofBuffer,
        LPDWORD lpnNumberOfBytesRead);
BOOL HandleReadData(LPCSTR lpszInputBuffer, DWORD dwSizeofBuffer);


BOOL HandleCommEvent(LPOVERLAPPED lpOverlappedCommEvent,
        LPDWORD lpfdwEvtMask, BOOL fRetrieveEvent);
BOOL SetupCommEvent(LPOVERLAPPED lpOverlappedCommEvent,
        LPDWORD lpfdwEvtMask);



#define WAIT_OBJECT_1 (WAIT_OBJECT_0 + 1)
#define WAIT_OBJECT_2 (WAIT_OBJECT_0 + 2)
#define WAIT_OBJECT_3 (WAIT_OBJECT_0 + 3)
#define WAIT_OBJECT_4 (WAIT_OBJECT_0 + 4)
#define WAIT_OBJECT_5 (WAIT_OBJECT_0 + 5)


volatile BOOL g_bCommStarted = FALSE;

//*****************************************
// Functions exported for use by other modules
//*****************************************


//
//  FUNCTION: StartComm(HANDLE)
//
//  PURPOSE: Starts communications over the comm port.
//
//  PARAMETERS:
//    hNewCommFile - This is the COMM File handle to communicate with.
//                   This handle is obtained from TAPI.
//
//  RETURN VALUE:
//    TRUE if able to setup the communications.
//
//  COMMENTS:
//
//    StartComm makes sure there isn't communication in progress already,
//    the hNewCommFile is valid, and all the threads can be created.  It
//    also configures the hNewCommFile for the appropriate COMM settings.
//
//    If StartComm fails for any reason, it's up to the calling application
//    to close the Comm file handle.
//
//

extern BOOL CreateQueue(DWORD dwElements, DWORD dwmaxMsg, DWORD dwmaxPlayers);
extern BOOL DeleteQueue();

BOOL _cdecl StartComm(HANDLE hNewCommFile, HANDLE hEvent)
{
    // Is this a valid comm handle?
    if (GetFileType(hNewCommFile) != FILE_TYPE_CHAR)
    {
        TSHELL_INFO(TEXT("File handle is not a comm handle."));
        return FALSE;
    }

    // Are we already doing comm?
    if (g_hCommFile != NULL)
    {
        TSHELL_INFO(TEXT("Already have a comm file open"));
        return FALSE;
    }



    // Its ok to continue.

    g_hCommFile = hNewCommFile;

    // Setting and querying the comm port configurations.

    { // Configure the comm settings.
        COMMTIMEOUTS commtimeouts;
        DCB dcb;
        COMMPROP commprop;
        DWORD fdwEvtMask;

        // These are here just so you can set a breakpoint
        // and see what the comm settings are.  Most Comm settings
        // are already set through TAPI.
        GetCommState(hNewCommFile, &dcb);
        GetCommProperties(hNewCommFile, &commprop);
        GetCommMask(g_hCommFile, &fdwEvtMask);
        GetCommTimeouts(g_hCommFile, &commtimeouts);


        // The CommTimeout numbers will very likely change if you are
        // coding to meet some kind of specification where
        // you need to reply within a certain amount of time after
        // recieving the last byte.  However,  If 1/4th of a second
        // goes by between recieving two characters, its a good
        // indication that the transmitting end has finished, even
        // assuming a 1200 baud modem.

        commtimeouts.ReadIntervalTimeout         = 250;
        commtimeouts.ReadTotalTimeoutMultiplier  = 0;
        commtimeouts.ReadTotalTimeoutConstant    = 0;
        commtimeouts.WriteTotalTimeoutMultiplier = 0;
        commtimeouts.WriteTotalTimeoutConstant   = 0;

        SetCommTimeouts(g_hCommFile, &commtimeouts);

        // fAbortOnError is the only DCB dependancy in TapiComm.
        // Can't guarentee that the SP will set this to what we expect.
        dcb.fAbortOnError = FALSE;
        SetCommState(hNewCommFile, &dcb);
    }

    // Create the events we need.
    g_hCloseEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hReadEvent   = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hDummyEvent1 = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hDummyEvent2 = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hWriteEvent1 = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hWriteEvent0 = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hCommEvent   = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (   !g_hCloseEvent
        || !g_hDummyEvent1
        || !g_hReadEvent
        || !g_hDummyEvent2
        || !g_hWriteEvent1
        || !g_hWriteEvent0
        || !g_hCommEvent)
    {
        DBG_INFO((DBGARG, TEXT("Unable to CreateEvent: %d"), GetLastError()));
        g_hCommFile = NULL;
        return FALSE;
    }

    // Create the Read thread.
    g_hIOThread =
        CreateThread(NULL, 0, StartIOThreadProc, 0, 0, &g_dwIOThreadID);

    if (g_hIOThread == NULL)
    {
        DBG_INFO((DBGARG, TEXT("Unable to create IO thread: %d"), GetLastError()));

        g_dwIOThreadID = 0;
        g_hCommFile = 0;

        if (g_hCloseEvent ) CloseHandle(g_hCloseEvent );
        if (g_hReadEvent )  CloseHandle(g_hReadEvent  );
        if (g_hDummyEvent1) CloseHandle(g_hDummyEvent1);
        if (g_hDummyEvent2) CloseHandle(g_hDummyEvent2);
        if (g_hWriteEvent1) CloseHandle(g_hWriteEvent1);
        if (g_hWriteEvent0) CloseHandle(g_hWriteEvent0);
        if (g_hCommEvent  ) CloseHandle(g_hCommEvent  );

        g_hCloseEvent   = NULL;
        g_hReadEvent    = NULL;
        g_hDummyEvent1  = NULL;
        g_hDummyEvent2  = NULL;
        g_hWriteEvent1  = NULL;
        g_hWriteEvent0  = NULL;
        g_hCommEvent    = NULL;
        return FALSE;
    }

    // Comm threads should to have a higher base priority than the UI thread.
    // If they don't, then any temporary priority boost the UI thread gains
    // could cause the COMM threads to loose data.
    SetThreadPriority(g_hIOThread, THREAD_PRIORITY_HIGHEST);

    g_bCommStarted = TRUE;
    // Everything was created ok.  Ready to go!
    if (hEvent)
        SetEvent(hEvent);
    return TRUE;
}


//
//  FUNCTION: StopComm
//
//  PURPOSE: Stop and end all communication threads.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    Tries to gracefully signal all communication threads to
//    close, but terminates them if it has to.
//
//

void _cdecl StopComm(HANDLE hEvent)
{
    g_bCommStarted = FALSE;
    // No need to continue if we're not communicating.
    if (g_hCommFile == NULL)
        return;

    TSHELL_INFO(TEXT("Stopping the Comm."));

    if (g_hIOThread)
    {

        TSHELL_INFO(TEXT("Closing Read Thread"));

        // Signal the event to close the worker threads.
        SetEvent(g_hCloseEvent);

        // Purge all outstanding reads
        PurgeComm(g_hCommFile, PURGE_RXABORT | PURGE_RXCLEAR
                             | PURGE_TXABORT | PURGE_TXCLEAR);

        // Wait 10 seconds for it to exit.  Shouldn't happen.
        if (WaitForSingleObject(g_hIOThread, 10000) == WAIT_TIMEOUT)
        {
            TSHELL_INFO(TEXT("IO thread not exiting.  Terminating it."));

            TerminateThread(g_hIOThread, 0);

            // The ReadThread cleans up these itself if it terminates
            // normally.
            CloseHandle(g_hIOThread);
            g_hIOThread = 0;
            g_dwIOThreadID = 0;
        }

    }

    CloseHandle(g_hCloseEvent );
    CloseHandle(g_hDummyEvent1);
    CloseHandle(g_hDummyEvent2);
    CloseHandle(g_hWriteEvent1);
    CloseHandle(g_hWriteEvent0);
    CloseHandle(g_hCommEvent  );

    g_hCloseEvent   = NULL;
    g_hDummyEvent1  = NULL;
    g_hDummyEvent2  = NULL;
    g_hWriteEvent1  = NULL;
    g_hWriteEvent0  = NULL;
    g_hCommEvent    = NULL;

    // Now close the comm port handle.
    CloseHandle(g_hCommFile);
    g_hCommFile = NULL;
    if (hEvent)
        SetEvent(hEvent);
}


//
//  FUNCTION: WriteCommString(LPCSTR, DWORD)
//
//  PURPOSE: Send a String to the Write Thread to be written to the Comm.
//
//  PARAMETERS:
//    pszStringToWrite     - String to Write to Comm port.
//    nSizeofStringToWrite - length of pszStringToWrite.
//
//  RETURN VALUE:
//    Returns TRUE if the PostMessage is successful.
//    Returns FALSE if PostMessage fails or Write thread doesn't exist.
//
//  COMMENTS:
//
//    This is a wrapper function so that other modules don't care that
//    Comm writing is done via PostMessage to a Write thread.  Note that
//    using PostMessage speeds up response to the UI (very little delay to
//    'write' a string) and provides a natural buffer if the comm is slow
//    (ie:  the messages just pile up in the message queue).
//
//    Note that it is assumed that pszStringToWrite is allocated with
//    LocalAlloc, and that if WriteCommString succeeds, its the job of the
//    Write thread to LocalFree it.  If WriteCommString fails, then its
//    the job of the calling function to free the string.
//
//

BOOL WriteCommString(LPVOID lpszStringToWrite, DWORD dwSizeofStringToWrite)
{
    if (g_hIOThread)
    {
        if (PostThreadMessage(g_dwIOThreadID, PWM_COMMWRITE,
                (WPARAM) dwSizeofStringToWrite, (LPARAM) lpszStringToWrite))
        {
            if (g_IDP)
                InterlockedIncrement((LPLONG) &g_IDP->m_dwPendingWrites);
            return TRUE;
        }
        else
            TSHELL_INFO(TEXT("Failed to Post to Write thread."));
    }
    else
        TSHELL_INFO(TEXT("Write thread not created."));

    return FALSE;
}



//*****************************************
// The rest of the functions are intended for use
// only within the CommCode module.
//*****************************************



//
//  FUNCTION: StartIOThreadProc(LPVOID)
//
//  PURPOSE: The starting point for the Write thread.
//
//  PARAMETERS:
//    lpvParam - unused.
//
//  RETURN VALUE:
//    DWORD - unused.
//
//  COMMENTS:
//
//    The Write thread uses a PeekMessage loop to wait for a string to write,
//    and when it gets one, it writes it to the Comm port.  If the CloseEvent
//    object is signaled, then it exits.  The use of messages to tell the
//    Write thread what to write provides a natural desynchronization between
//    the UI and the Write thread.
//
//

typedef enum
{
    READ_HDR,
    READ_MSG,
    READ_RECOVER_K,
    READ_RECOVER_J,
    READ_RECOVER_y,
    READ_RECOVER_o,
    READ_RECOVER_r,
    READ_RECOVER_h,
    READ_RECOVER_a,
    READ_RECOVER_n,
    READ_RECOVER_H,
    READ_RECOVER_a2,
    READ_RECOVER_l1,
    READ_RECOVER_l2,
    READ_GOOD_CONNECT_1,
    RG2,
    RG3,
    RG4,
    RG5,
    RG6,
    RG7,
    RG8,
    RG9,
    RG10,
    RG11,
    RG12,
    RG13,
    RG14,
    RG15,
    RG16
} READ_STATE;

typedef enum
{
    ZERO_PENDING,
    ONE_PENDING,
    TWO_PENDING
} WRITE_STATE;

#ifdef DEBUG
#define WAIT_ZERO_PENDING  INFINITE
#else
#define WAIT_ZERO_PENDING  5000
#endif

DWORD WINAPI StartIOThreadProc(LPVOID lpvParam)
{
    MSG msg;
    DWORD dwHandleSignaled;
    READ_STATE  rState = READ_HDR;
    WRITE_STATE wState = ZERO_PENDING;
    HANDLE HandlesToWaitFor[5];
    OVERLAPPED overlappedWrite0 = {0, 0, 0, 0, NULL};
    OVERLAPPED overlappedWrite1 = {0, 0, 0, 0, NULL};
    OVERLAPPED overlappedCommEvent = {0, 0, 0, 0, NULL};
    OVERLAPPED overlappedRead  = {0, 0, 0, 0, NULL};
    DWORD      dwCount;
    DWORD      dwReadCountExpected;
    DWORD      fdwEvtMask;
    BOOL       bb;
    BOOL       bFirst = TRUE;
    DWORD      dwTimeBegin = 0;
    DWORD      dwBadBegin = 0;

    HandlesToWaitFor[0] = g_hCloseEvent;
    HandlesToWaitFor[1] = g_hCommEvent;
    HandlesToWaitFor[2] = g_hReadEvent;


    overlappedRead.hEvent      = g_hReadEvent;
    overlappedCommEvent.hEvent = g_hCommEvent;

    overlappedWrite0.hEvent = g_hWriteEvent0;
    overlappedWrite1.hEvent = g_hWriteEvent1;
    writewait[0].bValid = FALSE;
    writewait[0].lpv    = NULL;
    writewait[0].dwSize = 0;
    writewait[1].bValid = FALSE;
    writewait[1].lpv    = NULL;
    writewait[1].dwSize = 0;

    // Setup CommEvent handling.

    // Set the comm mask so we receive error signals.
    if (!SetCommMask(g_hCommFile, EV_ERR))
    {
        DBG_INFO((DBGARG, TEXT("Unable to SetCommMask: %d"), GetLastError()));
        PostHangupCall();
        return(0);
    }

    // Start waiting for CommEvents (Errors)
    if (!SetupCommEvent(&overlappedCommEvent, &fdwEvtMask))
    {
        PostHangupCall();
        return(0);
    }


    dwCount = sizeof(DPHDR);
    dwReadCountExpected = dwCount;
    ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);

    TSHELL_INFO(TEXT("Comm started so release waiting operations."));
    g_IDP->SetBlock();

    while (TRUE)
    {
        switch(wState)
        {
        case ZERO_PENDING:
            {
            HandlesToWaitFor[3] = g_hDummyEvent1;
            HandlesToWaitFor[4] = g_hWriteEvent1;

            // TSHELL_INFO(TEXT("Wait with 0 Pending."));
            dwHandleSignaled =
                MsgWaitForMultipleObjects(5, HandlesToWaitFor, FALSE,
                    WAIT_ZERO_PENDING, QS_ALLINPUT);
            }
            break;
        case ONE_PENDING:
            {
            // TSHELL_INFO(TEXT("Wait with 1 Pending."));
            if (writewait[0].bValid)
            {
                HandlesToWaitFor[3] = g_hWriteEvent0;
                HandlesToWaitFor[4] = g_hDummyEvent2;

            }
            else
            {
                HandlesToWaitFor[3] = g_hDummyEvent1;
                HandlesToWaitFor[4] = g_hWriteEvent1;
            }

            dwHandleSignaled =
                MsgWaitForMultipleObjects(5, HandlesToWaitFor, FALSE,
                    INFINITE, QS_ALLINPUT);

            }
            break;
        case TWO_PENDING:
            {
            // TSHELL_INFO(TEXT("Wait with 2 Pending."));
            HandlesToWaitFor[3] = g_hWriteEvent0;
            HandlesToWaitFor[4] = g_hWriteEvent1;

            dwHandleSignaled =
                WaitForMultipleObjects(5, HandlesToWaitFor, FALSE,
                    INFINITE);
            }
            break;
        default:
            TSHELL_INFO(TEXT("Invalid Write State"));

        }

        // DBG_INFO((DBGARG, TEXT("IO Thread Woken up. %8x"), dwHandleSignaled));
        switch (dwHandleSignaled)
        {
        case WAIT_TIMEOUT:
            //
            // Do to what I believe are problems with MsgWait() we will
            // time out MsgWait() at 1000msec if in the zero pending state.
            //
            break;
        case WAIT_OBJECT_0:     // CloseEvent
        {
            TSHELL_INFO(TEXT("Close Event recieved."));
            //
            // Cleanup and Exit
            //
            return(0);
        }
            break;

        case WAIT_OBJECT_1:     // CommEvent
        {
            TSHELL_INFO(TEXT("CommEvent Recieved."));
            // Handle the CommEvent.
            if (!HandleCommEvent(&overlappedCommEvent, &fdwEvtMask, TRUE))
            {
                PostHangupCall();
                return(0);
            }

            // Start waiting for the next CommEvent.
            if (!SetupCommEvent(&overlappedCommEvent, &fdwEvtMask))
            {
                PostHangupCall();
                return(0);
            }

        }
            break;

        case WAIT_OBJECT_2:     // ReadEvent
        {
        // TSHELL_INFO(TEXT("ReadEvent Recieved."));

        bb = GetOverlappedResult(g_hCommFile, &overlappedRead, &dwCount, FALSE);
        DBG_INFO((DBGARG, TEXT("Read expected %d and got %d on result %d"),
                             dwReadCountExpected, dwCount, bb));
        if (dwCount == dwReadCountExpected)
        {
            if (rState == READ_HDR)
            {
                DBG_INFO((DBGARG, TEXT("Read Hdr to(%d) from(%d) count (%d) cookie(%d) All(%8x)"),
                        msg_Building.dpHdr.to,
                        msg_Building.dpHdr.from,
                        msg_Building.dpHdr.usCount,
                        msg_Building.dpHdr.usCookie,
                        msg_Building.dpHdr.dwConnect1));

                if (   msg_Building.dpHdr.usCookie == SPSYS_USER
                    || msg_Building.dpHdr.usCookie == SPSYS_SYS
                    || msg_Building.dpHdr.usCookie == SPSYS_HIGH
                    || msg_Building.dpHdr.usCookie == SPSYS_CONNECT)
                {
                    // TSHELL_INFO(TEXT("Got a valid msg header, look for body."));
                    rState = READ_MSG;
                    dwReadCountExpected = msg_Building.dpHdr.usCount;
                    ResetEvent(g_hReadEvent);
                    ReadFile(g_hCommFile, msg_Building.chMsgCompose,
                                dwReadCountExpected, &dwCount, &overlappedRead);
                }
                else if (   msg_Building.dpHdr.dwConnect1 == DPSYS_JOHN)
                {
                    SPMSG_CONNECT *pMsg;

                    TSHELL_INFO(TEXT("Other end needs recover ssync."));
                    pMsg = (SPMSG_CONNECT *) LocalAlloc(LMEM_FIXED, sizeof(SPMSG_CONNECT));
                    if (pMsg)
                    {
                        pMsg->dpHdr.to       = 0;
                        pMsg->dpHdr.from     = 0;
                        pMsg->dpHdr.usCount  = sizeof(SPMSG_CONNECT) - sizeof(DPHDR);
                        pMsg->dpHdr.usCookie = SPSYS_CONNECT;
                        pMsg->usVerMajor     = DPVERSION_MAJOR;
                        pMsg->usVerMinor     = DPVERSION_MINOR;
                        pMsg->dwConnect1     = DPSYS_KYRA;
                        pMsg->dwConnect2     = DPSYS_HALL;
                        WriteCommString(pMsg, sizeof(SPMSG_CONNECT));
                        dwCount = sizeof(DPHDR);
                        dwReadCountExpected = dwCount;
                        ResetEvent(g_hReadEvent);
                        ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                    }
                    else
                    {
                        PostHangupCall();
                        return(0);
                    }

                }
                else
                {
                    DPHDR   *pRecover;

                    TSHELL_INFO(TEXT("Bad header type.  Enter recover state."));

                    if (bFirst)
                    {
                        PurgeComm(g_hCommFile, PURGE_RXCLEAR);
                        rState = READ_GOOD_CONNECT_1;
                        dwCount = 1;
                        dwReadCountExpected = dwCount;
                        ResetEvent(g_hReadEvent);
                        dwTimeBegin = GetTickCount();
                        ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                    }
                    else
                    {
                        pRecover = (DPHDR *) LocalAlloc(LMEM_FIXED, sizeof(DPHDR));
                        if (pRecover)
                        {
                            g_bRecovery = TRUE;
                            pRecover->dwConnect1 = DPSYS_JOHN;

                            DBG_INFO((DBGARG, TEXT("Send John 1 %8x"), pRecover));

                            WriteCommString(pRecover, sizeof(DPHDR));
                            PurgeComm(g_hCommFile, PURGE_RXCLEAR);
                            rState = READ_RECOVER_K;
                            dwCount = 1;
                            dwReadCountExpected = dwCount;
                            ResetEvent(g_hReadEvent);
                            ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                        }
                        else
                        {
                            PostHangupCall();
                            return(0);
                        }
                    }
                }
            }
            else if (rState == READ_MSG)
            {
                bFirst = FALSE;
                g_IDP->HandleMessage((LPVOID) &msg_Building, dwReadCountExpected);
                rState = READ_HDR;
                dwCount = sizeof(DPHDR);
                dwReadCountExpected = dwCount;
                ResetEvent(g_hReadEvent);
                ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
            }
            else if (rState >= READ_GOOD_CONNECT_1)
                {
                    char    ch = *((CHAR *) (&msg_Building.dpHdr));
                    BOOL    bSuccess = FALSE;

                    DBG_INFO((DBGARG, TEXT("First Connect state loop. %x, State %d"), 0x000000ff & ch, rState));

                    switch( rState)
                    {
                    case READ_GOOD_CONNECT_1:
                        rState = (ch == 0x00) ? RG2 : READ_GOOD_CONNECT_1;
                        break;
                    case RG2:
                        rState = (ch == 0x00) ? RG3 : READ_GOOD_CONNECT_1;
                        break;
                    case RG3 :
                        if (ch == 0x0c)
                            rState = RG4;
                        else if (ch == 0x00)
                            rState = RG3;
                        else
                            rState = READ_GOOD_CONNECT_1;
                        break;
                    case RG4 :
                        rState = (ch == 0x3c) ? RG5 : READ_GOOD_CONNECT_1;
                        break;
                    case RG5 :
                        rState = (ch == 0x01) ? RG6 : READ_GOOD_CONNECT_1;
                        break;
                    case RG6 :
                        rState = (ch == 0x00) ? RG7 : READ_GOOD_CONNECT_1;
                        break;
                    case RG7 :
                        rState = (ch == 0x01) ? RG8 : READ_GOOD_CONNECT_1;
                        break;
                    case RG8 :
                        rState = (ch == 0x00) ? RG9 : READ_GOOD_CONNECT_1;
                        break;
                    case RG9 :
                        rState = (ch == 0x4b) ? RG10 : READ_GOOD_CONNECT_1;
                        break;
                    case RG10:
                        rState = (ch == 0x79) ? RG11 : READ_GOOD_CONNECT_1;
                        break;
                    case RG11:
                        rState = (ch == 0x72) ? RG12 : READ_GOOD_CONNECT_1;
                        break;
                    case RG12:
                        rState = (ch == 0x61) ? RG13 : READ_GOOD_CONNECT_1;
                        break;
                    case RG13:
                        rState = (ch == 0x48) ? RG14 : READ_GOOD_CONNECT_1;
                        break;
                    case RG14:
                        rState = (ch == 0x61) ? RG15 : READ_GOOD_CONNECT_1;
                        break;
                    case RG15:
                        rState = (ch == 0x6c) ? RG16 : READ_GOOD_CONNECT_1;
                        break;
                    case RG16:
                        rState = (ch == 0x6c) ? READ_HDR : READ_GOOD_CONNECT_1;
                        break;
                    default:
                        rState = READ_GOOD_CONNECT_1;
                    }

                    ResetEvent(g_hReadEvent);
                    if (rState == READ_HDR)
                    {
                        SPMSG_CONNECT *pConnect;
                        pConnect = (SPMSG_CONNECT *) &msg_Building;

                        pConnect->dpHdr.to       = 0;
                        pConnect->dpHdr.from     = 0;
                        pConnect->dpHdr.usCount  = sizeof(SPMSG_CONNECT) - sizeof(DPHDR);
                        pConnect->dpHdr.usCookie = SPSYS_CONNECT;
                        pConnect->usVerMajor     = DPVERSION_MAJOR;
                        pConnect->usVerMinor     = DPVERSION_MINOR;
                        pConnect->dwConnect1     = DPSYS_KYRA;
                        pConnect->dwConnect2     = DPSYS_HALL;

                        g_IDP->HandleMessage((LPVOID) &msg_Building, sizeof(SPMSG_CONNECT));
                        dwCount = sizeof(READ_HDR);
                        dwReadCountExpected = dwCount;

                        TSHELL_INFO(TEXT("Sweet recovery, I hope."));
                        DBG_INFO(( DBGARG, TEXT("Garbage process %d ticks"),
                            GetTickCount() - dwTimeBegin));
                    }
                    ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                }
            else
                {
                    char    ch = *((CHAR *) (&msg_Building.dpHdr));
                    BOOL    bSuccess = FALSE;

                    DBG_INFO((DBGARG, TEXT("Recover state loop. %x"), 0x000000ff & ch));

                    switch (ch)
                    {
                    case 'K':
                        if (rState == READ_RECOVER_K)
                            rState = READ_RECOVER_y;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'y':
                        if (rState == READ_RECOVER_y)
                            rState = READ_RECOVER_r;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'r':
                        if (rState == READ_RECOVER_r)
                            rState = READ_RECOVER_a;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'a':
                        if (rState == READ_RECOVER_a)
                            rState = READ_RECOVER_H;
                        else if (rState == READ_RECOVER_a2)
                            rState = READ_RECOVER_l1;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'H':
                        if (rState == READ_RECOVER_H)
                            rState = READ_RECOVER_a2;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'l':
                        if (rState == READ_RECOVER_l1)
                            rState = READ_RECOVER_l2;
                        else if (rState == READ_RECOVER_l2)
                        {
                            SPMSG_CONNECT *pMsg;

                            pMsg = (SPMSG_CONNECT *) LocalAlloc(LMEM_FIXED, sizeof(SPMSG_CONNECT));

                            if (pMsg)
                            {
                                pMsg->dpHdr.to       = 0;
                                pMsg->dpHdr.from     = 0;
                                pMsg->dpHdr.usCount  = sizeof(SPMSG_CONNECT) - sizeof(DPHDR);
                                pMsg->dpHdr.usCookie = SPSYS_CONNECT;
                                pMsg->usVerMajor     = DPVERSION_MAJOR;
                                pMsg->usVerMinor     = DPVERSION_MINOR;
                                pMsg->dwConnect1     = DPSYS_KYRA;
                                pMsg->dwConnect2     = DPSYS_HALL;
                                WriteCommString(pMsg, sizeof(SPMSG_CONNECT));
                                bSuccess = TRUE;
                                g_bRecovery = FALSE;
                            }
                            else
                            {
                                PostHangupCall();
                                return(0);
                            }
                        }
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'J':
                        if (rState == READ_RECOVER_J)
                            rState = READ_RECOVER_o;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'o':
                        if (rState == READ_RECOVER_o)
                            rState = READ_RECOVER_h;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'h':
                        if (rState == READ_RECOVER_h)
                            rState = READ_RECOVER_n;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    case 'n':
                        if (rState == READ_RECOVER_n)
                            bSuccess = TRUE;
                        else
                            rState = READ_RECOVER_K;
                        break;

                    default:
                        rState = READ_RECOVER_K;
                        break;
                    }
                    if (bSuccess)
                    {
                        rState = READ_HDR;
                        dwCount = sizeof(DPHDR);
                    }
                    else
                    {
                        dwCount = 1;
                    }

                    dwReadCountExpected = dwCount;
                    ResetEvent(g_hReadEvent);
                    ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                }
        }
        else
        {
            DPHDR   *pRecover;

            if (g_bIgnoreReads)
            {
                TSHELL_INFO(TEXT("Ignore extraneous reads before we send something."));
                dwBadBegin++;
                if (dwBadBegin % 10)
                {
                    TSHELL_INFO(TEXT("Bad Byte again."));
                }

                dwCount = sizeof(DPHDR);
                dwReadCountExpected = dwCount;
                ResetEvent(g_hReadEvent);
                ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                break;
            }

            if (bFirst)
            {
                TSHELL_INFO(TEXT("Got bad data before we read anything.  Look for Good Connect."));
                PurgeComm(g_hCommFile, PURGE_RXCLEAR);
                rState = READ_GOOD_CONNECT_1;
                dwTimeBegin = GetTickCount();
                dwCount = 1;
                dwReadCountExpected = dwCount;
                ResetEvent(g_hReadEvent);
                ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
                break;
            }


            TSHELL_INFO(TEXT("Recover from bad read count."));
            DBG_INFO((DBGARG, TEXT("Bad Packet Begins %8x, Read %d Expected %d State %d"),
                &msg_Building, dwCount, dwReadCountExpected, rState));

            DBG_INFO((DBGARG, TEXT("Read Bad Hdr to(%d) from(%d) count (%d) cookie(%d) All(%8x)"),
                    msg_Building.dpHdr.to,
                    msg_Building.dpHdr.from,
                    msg_Building.dpHdr.usCount,
                    msg_Building.dpHdr.usCookie,
                    msg_Building.dpHdr.dwConnect1));

            pRecover = (DPHDR *) LocalAlloc(LMEM_FIXED, sizeof(DPHDR));

            if (pRecover)
            {
                g_bRecovery = TRUE;
                pRecover->dwConnect1 = DPSYS_JOHN;

                DBG_INFO((DBGARG, TEXT("Send John 1 %8x"), pRecover));

                WriteCommString(pRecover, sizeof(DPHDR));
                PurgeComm(g_hCommFile, PURGE_RXCLEAR);
                rState = READ_RECOVER_K;
                dwCount = 1;
                dwReadCountExpected = dwCount;
                ResetEvent(g_hReadEvent);
                ReadFile(g_hCommFile, &msg_Building.dpHdr, dwCount, &dwCount, &overlappedRead);
            }
            else
            {
                PostHangupCall();
                return(0);
            }
        }
        }
            break;

        case WAIT_OBJECT_3:     // Write Buffer 1 completion.
        {
            // TSHELL_INFO(TEXT("Write Buffer1 received."));
            if (writewait[0].bValid == TRUE)
            {
                GetOverlappedResult(g_hCommFile, &overlappedWrite0, &dwCount, FALSE);
                if (writewait[0].dwSize == dwCount)
                {
                    //
                    // Success.
                    //
                    writewait[0].bValid = FALSE;
                    DBG_INFO((DBGARG, TEXT("Free 0 %8x"), writewait[0].lpv));

                    LocalFree((HLOCAL) writewait[0].lpv);
                    if (wState == TWO_PENDING)
                    {
                        wState = ONE_PENDING;
                    }
                    else if (wState == ONE_PENDING)
                    {
                        wState = ZERO_PENDING;
                    }
                    //
                    // state of zero pending would be a fatal error.  BUGBUG;
                    //
                }
                else
                {
                    writewait[0].bValid = FALSE;
                    writewait[0].bValid = FALSE;

                    DBG_INFO((DBGARG, TEXT("Free Err 0 %8x"), writewait[0].lpv));

                    LocalFree((HLOCAL) writewait[0].lpv);
                    if (wState == TWO_PENDING)
                    {
                        wState = ONE_PENDING;
                    }
                    else if (wState == ONE_PENDING)
                    {
                        wState = ZERO_PENDING;
                    }
                    DBG_INFO((DBGARG, TEXT("Write Error Tried %d Wrote %d"),
                        writewait[0].dwSize, dwCount));
                }
            }
            //
            // if bValid not TRUE error.  BUGBUG.
            //
            ResetEvent(g_hWriteEvent0);
        }
            break;

        case WAIT_OBJECT_4:     // Write Buffer 2 completion.
        {
            // TSHELL_INFO(TEXT("Write Buffer2 received."));
            if (writewait[1].bValid == TRUE)
            {
                GetOverlappedResult(g_hCommFile, &overlappedWrite1, &dwCount, FALSE);
                if (writewait[1].dwSize == dwCount)
                {
                    //
                    // Success.
                    //
                    writewait[1].bValid = FALSE;

                    DBG_INFO((DBGARG, TEXT("Free 1 %8x"), writewait[1].lpv));

                    LocalFree((HLOCAL) writewait[1].lpv);
                    if (wState == TWO_PENDING)
                    {
                        wState = ONE_PENDING;
                    }
                    else if (wState == ONE_PENDING)
                    {
                        wState = ZERO_PENDING;
                    }
                    //
                    // state of zero pending would be a fatal error.  BUGBUG;
                    //
                }
                else
                {
                    writewait[1].bValid = FALSE;

                    DBG_INFO((DBGARG, TEXT("Free Err 1 %8x"), writewait[1].lpv));

                    LocalFree((HLOCAL) writewait[1].lpv);
                    if (wState == TWO_PENDING)
                    {
                        wState = ONE_PENDING;
                    }
                    else if (wState == ONE_PENDING)
                    {
                        wState = ZERO_PENDING;
                    }
                    DBG_INFO((DBGARG, TEXT("Write Error Tried %d Wrote %d"),
                        writewait[0].dwSize, dwCount));
                }
            }
            //
            // if bValid not TRUE error.  BUGBUG.
            //
            ResetEvent(g_hWriteEvent1);
        }
            break;

        case WAIT_OBJECT_5:     // More Write Requests.
            //
            // It turns out that out MsgWait function won't return
            // if we have a current message in the loop, only if
            // we get a new one.
            //
            // That has to be wrong, since we have a window
            // of opportunity after we do our peek's manually and
            // before we do a MsgWait().
            //
            break;
        }

        //
        // Remember that loop conditional doesn't execute PeekMessage()
        // if the state is already TWO_PENDING.  Don't change it or
        // you'll lose a message.
        //
        while (wState != TWO_PENDING && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
        {
            if (msg.hwnd != NULL || msg.message != PWM_COMMWRITE)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                if (g_IDP)
                    InterlockedDecrement((LPLONG) &g_IDP->m_dwPendingWrites);

                DBG_INFO((DBGARG, TEXT("Write Hdr to(%d) from(%d) count (%d) cookie(%d): %8x %d"),
                        ((DPHDR *)msg.lParam)->to,
                        ((DPHDR *)msg.lParam)->from,
                        ((DPHDR *)msg.lParam)->usCount,
                        ((DPHDR *)msg.lParam)->usCookie,
                        ((DPHDR *)msg.lParam)->dwConnect1,
                        rState));


                if (writewait[0].bValid == FALSE)
                {
                    writewait[0].bValid = TRUE;
                    writewait[0].lpv    = (LPVOID) msg.lParam;

                    DBG_INFO((DBGARG, TEXT("Set 0 %8x"), writewait[0].lpv));

                    writewait[0].dwSize = (DWORD)msg.wParam;
                    WriteFile( g_hCommFile, (LPVOID) msg.lParam, (DWORD)msg.wParam,
                            &dwCount, &overlappedWrite0);
                }
                else
                {
                    writewait[1].bValid = TRUE;
                    writewait[1].lpv    = (LPVOID) msg.lParam;

                    DBG_INFO((DBGARG, TEXT("Set 1 %8x"), writewait[1].lpv));

                    writewait[1].dwSize = (DWORD)msg.wParam;
                    WriteFile( g_hCommFile, (LPVOID) msg.lParam, (DWORD)msg.wParam,
                            &dwCount, &overlappedWrite1);
                }
            }
            if (wState == ZERO_PENDING)
            {
                wState = ONE_PENDING;
            }
            else if (wState == ONE_PENDING)
            {
                wState = TWO_PENDING;
            }
            //
            // BUGBUG state two_pending is illegal.
            //
        }
    }



    return 0;
}


//  FUNCTION: SetupCommEvent(LPOVERLAPPED, LPDWORD)
//
//  PURPOSE: Sets up the overlapped WaitCommEvent call.
//
//  PARAMETERS:
//    lpOverlappedCommEvent - Pointer to the overlapped structure to use.
//    lpfdwEvtMask          - Pointer to DWORD to received Event data.
//
//  RETURN VALUE:
//    TRUE if able to successfully setup the WaitCommEvent.
//    FALSE if unable to setup WaitCommEvent, unable to handle
//    an existing outstanding event or if the CloseEvent has been signaled.
//
//  COMMENTS:
//
//    This function is a helper function for the Read Thread that sets up
//    the WaitCommEvent so we can deal with comm events (like Comm errors)
//    if they occur.
//
//

BOOL SetupCommEvent(LPOVERLAPPED lpOverlappedCommEvent,
    LPDWORD lpfdwEvtMask)
{
    DWORD dwLastError;

  StartSetupCommEvent:

    // Make sure the CloseEvent hasn't been signaled yet.
    // Check is needed because this function is potentially recursive.
    if (WAIT_TIMEOUT != WaitForSingleObject(g_hCloseEvent,0))
        return FALSE;

    // Start waiting for Comm Errors.
    if (WaitCommEvent(g_hCommFile, lpfdwEvtMask, lpOverlappedCommEvent))
    {
        // This could happen if there was an error waiting on the
        // comm port.  Lets try and handle it.

        TSHELL_INFO(TEXT("Event (Error) waiting before WaitCommEvent."));

        if (!HandleCommEvent(NULL, lpfdwEvtMask, FALSE))
            return FALSE;

        // What could cause infinite recursion at this point?
        goto StartSetupCommEvent;
    }

    // We expect ERROR_IO_PENDING returned from WaitCommEvent
    // because we are waiting with an overlapped structure.

    dwLastError = GetLastError();

    // LastError was ERROR_IO_PENDING, as expected.
    if (dwLastError == ERROR_IO_PENDING)
    {
        TSHELL_INFO(TEXT("Waiting for a CommEvent (Error) to occur."));
        return TRUE;
    }

    // Its possible for this error to occur if the
    // service provider has closed the port.  Time to end.
    if (dwLastError == ERROR_INVALID_HANDLE)
    {
        TSHELL_INFO(TEXT("ERROR_INVALID_HANDLE, Likely that the Service Provider has closed the port."));
        return FALSE;
    }

    // Unexpected error. No idea what could cause this to happen.
    TSHELL_INFO(TEXT("Unexpected WaitCommEvent error: "));
    return FALSE;
}


//
//  FUNCTION: HandleCommEvent(LPOVERLAPPED, LPDWORD, BOOL)
//
//  PURPOSE: Handle an outstanding Comm Event.
//
//  PARAMETERS:
//    lpOverlappedCommEvent - Pointer to the overlapped structure to use.
//    lpfdwEvtMask          - Pointer to DWORD to received Event data.
//     fRetrieveEvent       - Flag to signal if the event needs to be
//                            retrieved, or has already been retrieved.
//
//  RETURN VALUE:
//    TRUE if able to handle a Comm Event.
//    FALSE if unable to setup WaitCommEvent, unable to handle
//    an existing outstanding event or if the CloseEvent has been signaled.
//
//  COMMENTS:
//
//    This function is a helper function for the Read Thread that (if
//    fRetrieveEvent == TRUE) retrieves an outstanding CommEvent and
//    deals with it.  The only event that should occur is an EV_ERR event,
//    signalling that there has been an error on the comm port.
//
//    Normally, comm errors would not be put into the normal data stream
//    as this sample is demonstrating.  Putting it in a status bar would
//    be more appropriate for a real application.
//
//

BOOL HandleCommEvent(LPOVERLAPPED lpOverlappedCommEvent,
    LPDWORD lpfdwEvtMask, BOOL fRetrieveEvent)
{
    DWORD dwDummy;
    LPSTR lpszOutput;
    char szError[128] = "";
    DWORD dwErrors;
    DWORD dwLastError;


    lpszOutput = (char *) LocalAlloc(LPTR,256);
    if (lpszOutput == NULL)
    {
        DBG_INFO((DBGARG, TEXT("LocalAlloc: %d"), GetLastError()));
        return FALSE;
    }

    // If this fails, it could be because the file was closed (and I/O is
    // finished) or because the overlapped I/O is still in progress.  In
    // either case (or any others) its a bug and return FALSE.
    if (fRetrieveEvent)
        if (!GetOverlappedResult(g_hCommFile,
                lpOverlappedCommEvent, &dwDummy, FALSE))
        {
            dwLastError = GetLastError();

            // Its possible for this error to occur if the
            // service provider has closed the port.  Time to end.
            if (dwLastError == ERROR_INVALID_HANDLE)
            {
                TSHELL_INFO(TEXT("ERROR_INVALID_HANDLE, Likely that the Service Provider has closed the port."));
                return FALSE;
            }

            DBG_INFO((DBGARG, TEXT("Unexpected GetOverlappedResult for WaitCommEvent: %x"),
                dwLastError));
            return FALSE;
        }

    // Was the event an error?
    if (*lpfdwEvtMask & EV_ERR)
    {
        // Which error was it?
        if (!ClearCommError(g_hCommFile, &dwErrors, NULL))
        {
            dwLastError = GetLastError();

            // Its possible for this error to occur if the
            // service provider has closed the port.  Time to end.
            if (dwLastError == ERROR_INVALID_HANDLE)
            {
                TSHELL_INFO(TEXT("ERROR_INVALID_HANDLE, Likely that the Service Provider has closed the port."));
                return FALSE;
            }

            DBG_INFO((DBGARG, TEXT("ClearCommError: %x"), GetLastError()));
            return FALSE;
        }

        // Its possible that multiple errors occured and were handled
        // in the last ClearCommError.  Because all errors were signaled
        // individually, but cleared all at once, pending comm events
        // can yield EV_ERR while dwErrors equals 0.  Ignore this event.
        if (dwErrors == 0)
        {
            lstrcat(szError, TEXT("NULL Error"));
        }

        if (dwErrors & CE_FRAME)
        {
            if (szError[0])
                lstrcat(szError,TEXT(" and "));

            lstrcat(szError,TEXT("CE_FRAME"));
        }

        if (dwErrors & CE_OVERRUN)
        {
            if (szError[0])
                lstrcat(szError,TEXT(" and "));

            lstrcat(szError,TEXT("CE_OVERRUN"));
        }

        if (dwErrors & CE_RXPARITY)
        {
            if (szError[0])
                lstrcat(szError,TEXT(" and "));

            lstrcat(szError,TEXT("CE_RXPARITY"));
        }

        if (dwErrors & ~ (CE_FRAME | CE_OVERRUN | CE_RXPARITY))
        {
            if (szError[0])
                lstrcat(szError,TEXT(" and "));

            lstrcat(szError,TEXT("EV_ERR Unknown EvtMask"));
        }


        DBG_INFO((DBGARG, TEXT("Comm Event: '%s', EvtMask = '%lx' %s %d"),
            szError, dwErrors));

        return TRUE;

    }

    // Should not have gotten here.  Only interested in ERR conditions.

    DBG_INFO((DBGARG, TEXT("Unexpected comm event %lx"),*lpfdwEvtMask));
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\dpspimp.h ===
// Direct Play object class implementation

#ifndef _DP_SPIMP_H
#define _DP_SPIMP_H

#include "..\dplay\dplayi.h"

// Begin: declaration of main implementation class for IDirectPlay


#define MAX_MSG      (512 + sizeof(DPHDR))
#define MAX_PLAYERS  16
#define MAXIMUM_PLAYER_ID   256

typedef struct
{
    DPID    pid;
    char    chNickName[DPSHORTNAMELEN];
    char    chFullName[DPLONGNAMELEN ];
    HANDLE  hEvent;
    BOOL    bPlayer;
    BOOL    bValid;
    BOOL    bLocal;
    DPID    aGroup[MAX_PLAYERS];
} PLAYER_RECORD;


class CImpIDP_SP : public IDirectPlaySP {
public:
    // IUnknown methods
    // IDirectPlay methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID iid, LPVOID *ppvObj );
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
    virtual ULONG STDMETHODCALLTYPE Release( void );

    virtual HRESULT STDMETHODCALLTYPE AddPlayerToGroup(
                                            DPID dwDPIDGroup,
                                            DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE Close(DWORD);
    virtual HRESULT STDMETHODCALLTYPE CreatePlayer(
                                        LPDPID pPlayerID,
                                        LPSTR pNickName,
                                        LPSTR pFullName,
                                        LPHANDLE lpReceiveEvent,
                                        BOOL     bPlayer);

    virtual HRESULT STDMETHODCALLTYPE   DeletePlayerFromGroup(
                                        DPID DPid,
                                        DPID dwDPIDPlayer);
    virtual HRESULT STDMETHODCALLTYPE DestroyPlayer( DPID pPlayerID, BOOL );
    virtual HRESULT STDMETHODCALLTYPE EnumGroupPlayers(
                                      DPID dwGroupPid,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumPlayers(
                                      DWORD dwSessionID,
                                      LPDPENUMPLAYERSCALLBACK EnumCallback,
                                      LPVOID pContext,
                                      DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE EnumSessions(
                                       LPDPSESSIONDESC,
                                       DWORD dwTimeout,
                                       LPDPENUMSESSIONSCALLBACK EnumCallback,
                                       LPVOID,
                                       DWORD);

    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetMessageCount(DPID pidPlayer, LPDWORD lpdwCount);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerCaps(
                                        DPID dwDPId,
                                        LPDPCAPS lpDPCaps);
    virtual HRESULT STDMETHODCALLTYPE GetPlayerName(DPID dpID,
                          LPSTR lpFriendlyName,          // buffer to hold name
                          LPDWORD pdwFriendlyNameLength, // length of name buffer
                          LPSTR lpFormalName,
                          LPDWORD pdwFormalNameLength
                          );


    virtual HRESULT STDMETHODCALLTYPE Initialize(LPGUID);
    virtual HRESULT STDMETHODCALLTYPE Open(
                        LPDPSESSIONDESC lpSDesc, HANDLE hEvent);

    virtual HRESULT STDMETHODCALLTYPE Receive(
                                LPDPID from,
                                LPDPID to,
                                DWORD  dwReceiveFlags,
                                LPVOID,
                                LPDWORD);


    virtual HRESULT STDMETHODCALLTYPE SaveSession(LPVOID lpv, LPDWORD lpdw);

    virtual HRESULT STDMETHODCALLTYPE SetPrevPlayer(LPSTR lpName, LPVOID lpv, DWORD dw);

    virtual HRESULT STDMETHODCALLTYPE SetPrevSession(LPSTR lpName, LPVOID lpv, DWORD dw);

    virtual HRESULT STDMETHODCALLTYPE EnableNewPlayers(BOOL bEnable);

    virtual HRESULT STDMETHODCALLTYPE Send(
                                DPID from,
                                DPID to,
                                DWORD dwFlags,
                                LPVOID lpvMsg,
                                DWORD dwLength);
    virtual HRESULT STDMETHODCALLTYPE SetPlayerName(
                                DPID from,
                                LPSTR lpFriendlyName,          
                                LPSTR lpFormalName,
                                BOOL  bPlayer);



   static CImpIDP_SP* NewCImpIDP_SP();

    VOID HandleConnect();
    VOID HandleMessage(LPVOID lpv, DWORD dwSize);
    VOID PulseBlock() {PulseEvent(m_hBlockingEvent);}
    VOID SetBlock() {SetEvent(m_hBlockingEvent);}
    VOID SendDesc(LPDPSESSIONDESC);
    VOID SendPing();
    VOID PostHangup();
    VOID ISend(LONG, LONG, DWORD, LPVOID, DWORD);
    VOID LocalMsg(LONG, LPVOID, DWORD);
    VOID RemoteMsg(LONG, LPVOID, DWORD);
    LONG FindInvalidIndex();
    VOID ConnectPlayers();
    VOID DeleteRemotePlayers();
    VOID ResetSessionDesc() {memset(&m_dpDesc, 0x00, sizeof(DPSESSIONDESC));}
    volatile BOOL             m_bConnected;
    BOOL             m_bPlayer0;            // If I created the call, I am player
                                            // zero.
    volatile DWORD            m_dwPendingWrites;

   void *operator new( size_t size );
   void operator delete( void *ptr );


protected:
    void Lock();
    void Unlock();

private:
    LONG GetPlayerIndex(DPID);
    BOOL SetSession(DWORD dw);
    CImpIDP_SP(void);
   ~CImpIDP_SP(void);

    DWORD            m_dwPingSent;
    HANDLE           m_hBlockingEvent;
    DWORD            m_dwNextPlayer;
    BOOL             m_bEnablePlayerAdd;

    PLAYER_RECORD    m_aPlayer[MAX_PLAYERS];
    char             m_lpDisplay[128];
    char             m_lpDialable[128];
    DWORD            m_dwID;
    LONG             m_iPlayerIndex;
    DPSESSIONDESC    m_dpDesc;

    int              m_refCount;
    CRITICAL_SECTION m_critSection;
    DPCAPS           m_dpcaps;

    HANDLE           m_hNewPlayerEvent;

    HANDLE           m_hTapiThread;
    DWORD            m_dwTapiThreadID;
    char           **m_ppSessionArray;
    DWORD            m_dwSessionPrev;
    DWORD            m_dwSessionAlloc;
};


BOOL SetIDP_SP( CImpIDP_SP *pSP);


// End  : declaration of main implementation class for IDirectPlay


/****************************************************************************
 *
 * DIRECTPLAY MESSAGES
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/






// #define DPSYS_ENUM                    0x6172  // '4b797261' == 'Kyra' Born 10/21/94
// #define DPSYS_KYRA                    0x6172794b
// #define DPSYS_HALL                    0x6c6c6148
#define SPSYS_SYS                     0x07
#define SPSYS_USER                    0x0b
#define SPSYS_HIGH                    0x0d
#define SPSYS_CONNECT                 0x0f
// #define SYS_MSG     0x8000

typedef struct
{
    union
    {
        DWORD dwConnect1;  
        struct
        {
            UINT    to          :  8;
            UINT    from        :  8;
            UINT    usCount     : 10;
            UINT    usCookie    :  6;
        };
    };
}   DPHDR;

#if 0
typedef struct
{
    union
    {
        DWORD dwConnect1;
        struct
        {
            USHORT  usCookie;
            BYTE    to;
            BYTE    from;
        };
    };
    union
    {
        DWORD dwConnect2;
        struct
        {
            USHORT  usCount;
            BYTE    bHdrCRC;
            BYTE    bMsgCRC;
        };
    };
} DPHDR;
#endif


typedef struct
{
    DPHDR dpHdr;
    char chMsgCompose[1000];
} MSG_BUILDER;

#define SP_ENUM_COOKIE     0x794b

typedef struct
{
    DPHDR   dpHdr;
    USHORT  usVerMajor;
    USHORT  usVerMinor;
    DWORD   dwConnect1;
    DWORD   dwConnect2;
} SPMSG_CONNECT;

typedef struct
{
    DPHDR           dpHdr;
    DPMSG_GENERIC   sMsg;
} SPMSG_GENERIC;

typedef struct
{
    DPHDR   dpHdr;
    DWORD   dwType;
    BYTE    Group;
    BYTE    bytePlayers[16];
} SPMSG_SETGROUPPLAYERS16;    


#define SIZE_GENERIC (sizeof(SPMSG_GENERIC) - sizeof(DPHDR))
typedef struct
{
    DPHDR           dpHdr;
    DWORD          dwType;
    DPSESSIONDESC   dpSessionDesc;
} SPMSG_ENUM;

#define DPSYS_ENUM_REPLY     0x0002

typedef struct
{
    DPHDR           dpHdr;
    DWORD          dwType;
    DWORD          usPort;
} SPMSG_ENUM_REPLY;


typedef struct
{
    DWORD  dwType;
    DPID    dpId;
} DPMSG_GETPLAYER;

typedef struct
{
    DPHDR           dpHdr;
    DPMSG_GETPLAYER sMsg;
} SPMSG_GETPLAYER;
#define SIZE_GETPLAYER  (sizeof(SPMSG_GETPLAYER) - sizeof(DPHDR))


typedef struct
{
    DPHDR           dpHdr;
    DPMSG_ADDPLAYER sMsg;
} SPMSG_ADDPLAYER;


#define SIZE_ADDPLAYER (sizeof(SPMSG_ADDPLAYER) - sizeof(DPHDR))


typedef struct
{
    DPHDR   dpHdr;
    DPMSG_GROUPADD sMsg;
} SPMSG_GROUPADD;

typedef struct
{
    DPHDR   dpHdr;
    DWORD  dwType;
    DWORD   dwTicks;
} SPMSG_PING;

#define SIZE_PING (sizeof(SPMSG_PING) - sizeof(DPHDR))



typedef struct
{
    DPHDR   dpHdr;
    DWORD          dwType;
    GUID    guid;
} SPMSG_INVITE;



typedef struct
{
    DPHDR       dpHdr;
    DWORD       dwType;
    DPCAPS      dpCaps;
} SPMSG_GETPLAYERCAPS;

#define SIZE_GETPLAYERCAPS (sizeof(SPMSG_GETPLAYERCAPS) - sizeof(DPHDR))

typedef struct
{
    DPHDR           dpHdr;
    DWORD           dwType;
    DPSESSIONDESC   dpDesc;
} SPMSG_SENDDESC;

#define SIZE_SENDDESC (sizeof(SPMSG_SENDDESC) - sizeof(DPHDR))

typedef struct
{
    DWORD       dwType;
    BOOL        bEnable;
} DPMSG_ENABLEPLAYER;
typedef struct
{
    DPHDR               dpHdr;
    DPMSG_ENABLEPLAYER  sMsg;
} SPMSG_ENABLEPLAYER;

extern BOOL AddMessage(LPVOID lpvMsg, DWORD dwSize, DPID pidTo, DPID pidFrom, BOOL bHigh);
extern HRESULT GetQMessage(LPVOID lpvMsg, LPDWORD pdwSize, DPID *ppidTo, DPID *ppidFrom,
                DWORD dwFlags, BOOL bPeek);
extern VOID  FlushQueue(DPID pid);
extern DWORD GetPlayerCount(DPID spid);

#define DPSYS_JOHN    0x6e686f4a


// Enumeration Messages

//
// Thread Messages
//
#define PWM_BASE        0x00007000
#define PWM_COMMWRITE   PWM_BASE    +1
#define PWM_SETIDP      PWM_BASE    +2
#define PWM_HANGUP      PWM_BASE    +3
#define PWM_CLOSE       PWM_BASE    +4




#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\dpspimp.cpp ===
// =================================================================
//
//  Direct Play Network Methods
//
//  Functions to manage communications over a network.
//
//
// =================================================================
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <winsock.h>
#ifndef _MT
#define _MT
#endif
#include <process.h>
#include <string.h>

#include "dpspimp.h"
#include "logit.h"

#include "tapicode.h"
#include "commcode.h"
#include "resource.h"

extern volatile BOOL g_bIgnoreReads;
extern volatile BOOL g_bRecovery;
extern volatile BOOL g_bCommStarted;

extern "C" HINSTANCE hInst;
extern volatile DWORD g_dwRate;
extern BOOL  g_bCallCancel;


#define malloc(a)  LocalAlloc(LMEM_FIXED, (a))
#define free(a)      LocalFree((HLOCAL)(a))


CImpIDP_SP *pDirectPlayObject = NULL; // We only allow one object
                                             // to be created currently - see below.


HANDLE hOnlyOneAllowed = NULL;

extern CImpIDP_SP *g_IDP;

extern BOOL CreateQueue(DWORD dwElements, DWORD dwMaxMsg, DWORD dwMaxPlayers);
extern BOOL DeleteQueue();

GUID DPLAY_MODEM = { /* 8cab4652-b1b6-11ce-920c-00aa006c4972 */
    0x8cab4652,
    0xb1b6,
    0x11ce,
    {0x92, 0x0c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72}
  };


BOOL g_bPostHangup = FALSE;
DWORD WINAPI StartTapiThreadProc(LPVOID lpvParam)
{
    HANDLE hEvent = (LPHANDLE) lpvParam;
    MSG    msg;
    CImpIDP_SP *pIDP = NULL;
    BOOL   bShutdown = FALSE;

    if (hEvent == NULL)
        return(0);

    if (! InitializeTAPI(NULL))
        return(NULL);

    SetEvent(hEvent);
    while(!bShutdown && GetMessage(&msg, NULL, 0, 0) )
    {
        switch (msg.message)
        {
        case PWM_SETIDP:
            pIDP = (CImpIDP_SP *) msg.wParam;
            break;

        case PWM_CLOSE:
            TSHELL_INFO(TEXT("Close requested."));
            bShutdown = TRUE;
            break;

        case PWM_HANGUP:
            TSHELL_INFO(TEXT("Hangup Requested"));
            pIDP->m_bConnected = FALSE;
            pIDP->m_bPlayer0 = FALSE;
            g_bIgnoreReads = FALSE;
            pIDP->DeleteRemotePlayers();
            pIDP->ResetSessionDesc();

            if (!HangupCallI())
            {
                TSHELL_INFO(TEXT("HangupCall failed."));
                bShutdown = TRUE;
            }
            g_bPostHangup = FALSE;
            TSHELL_INFO(TEXT("Hangup Finished."));
            break;

        default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            break;
        }
    }
    TSHELL_INFO( TEXT("Exit StartThreadTapi Loop. "));
    ShutdownTAPI();
    TSHELL_INFO(TEXT("StartThreadTapi exits."));
    return(0);

}

//
//  FUNCTION: PostHangupCall()
//
//  PURPOSE: Posts a message to the main TAPI thread to hangup the call.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    TAPI is thread specific, meaning that only the thread that does the
//    lineInitialize can get asynchronous messages through the callback.
//    Since the HangupCall can potentially go into a loop waiting for
//    specific events, any other threads that call HangupCall can cause
//    timing confusion.  Best to just have other threads 'ask' the main thread
//    to hangup the call.
//

void PostHangupCall()
{

    if (g_IDP)
        g_IDP->PostHangup();
    else
        HangupCall(__LINE__);
}

HRESULT CImpIDP_SP::Initialize(LPGUID lpiid)
{
    TSHELL_INFO(TEXT("Already Initialized."));
    return(DPERR_ALREADYINITIALIZED);
}

void *CImpIDP_SP::operator new( size_t size )
{
    return(LocalAlloc(LMEM_FIXED, size));
}
void CImpIDP_SP::operator delete( void *ptr )
{
    LocalFree((HLOCAL)ptr);
}




VOID CImpIDP_SP::PostHangup()
{
    g_bPostHangup = TRUE;
    if (m_dwTapiThreadID)
        PostThreadMessage( m_dwTapiThreadID, PWM_HANGUP, 0, 0);

}
CImpIDP_SP *CImpIDP_SP::NewCImpIDP_SP()
{
    CImpIDP_SP *pImp    = NULL;
    HANDLE hEvent       = NULL;
    HANDLE hTapiThread  = NULL;
    DWORD  dwTapiThreadID;
    DWORD  dwRet1;
    DWORD  dwRet2;

    g_bIgnoreReads = FALSE;

    if (g_IDP)
        return(NULL);

    if (!CreateQueue(64, MAX_MSG, MAX_PLAYERS))
    {
        TSHELL_INFO(TEXT("Couldn't initialize queue."));
        return(NULL);
    }

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!hEvent)
        return(NULL);

    pImp = new CImpIDP_SP;

    if (!pImp)
        return(NULL);

    hTapiThread = CreateThread(NULL, 0, StartTapiThreadProc,
                        (LPVOID) hEvent, 0, &dwTapiThreadID);

    if (!hTapiThread)
    {
        delete pImp;
        return(NULL);
    }

    dwRet1 = WaitForSingleObject(hEvent, 10000);

    CloseHandle(hEvent);

    dwRet2 = WaitForSingleObject(hTapiThread, 0);

    if (dwRet1 == WAIT_TIMEOUT || dwRet2 != WAIT_TIMEOUT)
    {
        if (dwRet2 == WAIT_TIMEOUT)
        {
            TerminateThread(hTapiThread, 0);
            Sleep(200);
        }
        CloseHandle(hTapiThread);
        delete pImp;
        return(NULL);
    }


    PostThreadMessage( dwTapiThreadID, PWM_SETIDP, (WPARAM) pImp, 0);
    pImp->m_dpcaps.dwMaxBufferSize = 512;
    pImp->m_hTapiThread = hTapiThread;
    pImp->m_dwTapiThreadID = dwTapiThreadID;
    g_IDP = pImp;




    return(pImp);
}


// ----------------------------------------------------------
// CreateNewDirectPlay - DCO object creation entry point
// called by the DCO interface functions to create a new
// DCO object.
// ----------------------------------------------------------
IDirectPlaySP * _cdecl CreateNewDirectPlay( LPGUID lpGuid )
{
    //
    // One object at a time, please.
    //
    if (pDirectPlayObject != NULL || hOnlyOneAllowed != NULL)
        return(NULL);

    hOnlyOneAllowed = CreateEvent(NULL, TRUE, TRUE, "DPSERIAL_UNIQUE");
    if (hOnlyOneAllowed == NULL)
        return(NULL);
    else
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
            TSHELL_INFO(TEXT("Someone tried to run 2 modems!"));
            CloseHandle(hOnlyOneAllowed);
            hOnlyOneAllowed = NULL;
            return(NULL);
        }
    }




    if (! IsEqualGUID((REFGUID) DPLAY_MODEM, (REFGUID) *lpGuid))
        return(NULL);

    //
    // The network service provider doesn't support more than 1
    // Guid, so we do nothing.
    //
    lpGuid;

    pDirectPlayObject = CImpIDP_SP::NewCImpIDP_SP();

    if (!pDirectPlayObject)
        return(NULL);
    else
        return(pDirectPlayObject);
}


// Begin: IUnknown interface implementation
HRESULT CImpIDP_SP::QueryInterface(
    REFIID iid,
    LPVOID *ppvObj
)
{
    HRESULT retVal = DPERR_GENERIC;

    //
    // BUGBUG
    //
    if (ppvObj && ! IsBadWritePtr(ppvObj, 4))
        {
        AddRef();
        *ppvObj = this;
        return(DP_OK);
        }
    else
        return(DPERR_INVALIDPARAM);

}

ULONG CImpIDP_SP::AddRef( void)
{
    ULONG newRefCount;

    Lock();
    m_refCount++;
    newRefCount = m_refCount;
    Unlock();

    DBG_INFO((DBGARG, TEXT("newRefCount = %lu"), newRefCount));

    return( newRefCount );
}

ULONG CImpIDP_SP::Release( void )
{
    ULONG newRefCount;
    DWORD ii;
    DWORD dwTime = 0;

#ifdef DEBUG
    DWORD dwTickCount = GetTickCount();
#endif

    Lock();
    m_refCount--;
    newRefCount = m_refCount;
    Unlock();

    if (newRefCount == 0)
        {
        Close(DPLAY_CLOSE_INTERNAL);

        if (m_dwTapiThreadID && m_hTapiThread)
        {
            while (m_hTapiThread && dwTime < 4000)
            {
                PostThreadMessage( m_dwTapiThreadID, PWM_CLOSE, 0, 0);
                if (WaitForSingleObject(m_hTapiThread, 100) == WAIT_TIMEOUT)
                {
                    dwTime += 100;
                }
                else
                {
                    CloseHandle(m_hTapiThread);
                    m_hTapiThread = NULL;
                }
            }
        }

        if (m_ppSessionArray)
        {
            for (ii = 0; ii < m_dwSessionPrev; ii++)
                free(m_ppSessionArray[ii]);
            free(m_ppSessionArray);
        }

        if (m_hTapiThread && WaitForSingleObject(m_hTapiThread, 100) == WAIT_TIMEOUT)
        {
            TSHELL_INFO(TEXT("Terminate Thread."));
            TerminateThread(m_hTapiThread, 0);
            Sleep(200);
            CloseHandle(m_hTapiThread);
        }

        DeleteCriticalSection(&m_critSection);
        DeleteQueue();
        g_IDP = NULL;

        hInst = NULL;
        pDirectPlayObject = NULL;

        DBG_INFO((DBGARG, TEXT("Total close time %d"), GetTickCount() - dwTickCount));

        delete this;
        pDirectPlayObject = NULL;
        CloseHandle(hOnlyOneAllowed);
        hOnlyOneAllowed = NULL;
        }

    DBG_INFO((DBGARG, TEXT("newRefCount = %lu"), newRefCount));

    return( newRefCount );
}

// End  : IUnknown interface implementation


// ----------------------------------------------------------
// CImpIDP_SP constructor - create a new DCO object
// along with a queue of receive buffers.
// ----------------------------------------------------------
CImpIDP_SP::CImpIDP_SP()
{
    m_bConnected             = FALSE;
    m_bPlayer0               = FALSE;
    m_dwPendingWrites        = 0;

    m_dwPingSent             = 0;
    m_hBlockingEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_dwNextPlayer           = 1;
    m_bEnablePlayerAdd       = TRUE;

    memset(&m_aPlayer[0], 0x00, sizeof(PLAYER_RECORD) * MAX_PLAYERS);
    m_lpDisplay[0]           = 0x00;
    m_lpDialable[0]          = 0x00;
    m_dwID                   = 0;
    m_iPlayerIndex           = -1;
    memset(&m_dpDesc, 0x00, sizeof(DPSESSIONDESC));

    // Initialize ref count
    m_refCount = 1;
    InitializeCriticalSection( &m_critSection );
    memset(&m_dpcaps, 0x00, sizeof(DPCAPS));
    m_dpcaps.dwSize          = sizeof(DPCAPS);
    m_dpcaps.dwFlags         = 0;
    m_dpcaps.dwMaxQueueSize  = 64;
    m_dpcaps.dwMaxPlayers    = MAX_PLAYERS;
    m_dpcaps.dwHundredBaud   = 0;

    m_hNewPlayerEvent        = NULL;
    m_hTapiThread            = NULL;
    m_dwTapiThreadID         = 0;
    m_ppSessionArray         = 0;
    m_dwSessionPrev          = 0;
    m_dwSessionAlloc         = 0;

}

// ----------------------------------------------------------
// CImpDirectPlay destructor -
// ----------------------------------------------------------
CImpIDP_SP::~CImpIDP_SP()
{
    TSHELL_INFO(TEXT("Deletion."));
}


void CImpIDP_SP::Lock( void )
{
    EnterCriticalSection( &m_critSection );
}

void CImpIDP_SP::Unlock( void )
{
    LeaveCriticalSection( &m_critSection );
}


// ----------------------------------------------------------
// GetCaps - return info about the connection media
// ----------------------------------------------------------

//
// Return our caps immediately if we have a valid latency value.
// if we haven't gotten latency yet, send a DPSYS_PING.  Latency is
// the time it takes to get a response DPSYS_PING / 2.
//
HRESULT CImpIDP_SP::GetCaps(
                            LPDPCAPS lpDPCaps // buffer to receive capabilities
                            )
{
    m_dpcaps.dwHundredBaud = g_dwRate / 100;
    *lpDPCaps = m_dpcaps;

    if (m_dpcaps.dwLatency == 0)
        SendPing();

    return(DP_OK);
}


// ----------------------------------------------------------
//    Connect - establishes communications with underlying transport,
//    and initializes name services and network entities
// ----------------------------------------------------------
BOOL    CImpIDP_SP::SetSession(DWORD dw)
{
    m_lpDisplay[0]  = 0x00;
    if (dw == 0)
    {
        m_lpDialable[0] = 0x00;
        return(TRUE);
    }
    else
    {
        dw--;
        if (dw >= m_dwSessionPrev)
            return(FALSE);
        lstrcpy( m_lpDialable, (m_ppSessionArray[dw] + sizeof(dw)));
        lstrcpy( m_lpDisplay, (m_ppSessionArray[dw] + sizeof(dw)));

        DBG_INFO((DBGARG, TEXT("Got %s for dialable string."), m_lpDialable));

        return(TRUE);
    }
}

HRESULT CImpIDP_SP::Open(
                        LPDPSESSIONDESC lpSDesc, HANDLE lpHandle
)
{
    DWORD ii;
    SPMSG_CONNECT *pMsg;

    TSHELL_INFO(TEXT("SP Open"));

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid )
        {
            TSHELL_INFO(TEXT("Illegal player found, return error."));
            return(DPERR_ACTIVEPLAYERS);
        }
    }

    if (lpSDesc->dwFlags & DPOPEN_CREATESESSION)
    {
        TSHELL_INFO(TEXT("Place machine in Recieve mode."));

        if (ReceiveCall())
        {
            m_bPlayer0 = TRUE;
            memcpy( (LPVOID) &m_dpDesc, lpSDesc, sizeof(DPSESSIONDESC));
            m_dpDesc.dwCurrentPlayers = 0;
            m_dpDesc.dwReserved1      = 0;
            m_dpDesc.dwReserved2      = 0;

            return(DP_OK);
        }
        else
            return(DPERR_GENERIC);

    }
    else if (lpSDesc->dwFlags & DPOPEN_OPENSESSION)
    {
        TSHELL_INFO(TEXT("Open a session."));
        if (!SetSession(lpSDesc->dwSession))
            return(DPERR_GENERIC);


        TSHELL_INFO(TEXT("Dial call."));

        g_bIgnoreReads = TRUE;

        ResetEvent(m_hBlockingEvent);

        if (DialCall(m_lpDisplay, m_lpDialable, &m_dwID, m_hBlockingEvent))
        {
            TSHELL_INFO(TEXT("DialCall Succeeded."));

            if (    WaitForSingleObject(m_hBlockingEvent, 60000) == WAIT_TIMEOUT
                || !g_bCommStarted)
            {
                TSHELL_INFO(TEXT("Timeout waiting for connection."));
                return(DPERR_NOCONNECTION);
            }

            TSHELL_INFO(TEXT("No messages sent yet."));
            Sleep(1000);
            g_bIgnoreReads = FALSE;
            TSHELL_INFO(TEXT("Now try and connect."));
            ResetEvent(m_hBlockingEvent);
            //
            // Send connection protocol messages.
            //
            for (ii = 0; (ii < 10)
                         && !m_bConnected
                         && !g_bRecovery
                         && g_bCommStarted; ii++)
            {
                pMsg = (SPMSG_CONNECT *) malloc(sizeof(SPMSG_CONNECT));
                pMsg->dpHdr.to       = 0;
                pMsg->dpHdr.from     = 0;
                pMsg->dpHdr.usCount  = sizeof(SPMSG_CONNECT) - sizeof(DPHDR);
                pMsg->dpHdr.usCookie = SPSYS_CONNECT;
                pMsg->usVerMajor     = DPVERSION_MAJOR;
                pMsg->usVerMinor     = DPVERSION_MINOR;
                pMsg->dwConnect1 = DPSYS_KYRA;
                pMsg->dwConnect2 = DPSYS_HALL;
                // TSHELL_INFO(TEXT("Write Connection Msg."));
                g_bIgnoreReads = FALSE;
                WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_CONNECT));
                WaitForSingleObject(m_hBlockingEvent, 6000);
                if (g_bRecovery)
                {
                    TSHELL_INFO(TEXT("Open Generated recovery problem."));
                    ResetEvent(m_hBlockingEvent);
                    WaitForSingleObject(m_hBlockingEvent, 10000);
                }
                if (g_bRecovery)
                {
                    TSHELL_INFO(TEXT("Open Still has recovery problem, give up."));
                }

            }

            if (m_bConnected && m_dpDesc.dwMaxPlayers != 0)
            {
                TSHELL_INFO(TEXT("Connection Made."));
                DBG_INFO((DBGARG, TEXT("Current Players. %d"), m_dpDesc.dwCurrentPlayers));
                SendPing();
                return(DP_OK);
            }
            else
            {
                TSHELL_INFO(TEXT("Connection timed out"));
                Close(0);
                return(DPERR_NOCONNECTION);
            }

        }
        else
        {
            if (g_bCallCancel)
                return(DPERR_USERCANCEL);

            TSHELL_INFO(TEXT("DialCall failed."));
            return(DPERR_GENERIC);
        }
    }
    else
    {
        TSHELL_INFO(TEXT("Unhandled Open flags."));
        return(DPERR_UNSUPPORTED);
    }
}


// ----------------------------------------------------------
// CreatePlayer - registers new player, N.B. may fail if
// not currently connected to name server
// ----------------------------------------------------------
LONG    CImpIDP_SP::FindInvalidIndex()
{
    DWORD   ii;

    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (m_aPlayer[ii].bValid == FALSE)
            return(ii);

    return(-1);
}
VOID CImpIDP_SP::LocalMsg(LONG iIndex, LPVOID lpv, DWORD dwSize)
{

    LONG ii;

    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (   ii != iIndex
            && m_aPlayer[ii].bValid
            && m_aPlayer[ii].bLocal
            && m_aPlayer[ii].bPlayer)
                AddMessage(lpv, dwSize, m_aPlayer[ii].pid, 0, 0);

}
VOID CImpIDP_SP::RemoteMsg(LONG iIndex, LPVOID lpv, DWORD dwSize)
{
    SPMSG_GENERIC *pMsg;
    DWORD dwTotal = dwSize + sizeof(DPHDR);

    pMsg = (SPMSG_GENERIC *) malloc(dwTotal);
    if (pMsg)
    {
        pMsg->dpHdr.usCookie = SPSYS_SYS;
        pMsg->dpHdr.to       = 0;
        pMsg->dpHdr.from     = 0;
        pMsg->dpHdr.usCount  = (USHORT) dwSize;
        memcpy( (LPVOID) &pMsg->sMsg, lpv, dwSize);
        WriteCommString( (LPVOID) pMsg, dwTotal);
    }
}

extern BOOL SetupLocalPlayer(DPID pid, HANDLE hEvent);
HRESULT CImpIDP_SP::CreatePlayer(
    LPDPID pPlayerID,
    LPSTR pNickName,
    LPSTR pFullName,
    LPHANDLE lpReceiveEvent,
    BOOL  bPlayer
)
{
    DWORD ii, jj;
    SPMSG_ADDPLAYER *pMsg;
    HANDLE  hEvent = NULL;
    BOOL    bb     = TRUE;
    HRESULT hr     = DP_OK;
    LONG    iIndex;
    DPMSG_ADDPLAYER dpAdd;

    // TSHELL_INFO(TEXT("Enter Create Player"));

    if (m_dwNextPlayer > MAXIMUM_PLAYER_ID)
    {
        return(DPERR_CANTCREATEPLAYER);
    }

    if (m_bConnected == FALSE)
        if (m_bPlayer0 != TRUE)
            return(DPERR_NOCONNECTION);

    if (m_bEnablePlayerAdd == FALSE && bPlayer == TRUE)
        return(DPERR_CANTCREATEPLAYER);

    if (m_dpDesc.dwMaxPlayers == m_dpDesc.dwCurrentPlayers)
    {
        DBG_INFO((DBGARG, TEXT("CreatePlayer: at max players already. %d"),
            m_dpDesc.dwMaxPlayers));
        return(DPERR_CANTADDPLAYER);
    }

    if (m_iPlayerIndex != -1)
    {
        TSHELL_INFO(TEXT("Player index not -1, create already in progress."));
        return(DPERR_GENERIC);
    }

    iIndex = FindInvalidIndex();
    if (iIndex == -1)
        return(DPERR_GENERIC);

    if (m_hNewPlayerEvent)
        return(DPERR_GENERIC);

    if (!(hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        TSHELL_INFO(TEXT("CreatePlayer: CreateEvent failure."));
        return(DPERR_GENERIC);
    }
    else
    {
        ; // DBG_INFO((DBGARG, TEXT("CreatePlayer %8x Event"), hEvent));
    }


    dpAdd.dwType = DPSYS_ADDPLAYER;
    dpAdd.dwPlayerType = bPlayer;
    dpAdd.dpId     = 0;
    lstrcpy( dpAdd.szShortName, pNickName);
    lstrcpy( dpAdd.szLongName , pFullName);

    if (m_bPlayer0)
    {
        m_dpDesc.dwCurrentPlayers++;
        m_aPlayer[iIndex].pid = (DPID) m_dwNextPlayer++;
        lstrcpy( m_aPlayer[iIndex].chNickName, pNickName);
        lstrcpy( m_aPlayer[iIndex].chFullName, pFullName);
        m_aPlayer[iIndex].bValid  = TRUE;
        m_aPlayer[iIndex].bPlayer = bPlayer;
        m_aPlayer[iIndex].hEvent  = hEvent;
        m_aPlayer[iIndex].bLocal  = TRUE;
        for (ii = 0; ii < MAX_PLAYERS; ii++)
            m_aPlayer[iIndex].aGroup[ii] = 0;


        dpAdd.dpId     = m_aPlayer[iIndex].pid;

        LocalMsg( iIndex, (LPVOID) &dpAdd, sizeof(DPMSG_ADDPLAYER));
        RemoteMsg(iIndex, (LPVOID) &dpAdd, sizeof(DPMSG_ADDPLAYER));
        hEvent = NULL;
        *pPlayerID = (DPID) (0x0000ffff & m_aPlayer[iIndex].pid);
        if (lpReceiveEvent)
            *lpReceiveEvent = m_aPlayer[iIndex].hEvent;
        SetupLocalPlayer(m_aPlayer[iIndex].pid, m_aPlayer[iIndex].hEvent);
        return(DP_OK);
    }

    m_hNewPlayerEvent = hEvent;
    for (jj = 0; jj < 3; jj++)
    {
        pMsg = (SPMSG_ADDPLAYER *) malloc(sizeof(SPMSG_ADDPLAYER));
        if (pMsg)
        {
            TSHELL_INFO(TEXT("Prepare AddPlayer message"));
            pMsg->dpHdr.usCookie = SPSYS_SYS;
            pMsg->dpHdr.to       = 0;
            pMsg->dpHdr.from     = 0;
            pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
            memcpy( (LPVOID) &pMsg->sMsg, &dpAdd, sizeof(DPMSG_ADDPLAYER));
            WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_ADDPLAYER));
            pMsg = NULL;

            if (WaitForSingleObject(m_hNewPlayerEvent, 4500) != WAIT_TIMEOUT)
            {
                if (m_iPlayerIndex != -1)
                {
                    SetupLocalPlayer(m_aPlayer[m_iPlayerIndex].pid, m_hNewPlayerEvent);
                    m_aPlayer[m_iPlayerIndex].hEvent = m_hNewPlayerEvent;
                    if (lpReceiveEvent)
                        *lpReceiveEvent = m_aPlayer[m_iPlayerIndex].hEvent;
                    m_hNewPlayerEvent = NULL;
                    *pPlayerID = (DPID) (0x0000ffff & m_aPlayer[m_iPlayerIndex].pid);
                    m_iPlayerIndex = -1;

                    return(DP_OK);
                }
            }

            ResetEvent(m_hNewPlayerEvent);
        }
        else
        {
            hr = DPERR_NOMEMORY;
            goto abort;
        }

    }


    hr = DPERR_CANTADDPLAYER;


abort:
    m_hNewPlayerEvent = NULL;

    if (pMsg)
        LocalFree((HLOCAL) pMsg);
    if (hEvent)
        CloseHandle(hEvent);

    return(hr);

}

LONG CImpIDP_SP::GetPlayerIndex(DPID playerID)
{
    DWORD ii;
    DPID  pid = 0xffff & ((DPID) playerID);

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid)
            if (m_aPlayer[ii].pid == pid)
                return(ii);
    }
    return(-1);
}


// ----------------------------------------------------------
// DestroyPlayer
// ----------------------------------------------------------
HRESULT CImpIDP_SP::DestroyPlayer( DPID playerID, BOOL bPlayer)
{
    LONG    iIndex;
    DWORD   ii, jj;

    DPMSG_GETPLAYER  dpGet;

    SPMSG_GETPLAYER *pMsg;
    HANDLE  hEvent = NULL;
    HRESULT hr     = DP_OK;

    if ((iIndex = GetPlayerIndex(playerID)) == -1)
        return(DPERR_INVALIDPLAYER);

    if (m_aPlayer[iIndex].bPlayer != bPlayer)
        return(DPERR_INVALIDPLAYER);


    if (bPlayer)
    {
        dpGet.dwType     = DPSYS_DELETEPLAYER;
    }
    else
    {
        dpGet.dwType     = DPSYS_DELETEGROUP;
    }

    m_dpDesc.dwCurrentPlayers--;
    dpGet.dpId        = m_aPlayer[iIndex].pid;

    if (m_bPlayer0)
    {
        if (m_aPlayer[iIndex].bLocal)
        {
            FlushQueue(playerID);
            CloseHandle(m_aPlayer[iIndex].hEvent);
        }
        m_aPlayer[iIndex].bValid = FALSE;
        LocalMsg(iIndex, (LPVOID) &dpGet, sizeof(DPMSG_GETPLAYER));
    }

    pMsg = (SPMSG_GETPLAYER *) malloc(sizeof(SPMSG_GETPLAYER));
    if (pMsg)
    {
        pMsg->dpHdr.usCookie = SPSYS_SYS;
        pMsg->dpHdr.to       = 0;
        pMsg->dpHdr.from     = 0;
        pMsg->dpHdr.usCount  = sizeof(DPMSG_GETPLAYER);
        memcpy( (LPVOID) &pMsg->sMsg, (LPVOID) &dpGet, sizeof(DPMSG_GETPLAYER));
        WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
    }


    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (   m_aPlayer[ii].bValid  == TRUE
            && m_aPlayer[ii].bPlayer == FALSE
            && m_aPlayer[ii].aGroup)
        {
            for (jj = 0; jj < MAX_PLAYERS; jj++)
            {
                if (m_aPlayer[ii].aGroup[jj] == playerID)
                {
                    m_aPlayer[ii].aGroup[jj] = 0;
                    break;
                }
            }

        }
    }

    return(DP_OK);

}


// ----------------------------------------------------------
// Close - close the connection
// ----------------------------------------------------------
HRESULT CImpIDP_SP::Close( DWORD dwFlag)
{
    DWORD ii;

    TSHELL_INFO(TEXT("Close Processing."));
        for (ii = 0; ii < MAX_PLAYERS; ii++)
        {
            if (m_aPlayer[ii].bValid)
            {
                m_aPlayer[ii].bValid = FALSE;

                if (m_aPlayer[ii].bLocal && m_aPlayer[ii].bPlayer)
                {
                    FlushQueue(m_aPlayer[ii].pid);
                    CloseHandle(m_aPlayer[ii].hEvent);
                }
            }
        }

    g_bIgnoreReads = FALSE;
    m_bConnected = FALSE;
    m_bPlayer0 = FALSE;
    PostHangup();
    return(DP_OK);
}

// ----------------------------------------------------------
// GetName -
// ----------------------------------------------------------
HRESULT CImpIDP_SP::GetPlayerName(
    DPID dpID,
    LPSTR lpNickName,          // buffer to hold name
    LPDWORD pdwNickNameLength, // length of name buffer
    LPSTR lpFullName,
    LPDWORD pdwFullNameLength
)
{
    LONG    iIndex;

    HRESULT hr     = DP_OK;
    DPID    pid = (DPID) dpID;

    if ((iIndex = GetPlayerIndex(dpID)) != -1)
    {
        lstrcpy( lpNickName, m_aPlayer[iIndex].chNickName);
        lstrcpy( lpFullName, m_aPlayer[iIndex].chFullName);
        *pdwNickNameLength = lstrlen(lpNickName) + 1;
        *pdwFullNameLength = lstrlen(lpFullName) + 1;
        return(DP_OK);
    }
    else
    {
        return(DPERR_INVALIDPID);
    }

}


HRESULT CImpIDP_SP::EnumGroupPlayers(
                              DPID dwGroupPid,
                              LPDPENUMPLAYERSCALLBACK EnumCallback,
                              LPVOID pContext,
                              DWORD dwFlags)
{

    DWORD   ii;
    HRESULT hr     = DP_OK;
    LONG    iIndexG;
    LONG    iIndexP;
    DPID    pid;

    iIndexG = GetPlayerIndex(dwGroupPid);

    if (iIndexG == -1)
        return(DPERR_INVALIDPID);

    if (m_aPlayer[iIndexG].bPlayer)
        return(DPERR_INVALIDPID);

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if ((pid = m_aPlayer[iIndexG].aGroup[ii]) != 0)
        {
            iIndexP = GetPlayerIndex(pid);
            if (iIndexP != -1)
            {
                (EnumCallback)((DPID) m_aPlayer[iIndexP].pid,
                    m_aPlayer[iIndexP].chNickName,
                    m_aPlayer[iIndexP].chFullName,
                      ((m_aPlayer[iIndexP].bLocal  ) ? DPENUMPLAYERS_LOCAL : DPENUMPLAYERS_REMOTE)
                    | ((!m_aPlayer[iIndexP].bPlayer) ? DPENUMPLAYERS_GROUP : 0),
                    pContext);
            }
            else
            {
                m_aPlayer[iIndexG].aGroup[ii] = 0;
            }
        }
    }

    return(DP_OK);
}

// ----------------------------------------------------------
// EnumPlayers - return info on peer connections.
// ----------------------------------------------------------
HRESULT CImpIDP_SP::EnumPlayers(
                              DWORD dwSessionId,
                              LPDPENUMPLAYERSCALLBACK EnumCallback,
                              LPVOID pContext,
                              DWORD dwFlags)
{

    DWORD   ii;
    HRESULT hr     = DP_OK;

    if (dwFlags & DPENUMPLAYERS_PREVIOUS)
    {
        return(DPERR_UNSUPPORTED);
    }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (     m_aPlayer[ii].bValid
            && (   (m_aPlayer[ii].bPlayer == FALSE &&  (dwFlags & DPENUMPLAYERS_GROUP))
                || (m_aPlayer[ii].bPlayer == TRUE  && !(dwFlags & DPENUMPLAYERS_NOPLAYERS))))
        {
            if((EnumCallback)((DPID) m_aPlayer[ii].pid,
                m_aPlayer[ii].chNickName,
                m_aPlayer[ii].chFullName,
                  ((m_aPlayer[ii].bLocal  ) ? DPENUMPLAYERS_LOCAL : DPENUMPLAYERS_REMOTE)
                | ((!m_aPlayer[ii].bPlayer) ? DPENUMPLAYERS_GROUP : 0),
                pContext) == FALSE)
            {
                break;
            }

        }

    return(DP_OK);
}

HRESULT CImpIDP_SP::EnumSessions(
                                       LPDPSESSIONDESC lpSDesc,
                                       DWORD dwTimeout,
                                       LPDPENUMSESSIONSCALLBACK EnumCallback,
                                       LPVOID lpvContext,
                                       DWORD dwFlags)
{
    DPSESSIONDESC dpSDesc;





    memcpy( &dpSDesc.guidSession, &(lpSDesc->guidSession), sizeof(GUID));
    dpSDesc.dwSession        = 0;
    dpSDesc.dwMaxPlayers     = MAX_PLAYERS;
    dpSDesc.dwCurrentPlayers = 0;
    dpSDesc.dwFlags          = 0;
    dpSDesc.dwSize           = sizeof(DPSESSIONDESC);
    LoadString(hInst, IDS_DIALNEW, dpSDesc.szSessionName, sizeof(dpSDesc.szSessionName));

    EnumCallback( &dpSDesc, lpvContext, NULL, 0);


    if (m_dwSessionPrev && dwFlags & DPENUMSESSIONS_PREVIOUS)
    {
        DWORD ii;
        DWORD dw;

        for (ii = 0; ii < m_dwSessionPrev; ii++)
        {
            dpSDesc.dwSession = ii + 1;
            dw = *((DWORD *)(m_ppSessionArray[ii]));
            lstrcpyn( dpSDesc.szSessionName,
                      ((m_ppSessionArray[ii]) + sizeof(DWORD) + dw), DPLONGNAMELEN);
            dpSDesc.szSessionName[DPLONGNAMELEN-1] = 0x00;
            EnumCallback( &dpSDesc, lpvContext, NULL, 0);
        }
    }


    return(DP_OK);
}

VOID CImpIDP_SP::ISend(
        LONG    iFrom,
        LONG    iTo,
        DWORD   dwFlags,
        LPVOID  lpvBuffer,
        DWORD   dwBuffSize)
{

    MSG_BUILDER *pMsg;
    DWORD        ii;
    LONG         iIndexT;

    if (m_aPlayer[iTo].bPlayer == FALSE)
    {
        for (ii = 0; ii < MAX_PLAYERS; ii++)
        {
            if (m_aPlayer[iTo].aGroup[ii])
                if ((iIndexT = GetPlayerIndex(m_aPlayer[iTo].aGroup[ii])) != -1)
                    ISend(iFrom, iIndexT, dwFlags, lpvBuffer, dwBuffSize);
        }
    }
    else
    {
        if (m_aPlayer[iTo].bLocal)
        {
            AddMessage(lpvBuffer,
                       dwBuffSize,
                       m_aPlayer[iTo].pid,
                       m_aPlayer[iFrom].pid,
                       dwFlags & DPSEND_HIGHPRIORITY);

        }
        else
        {
            LPVOID       lpv = malloc(sizeof(DPHDR) + dwBuffSize);
            if (!lpv)
                return;

//            TSHELL_INFO(TEXT("Sending Remote Message."));

            pMsg = (MSG_BUILDER *) lpv;
            pMsg->dpHdr.usCookie = (dwFlags & DPSEND_HIGHPRIORITY) ? SPSYS_HIGH : SPSYS_USER;
            pMsg->dpHdr.to       = (BYTE) m_aPlayer[iTo].pid;
            pMsg->dpHdr.from     = (BYTE) m_aPlayer[iFrom].pid;
            pMsg->dpHdr.usCount  = (USHORT) dwBuffSize;
            memcpy( pMsg->chMsgCompose, lpvBuffer, dwBuffSize);
            WriteCommString( (LPVOID) pMsg, sizeof(DPHDR) + dwBuffSize);
            lpv = NULL;
        }

    }

}

// ----------------------------------------------------------
// Send - transmit data over socket.
// ----------------------------------------------------------
HRESULT CImpIDP_SP::Send(
        DPID    from,
        DPID    to,
        DWORD   dwFlags,
        LPVOID  lpvBuffer,
        DWORD   dwBuffSize)
{
    DWORD        ii;
    LONG         iFrom;
    BOOL         bSent = FALSE;

    if (m_dwPendingWrites > m_dpcaps.dwMaxQueueSize)
    {
        return(DPERR_BUSY);
    }

    if (dwBuffSize > MAX_MSG)
        return(DPERR_INVALIDPARAMS);

    if (from == 0)
    {
        return(DPERR_INVALIDPID);
    }
    else
    {
        iFrom = GetPlayerIndex(from);
//        DBG_INFO((DBGARG, TEXT("Send From Pid %d Player Index %d"), from, iFrom));
        if (iFrom == -1)
            for (ii = 0; ii < MAX_PLAYERS; ii++)
            {
                DBG_INFO((DBGARG, TEXT("Index %d Valid %d Pid %d Local %d"),
                    ii,
                    m_aPlayer[ii].bValid,
                    m_aPlayer[ii].pid,
                    m_aPlayer[ii].bLocal));
            }


        if (iFrom == -1 || ! m_aPlayer[iFrom].bLocal)
            return(DPERR_INVALIDPID);
    }


    for (ii = 0; ii < MAX_PLAYERS; ii++)
        if (m_aPlayer[ii].bValid && m_aPlayer[ii].pid != from)
        {
            if (   (to == 0 && m_aPlayer[ii].bPlayer == TRUE)
                || m_aPlayer[ii].pid == to)
            {
                ISend(iFrom, ii, dwFlags, lpvBuffer, dwBuffSize);
                bSent = TRUE;
            }
        }

    return(bSent ? m_dwPendingWrites : DPERR_INVALIDPID);
}

// ----------------------------------------------------------
//  Receive - receive message
// ----------------------------------------------------------
HRESULT CImpIDP_SP::Receive(
        LPDPID   pidfrom,
        LPDPID   pidto,
        DWORD    dwFlags,
        LPVOID   lpvBuffer,
        LPDWORD  lpdwSize)
{
    HRESULT hr;
    LONG    iIndex;
    BOOL    bb;

    bb = TRUE;

    if (dwFlags & DPRECEIVE_TOPLAYER)
    {
        iIndex = GetPlayerIndex(*pidto);

        if (iIndex == -1 || m_aPlayer[iIndex].bLocal == FALSE)
            bb = FALSE;
    }

    if ((dwFlags & DPRECEIVE_FROMPLAYER) && *pidfrom != 0)
    {
        iIndex = GetPlayerIndex(*pidfrom);

        if (iIndex == -1 || m_aPlayer[iIndex].bLocal == FALSE)
            bb = FALSE;
    }

    if (bb == FALSE)
    {
        return(DPERR_INVALIDPID);
    }

    hr = GetQMessage(lpvBuffer, lpdwSize, pidto, pidfrom, dwFlags,
                        dwFlags & DPRECEIVE_PEEK);
    return(hr);
}


HRESULT CImpIDP_SP::SetPlayerName(
                DPID  pid,
                LPSTR lpFriendlyName,
                LPSTR lpFormalName,
                BOOL  bPlayer)
{
    SPMSG_ADDPLAYER *pMsg;


    //
    // Send DPSYS_SETPLAYER to nameserver.
    //
    LONG iIndex = GetPlayerIndex(pid);

    if (iIndex == -1)
        return(DPERR_INVALIDPLAYER);


    if (m_aPlayer[iIndex].bPlayer != bPlayer)
        return(DPERR_INVALIDPLAYER);

    lstrcpyn( m_aPlayer[iIndex].chNickName, lpFriendlyName, DPSHORTNAMELEN);
    lstrcpyn( m_aPlayer[iIndex].chFullName, lpFormalName  , DPLONGNAMELEN);

    pMsg = (SPMSG_ADDPLAYER *) malloc(sizeof(SPMSG_ADDPLAYER));
    if (!pMsg)
    {
        return(DPERR_NOMEMORY);
    }

    pMsg->dpHdr.usCookie = SPSYS_SYS;
    pMsg->dpHdr.to       = 0;
    pMsg->dpHdr.from     = 0;
    pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
    pMsg->sMsg.dwType         = DPSYS_SETPLAYER;
    pMsg->sMsg.dwPlayerType        = bPlayer;
    pMsg->sMsg.dpId            = m_aPlayer[iIndex].pid;
    lstrcpy( pMsg->sMsg.szShortName, lpFriendlyName);
    lstrcpy( pMsg->sMsg.szLongName,  lpFormalName);

    WriteCommString( pMsg, sizeof(SPMSG_ADDPLAYER));

    return(DP_OK);
}

HRESULT CImpIDP_SP::SaveSession(LPVOID lpv, LPDWORD lpdw)
{
    DWORD dwLen;

    if (!m_bConnected)
        return(DPERR_NOCONNECTION);

    if (m_bPlayer0)
        return(DPERR_UNSUPPORTED);

    if (m_lpDialable[0] == 0x00)
        return(DPERR_GENERIC);

    dwLen = 1 + lstrlen(m_lpDialable);

    if (*lpdw < dwLen)
    {
        *lpdw = dwLen;
        TSHELL_INFO(TEXT("SaveSession buffer too small."));
        return(DPERR_BUFFERTOOSMALL);
    }

    if (lpv)
    {
        lstrcpy( (char *) lpv, m_lpDialable);
        *lpdw = dwLen;
    }

    return(DP_OK);
}


HRESULT CImpIDP_SP::SetPrevSession(LPSTR lpName, LPVOID lpv, DWORD dw)
{
    //
    //
    //
    DWORD dwLen;

    // TSHELL_INFO(TEXT("SetPrevSession"));
    if (m_dwSessionAlloc == m_dwSessionPrev)
    {
        char **ppTmp;

        m_dwSessionAlloc += 16;
        ppTmp = (char **) malloc(sizeof(char *) * m_dwSessionAlloc);
        if (ppTmp)
        {
            if (m_ppSessionArray)
            {
                memcpy( ppTmp, m_ppSessionArray, m_dwSessionPrev);
                free(m_ppSessionArray);
            }
        }
        else
        {
            m_dwSessionAlloc -= 16;
            return(DPERR_NOMEMORY);
        }
        m_ppSessionArray = ppTmp;

    }
    dwLen = lstrlen(lpName) + 1;
    m_ppSessionArray[m_dwSessionPrev] = (char *) malloc(dwLen + dw + sizeof(dw));
    if (m_ppSessionArray[m_dwSessionPrev])
    {
        // TSHELL_INFO(TEXT("Fill in structure"));
        *((DWORD *)(m_ppSessionArray[m_dwSessionPrev])) = dw;
        memcpy(((m_ppSessionArray[m_dwSessionPrev]) + sizeof(dw)), lpv, dw);
        lstrcpy(((m_ppSessionArray[m_dwSessionPrev]) + sizeof(dw) + dw), lpName);
        m_dwSessionPrev++;
        return(DP_OK);
    }
    else
    {
        return(DPERR_NOMEMORY);
    }

    return(DPERR_UNSUPPORTED);
}


HRESULT CImpIDP_SP::SetPrevPlayer(LPSTR lpName, LPVOID lpv, DWORD dw)
{
    //
    //
    // This doesn't make sense for a serial point to point SP.
    //
    TSHELL_INFO( TEXT("not currently supported") );
    return(DPERR_UNSUPPORTED);
}

HRESULT CImpIDP_SP::EnableNewPlayers(BOOL bEnable)
{
    //
    // Implementation not set, and won't follow this calling convention.
    // ignore for now.
    //
    SPMSG_ENABLEPLAYER *pMsg;

    pMsg = (SPMSG_ENABLEPLAYER *) malloc(sizeof(SPMSG_ENABLEPLAYER));
    if (pMsg)
    {
        m_bEnablePlayerAdd = bEnable;
        pMsg->dpHdr.usCookie = SPSYS_SYS;
        pMsg->dpHdr.to       = 0;
        pMsg->dpHdr.from     = 0;
        pMsg->dpHdr.usCount  = sizeof(DPMSG_ENABLEPLAYER);
        pMsg->sMsg.dwType    = DPSYS_ENABLEPLAYER;
        pMsg->sMsg.bEnable   = bEnable;
        WriteCommString( pMsg, sizeof(SPMSG_ENABLEPLAYER));
        return(DP_OK);
    }
    else
        return(DPERR_NOMEMORY);
}

HRESULT CImpIDP_SP::GetPlayerCaps(
                    DPID pid,
                    LPDPCAPS lpDPCaps)
{
    LONG iIndex = GetPlayerIndex(pid);

    if (iIndex == -1 || m_aPlayer[iIndex].bPlayer == FALSE)
        return(DPERR_INVALIDPID);

    m_dpcaps.dwHundredBaud = g_dwRate / 100;
    *lpDPCaps = m_dpcaps;
    if (m_aPlayer[iIndex].bLocal)
        lpDPCaps->dwLatency = 1;

    return(DP_OK);
}

HRESULT CImpIDP_SP::GetMessageCount(DPID pid, LPDWORD lpdw )
{
    //
    // Return count for this pid, if it is a local player we have
    // been tracking with Interlock calls.
    //
    LONG iIndex = GetPlayerIndex((DPID) pid);

    if (iIndex == -1 || m_aPlayer[iIndex].bPlayer == FALSE)
        return(DPERR_INVALIDPLAYER);

    if (m_aPlayer[iIndex].bLocal == FALSE)
        return(DPERR_INVALIDPLAYER);

    *lpdw = GetPlayerCount((DPID) pid);
    return(DP_OK);

}
HRESULT CImpIDP_SP::AddPlayerToGroup(
                        DPID pidGroup,
                        DPID pidPlayer)
{
    DPMSG_GROUPADD dpGAdd;
    LONG           iIndexG;
    LONG           iIndexP;
    DWORD          ii;
    SPMSG_GROUPADD *pMsg;

    iIndexG = GetPlayerIndex(pidGroup);
    iIndexP = GetPlayerIndex(pidPlayer);

    if (iIndexG == -1 || m_aPlayer[iIndexG].bPlayer == TRUE)
        return(DPERR_INVALIDPID);

    if (iIndexP == -1 || m_aPlayer[iIndexP].bPlayer == FALSE)
        return(DPERR_INVALIDPID);

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[iIndexG].aGroup[ii] == m_aPlayer[iIndexP].pid)
        {
            return(DPERR_INVALIDPID);
        }
    }


    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[iIndexG].aGroup[ii] == 0)
        {
            dpGAdd.dwType    = DPSYS_ADDPLAYERTOGROUP;
            dpGAdd.dpIdGroup  = m_aPlayer[iIndexG].pid;
            dpGAdd.dpIdPlayer = m_aPlayer[iIndexP].pid;
            LocalMsg(iIndexG, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));
            m_aPlayer[iIndexG].aGroup[ii] = m_aPlayer[iIndexP].pid;


            pMsg = (SPMSG_GROUPADD *) malloc(sizeof(SPMSG_GROUPADD));

            if (pMsg)
            {
                pMsg->dpHdr.usCookie = SPSYS_SYS;
                pMsg->dpHdr.to       = 0;
                pMsg->dpHdr.from     = 0;
                pMsg->dpHdr.usCount  = sizeof(DPMSG_GROUPADD);

                memcpy( (LPVOID) &pMsg->sMsg, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));
                WriteCommString( pMsg, sizeof(SPMSG_GROUPADD));
                return(DP_OK);
            }
            else
                return(DPERR_NOMEMORY);
        }
    }
    return(DPERR_GENERIC);
}

HRESULT CImpIDP_SP::DeletePlayerFromGroup(
                    DPID pidGroup,
                    DPID pidPlayer)
{
    DPMSG_GROUPADD dpGAdd;
    LONG           iIndexG;
    LONG           iIndexP;
    DWORD          ii;
    SPMSG_GROUPADD *pMsg;

    iIndexG = GetPlayerIndex(pidGroup);
    iIndexP = GetPlayerIndex(pidPlayer);

    if (iIndexG == -1 || m_aPlayer[iIndexG].bPlayer == TRUE)
        return(DPERR_INVALIDPID);

    if (iIndexP == -1 || m_aPlayer[iIndexP].bPlayer == FALSE)
        return(DPERR_INVALIDPID);


    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[iIndexG].aGroup[ii] == m_aPlayer[iIndexP].pid)
        {
            dpGAdd.dwType    = DPSYS_DELETEPLAYERFROMGRP;
            dpGAdd.dpIdGroup  = m_aPlayer[iIndexG].pid;
            dpGAdd.dpIdPlayer = m_aPlayer[iIndexP].pid;
            LocalMsg(iIndexG, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));

            m_aPlayer[iIndexG].aGroup[ii] = 0;

            pMsg = (SPMSG_GROUPADD *) malloc(sizeof(SPMSG_GROUPADD));

            if (pMsg)
            {
                pMsg->dpHdr.usCookie = SPSYS_SYS;
                pMsg->dpHdr.to       = 0;
                pMsg->dpHdr.from     = 0;
                pMsg->dpHdr.usCount  = sizeof(DPMSG_GROUPADD);

                memcpy( (LPVOID) &pMsg->sMsg, (LPVOID) &dpGAdd, sizeof(DPMSG_GROUPADD));
                WriteCommString( pMsg, sizeof(SPMSG_GROUPADD));
                return(DP_OK);
            }
            else
                return(DPERR_NOMEMORY);
        }
    }
    return(DPERR_INVALIDPID);
}

VOID CImpIDP_SP::HandleMessage(LPVOID lpv, DWORD dwSize)
{
    DPHDR *pHdr;
    BOOL   bHigh = FALSE;
    DPID   pidTo, pidFrom;
    DWORD  ii;
    SPMSG_ADDPLAYER *pAddPlayer;
    LONG   iIndex;

    pHdr = (DPHDR *) lpv;


    // TSHELL_INFO(TEXT("HandleMessage entered."));
    switch(pHdr->usCookie)
    {
    default:
        TSHELL_INFO(TEXT("Unknown message value"));
        break;

    case SPSYS_CONNECT:
        SPMSG_CONNECT *pConnect;

        pConnect = (SPMSG_CONNECT *) lpv;
        if (   pConnect->dpHdr.usCount == sizeof(SPMSG_CONNECT) - sizeof(DPHDR)
            && pConnect->usVerMajor == DPVERSION_MAJOR
            && pConnect->usVerMinor == DPVERSION_MINOR
            && pConnect->dwConnect1 == DPSYS_KYRA
            && pConnect->dwConnect2 == DPSYS_HALL)
        {
            HandleConnect();
        }

        return;

    case SPSYS_HIGH:
        bHigh = TRUE;
        //
        // Fall Through!
        //
    case SPSYS_USER:
        pidTo   = 0x00ff & ((DPID) pHdr->to);
        pidFrom = 0x00ff & ((DPID) pHdr->from);
        dwSize  = (DWORD)  ((DPID) pHdr->usCount);
        AddMessage((LPVOID) (((LPBYTE) lpv) + sizeof(DPHDR)), dwSize,
            pidTo, pidFrom, bHigh);
        if (   pidFrom != 0
            && ((iIndex = GetPlayerIndex(pidFrom)) == -1))
            {
                SPMSG_GETPLAYER *pMsg;
                pMsg = (SPMSG_GETPLAYER *) malloc(sizeof(SPMSG_GETPLAYER));
                if (pMsg)
                {
                    pMsg->dpHdr.usCookie = SPSYS_SYS;
                    pMsg->dpHdr.to       = 0;
                    pMsg->dpHdr.from     = 0;
                    pMsg->dpHdr.usCount  = sizeof(DPMSG_GETPLAYER);
                    pMsg->sMsg.dwType    = DPSYS_GETPLAYER;
                    pMsg->sMsg.dpId       = pidFrom;
                    WriteCommString((LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
                }
            }
        break;

    case SPSYS_SYS:
        TSHELL_INFO(TEXT("HandleMessage System Message."));
        switch(((SPMSG_GENERIC *)lpv)->sMsg.dwType)
        {
        default:

            DBG_INFO((DBGARG, TEXT("Unknown Type %x"), ((SPMSG_GENERIC *)lpv)->sMsg.dwType));
            break;

        case DPSYS_ENABLEPLAYER:
            {
            SPMSG_ENABLEPLAYER *pMsg;

            pMsg = (SPMSG_ENABLEPLAYER *) lpv;
            if (pMsg->dpHdr.usCount == sizeof(DPMSG_ENABLEPLAYER))
            {
                m_bEnablePlayerAdd = pMsg->sMsg.bEnable;
            }
            }
            break;

        case DPSYS_SETGROUPPLAYER:
            {
            SPMSG_SETGROUPPLAYERS16 *pMsgG;
            LONG           iIndexG;
            DWORD          ii, jj;
            DPID           pid;

            pMsgG = (SPMSG_SETGROUPPLAYERS16 *) lpv;

            if (pMsgG->dpHdr.usCount == (sizeof(SPMSG_SETGROUPPLAYERS16) - sizeof(DPHDR)))
            {
                iIndexG = GetPlayerIndex((DPID) (0x000000ff & pMsgG->Group));
                if (iIndexG == -1)
                {
                    TSHELL_INFO(TEXT("Invalid SetGroupMembers message."));
                }
                else
                {
                    for (ii = 0, jj = 0; ii < 16; ii++)
                    {
                        if (pMsgG->bytePlayers[ii] != 0)
                        {
                            pid = (DPID) (0x000000ff & pMsgG->bytePlayers[ii]);
                            if (GetPlayerIndex(pid) != -1)
                            {
                                m_aPlayer[iIndexG].aGroup[jj++] = pid;
                            }
                        }
                    }
                }

            }

            }
            break;

        case DPSYS_DELETEPLAYERFROMGRP:
        case DPSYS_ADDPLAYERTOGROUP:
            {
            SPMSG_GROUPADD *pMsg;
            LONG           iIndexG;
            LONG           iIndexP;

            pMsg = (SPMSG_GROUPADD *) lpv;

            if (pMsg->dpHdr.usCount == sizeof(DPMSG_GROUPADD))
            {
                iIndexG = GetPlayerIndex(pMsg->sMsg.dpIdGroup);
                iIndexP = GetPlayerIndex(pMsg->sMsg.dpIdPlayer);
                if (   iIndexG == -1
                    || m_aPlayer[iIndexG].bPlayer == TRUE
                    || iIndexP == -1
                    || m_aPlayer[iIndexP].bPlayer == FALSE)
                {
                    TSHELL_INFO(TEXT("Invalid GroupAdd message."));
                }
                else
                {
                    if (pMsg->sMsg.dwType == DPSYS_ADDPLAYERTOGROUP)
                    {

                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                            if (m_aPlayer[iIndexG].aGroup[ii] == 0)
                            {
                                m_aPlayer[iIndexG].aGroup[ii] = m_aPlayer[iIndexP].pid;
                                LocalMsg(iIndexG, (LPVOID) &pMsg->sMsg, sizeof(DPMSG_GROUPADD));
                                break;
                            }
                    }
                    else
                    {

                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                            if (m_aPlayer[iIndexG].aGroup[ii] == m_aPlayer[iIndexP].pid)
                            {
                                m_aPlayer[iIndexG].aGroup[ii] = 0;
                                LocalMsg(iIndexG, (LPVOID) &pMsg->sMsg, sizeof(DPMSG_GROUPADD));
                            }
                    }

                }

            }
            else
            {
                TSHELL_INFO(TEXT("Invalid size on system message"));
            }
            }
            break;



        case DPSYS_SENDDESC:
            {
                SPMSG_SENDDESC *pMsg;

                pMsg = (SPMSG_SENDDESC *) lpv;
                if (pMsg->dpHdr.usCount == SIZE_SENDDESC)
                {
                    memcpy( (LPVOID) &m_dpDesc, (LPVOID) &pMsg->dpDesc, sizeof(m_dpDesc));
                    DBG_INFO((DBGARG, TEXT("New Description. Current Players %d, Max %d"),
                         m_dpDesc.dwCurrentPlayers, m_dpDesc.dwMaxPlayers));
                }
                else
                {
                    TSHELL_INFO(TEXT("Bad SendDesc message."));
                }
            }
            break;

        case DPSYS_PING:
            {
                SPMSG_PING *pMsg;

                pMsg = (SPMSG_PING *) lpv;
                if (pMsg->dpHdr.usCount == SIZE_PING)
                {
                    if (pMsg->dwTicks == m_dwPingSent)
                    {
                        m_dpcaps.dwLatency = (GetTickCount() - m_dwPingSent) /2;
                        m_dwPingSent = 0;
                        // TSHELL_INFO(TEXT("Latency Accepted from our Ping."));
                    }
                    else
                    {
                        SPMSG_PING *pMsg2;

                        pMsg2 = (SPMSG_PING *) malloc(sizeof(SPMSG_PING));
                        if (pMsg2)
                        {
                            memcpy( (LPVOID) pMsg2, (LPVOID) pMsg, sizeof(SPMSG_PING));
                            WriteCommString(pMsg2, sizeof(SPMSG_PING));
                            // TSHELL_INFO(TEXT("Return Ping."));
                        }

                    }
                TSHELL_INFO(TEXT("Ping Recieved."));
                }
            }
            break;

        case DPSYS_SETPLAYER:
            {
            pAddPlayer  = (SPMSG_ADDPLAYER *) lpv;

            TSHELL_INFO(TEXT("Received SETPLAYER message"));
            if (pAddPlayer->dpHdr.usCount == SIZE_ADDPLAYER)
            {
                iIndex = GetPlayerIndex(pAddPlayer->sMsg.dpId);
                if (iIndex != -1)
                {
                    if (m_aPlayer[iIndex].bPlayer == (BOOL) pAddPlayer->sMsg.dwPlayerType)
                    {
                        lstrcpyn( m_aPlayer[iIndex].chNickName, pAddPlayer->sMsg.szShortName, DPSHORTNAMELEN);
                        lstrcpyn( m_aPlayer[iIndex].chFullName, pAddPlayer->sMsg.szLongName , DPLONGNAMELEN);
                    }
                    TSHELL_INFO(TEXT("Name change through SETPLAYER"));


                }
                else if (   !m_bPlayer0
                         && ((iIndex = FindInvalidIndex()) != -1))
                {
                    lstrcpy( m_aPlayer[iIndex].chNickName, pAddPlayer->sMsg.szShortName);
                    lstrcpy( m_aPlayer[iIndex].chFullName, pAddPlayer->sMsg.szLongName);
                    m_aPlayer[iIndex].bValid  = TRUE;
                    m_aPlayer[iIndex].bPlayer = pAddPlayer->sMsg.dwPlayerType;
                    m_aPlayer[iIndex].bLocal  = FALSE;
                    for (ii = 0; ii < MAX_PLAYERS; ii++)
                        m_aPlayer[iIndex].aGroup[ii] = 0;

                    m_aPlayer[iIndex].pid = pAddPlayer->sMsg.dpId;
                    TSHELL_INFO(TEXT("Remote player updated with SETPLAYER."));
                }
            }
            }
                break;

        case DPSYS_ADDPLAYER:
            {
            pAddPlayer = (SPMSG_ADDPLAYER *) lpv;

            if (pAddPlayer->dpHdr.usCount == SIZE_ADDPLAYER)
            {

                if (m_bEnablePlayerAdd == FALSE && pAddPlayer->sMsg.dwPlayerType == TRUE)
                    break;

                if (m_bPlayer0)
                {
                    TSHELL_INFO(TEXT("Begin AddPlayer Processing Player 0."));

                    if (   m_dpDesc.dwMaxPlayers >= m_dpDesc.dwCurrentPlayers
                        && pAddPlayer->sMsg.dpId == 0
                        && ((iIndex = FindInvalidIndex()) != -1)
                        && (m_dwNextPlayer < MAXIMUM_PLAYER_ID))
                    {

                        SPMSG_ADDPLAYER *pReplyMsg;

                        m_dpDesc.dwCurrentPlayers++;
                        m_aPlayer[iIndex].pid = (DPID) m_dwNextPlayer++;
                        lstrcpy( m_aPlayer[iIndex].chNickName, pAddPlayer->sMsg.szShortName);
                        lstrcpy( m_aPlayer[iIndex].chFullName, pAddPlayer->sMsg.szLongName);
                        m_aPlayer[iIndex].bValid  = TRUE;
                        m_aPlayer[iIndex].bPlayer = pAddPlayer->sMsg.dwPlayerType;
                        m_aPlayer[iIndex].bLocal  = FALSE;
                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                            m_aPlayer[iIndex].aGroup[ii] = 0;

                        pAddPlayer->sMsg.dpId = m_aPlayer[iIndex].pid;

                        pReplyMsg = (SPMSG_ADDPLAYER *) malloc(sizeof(SPMSG_ADDPLAYER));
                        if (pReplyMsg)
                        {
                            TSHELL_INFO(TEXT("Replying to AddPlayer message."));
                            memcpy((LPVOID) pReplyMsg, (LPVOID) pAddPlayer,
                                    sizeof(SPMSG_ADDPLAYER));
                            WriteCommString( (LPVOID) pReplyMsg, sizeof(SPMSG_ADDPLAYER));
                        }

                        LocalMsg(iIndex, &pAddPlayer->sMsg, sizeof(DPMSG_ADDPLAYER));

                    }
                    else
                    {
                        TSHELL_INFO(TEXT("Ignoring message, it will timeout."));
                    }

                }
                else
                {
                    TSHELL_INFO(TEXT("Begin AddPlayer Processing Remote."));
                    iIndex = GetPlayerIndex(pAddPlayer->sMsg.dpId);
                    if (iIndex == -1 && (iIndex = FindInvalidIndex()) != -1)
                    {
                        lstrcpy( m_aPlayer[iIndex].chNickName, pAddPlayer->sMsg.szShortName);
                        lstrcpy( m_aPlayer[iIndex].chFullName, pAddPlayer->sMsg.szLongName);
                        m_aPlayer[iIndex].bValid  = TRUE;
                        m_aPlayer[iIndex].bPlayer = pAddPlayer->sMsg.dwPlayerType;
                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                            m_aPlayer[iIndex].aGroup[ii] = 0;

                        m_aPlayer[iIndex].pid = pAddPlayer->sMsg.dpId;
                        LocalMsg(iIndex, &pAddPlayer->sMsg, sizeof(DPMSG_ADDPLAYER));
                        if (m_hNewPlayerEvent)
                        {
                            m_aPlayer[iIndex].bLocal  = TRUE;
                            m_iPlayerIndex = iIndex;
                            SetEvent(m_hNewPlayerEvent);
                        }
                        else
                            m_aPlayer[iIndex].bLocal  = FALSE;

                    }
                }
            }
            else
            {
                TSHELL_INFO(TEXT("Invalid size on system message ADDPLAYER"));
            }
            }
            break;

        case DPSYS_DELETEGROUP:
        case DPSYS_DELETEPLAYER:
            {
            SPMSG_GETPLAYER *pMsg;
            SPMSG_GETPLAYER *pMsg2;

            pMsg = (SPMSG_GETPLAYER *) lpv;

            TSHELL_INFO(TEXT("Got Delete"));
            if (pMsg->dpHdr.usCount == SIZE_GETPLAYER)
            {
                if ((iIndex = GetPlayerIndex(pMsg->sMsg.dpId)) != -1)
                {
                    if (m_bPlayer0)
                    {
                        pMsg2 = (SPMSG_GETPLAYER *) malloc(sizeof(SPMSG_GETPLAYER));
                        if (pMsg2)
                        {
                            TSHELL_INFO(TEXT("Player 0 Pings Delete."));
                            memcpy( (LPVOID) pMsg2, (LPVOID) pMsg, sizeof(SPMSG_GETPLAYER));
                            WriteCommString( (LPVOID) pMsg2, sizeof(SPMSG_GETPLAYER));
                        }
                    }

                    if (m_aPlayer[iIndex].bLocal)
                    {
                        CloseHandle(m_aPlayer[iIndex].hEvent);
                        FlushQueue(m_aPlayer[iIndex].pid);
                    }
                    m_aPlayer[iIndex].bValid = FALSE;
                    LocalMsg(iIndex, (LPVOID) &pMsg->sMsg, sizeof(DPMSG_GETPLAYER));

                    m_dpDesc.dwCurrentPlayers--;

                    if (pMsg->sMsg.dwType == DPSYS_DELETEPLAYER)
                    {
                        DWORD ii, jj;

                        for (ii = 0; ii < MAX_PLAYERS; ii++)
                        {
                            if (   m_aPlayer[ii].bValid  == TRUE
                                && m_aPlayer[ii].bPlayer == FALSE
                                && m_aPlayer[ii].aGroup)
                            {
                                for (jj = 0; jj < MAX_PLAYERS; jj++)
                                {
                                    if (m_aPlayer[ii].aGroup[jj] == pMsg->sMsg.dpId)
                                    {
                                        m_aPlayer[ii].aGroup[jj] = 0;
                                        break;
                                    }
                                }

                            }
                        }
                    }
                }

            }
            else
            {
                TSHELL_INFO(TEXT("Invalid size on system message"));
            }
            }
            break;

        case DPSYS_GETPLAYER:
            {
            DPID             pid = ((SPMSG_GETPLAYER *) lpv)->sMsg.dpId;
            BOOL             bFound = FALSE;

            if (m_bPlayer0)
            {

                if ((iIndex = GetPlayerIndex((DPID) pid)) != -1)
                {
                    SPMSG_ADDPLAYER *pMsg;

                    pMsg = (SPMSG_ADDPLAYER *) malloc(sizeof(SPMSG_ADDPLAYER));
                    pMsg->dpHdr.usCookie = SPSYS_SYS;
                    pMsg->dpHdr.to       = 0;
                    pMsg->dpHdr.from     = 0;
                    pMsg->dpHdr.usCount  = SIZE_ADDPLAYER;
                    pMsg->sMsg.dwType         = DPSYS_SETPLAYER;
                    pMsg->sMsg.dwPlayerType    = m_aPlayer[iIndex].bPlayer;
                    pMsg->sMsg.dpId            = pid;
                    lstrcpy( pMsg->sMsg.szShortName, m_aPlayer[iIndex].chNickName);
                    lstrcpy( pMsg->sMsg.szLongName,  m_aPlayer[iIndex].chFullName);

                    WriteCommString( pMsg, sizeof(SPMSG_ADDPLAYER));
                }
            }

            }
            break;

        }
    }
}

VOID CImpIDP_SP::SendDesc(LPDPSESSIONDESC pDesc)
{
    if (!m_bConnected || ! m_bPlayer0)
        return;

    TSHELL_INFO(TEXT("Here"));

    SPMSG_SENDDESC *pMsg = (SPMSG_SENDDESC *) malloc(sizeof(SPMSG_SENDDESC));

    if (pMsg)
    {
        pMsg->dpHdr.usCookie = SPSYS_SYS;
        pMsg->dpHdr.to       = 0;
        pMsg->dpHdr.from     = 0;
        pMsg->dpHdr.usCount  = SIZE_SENDDESC;
        pMsg->dwType         = DPSYS_SENDDESC;
        memcpy((LPVOID) &pMsg->dpDesc, (LPVOID) pDesc, sizeof(pMsg->dpDesc));
        WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_SENDDESC));
        TSHELL_INFO(TEXT("Description Sent."));
    }


}
VOID CImpIDP_SP::SendPing()
{

    if (!m_bConnected)
    {
        return;
    }

    if (   m_dwPingSent
        && (GetTickCount() < (m_dwPingSent + 2000)))
        {
        return;
        }
    else
        m_dwPingSent = 0;

    SPMSG_PING *pMsg = (SPMSG_PING *) malloc(sizeof(SPMSG_PING));

    if (pMsg)
    {
        pMsg->dpHdr.usCookie = SPSYS_SYS;
        pMsg->dpHdr.to       = 0;
        pMsg->dpHdr.from     = 0;
        pMsg->dpHdr.usCount  = SIZE_PING;
        pMsg->dwType         = DPSYS_PING;
        pMsg->dwTicks        = m_dwPingSent = GetTickCount();
        WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_PING));
    }



}
VOID CImpIDP_SP::ConnectPlayers()
{

    DWORD ii;
    DWORD jj;
    DWORD kk;
    SPMSG_ADDPLAYER *pMsg;
    DPMSG_ADDPLAYER dpAdd;

    SPMSG_SETGROUPPLAYERS16 *pMsgG;

    dpAdd.dwType = DPSYS_SETPLAYER;
    dpAdd.dpId     = 0;


    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (m_aPlayer[ii].bValid && m_aPlayer[ii].bLocal)
        {
            pMsg = (SPMSG_ADDPLAYER *) malloc(sizeof(SPMSG_ADDPLAYER));
            if (pMsg)
            {
                dpAdd.dpId     = m_aPlayer[ii].pid;
                dpAdd.dwPlayerType = m_aPlayer[ii].bPlayer;
                lstrcpy( dpAdd.szShortName, m_aPlayer[ii].chNickName);
                lstrcpy( dpAdd.szLongName , m_aPlayer[ii].chFullName);

                pMsg->dpHdr.usCookie = SPSYS_SYS;
                pMsg->dpHdr.to       = (BYTE) m_aPlayer[ii].pid;
                pMsg->dpHdr.from     = 0;
                pMsg->dpHdr.usCount  = sizeof(DPMSG_ADDPLAYER);
                memcpy( (LPVOID) &pMsg->sMsg, &dpAdd, sizeof(DPMSG_ADDPLAYER));
                WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_ADDPLAYER));
            }
        }
    }

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (   m_aPlayer[ii].bValid
            && m_aPlayer[ii].bLocal
            && m_aPlayer[ii].bPlayer == FALSE)
        {
            pMsgG = (SPMSG_SETGROUPPLAYERS16 *) malloc(sizeof(SPMSG_SETGROUPPLAYERS16));
            if (pMsgG)
            {
                pMsgG->dpHdr.usCookie = SPSYS_SYS;
                pMsgG->dpHdr.to       = 0;
                pMsgG->dpHdr.from     = 0;
                pMsgG->dpHdr.usCount  = sizeof(SPMSG_SETGROUPPLAYERS16) - sizeof(DPHDR);
                pMsgG->dwType         = DPSYS_SETGROUPPLAYER;
                pMsgG->Group          = (BYTE) m_aPlayer[ii].pid;

                memset((LPVOID) pMsgG->bytePlayers, 0x00, 16);

                kk = 0;
                for (jj = 0; jj < MAX_PLAYERS && kk < 16; jj++)
                {
                    if (m_aPlayer[ii].aGroup[jj] != 0)
                        pMsgG->bytePlayers[kk++] = (BYTE) m_aPlayer[ii].aGroup[jj];

                }
                WriteCommString( (LPVOID) pMsgG, sizeof(SPMSG_SETGROUPPLAYERS16));
            }
        }
    }

}


VOID CImpIDP_SP::DeleteRemotePlayers()
{
    DWORD ii;
    DPMSG_DELETEPLAYER dpDel;
    DPMSG_GENERIC      dpGeneric;

    dpDel.dwType     = DPSYS_DELETEPLAYER;
    dpGeneric.dwType = DPSYS_SESSIONLOST;

    for (ii = 0; ii < MAX_PLAYERS; ii++)
    {
        if (   m_aPlayer[ii].bValid
            && m_aPlayer[ii].bLocal  == FALSE
            && m_aPlayer[ii].bPlayer == TRUE)
        {
            m_aPlayer[ii].bValid = FALSE;
            m_dpDesc.dwCurrentPlayers--;
            dpDel.dpId = m_aPlayer[ii].pid;
            LocalMsg(-1, (LPVOID) &dpDel, sizeof(DPMSG_DELETEPLAYER));
        }
    }

    LocalMsg(-1, (LPVOID) &dpGeneric, sizeof(DPMSG_GENERIC));
}

VOID CImpIDP_SP::HandleConnect()
{

    DPMSG_GENERIC notice;

    TSHELL_INFO(TEXT("Handle Connect"));

    if (!m_bConnected && m_dpDesc.dwMaxPlayers != 0)
    {
        TSHELL_INFO(TEXT("We are Connected.!"));
        m_bConnected = TRUE;
        SetEvent(m_hBlockingEvent);
    }

    if (m_bPlayer0)
    {

        SPMSG_CONNECT *pMsg = (SPMSG_CONNECT *) malloc(sizeof(SPMSG_CONNECT));
        SendPing();
        TSHELL_INFO(TEXT("Ping Sent."));
        SendDesc(&m_dpDesc);
        TSHELL_INFO(TEXT("Game Description Sent."));

        if (pMsg)
        {
            TSHELL_INFO(TEXT("Here."));
            pMsg->dpHdr.to       = 0;
            pMsg->dpHdr.from     = 0;
            pMsg->dpHdr.usCount  = sizeof(SPMSG_CONNECT) - sizeof(DPHDR);
            pMsg->dpHdr.usCookie = SPSYS_CONNECT;
            pMsg->usVerMajor     = DPVERSION_MAJOR;
            pMsg->usVerMinor     = DPVERSION_MINOR;
            pMsg->dwConnect1     = DPSYS_KYRA;
            pMsg->dwConnect2     = DPSYS_HALL;
            TSHELL_INFO(TEXT("Here."));
            WriteCommString( (LPVOID) pMsg, sizeof(SPMSG_CONNECT));
            notice.dwType = DPSYS_CONNECT;
            TSHELL_INFO(TEXT("Here."));
            AddMessage((LPVOID) &notice, sizeof(DPMSG_GENERIC), 0, 0, FALSE);
            TSHELL_INFO(TEXT("Here."));
        }

            TSHELL_INFO(TEXT("Here."));
        if (m_dpDesc.dwCurrentPlayers != 0)
        {
            TSHELL_INFO(TEXT("Here."));
            ConnectPlayers();
            TSHELL_INFO(TEXT("Current players Sent."));
        }
    }

    TSHELL_INFO(TEXT("Leave Connect"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\globals.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
// PURPOSE:
//
//  Contains declarations for all globally scoped names in the program
//

//-------------------------------------------------------------------------
//  About dialog defines.

#define IDD_VERFIRST    100
#define IDD_VERLAST     104


// -----------------------------------------------------------------------
// Global Variable declarations
//

extern "C" HINSTANCE hInst;     // The current instance
#define IDM_HANGUPCALL     1011


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\tapicode.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
// PURPOSE:
//    Contains public declarations for the TapiCode module.
//

BOOL InitializeTAPI(HWND hParentWnd);
BOOL ShutdownTAPI();
BOOL DialCall(LPSTR, LPSTR, LPDWORD, HANDLE);
BOOL ReceiveCall();
BOOL HangupCall(DWORD);
BOOL HangupCallI();
void PostHangupCall();

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\dputils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.h
 *  Content:	common upport routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

// char used when we can't convert from unicode to ansi
#define DPLAY_DEFAULT_CHAR "-"

extern int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
extern int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TapiComm.RC
//
#define IDC_COUNTRYCODE                 1000
#define IDC_TAPILINE                    1001
#define IDC_CONFIGURELINE               1002
#define IDC_DIALINGPROPERTIES           1003
#define IDC_PHONENUMBER                 1004
#define IDC_DIAL                        1005
#define IDC_AREACODE                    1006
#define IDC_CALLINGCARD                 1007
#define IDC_USEDIALINGRULES             1008
#define IDC_LOCATION                    1009
#define IDC_STATICCOUNTRYCODE           1013
#define IDC_STATICAREACODE              1014
#define IDC_STATICPHONENUMBER           1015
#define IDC_STATICLOCATION              1016
#define IDC_STATICCALLINGCARD           1017
#define IDC_STATICTAPILINE              1018
#define IDC_LINEICON                    1022

#define IDC_NOHELPCONTROLS              1101
#define IDC_STATICWHERETODIAL           1102
#define IDC_STATICHOWTODIAL             1103
#define IDC_STATICCONNECTUSING          1104

#define IDC_CONFIGURATIONCHANGED        1201
#define IDC_LINECREATE                  1202

#define IDC_STATIC                      -1

#define IDS_DIALDIALOG                  2001
#define IDS_WARNING                     2002
#define IDS_BADTRANSLATE                2003
#define IDS_NOTVALID                    2004
#define IDS_LOCATIONERR                 2005
#define IDS_DIALNEW                     2006


#define IDD_DIALDIALOG                  3001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1301
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\tapiinfo.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: TapiInfo.c
//
//  PURPOSE: Handles all Pretty Printing functions for the TapiComm sample. 
//
//  EXPORTED FUNCTIONS:  These functions are for use by other modules.
//
//      All of these pretty print to the debugging output.
//    OutputDebugLineCallback       - Calls FormatLineCallback.
//    OutputDebugLineError          - Calls OutputDebugLineErrorFileLine.
//    OutputDebugLastError          - Calls OutputDebugLineErrorFileLine.
//    OutputDebugPrintf             - Calls wsprintf
//    OutputDebugLineErrorFileLine  - Calls FormatLineError
//    OutputDebugLastErrorFileLine  - Calls FormatLastError
//
//      All of these functions pretty print to a string buffer.
//    FormatLineError               - Prints a LINEERR
//    FormatLastError               - Prints a GetLastError error.
//    FormatLineCallback            - Prints a lineCallbackFunc message.
//
//  INTERNAL FUNCTION:  These functions are for this module only.
//    strBinaryArrayAppend          - prints a binary flag array to a buffer.

#include <windows.h>
#include <tapi.h>
#include "TapiInfo.h"

// Maximum length of all internal string buffers.
#define MAXOUTPUTSTRINGLENGTH 4096

// define to make accessing arrays easy.
#define sizeofArray(pArray) (sizeof(pArray) / sizeof((pArray)[0]))


//*****************************************
// Internal prototypes.
//*****************************************

static long strBinaryArrayAppend(LPSTR pszOutputBuffer, DWORD dwFlags,
     LPSTR szStringArray[], DWORD dwSizeofStringArray);



//*****************************************
// Global arrays for interpreting TAPI constants.
//*****************************************

LPSTR pszLineErrorNameArray[] = 
{
"",
"LINEERR_ALLOCATED",
"LINEERR_BADDEVICEID",
"LINEERR_BEARERMODEUNAVAIL",
"LINEERR Unused constant, ERROR!!",
"LINEERR_CALLUNAVAIL",
"LINEERR_COMPLETIONOVERRUN",
"LINEERR_CONFERENCEFULL",
"LINEERR_DIALBILLING",
"LINEERR_DIALDIALTONE",
"LINEERR_DIALPROMPT",
"LINEERR_DIALQUIET",
"LINEERR_INCOMPATIBLEAPIVERSION",
"LINEERR_INCOMPATIBLEEXTVERSION",
"LINEERR_INIFILECORRUPT",
"LINEERR_INUSE",
"LINEERR_INVALADDRESS",
"LINEERR_INVALADDRESSID",
"LINEERR_INVALADDRESSMODE",
"LINEERR_INVALADDRESSSTATE",
"LINEERR_INVALAPPHANDLE",
"LINEERR_INVALAPPNAME",
"LINEERR_INVALBEARERMODE",
"LINEERR_INVALCALLCOMPLMODE",
"LINEERR_INVALCALLHANDLE",
"LINEERR_INVALCALLPARAMS",
"LINEERR_INVALCALLPRIVILEGE",
"LINEERR_INVALCALLSELECT",
"LINEERR_INVALCALLSTATE",
"LINEERR_INVALCALLSTATELIST",
"LINEERR_INVALCARD",
"LINEERR_INVALCOMPLETIONID",
"LINEERR_INVALCONFCALLHANDLE",
"LINEERR_INVALCONSULTCALLHANDLE",
"LINEERR_INVALCOUNTRYCODE",
"LINEERR_INVALDEVICECLASS",
"LINEERR_INVALDEVICEHANDLE",
"LINEERR_INVALDIALPARAMS",
"LINEERR_INVALDIGITLIST",
"LINEERR_INVALDIGITMODE",
"LINEERR_INVALDIGITS",
"LINEERR_INVALEXTVERSION",
"LINEERR_INVALGROUPID",
"LINEERR_INVALLINEHANDLE",
"LINEERR_INVALLINESTATE",
"LINEERR_INVALLOCATION",
"LINEERR_INVALMEDIALIST",
"LINEERR_INVALMEDIAMODE",
"LINEERR_INVALMESSAGEID",
"LINEERR Unused constant, ERROR!!",
"LINEERR_INVALPARAM",
"LINEERR_INVALPARKID",
"LINEERR_INVALPARKMODE",
"LINEERR_INVALPOINTER",
"LINEERR_INVALPRIVSELECT",
"LINEERR_INVALRATE",
"LINEERR_INVALREQUESTMODE",
"LINEERR_INVALTERMINALID",
"LINEERR_INVALTERMINALMODE",
"LINEERR_INVALTIMEOUT",
"LINEERR_INVALTONE",
"LINEERR_INVALTONELIST",
"LINEERR_INVALTONEMODE",
"LINEERR_INVALTRANSFERMODE",
"LINEERR_LINEMAPPERFAILED",
"LINEERR_NOCONFERENCE",
"LINEERR_NODEVICE",
"LINEERR_NODRIVER",
"LINEERR_NOMEM",
"LINEERR_NOREQUEST",
"LINEERR_NOTOWNER",
"LINEERR_NOTREGISTERED",
"LINEERR_OPERATIONFAILED",
"LINEERR_OPERATIONUNAVAIL",
"LINEERR_RATEUNAVAIL",
"LINEERR_RESOURCEUNAVAIL",
"LINEERR_REQUESTOVERRUN",
"LINEERR_STRUCTURETOOSMALL",
"LINEERR_TARGETNOTFOUND",
"LINEERR_TARGETSELF",
"LINEERR_UNINITIALIZED",
"LINEERR_USERUSERINFOTOOBIG",
"LINEERR_REINIT",
"LINEERR_ADDRESSBLOCKED",
"LINEERR_BILLINGREJECTED",
"LINEERR_INVALFEATURE",
"LINEERR_NOMULTIPLEINSTANCE"
};


LPSTR psz_dwMsg[] = {
    "LINE_ADDRESSSTATE",
    "LINE_CALLINFO",
    "LINE_CALLSTATE",
    "LINE_CLOSE",
    "LINE_DEVSPECIFIC",
    "LINE_DEVSPECIFICFEATURE",
    "LINE_GATHERDIGITS",
    "LINE_GENERATE",
    "LINE_LINEDEVSTATE",
    "LINE_MONITORDIGITS",
    "LINE_MONITORMEDIA",
    "LINE_MONITORTONE",
    "LINE_REPLY",
    "LINE_REQUEST",
    "PHONE_BUTTON",
    "PHONE_CLOSE",
    "PHONE_DEVSPECIFIC",
    "PHONE_REPLY",
    "PHONE_STATE",
    "LINE_CREATE",
    "PHONE_CREATE"
};


LPSTR pszfLINEADDRESSSTATE[] = 
{
    "Unknown LINEADDRESSSTATE information",
    "LINEADDRESSSTATE_OTHER",
    "LINEADDRESSSTATE_DEVSPECIFIC",
    "LINEADDRESSSTATE_INUSEZERO",
    "LINEADDRESSSTATE_INUSEONE",
    "LINEADDRESSSTATE_INUSEMANY",
    "LINEADDRESSSTATE_NUMCALLS",
    "LINEADDRESSSTATE_FORWARD",
    "LINEADDRESSSTATE_TERMINALS",
    "LINEADDRESSSTATE_CAPSCHANGE"
};


LPSTR pszfLINECALLINFOSTATE[] = 
{
    "Unknown LINECALLINFOSTATE state",
    "LINECALLINFOSTATE_OTHER",
    "LINECALLINFOSTATE_DEVSPECIFIC",
    "LINECALLINFOSTATE_BEARERMODE",
    "LINECALLINFOSTATE_RATE",
    "LINECALLINFOSTATE_MEDIAMODE",
    "LINECALLINFOSTATE_APPSPECIFIC",
    "LINECALLINFOSTATE_CALLID",
    "LINECALLINFOSTATE_RELATEDCALLID",
    "LINECALLINFOSTATE_ORIGIN",
    "LINECALLINFOSTATE_REASON",
    "LINECALLINFOSTATE_COMPLETIONID",
    "LINECALLINFOSTATE_NUMOWNERINCR",
    "LINECALLINFOSTATE_NUMOWNERDECR",
    "LINECALLINFOSTATE_NUMMONITORS",
    "LINECALLINFOSTATE_TRUNK",
    "LINECALLINFOSTATE_CALLERID",
    "LINECALLINFOSTATE_CALLEDID",
    "LINECALLINFOSTATE_CONNECTEDID",
    "LINECALLINFOSTATE_REDIRECTIONID",
    "LINECALLINFOSTATE_REDIRECTINGID",
    "LINECALLINFOSTATE_DISPLAY",
    "LINECALLINFOSTATE_USERUSERINFO",
    "LINECALLINFOSTATE_HIGHLEVELCOMP",
    "LINECALLINFOSTATE_LOWLEVELCOMP",
    "LINECALLINFOSTATE_CHARGINGINFO",
    "LINECALLINFOSTATE_TERMINAL",
    "LINECALLINFOSTATE_DIALPARAMS",
    "LINECALLINFOSTATE_MONITORMODES"
};


LPSTR pszfLINECALLSTATE[] = 
{
    "Unknown LINECALLSTATE state",
    "LINECALLSTATE_IDLE",
    "LINECALLSTATE_OFFERING",
    "LINECALLSTATE_ACCEPTED",
    "LINECALLSTATE_DIALTONE",
    "LINECALLSTATE_DIALING",
    "LINECALLSTATE_RINGBACK",
    "LINECALLSTATE_BUSY",
    "LINECALLSTATE_SPECIALINFO",
    "LINECALLSTATE_CONNECTED",
    "LINECALLSTATE_PROCEEDING",
    "LINECALLSTATE_ONHOLD",
    "LINECALLSTATE_CONFERENCED",
    "LINECALLSTATE_ONHOLDPENDCONF",
    "LINECALLSTATE_ONHOLDPENDTRANSFER",
    "LINECALLSTATE_DISCONNECTED",
    "LINECALLSTATE_UNKNOWN"
};


LPSTR pszfLINEDIALTONEMODE[] =
{
    "Unknown LINEDIALTONE information",
    "LINEDIALTONEMODE_NORMAL",
    "LINEDIALTONEMODE_SPECIAL",
    "LINEDIALTONEMODE_INTERNAL",
    "LINEDIALTONEMODE_EXTERNAL",
    "LINEDIALTONEMODE_UNKNOWN",
    "LINEDIALTONEMODE_UNAVAIL"
};


LPSTR pszfLINEBUSYMODE[] =
{
    "Unknown LINEBUSYMODE information",
    "LINEBUSYMODE_STATION",
    "LINEBUSYMODE_TRUNK",
    "LINEBUSYMODE_UNKNOWN",
    "LINEBUSYMODE_UNAVAIL"
};


LPSTR pszfLINESPECIALINFO[] =
{
    "Unknown LINESPECIALINFO information",
    "LINESPECIALINFO_NOCIRCUIT",
    "LINESPECIALINFO_CUSTIRREG",
    "LINESPECIALINFO_REORDER",
    "LINESPECIALINFO_UNKNOWN",
    "LINESPECIALINFO_UNAVAIL"
};


LPSTR pszfLINEDISCONNECTED[] =
{
    "Unknown LINEDISCONNECTED information",
    "LINEDISCONNECTMODE_NORMAL",
    "LINEDISCONNECTMODE_UNKNOWN",
    "LINEDISCONNECTMODE_REJECT",
    "LINEDISCONNECTMODE_PICKUP",
    "LINEDISCONNECTMODE_FORWARDED",
    "LINEDISCONNECTMODE_BUSY",
    "LINEDISCONNECTMODE_NOANSWER",
    "LINEDISCONNECTMODE_BADADDRESS",
    "LINEDISCONNECTMODE_UNREACHABLE",
    "LINEDISCONNECTMODE_CONGESTION",
    "LINEDISCONNECTMODE_INCOMPATIBLE",
    "LINEDISCONNECTMODE_UNAVAIL",
    "LINEDISCONNECTMODE_NODIALTONE"
};


LPSTR pszfLINECALLPRIVILEGE[] =
{
    "",
    "LINECALLPRIVILEGE_NONE",
    "LINECALLPRIVILEGE_MONITOR",
    "LINECALLPRIVILEGE_OWNER"
};


LPSTR pszfLINEGATHERTERM[] =
{
    "Unknown LINEGATHERTERM message",
    "LINEGATHERTERM_BUFFERFULL",
    "LINEGATHERTERM_TERMDIGIT",
    "LINEGATHERTERM_FIRSTTIMEOUT",
    "LINEGATHERTERM_INTERTIMEOUT",
    "LINEGATHERTERM_CANCEL"
};


LPSTR pszfLINEGENERATETERM[] = 
{
    "Unknown LINEGENERATETERM message",
    "LINEGENERATETERM_DONE",
    "LINEGENERATETERM_CANCEL"
};


LPSTR pszfLINEDEVSTATE[] =
{    
    "Unknown LINEDEVESTATE state",
    "LINEDEVSTATE_OTHER",
    "LINEDEVSTATE_RINGING",
    "LINEDEVSTATE_CONNECTED",
    "LINEDEVSTATE_DISCONNECTED",
    "LINEDEVSTATE_MSGWAITON",
    "LINEDEVSTATE_MSGWAITOFF",
    "LINEDEVSTATE_INSERVICE",
    "LINEDEVSTATE_OUTOFSERVICE",
    "LINEDEVSTATE_MAINTENANCE",
    "LINEDEVSTATE_OPEN",
    "LINEDEVSTATE_CLOSE",
    "LINEDEVSTATE_NUMCALLS",
    "LINEDEVSTATE_NUMCOMPLETIONS",
    "LINEDEVSTATE_TERMINALS",
    "LINEDEVSTATE_ROAMMODE",
    "LINEDEVSTATE_BATTERY",
    "LINEDEVSTATE_SIGNAL",
    "LINEDEVSTATE_DEVSPECIFIC",
    "LINEDEVSTATE_REINIT",
    "LINEDEVSTATE_LOCK",
    "LINEDEVSTATE_CAPSCHANGE",
    "LINEDEVSTATE_CONFIGCHANGE",
    "LINEDEVSTATE_TRANSLATECHANGE",
    "LINEDEVSTATE_COMPLCANCEL",
    "LINEDEVSTATE_REMOVED"
};


LPSTR pszfLINEDIGITMODE[] =
{
    "Unknown LINEDIGITMODE mode",
    "LINEDIGITMODE_PULSE",
    "LINEDIGITMODE_DTMF",
    "LINEDIGITMODE_DTMFEND"
};
    

LPSTR pszfLINEMEDIAMODE[] =
{
    "Unknown LINEMEDIAMODE mode",
    "UnUsed LINEMEDIAMODE mode, ERROR!!",
    "LINEMEDIAMODE_UNKNOWN",
    "LINEMEDIAMODE_INTERACTIVEVOICE",
    "LINEMEDIAMODE_AUTOMATEDVOICE",
    "LINEMEDIAMODE_DATAMODEM",
    "LINEMEDIAMODE_G3FAX",
    "LINEMEDIAMODE_TDD",
    "LINEMEDIAMODE_G4FAX",
    "LINEMEDIAMODE_DIGITALDATA",
    "LINEMEDIAMODE_TELETEX",
    "LINEMEDIAMODE_VIDEOTEX",
    "LINEMEDIAMODE_TELEX",
    "LINEMEDIAMODE_MIXED",
    "LINEMEDIAMODE_ADSI",
    "LINEMEDIAMODE_VOICEVIEW"
};


LPSTR pszfLINEREQUESTMODE[] =
{
    "Unknown LINEREQUESTMODE message",
    "LINEREQUESTMODE_MAKECALL",
    "LINEREQUESTMODE_MEDIACALL",
    "LINEREQUESTMODE_DROP"
};


//
//  MACRO: OutputDebugLineError(long, LPSTR)
//
//  PURPOSE: Pretty print a line error to the debugging output.
//
//  PARAMETERS:
//    lLineError - Actual error code to decipher.
//    pszPrefix  - String to prepend to the printed message.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This macro is actually defined in the .h file.
//    It will take a LINEERR error, turn it into a human
//    readable string, prepend pszPrefix (so you
//    can tag your errors), append __FILE__ and __LINE__
//    and print it to the debugging output.

//    This macro is just a wrapper around OutputDebugLineErrorFileLine
//    that is necessary to get proper values for __FILE__ and __LINE__.
//
//


/*
#define OuputDebugLineError(lLineError, pszPrefix) \
    OutputDebugLineErrorFileLine(lLineError, pszPrefix,\
        __FILE__, __LINE__)
*/

//
//  FUNCTION: OutputDebugLineErrorFileLine(..)
//
//  PURPOSE: Pretty print a line error to the debugging output.
//
//  PARAMETERS:
//    lLineError  - Actual error code to decipher.
//    pszPrefix   - String to prepend to the printed message.
//    szFileName  - Filename the error occured in.
//    nLineNumber - Line number the error occured at.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This is the actual function that OutputDebugLineError
//    expands to.  Its not likely to be usefull except
//    through the OutputDebugLineError macro, or to print
//    errors without line and file information.
//
//    If szFileName == NULL, then the File and Line are not printed.
//   
//    Note that there is an internal string length limit of
//    MAXOUTPUTSTRINGLENGTH.  If this length is exceeded,
//    the behavior will be the same as wsprintf, although
//    it will be undetectable.  *KEEP szPrefix SHORT!*
//
//

void OutputDebugLineErrorFileLine(
    long lLineError, LPSTR szPrefix, 
    LPSTR szFileName, DWORD nLineNumber)
{
    LPSTR szLineError;
    char szOutputLineError[MAXOUTPUTSTRINGLENGTH];

    if (szPrefix == NULL)
        szPrefix = "";

    // Pretty print the error message.
    szLineError = FormatLineError(lLineError, NULL, 0);

    // The only reason FormatLineError should fail is "Out of memory".
    if (szLineError == NULL)
    {
        if (szFileName == NULL)
            wsprintf(szOutputLineError, "%sOut of memory", szPrefix);
        else
            wsprintf(szOutputLineError, 
                "%sOut of memory in file %s, line %d\r\n",
                szPrefix, szFileName, nLineNumber);

        OutputDebugString(szOutputLineError);

        return;
    }

    // If szFileName, then use it; else don't.
    if (szFileName != NULL)
    {
        wsprintf(szOutputLineError,
            "%s\r\n\tTapi Line Error: \"%s\" \r\n\tin File \"%s\", Line %d\r\n",
            szPrefix, szLineError, szFileName, nLineNumber);
    }
    else
    {
        wsprintf(szOutputLineError,
            "%s\r\n\tTapi Line Error: \"%s\"\r\n",
            szPrefix, szLineError);
    }

    // Pointer returned from FormatLineError *must* be freed!
    LocalFree(szLineError);

    // Print it!
    OutputDebugString(szOutputLineError);

    return;
}


//
//  FUNCTION: FormatLineError(long, LPSTR, DWORD)
//
//  PURPOSE: Pretty print a line error to a string.
//
//  PARAMETERS:
//    lLineError           - Actual error code to decipher.
//    szOutputBuffer       - String buffer to pretty print to.
//    dwSizeofOutputBuffer - Size of String buffer.
//
//  RETURN VALUE:
//    Returns the buffer printed to.
//
//  COMMENTS:
//    If szOutputBuffer isn't big enough to hold the whole string,
//    then the string gets truncated to fit the buffer.
//
//    If szOutputBuffer == NULL, then dwSizeofOutputBuffer
//    is ignored, a buffer 'big enough' is LocalAlloc()d and
//    a pointer to it is returned.  However, its *very* important
//    that this pointer be LocalFree()d by the calling application.
//
//

LPSTR FormatLineError(long lLineError,
    LPSTR szOutputBuffer, DWORD dwSizeofOutputBuffer)
{
    char szUnknownLineError[256];
    LPSTR szLineError;
    int nSizeofLineError;
    long lErrorIndex;
    DWORD * pdwLineError;

    // Strip off the high bit to make the error code positive.
    pdwLineError = (LPDWORD) &lLineError;
    lErrorIndex = (long) (0x7FFFFFFF & *pdwLineError);

    // Is it an unknown error?
    if ((lErrorIndex >= sizeofArray(pszLineErrorNameArray)) ||
        (lErrorIndex < 0))
    {
        nSizeofLineError = 
            wsprintf(szUnknownLineError, "Unknown TAPI line error code: 0x%lx",
                lLineError);
        szLineError = szUnknownLineError;
    }
    else
    {
        szLineError = pszLineErrorNameArray[lErrorIndex];
        nSizeofLineError = strlen(szLineError);
    }

    // allocate a buffer if necessary
    if (szOutputBuffer == NULL)
    {
        szOutputBuffer = (LPSTR) LocalAlloc(LPTR, nSizeofLineError + 1);
        if (szOutputBuffer == NULL)
            return NULL;
    }
    else // truncate string if it won't fit in the specified buffer.
    {
        if ((DWORD) nSizeofLineError >= dwSizeofOutputBuffer)
            nSizeofLineError = dwSizeofOutputBuffer - 1;
    }

    // Put the string into the buffer and null terminate.
    memcpy(szOutputBuffer, szLineError, nSizeofLineError);
    szOutputBuffer[nSizeofLineError] = '\0';

    return szOutputBuffer;
}


//
//  MACRO: OutputDebugLastError(DWORD, LPSTR)
//
//  PURPOSE: Pretty print a system error to the debugging output.
//
//  PARAMETERS:
//    dwLastError - Actual error code to decipher.
//    pszPrefix   - String to prepend to the printed message.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This macro is actually defined in the .h file.
//    It will take an error that was retrieved by GetLastError(),
//    turn it into a human readable string, prepend pszPrefix
//    (so you can tag your errors), append __FILE__ and __LINE__
//    and print it to the debugging output.
//
//    This macro is just a wrapper around OutputDebugLastErrorFileLine
//    that is necessary to get proper values for __FILE__ and __LINE__.
//
//

/*
#define OuputDebugLastError(dwLastError, pszPrefix) \
    OutputDebugLastErrorFileLine(dwLastError, pszPrefix,\
        __FILE__, __LINE__)
*/


//
//  FUNCTION: OutputDebugLastErrorFileLine(..)
//
//  PURPOSE: Pretty print a line error to the debugging output.
//
//  PARAMETERS:
//    dwLastError - Actual error code to decipher.
//    pszPrefix   - String to prepend to the printed message.
//    szFileName  - Filename the error occured in.
//    nLineNumber - Line number the error occured at.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This is the actual function that OutputDebugLastError
//    expands to.  Its not likely to be usefull except
//    through the OutputDebugLastError macro or to print
//    errors without line and file information.
//
//    If szFileName == NULL, then the File and Line are not printed.
//   
//    Note that there is an internal string length limit of
//    MAXOUTPUTSTRINGLENGTH.  If this length is exceeded,
//    the behavior will be the same as wsprintf, although
//    it will be undetectable.  *KEEP szPrefix SHORT!*
//
//

void OutputDebugLastErrorFileLine(
    DWORD dwLastError, LPSTR szPrefix, 
    LPSTR szFileName, DWORD nLineNumber)
{
    LPSTR szLastError;
    char szOutputLastError[MAXOUTPUTSTRINGLENGTH];

    if (szPrefix == NULL)
        szPrefix = "";

    // Pretty print the error.
    szLastError = FormatLastError(dwLastError, NULL, 0);

    // The only reason FormatLastError should fail is "Out of memory".
    if (szLastError == NULL)
    {
        if (szFileName == NULL)
            wsprintf(szOutputLastError, "%sOut of memory\r\n", szPrefix);
        else
            wsprintf(szOutputLastError, "%sOut of memory in file %s, line %d\r\n",
                szPrefix, szFileName, nLineNumber);

        OutputDebugString(szOutputLastError);

        return;
    }

    // If szFileName, then use it; else don't.
    if (szFileName != NULL)
    {
        wsprintf(szOutputLastError,
            "%sGetLastError returned: \"%s\" in File \"%s\", Line %d\r\n",
            szPrefix, szLastError, szFileName, nLineNumber);
    }
    else
    {
        wsprintf(szOutputLastError,
            "%sGetLastError returned: \"%s\"\r\n",
            szPrefix, szLastError);
    }

    // Pointer returned from FormatLineError *must* be freed!
    LocalFree(szLastError);

    // Print it!
    OutputDebugString(szOutputLastError);
    return;
}


//
//  FUNCTION: FormatLastError(DWORD, LPSTR, DWORD)
//
//  PURPOSE: Pretty print a system error to a string.
//
//  PARAMETERS:
//    dwLastError          - Actual error code to decipher.
//    szOutputBuffer       - String buffer to pretty print to.
//    dwSizeofOutputBuffer - Size of String buffer.
//
//  RETURN VALUE:
//    Returns the buffer printed to.
//
//  COMMENTS:
//    If szOutputBuffer isn't big enough to hold the whole string,
//    then the string gets truncated to fit the buffer.
//
//    If szOutputBuffer == NULL, then dwSizeofOutputBuffer
//    is ignored, a buffer 'big enough' is LocalAlloc()d and
//    a pointer to it is returned.  However, its *very* important
//    that this pointer be LocalFree()d by the calling application.
//
//

LPSTR FormatLastError(DWORD dwLastError,
    LPSTR szOutputBuffer, DWORD dwSizeofOutputBuffer)
{
    DWORD dwRetFM;
    DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;

    // Should we allocate a buffer?
    if (szOutputBuffer == NULL)
    {
        // Actually, we make FormatMessage allocate the buffer, if needed.
        dwFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;

        // minimum size FormatMessage should allocate.
        dwSizeofOutputBuffer = 1;  
    }

    // Make FormatMessage pretty print the system error.
    dwRetFM = FormatMessage(
        dwFlags, NULL, dwLastError,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        (LPTSTR) &szOutputBuffer, dwSizeofOutputBuffer,
        NULL);

    // FormatMessage failed to print the error.
    if (dwRetFM == 0)
    {
        DWORD dwGetLastError;
        LPSTR szFormatMessageError;

        dwGetLastError = GetLastError();

        // If we asked FormatMessage to allocate a buffer, then it
        // might have allocated one.  Lets be safe and LocalFree it.
        if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
        {
            __try
            {
                LocalFree(szOutputBuffer);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // Actually, we do nothing for this fault.  If
                // there was a fault, it meant the buffer wasn't
                // allocated, and the LocalFree was unnecessary.
                ;
            }

            szOutputBuffer = (char *) LocalAlloc(LPTR, MAXOUTPUTSTRINGLENGTH);
            dwSizeofOutputBuffer = MAXOUTPUTSTRINGLENGTH;

            if (szOutputBuffer == NULL)
            {
                OutputDebugString("Out of memory trying to FormatLastError\r\n");
                return NULL;
            }
        }

        szFormatMessageError = 
            FormatLastError(dwGetLastError, NULL, 0);

        if (szFormatMessageError == NULL)
            return NULL;

        wsprintf(szOutputBuffer, 
            "FormatMessage failed on error 0x%lx for the following reason: %s",
            dwLastError, szFormatMessageError);

        LocalFree(szFormatMessageError);
    }

    return szOutputBuffer;
}


//
//  FUNCTION: OutputDebugLineCallback(...)
//
//  PURPOSE: Pretty print a message passed into a lineCallbackFunc.
//
//  PARAMETERS:
//    Standard lineCallbackFunc parameters.
//
//  RETURN VALUE:
//    none.
//
//  COMMENTS:
//
//    This function takes all of the parameters passed into a
//    lineCallbackFunc callback function, and pretty prints the
//    meaning of the message.  It then prints the result to
//    the debugging output.
//
//

void OutputDebugLineCallback(
    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, 
    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
    char szOutputBuff[MAXOUTPUTSTRINGLENGTH];

    FormatLineCallback(szOutputBuff, 
        dwDevice, dwMsg, dwCallbackInstance, 
        dwParam1, dwParam2, dwParam3);

    strcat(szOutputBuff,"\r\n");

    OutputDebugString(szOutputBuff);
}


//
//  FUNCTION: FormatLineCallback(...)
//
//  PURPOSE: Pretty prints into a buffer a lineCallbackFunc message.
//
//  PARAMETERS:
//    Standard lineCallbackFunc parameters.
//
//  RETURN VALUE:
//    The pointer to the buffer that has the resulting string.
//
//  COMMENTS:
//
//    This function takes all of the parameters passed into a
//    lineCallbackFunc callback function, and pretty prints the
//    meaning of the message.  It then returns the pointer to
//    the buffer containing this string.
//
//    If szOutputBuffer == NULL, then a buffer is LocalAlloc()d
//    and returned.  However, it is *very* important that this buffer
//    is LocalFree()d.
//

LPSTR FormatLineCallback(LPSTR szOutputBuffer,
    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, 
    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
    long lBufferIndex = 0;

    // Allocate the buffer if necessary.
    if (szOutputBuffer == NULL)
    {
        szOutputBuffer = (LPSTR) LocalAlloc(LPTR, MAXOUTPUTSTRINGLENGTH);

        if (szOutputBuffer == NULL)
            return NULL;
    }

    // Is this a known message?
    if (dwMsg >= sizeofArray(psz_dwMsg))
    {
        wsprintf(szOutputBuffer, "Tapi Msg: Unknown dwMsg: '0x%lx', "
            "dwDevice: '0x%lx', dwInst: '0x%lx', "
            "dwP1: '0x%lx', dwP2: '0x%lx', dwP3: '0x%lx'", dwMsg, 
            dwDevice, dwCallbackInstance, dwParam1, dwParam2, dwParam3);
        return szOutputBuffer;
    }

    // Lets start pretty printing.
    lBufferIndex +=
        wsprintf(szOutputBuffer, "Tapi Msg(%s) On(0x%lx)\r\n\t ",
            psz_dwMsg[dwMsg], dwDevice);

    // Which message was it?  And start decoding it!
    // How the message is decoded depends entirely on the message.
    // READ THE HELP FILES if you more information on this.
    switch(dwMsg)
    {
        case LINE_ADDRESSSTATE:
        {
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "Address ID: 0x%lx, Address State: ", dwParam1);

            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam2,
                    pszfLINEADDRESSSTATE, sizeofArray(pszfLINEADDRESSSTATE));

            break;
        }

        case LINE_CALLINFO:
        {
            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam1,
                    pszfLINECALLINFOSTATE, sizeofArray(pszfLINECALLINFOSTATE));

            break;
        }

        case LINE_CALLSTATE:
        {

            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam3,
                    pszfLINECALLPRIVILEGE, sizeofArray(pszfLINECALLPRIVILEGE));
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "; ");

            lBufferIndex += 
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam1,
                    pszfLINECALLSTATE, sizeofArray(pszfLINECALLSTATE));
    
            switch(dwParam1)
            {
                case LINECALLSTATE_DIALTONE:
                {
                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            ": ");

                    lBufferIndex += 
                        strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                        dwParam2,
                        pszfLINEDIALTONEMODE, sizeofArray(pszfLINEDIALTONEMODE));

                    break;
                }

                case LINECALLSTATE_BUSY:
                {
                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            ": ");

                    lBufferIndex += 
                        strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                        dwParam2,
                        pszfLINEBUSYMODE, sizeofArray(pszfLINEBUSYMODE));

                    break;
                }

                case LINECALLSTATE_SPECIALINFO:
                {
                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            ": ");

                    lBufferIndex += 
                        strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                        dwParam2,
                        pszfLINESPECIALINFO, sizeofArray(pszfLINESPECIALINFO));

                    break;
                }

                case LINECALLSTATE_DISCONNECTED:
                {
                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            ": ");

                    lBufferIndex += 
                        strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                        dwParam2,
                        pszfLINEDISCONNECTED, sizeofArray(pszfLINEDISCONNECTED));

                    break;
                }

                case LINECALLSTATE_CONFERENCED:
                {
                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            ": Parent conference call handle: 0x%lx", dwParam2);

                    break;
                }
            }

            break;
        }

        case LINE_CLOSE:
            break;

        case LINE_DEVSPECIFIC:
            break;

        case LINE_DEVSPECIFICFEATURE:
            break;

        case LINE_GATHERDIGITS:
        {
            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam1,
                    pszfLINEGATHERTERM, sizeofArray(pszfLINEGATHERTERM));

            break;
        }

        case LINE_GENERATE:
        {
            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam1,
                    pszfLINEGENERATETERM, sizeofArray(pszfLINEGENERATETERM));

            break;
        }

        case LINE_LINEDEVSTATE:
        {
            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam1,
                    pszfLINEDEVSTATE, sizeofArray(pszfLINEDEVSTATE));

            switch(dwParam1)
            {
                case LINEDEVSTATE_RINGING:
                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            "; Ring Mode: 0x%lx, Ring Count: %lu"
                            ,dwParam2, dwParam3);
                    break;

                case LINEDEVSTATE_REINIT:
                {
                    switch(dwParam2)
                    {
                        case LINE_CREATE:
                            lBufferIndex +=
                                wsprintf(&(szOutputBuffer[lBufferIndex]),
                                    "; ReInit reason: LINE_CREATE, "
                                        "New Line Device ID '0x%lx'"
                                    , dwParam3);
                            break;
                            
                        case LINE_LINEDEVSTATE:
                            lBufferIndex +=
                                wsprintf(&(szOutputBuffer[lBufferIndex]),
                                    "; ReInit reason: LINE_LINEDEVSTATE, ");

                            lBufferIndex +=
                                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                                    dwParam3,
                                    pszfLINEDEVSTATE, sizeofArray(pszfLINEDEVSTATE));

                            break;
                        
                        case 0:
                            break;
                        default:
                            lBufferIndex +=
                                wsprintf(&(szOutputBuffer[lBufferIndex]),
                                    "; ReInit reason: %s, dwParam3: 0x%lx"
                                    ,psz_dwMsg[dwParam2], dwParam3);
                            break;

                    }

                    break;
                }

                default:
                    break;
            }

            break;
        }

        case LINE_MONITORDIGITS:
        {
            lBufferIndex += 
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                dwParam2,
                pszfLINEDIGITMODE, sizeofArray(pszfLINEDIGITMODE));

            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    ", Received: '%c'", LOBYTE(LOWORD(dwParam1)));
            
            break;
        }

        case LINE_MONITORMEDIA:
        {
            lBufferIndex +=
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                    dwParam1,
                    pszfLINEMEDIAMODE, sizeofArray(pszfLINEMEDIAMODE));

            break;
        }

        case LINE_MONITORTONE:
        {
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "AppSpecific tone '%lu'", dwParam1);
            break;
        }

        case LINE_REPLY:
        {
            if (dwParam2 == 0)
            {
                lBufferIndex +=
                    wsprintf(&(szOutputBuffer[lBufferIndex]),
                        "Request ID: 0x%lx; Successful reply!", dwParam1);
            }
            else
            {
                char szTmpBuff[256];

                FormatLineError((long) dwParam2, szTmpBuff, 255);

                lBufferIndex +=
                    wsprintf(&(szOutputBuffer[lBufferIndex]),
                        "Request ID: 0x%lx; UnSuccessful reply; %s",
                        dwParam1, szTmpBuff);
            }

            break;
        }

        case LINE_REQUEST:
        {
            lBufferIndex += 
                strBinaryArrayAppend(&(szOutputBuffer[lBufferIndex]),
                dwParam1,
                pszfLINEREQUESTMODE, sizeofArray(pszfLINEREQUESTMODE));

            switch(dwParam1)
            {
                case LINEREQUESTMODE_DROP:
                {
                    char szHwndName[1024];

                    SendMessage((HWND) dwParam2, WM_GETTEXT, 1024, (long) szHwndName);

                    lBufferIndex +=
                        wsprintf(&(szOutputBuffer[lBufferIndex]),
                            ": hwnd dropping = 0x%lx, \"%s\"; wRequestID = %u",
                            dwParam2, szHwndName, LOWORD(dwParam3));
                    break;
                }
                default:
                    break;
            }

            break;
        }

        case LINE_CREATE:
        {
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "New Line Device ID '0x%lx'", dwParam1);
            break;
        }

        case PHONE_CREATE:
        {
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "New Phone Device ID '0x%lx'", dwParam1);
            break;
        }

        default:
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "dwParam1: 0x%lx , dwParam2: 0x%lx , dwParam3: 0x%lx",
                    dwParam1, dwParam2, dwParam3);
            break;

    } // End switch(dwMsg)

    // return that pointer!
    return szOutputBuffer;

}


//
//  FUNCTION: strBinaryArrayAppend(LPSTR, DWORD, LPSTR *, DWORD)
//
//  PURPOSE: Takes a bitmapped DWORD, an array representing that
//    binary mapping, and pretty prints it to a buffer.
//
//  PARAMETERS:
//    szOutputBuffer      - Buffer to print to.
//    dwFlags             - Binary mapped flags to interpret.
//    szStringArray       - Array of strings.
//    dwSizeofStringArray - number of elements in szStringArray.

//
//  RETURN VALUE:
//    The number of characters printed into szOutputBuffer.
//
//  COMMENTS:
//
//    This function takes dwFlags and checks each bit.  If the
//    bit is set, the appropriate string (taken from szStringArray)
//    is printed to the szOutputBuffer string buffer.  If there were
//    more bits set in the string than elements in the array, and error
//    is also tagged on the end.
//
//    This function is intended to be used only within the TapiInfo module.
//

static long strBinaryArrayAppend(LPSTR szOutputBuffer, DWORD dwFlags,
     LPSTR szStringArray[], DWORD dwSizeofStringArray)
{
    DWORD dwIndex = 1, dwPower = 1;
    long lBufferIndex = 0;
    BOOL bFirst = TRUE;

    // The zeroth element in every bitmapped array is the "unknown" or
    // "unchanged" message.
    if (dwFlags == 0)
    {
        lBufferIndex =
            wsprintf(szOutputBuffer, "%s", szStringArray[0]);
        return lBufferIndex;
    }

    // iterate through the flags and check each one.
    while(dwIndex < dwSizeofStringArray)
    {
        // If we find one, print it.
        if (dwFlags & dwPower)
            // Seporate each printing with a ", " except the first one.
            if (bFirst)
            {
                lBufferIndex +=
                    wsprintf(&(szOutputBuffer[lBufferIndex]),
                        "%s", szStringArray[dwIndex]);
                bFirst = FALSE;
            }
            else
                lBufferIndex +=
                    wsprintf(&(szOutputBuffer[lBufferIndex]),
                        ", %s", szStringArray[dwIndex]);

        dwIndex ++;
        dwFlags &= ~dwPower;  // clear it so we know we checked it.
        dwPower *= 2;
    }

    // If there are any flags left, they were not in the array.
    if (dwFlags)
    {
        if (bFirst)
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    "Unknown flags '0x%lx'", dwFlags);
        else
            lBufferIndex +=
                wsprintf(&(szOutputBuffer[lBufferIndex]),
                    ", Unknown flags '0x%lx'", dwFlags);
    }

    // how many did we print into the buffer?
    return lBufferIndex;
}



//
//  FUNCTION: OutputDebugPrintf(LPCSTR, ...)
//
//  PURPOSE: wsprintf to the debugging output.
//
//  PARAMETERS:
//    Exactly the same as wsprintf.
//
//  RETURN VALUE:
//    none.
//
//  COMMENTS:
//
//    This function takes exactly the same parameters as wsprintf and
//    prints the results to the debugging output.
//

void __cdecl OutputDebugPrintf(LPCSTR lpszFormat, ...)
{
    char szOutput[MAXOUTPUTSTRINGLENGTH];
    va_list v1;
    DWORD dwSize;

    va_start(v1, lpszFormat);

    dwSize = wvsprintf(szOutput, lpszFormat, v1);

    if (szOutput[dwSize-1] != '\n')
        strcat(szOutput, "\r\n");

    OutputDebugString(szOutput);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\wndproc.cpp ===
#include <windows.h>   // required for all Windows applications
#include "dpspimp.h"
#include "logit.h"
#include "tapicode.h"

HINSTANCE hInst = NULL;

char szAppName[] = "DPlay Serial Monitor";   // The name of this application

DWORD WndProcStart(LPVOID lpv)
{
    ((CImpIDP_SP *)pSrv->pThis)->WndProc();
    return(0);
    
}

DWORD CImpIDP_SP::WndProc()
{
    
    MSG msg;
    HANDLE hAccelTable;
    HINSTANCE hInstance = (HINSTANCE) GetModuleHandle(NULL);
    WNDCLASS  wc;
    HWND            hWnd; // Main window handle.



    if (! InitializeTAPI(NULL))
        return(0);

    TSHELL_INFO("WndProc starting");

    wc.style         = 0;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)WndProc;       // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = 0;                      // No per-window extra data.
    wc.hInstance     = hInst;              // Owner of this class
    wc.hIcon         = NULL; 
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szAppName;              // Name to register as

    RegisterClass(&wc);

    hInst = hInstance;

    hWnd = CreateWindow(
            szAppName,           // See RegisterClass() call.
            NULL,             // Text for window title bar.
            WS_POPUP,
            0,
            0,
            0,
            0,
            NULL,                // Overlapped windows have no parent.
            NULL,                // Use the window class menu.
            hInstance,           // This instance owns this window.
            NULL                 // We don't use any data in our WM_CREATE
    );

    // If window could not be created, return "failure"
    if (!hWnd)
        {
        return (FALSE);
        }       
            
    TSHELL_INFO("hWnd Created");
            
    ShowWindow(hWnd, SW_HIDE); // Show the window
        
    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,    // message structure
                      NULL,    // handle of window receiving the message
                         0,    // lowest message to examine
                         0)    // highest message to examine
            && !m_bStopHwnd
        {
        TranslateMessage(&msg);     // Translates virtual key codes
        DispatchMessage(&msg);      // Dispatches message to window
        }



    ShutDownTAPI();
    return (0); // Returns the value from PostQuitMessage
}


/****************************************************************************
        
        FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
        
        PURPOSE:  Processes messages
        
        MESSAGES:
        
        WM_COMMAND    - application menu (About dialog box)
        WM_DESTROY    - destroy window

        COMMENTS:

        To process the IDM_ABOUT message, call MakeProcInstance() to get the
        current instance address of the About() function.  Then call Dialog
        box which will create the box according to the information in your
        generic.rc file and turn control over to the About() function.  When
        it returns, free the intance address.

****************************************************************************/

LRESULT CALLBACK WndProc(
                HWND hWnd,         // window handle
                UINT message,      // type of message
                WPARAM uParam,     // additional information
                LPARAM lParam)     // additional information
{
    FARPROC lpProcAbout;  // pointer to the "About" function
    int wmId, wmEvent;

    switch (message)
        {
    case WM_DESTROY:  // message: window being destroyed
        PostQuitMessage(0);
        break;

    default:          // Passes it on if unproccessed
        return (DefWindowProc(hWnd, message, uParam, lParam));
    }
    return (0);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\tapiinfo.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
// PURPOSE:
//    Contains public declarations for the TapiInfo module.
//

#define OutputDebugLineError(lLineError, pszPrefix) \
    OutputDebugLineErrorFileLine(lLineError, pszPrefix,\
        __FILE__, __LINE__)

#define OutputDebugLastError(dwLastError, pszPrefix) \
    OutputDebugLastErrorFileLine(dwLastError, pszPrefix,\
        __FILE__, __LINE__)

void OutputDebugLineErrorFileLine(
    long lLineError, LPSTR szPrefix, 
    LPSTR szFileName, DWORD nLineNumber);

void OutputDebugLastErrorFileLine(
    DWORD dwLastError, LPSTR szPrefix, 
    LPSTR szFileName, DWORD nLineNumber);

void OutputDebugLineCallback(
    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, 
    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

void __cdecl OutputDebugPrintf(LPCSTR lpszFormat, ...);

LPSTR FormatLineError(long lLineError,
    LPSTR szOutputBuffer, DWORD dwSizeofOutputBuffer);

LPSTR FormatLastError(DWORD dwLastError,
    LPSTR szOutputBuffer, DWORD dwSizeofOutputBuffer);

LPSTR FormatLineCallback(LPSTR pszOutputBuffer,
    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, 
    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplay\serial\tapicode.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: TapiCode.c
//
//  PURPOSE: Handles all the TAPI routines for TapiComm.
//
//
//  EXPORTED FUNCTIONS:  These functions are for use by other modules.
//
//    InitializeTAPI    - Initialize this app with TAPI.
//    ShutdownTAPI      - Shutdown this app from TAPI.
//    DialCall          - Dial a Call.
//    HangupCall        - Hangup an existing Call.
//    PostHangupCall    - Posts a HangupCall message to the main window.
//
//  INTERNAL FUNCTIONS:  These functions are for this module only.
//
//    DialCallInParts           - Actually Dial the call.
//
//    lineCallbackFunc          - TAPI callback for async messages.
//
//    CheckAndReAllocBuffer     - Helper function for I_ wrappers functions.
//
//    I_lineNegotiateAPIVersion - Wrapper for lineNegotiateAPIVersion.
//    I_lineGetDevCaps          - Wrapper for lineGetDevCaps.
//    I_lineGetAddressStatus    - Wrapper for lineGetAddressStatus.
//    I_lineTranslateAddress    - Wrapper for lineTranslateAddress.
//    I_lineGetCallStatus       - Wrapper for lineGetCallStatus.
//    I_lineGetAddressCaps      - Wrapper for lineGetAddressCaps.
//
//    WaitForCallState          - Resynchronize by Waiting for a CallState.
//    WaitForReply              - Resynchronize by Waiting for a LINE_REPLY.
//
//    DoLineReply               - Handle asynchronous LINE_REPLY.
//    DoLineClose               - Handle asynchronous LINE_CLOSE.
//    DoLineDevState            - Handle asynchronous LINE_LINEDEVSTATE.
//    DoLineCallState           - Handle asynchronous LINE_CALLSTATE.
//    DoLineCreate              - Handle asynchronous LINE_CREATE.
//
//    HandleLineErr             - Handler for most LINEERR errors.
//
//    HandleIniFileCorrupt      - LINEERR handler for INIFILECORRUPT.
//    HandleNoDriver            - LINEERR handler for NODRIVER.
//    HandleNoDevicesInstalled  - LINEERR handler for NODEVICE.
//    HandleReInit              - LINEERR handler for REINIT.
//    HandleNoMultipleInstance  - LINEERR handler for NOMULTIPLEINSTANCE.
//    HandleNoMem               - LINEERR handler for NOMEM.
//    HandleOperationFailed     - LINEERR handler for OPERATIONFAILED.
//    HandleResourceUnavail     - LINEERR handler for RESOURCEUNAVAIL.
//
//    LaunchModemControlPanelAdd - Launches the Modem Control Panel.
//
//    GetAddressToDial          - Launches a GetAddressToDial dialog.
//    DialDialogProc            - Dialog Proc for the GetAddressToDial API.
//
//    I_lineNegotiateLegacyAPIVersion - Wrapper to negoitiate with legacy TSPs
//    VerifyUsableLine          - Verify that a line device is usable
//    FillTAPILine              - Fill a combobox with TAPI Device names
//    VerifyAndWarnUsableLine   - Verify and warn if a line device is usable
//    FillCountryCodeList       - Fill a combobox with country codes
//    FillLocationInfo          - Fill a combobox with current TAPI locations
//    UseDialingRules           - Enable/Disable dialing rules controls
//    DisplayPhoneNumber        - Create and display a valid phone number
//    PreConfigureDevice        - Preconfigure a device line


#include <tapi.h>
#include <windows.h>
#include <string.h>
#include "globals.h"
#include "TapiInfo.h"
#include "TapiCode.h"
#include "CommCode.h"
#include "resource.h"
// #include "statbar.h"
// #include "toolbar.h"
#include <logit.h>

HANDLE g_hConnectionEvent = NULL;

extern "C" HINSTANCE hInst;

// All TAPI line functions return 0 for SUCCESS, so define it.
#define SUCCESS 0

// Possible return error for resynchronization functions.
#define WAITERR_WAITABORTED  1
#define WAITERR_WAITTIMEDOUT 2

// Reasons why a line device might not be usable by TapiComm.
#define LINENOTUSEABLE_ERROR            1
#define LINENOTUSEABLE_NOVOICE          2
#define LINENOTUSEABLE_NODATAMODEM      3
#define LINENOTUSEABLE_NOMAKECALL       4
#define LINENOTUSEABLE_ALLOCATED        5
#define LINENOTUSEABLE_INUSE            6
#define LINENOTUSEABLE_NOCOMMDATAMODEM  7

// Constant used in WaitForCallState when any new
// callstate message is acceptable.
#define I_LINECALLSTATE_ANY 0

 // Wait up to 30 seconds for an async completion.
#define WAITTIMEOUT 30000

// TAPI version that this sample is designed to use.
#define SAMPLE_TAPI_VERSION 0x00010004


// Global TAPI variables.
HWND     g_hWndMainWindow = NULL;   // Apps main window.
HWND     g_hDlgParentWindow = NULL; // This will be the parent of all dialogs.
HLINEAPP g_hLineApp = NULL;
DWORD    g_dwNumDevs = 0;

// Global variable that holds the handle to a TAPI dialog
// that needs to be dismissed if line conditions change.
HWND g_hDialog = NULL;

// Global flags to prevent re-entrancy problems.
BOOL g_bShuttingDown = FALSE;
BOOL g_bStoppingCall = FALSE;
BOOL g_bInitializing = FALSE;


// This sample only supports one call in progress at a time.
BOOL g_bTapiInUse = FALSE;


// Data needed per call.  This sample only supports one call.
HCALL g_hCall = NULL;
HLINE g_hLine = NULL;
DWORD g_dwDeviceID = 0;
DWORD g_dwAPIVersion = 0;
DWORD g_dwCallState = 0;
char  g_szTranslatedNumber[128] = "";
char  g_szDisplayableAddress[128] = "";
char  g_szDialableAddress[128] = "";
BOOL  g_bConnected = FALSE;
LPVOID g_lpDeviceConfig = NULL;
DWORD g_dwSizeDeviceConfig;

// Global variables to allow us to do various waits.
BOOL  g_bReplyRecieved;
DWORD g_dwRequestedID;
long  g_lAsyncReply;
BOOL  g_bCallStateReceived;

// Structures needed to handle special non-dialable characters.
#define g_sizeofNonDialable (sizeof(g_sNonDialable)/sizeof(g_sNonDialable[0]))

typedef struct {
    LONG lError;
    DWORD dwDevCapFlag;
    LPSTR szToken;
    LPSTR szMsg;
} NONDIALTOKENS;

NONDIALTOKENS g_sNonDialable[] = {
    {LINEERR_DIALBILLING,  LINEDEVCAPFLAGS_DIALBILLING,  "$",
            "Wait for the credit card bong tone" },
    {LINEERR_DIALDIALTONE, LINEDEVCAPFLAGS_DIALDIALTONE, "W",
            "Wait for the second dial tone" },
    {LINEERR_DIALDIALTONE, LINEDEVCAPFLAGS_DIALDIALTONE, "w",
            "Wait for the second dial tone" },
    {LINEERR_DIALQUIET,    LINEDEVCAPFLAGS_DIALQUIET,    "@",
            "Wait for the remote end to answer" },
    {LINEERR_DIALPROMPT,   0,                            "?",
            "Press OK when you are ready to continue dialing"},
};

// "Dial" dialog controls and their associated help page IDs
DWORD g_adwSampleMenuHelpIDs[] =
{
    IDC_COUNTRYCODE          , IDC_COUNTRYCODE,
    IDC_STATICCOUNTRYCODE    , IDC_COUNTRYCODE,
    IDC_AREACODE             , IDC_AREACODE,
    IDC_STATICAREACODE       , IDC_AREACODE,
    IDC_PHONENUMBER          , IDC_PHONENUMBER,
    IDC_STATICPHONENUMBER    , IDC_PHONENUMBER,
    IDC_USEDIALINGRULES      , IDC_USEDIALINGRULES,
    IDC_LOCATION             , IDC_LOCATION,
    IDC_STATICLOCATION       , IDC_LOCATION,
    IDC_CALLINGCARD          , IDC_CALLINGCARD,
    IDC_STATICCALLINGCARD    , IDC_CALLINGCARD,
    IDC_DIALINGPROPERTIES    , IDC_DIALINGPROPERTIES,
    IDC_TAPILINE             , IDC_TAPILINE,
    IDC_STATICTAPILINE       , IDC_TAPILINE,
    IDC_CONFIGURELINE        , IDC_CONFIGURELINE,
    IDC_DIAL                 , IDC_DIAL,
    IDC_LINEICON             , IDC_LINEICON,
    //IDC_STATICWHERETODIAL    , IDC_STATICWHERETODIAL,
    //IDC_STATICHOWTODIAL      , IDC_STATICHOWTODIAL,
    //IDC_STATICCONNECTUSING   , IDC_STATICCONNECTUSING,
    //IDC_STATICPHONENUMBER    , IDC_PHONENUMBER,
    0,0
};

//**************************************************
// Prototypes for functions used only in this module.
//**************************************************

BOOL DialCallInParts (
    LPLINEDEVCAPS lpLineDevCaps,
    LPCSTR lpszAddress,
    LPCSTR lpszDisplayableAddress);

LPLINECALLPARAMS CreateCallParams (
    LPLINECALLPARAMS lpCallParams,
    LPCSTR lpszDisplayableAddress);

DWORD I_lineNegotiateAPIVersion (
    DWORD dwDeviceID);

LPLINECALLINFO I_lineGetCallInfo(LPLINECALLINFO lpLineCallInfo);

volatile DWORD g_dwRate = 0;
BOOL g_bCallCancel = FALSE;

LPVOID CheckAndReAllocBuffer(
    LPVOID lpBuffer, size_t sizeBufferMinimum,
    LPTCH szApiPhrase);

LPLINEDEVCAPS I_lineGetDevCaps (
    LPLINEDEVCAPS lpLineDevCaps,
    DWORD dwDeviceID,
    DWORD dwAPIVersion);

LPLINEADDRESSSTATUS I_lineGetAddressStatus (
    LPLINEADDRESSSTATUS lpLineAddressStatus,
    HLINE hLine,
    DWORD dwAddressID);

LPLINETRANSLATEOUTPUT I_lineTranslateAddress (
    LPLINETRANSLATEOUTPUT lpLineTranslateOutput,
    DWORD dwDeviceID,
    DWORD dwAPIVersion,
    LPCSTR lpszDialAddress);

LPLINECALLSTATUS I_lineGetCallStatus (
    LPLINECALLSTATUS lpLineCallStatus,
    HCALL hCall);

LPLINEADDRESSCAPS I_lineGetAddressCaps (
    LPLINEADDRESSCAPS lpLineAddressCaps,
    DWORD dwDeviceID, DWORD dwAddressID,
    DWORD dwAPIVersion, DWORD dwExtVersion);

long WaitForCallState (DWORD dwNewCallState);

long WaitForReply (long lRequestID);

void CALLBACK lineCallbackFunc(
    DWORD hDevice, DWORD dwMsg, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);

void DoLineReply(
    DWORD dwDevice, DWORD dwMsg, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void DoLineClose(
    DWORD dwDevice, DWORD dwMsg, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void DoLineDevState(
    DWORD dwDevice, DWORD dwsg, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void DoLineCallState(
    DWORD dwDevice, DWORD dwMsg, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void DoLineCreate(
    DWORD dwDevice, DWORD dwMessage, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);

BOOL HandleLineErr(long lLineErr);

BOOL HandleIniFileCorrupt();
BOOL HandleNoDriver();
BOOL HandleNoDevicesInstalled();
BOOL HandleReInit();
BOOL HandleNoMultipleInstance();
BOOL HandleNoMem();
BOOL HandleOperationFailed();
BOOL HandleResourceUnavail();

BOOL LaunchModemControlPanelAdd();

INT_PTR CALLBACK DialDialogProc(
    HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL GetAddressToDial();

DWORD I_lineNegotiateLegacyAPIVersion(DWORD dwDeviceID);
long VerifyUsableLine(DWORD dwDeviceID);
void FillTAPILine(HWND hwndDlg);
BOOL VerifyAndWarnUsableLine(HWND hwndDlg);
void FillCountryCodeList(HWND hwndDlg, DWORD dwDefaultCountryID);
void FillLocationInfo(HWND hwndDlg, LPSTR lpszCurrentLocation,
    LPDWORD lpdwCountryID, LPSTR lpszAreaCode);
void UseDialingRules(HWND hwndDlg);
void DisplayPhoneNumber(HWND hwndDlg);
void PreConfigureDevice(HWND hwndDlg, DWORD dwDeviceID);


//**************************************************
// Entry points from the UI
//**************************************************


//
//  FUNCTION: BOOL InitializeTAPI(HWND)
//
//  PURPOSE: Initializes TAPI
//
//  PARAMETERS:
//    hWndParent - Window to use as parent of any dialogs.
//
//  RETURN VALUE:
//    Always returns 0 - command handled.
//
//  COMMENTS:
//
//    This is the API that initializes the app with TAPI.
//    If NULL is passed for the hWndParent, then its assumed
//    that re-initialization has occurred and the previous hWnd
//    is used.
//
//

BOOL InitializeTAPI(HWND hWndParent)
{
    long lReturn;
    BOOL bTryReInit = TRUE;

    // If we're already initialized, then initialization succeeds.
    if (g_hLineApp)
        return TRUE;

    // If we're in the middle of initializing, then fail, we're not done.
    if (g_bInitializing)
        return FALSE;

    g_bInitializing = TRUE;

    // Initialize TAPI
    do
    {
        lReturn = lineInitialize(&g_hLineApp, hInst,
            lineCallbackFunc, "DPlayComm", &g_dwNumDevs);

        // If we get this error, its because some other app has yet
        // to respond to the REINIT message.  Wait 5 seconds and try
        // again.  If it still doesn't respond, tell the user.
        if (lReturn == LINEERR_REINIT)
        {
            if (bTryReInit)
            {
                MSG msg;
                DWORD dwTimeStarted;

                dwTimeStarted = GetTickCount();

                while(GetTickCount() - dwTimeStarted < 5000)
                {
                    if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                bTryReInit = FALSE;
                continue;
            }
            else
            {
                g_bInitializing = FALSE;
                return FALSE;
            }
        }

        if (lReturn == LINEERR_NODEVICE)
        {
            if (HandleNoDevicesInstalled())
                continue;
            else
            {

                TSHELL_INFO(TEXT("No devices installed."));

                g_bInitializing = FALSE;
                return FALSE;
            }
        }

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineInitialize unhandled error: %x"), lReturn));
            g_bInitializing = FALSE;
            return FALSE;
        }
    }
    while(lReturn != SUCCESS);

    g_hDlgParentWindow = g_hWndMainWindow = NULL;

    g_hCall = NULL;
    g_hLine = NULL;


    TSHELL_INFO(TEXT("Tapi initialized."));

    g_bInitializing = FALSE;
    return TRUE;
}


//
//  FUNCTION: BOOL ShutdownTAPI()
//
//  PURPOSE: Shuts down all use of TAPI
//
//  PARAMETERS:
//    None
//
//  RETURN VALUE:
//    True if TAPI successfully shut down.
//
//  COMMENTS:
//
//    If ShutdownTAPI fails, then its likely either a problem
//    with the service provider (and might require a system
//    reboot to correct) or the application ran out of memory.
//
//

BOOL ShutdownTAPI()
{
    long lReturn;

    // If we aren't initialized, then Shutdown is unnecessary.
    if (g_hLineApp == NULL)
        return TRUE;

    // Prevent ShutdownTAPI re-entrancy problems.
    if (g_bShuttingDown)
        return TRUE;

    g_bShuttingDown = TRUE;

    HangupCall(__LINE__);

    do
    {
        lReturn = lineShutdown(g_hLineApp);
        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineShutdown unhandled error: %x"), lReturn));
            break;
        }
    }
    while(lReturn != SUCCESS);

    g_bTapiInUse = FALSE;
    g_bConnected = FALSE;
    g_hLineApp = NULL;
    g_hCall = NULL;
    g_hLine = NULL;
    g_bShuttingDown = FALSE;

    TSHELL_INFO(TEXT("TAPI uninitialized."));

    return TRUE;
}



//
//  FUNCTION: BOOL HangupCall()
//
//  PURPOSE: Hangup the call in progress if it exists.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE if call hung up successfully.
//
//  COMMENTS:
//
//    If HangupCall fails, then its likely either a problem
//    with the service provider (and might require a system
//    reboot to correct) or the application ran out of memory.
//
//

extern BOOL g_bPostHangup;
BOOL HangupCall(DWORD dwCallLine)
{

    DBG_INFO((DBGARG, TEXT("HangupCall was called from %d"), dwCallLine));

    if (g_hConnectionEvent)
        SetEvent(g_hConnectionEvent);

    if (g_bPostHangup)
        return(TRUE);
    else
        return(HangupCallI());
}
BOOL HangupCallI()
{
    LPLINECALLSTATUS pLineCallStatus = NULL;
    long lReturn;


    // Prevent HangupCall re-entrancy problems.
    if (g_bStoppingCall)
        return TRUE;

    // if the 'Call' dialog is up, dismiss it.
    if (g_hDialog)
        PostMessage(g_hDialog, WM_COMMAND, IDCANCEL, 0);

    // If Tapi is not being used right now, then the call is hung up.
    if (!g_bTapiInUse)
        return TRUE;

    g_bStoppingCall = TRUE;

    TSHELL_INFO(TEXT("Stopping Call in progress"));

    // Stop any data communications on the comm port.
    StopComm(g_hConnectionEvent);

    // If there is a call in progress, drop and deallocate it.
    if (g_hCall)
    {
        TSHELL_INFO(TEXT("Calling lineGetCallStatus"));

        // I_lineGetCallStatus returns a LocalAlloc()d buffer
        pLineCallStatus = I_lineGetCallStatus(pLineCallStatus, g_hCall);
        if (pLineCallStatus == NULL)
        {
            ShutdownTAPI();
            g_bStoppingCall = FALSE;
            return FALSE;
        }

        // Only drop the call when the line is not IDLE.
        if (!((pLineCallStatus -> dwCallState) & LINECALLSTATE_IDLE))
        {

            TSHELL_INFO(TEXT("Line isn't idle, call lineDrop"));

            do
            {
                lReturn = WaitForReply(lineDrop(g_hCall, NULL, 0));

                if (lReturn == WAITERR_WAITTIMEDOUT)
                {

                    TSHELL_INFO(TEXT("Call timed out in WaitForReply."));

                    break;
                }

                if (lReturn == WAITERR_WAITABORTED)
                {

                    TSHELL_INFO(TEXT("lineDrop: WAITERR_WAITABORTED."));

                    break;
                }

                // Was the call already in IDLE?
                if (lReturn == LINEERR_INVALCALLSTATE)
                    break;

                if (HandleLineErr(lReturn))
                    continue;
                else
                {
                    DBG_INFO((DBGARG, TEXT("lineDrop unhandled error: %x"), lReturn));
                    break;
                }
            }
            while(lReturn != SUCCESS);

            // Wait for the dropped call to go IDLE before continuing.
            lReturn = WaitForCallState(LINECALLSTATE_IDLE);

#ifdef DEBUG
            if (lReturn == WAITERR_WAITTIMEDOUT)
                TSHELL_INFO(TEXT("Call timed out waiting for IDLE state."));

            if (lReturn == WAITERR_WAITABORTED)
                TSHELL_INFO(TEXT("WAITERR_WAITABORTED while waiting for IDLE state."));
#endif

            TSHELL_INFO(TEXT("Call Dropped."));
        }

        // The call is now idle.  Deallocate it!
        do
        {
            lReturn = lineDeallocateCall(g_hCall);
            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineDeallocateCall unhandled error: %x"), lReturn));
                break;
            }
        }
        while(lReturn != SUCCESS);


        TSHELL_INFO(TEXT("Call Deallocated."));

    }
    else
    {
        TSHELL_INFO(TEXT("g_hCall is NULL."));
    }




    // if we have a line open, close it.
    if (g_hLine)
    {
        do
        {
            lReturn = lineClose(g_hLine);
            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineClose unhandled error: %x"), lReturn));
                break;
            }
        }
        while(lReturn != SUCCESS);


        TSHELL_INFO(TEXT("Line Closed."));

    }

    else
    {
        TSHELL_INFO(TEXT("g_hLine is NULL."));
    }


    // Call and Line are taken care of.  Finish cleaning up.

    // If there is device configuration information, free the memory.
    if (g_lpDeviceConfig)
        LocalFree(g_lpDeviceConfig);
    g_lpDeviceConfig = NULL;

    g_hCall = NULL;
    g_hLine = NULL;
    g_bConnected = FALSE;

    g_bTapiInUse = FALSE;

    g_bStoppingCall = FALSE; // allow HangupCall to be called again.


    TSHELL_INFO(TEXT("Call stopped"));


    // Need to free LocalAlloc()d buffer returned from I_lineGetCallStatus
    if (pLineCallStatus)
        LocalFree(pLineCallStatus);

    return TRUE;
}




//
//  FUNCTION: LONG GetDefaultLine()
//
//  PURPOSE: Get Default line device.
//
LONG GetDefaultLine()
{
    DWORD dwDeviceID;
    DWORD dwAPIVersion;
    LPLINEDEVCAPS lpLineDevCaps = NULL;
    DWORD dwDefaultDevice = MAXDWORD;


    TSHELL_INFO(TEXT("GetDefaultLine"));


    for (dwDeviceID = 0;    dwDeviceID < g_dwNumDevs
                         && dwDefaultDevice == MAXDWORD; dwDeviceID ++)
    {
        dwAPIVersion = I_lineNegotiateLegacyAPIVersion(dwDeviceID);

        if (dwAPIVersion)
        {
            lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps,
                dwDeviceID, dwAPIVersion);
            if (lpLineDevCaps)
            {
                if (   (lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM)
                    && VerifyUsableLine(dwDeviceID) == SUCCESS)
                {
                    dwDefaultDevice = dwDeviceID;
                }
                else;  // Line isn't valid, unuseable.
            }
            else;  // Couldn't GetDevCaps.  Line is unavail.
        }
        else;  // Couldn't NegotiateAPIVersion.  Line is unavail.
    }

    if (lpLineDevCaps)
        LocalFree(lpLineDevCaps);

    if (dwDefaultDevice == MAXDWORD)
        return(-1);
    else
        return((LONG) dwDefaultDevice);
}

//
//  FUNCTION: ReceiveCall()
//
//  PURPOSE: Wait for someone to call us.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE if able to find a line.
//
//  COMMENTS:
//
//    This function makes several assumptions:
//

BOOL ReceiveCall()
{
    long lReturn;
    LPLINEADDRESSSTATUS lpLineAddressStatus = NULL;
    LPLINEDEVCAPS lpLineDevCaps = NULL;



    TSHELL_INFO(TEXT("Receive Call"));



    if (g_bTapiInUse)
    {

        TSHELL_INFO(TEXT("A call is already being handled"));

        return FALSE;
    }

    // If TAPI isn't initialized, its either because we couldn't initialize
    // at startup (and this might have been corrected by now), or because
    // a REINIT event was received.  In either case, try to init now.

    if (!g_hLineApp)
    {
        if (!InitializeTAPI(NULL))
            return FALSE;
    }

    // If there are no line devices installed on the machine, lets give
    // the user the opportunity to install one.
    if (g_dwNumDevs < 1)
    {
        if (!HandleNoDevicesInstalled())
            return FALSE;
    }

    // We now have a call active.  Prevent future calls.
    g_bTapiInUse = TRUE;

    if ((lReturn = GetDefaultLine()) < 0)
        return(FALSE);

    g_dwDeviceID = (DWORD) lReturn;

    // Negotiate the API version to use for this device.
    g_dwAPIVersion = I_lineNegotiateAPIVersion(g_dwDeviceID);
    if (g_dwAPIVersion == 0)
    {
        TSHELL_INFO(TEXT("Line Version problem."));
        HangupCall(__LINE__);
        goto DeleteBuffers;
    }

    // Open the Line for an incomming DATAMODEM call.
    do
    {
        lReturn = lineOpen(g_hLineApp, g_dwDeviceID, &g_hLine,
            g_dwAPIVersion, 0, 0,
            LINECALLPRIVILEGE_OWNER, LINEMEDIAMODE_DATAMODEM,
            0);

        if(lReturn == LINEERR_ALLOCATED)
        {
            TSHELL_INFO(TEXT("Fatal Error"));
            HangupCall(__LINE__);
            goto DeleteBuffers;
        }

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineOpen unhandled error: %x"), lReturn));

            HangupCall(__LINE__);
            goto DeleteBuffers;
        }
    }
    while(lReturn != SUCCESS);

    // Tell the service provider that we want all notifications that
    // have anything to do with this line.
    do
    {
        // Set the messages we are interested in.

        // Note that while most applications aren't really interested
        // in dealing with all of the possible messages, its interesting
        // to see which come through the callback for testing purposes.

        lReturn = lineSetStatusMessages(g_hLine,
            LINEDEVSTATE_OTHER          |
            LINEDEVSTATE_RINGING        |  // Important state!
            LINEDEVSTATE_CONNECTED      |  // Important state!
            LINEDEVSTATE_DISCONNECTED   |  // Important state!
            LINEDEVSTATE_MSGWAITON      |
            LINEDEVSTATE_MSGWAITOFF     |
            LINEDEVSTATE_INSERVICE      |
            LINEDEVSTATE_OUTOFSERVICE   |  // Important state!
            LINEDEVSTATE_MAINTENANCE    |  // Important state!
            LINEDEVSTATE_OPEN           |
            LINEDEVSTATE_CLOSE          |
            LINEDEVSTATE_NUMCALLS       |
            LINEDEVSTATE_NUMCOMPLETIONS |
            LINEDEVSTATE_TERMINALS      |
            LINEDEVSTATE_ROAMMODE       |
            LINEDEVSTATE_BATTERY        |
            LINEDEVSTATE_SIGNAL         |
            LINEDEVSTATE_DEVSPECIFIC    |
            LINEDEVSTATE_REINIT         |  // Not allowed to disable this.
            LINEDEVSTATE_LOCK           |
            LINEDEVSTATE_CAPSCHANGE     |
            LINEDEVSTATE_CONFIGCHANGE   |
            LINEDEVSTATE_COMPLCANCEL    ,

            LINEADDRESSSTATE_OTHER      |
            LINEADDRESSSTATE_DEVSPECIFIC|
            LINEADDRESSSTATE_INUSEZERO  |
            LINEADDRESSSTATE_INUSEONE   |
            LINEADDRESSSTATE_INUSEMANY  |
            LINEADDRESSSTATE_NUMCALLS   |
            LINEADDRESSSTATE_FORWARD    |
            LINEADDRESSSTATE_TERMINALS  |
            LINEADDRESSSTATE_CAPSCHANGE);


        if (HandleLineErr(lReturn))
            continue;
        else
        {
            // If we do get an unhandled problem, we don't care.
            // We just won't get notifications.
            DBG_INFO((DBGARG, TEXT("lineSetStatusMessages unhandled error: %x"), lReturn));
            break;
        }
    }
    while(lReturn != SUCCESS);


    return(TRUE);


DeleteBuffers:

    if (lpLineAddressStatus)
        LocalFree(lpLineAddressStatus);
    if (lpLineDevCaps)
        LocalFree(lpLineDevCaps);

    return g_bTapiInUse;
}






//
//  FUNCTION: DialCall(LPSTR lpDisplay, LPSTR lpDialable, DWORD dwDeviceID, HANDLE hEvent)
//
//  PURPOSE: Get a number from the user and dial it.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE if able to get a number, find a line, and dial successfully.
//
//  COMMENTS:
//
//    This function makes several assumptions:
//    - The number dialed will always explicitly come from the user.
//    - There will only be one outgoing address per line.
//

BOOL DialCall(LPSTR lpDisplay, LPSTR lpDialable, LPDWORD pdwDeviceID, HANDLE hEvent)
{
    long lReturn;
    LPLINEADDRESSSTATUS lpLineAddressStatus = NULL;
    LPLINEDEVCAPS lpLineDevCaps = NULL;

    g_bCallCancel = FALSE;

    if (g_bTapiInUse)
    {

        TSHELL_INFO(TEXT("A call is already being handled"));

        return FALSE;
    }


    g_hConnectionEvent = hEvent;
    // If TAPI isn't initialized, its either because we couldn't initialize
    // at startup (and this might have been corrected by now), or because
    // a REINIT event was received.  In either case, try to init now.

    if (!g_hLineApp)
    {
        if (!InitializeTAPI(NULL))
            return FALSE;
    }

    // If there are no line devices installed on the machine, lets give
    // the user the opportunity to install one.
    if (g_dwNumDevs < 1)
    {
        if (!HandleNoDevicesInstalled())
            return FALSE;
    }

    // We now have a call active.  Prevent future calls.
    g_bTapiInUse = TRUE;

    //
    // See if we can find the users Window.
    //
    {
        HWND hWndTop;
        DWORD   dwWindowProcId;
        DWORD   dwMyProcId;



        hWndTop = GetActiveWindow();
        dwMyProcId = GetCurrentProcessId();
        GetWindowThreadProcessId( hWndTop, &dwWindowProcId);

        DBG_INFO((DBGARG, TEXT("My process is %8x and the active window proc is %8x"),
            dwMyProcId, dwWindowProcId));

        if (dwMyProcId == dwWindowProcId)
            g_hDlgParentWindow = hWndTop;
        else
        {
            hWndTop = GetTopWindow(NULL);

            GetWindowThreadProcessId( hWndTop, &dwWindowProcId);

            if (dwMyProcId == dwWindowProcId)
                g_hDlgParentWindow = hWndTop;

            DBG_INFO((DBGARG,  TEXT("My process is %8x and the top window proc is %8x"),
                dwMyProcId, dwWindowProcId));
        }


    }


    if (lpDialable[0])
    {
        DBG_INFO((DBGARG, TEXT("Dialing with old data (%s)\r\n"), lpDialable));

        //
        // We were supplied with remembered data.  Use that.
        //
        lstrcpy( g_szDialableAddress, lpDialable);
        if ((lReturn = GetDefaultLine()) < 0)
            return(FALSE);

        g_dwDeviceID = (DWORD) lReturn;

    }
    else
    {

        TSHELL_INFO( TEXT("Get number from user"));

        // Get a phone number from the user.
        // Phone number will be placed in global variables if successful
        if (!GetAddressToDial())
        {
            g_bCallCancel = TRUE;
            HangupCall(__LINE__);
            TSHELL_INFO(TEXT("User didn't cooperate, bailing out."));
            goto DeleteBuffers;
        }
        lstrcpy( lpDisplay , g_szDisplayableAddress);
        lstrcpy( lpDialable, g_szDialableAddress   );
        *pdwDeviceID = g_dwDeviceID;

    }

    // Negotiate the API version to use for this device.
    g_dwAPIVersion = I_lineNegotiateAPIVersion(g_dwDeviceID);

    if (g_dwAPIVersion == 0)
    {
        HangupCall(__LINE__);
        TSHELL_INFO(TEXT("Line Version problem."));
        goto DeleteBuffers;
    }

    // Need to check the DevCaps to make sure this line is usable.
    // The 'Dial' dialog checks also, but better safe than sorry.
    lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps,
        g_dwDeviceID, g_dwAPIVersion);
    if (lpLineDevCaps == NULL)
    {
        HangupCall(__LINE__);
        TSHELL_INFO(TEXT("No useable line."));
        goto DeleteBuffers;
    }

    if (!(lpLineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE ))
    {
        HangupCall(__LINE__);
        goto DeleteBuffers;
    }

    if (!(lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM))
    {
        HangupCall(__LINE__);
        TSHELL_INFO(TEXT("No Datamodem capacity."));
        goto DeleteBuffers;
    }

    // Does this line have the capability to make calls?
    // It is possible that some lines can't make outbound calls.
    if (!(lpLineDevCaps->dwLineFeatures & LINEFEATURE_MAKECALL))
    {
        HangupCall(__LINE__);
        TSHELL_INFO(TEXT("Can't make calls on the device."));
        goto DeleteBuffers;
    }

    // Open the Line for an outgoing DATAMODEM call.
    do
    {
        TSHELL_INFO(TEXT("Opening line for Datamodem service."));

        lReturn = lineOpen(g_hLineApp, g_dwDeviceID, &g_hLine,
            g_dwAPIVersion, 0, 0,
            LINECALLPRIVILEGE_NONE, LINEMEDIAMODE_DATAMODEM,
            0);

        if(lReturn == LINEERR_ALLOCATED)
        {
            HangupCall(__LINE__);
            TSHELL_INFO(TEXT("Fatal Error"));
            goto DeleteBuffers;
        }

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineOpen unhandled error: %x"), lReturn));

            HangupCall(__LINE__);
            goto DeleteBuffers;
        }
    }
    while(lReturn != SUCCESS);

    TSHELL_INFO(TEXT("Line is OPEN."));


    // Tell the service provider that we want all notifications that
    // have anything to do with this line.
    do
    {
        // Set the messages we are interested in.

        // Note that while most applications aren't really interested
        // in dealing with all of the possible messages, its interesting
        // to see which come through the callback for testing purposes.

        lReturn = lineSetStatusMessages(g_hLine,
            LINEDEVSTATE_OTHER          |
            LINEDEVSTATE_RINGING        |
            LINEDEVSTATE_CONNECTED      |  // Important state!
            LINEDEVSTATE_DISCONNECTED   |  // Important state!
            LINEDEVSTATE_MSGWAITON      |
            LINEDEVSTATE_MSGWAITOFF     |
            LINEDEVSTATE_INSERVICE      |
            LINEDEVSTATE_OUTOFSERVICE   |  // Important state!
            LINEDEVSTATE_MAINTENANCE    |  // Important state!
            LINEDEVSTATE_OPEN           |
            LINEDEVSTATE_CLOSE          |
            LINEDEVSTATE_NUMCALLS       |
            LINEDEVSTATE_NUMCOMPLETIONS |
            LINEDEVSTATE_TERMINALS      |
            LINEDEVSTATE_ROAMMODE       |
            LINEDEVSTATE_BATTERY        |
            LINEDEVSTATE_SIGNAL         |
            LINEDEVSTATE_DEVSPECIFIC    |
            LINEDEVSTATE_REINIT         |  // Not allowed to disable this.
            LINEDEVSTATE_LOCK           |
            LINEDEVSTATE_CAPSCHANGE     |
            LINEDEVSTATE_CONFIGCHANGE   |
            LINEDEVSTATE_COMPLCANCEL    ,

            LINEADDRESSSTATE_OTHER      |
            LINEADDRESSSTATE_DEVSPECIFIC|
            LINEADDRESSSTATE_INUSEZERO  |
            LINEADDRESSSTATE_INUSEONE   |
            LINEADDRESSSTATE_INUSEMANY  |
            LINEADDRESSSTATE_NUMCALLS   |
            LINEADDRESSSTATE_FORWARD    |
            LINEADDRESSSTATE_TERMINALS  |
            LINEADDRESSSTATE_CAPSCHANGE);


        if (HandleLineErr(lReturn))
            continue;
        else
        {
            // If we do get an unhandled problem, we don't care.
            // We just won't get notifications.

            DBG_INFO((DBGARG, TEXT("lineSetStatusMessages unhandled error: %x"), lReturn));
            break;
        }
    }
    while(lReturn != SUCCESS);

    // Get LineAddressStatus so we can make sure the line
    // isn't already in use by a TAPI application.
    lpLineAddressStatus =
        I_lineGetAddressStatus(lpLineAddressStatus, g_hLine, 0);

    if (lpLineAddressStatus == NULL)
    {
        TSHELL_INFO(TEXT("Fatal Error"));
        HangupCall(__LINE__);
        goto DeleteBuffers;
    }

    // MAKECALL will be set if there are any available call appearances
    if ( ! ((lpLineAddressStatus -> dwAddressFeatures) &
            LINEADDRFEATURE_MAKECALL) )
    {

        TSHELL_INFO(TEXT("This line is not available to place a call."));

        HangupCall(__LINE__);
        goto DeleteBuffers;
    }

    // If the line was configured in the 'Dial' dialog, then
    // we need to actually complete the configuration.
    if (g_lpDeviceConfig)
        lineSetDevConfig(g_dwDeviceID, g_lpDeviceConfig,
            g_dwSizeDeviceConfig, "comm/datamodem");

    // Start dialing the number
    if (DialCallInParts(lpLineDevCaps, g_szDialableAddress,
            g_szDisplayableAddress))
    {
        TSHELL_INFO(TEXT("DialCallInParts succeeded."));
    }
    else
    {

        TSHELL_INFO(TEXT("DialCallInParts failed."));

        HangupCall(__LINE__);
        goto DeleteBuffers;
    }


DeleteBuffers:

    if (lpLineAddressStatus)
        LocalFree(lpLineAddressStatus);
    if (lpLineDevCaps)
        LocalFree(lpLineDevCaps);

    return g_bTapiInUse;
}


//**************************************************
// These APIs are specific to this module
//**************************************************



//
//  FUNCTION: DialCallInParts(LPLINEDEVCAPS, LPCSTR, LPCSTR)
//
//  PURPOSE: Dials the call, handling special characters.
//
//  PARAMETERS:
//    lpLineDevCaps - LINEDEVCAPS for the line to be used.
//    lpszAddress   - Address to Dial.
//    lpszDisplayableAddress - Displayable Address.
//
//  RETURN VALUE:
//    Returns TRUE if we successfully Dial.
//
//  COMMENTS:
//
//    This function dials the Address and handles any
//    special characters in the address that the service provider
//    can't handle.  It requires input from the user to handle
//    these characters; this can cause problems for fully automated
//    dialing.
//
//    Note that we can return TRUE, even if we don't reach a
//    CONNECTED state.  DIalCallInParts returns as soon as the
//    Address is fully dialed or when an error occurs.
//
//

#ifdef WINNT
#define Xstrcspn strcspn
#else
//
// Source for strcspn here because it isn't in C10 std lib.
//
static size_t __cdecl Xstrcspn (
        const char * string,
        const char * control
        )
{
        const unsigned char *str = (const unsigned char *) string;
        const unsigned char *ctrl = (const unsigned char *) control;

        unsigned char map[32];
        int count;

        /* Clear out bit map */
        for (count=0; count<32; count++)
                map[count] = 0;

        /* Set bits in control map */
        while (*ctrl)
        {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
                ctrl++;
        }


        /* 1st char in control map stops search */
        count=0;
        map[0] |= 1;    /* null chars not considered */
        while (!(map[*str >> 3] & (1 << (*str & 7))))
        {
                count++;
                str++;
        }
        return(count);
}
#endif


BOOL DialCallInParts(LPLINEDEVCAPS lpLineDevCaps,
    LPCSTR lpszAddress, LPCSTR lpszDisplayableAddress)
{
    LPLINECALLPARAMS  lpCallParams = NULL;
    LPLINEADDRESSCAPS lpAddressCaps = NULL;
    LPLINECALLSTATUS  lpLineCallStatus = NULL;

    long lReturn;
    int i;
    DWORD dwDevCapFlags;
    char szFilter[1+sizeof(g_sNonDialable)] = "";
    BOOL bFirstDial = TRUE;

    // Variables to handle Dialable Substring dialing.
    LPSTR lpDS; // This is just so we can free lpszDialableSubstring later.
    LPSTR lpszDialableSubstring;
    int nAddressLength = 0;
    int nCurrentAddress = 0;
    char chUnhandledCharacter;

    // Get the capabilities for the line device we're going to use.
    lpAddressCaps = I_lineGetAddressCaps(lpAddressCaps,
        g_dwDeviceID, 0, g_dwAPIVersion, 0);

    if (lpAddressCaps == NULL)
        return FALSE;

    // Setup our CallParams for DATAMODEM settings.
    lpCallParams = CreateCallParams (lpCallParams, lpszDisplayableAddress);
    if (lpCallParams == NULL)
        return FALSE;

    // Determine which special characters the service provider
    // does *not* handle so we can handle them manually.
    // Keep list of unhandled characters in szFilter.

    dwDevCapFlags = lpLineDevCaps -> dwDevCapFlags;  // SP handled characters.
    for (i = 0; i < g_sizeofNonDialable ; i++)
    {
        if ((dwDevCapFlags & g_sNonDialable[i].dwDevCapFlag) == 0)
        {
            strcat(szFilter, g_sNonDialable[i].szToken);
        }
    }

    // szFilter now contains the set of tokens which delimit dialable substrings

    // Setup the strings for substring dialing.

    nAddressLength = strlen(lpszAddress);
    lpDS = lpszDialableSubstring = (LPSTR) LocalAlloc(LPTR, nAddressLength + 1);
    if (lpszDialableSubstring == NULL)
    {
        DBG_INFO((DBGARG, TEXT("LocalAlloc failed: %x"), GetLastError()));

        HandleNoMem();
        goto errExit;
    }

    // Lets start dialing substrings!
    while (nCurrentAddress < nAddressLength)
    {
  retryAfterError:

        // Find the next undialable character
        i = Xstrcspn(&lpszAddress[nCurrentAddress], szFilter);

        // Was there one before the end of the Address string?
        if (i + nCurrentAddress < nAddressLength)
        {
            // Make sure this device can handle partial dial.
            if (! (lpAddressCaps -> dwAddrCapFlags &
                   LINEADDRCAPFLAGS_PARTIALDIAL))
            {
                goto errExit;
            }
            // Remember what the unhandled character is so we can handle it.
            chUnhandledCharacter = lpszAddress[nCurrentAddress+i];

            // Copy the dialable string to the Substring.
            memcpy(lpszDialableSubstring, &lpszAddress[nCurrentAddress], i);

            // Terminate the substring with a ';' to signify the partial dial.
            lpszDialableSubstring[i] = ';';
            lpszDialableSubstring[i+1] = '\0';

            // Increment the address for next iteration.
            nCurrentAddress += i + 1;
        }
        else // No more partial dials.  Dial the rest of the Address.
        {
            lpszDialableSubstring = (LPSTR) &lpszAddress[nCurrentAddress];
            chUnhandledCharacter = 0;
            nCurrentAddress = nAddressLength;
        }

        do
        {
            if (bFirstDial)
            {
                DBG_INFO((DBGARG, TEXT("lineMakeCall %8s %8x"), lpszDialableSubstring, lpCallParams));

                lReturn = WaitForReply(
                    lineMakeCall(g_hLine, &g_hCall, lpszDialableSubstring,
                        0, lpCallParams) );

            }
            else
            {
                DBG_INFO((DBGARG, TEXT("lineDial %8x %8s"), g_hCall, lpszDialableSubstring));

                lReturn = WaitForReply(
                    lineDial(g_hCall, lpszDialableSubstring, 0) );
            }

            DBG_INFO((DBGARG, TEXT("LineDial return %8x"), lReturn));

            switch(lReturn)
            {
            // We should not have received these errors because of the
            // prefiltering strategy, but there may be some ill-behaved
            // service providers which do not correctly set their
            // devcapflags.  Add the character corresponding to the error
            // to the filter set and retry dialing.
            //
            case LINEERR_DIALBILLING:
            case LINEERR_DIALDIALTONE:
            case LINEERR_DIALQUIET:
            case LINEERR_DIALPROMPT:
                {

                    TSHELL_INFO(TEXT("Service Provider incorrectly sets dwDevCapFlags"));


                    for (i = 0; i < g_sizeofNonDialable; i++)
                        if (lReturn == g_sNonDialable[i].lError)
                        {
                            strcat(szFilter, g_sNonDialable[i].szToken);
                        }

                    goto retryAfterError;
                }

            case WAITERR_WAITABORTED:

                    TSHELL_INFO(TEXT("While Dialing, WaitForReply aborted."));

                    goto errExit;

            }

            if (HandleLineErr(lReturn))
                continue;
            else
            {
#ifdef DEBUG
                if (bFirstDial)
                    DBG_INFO((DBGARG, TEXT("lineMakeCall unhandled error: %x"), lReturn));
                else
                    DBG_INFO((DBGARG, TEXT("lineDial unhandled error: %x"), lReturn));
#endif
                TSHELL_INFO(TEXT("Error Exit!"));

                goto errExit;
            }

        }
        while (lReturn != SUCCESS);

        bFirstDial = FALSE;

        // The dial was successful; now handle characters the service
        // provider didn't (if any).
        if (chUnhandledCharacter)
        {
            LPSTR lpMsg = "";

            // First, wait until we know we can continue dialing.  While the
            // last string is still pending to be dialed, we can't dial another.

            while(TRUE)
            {

                lpLineCallStatus = I_lineGetCallStatus(lpLineCallStatus, g_hCall);
                if (lpLineCallStatus == NULL)
                    goto errExit;

                // Does CallStatus say we can dial now?
                if ((lpLineCallStatus->dwCallFeatures) & LINECALLFEATURE_DIAL)
                {

                    TSHELL_INFO(TEXT("Ok to continue dialing."));

                    break;
                }

                // We can't dial yet, so wait for a CALLSTATE message

                TSHELL_INFO(TEXT("Waiting for dialing to be enabled."));


                if (WaitForCallState(I_LINECALLSTATE_ANY) != SUCCESS)
                    goto errExit;
            }

            for (i = 0; i < g_sizeofNonDialable; i++)
                if (chUnhandledCharacter == g_sNonDialable[i].szToken[0])
                    lpMsg = g_sNonDialable[i].szMsg;

            TCHAR   achTitle[MAX_PATH];

            LoadString(hInst, IDS_DIALDIALOG, achTitle, MAX_PATH);

            MessageBox(g_hDlgParentWindow, lpMsg, achTitle, MB_OK);
        }

    } // continue dialing until we dial all Dialable Substrings.

    LocalFree(lpCallParams);
    LocalFree(lpDS);
    LocalFree(lpAddressCaps);
    if (lpLineCallStatus)
        LocalFree(lpLineCallStatus);

    return TRUE;

  errExit:
        // if lineMakeCall has already been successfully called, there's a call in progress.
        // let the invoking routine shut down the call.
        // if the invoker did not clean up the call, it should be done here.

    if (lpLineCallStatus)
        LocalFree(lpLineCallStatus);
    if (lpDS)
        LocalFree(lpDS);
    if (lpCallParams)
        LocalFree(lpCallParams);
    if (lpAddressCaps)
        LocalFree(lpAddressCaps);

    return FALSE;
}


//
//  FUNCTION: CreateCallParams(LPLINECALLPARAMS, LPCSTR)
//
//  PURPOSE: Allocates and fills a LINECALLPARAMS structure
//
//  PARAMETERS:
//    lpCallParams -
//    lpszDisplayableAddress -
//
//  RETURN VALUE:
//    Returns a LPLINECALLPARAMS ready to use for dialing DATAMODEM calls.
//    Returns NULL if unable to allocate the structure.
//
//  COMMENTS:
//
//    If a non-NULL lpCallParams is passed in, it must have been allocated
//    with LocalAlloc, and can potentially be freed and reallocated.  It must
//    also have the dwTotalSize field correctly set.
//
//

LPLINECALLPARAMS CreateCallParams (
    LPLINECALLPARAMS lpCallParams, LPCSTR lpszDisplayableAddress)
{
    size_t sizeDisplayableAddress;

    if (lpszDisplayableAddress == NULL)
        lpszDisplayableAddress = "";

    sizeDisplayableAddress = strlen(lpszDisplayableAddress) + 1;

    lpCallParams = (LPLINECALLPARAMS) CheckAndReAllocBuffer(
        (LPVOID) lpCallParams,
        sizeof(LINECALLPARAMS) + sizeDisplayableAddress,
        TEXT("CreateCallParams: "));

    if (lpCallParams == NULL)
        return NULL;

    // This is where we configure the line for DATAMODEM usage.
    lpCallParams -> dwBearerMode = LINEBEARERMODE_VOICE;
    lpCallParams -> dwMediaMode  = LINEMEDIAMODE_DATAMODEM;

    // This specifies that we want to use only IDLE calls and
    // don't want to cut into a call that might not be IDLE (ie, in use).
    lpCallParams -> dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;

    // if there are multiple addresses on line, use first anyway.
    // It will take a more complex application than a simple tty app
    // to use multiple addresses on a line anyway.
    lpCallParams -> dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    lpCallParams -> dwAddressID = 0;

    // Since we don't know where we originated, leave these blank.
    lpCallParams -> dwOrigAddressSize = 0;
    lpCallParams -> dwOrigAddressOffset = 0;

    // Unimodem ignores these values.
    (lpCallParams -> DialParams) . dwDialSpeed = 0;
    (lpCallParams -> DialParams) . dwDigitDuration = 0;
    (lpCallParams -> DialParams) . dwDialPause = 0;
    (lpCallParams -> DialParams) . dwWaitForDialtone = 0;

    // Address we are dialing.
    lpCallParams -> dwDisplayableAddressOffset = sizeof(LINECALLPARAMS);
    lpCallParams -> dwDisplayableAddressSize = sizeDisplayableAddress;
    strcpy((LPSTR)lpCallParams + sizeof(LINECALLPARAMS),
           lpszDisplayableAddress);

    return lpCallParams;
}


//
//  FUNCTION: long WaitForReply(long)
//
//  PURPOSE: Resynchronize by waiting for a LINE_REPLY
//
//  PARAMETERS:
//    lRequestID - The asynchronous request ID that we're
//                 on a LINE_REPLY for.
//
//  RETURN VALUE:
//    - 0 if LINE_REPLY responded with a success.
//    - LINEERR constant if LINE_REPLY responded with a LINEERR
//    - 1 if the line was shut down before LINE_REPLY is received.
//
//  COMMENTS:
//
//    This function allows us to resynchronize an asynchronous
//    TAPI line call by waiting for the LINE_REPLY message.  It
//    waits until a LINE_REPLY is received or the line is shut down.
//
//    Note that this could cause re-entrancy problems as
//    well as mess with any message preprocessing that might
//    occur on this thread (such as TranslateAccelerator).
//
//    This function should to be called from the thread that did
//    lineInitialize, or the PeekMessage is on the wrong thread
//    and the synchronization is not guaranteed to work.  Also note
//    that if another PeekMessage loop is entered while waiting,
//    this could also cause synchronization problems.
//
//    One more note.  This function can potentially be re-entered
//    if the call is dropped for any reason while waiting.  If this
//    happens, just drop out and assume the wait has been canceled.
//    This is signaled by setting bReentered to FALSE when the function
//    is entered and TRUE when it is left.  If bReentered is ever TRUE
//    during the function, then the function was re-entered.
//
//    This function times out and returns WAITERR_WAITTIMEDOUT
//    after WAITTIMEOUT milliseconds have elapsed.
//
//


long WaitForReply (long lRequestID)
{
    static BOOL bReentered;
    bReentered = FALSE;

    if (lRequestID > SUCCESS)
    {
        MSG msg;
        DWORD dwTimeStarted;

        g_bReplyRecieved = FALSE;
        g_dwRequestedID = (DWORD) lRequestID;

        // Initializing this just in case there is a bug
        // that sets g_bReplyRecieved without setting the reply value.
        g_lAsyncReply = LINEERR_OPERATIONFAILED;

        dwTimeStarted = GetTickCount();

        while(!g_bReplyRecieved)
        {
            if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // This should only occur if the line is shut down while waiting.
            if (!g_bTapiInUse || bReentered)
            {
                bReentered = TRUE;
                return WAITERR_WAITABORTED;
            }

            // Its a really bad idea to timeout a wait for a LINE_REPLY.
            // If we are execting a LINE_REPLY, we should wait till we get
            // it; it might take a long time to dial (for example).

            // If 5 seconds go by without a reply, it might be a good idea
            // to display a dialog box to tell the user that a
            // wait is in progress and to give the user the capability to
            // abort the wait.
        }

        bReentered = TRUE;
        return g_lAsyncReply;
    }

    bReentered = TRUE;
    return lRequestID;
}


//
//  FUNCTION: long WaitForCallState(DWORD)
//
//  PURPOSE: Wait for the line to reach a specific CallState.
//
//  PARAMETERS:
//    dwDesiredCallState - specific CallState to wait for.
//
//  RETURN VALUE:
//    Returns 0 (SUCCESS) when we reach the Desired CallState.
//    Returns WAITERR_WAITTIMEDOUT if timed out.
//    Returns WAITERR_WAITABORTED if call was closed while waiting.
//
//  COMMENTS:
//
//    This function allows us to synchronously wait for a line
//    to reach a specific LINESTATE or until the line is shut down.
//
//    Note that this could cause re-entrancy problems as
//    well as mess with any message preprocessing that might
//    occur on this thread (such as TranslateAccelerator).
//
//    One more note.  This function can potentially be re-entered
//    if the call is dropped for any reason while waiting.  If this
//    happens, just drop out and assume the wait has been canceled.
//    This is signaled by setting bReentered to FALSE when the function
//    is entered and TRUE when it is left.  If bReentered is ever TRUE
//    during the function, then the function was re-entered.
//
//    This function should to be called from the thread that did
//    lineInitialize, or the PeekMessage is on the wrong thread
//    and the synchronization is not guaranteed to work.  Also note
//    that if another PeekMessage loop is entered while waiting,
//    this could also cause synchronization problems.
//
//    If the constant value I_LINECALLSTATE_ANY is used for the
//    dwDesiredCallState, then WaitForCallState will return SUCCESS
//    upon receiving any CALLSTATE messages.
//
//
//

long WaitForCallState(DWORD dwDesiredCallState)
{
    MSG msg;
    DWORD dwTimeStarted;
    static BOOL bReentered;

    bReentered = FALSE;

    dwTimeStarted = GetTickCount();

    g_bCallStateReceived = FALSE;

    while ((dwDesiredCallState == I_LINECALLSTATE_ANY) ||
           (g_dwCallState != dwDesiredCallState))
    {
        if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        // If we are waiting for any call state and get one, succeed.
        if ((dwDesiredCallState == I_LINECALLSTATE_ANY) &&
            g_bCallStateReceived)
        {
            break;
        }

        // This should only occur if the line is shut down while waiting.
        if (!g_bTapiInUse || bReentered)
        {
            bReentered = TRUE;

            TSHELL_INFO(TEXT("WAITABORTED"));

            return WAITERR_WAITABORTED;
        }

        // If we don't get the reply in a reasonable time, we time out.
        if (GetTickCount() - dwTimeStarted > WAITTIMEOUT)
        {
            bReentered = TRUE;

            TSHELL_INFO(TEXT("WAITTIMEDOUT"));

            return WAITERR_WAITTIMEDOUT;
        }

    }

    bReentered = TRUE;
    return SUCCESS;
}

//**************************************************
// lineCallback Function and Handlers.
//**************************************************


//
//  FUNCTION: lineCallbackFunc(..)
//
//  PURPOSE: Receive asynchronous TAPI events
//
//  PARAMETERS:
//    dwDevice  - Device associated with the event, if any
//    dwMsg     - TAPI event that occurred.
//    dwCallbackInstance - User defined data supplied when opening the line.
//    dwParam1  - dwMsg specific information
//    dwParam2  - dwMsg specific information
//    dwParam3  - dwMsg specific information
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This is the function where all asynchronous events will come.
//    Almost all events will be specific to an open line, but a few
//    will be general TAPI events (such as LINE_REINIT).
//
//    Its important to note that this callback will *ALWAYS* be
//    called in the context of the thread that does the lineInitialize.
//    Even if another thread (such as the COMM threads) calls the API
//    that would result in the callback being called, it will be called
//    in the context of the main thread (since in this sample, the main
//    thread does the lineInitialize).
//
//


void CALLBACK lineCallbackFunc(
    DWORD dwDevice, DWORD dwMsg, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{

#ifdef DEBUG
    OutputDebugLineCallback(
        dwDevice, dwMsg, dwCallbackInstance,
        dwParam1, dwParam2, dwParam3);
#endif

    // All we do is dispatch the dwMsg to the correct handler.
    switch(dwMsg)
    {
        case LINE_CALLSTATE:
            DoLineCallState(dwDevice, dwMsg, dwCallbackInstance,
                dwParam1, dwParam2, dwParam3);
            break;

        case LINE_CLOSE:
            DoLineClose(dwDevice, dwMsg, dwCallbackInstance,
                dwParam1, dwParam2, dwParam3);
            break;

        case LINE_LINEDEVSTATE:
            DoLineDevState(dwDevice, dwMsg, dwCallbackInstance,
                dwParam1, dwParam2, dwParam3);
            break;

        case LINE_REPLY:
            DoLineReply(dwDevice, dwMsg, dwCallbackInstance,
                dwParam1, dwParam2, dwParam3);
            break;

        case LINE_CREATE:
            DoLineCreate(dwDevice, dwMsg, dwCallbackInstance,
                dwParam1, dwParam2, dwParam3);
            break;

    default:

            TSHELL_INFO(TEXT("lineCallbackFunc message ignored"));

            break;

    }

    return;

}


//
//  FUNCTION: DoLineReply(..)
//
//  PURPOSE: Handle LINE_REPLY asynchronous messages.
//
//  PARAMETERS:
//    dwDevice  - Line Handle associated with this LINE_REPLY.
//    dwMsg     - Should always be LINE_REPLY.
//    dwCallbackInstance - Unused by this sample.
//    dwParam1  - Asynchronous request ID.
//    dwParam2  - success or LINEERR error value.
//    dwParam3  - Unused.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    All line API calls that return an asynchronous request ID
//    will eventually cause a LINE_REPLY message.  Handle it.
//
//    This sample assumes only one call at time, and that we wait
//    for a LINE_REPLY before making any other line API calls.
//
//    The only exception to the above is that we might shut down
//    the line before receiving a LINE_REPLY.
//
//

void DoLineReply(
    DWORD dwDevice, DWORD dwMessage, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{

#ifdef DEBUG
    if ((long) dwParam2 != SUCCESS)
        DBG_INFO((DBGARG, TEXT("LINE_REPLY error: %x"), (long) dwParam2));
    else
        TSHELL_INFO(TEXT("LINE_REPLY: successfully replied."));
#endif

    // If we are currently waiting for this async Request ID
    // then set the global variables to acknowledge it.
    if (g_dwRequestedID == dwParam1)
    {
        g_bReplyRecieved = TRUE;
        g_lAsyncReply = (long) dwParam2;
    }
}


//
//  FUNCTION: DoLineClose(..)
//
//  PURPOSE: Handle LINE_CLOSE asynchronous messages.
//
//  PARAMETERS:
//    dwDevice  - Line Handle that was closed.
//    dwMsg     - Should always be LINE_CLOSE.
//    dwCallbackInstance - Unused by this sample.
//    dwParam1  - Unused.
//    dwParam2  - Unused.
//    dwParam3  - Unused.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This message is sent when something outside our app shuts
//    down a line in use.
//
//    The hLine (and any hCall on this line) are no longer valid.
//
//

void DoLineClose(
    DWORD dwDevice, DWORD dwMessage, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
    // Line has been shut down.  Clean up our internal variables.
    g_hLine = NULL;
    g_hCall = NULL;
    HangupCall(__LINE__);
}


//
//  FUNCTION: DoLineDevState(..)
//
//  PURPOSE: Handle LINE_LINEDEVSTATE asynchronous messages.
//
//  PARAMETERS:
//    dwDevice  - Line Handle that was closed.
//    dwMsg     - Should always be LINE_LINEDEVSTATE.
//    dwCallbackInstance - Unused by this sample.
//    dwParam1  - LINEDEVSTATE constant.
//    dwParam2  - Depends on dwParam1.
//    dwParam3  - Depends on dwParam1.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    The LINE_LINEDEVSTATE message is received if the state of the line
//    changes.  Examples are RINGING, MAINTENANCE, MSGWAITON.  Very few of
//    these are relevant to this sample.
//
//    Assuming that any LINEDEVSTATE that removes the line from use by TAPI
//    will also send a LINE_CLOSE message.
//
//

void DoLineDevState(
    DWORD dwDevice, DWORD dwMessage, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
    switch(dwParam1)
    {
    case LINEDEVSTATE_RINGING:

            TSHELL_INFO(TEXT("Line Ringing."));

            break;

        case LINEDEVSTATE_REINIT:
        // This is an important case!  Usually means that a service provider
        // has changed in such a way that requires TAPI to REINIT.
        // Note that there are both 'soft' REINITs and 'hard' REINITs.
        // Soft REINITs don't actually require a full shutdown but is instead
        // just an informational change that historically required a REINIT
        // to force the application to deal with.  TAPI API Version 1.3 apps
        // will still need to do a full REINIT for both hard and soft REINITs.

            switch(dwParam2)
            {
                // This is the hard REINIT.  No reason given, just REINIT.
                // TAPI is waiting for everyone to shutdown.
                // Our response is to immediately shutdown any calls,
                // shutdown our use of TAPI and notify the user.
                case 0:
                    ShutdownTAPI();
                    TSHELL_INFO(TEXT("Tapi line configuration has changed."));
                    break;

            case LINE_CREATE:

                    TSHELL_INFO(TEXT("Soft REINIT: LINE_CREATE."));

                    DoLineCreate(dwDevice, (DWORD)dwParam2, dwCallbackInstance,
                        dwParam3, 0, 0);
                    break;

            case LINE_LINEDEVSTATE:

                    TSHELL_INFO(TEXT("Soft REINIT: LINE_LINEDEVSTATE."));

                    DoLineDevState(dwDevice, (DWORD)dwParam2, dwCallbackInstance,
                        dwParam3, 0, 0);
                    break;

                // There might be other reasons to send a soft reinit.
                // No need to to shutdown for these.
            default:

                    TSHELL_INFO(TEXT("Ignoring soft REINIT"));

                    break;
            }
            break;

        case LINEDEVSTATE_OUTOFSERVICE:
            TSHELL_INFO(TEXT("Line selected is now Out of Service."));
            HangupCall(__LINE__);
            break;

        case LINEDEVSTATE_DISCONNECTED:
            TSHELL_INFO(TEXT("Line selected is now disconnected."));
            HangupCall(__LINE__);
            break;

        case LINEDEVSTATE_MAINTENANCE:
            TSHELL_INFO(TEXT("Line selected is now out for maintenance."));
            HangupCall(__LINE__);
            break;

        case LINEDEVSTATE_TRANSLATECHANGE:
            if (g_hDialog)
                PostMessage(g_hDialog, WM_COMMAND, IDC_CONFIGURATIONCHANGED, 0);
            break;

        case LINEDEVSTATE_REMOVED:

            TSHELL_INFO(TEXT("A Line device has been removed;")
                " no action taken.");

            break;

        default:
            TSHELL_INFO(TEXT("Unhandled LINEDEVSTATE message"));
    }
}


//
//  FUNCTION: DoLineCreate(..)
//
//  PURPOSE: Handle LINE_LINECREATE asynchronous messages.
//
//  PARAMETERS:
//    dwDevice  - Unused.
//    dwMsg     - Should always be LINE_CREATE.
//    dwCallbackInstance - Unused.
//    dwParam1  - dwDeviceID of new Line created.
//    dwParam2  - Unused.
//    dwParam3  - Unused.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This message is new for Windows 95.  It is sent when a new line is
//    added to the system.  This allows us to handle new lines without having
//    to REINIT.  This allows for much more graceful Plug and Play.
//
//    This sample just changes the number of devices available and can use
//    it next time a call is made.  It also tells the "Dial" dialog.
//
//

void DoLineCreate(
    DWORD dwDevice, DWORD dwMessage, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
    // dwParam1 is the Device ID of the new line.
    // Add one to get the number of total devices.
    if (g_dwNumDevs <= dwParam1)
        g_dwNumDevs = (DWORD)dwParam1+1;
    if (g_hDialog)
        PostMessage(g_hDialog, WM_COMMAND, IDC_LINECREATE, 0);

}


//
//  FUNCTION: DoLineCallState(..)
//
//  PURPOSE: Handle LINE_CALLSTATE asynchronous messages.
//
//  PARAMETERS:
//    dwDevice  - Handle to Call who's state is changing.
//    dwMsg     - Should always be LINE_CALLSTATE.
//    dwCallbackInstance - Unused by this sample.
//    dwParam1  - LINECALLSTATE constant specifying state change.
//    dwParam2  - Specific to dwParam1.
//    dwParam3  - LINECALLPRIVILEGE change, if any.
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This message is received whenever a call changes state.  Lots of
//    things we do, ranging from notifying the user to closing the line
//    to actually connecting to the target of our phone call.
//
//    What we do is usually obvious based on the call state change.
//

void DoLineCallState(
    DWORD dwDevice, DWORD dwMessage, DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
    LONG    lErr;


    // This sets the global g_dwCallState variable so if we are waiting
    // for a specific call state change, we will know when it happens.
    g_dwCallState = (DWORD)dwParam1;
    g_bCallStateReceived = TRUE;

    // dwParam3 contains changes to LINECALLPRIVILEGE, if there are any.
    switch (dwParam3)
    {
        case 0:
            break; // no change to call state

         // close line if we are made monitor.  Shouldn't happen!
    case LINECALLPRIVILEGE_MONITOR:

            TSHELL_INFO(TEXT("line given monitor privilege; closing"));

            HangupCall(__LINE__);
            return;

         // close line if we are made owner.  Shouldn't happen!
    case LINECALLPRIVILEGE_OWNER:

            TSHELL_INFO(TEXT("line given owner privilege; Ready to Answer"));

            break;

    default: // Shouldn't happen!  All cases handled.

            TSHELL_INFO(TEXT("Unknown LINECALLPRIVILEGE message: closing"));

            HangupCall(__LINE__);
            return;
    }

    // dwParam1 is the specific CALLSTATE change that is occurring.
    switch (dwParam1)
    {
    case LINECALLSTATE_OFFERING:

            TSHELL_INFO(TEXT("Line Offered"));

            g_hCall = (HCALL) dwDevice;
            lErr = lineAccept(g_hCall, NULL, 0);

#ifdef DEBUG
            if (lErr < 0)
                TSHELL_INFO(TEXT("lineAccept in Offering failed."));
#endif

            lErr = lineAnswer(g_hCall, NULL, 0);

#ifdef DEBUG
            if (lErr < 0)
                TSHELL_INFO(TEXT("lineAnswer in Offering failed."));
#endif

            break;

    case LINECALLSTATE_ACCEPTED:

            TSHELL_INFO(TEXT("Line Accepted"));

            g_hCall = (HCALL) dwDevice;
            lErr = lineAnswer(g_hCall, NULL, 0);
#ifdef DEBUG
            if (lErr < 0)
                TSHELL_INFO(TEXT("lineAnswer in Accepted failed."));
#endif

            break;

    case LINECALLSTATE_DIALTONE:

            TSHELL_INFO(TEXT("Dial Tone"));

            break;

    case LINECALLSTATE_DIALING:

            TSHELL_INFO(TEXT("Dialing"));

            break;

    case LINECALLSTATE_PROCEEDING:

            TSHELL_INFO(TEXT("Proceeding"));

            break;

    case LINECALLSTATE_RINGBACK:

            TSHELL_INFO(TEXT("RingBack"));

            break;

    case LINECALLSTATE_BUSY:

            TSHELL_INFO(TEXT("Line busy, shutting down"));

            HangupCall(__LINE__);
            if (g_hConnectionEvent)
                SetEvent(g_hConnectionEvent);
            break;

    case LINECALLSTATE_IDLE:

            TSHELL_INFO(TEXT("Line idle"));

            HangupCall(__LINE__);
            if (g_hConnectionEvent)
                SetEvent(g_hConnectionEvent);
            break;

    case LINECALLSTATE_SPECIALINFO:

            TSHELL_INFO(
                TEXT("Special Info, probably couldn't dial number"));

            HangupCall(__LINE__);
            if (g_hConnectionEvent)
                SetEvent(g_hConnectionEvent);
            break;

        case LINECALLSTATE_DISCONNECTED:
        {
            LPTSTR pszReasonDisconnected;

            switch (dwParam2)
            {
                case LINEDISCONNECTMODE_NORMAL:
                    pszReasonDisconnected = TEXT("Remote Party Disconnected");
                    break;

                case LINEDISCONNECTMODE_UNKNOWN:
                    pszReasonDisconnected = TEXT("Disconnected: Unknown reason");
                    break;

                case LINEDISCONNECTMODE_REJECT:
                    pszReasonDisconnected = TEXT("Remote Party rejected call");
                    break;

                case LINEDISCONNECTMODE_PICKUP:
                    pszReasonDisconnected =
                        TEXT("Disconnected: Local phone picked up");
                    break;

                case LINEDISCONNECTMODE_FORWARDED:
                    pszReasonDisconnected = TEXT("Disconnected: Forwarded");
                    break;

                case LINEDISCONNECTMODE_BUSY:
                    pszReasonDisconnected = TEXT("Disconnected: Busy");
                    break;

                case LINEDISCONNECTMODE_NOANSWER:
                    pszReasonDisconnected = TEXT("Disconnected: No Answer");
                    break;

                case LINEDISCONNECTMODE_BADADDRESS:
                    pszReasonDisconnected = TEXT("Disconnected: Bad Address");
                    break;

                case LINEDISCONNECTMODE_UNREACHABLE:
                    pszReasonDisconnected = TEXT("Disconnected: Unreachable");
                    break;

                case LINEDISCONNECTMODE_CONGESTION:
                    pszReasonDisconnected = TEXT("Disconnected: Congestion");
                    break;

                case LINEDISCONNECTMODE_INCOMPATIBLE:
                    pszReasonDisconnected = TEXT("Disconnected: Incompatible");
                    break;

                case LINEDISCONNECTMODE_UNAVAIL:
                    pszReasonDisconnected = TEXT("Disconnected: Unavail");
                    break;

                case LINEDISCONNECTMODE_NODIALTONE:
                    pszReasonDisconnected = TEXT("Disconnected: No Dial Tone");
                    break;

                default:
                    pszReasonDisconnected =
                        TEXT("Disconnected: LINECALLSTATE; Bad Reason");
                    break;

            }


            TSHELL_INFO(pszReasonDisconnected);

            PostHangupCall();
            if (g_hConnectionEvent)
                SetEvent(g_hConnectionEvent);
            break;
        }


        case LINECALLSTATE_CONNECTED:  // CONNECTED!!!
        {
            LPVARSTRING lpVarString = NULL;
            DWORD dwSizeofVarString = sizeof(VARSTRING) + 128;
            HANDLE hCommFile = NULL;
            long lReturn;

            // Very first, make sure this isn't a duplicated message.
            // A CALLSTATE message can be sent whenever there is a
            // change to the capabilities of a line, meaning that it is
            // possible to receive multiple CONNECTED messages per call.
            // The CONNECTED CALLSTATE message is the only one in TapiComm
            // where it would cause problems if it where sent more
            // than once.

            if (g_bConnected)
                break;

            g_bConnected = TRUE;

            // Get the handle to the comm port from the driver so we can start
            // communicating.  This is returned in a LPVARSTRING structure.
            do
            {
                // Allocate the VARSTRING structure
                lpVarString = (LPVARSTRING) CheckAndReAllocBuffer((LPVOID) lpVarString,
                    dwSizeofVarString, TEXT("lineGetID: "));

                if (lpVarString == NULL)
                    goto ErrorConnecting;

                // Fill the VARSTRING structure
                lReturn = lineGetID(0, 0, g_hCall, LINECALLSELECT_CALL,
                    lpVarString, "comm/datamodem");

                if (HandleLineErr(lReturn))
                    ; // Still need to check if structure was big enough.
                else
                {
                    DBG_INFO((DBGARG, TEXT("lineGetID unhandled error: %x"), lReturn));

                    goto ErrorConnecting;
                }

                // If the VARSTRING wasn't big enough, loop again.
                if ((lpVarString -> dwNeededSize) > (lpVarString -> dwTotalSize))
                {
                    dwSizeofVarString = lpVarString -> dwNeededSize;
                    lReturn = -1; // Lets loop again.
                }
            }
            while(lReturn != SUCCESS);


            TSHELL_INFO(TEXT("Connected!  Starting communications!"));


            // Again, the handle to the comm port is contained in a
            // LPVARSTRING structure.  Thus, the handle is the very first
            // thing after the end of the structure.  Note that the name of
            // the comm port is right after the handle, but I don't want it.
            hCommFile =
                *((LPHANDLE)((LPBYTE)lpVarString +
                    lpVarString -> dwStringOffset));

            // Started communications!
            LPLINECALLINFO lpCInfo;

            lpCInfo = NULL;
            lpCInfo = I_lineGetCallInfo(lpCInfo);
            if (lpCInfo)
            {
                g_dwRate = lpCInfo->dwRate;
                LocalFree(lpCInfo);
            }
            if (StartComm(hCommFile, g_hConnectionEvent))
            {
                LocalFree(lpVarString);
                break;
            }

            // Couldn't start communications.  Clean up instead.
          ErrorConnecting:

            // Its very important that we close all Win32 handles.
            // The CommCode module is responsible for closing the hCommFile
            // handle if it succeeds in starting communications.
            if (hCommFile)
                CloseHandle(hCommFile);

            HangupCall(__LINE__);

            if (lpVarString)
                LocalFree(lpVarString);

            break;
        }

            default:

            TSHELL_INFO(TEXT("Unhandled LINECALLSTATE message"));

            break;
    }
}

//**************************************************
// line API Wrapper Functions.
//**************************************************


//
//  FUNCTION: LPVOID CheckAndReAllocBuffer(LPVOID, size_t, LPCSTR)
//
//  PURPOSE: Checks and ReAllocates a buffer if necessary.
//
//  PARAMETERS:
//    lpBuffer          - Pointer to buffer to be checked.  Can be NULL.
//    sizeBufferMinimum - Minimum size that lpBuffer should be.
//    szApiPhrase       - Phrase to print if an error occurs.
//
//  RETURN VALUE:
//    Returns a pointer to a valid buffer that is guarenteed to be
//    at least sizeBufferMinimum size.
//    Returns NULL if an error occured.
//
//  COMMENTS:
//
//    This function is a helper function intended to make all of the
//    line API Wrapper Functions much simplier.  It allocates (or
//    reallocates) a buffer of the requested size.
//
//    The returned pointer has been allocated with LocalAlloc,
//    so LocalFree has to be called on it when you're finished with it,
//    or there will be a memory leak.
//
//    Similarly, if a pointer is passed in, it *must* have been allocated
//    with LocalAlloc and it could potentially be LocalFree()d.
//
//    If lpBuffer == NULL, then a new buffer is allocated.  It is
//    normal to pass in NULL for this parameter the first time and only
//    pass in a pointer if the buffer needs to be reallocated.
//
//    szApiPhrase is used only for debugging purposes.
//
//    It is assumed that the buffer returned from this function will be used
//    to contain a variable sized structure.  Thus, the dwTotalSize field
//    is always filled in before returning the pointer.
//
//

LPVOID CheckAndReAllocBuffer(
    LPVOID lpBuffer, size_t sizeBufferMinimum, LPTCH szApiPhrase)
{
    size_t sizeBuffer;

    if (lpBuffer == NULL)  // Allocate the buffer if necessary.
    {
        sizeBuffer = sizeBufferMinimum;
        lpBuffer = (LPVOID) LocalAlloc(LPTR, sizeBuffer);

        if (lpBuffer == NULL)
        {
            DBG_INFO((DBGARG, TEXT("%s, LocalAlloc : %x"), szApiPhrase, GetLastError()));
            HandleNoMem();
            return NULL;
        }
    }
    else // If the structure already exists, make sure its good.
    {
        sizeBuffer = LocalSize((HLOCAL) lpBuffer);

        if (sizeBuffer == 0) // Bad pointer?
        {
            DBG_INFO((DBGARG, TEXT("%s, LocalSize : %x"), szApiPhrase, GetLastError()));
            return NULL;
        }

        // Was the buffer big enough for the structure?
        if (sizeBuffer < sizeBufferMinimum)
        {
            DBG_INFO((DBGARG, TEXT("%s, Reallocating structure"), szApiPhrase));
            LocalFree(lpBuffer);
            return CheckAndReAllocBuffer(NULL, sizeBufferMinimum, szApiPhrase);
        }

        // Lets zero the buffer out.
        memset(lpBuffer, 0, sizeBuffer);
    }

    ((LPVARSTRING) lpBuffer ) -> dwTotalSize = (DWORD) sizeBuffer;
    return lpBuffer;
}



//
//  FUNCTION: DWORD I_lineNegotiateAPIVersion(DWORD)
//
//  PURPOSE: Negotiate an API Version to use for a specific device.
//
//  PARAMETERS:
//    dwDeviceID - device to negotiate an API Version for.
//
//  RETURN VALUE:
//    Returns the API Version to use for this line if successful.
//    Returns 0 if negotiations fall through.
//
//  COMMENTS:
//
//    This wrapper function not only negotiates the API, but handles
//    LINEERR errors that can occur while negotiating.
//
//

DWORD I_lineNegotiateAPIVersion(DWORD dwDeviceID)
{
    LINEEXTENSIONID LineExtensionID;
    long lReturn;
    DWORD dwLocalAPIVersion;

    do
    {
        lReturn = lineNegotiateAPIVersion(g_hLineApp, dwDeviceID,
            SAMPLE_TAPI_VERSION, SAMPLE_TAPI_VERSION,
            &dwLocalAPIVersion, &LineExtensionID);

        // DBG_INFO((DBGARG, TEXT("version %8x, %8x, %8x %8x return %8x"),
        //    SAMPLE_TAPI_VERSION, SAMPLE_TAPI_VERSION,
        //    dwLocalAPIVersion, LineExtensionID, lReturn));

        if (lReturn == LINEERR_INCOMPATIBLEAPIVERSION)
        {

            TSHELL_INFO(TEXT("lineNegotiateAPIVersion, INCOMPATIBLEAPIVERSION."));

            return 0;
        }

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineNegotiateAPIVersion unhandled error: %x"), lReturn));
            return 0;
        }
    }
    while(lReturn != SUCCESS);

    return dwLocalAPIVersion;
}


//
//  FUNCTION: I_lineGetDevCaps(LPLINEDEVCAPS, DWORD , DWORD)
//
//  PURPOSE: Retrieve a LINEDEVCAPS structure for the specified line.
//
//  PARAMETERS:
//    lpLineDevCaps - Pointer to a LINEDEVCAPS structure to use.
//    dwDeviceID    - device to get the DevCaps for.
//    dwAPIVersion  - API Version to use while getting DevCaps.
//
//  RETURN VALUE:
//    Returns a pointer to a LINEDEVCAPS structure if successful.
//    Returns NULL if unsuccessful.
//
//  COMMENTS:
//
//    This function is a wrapper around lineGetDevCaps to make it easy
//    to handle the variable sized structure and any errors received.
//
//    The returned structure has been allocated with LocalAlloc,
//    so LocalFree has to be called on it when you're finished with it,
//    or there will be a memory leak.
//
//    Similarly, if a lpLineDevCaps structure is passed in, it *must*
//    have been allocated with LocalAlloc and it could potentially be
//    LocalFree()d.
//
//    If lpLineDevCaps == NULL, then a new structure is allocated.  It is
//    normal to pass in NULL for this parameter unless you want to use a
//    lpLineDevCaps that has been returned by a previous I_lineGetDevCaps
//    call.
//
//

LPLINECALLINFO I_lineGetCallInfo(LPLINECALLINFO lpLineCallInfo)
{
    size_t sizeofLineCallInfo = sizeof(LINECALLINFO) + 128;
    long lReturn;

    // Continue this loop until the structure is big enough.
    while(TRUE)
    {
        // Make sure the buffer exists, is valid and big enough.
        lpLineCallInfo =
            (LPLINECALLINFO) CheckAndReAllocBuffer(
                (LPVOID) lpLineCallInfo, // Pointer to existing buffer, if any
                sizeofLineCallInfo,      // Minimum size the buffer should be
                TEXT("lineCallInfo"));      // Phrase to tag errors, if any.

        if (lpLineCallInfo == NULL)
            return NULL;

        // Make the call to fill the structure.
        do
        {
            lReturn =
                lineGetCallInfo(g_hCall, lpLineCallInfo);

            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineGetCallInfo unhandled error: %x"), lReturn));

                LocalFree(lpLineCallInfo);
                return NULL;
            }
        }
        while (lReturn != SUCCESS);

        // If the buffer was big enough, then succeed.
        if ((lpLineCallInfo -> dwNeededSize) <= (lpLineCallInfo -> dwTotalSize))
            return lpLineCallInfo;

        // Buffer wasn't big enough.  Make it bigger and try again.
        sizeofLineCallInfo = lpLineCallInfo->dwNeededSize;
    }
}


LPLINEDEVCAPS I_lineGetDevCaps(
    LPLINEDEVCAPS lpLineDevCaps,
    DWORD dwDeviceID, DWORD dwAPIVersion)
{
    size_t sizeofLineDevCaps = sizeof(LINEDEVCAPS) + 128;
    long lReturn;

    // Continue this loop until the structure is big enough.
    while(TRUE)
    {
        // Make sure the buffer exists, is valid and big enough.
        lpLineDevCaps =
            (LPLINEDEVCAPS) CheckAndReAllocBuffer(
                (LPVOID) lpLineDevCaps, // Pointer to existing buffer, if any
                sizeofLineDevCaps,      // Minimum size the buffer should be
                TEXT("lineGetDevCaps"));      // Phrase to tag errors, if any.

        if (lpLineDevCaps == NULL)
            return NULL;

        // Make the call to fill the structure.
        do
        {
            lReturn =
                lineGetDevCaps(g_hLineApp,
                    dwDeviceID, dwAPIVersion, 0, lpLineDevCaps);

            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineGetDevCaps unhandled error: %x"), lReturn));

                LocalFree(lpLineDevCaps);
                return NULL;
            }
        }
        while (lReturn != SUCCESS);

        // If the buffer was big enough, then succeed.
        if ((lpLineDevCaps -> dwNeededSize) <= (lpLineDevCaps -> dwTotalSize))
            return lpLineDevCaps;

        // Buffer wasn't big enough.  Make it bigger and try again.
        sizeofLineDevCaps = lpLineDevCaps -> dwNeededSize;
    }
}



//
//  FUNCTION: I_lineGetAddressStatus(LPLINEADDRESSSTATUS, HLINE, DWORD)
//
//  PURPOSE: Retrieve a LINEADDRESSSTATUS structure for the specified line.


//
//  PARAMETERS:
//    lpLineAddressStatus - Pointer to a LINEADDRESSSTATUS structure to use.
//    hLine       - Handle of line to get the AddressStatus of.
//    dwAddressID - Address ID on the hLine to be used.
//
//  RETURN VALUE:
//    Returns a pointer to a LINEADDRESSSTATUS structure if successful.
//    Returns NULL if unsuccessful.
//
//  COMMENTS:
//
//    This function is a wrapper around lineGetAddressStatus to make it easy
//    to handle the variable sized structure and any errors received.
//
//    The returned structure has been allocated with LocalAlloc,
//    so LocalFree has to be called on it when you're finished with it,
//    or there will be a memory leak.
//
//    Similarly, if a lpLineAddressStatus structure is passed in, it *must*
//    have been allocated with LocalAlloc and it could potentially be
//    LocalFree()d.
//
//    If lpLineAddressStatus == NULL, then a new structure is allocated.  It
//    is normal to pass in NULL for this parameter unless you want to use a
//    lpLineAddressStatus that has been returned by previous
//    I_lineGetAddressStatus call.
//
//

LPLINEADDRESSSTATUS I_lineGetAddressStatus(
    LPLINEADDRESSSTATUS lpLineAddressStatus,
    HLINE hLine, DWORD dwAddressID)
{
    size_t sizeofLineAddressStatus = sizeof(LINEADDRESSSTATUS) + 128;
    long lReturn;

    // Continue this loop until the structure is big enough.
    while(TRUE)
    {
        // Make sure the buffer exists, is valid and big enough.
        lpLineAddressStatus =
            (LPLINEADDRESSSTATUS) CheckAndReAllocBuffer(
                (LPVOID) lpLineAddressStatus,
                sizeofLineAddressStatus,
                TEXT("lineGetAddressStatus"));

        if (lpLineAddressStatus == NULL)
            return NULL;

        // Make the call to fill the structure.
        do
        {
            lReturn =
                lineGetAddressStatus(hLine, dwAddressID, lpLineAddressStatus);

            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineGetAddressStatus unhandled error: %x"), lReturn));

                LocalFree(lpLineAddressStatus);
                return NULL;
            }
        }
        while (lReturn != SUCCESS);

        // If the buffer was big enough, then succeed.
        if ((lpLineAddressStatus -> dwNeededSize) <=
            (lpLineAddressStatus -> dwTotalSize))
        {
            return lpLineAddressStatus;
        }

        // Buffer wasn't big enough.  Make it bigger and try again.
        sizeofLineAddressStatus = lpLineAddressStatus -> dwNeededSize;
    }
}


//
//  FUNCTION: I_lineGetCallStatus(LPLINECALLSTATUS, HCALL)
//
//  PURPOSE: Retrieve a LINECALLSTATUS structure for the specified line.
//
//  PARAMETERS:
//    lpLineCallStatus - Pointer to a LINECALLSTATUS structure to use.
//    hCall - Handle of call to get the CallStatus of.
//
//  RETURN VALUE:
//    Returns a pointer to a LINECALLSTATUS structure if successful.
//    Returns NULL if unsuccessful.
//
//  COMMENTS:
//
//    This function is a wrapper around lineGetCallStatus to make it easy
//    to handle the variable sized structure and any errors received.
//
//    The returned structure has been allocated with LocalAlloc,
//    so LocalFree has to be called on it when you're finished with it,
//    or there will be a memory leak.
//
//    Similarly, if a lpLineCallStatus structure is passed in, it *must*
//    have been allocated with LocalAlloc and it could potentially be
//    LocalFree()d.
//
//    If lpLineCallStatus == NULL, then a new structure is allocated.  It
//    is normal to pass in NULL for this parameter unless you want to use a
//    lpLineCallStatus that has been returned by previous I_lineGetCallStatus
//    call.
//
//

LPLINECALLSTATUS I_lineGetCallStatus(
    LPLINECALLSTATUS lpLineCallStatus,
    HCALL hCall)
{
    size_t sizeofLineCallStatus = sizeof(LINECALLSTATUS) + 128;
    long lReturn;

    // Continue this loop until the structure is big enough.
    while(TRUE)
    {
        // Make sure the buffer exists, is valid and big enough.
        lpLineCallStatus =
            (LPLINECALLSTATUS) CheckAndReAllocBuffer(
                (LPVOID) lpLineCallStatus,
                sizeofLineCallStatus,
                TEXT("lineGetCallStatus"));

        if (lpLineCallStatus == NULL)
            return NULL;

        // Make the call to fill the structure.
        do
        {
            lReturn =
                lineGetCallStatus(hCall, lpLineCallStatus);

            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineGetCallStatus unhandled error: %x"), lReturn));
                LocalFree(lpLineCallStatus);
                return NULL;
            }
        }
        while (lReturn != SUCCESS);

        // If the buffer was big enough, then succeed.
        if ((lpLineCallStatus -> dwNeededSize) <=
            (lpLineCallStatus -> dwTotalSize))
        {
            return lpLineCallStatus;
        }

        // Buffer wasn't big enough.  Make it bigger and try again.
        sizeofLineCallStatus = lpLineCallStatus -> dwNeededSize;
    }
}


//
//  FUNCTION: I_lineTranslateAddress
//              (LPLINETRANSLATEOUTPUT, DWORD, DWORD, LPCSTR)
//
//  PURPOSE: Retrieve a LINECALLSTATUS structure for the specified line.
//
//  PARAMETERS:
//    lpLineTranslateOutput - Pointer to a LINETRANSLATEOUTPUT structure.
//    dwDeviceID      - Device that we're translating for.
//    dwAPIVersion    - API Version to use.
//    lpszDialAddress - pointer to the DialAddress string to translate.
//
//  RETURN VALUE:
//    Returns a pointer to a LINETRANSLATEOUTPUT structure if successful.
//    Returns NULL if unsuccessful.
//
//  COMMENTS:
//
//    This function is a wrapper around lineGetTranslateOutput to make it
//    easy to handle the variable sized structure and any errors received.
//
//    The returned structure has been allocated with LocalAlloc,
//    so LocalFree has to be called on it when you're finished with it,
//    or there will be a memory leak.
//
//    Similarly, if a lpLineTranslateOutput structure is passed in, it
//    *must* have been allocated with LocalAlloc and it could potentially be
//    LocalFree()d.
//
//    If lpLineTranslateOutput == NULL, then a new structure is allocated.
//    It is normal to pass in NULL for this parameter unless you want to use
//    a lpLineTranslateOutput that has been returned by previous
//    I_lineTranslateOutput call.
//
//

LPLINETRANSLATEOUTPUT I_lineTranslateAddress(
    LPLINETRANSLATEOUTPUT lpLineTranslateOutput,
    DWORD dwDeviceID, DWORD dwAPIVersion,
    LPCSTR lpszDialAddress)
{
    size_t sizeofLineTranslateOutput = sizeof(LINETRANSLATEOUTPUT) + 128;
    long lReturn;

    // Continue this loop until the structure is big enough.
    while(TRUE)
    {
        // Make sure the buffer exists, is valid and big enough.
        lpLineTranslateOutput =
            (LPLINETRANSLATEOUTPUT) CheckAndReAllocBuffer(
                (LPVOID) lpLineTranslateOutput,
                sizeofLineTranslateOutput,
                TEXT("lineTranslateOutput"));

        if (lpLineTranslateOutput == NULL)
            return NULL;

        // Make the call to fill the structure.
        do
        {
            // Note that CALLWAITING is disabled
            // (assuming the service provider can disable it)
            lReturn =
                lineTranslateAddress(g_hLineApp, dwDeviceID, dwAPIVersion,
                    lpszDialAddress, 0,
                    LINETRANSLATEOPTION_CANCELCALLWAITING,
                    lpLineTranslateOutput);

            // If the address isn't translatable, notify the user.
            if (lReturn == LINEERR_INVALADDRESS)
            {
                TCHAR   achTitle[MAX_PATH];
                TCHAR   achMsg[MAX_PATH];

                LoadString(hInst, IDS_WARNING, achTitle, MAX_PATH);
                LoadString(hInst, IDS_BADTRANSLATE, achMsg, MAX_PATH);

                MessageBox(g_hDlgParentWindow, achMsg, achTitle, MB_OK);
            }

            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineTranslateOutput unhandled error: %x"), lReturn));
                LocalFree(lpLineTranslateOutput);
                return NULL;
            }
        }
        while (lReturn != SUCCESS);

        // If the buffer was big enough, then succeed.
        if ((lpLineTranslateOutput -> dwNeededSize) <=
            (lpLineTranslateOutput -> dwTotalSize))
        {
            return lpLineTranslateOutput;
        }

        // Buffer wasn't big enough.  Make it bigger and try again.
        sizeofLineTranslateOutput = lpLineTranslateOutput -> dwNeededSize;
    }
}


//
//  FUNCTION: I_lineGetAddressCaps(LPLINEADDRESSCAPS, ..)
//
//  PURPOSE: Retrieve a LINEADDRESSCAPS structure for the specified line.
//
//  PARAMETERS:
//    lpLineAddressCaps - Pointer to a LINEADDRESSCAPS, or NULL.
//    dwDeviceID        - Device to get the address caps for.
//    dwAddressID       - This sample always assumes the first address.
//    dwAPIVersion      - API version negotiated for the device.
//    dwExtVersion      - Always 0 for this sample.
//
//  RETURN VALUE:
//    Returns a pointer to a LINEADDRESSCAPS structure if successful.
//    Returns NULL if unsuccessful.
//
//  COMMENTS:
//
//    This function is a wrapper around lineGetAddressCaps to make it easy
//    to handle the variable sized structure and any errors received.
//
//    The returned structure has been allocated with LocalAlloc,
//    so LocalFree has to be called on it when you're finished with it,
//    or there will be a memory leak.
//
//    Similarly, if a lpLineAddressCaps structure is passed in, it *must*
//    have been allocated with LocalAlloc and it could potentially be
//    LocalFree()d.  It also *must* have the dwTotalSize field set.
//
//    If lpLineAddressCaps == NULL, then a new structure is allocated.  It
//    is normal to pass in NULL for this parameter unless you want to use a
//    lpLineCallStatus that has been returned by previous I_lineGetAddressCaps
//    call.
//
//

LPLINEADDRESSCAPS I_lineGetAddressCaps (
    LPLINEADDRESSCAPS lpLineAddressCaps,
    DWORD dwDeviceID, DWORD dwAddressID,
    DWORD dwAPIVersion, DWORD dwExtVersion)
{
    size_t sizeofLineAddressCaps = sizeof(LINEADDRESSCAPS) + 128;
    long lReturn;

    // Continue this loop until the structure is big enough.
    while(TRUE)
    {
        // Make sure the buffer exists, is valid and big enough.
        lpLineAddressCaps =
            (LPLINEADDRESSCAPS) CheckAndReAllocBuffer(
                (LPVOID) lpLineAddressCaps,
                sizeofLineAddressCaps,
                TEXT("lineGetAddressCaps"));

        if (lpLineAddressCaps == NULL)
            return NULL;

        // Make the call to fill the structure.
        do
        {
            lReturn =
                lineGetAddressCaps(g_hLineApp,
                    dwDeviceID, dwAddressID, dwAPIVersion, dwExtVersion,
                    lpLineAddressCaps);

            if (HandleLineErr(lReturn))
                continue;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineGetAddressCaps unhandled error: %x"), lReturn));
                LocalFree(lpLineAddressCaps);
                return NULL;
            }
        }
        while (lReturn != SUCCESS);

        // If the buffer was big enough, then succeed.
        if ((lpLineAddressCaps -> dwNeededSize) <=
            (lpLineAddressCaps -> dwTotalSize))
        {
            return lpLineAddressCaps;
        }

        // Buffer wasn't big enough.  Make it bigger and try again.
        sizeofLineAddressCaps = lpLineAddressCaps -> dwNeededSize;
    }
}



//**************************************************
// LINEERR Error Handlers
//**************************************************


//
//  FUNCTION: HandleLineErr(long)
//
//  PURPOSE: Handle several standard LINEERR errors
//
//  PARAMETERS:
//    lLineErr - Error code to be handled.
//
//  RETURN VALUE:
//    Return TRUE if lLineErr wasn't an error, or if the
//      error was successfully handled and cleared up.
//    Return FALSE if lLineErr was an unhandled error.
//
//  COMMENTS:
//
//    This is the main error handler for all TAPI line APIs.
//    It handles (by correcting or just notifying the user)
//    most of the errors that can occur while using TAPI line APIs.
//
//    Note that many errors still return FALSE (unhandled) even
//    if a dialog is displayed.  Often, the dialog is just notifying
//    the user why the action was canceled.
//
//
//

BOOL HandleLineErr(long lLineErr)
{
    // lLineErr is really an async request ID, not an error.
    if (lLineErr > SUCCESS)
        return FALSE;

    // All we do is dispatch the correct error handler.
    switch(lLineErr)
    {
        case SUCCESS:
            return TRUE;

        case LINEERR_INVALCARD:
        case LINEERR_INVALLOCATION:
        case LINEERR_INIFILECORRUPT:
            return HandleIniFileCorrupt();

        case LINEERR_NODRIVER:
            return HandleNoDriver();

        case LINEERR_REINIT:
            return HandleReInit();

        case LINEERR_NOMULTIPLEINSTANCE:
            return HandleNoMultipleInstance();

        case LINEERR_NOMEM:
            return HandleNoMem();

        case LINEERR_OPERATIONFAILED:
            return HandleOperationFailed();

        case LINEERR_RESOURCEUNAVAIL:
            return HandleResourceUnavail();

        // Unhandled errors fail.
        default:
            return FALSE;
    }
}



//
//  FUNCTION: HandleIniFileCorrupt
//
//  PURPOSE: Handle INIFILECORRUPT error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//    This error shouldn't happen under Windows 95 anymore.  The TAPI.DLL
//    takes care of correcting this problem.  If it does happen, just
//    notify the user.
//

BOOL HandleIniFileCorrupt()
{
    lineTranslateDialog(g_hLineApp, 0, SAMPLE_TAPI_VERSION,
        g_hDlgParentWindow, NULL);

    return TRUE;
}


//
//  FUNCTION: HandleNoDriver
//
//  PURPOSE: Handle NODRIVER error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//

BOOL HandleNoDriver()
{
    return FALSE;
}


//
//  FUNCTION: HandleNoMultipleInstance
//
//  PURPOSE: Handle NOMULTIPLEINSTANCE error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//

BOOL HandleNoMultipleInstance()
{
    return FALSE;
}


//
//  FUNCTION: HandleReInit
//
//  PURPOSE: Handle REINIT error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//

BOOL HandleReInit()
{
    ShutdownTAPI();
    return FALSE;
}


//
//  FUNCTION: HandleNoMem
//
//  PURPOSE: Handle NOMEM error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//    This is also called if I run out of memory for LocalAlloc()s
//
//

BOOL HandleNoMem()
{
    return FALSE;
}


//
//  FUNCTION: HandleOperationFailed
//
//  PURPOSE: Handle OPERATIONFAILED error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//

BOOL HandleOperationFailed()
{
    TSHELL_INFO(TEXT("TAPI Operation Failed for unknown reasons."));
    return FALSE;
}


//
//  FUNCTION: HandleResourceUnavail
//
//  PURPOSE: Handle RESOURCEUNAVAIL error.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//

BOOL HandleResourceUnavail()
{
    return FALSE;
}


//
//  FUNCTION: HandleNoDevicesInstalled
//
//  PURPOSE: Handle cases when we know NODEVICE error
//    is returned because there are no devices installed.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - error was corrected.
//    FALSE - error was not corrected.
//
//  COMMENTS:
//
//    This function is not part of standard error handling
//    but is only used when we know that the NODEVICE error
//    means that no devices are installed.
//
//

BOOL HandleNoDevicesInstalled()
{
    if (LaunchModemControlPanelAdd())
        return TRUE;

    return FALSE;
}


//
//  FUNCTION: LaunchModemControlPanelAdd
//
//  PURPOSE: Launch Add Modem Control Panel applet.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE  - Control Panel launched successfully.
//    FALSE - It didn't.
//
//  COMMENTS:
//
//

BOOL LaunchModemControlPanelAdd()
{
    PROCESS_INFORMATION piProcInfo;
    STARTUPINFO siStartupInfo;

    siStartupInfo.cb = sizeof(STARTUPINFO);
    siStartupInfo.lpReserved = NULL;
    siStartupInfo.lpDesktop = NULL;
    siStartupInfo.lpTitle = NULL;
    siStartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    siStartupInfo.wShowWindow = SW_SHOWNORMAL;
    siStartupInfo.cbReserved2 = 0;
    siStartupInfo.lpReserved2 = NULL;

    // The string to launch the modem control panel is *VERY* likely
    // to change on NT.  If nothing else, this is 'contrl32' on NT
    // instead of 'control'.
    if (CreateProcess(
            NULL,
            "CONTROL.EXE MODEM.CPL,,ADD",
            NULL, NULL, FALSE,
            NORMAL_PRIORITY_CLASS,
            NULL, NULL,
            &siStartupInfo,
            &piProcInfo))
    {
        CloseHandle(piProcInfo.hThread);


        // Control panel 'Add New Modem' has been launched.  Now we should
        // wait for it to go away before continueing.

        // If we WaitForSingleObject for the control panel to exit, then we
        // get into a deadlock situation if we need to respond to any messages
        // from the control panel.

        // If we use a PeekMessage loop to wait, we run into
        // message re-entrancy problems.  (The user can get back to our UI
        // and click 'dial' again).

        // Instead, we take the easy way out and return FALSE to abort
        // the current operation.

        CloseHandle(piProcInfo.hProcess);
    }
    else
    {
        DBG_INFO((DBGARG, TEXT("Unable to LaunchModemControlPanelAdd: %x"), GetLastError()));

    }

    return FALSE;
}


//**************************************************
//
// All the functions from this point on are used solely by the "Dial" dialog.
// This dialog is used to get both the 'phone number' address,
// the line device to be used as well as allow the user to configure
// dialing properties and the line device.
//
//**************************************************

//
//  FUNCTION: DWORD I_lineNegotiateLegacyAPIVersion(DWORD)
//
//  PURPOSE: Negotiate an API Version to use for a specific device.
//
//  PARAMETERS:
//    dwDeviceID - device to negotiate an API Version for.
//
//  RETURN VALUE:
//    Returns the API Version to use for this line if successful.
//    Returns 0 if negotiations fall through.
//
//  COMMENTS:
//
//    This wrapper is slightly different from the I_lineNegotiateAPIVersion.
//    This wrapper allows TapiComm to negotiate an API version between
//    1.3 and SAMPLE_TAPI_VERSION.  Normally, this sample is specific to
//    API Version SAMPLE_TAPI_VERSION.  However, there are a few times when
//    TapiComm needs to get information from a service provider, but also knows
//    that a lower API Version would be ok.  This allows TapiComm to recognize
//    legacy service providers even though it can't use them.  1.3 is the
//    lowest API Version a legacy service provider should support.
//
//

DWORD I_lineNegotiateLegacyAPIVersion(DWORD dwDeviceID)
{
    LINEEXTENSIONID LineExtensionID;
    long lReturn;
    DWORD dwLocalAPIVersion;

    do
    {
        lReturn = lineNegotiateAPIVersion(g_hLineApp, dwDeviceID,
            0x00010003, SAMPLE_TAPI_VERSION,
            &dwLocalAPIVersion, &LineExtensionID);

        if (lReturn == LINEERR_INCOMPATIBLEAPIVERSION)
        {

            TSHELL_INFO(TEXT("INCOMPATIBLEAPIVERSION in Dial Dialog."));

            return 0;
        }

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineNegotiateAPIVersion in Dial Dialog unhandled error: %x"), lReturn));
            return 0;
        }
    }
    while(lReturn != SUCCESS);

    return dwLocalAPIVersion;
}


//
//  FUNCTION: long VerifyUsableLine(DWORD)
//
//  PURPOSE: Verifies that a specific line device is useable by TapiComm.
//
//  PARAMETERS:
//    dwDeviceID - The ID of the line device to be verified
//
//  RETURN VALUE:
//    Returns SUCCESS if dwDeviceID is a usable line device.
//    Returns a LINENOTUSEABLE_ constant otherwise.
//
//  COMMENTS:
//
//    VerifyUsableLine takes the give device ID and verifies step by step
//    that the device supports all the features that TapiComm requires.
//
//

long VerifyUsableLine(DWORD dwDeviceID)
{
    LPLINEDEVCAPS lpLineDevCaps = NULL;
    LPLINEADDRESSSTATUS lpLineAddressStatus = NULL;
    LPVARSTRING lpVarString = NULL;
    DWORD dwAPIVersion;
    long lReturn;
    long lUsableLine = SUCCESS;
    HLINE hLine = 0;

    DBG_INFO((DBGARG, TEXT("Testing Line ID '0x%lx'"),dwDeviceID));

    // The line device must support an API Version that TapiComm does.
    dwAPIVersion = I_lineNegotiateAPIVersion(dwDeviceID);
    if (dwAPIVersion == 0)
        return LINENOTUSEABLE_ERROR;

    lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps,
        dwDeviceID, dwAPIVersion);

    if (lpLineDevCaps == NULL)
        return LINENOTUSEABLE_ERROR;

    // Must support LINEBEARERMODE_VOICE
    if (!(lpLineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE ))
    {
        lUsableLine = LINENOTUSEABLE_NOVOICE;

        TSHELL_INFO(TEXT("LINEBEARERMODE_VOICE not supported"));

        goto DeleteBuffers;
    }

    // Must support LINEMEDIAMODE_DATAMODEM
    if (!(lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM))
    {
        lUsableLine = LINENOTUSEABLE_NODATAMODEM;

        TSHELL_INFO(TEXT("LINEMEDIAMODE_DATAMODEM not supported"));

        goto DeleteBuffers;
    }

    // Must be able to make calls
    if (!(lpLineDevCaps->dwLineFeatures & LINEFEATURE_MAKECALL))
    {
        lUsableLine = LINENOTUSEABLE_NOMAKECALL;

        TSHELL_INFO(TEXT("LINEFEATURE_MAKECALL not supported"));

        goto DeleteBuffers;
    }

    // It is necessary to open the line so we can check if
    // there are any call appearances available.  Other TAPI
    // applications could be using all call appearances.
    // Opening the line also checks for other possible problems.
    do
    {
        lReturn = lineOpen(g_hLineApp, dwDeviceID, &hLine,
            dwAPIVersion, 0, 0,
            LINECALLPRIVILEGE_NONE, LINEMEDIAMODE_DATAMODEM,
            0);

        if(lReturn == LINEERR_ALLOCATED)
        {

            TSHELL_INFO(TEXT("Line is already in use by a non-TAPI app or another Service Provider."));

            lUsableLine = LINENOTUSEABLE_ALLOCATED;
            goto DeleteBuffers;
        }

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineOpen unhandled error: %x"), lReturn));
            lUsableLine = LINENOTUSEABLE_ERROR;
            goto DeleteBuffers;
        }
    }
    while(lReturn != SUCCESS);

    // Get LineAddressStatus to make sure the line isn't already in use.
    lpLineAddressStatus =
        I_lineGetAddressStatus(lpLineAddressStatus, hLine, 0);

    if (lpLineAddressStatus == NULL)
    {
        lUsableLine = LINENOTUSEABLE_ERROR;
        goto DeleteBuffers;
    }

    // Are there any available call appearances (ie: is it in use)?
    if ( !((lpLineAddressStatus -> dwAddressFeatures) &
           LINEADDRFEATURE_MAKECALL) )
    {

        TSHELL_INFO(TEXT("LINEADDRFEATURE_MAKECALL not available"));

        lUsableLine = LINENOTUSEABLE_INUSE;
        goto DeleteBuffers;
    }

    // Make sure the "comm/datamodem" device class is supported
    // Note that we don't want any of the 'extra' information
    // normally returned in the VARSTRING structure.  All we care
    // about is if lineGetID succeeds.
    do
    {
        lpVarString = (LPVARSTRING) CheckAndReAllocBuffer((LPVOID) lpVarString,
            sizeof(VARSTRING),TEXT("VerifyUsableLine:lineGetID: "));

        if (lpVarString == NULL)
        {
            lUsableLine = LINENOTUSEABLE_ERROR;
            goto DeleteBuffers;
        }

        lReturn = lineGetID(hLine, 0, 0, LINECALLSELECT_LINE,
            lpVarString, "comm/datamodem");

        if (HandleLineErr(lReturn))
            continue;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineGetID unhandled error: %x"), lReturn));
            lUsableLine = LINENOTUSEABLE_NOCOMMDATAMODEM;
            goto DeleteBuffers;
        }
    }
    while(lReturn != SUCCESS);


    TSHELL_INFO(TEXT("Line is suitable and available for use."));


  DeleteBuffers:

    if (hLine)
        lineClose(hLine);
    if (lpLineAddressStatus)
        LocalFree(lpLineAddressStatus);
    if (lpLineDevCaps)
        LocalFree(lpLineDevCaps);
    if (lpVarString)
        LocalFree(lpVarString);

    hLine = NULL;
    lpLineAddressStatus = NULL;
    lpLineDevCaps = NULL;
    lpVarString = NULL;
    return lUsableLine;
}


//
//  FUNCTION: void FillTAPILine(HWND)
//
//  PURPOSE: Fills the 'TAPI Line' control with the available line devices.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function enumerates through all the TAPI line devices and
//    queries each for the device name.  The device name is then put into
//    the 'TAPI Line' control.  These device names are kept in order rather
//    than sorted.  This allows "Dial" to know which device ID the user
//    selected just by the knowing the index of the selected string.
//
//    There are default values if there isn't a device name, if there is
//    an error on the device, or if the device name is an empty string.
//    The device name is also checked to make sure it is null terminated.
//
//    Note that a Legacy API Version is negotiated.  Since the fields in
//    the LINEDEVCAPS structure that we are interested in haven't moved, we
//    can negotiate a lower API Version than this sample is designed for
//    and still be able to access the necessary structure members.
//
//    The first line that is usable by TapiComm is selected as the 'default'
//    line.  Also note that if there was a previously selected line, this
//    remains the default line.  This would likely only occur if this
//    function is called after the dialog has initialized once; for example,
//    if a new line is added.
//
//

void FillTAPILine(HWND hwndDlg)
{
    DWORD dwDeviceID;
    DWORD dwAPIVersion;
    LPLINEDEVCAPS lpLineDevCaps = NULL;
    char szLineUnavail[] = "Line Unavailable";
    char szLineUnnamed[] = "Line Unnamed";
    char szLineNameEmpty[] = "Line Name is Empty";
    LPSTR lpszLineName;
    long lReturn;
    DWORD dwDefaultDevice = MAXDWORD;

    // Make sure the control is empty.  If it isn't,
    // hold onto the currently selected ID and then reset it.
    if (SendDlgItemMessage(hwndDlg, IDC_TAPILINE, CB_GETCOUNT, 0, 0))
    {
        dwDefaultDevice = (DWORD)SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
            CB_GETCURSEL, 0, 0);
        SendDlgItemMessage(hwndDlg, IDC_TAPILINE, CB_RESETCONTENT, 0, 0);
    }

    for (dwDeviceID = 0; dwDeviceID < g_dwNumDevs; dwDeviceID ++)
    {
        dwAPIVersion = I_lineNegotiateLegacyAPIVersion(dwDeviceID);
        if (dwAPIVersion)
        {
            lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps,
                dwDeviceID, dwAPIVersion);
            if (lpLineDevCaps)
            {
                if ((lpLineDevCaps -> dwLineNameSize) &&
                    (lpLineDevCaps -> dwLineNameOffset) &&
                    (lpLineDevCaps -> dwStringFormat == STRINGFORMAT_ASCII))
                {
                    // This is the name of the device.
                    lpszLineName = ((char *) lpLineDevCaps) +
                        lpLineDevCaps -> dwLineNameOffset;

                    if (lpszLineName[0] != '\0')
                    {
        // Reverse indented to make this fit

        // Make sure the device name is null terminated.
        if (lpszLineName[lpLineDevCaps->dwLineNameSize -1] != '\0')
        {
            // If the device name is not null terminated, null
            // terminate it.  Yes, this looses the end character.
            // Its a bug in the service provider.
            lpszLineName[lpLineDevCaps->dwLineNameSize-1] = '\0';

            DBG_INFO((DBGARG, TEXT("Device name for device 0x%lx is not null terminated."),
                dwDeviceID));
        }
                    }
                    else // Line name started with a NULL.
                        lpszLineName = szLineNameEmpty;
                }
                else  // DevCaps doesn't have a valid line name.  Unnamed.
                    lpszLineName = szLineUnnamed;
            }
            else  // Couldn't GetDevCaps.  Line is unavail.
                lpszLineName = szLineUnavail;
        }
        else  // Couldn't NegotiateAPIVersion.  Line is unavail.
            lpszLineName = szLineUnavail;

        // Put the device name into the control
        lReturn = (long)SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
            CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) lpszLineName);

        // If this line is usable and we don't have a default initial
        // line yet, make this the initial line.
        if ((lpszLineName != szLineUnavail) &&
            (dwDefaultDevice == MAXDWORD) &&
            (VerifyUsableLine(dwDeviceID) == SUCCESS))
        {
            dwDefaultDevice = dwDeviceID;
        }
    }

    if (lpLineDevCaps)
        LocalFree(lpLineDevCaps);

    if (dwDefaultDevice == MAXDWORD)
        dwDefaultDevice = 0;

    // Set the initial default line
    SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
        CB_SETCURSEL, dwDefaultDevice, 0);
}


//
//  FUNCTION: BOOL VerifyAndWarnUsableLine(HWND)
//
//  PURPOSE: Verifies the line device selected by the user.
//
//  PARAMETERS:
//    hwndDlg - The handle to the current "Dial" dialog.
//
//  RETURN VALUE:
//    Returns TRUE if the currently selected line device is useable
//      by TapiComm.  Returns FALSE if it isn't.
//
//  COMMENTS:
//
//    This function is very specific to the "Dial" dialog.  It gets
//    the device selected by the user from the 'TAPI Line' control and
//    VerifyUsableLine to make sure this line device is usable.  If the
//    line isn't useable, it notifies the user and disables the 'Dial'
//    button so that the user can't initiate a call with this line.
//
//    This function is also responsible for filling in the line specific
//    icon found on the "Dial" dialog.
//
//

BOOL VerifyAndWarnUsableLine(HWND hwndDlg)
{
    DWORD dwDeviceID;
    long lReturn;
    HICON hIcon = 0;
    HWND hControlWnd;

    // Get the selected line device.
    dwDeviceID = (DWORD)SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
                        CB_GETCURSEL, 0, 0);

    // Get the "comm" device icon associated with this line device.
    lReturn = lineGetIcon(dwDeviceID, "comm", &hIcon);

    if (lReturn == SUCCESS)
        SendDlgItemMessage(hwndDlg, IDC_LINEICON, STM_SETICON,
            (WPARAM) hIcon, 0);
    else
        // Any failure to get an icon makes us use the default icon.
        SendDlgItemMessage(hwndDlg, IDC_LINEICON, WM_SETTEXT,
            0, (LPARAM) (LPCTSTR) "TapiComm");

/*  // It turns out that TAPI will always return an icon, even if
    // the device class isn't supported by the TSP or even if the TSP
    // doesn't return any icons at all.  This code is unnecessary.
    // The only reason lineGetIcon would fail is due to resource problems.

    else
    {
        // If the line doesn't have a "comm" device icon, use its default one.
        lReturn = lineGetIcon(dwDeviceID, NULL, &hIcon);
        if (lReturn == SUCCESS)
        {

            TSHELL_INFO(TEXT("Line doesn't support a \"comm\" icon."));

            SendDlgItemMessage(hwndDlg, IDC_LINEICON, STM_SETICON,
                (WPARAM) hIcon, 0);
        }
        else
        {
            // If lineGetIcon fails, just use TapiComms icon.
            DBG_INFO((DBGARG, TEXT("lineGetIcon: %x"), lReturn));

            SendDlgItemMessage(hwndDlg, IDC_LINEICON, WM_SETTEXT,
                0, (LPARAM) (LPCTSTR) "TapiComm");
        }
    }
*/

    // Verify if the device is usable by TapiComm.
    lReturn = VerifyUsableLine(dwDeviceID);

    // Enable or disable the 'Dial' button, depending on if the line is ok.
    // Make sure there is a number to dial before enabling the button.
    hControlWnd = GetDlgItem(hwndDlg, IDC_DIAL);

    //
    // Store Canon
    //
    if (g_szTranslatedNumber[0] = 0x00)
    {
        EnableWindow(hControlWnd, FALSE);
    }
    else
        EnableWindow(hControlWnd, (lReturn == SUCCESS));

    // Any errors on this line prevent us from configuring it
    // or using dialing properties.
    if (lReturn == LINENOTUSEABLE_ERROR)
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_CONFIGURELINE), FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_DIALINGPROPERTIES), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_CONFIGURELINE), TRUE);
        if (SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES, BM_GETCHECK, 0, 0))
            EnableWindow(GetDlgItem(hwndDlg, IDC_DIALINGPROPERTIES), TRUE);
    }

    switch(lReturn)
    {
        case SUCCESS:
            g_dwDeviceID = dwDeviceID;
            return TRUE;

        case LINENOTUSEABLE_ERROR:
            TSHELL_INFO(TEXT("The selected line is incompatible with DirectPlay"));
            break;
        case LINENOTUSEABLE_NOVOICE:
            TSHELL_INFO(TEXT("The selected line doesn't support VOICE capabilities",));
            break;
        case LINENOTUSEABLE_NODATAMODEM:
            TSHELL_INFO(TEXT("The selected line doesn't support DATAMODEM capabilities",));
            break;
        case LINENOTUSEABLE_NOMAKECALL:
            TSHELL_INFO(TEXT("The selected line doesn't support MAKECALL capabilities",));
            break;
        case LINENOTUSEABLE_ALLOCATED:
            TSHELL_INFO(TEXT("The selected line is already in use by a non-TAPI application",));
            break;
        case LINENOTUSEABLE_INUSE:
            TSHELL_INFO(TEXT("The selected line is already in use by a TAPI application",));
            break;

        case LINENOTUSEABLE_NOCOMMDATAMODEM:
            TSHELL_INFO(TEXT("The selected line doesn't support the COMM/DATAMODEM device class",));
            break;
    }

    // g_dwDeviceID == MAXDWORD mean the selected device isn't usable.
    g_dwDeviceID = MAXDWORD;
    return FALSE;
}


//
//  FUNCTION: void FillCountryCodeList(HWND, DWORD)
//
//  PURPOSE: Fill the 'Country Code' control
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//    dwDefaultCountryID - ID of the 'default' country to be selected
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function fills the 'Country Code' control with country names.
//    The country code is appended to the end of the name and the names
//    are added to the control sorted.  Because the country code is
//    embedded in the string along with the country name, there is no need
//    for any of the country information structures to be kept around.  The
//    country code can be extracted from the selected string at any time.
//
//

void FillCountryCodeList(HWND hwndDlg, DWORD dwDefaultCountryID)
{
    LPLINECOUNTRYLIST lpLineCountryList = NULL;
    DWORD dwSizeofCountryList = sizeof(LINECOUNTRYLIST);
    long lReturn;
    DWORD dwCountry;
    LPLINECOUNTRYENTRY lpLineCountryEntries;
    char szRenamedCountry[256];

    // Get the country information stored in TAPI
    do
    {
        lpLineCountryList = (LPLINECOUNTRYLIST) CheckAndReAllocBuffer(
            (LPVOID) lpLineCountryList, dwSizeofCountryList,
            TEXT("FillCountryCodeList"));

        if (lpLineCountryList == NULL)
            return;

        lReturn = lineGetCountry (0, SAMPLE_TAPI_VERSION, lpLineCountryList);

        if (HandleLineErr(lReturn))
            ;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineGetCountry unhandled error: %x"), lReturn));
            LocalFree(lpLineCountryList);
            return;
        }

        if ((lpLineCountryList -> dwNeededSize) >
            (lpLineCountryList -> dwTotalSize))
        {
            dwSizeofCountryList = lpLineCountryList ->dwNeededSize;
            lReturn = -1; // Lets loop again.
        }
    }
    while (lReturn != SUCCESS);

    // Find the first country entry
    lpLineCountryEntries = (LPLINECOUNTRYENTRY)
        (((LPBYTE) lpLineCountryList)
         + lpLineCountryList -> dwCountryListOffset);

    // Now enumerate through all the countries
    for (dwCountry = 0;
         dwCountry < lpLineCountryList -> dwNumCountries;
         dwCountry++)
    {
        // append the country code to the country name
        wsprintf(szRenamedCountry,"%s (%lu)",
            (((LPSTR) lpLineCountryList) +
                lpLineCountryEntries[dwCountry].dwCountryNameOffset),
            lpLineCountryEntries[dwCountry].dwCountryCode);

        // Now put this country name / code string into the combobox
        lReturn = (long)SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, CB_ADDSTRING,
                    0, (LPARAM) (LPCTSTR) szRenamedCountry);

        // If this country is the default country, select it.
        if (lpLineCountryEntries[dwCountry].dwCountryID
            == dwDefaultCountryID)
        {
            SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, CB_SETCURSEL, lReturn, 0);
        }
    }

    LocalFree(lpLineCountryList);
    return;
}


//
//  FUNCTION: void FillLocationInfo(HWND, LPSTR, LPDWORD, LPSTR)
//
//  PURPOSE: Fill (or refill) the 'Your Location' control
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//    lpszCurrentLocation - Name of current location, or NULL
//    lpdwCountryID - location to store the current country ID or NULL
//    lpszAreaCode - location to store the current area code or NULL
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function is moderately multipurpose.
//
//    If lpszCurrentLocation is NULL, then the 'Your Location' control
//    is filled with all the locations stored in TAPI and the TAPI 'default'
//    location is selected.  This is done during initialization and
//    also after the 'Dialing Properties' dialog has been displayed.
//    This last is done because the user can change the current location
//    or add and delete locations while in the 'Dialing Properties' dialog.
//
//    If lpszCurrentLocation is a valid string pointer, then it is assumed
//    that the 'Your Location' control is already filled and that the user
//    is selecting a specific location.  In this case, all of the existing
//    TAPI locations are enumerated until the specified location is found.
//    At this point, the specified location is set to the current location.
//
//    In either case, if lpdwCountryID is not NULL, it is filled with the
//    country ID for the current location.  If lpszAreaCode is not NULL, it
//    is filled with the area code defined for the current location.  These
//    values can be used later to initialize other "Dial" controls.
//
//    This function also fills the 'Calling Card' control based on
//    the information stored in the current location.
//
//

void FillLocationInfo(HWND hwndDlg, LPSTR lpszCurrentLocation,
    LPDWORD lpdwCountryID, LPSTR lpszAreaCode)
{
    LPLINETRANSLATECAPS lpTranslateCaps = NULL;
    DWORD dwSizeofTranslateCaps = sizeof(LINETRANSLATECAPS);
    long lReturn;
    DWORD dwCounter;
    LPLINELOCATIONENTRY lpLocationEntry;
    LPLINECARDENTRY lpLineCardEntry = NULL;
    DWORD dwPreferredCardID = MAXDWORD;
    TCHAR   achMsg[MAX_PATH];

    // First, get the TRANSLATECAPS
    do
    {
        lpTranslateCaps = (LPLINETRANSLATECAPS) CheckAndReAllocBuffer(
            (LPVOID) lpTranslateCaps, dwSizeofTranslateCaps,
            TEXT(TEXT("FillLocationInfo")));

        if (lpTranslateCaps == NULL)
            return;

        lReturn = lineGetTranslateCaps(g_hLineApp, SAMPLE_TAPI_VERSION,
                    lpTranslateCaps);

        if (HandleLineErr(lReturn))
            ;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineGetTranslateCaps unhandled error: %x"), lReturn));
            LocalFree(lpTranslateCaps);
            return;
        }

        if ((lpTranslateCaps -> dwNeededSize) >
            (lpTranslateCaps -> dwTotalSize))
        {
            dwSizeofTranslateCaps = lpTranslateCaps ->dwNeededSize;
            lReturn = -1; // Lets loop again.
        }
    }
    while(lReturn != SUCCESS);

    // Find the location information in the TRANSLATECAPS
    lpLocationEntry = (LPLINELOCATIONENTRY)
        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps->dwLocationListOffset);

    // If lpszCurrentLocation, then make that location 'current'
    if (lpszCurrentLocation)
    {
        // loop through all locations, looking for a location match
        for(dwCounter = 0;
            dwCounter < lpTranslateCaps -> dwNumLocations;
            dwCounter++)
        {
            if (strcmp((((LPSTR) lpTranslateCaps) +
                            lpLocationEntry[dwCounter].dwLocationNameOffset),
                        lpszCurrentLocation)
                == 0)
            {
                // Found it!  Set the current location.
                lineSetCurrentLocation(g_hLineApp,
                    lpLocationEntry[dwCounter].dwPermanentLocationID);

                // Set the return values.
                if (lpdwCountryID)
                    *lpdwCountryID = lpLocationEntry[dwCounter].dwCountryID;

                if (lpszAreaCode)
                    strcpy(lpszAreaCode, (((LPSTR) lpTranslateCaps) +
                            lpLocationEntry[dwCounter].dwCityCodeOffset));

                // Store the preferred card ID for later use.
                dwPreferredCardID = lpLocationEntry[dwCounter].dwPreferredCardID;
                break;
            }
        }

        // Was a match for lpszCurrentLocation found?
        if (dwPreferredCardID == MAXDWORD)
        {

            TSHELL_INFO(TEXT("lpszCurrentLocation not found"));

            LoadString( hInst, IDS_LOCATIONERR, achMsg, sizeof(achMsg));

            SendDlgItemMessage(hwndDlg, IDC_CALLINGCARD, WM_SETTEXT, 0,
                (LPARAM) achMsg);
            LocalFree(lpTranslateCaps);
            return;
        }
    }
    else // fill the combobox and use the TAPI 'current' location.
    {
        // First empty the combobox
        SendDlgItemMessage(hwndDlg, IDC_LOCATION, CB_RESETCONTENT, 0, 0);

        // enumerate all the locations
        for(dwCounter = 0;
            dwCounter < lpTranslateCaps -> dwNumLocations;
            dwCounter++)
        {
            // Put each one into the combobox
            lReturn = (long)SendDlgItemMessage(hwndDlg, IDC_LOCATION, CB_ADDSTRING,
                0, (LPARAM) (((LPBYTE) lpTranslateCaps) +
                    lpLocationEntry[dwCounter].dwLocationNameOffset));

            // Is this location the 'current' location?
            if (lpLocationEntry[dwCounter].dwPermanentLocationID ==
                lpTranslateCaps->dwCurrentLocationID)
            {
                // Return the requested information
                if (lpdwCountryID)
                    *lpdwCountryID = lpLocationEntry[dwCounter].dwCountryID;

                if (lpszAreaCode)
                    strcpy(lpszAreaCode, (((LPSTR) lpTranslateCaps) +
                            lpLocationEntry[dwCounter].dwCityCodeOffset));

                // Set this to be the active location.
                SendDlgItemMessage(hwndDlg, IDC_LOCATION, CB_SETCURSEL, lReturn, 0);
                dwPreferredCardID = lpLocationEntry[dwCounter].dwPreferredCardID;
            }
        }
    }

    // Now locate the prefered card and display it.

    lpLineCardEntry = (LPLINECARDENTRY)
        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps->dwCardListOffset);

    for(dwCounter = 0;
        dwCounter < lpTranslateCaps -> dwNumCards;
        dwCounter++)
    {
        if (lpLineCardEntry[dwCounter].dwPermanentCardID == dwPreferredCardID)
        {
            SendDlgItemMessage(hwndDlg, IDC_CALLINGCARD, WM_SETTEXT, 0,
                (LPARAM) (((LPBYTE) lpTranslateCaps) +
                    lpLineCardEntry[dwCounter].dwCardNameOffset));
            break;
        }
    }

    LocalFree(lpTranslateCaps);
}



//
//  FUNCTION: void UseDialingRules(HWND)
//
//  PURPOSE: Enable/disable Dialing Rule controls
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    The sole purpose of this function is to enable or disable
//    the controls that apply to dialing rules if the
//    "Use Country Code and Area Code" checkbox is checked or unchecked,
//    as appropriate.
//
//

void UseDialingRules(HWND hwndDlg)
{
    HWND hControl;
    BOOL bEnableWindow;

    bEnableWindow = (BOOL)SendDlgItemMessage(hwndDlg,
        IDC_USEDIALINGRULES, BM_GETCHECK, 0, 0);

    hControl = GetDlgItem(hwndDlg, IDC_STATICCOUNTRYCODE);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_COUNTRYCODE);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_STATICAREACODE);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_AREACODE);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_STATICLOCATION);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_LOCATION);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_STATICCALLINGCARD);
    EnableWindow(hControl, bEnableWindow);

    hControl = GetDlgItem(hwndDlg, IDC_CALLINGCARD);
    EnableWindow(hControl, bEnableWindow);

    if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_CONFIGURELINE)))
    {
        hControl = GetDlgItem(hwndDlg, IDC_DIALINGPROPERTIES);
        EnableWindow(hControl, bEnableWindow);
    }
}


//
//  FUNCTION: void DisplayPhoneNumber(HWND)
//
//  PURPOSE: Create, Translate and Display the Phone Number
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function uses the information stored in many other controls
//    to build the phone number, translate it, and display it.  Also
//    makes sure the Dial button is enabled or disabled, based on if the
//    number can be dialed or not.
//
//    There are actually three phone numbers generated during this
//    process:  canonical, dialable and displayable.  Normally, only the
//    displayable number is shown to the user; the other two numbers are
//    to be used by the program internally.  However, for demonstration
//    purposes (and because it is cool for developers to see these numbers),
//    all three numbers are displayed.
//

void DisplayPhoneNumber(HWND hwndDlg)
{
    char szPreTranslatedNumber[128] = "";
    int  nPreTranslatedSize = 0;
    char szTempBuffer[512];
    int  i;
    DWORD dwDeviceID;
    LPLINETRANSLATEOUTPUT lpLineTranslateOutput = NULL;

    // Disable the 'dial' button if there isn't a number to dial
    if (0 == SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER,
            WM_GETTEXTLENGTH, 0, 0))
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_DIAL), FALSE);
        return;
    }

    // If we use the dialing rules, lets make canonical format.
    // Canonical format is explained in the TAPI documentation and the
    // string format needs to be followed very strictly.
    if (SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES,
        BM_GETCHECK, 0, 0))
    {
        // First character *has* to be the plus sign.
        szPreTranslatedNumber[0] = '+';
        nPreTranslatedSize = 1;

        // The country code *has* to be next.
        // Country code was stored in the string with the country
        // name and needs to be extracted at this point.
        i = (int)SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE,
                CB_GETCURSEL, 0, 0);
        SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE,
            CB_GETLBTEXT, (WPARAM) i, (LPARAM) (LPCTSTR) szTempBuffer);

        // Country code is at the end of the string, surounded by parens.
        // This makes it easy to identify the country code.
        i = strlen(szTempBuffer);
        while(szTempBuffer[--i] != '(');

        while(szTempBuffer[++i] != ')')
            szPreTranslatedNumber[nPreTranslatedSize++] = szTempBuffer[i];

        // Next is the area code.
        i = (int)SendDlgItemMessage(hwndDlg, IDC_AREACODE, WM_GETTEXT,
                510, (LPARAM) (LPCTSTR) szTempBuffer);

        // Note that the area code is optional.  If it is included,
        // then it has to be preceeded by *exactly* one space and it
        // *has* to be surrounded by parens.
        if (i)
            nPreTranslatedSize +=
                wsprintf(&szPreTranslatedNumber[nPreTranslatedSize],
                    " (%s)", szTempBuffer);

        // There has to be *exactly* one space before the rest of the number.
        szPreTranslatedNumber[nPreTranslatedSize++] = ' ';

        // At this point, the phone number is appended to the
        // canonical number.  The next step is the same whether canonical
        // format is used or not; just the prepended area code and
        // country code are different.
    }

    SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER, WM_GETTEXT,
        510, (LPARAM) (LPCTSTR) szTempBuffer);

    strcat(&szPreTranslatedNumber[nPreTranslatedSize], szTempBuffer);

    dwDeviceID = (DWORD)SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
                        CB_GETCURSEL, 0, 0);

    // Translate the address!
    lpLineTranslateOutput = I_lineTranslateAddress(
        lpLineTranslateOutput, dwDeviceID, SAMPLE_TAPI_VERSION,
        szPreTranslatedNumber);

    // Unable to translate it?
    if (lpLineTranslateOutput == NULL)
    {
        g_szTranslatedNumber[0]   = 0x00;
        g_szDisplayableAddress[0] = 0x00;
        g_szDialableAddress[0]    = 0x00;

        EnableWindow(GetDlgItem(hwndDlg, IDC_DIAL), FALSE);
        return;
    }

    // Is the selected device useable with TapiComm?
    if (g_dwDeviceID != MAXDWORD)
        EnableWindow(GetDlgItem(hwndDlg, IDC_DIAL), TRUE);

    // Fill the appropriate phone number controls.
    strcpy( g_szTranslatedNumber, szPreTranslatedNumber);
    strcpy( g_szDialableAddress, ((LPSTR) lpLineTranslateOutput +
            lpLineTranslateOutput -> dwDialableStringOffset));

    strcpy( g_szDisplayableAddress, ((LPSTR) lpLineTranslateOutput +
            lpLineTranslateOutput -> dwDisplayableStringOffset));

    LocalFree(lpLineTranslateOutput);

}


//
//  FUNCTION: void PreConfigureDevice(HWND, DWORD)
//
//  PURPOSE:
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//    dwDeviceID - line device to be configured
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    At one point, PreConfigureDevice used lineConfigDialog to
//    configure the device.  This has the unfortunate effect of configuring
//    the device immediately, even if it is in use by another TAPI app.
//    This can be really bad if data communications are already in
//    progress (like with RAS).
//
//    Now, PreConfigureDevice uses lineConfigDialogEdit to give the
//    user the configuration UI, but it doesn't actually do anything to
//    the line device.  TapiComm stores the configuration information so
//    that it can be set later, just before making the call.
//
//

void PreConfigureDevice(HWND hwndDlg, DWORD dwDeviceID)
{
    long lReturn;
    LPVARSTRING lpVarString = NULL;
    DWORD dwSizeofVarString = sizeof(VARSTRING);

    // If there isn't already any device configuration information,
    // then we need to get some.
    if (g_lpDeviceConfig == NULL)
    {
        do
        {
            lpVarString = (LPVARSTRING) CheckAndReAllocBuffer(
                (LPVOID) lpVarString, dwSizeofVarString,
                TEXT("PreConfigureDevice - lineGetDevConfig: "));

            if (lpVarString == NULL)
                return;

            lReturn = lineGetDevConfig(dwDeviceID, lpVarString,
                "comm/datamodem");

            if (HandleLineErr(lReturn))
                ;
            else
            {
                DBG_INFO((DBGARG, TEXT("lineGetDevCaps unhandled error: %x"), lReturn));
                LocalFree(lpVarString);
                return;
            }

            if ((lpVarString -> dwNeededSize) > (lpVarString -> dwTotalSize))
            {
                dwSizeofVarString = lpVarString -> dwNeededSize;
                lReturn = -1; // Lets loop again.
            }
        }
        while (lReturn != SUCCESS);

        g_dwSizeDeviceConfig = lpVarString -> dwStringSize;

        // The extra byte allocated is in case dwStringSize is 0.
        g_lpDeviceConfig = CheckAndReAllocBuffer(
                g_lpDeviceConfig, g_dwSizeDeviceConfig+1,
                TEXT("PreConfigureDevice - Allocate device config: "));

        if (!g_lpDeviceConfig)
        {
            LocalFree(lpVarString);
            return;
        }

        memcpy(g_lpDeviceConfig,
            ((LPBYTE) lpVarString + lpVarString -> dwStringOffset),
            g_dwSizeDeviceConfig);
    }

    // Next make the lineConfigDialogEdit call.

    // Note that we determine the initial size of the VARSTRING
    // structure based on the known size of the existing configuration
    // information.  I make the assumption that this configuration
    // information is very unlikely to grow by more than 5K or by
    // more than 5 times.  This is a *very* conservative number.
    // We do *not* want lineConfigDialogEdit to fail just because there
    // wasn't enough room to stored the data.  This would require the user
    // to go through configuration again and that would be annoying.

    dwSizeofVarString = 5 * g_dwSizeDeviceConfig + 5000;

    do
    {
        lpVarString = (LPVARSTRING) CheckAndReAllocBuffer(
            (LPVOID) lpVarString, dwSizeofVarString,
            TEXT("PreConfigureDevice - lineConfigDialogEdit: "));

        if (lpVarString == NULL)
            return;

        lReturn = lineConfigDialogEdit(dwDeviceID, hwndDlg, "comm/datamodem",
            g_lpDeviceConfig, g_dwSizeDeviceConfig, lpVarString);

        if (HandleLineErr(lReturn))
            ;
        else
        {
            DBG_INFO((DBGARG, TEXT("lineConfigDialogEdit unhandled error: %x"), lReturn));
            LocalFree(lpVarString);
            return;
        }

        if ((lpVarString -> dwNeededSize) > (lpVarString -> dwTotalSize))
        {
            // We had been conservative about making sure the structure was
            // big enough.  Unfortunately, not conservative enough.  Hopefully,
            // this will not happen a second time because we are *DOUBLING*
            // the NeededSize.
            dwSizeofVarString = (lpVarString -> dwNeededSize) * 2;
            lReturn = -1; // Lets loop again.
        }
    }
    while (lReturn != SUCCESS);

    // Store the configuration information into a global structure
    // so it can be set at a later time.
    g_dwSizeDeviceConfig = lpVarString -> dwStringSize;
    g_lpDeviceConfig = CheckAndReAllocBuffer(
            g_lpDeviceConfig, g_dwSizeDeviceConfig+1,
            TEXT("PreConfigureDevice - Reallocate device config: "));

    if (!g_lpDeviceConfig)
    {
        LocalFree(lpVarString);
        return;
    }

    memcpy(g_lpDeviceConfig,
        ((LPBYTE) lpVarString + lpVarString -> dwStringOffset),
        g_dwSizeDeviceConfig);

    LocalFree(lpVarString);
}


//
//  FUNCTION: BOOL GetAddressToDial
//
//  PURPOSE: Get an address to dial from the user.
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    TRUE if a valid device and phone number have been entered by
//    the user.  FALSE if the user canceled the dialing process.
//
//  COMMENTS:
//
//    All this function does is launch the "Dial" dialog.
//
//

BOOL GetAddressToDial()
{
    BOOL bRet;

    bRet = (BOOL)DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_DIALDIALOG), g_hDlgParentWindow,
                                DialDialogProc, 0);
    g_hDialog = NULL;
    g_hDlgParentWindow = g_hWndMainWindow;


    return bRet;
}


//
//  FUNCTION: DialDialogProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Dialog callback procedure for the dialing dialog
//
//  PARAMETERS:
//    hwndDlg - Dialog calling the callback.
//    uMsg    - Dialog message.
//    wParam  - uMsg specific.
//    lParam  - uMsg specific.
//
//  RETURN VALUE:
//    returns 0 - command handled.
//    returns non-0 - command unhandled
//
//  COMMENTS:
//
//    This is the dialog to get the phone number and line device
//    from the user.  All the relavent information is stored in global
//    variables to be used later if the dialog returns successfully.
//
//


INT_PTR CALLBACK DialDialogProc(
    HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Static variables to store the information from last time the
    // "Dial" dialog was displayed.  That way the phone number can be
    // typed once but used several times.

    static TCHAR szCountryName[512]  = TEXT("");
    static TCHAR szAreaCode[256]     = TEXT("");
    static TCHAR szPhoneNumber[512]  = TEXT("");
    static DWORD dwUsedDeviceID     = MAXDWORD;
    static BOOL bUsedCountryAndArea = FALSE;
    static BOOL bHistoryValid       = FALSE;

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            DWORD dwCountryID = 0;


            // Store the Dialog Window so it can be dismissed if necessary
            g_hDialog = hwndDlg;

            // This dialog should be parent to all dialogs.
            g_hDlgParentWindow = hwndDlg;

            // Initialize the Dialog Box. Lots to do here.

            FillTAPILine(hwndDlg);
            if (g_lpDeviceConfig)
            {
                LocalFree(g_lpDeviceConfig);
                g_lpDeviceConfig = NULL;
            }

            // If there is a valid history, use it to initialize the controls.
            if (bHistoryValid)
            {
                FillLocationInfo(hwndDlg, NULL, NULL, NULL);
                FillCountryCodeList(hwndDlg, 0);

                SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, CB_SELECTSTRING,
                    (WPARAM) -1, (LPARAM) (LPCTSTR) szCountryName);

                SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER, WM_SETTEXT, 0,
                    (LPARAM) (LPCTSTR) szPhoneNumber);

                SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES,
                    BM_SETCHECK, (WPARAM) bUsedCountryAndArea, 0);

                SendDlgItemMessage(hwndDlg, IDC_TAPILINE, CB_SETCURSEL,
                    g_dwDeviceID, 0);
            }
            else
            {
                FillLocationInfo(hwndDlg, NULL, &dwCountryID, szAreaCode);
                FillCountryCodeList(hwndDlg, dwCountryID);
                SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES,
                    BM_SETCHECK, 1, 0);
            }

            SendDlgItemMessage(hwndDlg, IDC_AREACODE, WM_SETTEXT,
                0, (LPARAM) (LPCTSTR) szAreaCode);

            UseDialingRules(hwndDlg);
            DisplayPhoneNumber(hwndDlg);
            VerifyAndWarnUsableLine(hwndDlg);

            return TRUE;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDC_TAPILINE:
                    if (HIWORD(wParam) == CBN_SELENDOK)
                    {
                        if (g_lpDeviceConfig)
                        {
                            LocalFree(g_lpDeviceConfig);
                            g_lpDeviceConfig = NULL;
                        }
                        DisplayPhoneNumber(hwndDlg);
                        VerifyAndWarnUsableLine(hwndDlg);
                    }
                    return TRUE;

                case IDC_CONFIGURELINE:
                {
                    DWORD dwDeviceID;
                    dwDeviceID = (DWORD)SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
                        CB_GETCURSEL, 0, 0);
                    PreConfigureDevice(hwndDlg, dwDeviceID);
                    DisplayPhoneNumber(hwndDlg);
                    return TRUE;
                }

                case IDC_COUNTRYCODE:
                    if (HIWORD(wParam) == CBN_SELENDOK)
                        DisplayPhoneNumber(hwndDlg);
                    return TRUE;

                case IDC_AREACODE:
                case IDC_PHONENUMBER:
                    if (HIWORD(wParam) == EN_CHANGE)
                        DisplayPhoneNumber(hwndDlg);
                    return TRUE;

                case IDC_USEDIALINGRULES:
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        UseDialingRules(hwndDlg);
                        DisplayPhoneNumber(hwndDlg);
                    }
                    return TRUE;

                case IDC_LOCATION:
                    if (HIWORD(wParam) == CBN_CLOSEUP)
                    {
                        char szCurrentLocation[128];
                        int nCurrentSelection;

                        nCurrentSelection = (int)SendDlgItemMessage(hwndDlg,
                            IDC_LOCATION, CB_GETCURSEL, 0, 0);
                        SendDlgItemMessage(hwndDlg, IDC_LOCATION,
                            CB_GETLBTEXT, nCurrentSelection,
                            (LPARAM) (LPCTSTR) szCurrentLocation);

                        // If the user selected a 'location', make it current.
                        FillLocationInfo(hwndDlg, szCurrentLocation, NULL, NULL);
                        DisplayPhoneNumber(hwndDlg);
                    }
                    return TRUE;

                case IDC_DIALINGPROPERTIES:
                {
                    DWORD dwDeviceID;
                    long lReturn;

                    dwDeviceID = (DWORD)SendDlgItemMessage(hwndDlg, IDC_TAPILINE,
                            CB_GETCURSEL, 0, 0);

                    lReturn = lineTranslateDialog(g_hLineApp, dwDeviceID,
                        SAMPLE_TAPI_VERSION, hwndDlg, g_szTranslatedNumber);

#ifdef DEBUG
                    if (lReturn != SUCCESS)
                        DBG_INFO((DBGARG, TEXT("lineTranslateDialog: %x"), lReturn));
#endif

                    // The user could have changed the default location, or
                    // added or removed a location while in the 'Dialing
                    // Properties' dialog.  Refill the Location Info.
                    FillLocationInfo(hwndDlg, NULL, NULL, NULL);
                    DisplayPhoneNumber(hwndDlg);

                    return TRUE;
                }

                case IDCANCEL:
                    EndDialog(hwndDlg, FALSE);
                    return TRUE;

                case IDC_DIAL:
                {
                    // The Dial button has to be enabled and the line has
                    // to be currently usable to continue.
                    if (!(IsWindowEnabled((HWND)lParam) &&
                          VerifyAndWarnUsableLine(hwndDlg)))
                        return TRUE;

                    DisplayPhoneNumber(hwndDlg);

                    // Store all the relavent information in static
                    // variables so they will be available the next time a
                    // number is dialed.
                    SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE,
                        WM_GETTEXT, 511, (LPARAM) (LPCTSTR) szCountryName);

                    SendDlgItemMessage(hwndDlg, IDC_AREACODE,
                        WM_GETTEXT, 255, (LPARAM) (LPCTSTR) szAreaCode);

                    SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER,
                        WM_GETTEXT, 511, (LPARAM) (LPCTSTR) szPhoneNumber);

                    bUsedCountryAndArea = (BOOL) SendDlgItemMessage(hwndDlg,
                        IDC_USEDIALINGRULES, BM_GETCHECK, 0, 0);

                    bHistoryValid = TRUE;

                    EndDialog(hwndDlg, TRUE);
                    return TRUE;
                }


                // This message is actually posted to the dialog from the
                // lineCallbackFunc when it receives a
                // LINEDEVSTATE_TRANSLATECHANGE message.  Notify the user and
                // retranslate the number.  Also refill the Location Info
                // since this could have been generated by a location change.
                case IDC_CONFIGURATIONCHANGED:
                {
                    FillLocationInfo(hwndDlg, NULL, NULL, NULL);
                    DisplayPhoneNumber(hwndDlg);

                    return TRUE;
                }

                // If we get a LINE_CREATE message, all that needs to be done
                // is to reset this controls contents.  The selected line
                // won't change and no lines will be removed.
                case IDC_LINECREATE:
                {
                    FillTAPILine(hwndDlg);
                    return TRUE;
                }

                default:
                    break;
            }

            break;
        }

        default:
            break;
    }

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\dputils.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.c
 *  Content:	common support routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"
#include "dputils.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL bDefault;

	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			DPLAY_DEFAULT_CHAR,&bDefault);

	if (bDefault)
	{
		DPF(0,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
		DPF(0,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
	}
	
	return rval;

} // WideToAnsi

/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

	return rval;
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   6/10/98   a-peterz Check CreateFile() result against INVALID_HANDLE_VALUE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "newdpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static 
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;
 
int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl( 
HANDLE hDevice, 			// handle to device of interest 
DWORD dwIoControlCode, 		// control code of operation to perform 
LPVOID lpInBuffer, 			// pointer to buffer to supply input data 
DWORD nInBufferSize, 		// size of input buffer 
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data 
DWORD nOutBufferSize, 		// size of output buffer 
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count 
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation 
); 
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
#define WRITE_STATS     (FIRST_DEBUG_PROC+2)

HANDLE hDPLAY_VxD=0;
HANDLE hLogMutex=0;
HANDLE hLogFile=0;
PSHARED_LOG_FILE pLogFile=0;

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

void DbgWriteStats(PIN_WRITESTATS pIn)
{
	UINT rc;
	UINT cbRet;

	if(hDPLAY_VxD){
		DeviceIoControl(hDPLAY_VxD,WRITE_STATS,pIn,sizeof(IN_WRITESTATS), &rc, sizeof(rc), &cbRet, NULL);
	}
}

static BOOL InitMemLogString(VOID)
{
	DWORD dwLastError;

	hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
	dwLastError=GetLastError();
	hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
	pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);

	if(!hLogFile || !hLogMutex || !pLogFile){
		if(hLogFile){
			CloseHandle(hLogFile);
			hLogFile=0;
		}
		if(hLogMutex){
			CloseHandle(hLogMutex);
			hLogMutex=0;
		}
		if(pLogFile){
			UnmapViewOfFile(pLogFile);
			pLogFile=NULL;
		}
		return FALSE;
	} else {
		WaitForSingleObject(hLogMutex,INFINITE);
			if((dwLastError!=ERROR_ALREADY_EXISTS) || 
				(pLogFile->nEntries > DPLOG_NUMENTRIES) || (pLogFile->nEntries == 0) ||
				(pLogFile->cbLine   > DPLOG_ENTRYSIZE)  || (pLogFile->cbLine   == 0) ||
				(pLogFile->iWrite   > DPLOG_NUMENTRIES) ||
				(pLogFile->cInUse   > DPLOG_NUMENTRIES)
			){
				pLogFile->nEntries = DPLOG_NUMENTRIES;
				pLogFile->cbLine   = DPLOG_ENTRYSIZE;
				pLogFile->iWrite   = 0;
				pLogFile->cInUse   = 0;
			}	
		ReleaseMutex(hLogMutex);
	}
	return TRUE;
}

static void MemLogString(LPSTR str)
{
	PLOG_ENTRY pEntry;
	DWORD cbCopy;
	
	if(!hLogFile){
		if(!InitMemLogString()){
			return;
		}
	}

	WaitForSingleObject(hLogMutex,INFINITE);

	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
	pEntry->hThread=GetCurrentThreadId();
	pEntry->tLogged=timeGetTime();
	pEntry->DebugLevel=0;

	cbCopy=strlen(str)+1;
	if(cbCopy > DPLOG_ENTRYSIZE){
		str[DPLOG_ENTRYSIZE]=0;
		cbCopy=DPLOG_ENTRYSIZE;
	}
	memcpy(pEntry->str, str, cbCopy);

	if(pLogFile->iWrite+1 > pLogFile->cInUse){
		pLogFile->cInUse=pLogFile->iWrite+1;
	}

	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
	ReleaseMutex(hLogMutex);

}

static void LogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
	UINT rc;
	UINT cbRet;
	int maxlen = MAX_STRING+sizeof(LOGENTRY);

	if(hDPLAY_VxD && str){
		while(str[i] && i < maxlen)
			i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}

	if(bLogging & 2){
		MemLogString(str);
	}
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
	if(!bLogging || bLogging & 1)
	{            
	    OUTPUTDEBUGSTRING( str );
	    OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
	    LogString(str);
	}    
    
}
    
void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
        	hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
        	if(hDPLAY_VxD != INVALID_HANDLE_VALUE){
        		IN_LOGINIT In;
        		OUT_LOGINIT Out;
        		UINT cbRet;
        		In.nCharsPerLine=MAX_STRING;
        		In.nLogEntries=5000;
				DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
        	}
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(volatile DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;

    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;
    
    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;
    
}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\memlog.h ===
#include <windows.h>
#include <mmsystem.h>

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define BASE_LOG_FILENAME  "DPLAYLOG-0"
#define BASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(SHARED_LOG_FILE)+((sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _SHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}SHARED_LOG_FILE, *PSHARED_LOG_FILE;

typedef struct _LOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	CHAR	str[0];
} LOG_ENTRY, *PLOG_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\common\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "newdpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lBytesAlloc;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
	lBytesAlloc+=pmt->dwSize;\
		{	\
			IN_WRITESTATS InWS;	\
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	\
		 	InWS.stat_USER3=lBytesAlloc;	\
			DbgWriteStats(&InWS);	\
		} \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

#ifdef DEBUG
	    lBytesAlloc -= pmt->dwSize;
		{	
			IN_WRITESTATS InWS;	
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	
		 	InWS.stat_USER3=lBytesAlloc;	
			DbgWriteStats(&InWS);	
		}
#endif

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	lBytesAlloc -= pmt->dwSize;

	pmt->dwSize = size - sizeof( MEMTRACK );

	lBytesAlloc += pmt->dwSize;

	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER3=lBytesAlloc;
		DbgWriteStats(&InWS);
	}

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lBytesAlloc = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPlay"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dblbuf.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       dblbuf.c
*  Content:	   memory manager for double buffer memory for messages.
*  History:
*   Date		By		Reason
*   ====		==		======
*  12/29/97   aarono    Original
*
* Synopsis:
*
***************************************************************************/

PVOID GetDoubleBuffer(UINT size)
{
}

VOID FreeDoubleBuffer(PVOID pBuffer)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\do.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       do.c
*  Content:	helper functions for iplay.c
*  History:
*   Date		By		Reason
*   ====		==		======
*	6/29/96		andyco	created it to keep clutter down in iplay.c
***************************************************************************/

#include "dplaypr.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"DoXXX"

// called by GetPlayer, GetGroup, InternalSetData to set up the player data
// flags can be DPSET_LOCAL or DPSET_REMOTE
// NOTE - can be called on a player, or on a group cast to a player!
HRESULT DoPlayerData(LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,DWORD dwSourceSize,
	DWORD dwFlags)
{
	LPVOID pvDest; // we set these two based on which flags 
	DWORD dwDestSize; // to dplayi_player->(local)data

	// figure out which dest they want
	if (dwFlags & DPSET_LOCAL)
	{
		pvDest = lpPlayer->pvPlayerLocalData;
		dwDestSize = lpPlayer->dwPlayerLocalDataSize;
	}
	else 
	{
		pvDest = lpPlayer->pvPlayerData;
		dwDestSize = lpPlayer->dwPlayerDataSize;
	}

	// are we copying anything
	if (dwSourceSize)
	{
		// see if we need to alloc dest
		if (0 == dwDestSize)
		{
			ASSERT(!pvDest);
			pvDest = DPMEM_ALLOC(dwSourceSize);
			if (!pvDest)
			{
				DPF_ERR("could not alloc player blob!");
				return E_OUTOFMEMORY;
			}
		} // !pvDest
		// do we need to realloc?
		else if (dwSourceSize != dwDestSize)
		{
			LPVOID	pvTempPlayerData;

			ASSERT(pvDest);
			pvTempPlayerData = DPMEM_REALLOC(pvDest,dwSourceSize);
			if (!pvTempPlayerData)
			{
				DPF_ERR("could not re-alloc player blob!");
				return E_OUTOFMEMORY;
			}
		   	pvDest = pvTempPlayerData;
		}
		// copy the data over
		memcpy(pvDest,pvSource,dwSourceSize);
		dwDestSize = dwSourceSize;

	} // dwDataSize
	else 
	{
		// set it to NULL
		if (dwDestSize)
		{
			ASSERT(pvDest);
			DPMEM_FREE(pvDest);
			pvDest = NULL;
			dwDestSize = 0;
		}
	} // !dwSourceSize

	// update the appropriate pointer
	if (dwFlags & DPSET_LOCAL)
	{
		lpPlayer->pvPlayerLocalData = pvDest;
		lpPlayer->dwPlayerLocalDataSize = dwDestSize;
	}
	else 
	{
		//
		// set the remote data
		lpPlayer->pvPlayerData = pvDest;
		lpPlayer->dwPlayerDataSize = dwDestSize;
	}

	return DP_OK;

} // DoPlayerData

// NOTE - can be called on a player, or on a group cast to a player!
// called by GetPlayer, GetGroup, InternalSetName to set the player name
HRESULT DoPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName)
{
    HRESULT hr=DP_OK;

	if (pName)
	{
		// free the old ones, copy over the new ones
		if (pPlayer->lpszShortName) DPMEM_FREE(pPlayer->lpszShortName);
		hr = GetString(&(pPlayer->lpszShortName),pName->lpszShortName);
		if (FAILED(hr))
		{
			return hr;
		}

		if (pPlayer->lpszLongName) DPMEM_FREE(pPlayer->lpszLongName); 
		hr = GetString(&(pPlayer->lpszLongName),pName->lpszLongName);
		if (FAILED(hr))
		{
			return hr;
		} 
	}
	else	// no names given, so free old ones
	{
		if (pPlayer->lpszShortName)
		{
			DPMEM_FREE(pPlayer->lpszShortName);
			pPlayer->lpszShortName = NULL;
		}

		if (pPlayer->lpszLongName)
		{
			DPMEM_FREE(pPlayer->lpszLongName);
			pPlayer->lpszLongName = NULL;
		}
	}


    return hr;   	
} // DoPlayerName

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dplayi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:    DirectPlay internal include file for DPlay functions included
 *				by the lobby (not used in any of the DPlay files).
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	3/9/97		myronth	Created it
 *	3/17/97		myronth	Added player & group structs (only what we need)
 *	3/25/97		myronth	Fixed GetPlayer prototype (1 new parameter)
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __DPLAYI_INCLUDED__
#define __DPLAYI_INCLUDED__


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

// Mimick the first part of the player/group struct.  This is really
// the only part we need.
typedef struct DPLAYI_GROUP
{
    DWORD                       dwSize;
	DWORD						dwFlags;
    DPID                        dwID; // DPID for this group
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOID						pvPlayerData;
	DWORD						dwPlayerDataSize;
	LPVOID						pvPlayerLocalData;
	DWORD						dwPlayerLocalDataSize;
} DPLAYI_GROUP, * LPDPLAYI_GROUP;

typedef DPLAYI_GROUP DPLAYI_PLAYER;
typedef DPLAYI_PLAYER * LPDPLAYI_PLAYER;

typedef struct DPLAYI_DPLAY * LPDPLAYI_DPLAY;

// REVIEW!!!! -- Should we just include dplaysp.h to get this.  I really
// don't like having it defined in two places.
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

// DPlay Critical Section stuff
extern LPCRITICAL_SECTION gpcsDPlayCritSection;	// defined in dllmain.c
#ifdef DEBUG
extern int gnDPCSCount; // count of dplay lock
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection),gnDPCSCount--;ASSERT(gnDPCSCount>=0);
#else 
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection);
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection);
#endif
// End DPlay Critical Section stuff

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// handler.c
extern HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY, LPBYTE, LPVOID);

// iplay.c
extern HRESULT GetGroup(LPDPLAYI_DPLAY, LPDPLAYI_GROUP *,LPDPNAME,
						LPVOID, DWORD, DWORD);
extern HRESULT GetPlayer(LPDPLAYI_DPLAY, LPDPLAYI_PLAYER *,	LPDPNAME,
						HANDLE, LPVOID, DWORD, DWORD, LPWSTR);

// namesrv.c
extern HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY, LPDWORD);


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#endif // __DPLAYI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\api.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       api.c
 *  Content:	DirectPlay api's
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *    1/96		andyco	   	created it
 *	2/15/96 	andyco	   	hardwired  to load dpwsock sp, return fake enum
 *	3/16/96 	andyco	   	spinit - new structure
 *	3/23/96		andyco	   	use registry
 *	4/10/96		andyco	   	added verifyspcallbacks
 *	4/23/96		andyco	   	added check for mw2 on enum. only return dp1.0 service
 *						   	providers if the .exe is mw2.
 *	5/6/96		andyco	   	moved os functionality to dpos.c
 *	5/29/96		andyco	   	new vtbls
 *	6/19/96		kipo	   	Bug #2052 in api.c: changed MW2Enum() to use the TAPI
 *						   	service provider GUID from DirectPlay 1.0 instead of the
 *						   	new serial service provider GUID. This will let
 *						   	MechWarrior work over TAPI; changed time bomb date to 8/31/96.
 *	6/20/96		andyco	   	added WSTRLEN_BYTES
 *	6/21/96 	kipo	   	Bug #2078. Changed modem service provider GUID so it's not the
 *						   	same as the DPlay 1.0 GUID, so games that are checking won't
 *						   	put up their loopy modem-specific UI.
 *	6/22/96		kipo	   	added EnumConnectionData() method.
 *	6/23/96		kipo	   	updated for latest service provider interfaces.
 *  6/26/96		andyco	   	take service lock b4 dplay lock on DirectPlayConnect
 *	6/26/96		kipo	   	changed guidGame to guidApplication; added support for DPADDRESS.
 *						   	changed GetFlags to GetPlayerFlags.
 *  6/26/96		kipo	   	check version returned by service provider
 *	6/28/96		andyco	   	check for DPLERR_BUFFERTOOSMALL on getconnectionsettings
 *	6/28/96		kipo	   	added support for CreateAddress() method.
 *  7/8/96  	AjayJ      	Adjusted vtable for IDirectPlay2 and IDirectPlay2A to match
 *          	           	dplay.h (remove EnableNewPlayers, SaveSession, alphabetize)
 *          	           	DummyEnumSessionsCallBack - fixed prototype to match dplay.h
 *  7/10/96		kipo	   	turned stack frame generation on around calls to DirectPlayEnumerateA
 *						   	so that apps that use _cdecl callbacks will continue
 *						   	to work. Fixes bug #2260 that was crashing "Space Hulk".
 * 	7/13/96		andyco	   	added DirectPlayEnumerate entry for compat. set MW2 global
 *						   	bool.
 *	7/23/96		andyco	   	added get max message size after sp init
 *	8/10/96		kipo	   	updated time bomb date
 *  8/ 9/96 	sohailm    	Bug #2376: added logic to free sp module if an error occurs in LoadSP.
 *	8/15/96		andyco		call sp_shutdown if sp_init succeeds but we don't like the
 *							version
 *	8/23/96		kipo		removed time bomb
 *  10/3/96 	sohailm     renamed VALID_UUID_PTR() call to VALID_GUID_PTR()
 *	10/31/96	andyco		added idirectplay3
 *	1/24/97		andyco		call freelibrary on the sp
 *	2/30/97		andyco		added enumconnections, initializeconnection to dp3 vtbl
 *	3/04/97		kipo		updated gdwDPlaySPRefCount definition
 *	3/12/97		myronth		added Lobby object creation code
 *  3/12/97     sohailm     added SecureOpen(), SecureOpenA() to DIRECTPLAYCALLBACKS3 and 
 *                          DIRECTPLAYCALLBACKS3A respectively, updated existing code to reflect 
 *                          changes in function parameters (InternalOpenSession, FreeSessionList)
 *	3/17/97		kipo		added support for CreateCompoundAddress()
 *	4/1/97		andyco		put in app hack for ms-golf.  don't load guid_local_tcp.
 *							use guid_tcp instead.  this is because guid_local_tcp 
 *							points to a sp that uses ddhelp.exe.  but, dplay is no longer
 *							using ddhelp.exe (see dplaysvr), so they're broken.
 *	3/31/97		myronth		Fixed DPF spew level for checking if a game was lobbied.
 *	4/20/97		andyco		added group in group stuff
 *	5/8/97		myronth		added Get/SetGroupConnectionSettings, StartSession
 *	5/12/97		kipo		fixed bugs #5506 and 5507
 *	5/17/97		myronth		Added SendChatMessage to IDirectPlay3
 *	5/27/97		kipo		Changed time bomb data to 10/15/97
 *	5/29/97		andyco		made ConnectFindSession() async
 *	5/30/97		myronth		Added GetGroupParent
 *  5/30/97     sohailm     Added GetPlayerAccount to vtable.
 *	5/30/97		kipo		Added GetPlayerFlags() and GetGroupFlags()
 *	6/16/97		andyco		don't take service lock on connect, so dpthread
 *							can run.
 *	6/25/97		kipo		remove time bomb for DX5
 *	7/30/97		myronth		Fixed wrong validation macro for guid
 *	8/5/97		andyco		async addforward. init this->dwMinVersion.
 *	8/19/97		myronth		Save the lobby object that lobbied us
 *	8/19/97		myronth		Change that to saving a copy of the lobby interface
 *	8/14/97		sohailm		Not verifying sp callback ptrs correctly (#10929)
 *	8/22/97		myronth		Added registry support for Description and Private values
 *	10/21/97	myronth		Added IDirectPlay4 callback tables
 *	10/29/97	myronth		Changed Get/SetGroupOwner callback pointers
 *	11/13/97	myronth		Added functions for asynchronous Connect (#12541)
 *	11/19/97	myronth		Changed Connect timeout to max at a minute (#13216)
 *	11/20/97	myronth		Made EnumConnections & DirectPlayEnumerate 
 *							drop the lock before calling the callback (#15208)
 *	11/24/97	kipo		Added time bomb for DX6
 *	12/3/97		myronth		Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	12/5/97		andyco		voice entries
 *  12/18/97    aarono      added pool allocation
 *	01/20/97	sohailm		don't free sp list after DirectPlayEnumerate (#17006)
 *	1/20/98		myronth		Changed PRV_SendStandardSystemMessage
 *	1/20/98		myronth		#ifdef'd out voice support
 *  2/18/98		aarono      unpatched protocol from table, moved InitProtocol
 *  4/30/98     aarono      fix connect when talking to secure server
 *  6/18/98     aarono      fix group SendEx ASYNC to use unique Header
 *  6/25/98     a-peterz    fix incorrect sizeof() in ConnectMe
 ***************************************************************************/
		
					
// todo - do we need to check the version on mw2?

#include "dplaypr.h"
#include "dplobby.h"
#include "dpprot.h"
#include "fpm.h"
#include "..\protocol\mytimer.h"

// gdwDPLaySPRefCount is here so SP's can statically link to dplay
// this can keep some apps from unloading dplayx before the SP (no
// release) and crashing. Disable the warning so that we can include the
// extern declaration in dplaysp.h
#define DllExport	__declspec( dllexport )
#pragma warning( disable : 4273 )

DllExport DWORD gdwDPlaySPRefCount = 0;

// list of all sp info gotten from the registry
LPSPNODE gSPNodes;

// set if we're running mech
BOOL gbMech;

// set if we have a dx3 SP loaded. once we load a dx3 SP, 
// we do not allow any more directplay objects to be created
// (since in dx3 you could only have one directplay, we don't 
// want to risk crashing the SP)
BOOL gbDX3SP;											

// gpObjectList is the list of all dplay objects that exist in
// this dll.  used in dllmain and classfactory->canunloadnow
LPDPLAYI_DPLAY gpObjectList;
UINT gnObjects; // the # of dplay objects in the gpObjectList

//
// DP_1_xxx is a dplay 10 function.  see iplay1.c
// DP_A_xxx is a dplay 20 ansi function.  see iplaya.c
// DP_xxx is a dplay 20 function.  see iplay.c and enum.c
// DP_SP_xxx is a service provider callback.  see sphelp.c and handler.c
//

/*
 * the one copy of the direct play 1.0 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS dpCallbacks =
{
    DP_QueryInterface,
    DP_AddRef,
    DP_Release,
    DP_AddPlayerToGroup,
    DP_Close,
    DP_1_CreatePlayer,
    DP_1_CreateGroup,
    DP_DeletePlayerFromGroup,
    DP_DestroyPlayer,
    DP_DestroyGroup,
    DP_EnableNewPlayers,
    DP_1_EnumGroupPlayers,
    DP_1_EnumGroups,
    DP_1_EnumPlayers,
    DP_1_EnumSessions,
    DP_1_GetCaps,
    DP_GetMessageCount,
    DP_1_GetPlayerCaps,
    DP_1_GetPlayerName,
    DP_Initialize,
    DP_1_Open,
    DP_1_Receive,
    DP_1_SaveSession,
    DP_Send,
    DP_1_SetPlayerName      	
};  				

/*
 *  the direct play 2 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS2 dpCallbacks2 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc
};  				

/*
 *  the direct play 2A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS2A dpCallbacks2A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc
};  				

// Protocol needs to wrap SendComplete since unlike HandleMessage, the values to complete
// will change from an SP code to a Protocol code, so there is no propogation
// method other than wrapping the SendComplete.

DIRECTPLAYCALLBACKSSP dpCallbacksSP =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_SP_AddMRUEntry,
	(LPVOID)DP_SP_CreateAddress,
	(LPVOID)DP_SP_EnumAddress,
	(LPVOID)DP_SP_EnumMRUEntries,
	(LPVOID)DP_SP_GetPlayerFlags,
	(LPVOID)DP_SP_GetSPPlayerData,
	(LPVOID)DP_SP_HandleMessage, 
	(LPVOID)DP_SP_SetSPPlayerData,
    /*** IDirectPlaySP methods added for DX 5***/
    (LPVOID)DP_SP_CreateCompoundAddress,
	(LPVOID)DP_SP_GetSPData,
	(LPVOID)DP_SP_SetSPData,
#ifdef BIGMESSAGEDEFENSE
	(LPVOID)DP_SP_ProtocolSendComplete,   // Goes through protocol.lib to DP_SP_ProtocolSendComplete
	(LPVOID)DP_SP_HandleSPWarning
#else
	(LPVOID)DP_SP_ProtocolSendComplete   // Goes through protocol.lib to DP_SP_ProtocolSendComplete
#endif
};    
	 

/*
 *  the direct play 3 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS3 dpCallbacks3 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_EnumConnections,
	(LPVOID)DP_EnumGroupsInGroup,
	(LPVOID)DPL_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_SecureOpen,
	(LPVOID)DP_SendChatMessage,
	(LPVOID)DPL_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags
};  				


/*
 *  the direct play 3A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS3A dpCallbacks3A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_A_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_A_EnumConnectionsPreDP4,
	(LPVOID)DP_A_EnumGroupsInGroup,
	(LPVOID)DPL_A_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_A_SecureOpen,
	(LPVOID)DP_A_SendChatMessage,
	(LPVOID)DPL_A_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_A_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags
};  				
	 
/*
 *  the direct play 4 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS4 dpCallbacks4 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_EnumConnections,
	(LPVOID)DP_EnumGroupsInGroup,
	(LPVOID)DPL_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_SecureOpen,
	(LPVOID)DP_SendChatMessage,
	(LPVOID)DPL_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags,
    /*** IDirectPlay4 methods ***/
	(LPVOID)DPL_GetGroupOwner,
	(LPVOID)DPL_SetGroupOwner,
	(LPVOID)DP_SendEx,
	(LPVOID)DP_GetMessageQueue,
	(LPVOID)DP_CancelMessage,
	(LPVOID)DP_CancelPriority,
#ifdef DPLAY_VOICE_SUPPORT
	(LPVOID)DP_CloseVoice,
 	(LPVOID)DP_OpenVoice
#endif
};  				


/*
 *  the direct play 4A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS4A dpCallbacks4A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_A_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_A_EnumConnections,
	(LPVOID)DP_A_EnumGroupsInGroup,
	(LPVOID)DPL_A_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_A_SecureOpen,
	(LPVOID)DP_A_SendChatMessage,
	(LPVOID)DPL_A_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_A_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags,
    /*** IDirectPlay4 methods ***/
	(LPVOID)DPL_GetGroupOwner,
	(LPVOID)DPL_SetGroupOwner,
	(LPVOID)DP_SendEx,
	(LPVOID)DP_GetMessageQueue,
	(LPVOID)DP_CancelMessage,
	(LPVOID)DP_CancelPriority,
#ifdef DPLAY_VOICE_SUPPORT
	(LPVOID)DP_CloseVoice,
 	(LPVOID)DP_OpenVoice
#endif
};  				

// todo - Add DP_A_GetAccountDesc() to vtable

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayCreate"

#if 0

// shut 'em down if they try to use the beta bits too long
HRESULT TimeBomb() 
{
    SYSTEMTIME	st;
	HWND hwnd; 

#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")

    GetSystemTime( &st );

    if( st.wYear > 1999 ||
		(st.wYear == 1999 && (st.wMonth > 8 || (st.wMonth == 8 && st.wDay > 15))))
    {
		// in case ddraw app is full screen xclusive, get a parent window
		hwnd = GetForegroundWindow();
		MessageBoxA( hwnd, "This pre-release version of DirectPlay has expired.", "Microsoft DirectPlay", MB_OK  );
		return DP_OK;
    }
	return DP_OK;
} // TimeBomb

#endif

#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))
// called by loadsp to make sure we didn't get bogus call back ptrs
HRESULT VerifySPCallbacks(LPDPLAYI_DPLAY this) 
{
	LPDWORD lpCallback;
	int nCallbacks = NUM_CALLBACKS(this->pcbSPCallbacks);
	int i;

	DPF(1,"verifying %d callbacks\n",nCallbacks);
	lpCallback = (LPDWORD)this->pcbSPCallbacks + 2; // + 1 for dwSize, + 1 for dwFlags

	for (i=0;i<nCallbacks ;i++ )
	{
		if ((*lpCallback) && !VALIDEX_CODE_PTR(*lpCallback)) 
		{
			DPF_ERR("sp provided bad callback pointer!");
			return E_FAIL;
		}
		lpCallback++;
	}

	return DP_OK;	
} // VerifySPCallbacks


// get the max message sizes for this xport
HRESULT GetMaxMessageSize(LPDPLAYI_DPLAY this)
{
	HRESULT hr;
	DPCAPS caps;

	memset(&caps,0,sizeof(DPCAPS));
	caps.dwSize = sizeof(DPCAPS);

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
	if (FAILED(hr))
	{
		ASSERT(FALSE); // sp should at least support unreliable!
		return hr;
	}
	
	this->dwSPMaxMessage = caps.dwMaxBufferSize+sizeof(MSG_PLAYERMESSAGE);

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,DPGETCAPS_GUARANTEED);
	if (FAILED(hr))
	{
		// use unreliable
		this->dwSPMaxMessageGuaranteed = this->dwSPMaxMessage;
	}
	else 
	{
		this->dwSPMaxMessageGuaranteed = caps.dwMaxBufferSize;		
	}

	return DP_OK;

} // GetMaxMessageSize

// find the sp correspoding to lpGUID, and load it. call SPInit.
HRESULT LoadSP(LPDPLAYI_DPLAY this,LPGUID lpGUID,LPDPADDRESS lpAddress,DWORD dwAddressSize)
{
	SPINITDATA sd;
	LPSPNODE pspNode;
	BOOL bFound=FALSE;
	LPDPSP_SPINIT spinit;	
	HRESULT hr;
	LPDPLAYI_DPLAY_INT pInt;
	DWORD	dwError;

#ifdef DEBUG
	CHAR szGuid[GUID_STRING_SIZE];
	hr = AnsiStringFromGUID(lpGUID, szGuid, GUID_STRING_SIZE);
	if (!FAILED(hr))
	{
		DPF(5, "LoadSP called for GUID = %s, address = 0x%08x",szGuid, lpGUID);		
	}
#endif

	// Build the list
	hr = InternalEnumerate();
	if (FAILED(hr))
	{
		// rut ro!
		ASSERT(FALSE);
		return hr;
	}

	// find the right spnode
	pspNode = gSPNodes;
	while (pspNode && !(bFound))
	{
		if (IsEqualGUID(&(pspNode->guid),lpGUID)) bFound=TRUE;
		else pspNode=pspNode->pNextSPNode;
	}
	if (!bFound) 
	{
		DPF_ERR("could not find specified service provider!!");
		return DPERR_UNAVAILABLE;
	}
	
	DPF(0,"loading sp = %ls\n",pspNode->lpszPath);	

	// store the pspnode
	this->pspNode = pspNode;

 	// try to load the specified sp
    this->hSPModule = OS_LoadLibrary(pspNode->lpszPath);
	if (!this->hSPModule) 
	{
		DPF(0,"Could not load service provider - %ls\n",pspNode->lpszPath);
		return DPERR_UNAVAILABLE;
	}

    spinit= (LPDPSP_SPINIT) OS_GetProcAddress(this->hSPModule,"SPInit");
	if (!spinit) 
	{
		DPF(0,"Could not find service provider entry point");
		hr = DPERR_UNAVAILABLE;
        goto CLEANUP_AND_EXIT;
	}

	// get an IDirectPlaySP to pass it
	hr = GetInterface(this,&pInt,&dpCallbacksSP);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplaysp object. hr = 0x%08lx\n",hr);
        goto CLEANUP_AND_EXIT;
	}

	// set up the init data struct
	memset(&sd,0,sizeof(sd));
	sd.lpCB = this->pcbSPCallbacks;
    sd.lpCB->dwSize = sizeof(DPSP_SPCALLBACKS);
	sd.dwReserved1 = pspNode->dwReserved1;
	sd.dwReserved2 = pspNode->dwReserved2;
 	sd.lpszName = pspNode->lpszName;
	sd.lpGuid = &(pspNode->guid);
	sd.lpISP = (IDirectPlaySP *) pInt;
	
	sd.lpAddress = lpAddress;
	sd.dwAddressSize = dwAddressSize;

	hr = spinit(&sd);
    if (FAILED(hr))
    {
    	DPF_ERR("could not start up service provider!");
        goto CLEANUP_AND_EXIT;
    }

	// reset size of callback structure in case SP changed it
	this->pcbSPCallbacks->dwSize = sizeof(DPSP_SPCALLBACKS);

	hr = VerifySPCallbacks(this);
    if (FAILED(hr))
    {
    	DPF_ERR("invalid callbacks from service provider!");
        goto CLEANUP_AND_EXIT;
    }

	// check that SP version makes sense
	if ((sd.dwSPVersion & DPSP_MAJORVERSIONMASK) < DPSP_DX3VERSION)
	{
    	DPF_ERR("incompatible version returned from service provider!");
		// the init did succeed, try to call shutdown
	    if (sd.lpCB->Shutdown)  
	    {
			// dx3 and earlier sp's had a VOID arg list for shutdown
	    	hr = CALLSPVOID( sd.lpCB->Shutdown );
	    }
		else 
		{
			// shutdown not required...
		}
	    
		if (FAILED(hr)) 
		{
			DPF_ERR("could not invoke shutdown");
		}

		hr = DPERR_UNAVAILABLE;
        goto CLEANUP_AND_EXIT;
	}
	else if ((sd.dwSPVersion & DPSP_MAJORVERSIONMASK) == DPSP_DX3VERSION) 
	{
		DPF(0,"loading DX3 service provider");
		this->dwFlags |= DPLAYI_DPLAY_DX3SP;
		gbDX3SP = TRUE; // set a .dll var indicating it's not safe to allow any more directplay objects
						// to be created
	}

	// a-josbor: remember the version number in case we need it later
	this->dwSPVersion = sd.dwSPVersion;
	
	// set the blob size
	this->dwSPHeaderSize = sd.dwSPHeaderSize;
	DPF(1,"setting sp's message data size to %d\n",this->dwSPHeaderSize);

	// store a pointer to our IDirectPlaySP
	this->pISP = (IDirectPlaySP *)pInt;

	hr = GetMaxMessageSize(this);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        goto CLEANUP_AND_EXIT;
    }


    // success
    return DP_OK;

CLEANUP_AND_EXIT:
    if (this->hSPModule)
    {
        if (!FreeLibrary(this->hSPModule))
        {
            ASSERT(FALSE);
			dwError = GetLastError();
			DPF_ERR("could not free sp module");
			DPF(0, "dwError = %d", dwError);
        }
		this->hSPModule = NULL;
    }
	
	if (pInt)
	{
		// release the idirectplaysp interface we alloc'ed above...	
		this->dwRefCnt++;	 // since sp is not really loaded, make sure we don't nuke this object
		ASSERT(this->dwRefCnt >= 3);
		DP_Release((LPDIRECTPLAY)pInt);
		this->dwRefCnt--;
	}
	
	// make sure we reset this flag if we failed.  we never would have gotten here if it had
	// been true b4 the call, so if it changed, it was on the failed load
	gbDX3SP = FALSE;
	
    return hr;
} // LoadSP


// called by our MS Golf app hack
// builds a tcp/ip broadcast address
HRESULT  GetTCPBroadcastAddress(IDirectPlay * piplay,LPDPADDRESS * ppAddress,LPDWORD pdwAddressSize)
{
	HRESULT hr;
	char * pszBroadcast="";
	DWORD dwBroadcastSize = sizeof(char);

	ASSERT(ppAddress);
	ASSERT(NULL == *ppAddress);
	ASSERT(pdwAddressSize);
	ASSERT(0 == *pdwAddressSize);
	
	// call once to get the size - note - it's ok to cast ipiplay here,
	// since create address only checks for valid this ptr...
	hr =  DP_SP_CreateAddress((IDirectPlaySP *) piplay,&GUID_TCP,&DPAID_INet,
		pszBroadcast,dwBroadcastSize,*ppAddress,pdwAddressSize);
	ASSERT(DPERR_BUFFERTOOSMALL == hr);
	
	// alloc the size needed
	*ppAddress = DPMEM_ALLOC(*pdwAddressSize);
	if (!*ppAddress) return DPERR_OUTOFMEMORY;

	// call it again - this time we should get the real show!	
	hr =  DP_SP_CreateAddress((IDirectPlaySP *) piplay,&GUID_TCP,&DPAID_INet,
		pszBroadcast,dwBroadcastSize,*ppAddress,pdwAddressSize);
	if (FAILED(hr))	ASSERT(FALSE);
	
	return hr;
	
} // GetTCPBroadcastAddress

// called by InternalCreate
HRESULT AllocMemoryPools(LPDPLAYI_DPLAY this)
{
	InitTablePool(this);
	this->lpPlayerMsgPool=NULL;
	this->lpSendParmsPool=NULL;
	this->lpMsgNodePool=NULL;
	if(InitContextTable(this)!=DP_OK){
		return DPERR_NOMEMORY;
	}
	this->lpPlayerMsgPool=FPM_Init(sizeof(GROUPHEADER),NULL,NULL,NULL);
	if(!this->lpPlayerMsgPool){
		return DPERR_NOMEMORY;
	}
	this->lpSendParmsPool=FPM_Init(sizeof(SENDPARMS),SendInitAlloc,SendInit,SendFini);
	if(!this->lpSendParmsPool){
		return DPERR_NOMEMORY;
	}
	this->lpMsgNodePool=FPM_Init(sizeof(MESSAGENODE),NULL,NULL,NULL);
	if(!this->lpMsgNodePool){
		return DPERR_NOMEMORY;
	}
	return DP_OK;
}

VOID FreeMemoryPools(LPDPLAYI_DPLAY this)
{
	if(this->lpPlayerMsgPool){
		this->lpPlayerMsgPool->Fini(this->lpPlayerMsgPool,FALSE);
	}
	if(this->lpSendParmsPool){
		this->lpSendParmsPool->Fini(this->lpSendParmsPool,FALSE);
	}
	if(this->lpMsgNodePool){
		this->lpMsgNodePool->Fini(this->lpMsgNodePool,FALSE);
	}
	FiniTablePool(this);
	FiniContextTable(this);
}

HRESULT InitReply(LPDPLAYI_DPLAY this)
{
	if(!(this->hReply = CreateEventA(NULL,FALSE,FALSE,NULL))){	// Auto-Reset, unsignalled event.
		return DPERR_OUTOFMEMORY;
	}
	
	InitializeCriticalSection(&this->ReplyCS);
	this->dwReplyCommand = 0;
	this->pReplyBuffer   = NULL;
	this->pvReplySPHeader= NULL;
	return DP_OK;	
}

VOID FiniReply(LPDPLAYI_DPLAY this)
{
	if(this->hReply){
		CloseHandle(this->hReply);
		this->hReply=0;
		DeleteCriticalSection(&this->ReplyCS);
	}
}

VOID SetupForReply(LPDPLAYI_DPLAY this, DWORD dwReplyCommand)
{
	EnterCriticalSection(&this->ReplyCS);
	ASSERT(this->dwReplyCommand==0);
	this->dwReplyCommand=dwReplyCommand;
	ResetEvent(this->hReply);
	this->pReplyBuffer=NULL;
	this->pvReplySPHeader=NULL;
	LeaveCriticalSection(&this->ReplyCS);
}

VOID UnSetupForReply(LPDPLAYI_DPLAY this)
{
	EnterCriticalSection(&this->ReplyCS);
	this->dwReplyCommand=0;
	if(this->pReplyBuffer){
		FreeReplyBuffer(this->pReplyBuffer);
	}
	this->pReplyBuffer=NULL;
	this->pvReplySPHeader=NULL;
	LeaveCriticalSection(&this->ReplyCS);
}

HRESULT WaitForReply(LPDPLAYI_DPLAY this, PCHAR *ppReply, LPVOID *ppvSPHeader, DWORD dwTimeout)
{
	HRESULT hr;
	DWORD dwRet;

	EnterCriticalSection(&this->ReplyCS);
	if(!this->dwReplyCommand){
		// its just gonna timeout anyway, may as well be now.
		// this can happen because some error paths after calling 
		// SendCreateMessage don't bail properly.
		DPF(0,"ERROR: Called WaitForReply with NO REPLY TYPE SPECIFIED!\n");
		hr=DPERR_TIMEOUT;
		goto exit;
	}
	DPF(0,"WAITFORREPLY, Waiting for a x%x\n",this->dwReplyCommand);
	LeaveCriticalSection(&this->ReplyCS);

	dwRet=WaitForSingleObject(this->hReply, dwTimeout);
	
	EnterCriticalSection(&this->ReplyCS);
	
		if(this->pReplyBuffer){
			*ppReply=this->pReplyBuffer;
			if(ppvSPHeader){
				*ppvSPHeader=this->pvReplySPHeader;
			}
			// got a reply
			hr=DP_OK;
			this->pReplyBuffer=NULL;
			this->pvReplySPHeader=NULL;
		} else {
			// didn't get a reply (timed out) or no memory for buffer
			DPF(0, "WaitForReply: timed out waiting for reply!\n");
			hr=DPERR_TIMEOUT;
			*ppReply=NULL;
		}
		this->dwReplyCommand=0;

exit:
	LeaveCriticalSection(&this->ReplyCS);
	
	return hr;
}

VOID FreeReplyBuffer(PCHAR pReplyBuffer)
{
	DPMEM_FREE(pReplyBuffer);
}

HRESULT HandleReply(LPDPLAYI_DPLAY this, PCHAR pReplyBuffer, DWORD cbReplyBuffer, DWORD dwReplyCommand, PVOID pvSPHeader)
{
	HRESULT hr;
	EnterCriticalSection(&this->ReplyCS);

	// Normally we only allow one expected response, the only exception is we might get an
	// ADDFORWARDREPLY with error when waiting for a SUPERENUMPLAYERSREPLY, if there are more exceptions,
	// we can change the dwReplyCommand to a pointer to an array of things we are waiting for.
	// added another exception, when waiting for a SUPERENUMPLAYERREPLY x29, allow x3 (ENUMPLAYERSREPLY)
	// added another exception, when waiting for a ENUMPLAYERSREPLY x3, allow x24 (ADDFORWARDREPLY)
	if(
	   (dwReplyCommand==this->dwReplyCommand) || 
	   ((this->dwReplyCommand==DPSP_MSG_SUPERENUMPLAYERSREPLY) && 
	    ((dwReplyCommand==DPSP_MSG_ENUMPLAYERSREPLY)||(dwReplyCommand==DPSP_MSG_ADDFORWARDREPLY))
	   ) ||
	   ((this->dwReplyCommand==DPSP_MSG_ENUMPLAYERSREPLY) &&
	   (dwReplyCommand==DPSP_MSG_ADDFORWARDREPLY)
	   )
	  )
	{
		// winner
		ASSERT(!this->pReplyBuffer);
		DPF(5,"HANDLEREPLY: Got reply we wanted x%x\n",dwReplyCommand);
		this->pReplyBuffer=DPMEM_ALLOC(cbReplyBuffer+this->dwSPHeaderSize);
		if(this->pReplyBuffer){
			memcpy(this->pReplyBuffer,pReplyBuffer,cbReplyBuffer);
			if(pvSPHeader){
				this->pvReplySPHeader=this->pReplyBuffer+cbReplyBuffer;
				memcpy(this->pvReplySPHeader, pvSPHeader, this->dwSPHeaderSize);
			} else {
				this->pvReplySPHeader=NULL;
			}
		} else {
			DPF(0,"HandleReply couldn't allocate reply buffer, WaitForReply will think it timed out\n");
		}
		SetEvent(this->hReply);
		hr=DP_OK;
	} else {
		// bogus, don't want this reply
		DPF(0,"Rejecting Reply Command x%x I'm waiting for a x%x\n",dwReplyCommand,this->dwReplyCommand);
		hr=DPERR_NOTHANDLED;
	}
	LeaveCriticalSection(&this->ReplyCS);
	return hr;
}

// called by DirectPlayCreate,DirectPlayConnect
// pCallbacks is the vtbl we want to create w/
HRESULT InternalCreate(LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter,
	LPDPLCONNECTION lpConnect,LPVOID pCallbacks) 
{
    LPDPLAYI_DPLAY this=NULL;
	LPDPLAYI_DPLAY_INT pInt=NULL;
	HRESULT hr;
						
    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }
   
    TRY
    {
    	if (lplpDP == NULL)
    	{
        	DPF_ERR("NULL pointer for receiving LPDIRECTPLAY!");
			return DPERR_INVALIDPARAMS;
    	}
    	
        *lplpDP = NULL;
        if (!VALID_READ_GUID_PTR(lpGUID))
        {
        	DPF_ERR("invalid guid!");
			return DPERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if (gbDX3SP)
	{
		DPF_ERR("DX3 Service Provider loaded - unable to create another DirectPlay object");
		return DPERR_ALREADYINITIALIZED;
	}

#if 0

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif

    this = DPMEM_ALLOC(sizeof(DPLAYI_DPLAY));
    if (!this) 
    {
    	DPF_ERR("out of memory");
        return E_OUTOFMEMORY;
    }

	this->dwSize = sizeof(DPLAYI_DPLAY);

	// set AppHack flags.
	hr=GetAppHacks(this);
	
	// allocate cached memory pools
	if(DP_OK != AllocMemoryPools(this)){
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
	}

	// allocate support for handling replies.
	if(DP_OK != InitReply(this)){
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
	}

    // alloc the callbacks
    this->pcbSPCallbacks = DPMEM_ALLOC(sizeof(DPSP_SPCALLBACKS));
    if (!this->pcbSPCallbacks) 
    {
		DPF_ERR("could not create direct play - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
    }
	// stick our version in the table, so SP knows who they're dealing with
	this->pcbSPCallbacks->dwVersion = DPSP_MAJORVERSION;
	
	// get our aggregated lobby object
	hr = PRV_AllocateLobbyObject(this, &this->lpLobbyObject);
	if(FAILED(hr))
	{
		DPF(0,"could not create directplaylobby object. hr = 0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// get an idirectplay
	hr = GetInterface(this,&pInt,pCallbacks);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplay object. hr = 0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// are we loading a real SP, or were we called by our classfactory
	// in response to CoCreateInstance?
	if (IsEqualGUID(lpGUID,&GUID_NULL))
	{
		DPF(2,"InternalCreate - using class factory guid");
		this->dwFlags |= DPLAYI_DPLAY_UNINITIALIZED;
	}
	else 
	{
		// did they ask for the local_tcp sp?  ms golf shipped a private version of this, and, it's
		// broken. instead, use our winsock sp w/ a broadcast address - this works the same way (only
		// it's not broken:-)
		if (IsEqualGUID(lpGUID,&GUID_LOCAL_TCP))
		{
			LPDPADDRESS pAddress=NULL;
			DWORD dwAddressSize=0;

			// APP HACK for MSGOLF!
			DPF(0,"detected unsupported tcp/ip service provider - forcing to dpwsockx");
			if (lpConnect)
			{
				// they gave us an address - use it
				hr = LoadSP(this,(LPGUID)&GUID_TCP,lpConnect->lpAddress,lpConnect->dwAddressSize);						
			}
			else 
			{
				// they didn't pass a connection struct, go build a broadcast address
				hr = GetTCPBroadcastAddress((IDirectPlay *)pInt,&pAddress,&dwAddressSize);
				if (FAILED(hr))	ASSERT(FALSE);

				// if it failed, pvAddress is still NULL - winsock will pop a dialog. oh well.
				hr = LoadSP(this,(LPGUID)&GUID_TCP,pAddress,dwAddressSize);
				
				if (pAddress) DPMEM_FREE(pAddress);
			}
		}
		// go get the sp they asked for
		else if (lpConnect)
		{
			hr = LoadSP(this,lpGUID,lpConnect->lpAddress,lpConnect->dwAddressSize);			
		}
		else 
		{
			hr = LoadSP(this,lpGUID,NULL,0);			
		}

		if (FAILED(hr)) 
		{
			DPF(0,"could not create direct play - load sp failed! hr = 0x%08lx\n",hr);
			goto ERROR_INTERNALCREATE;
		}
	}

	if(!(this->dwAppHacks & DPLAY_APPHACK_NOTIMER)){

		hr=InitTimerWorkaround();
		
		if(FAILED(hr)){
			DPF(0,"Could not initialize DirectPlay timer package, hr =0x%08lx\n",hr);
			goto ERROR_INTERNALCREATE;
		}

	}
	
	if(FAILED(hr)){
		DPF(0,"Could not initialize DirectPlay timer package, hr =0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// add this to the front of our dll object list
	this->pNextObject = gpObjectList;
	gpObjectList = this;
	gnObjects++;
	
	// init the min version for this object
	this->dwMinVersion = DPSP_MSG_VERSION;
		
	DPF(3,"InternalCreate :: created new dplay object.  %d objects outstanding",gnObjects);
	
    *lplpDP = (LPDIRECTPLAY)pInt;

    return DP_OK;

ERROR_INTERNALCREATE:

	if(this)
	{
		FiniReply(this);
		FreeMemoryPools(this);
		if(this->lpLobbyObject)
			PRV_DestroyDPLobby(this->lpLobbyObject);
		if(this->pcbSPCallbacks)
			DPMEM_FREE(this->pcbSPCallbacks);
		DPMEM_FREE(this);
	}

	if(pInt)
		DPMEM_FREE(pInt);

	return hr;

} // InternalCreate

HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter) 
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalCreate(lpGUID,lplpDP,pUnkOuter,NULL,&dpCallbacks);

	LEAVE_DPLAY();
	
	return hr;

}// DirectPlayCreate

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayEnumerate"

// See if a duplicate node exists
BOOL DoesDuplicateSPNodeWithDescriptionExist(LPGUID lpguid)
{
	LPSPNODE	pspNode = gSPNodes;

	while(pspNode)
	{
		// If the GUID's are equal and it had a description, return TRUE
		if(IsEqualGUID(&pspNode->guid, lpguid) &&
			(pspNode->dwNodeFlags & SPNODE_DESCRIPTION))
			return TRUE;
		   
		// Move to the next node
		pspNode = pspNode->pNextSPNode;
	}

	return FALSE;
}

void FreeSPNode(LPSPNODE pspNode)
{
	if(!pspNode)
		return;

	if(pspNode->lpszName)
		DPMEM_FREE(pspNode->lpszName);
	if(pspNode->lpszPath)
		DPMEM_FREE(pspNode->lpszPath);
	if(pspNode->lpszDescA)
		DPMEM_FREE(pspNode->lpszDescA);
	if(pspNode->lpszDescW)
		DPMEM_FREE(pspNode->lpszDescW);
	DPMEM_FREE(pspNode);
}

// Remove any duplicate SP Nodes from the list if they don't use a description
// string (workaround for pre-DX5.1 localization bug)
void RemoveDuplicateSPWithoutDescription(LPSPNODE pspNode)
{
	LPSPNODE	pspCurrent;
	LPSPNODE	pspPrev;
	LPSPNODE	pspNext;
	GUID		guid = pspNode->guid;
	

	// Move to the next node
	pspPrev = pspNode;
	pspCurrent = pspNode->pNextSPNode;

	// Walk the list
	while(pspCurrent)
	{
		// If the guids are equal and this node doesn't use a description string
		// then remove it from the list
		if((IsEqualGUID(&pspCurrent->guid, &guid)) &&
			(!(pspCurrent->dwNodeFlags & SPNODE_DESCRIPTION)))
		{
			// Remove it from the list and save the next pointer
			pspPrev->pNextSPNode = pspNext = pspCurrent->pNextSPNode;

			// free the current node
			FreeSPNode(pspCurrent);

			// Move to the next node
			pspCurrent = pspNext;
		}
		else
		{
			// Move to the next node
			pspPrev = pspCurrent;
			pspCurrent = pspCurrent->pNextSPNode;
		}
	}
}


// add a new node to the sp list
// called by GetKeyValues
HRESULT AddSPNode(LPWSTR lpszName,LPWSTR lpszGuid,LPWSTR lpszPath,DWORD dwReserved1,
			DWORD dwReserved2, DWORD dwSPFlags, LPSTR lpszDescA, LPWSTR lpszDescW)
{
	LPSPNODE pspNode=NULL;
	int iStrLen; // string length, in bytes
	HRESULT hr=DP_OK;
	GUID guid;

	// First convert the guid
	hr = GUIDFromString(lpszGuid,&guid);
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		DPF_ERR("could not parse guid");
		return hr;
	}

	// If we aren't using the description, make sure an SP Node with the same
	// guid AND a valid description doesn't already in the list.  If it does,
	// we need to skip this node and not add it
	if(!(dwSPFlags & SPNODE_DESCRIPTION))
	{
		if(DoesDuplicateSPNodeWithDescriptionExist(&guid))
		{
			DPF(8, "Duplicate SP with a description exists, skipping node");
			return DP_OK;
		}
	}

	// alloc the spnode	
	pspNode = DPMEM_ALLOC(sizeof(SPNODE));
	if (!pspNode)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		return E_OUTOFMEMORY;
	}

	// alloc the strings
	iStrLen = WSTRLEN_BYTES(lpszName);
	pspNode->lpszName = DPMEM_ALLOC(iStrLen);
	if (!pspNode->lpszName)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	memcpy(pspNode->lpszName,lpszName,iStrLen);

	iStrLen = WSTRLEN_BYTES(lpszPath);
	pspNode->lpszPath = DPMEM_ALLOC(iStrLen);
	if (!pspNode->lpszPath)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	memcpy(pspNode->lpszPath,lpszPath,iStrLen);

	iStrLen = (lpszDescA ? lstrlenA(lpszDescA) : 0);
	if(iStrLen)
	{
		// Count the null terminator since lstrlen didn't
		iStrLen++;
		pspNode->lpszDescA = DPMEM_ALLOC(iStrLen);
		if (!pspNode->lpszDescA)
		{
			DPF_ERR("could not alloc enum node - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pspNode->lpszDescA,lpszDescA,iStrLen);

		iStrLen = WSTRLEN_BYTES(lpszDescW);
		pspNode->lpszDescW = DPMEM_ALLOC(iStrLen);
		if (!pspNode->lpszDescW)
		{
			DPF_ERR("could not alloc enum node - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pspNode->lpszDescW,lpszDescW,iStrLen);
	}

	pspNode->dwReserved1 = dwReserved1;
	pspNode->dwReserved2 = dwReserved2;

	// Save the guid
	memcpy(&(pspNode->guid),&guid,sizeof(guid));

	// Save the SP Node flags (internal flags)
	pspNode->dwNodeFlags = dwSPFlags;

	// add it to the (front of the) list
	pspNode->pNextSPNode = gSPNodes;
	gSPNodes= pspNode;

	// If this SP Node has a description, we need to walk the list and remove
	// any other SP nodes with the same GUID that DO NOT have a description.
	// This will get around our pre-DX5.1 problem of enumerating SP's twice
	// on localized versions of Win95 with US versions of games installed
	// NOTE: This function assumes the first node in the list is the one
	// we just added!!!!!
	if(dwSPFlags & SPNODE_DESCRIPTION)
		RemoveDuplicateSPWithoutDescription(pspNode);
	
	return DP_OK;

ERROR_EXIT:
	FreeSPNode(pspNode);
	return hr;

} // AddSPNode

/*
 ** GetKeyValue
 *
 *  CALLED BY: RegEnumerate
 *
 *  PARAMETERS:
 *		hKey - key above service provider
 *		lpszName - name of service provider key
 *
 *  DESCRIPTION: opens the service provider key, and reads
 *		sp data
 *
 *  RETURNS:  DP_OK or E_FAIL
 *
 */

HRESULT GetKeyValues(HKEY hKey,LPWSTR lpszName) 
{
	HKEY hKeySP;	
	LONG lErr;
	DWORD dwType;
	CHAR szDescA[DPLAY_REGISTRY_NAMELEN];
	WCHAR szDescW[DPLAY_REGISTRY_NAMELEN];
	WCHAR szPath[DPLAY_REGISTRY_NAMELEN];
	DWORD cchData = 0;
	WCHAR szGuid[GUID_STRING_SIZE]; // space for guid + {,-,-,}
	HRESULT hr;
	DWORD dwReserved1=0,dwReserved2=0; // for reading dwReserved1+2
	DWORD dwSPFlags = 0;

	// open the base key  
	lErr = OS_RegOpenKeyEx(hKey,lpszName,0,KEY_READ,&hKeySP);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d\n",lErr);
		return E_FAIL;
	}

	// first see if the "Private" key exists.  If it does, then skip this SP
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Private"),NULL,&dwType,NULL,&cchData);
	if (ERROR_SUCCESS == lErr) 
	{
		// The key exists, so set the flag so we don't enumerate it
		dwSPFlags |= SPNODE_PRIVATE;
	}

	// path
	cchData = DPLAY_REGISTRY_NAMELEN * sizeof(WCHAR);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Path"),NULL,&dwType,(LPBYTE)szPath,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read path err = %d\n",lErr);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}
	DPF(5,"got path = %ls\n",szPath);

	// guid
	cchData = GUID_STRING_SIZE * sizeof(WCHAR);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Guid"),NULL,&dwType,(LPBYTE)szGuid,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read guid err = %d\n",lErr);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}
	DPF(5,"got guid = %ls\n",szGuid);

	// description A
	// NOTE: This value is always assumed to be an ANSI string, regardless of
	// which platform we are on.  On Win95, this is an ANSI (possibly multi-byte),
	// and on NT, although it is stored as Unicode, we always want to treat it
	// as an ANSI string
	cchData = sizeof(szDescA);
	lErr = RegQueryValueExA(hKeySP,"DescriptionA",NULL,&dwType,(LPBYTE)szDescA,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(5,"Could not read description err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	else
	{
		DPF(5,"got descriptionA = %s\n",szDescA);
		
		// Set our description flag
		dwSPFlags |= SPNODE_DESCRIPTION;

		// Now try to get the DescriptionW string if one exists.  If for some
		// reason a DescriptionW string exists, but the DescriptionA does not,
		// we pretend the DescriptionW string doesn't exist either.
		// NOTE: We always assume the DescriptionW string is a Unicode string,
		// even on Win95.  On Win95, this will be of the type REG_BINARY, but
		// it is really just a Unicode string.
		cchData = sizeof(szDescW);
		lErr = OS_RegQueryValueEx(hKeySP,TEXT("DescriptionW"),NULL,&dwType,(LPBYTE)szDescW,&cchData);
		if (ERROR_SUCCESS != lErr) 
		{
			DPF(5,"Could not get descriptionW, converting descriptionA");

			// We couldn't get descriptionW, so convert descriptionA...
			AnsiToWide(szDescW,szDescA,(lstrlenA(szDescA)+1));
		}
		else
		{
			DPF(5,"got descriptionW = %ls\n",szDescW);
		}

	}

	// reserved1
	cchData = sizeof(DWORD);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("dwReserved1"),NULL,&dwType,(LPBYTE)&dwReserved1,
		&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read dwReserved1 err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	DPF(5,"got dwReserved1 = %d\n",dwReserved1);

	// reserved2
	cchData = sizeof(DWORD);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("dwReserved2"),NULL,&dwType,(LPBYTE)&dwReserved2,
		&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read dwReserved2 err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	DPF(5,"got dwReserved2 = %d\n",dwReserved2);

	// If we have a description string, use it.  If not, use the key name
	hr = AddSPNode(lpszName,szGuid,szPath,dwReserved1,dwReserved2, dwSPFlags,
					szDescA, szDescW);

ERROR_EXIT:
	RegCloseKey(hKeySP);

	return hr;

} // GetKeyValues

// enumerate through the service providers stored under directplay in the
// registry
// read the data stored in the registry, and add it to our list of spnodes
HRESULT RegEnumerate() 
{
	LONG lErr;
	HKEY hKey;
	DWORD dwSubkey=0;
	WCHAR lpszName[DPLAY_REGISTRY_NAMELEN];
	DWORD cchName;
	HRESULT hr;

	// open the base key - 
	// "HKEY_LOCAL_MACHINE\Software\Microsoft\DirectPlay\Service Providers"
	lErr = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE,DPLAY_REGISTRY_PATH,0,KEY_READ,
				&hKey);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d\n",lErr);
		return E_FAIL;
	}

	// enumerate subkeys
	do
	{
		// find an sp
		cchName= DPLAY_REGISTRY_NAMELEN;
		lErr = OS_RegEnumKeyEx(hKey,dwSubkey,lpszName,&cchName,
				NULL,NULL,0,NULL);
		
		if (ERROR_SUCCESS == lErr)
		{
			hr = GetKeyValues(hKey,lpszName);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// keep trying the rest of the sp's
			}
		}
		dwSubkey++;
	} while(ERROR_NO_MORE_ITEMS != lErr );

	RegCloseKey(hKey);

	return DP_OK;

} // RegEnumerate

#define FILE_NAME_SIZE 256

// used b4 we compare module name to "mech2.exe".  it's ok to hard code for english,
// since we're just special casing this one app.
void LowerCase(char * lpsz) 
{
	while (*lpsz)
	{
	    if (*lpsz >= 'A' && *lpsz <= 'Z') *lpsz = (*lpsz - 'A' + 'a');
		lpsz++;
	}
} // LowerCase


HRESULT InternalEnumerate()
{

	HRESULT hr=DP_OK;

	if (!gSPNodes)
	{
		// enum from the registry
		hr = RegEnumerate();		
	}
	
	return hr;	
} // InternalEnumerate

HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK pCallback, LPVOID pContext)
{
	HRESULT hr;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;

    ENTER_DPLAY();

	if( !VALIDEX_CODE_PTR( pCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DPLAY();
	    return DPERR_INVALIDPARAMS;
	}

	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF(0,"could not enumerate reg entries - hr = 0x%08lx\n",hr);
		LEAVE_DPLAY();
		return hr;
	}

	// Store our head pointer, and get a temporary pointer
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the lock
	LEAVE_DPLAY();

	while ((pspNode) && (bContinue))
	{
		DWORD dwMajorVersion,dwMinorVersion;
		LPWSTR	lpwszName;

		// Use the description string if one exists
		if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
			lpwszName = pspNode->lpszDescW;
		else
			lpwszName = pspNode->lpszName;
		
		// Make sure it's not a private one
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			dwMajorVersion = HIWORD(DPSP_MAJORVERSION);
			dwMinorVersion = LOWORD(DPSP_MAJORVERSION);

			// call the app
			bContinue= pCallback(&(pspNode->guid),lpwszName,dwMajorVersion,
				dwMinorVersion,pContext);
		}

		pspNode = pspNode->pNextSPNode;
	}

    return DP_OK;	
} // DirectPlayEnumerateW

// Some DP 1.0 apps were declaring their callbacks to be _cdecl instead
// of _stdcall and relying on DPlay to generate stack frames to clean up after
// them. To keep them running we just turn on stack frame generation for this
// one call so that they keep running. Yuck.

// turn on stack frame generation (yes, I know the word "off" is in there - thank you VC)
#pragma optimize ("y", off)

HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA pCallback, LPVOID pContext)
{
	HRESULT hr;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;
	char lpszName[DPLAY_REGISTRY_NAMELEN];

    ENTER_DPLAY();

	if( !VALIDEX_CODE_PTR( pCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DPLAY();
	    return DPERR_INVALIDPARAMS;
	}

	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF(0,"could not enumerate reg entries - hr = 0x%08lx\n",hr);
		LEAVE_DPLAY();
		return hr;
	}

	// Store our head pointer, and get a temporary pointer
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the lock
	LEAVE_DPLAY();
	
	while ((pspNode) && (bContinue))
	{
		DWORD dwMajorVersion,dwMinorVersion;

		// Use the description string if one exists
		if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
		//	for backwards compat, we ANSIfy the Unicode string
			WideToAnsi(lpszName, pspNode->lpszDescW, DPLAY_REGISTRY_NAMELEN);
		else
			WideToAnsi(lpszName ,pspNode->lpszName,DPLAY_REGISTRY_NAMELEN);

		// Make sure it's not a private one
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			dwMajorVersion = HIWORD(DPSP_MAJORVERSION);
			dwMinorVersion = LOWORD(DPSP_MAJORVERSION);

			// call the app
			bContinue= pCallback(&(pspNode->guid),lpszName,dwMajorVersion,
				dwMinorVersion,pContext);
		}

		pspNode = pspNode->pNextSPNode;
	}

    return DP_OK;	

} // DirectPlayEnumerateA

// hack for compat.
// apps that linked to dp1 by name will come through this entry
#undef DirectPlayEnumerate
HRESULT WINAPI DirectPlayEnumerate( LPDPENUMDPCALLBACKA pCallback, LPVOID pContext)
{
	return DirectPlayEnumerateA(  pCallback,  pContext);
} 

// restore default optimizations
#pragma optimize ("", on)

BOOL PASCAL DummyEnumSessionsCallBack(
    LPCDPSESSIONDESC2 lpDPSGameDesc,
    LPDWORD		lpdwTimeOut,
    DWORD		dwFlags,
    LPVOID		lpContext)
{
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindSessionInSessionList"

//
// called by ConnectFindSession
LPSESSIONLIST FindSessionInSessionList(LPDPLAYI_DPLAY this,GUID const *pGuid)
{
	LPSESSIONLIST pSession = this->pSessionList;
	BOOL bFoundIt = FALSE;
	HRESULT hr=DP_OK;

	while ((pSession) && !bFoundIt)
	{
		if (IsEqualGUID((&pSession->dpDesc.guidInstance),pGuid))
		{
			bFoundIt=TRUE;
		} 
		else pSession = pSession->pNextSession;
	}
	if (!bFoundIt) 
	{
		DPF_ERR("could not find matching session");
		return NULL;
	}
	
	return pSession;
} // FindSessionInSessionList

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayConnectW"

// how long we wait between checking local session list
// for session we're searching for.  
#define ENUM_TIME 100

//
// called by ConnectMe
HRESULT AsyncConnectFindSession(LPDIRECTPLAYLOBBY pIDL,
		LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect)
{
	HRESULT hr;
	

	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,
		lpConnect->lpSessionDesc,0,DummyEnumSessionsCallBack,
		NULL,(DPENUMSESSIONS_ASYNC | DPENUMSESSIONS_RETURNSTATUS));

	ENTER_DPLAY();
	
	if(SUCCEEDED(hr) || (hr == DPERR_CONNECTING))
	{
		// Turn the async flag on to say that we are processing
		PRV_TurnAsyncConnectOn(pIDL);
	}

	if (FindSessionInSessionList(this,&(lpConnect->lpSessionDesc->guidInstance) ) )
	{
		return DP_OK;
	}

	// If things are okay, we need to return DPERR_CONNECTING to say that
	// we're still working (this gets around SP's like the winsock SP which
	// returns DP_OK during an async EnumSessions)
	if(SUCCEEDED(hr))
		return DPERR_CONNECTING;
	else
		return hr;
	
}  // AsyncConnectFindSession
		

HRESULT StopAsyncConnect(LPDIRECTPLAYLOBBY pIDL, LPDPLAYI_DPLAY this,
		LPDPLCONNECTION lpConnect)
{
	HRESULT hr;

	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
		0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_STOPASYNC);

	ENTER_DPLAY();
	
	if (FAILED(hr))
	{
		DPF_ERRVAL("Failed stopping async enum - hr = 0x%08x\n", hr);
		return hr;
	}

	return DP_OK;

} // StopAsyncConnect


// enum 'till we find the right session, or run out of time
HRESULT ConnectFindSession(LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect)
{
	// the total amount of time we'll wait to join
	DWORD dwTotalTimeout,dwTimeStarted;
    BOOL bFoundIt=FALSE;
	HRESULT hr;
	
	dwTotalTimeout = GetDefaultTimeout( this, TRUE) * DP_NAMETABLE_SCALE;

	// Now, if the value is over a minute, max it out at a minute
	if(dwTotalTimeout > DP_MAX_CONNECT_TIME)
		dwTotalTimeout = DP_MAX_CONNECT_TIME;
	DPF(3,"ConnectFindSession - total time out = %d\n",dwTotalTimeout);

	//
	// call enum once, just to kick start (e.g. get any dialogs out of 
	// the way
	 
	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
		0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_ASYNC);

	ENTER_DPLAY();
	
	if (FAILED(hr))
	{
		DPF_ERRVAL("ConnectFindSession enum failed - hr = 0x%08lx\n", hr);
		return hr;
	}

	dwTimeStarted = GetTickCount();		

	while (dwTotalTimeout > (GetTickCount() - dwTimeStarted))
	{
		if (FindSessionInSessionList(this,&(lpConnect->lpSessionDesc->guidInstance) ) )
		{
			bFoundIt = TRUE;
			break;
		}

		// we leave dplay here, since when we get to internal enum , the lock 
		// count has to be at one...
		LEAVE_DPLAY();
		
		// wait a bit, so replies can filter in...
		Sleep(ENUM_TIME);

		hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
			0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_ASYNC);

		ENTER_DPLAY();
		
		if (FAILED(hr))
		{
			DPF(0,"ConnectFindSession enum failed - hr = 0x%08lx\n");
			return hr;
		}
	} 

	if (!bFoundIt)
	{
		DPF_ERR(" !@!@!@ !@!@!@ NO SESSION WAS FOUND! TIMEOUT !@!@!@ !@!@!@ ");
		return DPERR_NOSESSIONS;
	}
	
	return DP_OK; // found it!
	
}  // ConnectFindSession
		

HRESULT ConnectMe(LPDIRECTPLAYLOBBY pIDL, LPDIRECTPLAY2 FAR *lplpDP,
		IUnknown FAR *pUnkOuter, DWORD dwFlags) 
{
	HRESULT hr=DP_OK;
	IDirectPlay2 * pIDP2 = NULL;
	LPDPLAYI_DPLAY this = NULL;
	DWORD dwConnectSize;
	LPDPLCONNECTION lpConnect = NULL;

	ENTER_DPLAY();

	// First, see if we were already called with the async flag, and
	// see if our DPlay2 and DPLCONNECTION pointers already exist
	if(dwFlags & DPCONNECT_RETURNSTATUS)
	{
		// If our pointers exist, then just get them
		PRV_GetConnectPointers(pIDL, &pIDP2, &lpConnect);
	}
	else
	{
		// Make sure we're not already in an async mode
		if(PRV_IsAsyncConnectOn(pIDL))
		{
			// Since we're in the middle of an async Connect, we don't want
			// to blow away our pointers, so we'll just exit from here.
			DPF_ERR("Connect called without the async flag with an asynchronous Connect in progress!");
			goto JUST_EXIT;
		}
	}

	// Now, if our pointers exist, we can skip this part (aka we're already
	// in the middle of an asynchronous Connect, so we have the pointers)
	if(!(pIDP2 && lpConnect))
	{
		// find out how big for connect buffer + alloc it
		hr = pIDL->lpVtbl->GetConnectionSettings(pIDL,0,NULL,&dwConnectSize);
		if (DPERR_BUFFERTOOSMALL != hr) 
		{
			// we passed NULL buffer.  If something other than too small 
			// is returned, we're hosed.
			DPF(2,"Could not get connect settings from lobby  - hr = 0x%08lx\n",hr);
			DPF(2,"Game may not have been lobbied");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}
		// alloc it
		lpConnect = DPMEM_ALLOC(dwConnectSize);
		if (!lpConnect)
		{
			DPF_ERR("could not get connect struct - out of memory");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}
		
		// set up the connect
		memset(lpConnect,0,dwConnectSize);
		lpConnect->dwSize = sizeof(DPLCONNECTION);

		// go get the connect buffer
		hr = pIDL->lpVtbl->GetConnectionSettings(pIDL,0,lpConnect,&dwConnectSize);
		if (FAILED(hr))
		{
			DPF(2,"Could not get connect settings from lobby  - hr = 0x%08lx\n",hr);
			DPF(2,"Game may not have been lobbied");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}

		ASSERT(lpConnect);

		// Send a system message to the lobby client about our status
		PRV_SendStandardSystemMessage(pIDL, DPLSYS_CONNECTIONSETTINGSREAD,
			DPLOBBYPR_GAMEID);

		hr =InternalCreate(&(lpConnect->guidSP),(LPDIRECTPLAY *)&pIDP2,NULL,lpConnect,&dpCallbacks2);
		if (FAILED(hr))
		{
			DPF(0,"internal create failed - hr = 0x%08lx\n",hr);
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}

		// If we're async, save off the DPlay2 and DPLCONNECTION pointers
		if(dwFlags & DPCONNECT_RETURNSTATUS)
			PRV_SaveConnectPointers(pIDL, pIDP2, lpConnect);
	}

	this = DPLAY_FROM_INT(pIDP2);
#ifdef DEBUG	
	hr = VALID_DPLAY_PTR( this );
	ASSERT( SUCCEEDED(hr) );
#endif 

	// if we're going to join, enum 1st. this is  so dplay will have an internal
	// list of sessions that we can then open.
	if (lpConnect->dwFlags & DPOPEN_JOIN)
	{
		// If the async flag was set, call our async version
		if(dwFlags & DPCONNECT_RETURNSTATUS)
		{
			// Call the non-asynchronous version			
			hr = AsyncConnectFindSession(pIDL,this,lpConnect);
			if (FAILED(hr))
			{
				// An error here is valid (i.e. DPERR_CONNECTING) if
				// we are doing an async Connect.  We don't want to
				// blow away any of our pointers, so just exit here.
				goto JUST_EXIT;
			}

			// Turn off the async stuff in the lobby object
			PRV_SaveConnectPointers(pIDL, NULL, NULL);
			PRV_TurnAsyncConnectOff(pIDL);
		}
		else
		{
			// Call the non-asynchronous version			
			hr = ConnectFindSession(this,lpConnect);
			if (FAILED(hr))
			{
				DPF_ERR("could not find matching session");
				// Send a system message to the lobby client about our status
				PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
					DPLOBBYPR_GAMEID);
				goto CLEANUP_EXIT;
			}
		}
	}

	// now, create or join
	hr = InternalOpenSession(this,lpConnect->lpSessionDesc,FALSE,lpConnect->dwFlags,
        TRUE,NULL,NULL);
	if (FAILED(hr))
	{
		DPF(0,"could not open session  - hr = 0x%08lx\n",hr);
		// Send a system message to the lobby client about our status
		PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
			DPLOBBYPR_GAMEID);
		goto CLEANUP_EXIT;
	}

	// Send a system message to the lobby client about our status
	PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTSUCCEEDED,
		DPLOBBYPR_GAMEID);

	// Save a copy of the lobby interface so that we can send
	// messages back to the server from inside dplay
	hr = IDirectPlayLobby_QueryInterface(pIDL, &IID_IDirectPlayLobby,
			&(this->lpLaunchingLobbyObject));
	if(FAILED(hr))
	{
		DPF(2, "Unable to QueryInterface for internal IDirectPlayLobby --");
		DPF(2, "Lobby Server will not be notified of session events");
	}

	// normal exit
	*lplpDP = pIDP2;

	// fall through

CLEANUP_EXIT:

	// If we were async, make sure our pointers are cleared
	if((dwFlags & DPCONNECT_RETURNSTATUS) && (PRV_IsAsyncConnectOn(pIDL)))
	{
		StopAsyncConnect(pIDL, this, lpConnect);
		PRV_SaveConnectPointers(pIDL, NULL, NULL);
		PRV_TurnAsyncConnectOff(pIDL);
	}

	if (lpConnect)
		DPMEM_FREE(lpConnect);

	LEAVE_DPLAY();

	if(FAILED(hr))
	{
		if (pIDP2)
			pIDP2->lpVtbl->Release(pIDP2);
	}

	return hr;

JUST_EXIT:
	
	// This lable is here to avoid doing an of the cleanup, but
	// still drop the lock in only one place.  There are several
	// exit paths (namely during an async Connect) where we
	// don't want to free our Connection Settings or our
	// IDirectPlay2 pointer.
	LEAVE_DPLAY();
	return hr;

} // ConnectMe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\apphack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.c
 *
 *  Content:	Hacks to make broken apps work
 *
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *  12/03/98  aarono        original
 *  12/03/98  aarono        Formula1 J crashes when MMTIMER starts
 ***************************************************************************/
 
#include "dplaypr.h"
//#include "winnt.h"

#define DPLAY_REGISTRY_APPHACKS "Software\\Microsoft\\DirectPlay\\Compatibility"
#define REGSTR_VAL_NAME		    "Name"
#define REGSTR_VAL_APPID	    "ID"
#define REGSTR_VAL_FLAGS	    "Flags"

__inline static BOOL fileRead( HANDLE hFile, void *data, int len )
{
    DWORD	len_read;

    if( !ReadFile( hFile,  data, (DWORD) len, &len_read, NULL ) ||
    	len_read != (DWORD) len )
    {
		return FALSE;
    }
    return TRUE;

} /* fileRead */

__inline static BOOL fileSeek( HANDLE hFile, DWORD offset )
{
    if( SetFilePointer( hFile, offset, NULL, FILE_BEGIN ) != offset )
    {
		return FALSE;
    }
    return TRUE;

} /* fileSeek */


HRESULT GetAppHacks(LPDPLAYI_DPLAY this)
{
	CHAR name[_MAX_PATH];  // general purpose
	CHAR name_last[_MAX_PATH]; // stores last component of name
	LONG lErr;
	HKEY hKey;
	HANDLE hFile;
	IMAGE_NT_HEADERS nth;
	IMAGE_DOS_HEADER dh;
	DWORD appid;

	DWORD index;
	DWORD i;

	// open the base key - 
	// "HKEY_LOCAL_MACHINE\Software\Microsoft\DirectPlay\Service Providers"
	lErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE,DPLAY_REGISTRY_APPHACKS,0,KEY_READ,&hKey);
	
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d, guess there are no apphacks\n",lErr);
		return DP_OK;	// ok, no app hacks to apply.
	}

	// ok, we now know there are some overrides to apply - so get info about this application.
    hFile =  GetModuleHandleA( NULL );
	
	GetModuleFileNameA( hFile, name, sizeof(name));

	DPF(3,"full name = %s",name);

    i = strlen( name )-1;
    while( i >=0 && name[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name_last, &name[i] );

    /*
     * go find the timestamp in the file
     */
    appid = 0;
    do
    {
        hFile = CreateFileA( name, GENERIC_READ, FILE_SHARE_READ,
	        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
	    DPF( 0, "Could not open file %s", name );
	    break;
        }
        if( !fileRead( hFile, &dh, sizeof( dh ) ) )
        {
	    DPF( 0, "Could not read DOS header for file %s", name );
	    break;
        }
        if( dh.e_magic != IMAGE_DOS_SIGNATURE )
        {
	    DPF( 0, "Invalid DOS header for file %s", name );
	    break;
        }
        if( !fileSeek( hFile, dh.e_lfanew ) )
        {
	    DPF( 0, "Could not seek to PE header in file %s", name );
	    break;
        }
        if( !fileRead( hFile, &nth, sizeof( nth ) ) )
        {
	    DPF( 0, "Could not read PE header for file %s", name );
	    break;
        }
        if( nth.Signature != IMAGE_NT_SIGNATURE )
        {
	    DPF( 0, "Bogus PE header for file %s", name );
	    break;
        }
        appid = nth.FileHeader.TimeDateStamp;
        if( appid == 0 )
        {
	    DPF( 0, "TimeDataStamp is 0 for file %s", name );
	    break;
        }
        DPF( 1, "Obtained appid: 0x%08lx", appid );
    } while(0); //fake try-except

    if(hFile != INVALID_HANDLE_VALUE){
    	CloseHandle( hFile );
    }
   	hFile=NULL;

	// now have a valid appid (timestamp) and filename, also hKey point to the apphack list.
	// apphack keys are stored as follows
    //
	// ProgramName -+-- Flags (BINARY-LO BYTE FIRST)
	//              |
	//              +-- ID (BINARY - TIMESTAMP (ID))
	//              |
	//              +-- NAME (STRING - EXE NAME)
	//
	// We will now run through looking for a matching ID and then if that matches check the name
	// if both match, we will add the flags to this->dwAppHacks 

	index = 0;
    /*
     * run through all keys
     */
    while( !RegEnumKeyA( hKey, index, name, sizeof( name ) ) )
    {
		HKEY	hsubkey;
	    DWORD	type;
	    DWORD	cb;
	    DWORD	id;
	    DWORD	flags;

		if(!RegOpenKeyA(hKey,name,&hsubkey)){

		    cb = sizeof( name );
		    if( !RegQueryValueExA( hsubkey, REGSTR_VAL_NAME, NULL, &type, name, &cb ) )
		    {
				if( type == REG_SZ )
				{
				    cb = sizeof( flags );
				    if( !RegQueryValueExA( hsubkey, REGSTR_VAL_FLAGS, NULL, &type, (LPSTR) &flags, &cb ) )
				    {
				    
						if( (type == REG_DWORD) || (type == REG_BINARY && cb == sizeof( flags )) )
						{
							cb = 4;
							if( !RegQueryValueExA( hsubkey, REGSTR_VAL_APPID, NULL, &type, (LPSTR) &id, &cb ) )
							{
							    if( (type == REG_DWORD) ||
								(type == REG_BINARY && cb == sizeof( flags )) )
							    {
									/*
									 * finally!  we have all the data. check if its the same as this one.
									 */
									 if(id==appid && !memcmp(name,name_last,cb))
									 {
									 	this->dwAppHacks |= flags;
									 	DPF(0,"Setting dwAppHacks to %x\n", this->dwAppHacks);
									 	RegCloseKey(hsubkey);
									 	break; // punt outta here.
									 }
							    } else {
									DPF( 0, "    AppID not a DWORD for app %s", name );
							    }
						    } else {
						    	DPF(0, "    AppID not Found");
						    }
					    } else {
					    	DPF( 0, "    Not BINARY DWORD flags\n");
					    }
					} else {
						DPF( 0, "    No flags found for app %s", name );
				    }
				} else	{
				    DPF( 0, "    Executable name not a string!!!" );
				}
		    } else {
				DPF( 0, "    Executable name not found!!!" );
		    }
		} else {
		    DPF( 0, "  RegOpenKey for %ld FAILED!" );
		} 
		if(hsubkey)RegCloseKey(hsubkey);
		hsubkey=NULL;
		index++;
	}

	RegCloseKey(hKey);

	return DP_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\connect.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       connect.c
 *  Content:	DirectPlay connection related methods
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *    3/1/96	andyco	   	created it
 *	3/10/97		myronth		Added lobby support for EnumConnections and
 *							InitializeConnection, fixed uninit'd struct
 *	3/25/97		kipo		EnumConnections takes a const *GUID
 *	5/10/97		kipo		added GUID to EnumConnections callback
 *	5/12/97		kipo		fixed bugs #7516, 6411, 6888
 *	5/13/97		myronth		Set DPLAYI_DPLAY_SPSECURITY flag so that dplay
 *							lets the LP do all the security for a secure session
 *  7/28/97		sohailm		FindGuidCallback() was assuming pointers were valid after
 *                          duration of call.
 *	8/22/97		myronth		Added registry support for Description and Private values
 *	11/20/97	myronth		Made EnumConnections & DirectPlayEnumerate 
 *							drop the lock before calling the callback (#15208)
 *	01/20/97	sohailm		don't free sp list after EnumConnections (#17006)
 ***************************************************************************/
						
#include "dplaypr.h"
#include "dplobby.h"


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_EnumConnections"
  

// list of all sp info gotten from the registry
extern LPSPNODE gSPNodes;
// call internalenumearte to build a list of sp's / connections
// wrap the sp's in a dpaddress
// call 'em back
HRESULT InternalEnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK pCallback,LPVOID pvContext,DWORD dwFlags,
	BOOL fAnsi, BOOL bPreDP4)
{
	HRESULT hr = DP_OK;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;
	ADDRESSHEADER header;
	DPNAME name;
	LPWSTR lpwszName;
		
	TRY
    {
		if( !VALIDEX_CODE_PTR( pCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		if ( pGuid && !VALID_READ_GUID_PTR( pGuid) )
		{
		    DPF_ERR( "Invalid guid" );
		    return DPERR_INVALIDPARAMS;
		}
		if (dwFlags & (~(DPCONNECTION_DIRECTPLAY |
						DPCONNECTION_DIRECTPLAYLOBBY)))
		{
		    DPF_ERR( "Invalid dwFlags" );
		    return DPERR_INVALIDFLAGS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	// A zero dwFlags value means enumerate all of them, so let's
	// make the code below a little easier
	if(!dwFlags)
		dwFlags = DPCONNECTION_DIRECTPLAY;

	// Enumerate lobby providers if the flags say so
	if(DPCONNECTION_DIRECTPLAYLOBBY & dwFlags)
	{
		hr = PRV_EnumConnections(pGuid, pCallback, pvContext, dwFlags, fAnsi);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
			DPF(0, "Unable to enumerate Lobby Providers, hr = 0x%08x", hr);
		}

		// If enumerating lobby providers is the only things the user
		// requested, then bail
		if(!(dwFlags & ~(DPCONNECTION_DIRECTPLAYLOBBY)))
			return hr;
	}

	// Enumerate DirectPlay Service Providers
	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF_ERRVAL("could not enumerate reg entries - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	// set up the non-changing fields in addr
	// 1st, size
	memset(&header, 0, sizeof(ADDRESSHEADER));
	header.dpaSizeChunk.guidDataType = DPAID_TotalSize;
	header.dpaSizeChunk.dwDataSize = sizeof(DWORD);		
	header.dwTotalSize = sizeof(header);

	// next, SP guid
	header.dpaSPChunk.guidDataType = DPAID_ServiceProvider;
	header.dpaSPChunk.dwDataSize = sizeof(GUID);

	memset(&name,0,sizeof(name));
	name.dwSize = sizeof(name);
	
	// now, we have a list of SP's.  walk the list, and call the app back
	// run through what we found...
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the locks
	LEAVE_ALL();

	while ((pspNode) && (bContinue))
	{
		header.guidSP = pspNode->guid;
		
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			if (fAnsi)
			{
				// Use the description if one exists, and we already
				// have an ANSI version of it, so we don't need to
				// convert it...
				if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
				{
					// a-josbor: on a PRE-DPLAY4 interface, we need to simulate the old MBCS
					//	strings, so grab the UNICODE and convert it to MBCS
					if (bPreDP4)
					{
						name.lpszShortNameA = NULL; // 0 it out!
						GetAnsiString(&(name.lpszShortNameA), pspNode->lpszDescW);
					}
					else
					{
						name.lpszShortNameA = pspNode->lpszDescA;
					}
					
					// call the app
					bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);

					if (bPreDP4)
					{
						DPMEM_FREE(name.lpszShortNameA);
					}
				}
				else
				{
					name.lpszShortNameA = NULL; // 0 it out!
					if (SUCCEEDED(GetAnsiString(&(name.lpszShortNameA),pspNode->lpszName)))
					{
						// call the app
						bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);

						DPMEM_FREE(name.lpszShortNameA);
					}
				}
			}
			else 
			{
				// Use the description if one exists
				if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
					lpwszName = pspNode->lpszDescW;
				else
					lpwszName = pspNode->lpszName;

				name.lpszShortName = lpwszName;

				// call the app
				bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);
			}
		}

		pspNode = pspNode->pNextSPNode;

	} // while

	// take the locks back
	ENTER_ALL();
	
	return DP_OK;	
		
} // InternalEnumConnections

HRESULT DPAPI DP_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;
	DPF(7,"Entering DP_EnumConnections");

	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,FALSE, FALSE);
	
	LEAVE_ALL();
		
	return hr;
	
} // DP_EnumConnections

   
HRESULT DPAPI DP_A_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;

	DPF(7,"Entering DP_A_EnumConnections");
	
	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,TRUE, FALSE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_A_EnumConnections   

HRESULT DPAPI DP_A_EnumConnectionsPreDP4(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;

	DPF(7,"Entering DP_A_EnumConnections");
	
	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,TRUE, TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_A_EnumConnectionsPreDP4   


// called by enumaddress - we're looking for DPAID_ServiceProvider
BOOL FAR PASCAL FindGuidCallback(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	// is this a sp chunk
	if (IsEqualGUID(lpguidDataType, &DPAID_ServiceProvider))
	{
		// copy the guid
		*((LPGUID)lpContext) = *((LPGUID)lpData);
		// all done!
		return FALSE;
	}
	// keep trying	
	return TRUE;

} // EnumConnectionData

// fake struct used only for pvAdress size validation - pvAddress must be at least this big
// dpaddress must have at least this must data in it to be valid for initializeconnection
typedef struct 
{
	DPADDRESS	dpaSizeChunk; // the size header
	DWORD		dwTotalSize; // the size
} MINIMALADDRESS,*LPMINIMALADDRESS;

// get our tihs ptr, and call loadsp on it
HRESULT DPAPI DP_InitializeConnection(LPDIRECTPLAY lpDP,LPVOID pvAddress,
	DWORD dwFlags)
{
	HRESULT hr = DP_OK;
	LPDPLAYI_DPLAY this;
	GUID guidSP = GUID_NULL; // the SP's guid
	LPDPADDRESS paddr;
	DWORD dwAddressSize;
				
	DPF(7,"Entering DP_InitializeConnection");

	ENTER_DPLAY();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (DPERR_UNINITIALIZED != hr)
		{
			DPF_ERR("bad or already initialized dplay ptr!");
			LEAVE_DPLAY();
			return DPERR_ALREADYINITIALIZED;
		}
		
		ASSERT(this->dwFlags & DPLAYI_DPLAY_UNINITIALIZED);
		
		// validate this address like it has never been validated before
		paddr = (LPDPADDRESS)pvAddress;
    	
		if (!VALID_READ_STRING_PTR(paddr,sizeof(MINIMALADDRESS)))
    	{
    		DPF_ERR("bad address - too small");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
    	}
		// the size needs to be the 1st chunk
		if (!IsEqualGUID(&paddr->guidDataType, &DPAID_TotalSize))
		{
			DPF_ERR(" could not extract size from pvAdress - bad pvAddress");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
		}

		// address size follows paddr
		dwAddressSize = ((MINIMALADDRESS *)paddr)->dwTotalSize;

		if (!VALID_READ_STRING_PTR(paddr,dwAddressSize))
    	{
    		DPF_ERR("bad address - too small");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
    	}
		
        if (dwFlags)
        {
        	DPF_ERR("invalid flags");
			LEAVE_DPLAY();
			return DPERR_INVALIDFLAGS;
        }
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLAY();
        return DPERR_EXCEPTION;
    }


	// First see if the DPADDRESS contains the LobbyProvider guid.  If it
	// does, load it.  If it doesn't then try looking for a DPlay SP.
 	hr = InternalEnumAddress((IDirectPlaySP *)this->pInterfaces,
			PRV_FindLPGUIDInAddressCallback,pvAddress,dwAddressSize,&guidSP);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Trying to find lobby provider guid - couldn't enum the address - hr = 0x%08lx\n",hr);
	}

	// If we found a lobby provider, try loading it
	if(!IsEqualGUID(&guidSP,&GUID_NULL))
	{
		hr = PRV_LoadSP(this->lpLobbyObject, &guidSP, pvAddress, dwAddressSize);
		if (FAILED(hr))
		{
			DPF_ERRVAL("Unable to load lobby provider - hr = 0x%08lx",hr);
			LEAVE_DPLAY();
			return hr;
		}

		// Mark the dplay object as lobby owned and consider it initialized
		// Also set the DPLAY_SPSECURITY flag so that dplay lets the LP do
		// all of the security.
		this->dwFlags |= (DPLAYI_DPLAY_LOBBYOWNS | DPLAYI_DPLAY_SPSECURITY);
		this->dwFlags &= ~DPLAYI_DPLAY_UNINITIALIZED;

		// Increment the ref cnt on the dplay object (the release code expects
		// an extra ref cnt if the object has been initialized.  This is usually
		// for the IDirectPlaySP interface, but it works just fine in our case
		// for the lobby object's lobby SP).
		this->dwRefCnt++;

		LEAVE_DPLAY();
		return hr;
	}


	// We didn't find a Lobby Provider guid, so look for the SP guid
 	hr = InternalEnumAddress((IDirectPlaySP *)this->pInterfaces,FindGuidCallback,
		pvAddress,dwAddressSize,&guidSP);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Trying to find sp guid - couldn't enum the address - hr = 0x%08lx\n",hr);
	}


	// we found the SP, so load it
	if(!IsEqualGUID(&guidSP, &GUID_NULL))
	{
		// mark dplay as init'ed, since SP may need to make some calls...	
		this->dwFlags &= ~DPLAYI_DPLAY_UNINITIALIZED;
		
		hr = LoadSP(this,&guidSP,(LPDPADDRESS)pvAddress,dwAddressSize);
		if (FAILED(hr))
		{
			DPF_ERRVAL("could not load sp - hr = 0x%08lx",hr);
			this->dwFlags |= DPLAYI_DPLAY_UNINITIALIZED;
			LEAVE_DPLAY();
			return hr;
		}

		// At this point, DirectPlay is finished loading the SP, only
		// code related to the lobby exists beyond this point, so we'll
		// just exit from here.
		LEAVE_DPLAY();
		return hr;
	}


	// We must not have found a provider we can load...
	DPF_ERR("could not find a provider in address");
	LEAVE_DPLAY();
	return DPERR_INVALIDPARAMS;
	
} // DP_InitializeConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpmem.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:	dpmem.c
*  Content:	Memory function wrappers for DirectPlay
*  History:
*   Date		By		Reason
*   ====		==		======
*	9/26/96		myronth	created it
***************************************************************************/
#include "dplaypr.h"
#include "memalloc.h"
  
#ifdef MEMFAIL
#pragma message ("NOTE: Building with the MEMFAIL option")

//
// Typedefs for memory failure functions
//
typedef enum {NONE, RANDOM, BYTES, ALLOCS, OVERSIZED, TIME} FAILKEY;

FAILKEY	g_FailKey;
DWORD	g_dwSeed=0;
DWORD	g_dwStartTime=0;
DWORD	g_dwFailAfter=0;
BOOL	g_bKeepTally=FALSE;
DWORD	g_dwAllocTally=0;
DWORD	g_dwByteTally=0;

DWORD	g_dwAllocsBeforeFail=0;
DWORD	g_dwAllocsSinceFail=0;

BOOL	DPMEM_ForceFail( UINT uSize );
void	WriteMemFailRegTally( DWORD dwAllocs, DWORD dwBytes );
void	ReadMemFailRegKeys( void );

#endif


//
// Globals
//
CRITICAL_SECTION	gcsMemoryCritSection;


//
// Definitions
//

#define ENTER_DPMEM() EnterCriticalSection(&gcsMemoryCritSection);
#define LEAVE_DPMEM() LeaveCriticalSection(&gcsMemoryCritSection);


//
// Functions
//
#undef DPF_MODNAME
#define DPF_MODNAME	"MemoryFunctions"


LPVOID DPMEM_Alloc(UINT size)
{
	LPVOID	lpv;

#ifdef MEMFAIL
	if (DPMEM_ForceFail( size ))
		return NULL;
#endif

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	lpv = MemAlloc(size);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return lpv;
}


LPVOID DPMEM_ReAlloc(LPVOID ptr, UINT size)
{
	LPVOID	lpv;

#ifdef MEMFAIL
	if (DPMEM_ForceFail( size ))
		return NULL;
#endif

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	lpv = MemReAlloc(ptr, size);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return lpv;
}


void DPMEM_Free(LPVOID ptr)
{

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	MemFree(ptr);	

	// Exit the memory critical section
	LEAVE_DPMEM();
}


BOOL DPMEM_Init()
{
	BOOL	bReturn;


	// Call the heap routine
	bReturn = MemInit();	

	return bReturn;
}


void DPMEM_Fini()
{

	// Call the heap routine
	MemFini();	

}


void DPMEM_State()
{

	// NOTE: This function is only defined for debug
#ifdef DEBUG

	// Call the heap routine
	MemState();	

#endif // DEBUG

}


UINT_PTR DPMEM_Size(LPVOID ptr)
{
	UINT_PTR	uReturn;


	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	uReturn = MemSize(ptr);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return uReturn;
}


/////////////////////
#ifdef MEMFAIL
////////////////////

void ReadMemFailRegKeys( void )
{
    HKEY	hKey	= NULL;
    HRESULT hr		= DP_OK;
	char	szFailKey[256];

    // Open the reg key
    hr  = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
						"Software\\Microsoft\\DirectPlay\\MemFail", 0, 
						KEY_READ, 
						&hKey);

	if(ERROR_SUCCESS == hr)
	{
		DWORD	dwKeyType;
		DWORD	dwBufferSize;

		dwBufferSize = 256;
		hr=RegQueryValueExA(hKey, "FailKey", NULL, &dwKeyType,
							(BYTE *)szFailKey, &dwBufferSize  );
		if (FAILED(hr))
			goto FAILURE;

		// Set the g_FailKey based on the string we got from the registry
		if (!strcmp(szFailKey, "NONE"))
			g_FailKey	= NONE;

		if (!strcmp(szFailKey, "RANDOM"))
			g_FailKey	= RANDOM;
		
		if (!strcmp(szFailKey, "BYTES"))
			g_FailKey	= BYTES;
		
		if (!strcmp(szFailKey, "ALLOCS"))
			g_FailKey	= ALLOCS;
		
		if (!strcmp(szFailKey, "OVERSIZED"))
			g_FailKey	= OVERSIZED;
		
		if (!strcmp(szFailKey, "TIME"))
			g_FailKey	= TIME;

		dwBufferSize = sizeof(DWORD);
		hr=RegQueryValueExA(hKey, "FailAfter", NULL, &dwKeyType, (BYTE *) &g_dwFailAfter, &dwBufferSize );
		if (FAILED(hr))
			goto FAILURE;

		dwBufferSize = sizeof(BOOL);
		hr=RegQueryValueExA(hKey, "KeepTally", NULL, &dwKeyType, (BYTE *) &g_bKeepTally, &dwBufferSize );
		if (FAILED(hr))
			goto FAILURE;
    }

FAILURE:
	// Close the registry key
	hr=RegCloseKey(hKey);
	return;
}



void WriteMemFailRegTally( DWORD dwAllocs, DWORD dwBytes )
{
	HRESULT		hr				= E_FAIL;
	HKEY		hKey			= NULL;

    // Open the reg key
    hr  = RegOpenKeyExA(	HKEY_LOCAL_MACHINE, 
							"Software\\Microsoft\\DirectPlay\\MemFail", 
							0,
							KEY_ALL_ACCESS, 
							&hKey );

	if (ERROR_SUCCESS != hr)
	{
		HKEY hKeyTop = NULL;
		hr  = RegOpenKeyExA(	HKEY_LOCAL_MACHINE, 
								"Software\\Microsoft\\DirectPlay", 
								0,
								KEY_ALL_ACCESS, 
								&hKeyTop);

		hr = RegCreateKeyA( hKeyTop,  "MemFail", &hKey );

		if (FAILED(hr))
			 goto FAILURE;

		RegCloseKey(hKeyTop);
	}

    hr=RegSetValueExA(hKey, "AllocTally",	0, REG_DWORD, (CONST BYTE *) &dwAllocs, sizeof(DWORD) );
    hr=RegSetValueExA(hKey, "ByteTally",	0, REG_DWORD, (CONST BYTE *) &dwBytes, sizeof(DWORD) );

FAILURE:
    // Close the registry key
    hr=RegCloseKey(hKey);
    return;
}


//
// Called with each memory allocation or reallocation
//
// Based on criteria from the registry, and the status of previous allocs
// this will either make the allocation succeed or fail.
//
BOOL DPMEM_ForceFail( UINT uSize )
{
	BOOL	bFail=FALSE;

	// If this is the first call, initialize the seed
	if (!g_dwSeed)
	{
		g_dwSeed	= GetTickCount();
		srand( g_dwSeed );
	}

	// Store the time of the first memory allocation
	if (!g_dwStartTime)
		g_dwStartTime	= GetTickCount();
	 
	// See what values are in the registry
	ReadMemFailRegKeys();

	//
	// Depending on what value the FailKey reg entry holds, fail, or pass
	//
	switch (g_FailKey)
	{
		case ALLOCS:
			if (g_dwAllocTally == g_dwFailAfter)
				return TRUE;
		break;

		case BYTES:
			if ((g_dwByteTally + uSize) > g_dwFailAfter)
				return TRUE;
		break;

		case OVERSIZED:
			if ( uSize > g_dwFailAfter )
				return TRUE;
		break;

		case RANDOM:
			if (!g_dwAllocsBeforeFail && g_dwFailAfter)
				g_dwAllocsBeforeFail	= rand() % g_dwFailAfter;

			if (g_dwAllocsSinceFail == g_dwAllocsBeforeFail)
			{
				g_dwAllocsSinceFail		= 0;
				g_dwAllocsBeforeFail	= 0;
				return TRUE;
			}
			else
				g_dwAllocsSinceFail++;
		break;

		case TIME:
			if ((GetTickCount() - g_dwStartTime) > (g_dwFailAfter * 1000))
				return TRUE;
		break;
	}

	// Increment our tallys
	g_dwAllocTally++;
	g_dwByteTally += uSize;

	// Write them back to the registry, if requested
	if (g_bKeepTally)
		WriteMemFailRegTally( g_dwAllocTally, g_dwByteTally );

	return bFail;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpmem.h ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:	dpmem.h
*  Content:	Header file for memory function wrappers for DirectPlay
*  History:
*   Date		By		Reason
*   ====		==		======
*	9/26/96		myronth	created it
***************************************************************************/

extern CRITICAL_SECTION gcsMemoryCritSection; // From dpmem.c


LPVOID DPMEM_Alloc(UINT);
LPVOID DPMEM_ReAlloc(LPVOID, UINT);
void DPMEM_Free(LPVOID);
void DPMEM_Fini(void);
void DPMEM_State(void);
BOOL DPMEM_Init(void);
UINT_PTR DPMEM_Size(LPVOID);


#define INIT_DPMEM_CSECT() InitializeCriticalSection(&gcsMemoryCritSection);
#define FINI_DPMEM_CSECT() DeleteCriticalSection(&gcsMemoryCritSection);

#define DPMEM_ALLOC(size) DPMEM_Alloc(size)
#define DPMEM_REALLOC(ptr, size) DPMEM_ReAlloc(ptr, size)
#define DPMEM_FREE(ptr) DPMEM_Free(ptr)
// These can be used so bounds checker can find leaks
//#define DPMEM_ALLOC(size) GlobalAlloc(GPTR, (size))
//#define DPMEM_REALLOC(ptr,size) GlobalReAlloc(ptr, size, 0)
//#define DPMEM_FREE(ptr) GlobalFree(ptr)

#define DPMEM_FINI() DPMEM_Fini()
#define DPMEM_STATE() DPMEM_State()
#define DPMEM_INIT() DPMEM_Init()
#define DPMEM_SIZE() DPMEM_Size()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	DPlay.DLL initialization
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *   1/16		andyco	ported from dplay to dp2
 *	11/04/96	myronth	added DPAsyncData crit section initialization
 *	2/26/97		myronth	removed DPAsyncData stuff
 *	3/1/97		andyco	added print verison string
 *	3/12/97		myronth	added LobbyProvider list cleanup
 *  3/12/97     sohailm added declarations for ghConnectionEvent,gpFuncTbl,gpFuncTblA,ghSecLib
 *                      replaced session desc string cleanup code with a call to FreeDesc()
 *	3/15/97		andyco	moved freesessionlist() -> freesessionlist(this) into dpunk.c
 *  5/12/97     sohailm renamed gpFuncTbl to gpSSPIFuncTbl and ghSecLib to ghSSPI.
 *                      added declarations for gpCAPIFuncTbl, ghCAPI.
 *                      added support to free CAPI function table and unload the library.
 *	6/4/97		kipo	bug #9453: added CloseHandle(ghReplyProcessed)
 *	8/22/97		myronth	Made a function out of the SPNode cleanup code
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *   3/9/98     aarono  added init and delete of critical section for
 *                      packetize timeout list.
 ***************************************************************************/

#include "dplaypr.h"
#include "dpneed.h"
#include "dpmem.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DLLMain"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime=TRUE;
LPCRITICAL_SECTION	gpcsDPlayCritSection,
					gpcsServiceCritSection,
					gpcsDPLCritSection,
					gpcsDPLQueueCritSection,
					gpcsDPLGameNodeCritSection;
BOOL gbWin95 = TRUE;
extern LPSPNODE gSPNodes;// from api.c
extern CRITICAL_SECTION g_SendTimeOutListLock; // from paketize.c

// global event handles. these are set in handler.c when the 
// namesrvr responds to our request.
HANDLE ghEnumPlayersReplyEvent,ghRequestPlayerEvent,ghReplyProcessed, ghConnectionEvent;
#ifdef DEBUG
// count of dplay crit section
int gnDPCSCount; // count of dplay lock
#endif 
// global pointers to sspi function tables
PSecurityFunctionTableA	gpSSPIFuncTblA = NULL;  // Ansi
PSecurityFunctionTable	gpSSPIFuncTbl = NULL;   // Unicode
// global pointe to capi function table
LPCAPIFUNCTIONTABLE gpCAPIFuncTbl = NULL;

// sspi libaray handle, set when sspi is initialized
HINSTANCE ghSSPI=NULL;
// capi libaray handle, set when capi is initialized
HINSTANCE ghCAPI=NULL;

// free up the list of sp's built by directplayenum
HRESULT FreeSPList(LPSPNODE pspHead)
{
	LPSPNODE pspNext;

	while (pspHead)
	{
		// get the next node
		pspNext = pspHead->pNextSPNode;
		// free the current node
		FreeSPNode(pspHead);
		// repeat
		pspHead = pspNext;
	}
	
	return DP_OK;

} // FreeSPList

#if 0
// walk the list of dplay objects, and shut 'em down!
HRESULT CleanUpObjectList()
{
#ifdef DEBUG	
	HRESULT hr;
#endif 	
	
	DPF_ERRVAL("cleaning up %d unreleased objects",gnObjects);
	while (gpObjectList)
	{
#ifdef DEBUG	
		hr = VALID_DPLAY_PTR(gpObjectList);
		// DPERR_UNINITIALIZED is a valid failure here...
		if (FAILED(hr) && (hr != DPERR_UNINITIALIZED))
		{
			DPF_ERR("bogus dplay in object list");
			ASSERT(FALSE);
		}
#endif 
		//		
		// when this returns 0, gpObjectList will be released
		// 
		while (DP_Release((LPDIRECTPLAY)gpObjectList->pInterfaces)) ;
	}

	return DP_OK;
		
} // CleanUpObjectList

#endif 

#ifdef DEBUG
void PrintVersionString(HINSTANCE hmod)
{
	LPBYTE 				pbVersion;
 	DWORD 				dwVersionSize;
	DWORD 				dwBogus; // for some reason, GetFileVersionInfoSize wants to set something
								// to 0.  go figure.
    DWORD				dwLength=0;
	LPSTR				pszVersion=NULL;

			
	dwVersionSize = GetFileVersionInfoSizeA("dplayx.dll",&dwBogus);
	if (0 == dwVersionSize )
	{
		DPF_ERR(" could not get version size");
		return ;
	}
	
	pbVersion = DPMEM_ALLOC(dwVersionSize);
	if (!pbVersion)
	{
		DPF_ERR("could not get version ! out of memory");
		return ;
	}
	
	if (!GetFileVersionInfoA("dplayx.dll",0,dwVersionSize,pbVersion))
	{
		DPF_ERR("could not get version info!");
		goto CLEANUP_EXIT;
	}

    if( !VerQueryValueA( pbVersion, "\\StringFileInfo\\040904E4\\FileVersion", (LPVOID *)&pszVersion, &dwLength ) )
    {
		DPF_ERR("could not query version");
		goto CLEANUP_EXIT;
    }

	OutputDebugStringA("\n");

    if( NULL != pszVersion )
    {
 		DPF(0," DPLAYX.DLL - version = %s",pszVersion);
    }
	else 
	{
 		DPF(0," DPLAYX.DLL - version unknown");
	}

	OutputDebugStringA("\n");	

	// fall through
		
CLEANUP_EXIT:
	DPMEM_FREE(pbVersion);
	return ;			

} // PrintVersionString

#endif  // DEBUG

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        #if 0
        _asm 
        {
        	 int 3
        };
		#endif 
        DisableThreadLibraryCalls( hmod );
        DPFINIT(); 

		
        /*
         * is this the first time?
         */
        if( InterlockedExchange( &bFirstTime, FALSE ) )
        {
            
            ASSERT( dwRefCnt == 0 );

	        /*
	         * initialize memory
	         */
			// Init this CSect first since the memory routines use it
			INIT_DPMEM_CSECT();

            if( !DPMEM_INIT() )
            {
                LEAVE_DPLAY();
                DPF( 1, "LEAVING, COULD NOT MemInit" );
                return FALSE;
            }
	
			#ifdef DEBUG
			PrintVersionString(hmod);
			#endif 
			
	        DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
                        GetCurrentProcessId(), GetCurrentThreadId() );

			// alloc the crit section
			gpcsDPlayCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPlayCritSection) 
			{
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the service crit section
			gpcsServiceCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsServiceCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby crit section
			gpcsDPLCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby Message Queue crit section
			gpcsDPLQueueCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLQueueCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPMEM_FREE(gpcsDPLCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby game node crit section
			gpcsDPLGameNodeCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLGameNodeCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPMEM_FREE(gpcsDPLCritSection);
				DPMEM_FREE(gpcsDPLQueueCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// set up the events
			ghEnumPlayersReplyEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
			ghRequestPlayerEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
          	ghReplyProcessed = CreateEventA(NULL,TRUE,FALSE,NULL);
          	ghConnectionEvent = CreateEventA(NULL,TRUE,FALSE,NULL);

			// Initialize CriticalSection for Packetize Timeout list
			InitializeCriticalSection(&g_PacketizeTimeoutListLock);

          	INIT_DPLAY_CSECT();
			INIT_SERVICE_CSECT();
          	INIT_DPLOBBY_CSECT();
			INIT_DPLQUEUE_CSECT();
			INIT_DPLGAMENODE_CSECT();
        }

        ENTER_DPLAY();

		// Set the platform flag
		if(OS_IsPlatformUnicode())
			gbWin95 = FALSE;

        dwRefCnt++;

        LEAVE_DPLAY();
        break;

    case DLL_PROCESS_DETACH:
        
        ENTER_DPLAY();

        DPF( 2, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
                DllMain, GetCurrentProcessId(), GetCurrentThreadId() );

        dwRefCnt--;        
       	if (0==dwRefCnt) 
       	{		  
			DPF(0,"dplay going away!");

			if (0 != gnObjects)
			{
				DPF_ERR(" PROCESS UNLOADING WITH DPLAY OBJECTS UNRELEASED");			
				DPF_ERRVAL("%d unreleased objects",gnObjects);
			}
			
			FreeSPList(gSPNodes);
			gSPNodes = NULL;		// Just to be safe
			PRV_FreeLSPList(glpLSPHead);
			glpLSPHead = NULL;		// Just to be safe

			if (ghEnumPlayersReplyEvent) CloseHandle(ghEnumPlayersReplyEvent);
			if (ghRequestPlayerEvent) CloseHandle(ghRequestPlayerEvent);
			if (ghReplyProcessed) CloseHandle(ghReplyProcessed);
			if (ghConnectionEvent) CloseHandle(ghConnectionEvent);
            
			LEAVE_DPLAY();      	
       	    
       	    FINI_DPLAY_CSECT();	
			FINI_SERVICE_CSECT();
           	FINI_DPLOBBY_CSECT();
			FINI_DPLQUEUE_CSECT();
			FINI_DPLGAMENODE_CSECT();

			// Delete CriticalSection for Packetize Timeout list
			DeleteCriticalSection(&g_PacketizeTimeoutListLock); 

			DPMEM_FREE(gpcsDPlayCritSection);
			DPMEM_FREE(gpcsServiceCritSection);
			DPMEM_FREE(gpcsDPLCritSection);
			DPMEM_FREE(gpcsDPLQueueCritSection);
			DPMEM_FREE(gpcsDPLGameNodeCritSection);

            if (ghSSPI)
            {
                FreeLibrary(ghSSPI);
                ghSSPI = NULL;
            }

            OS_ReleaseCAPIFunctionTable();

            if (ghCAPI)
            {
                FreeLibrary(ghCAPI);
                ghCAPI = NULL;
            }

			// Free this last since the memory routines use it
			FINI_DPMEM_CSECT();

        #ifdef DEBUG
			DPMEM_STATE();
        #endif // debug
			DPMEM_FINI(); 
       	} 
        else
        {
            LEAVE_DPLAY();		
        }

        break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\classfac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	directplay class factory code
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	17-jan-97	andyco	created it from ddraw\classfac.c
 *	4/11/97		myronth	Added support for DirectPlayLobby objects
 ***************************************************************************/
#include "dplaypr.h"

static IClassFactoryVtbl	directPlayClassFactoryVtbl;
static IClassFactoryVtbl	directPlayLobbyClassFactoryVtbl;

typedef struct DPLAYCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD					dwRefCnt;
} DPLAYCLASSFACTORY, *LPDPLAYCLASSFACTORY;

#define VALIDEX_DIRECTPLAYCF_PTR( ptr ) \
        ((!IsBadWritePtr( ptr, sizeof( DPLAYCLASSFACTORY ))) && \
        ((ptr->lpVtbl == &directPlayClassFactoryVtbl) || \
		(ptr->lpVtbl == &directPlayLobbyClassFactoryVtbl)))
		
#define DPF_MODNAME "DPCF_QueryInterface"

/*
 * DPCF_QueryInterface
 */
STDMETHODIMP DPCF_QueryInterface(
                LPCLASSFACTORY this,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPDPLAYCLASSFACTORY	pcf;
	HRESULT hr;
	
    DPF( 2, "ClassFactory::QueryInterface" );
	
	ENTER_DPLAY();

    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
			LEAVE_DPLAY();
            return E_FAIL;
        }

        if( !VALID_DWORD_PTR( ppvObj ) )
        {
            DPF_ERR( "Invalid object ptr" );
			LEAVE_DPLAY();
            return E_INVALIDARG;
        }
        *ppvObj = NULL;

        if( !VALID_READ_GUID_PTR( riid ) )
        {
            DPF_ERR( "Invalid iid ptr" );
            LEAVE_DPLAY();
            return E_INVALIDARG;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLAY();
        return E_FAIL;
    }

    if( IsEqualIID(riid, &IID_IClassFactory) ||
                    IsEqualIID(riid, &IID_IUnknown))
    {
        pcf->dwRefCnt++; 
        *ppvObj = this;
		hr = S_OK;
    }
    else
    { 
        DPF_ERR("E_NOINTERFACE" );
		hr = E_NOINTERFACE;
    }

	LEAVE_DPLAY();
	
	return hr;
	
} /* DPCF_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_AddRef"

/*
 * DPCF_AddRef
 */
STDMETHODIMP_(ULONG) DPCF_AddRef( LPCLASSFACTORY this )
{
    LPDPLAYCLASSFACTORY pcf;

	ENTER_DPLAY();
	
    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
            LEAVE_DPLAY();
            return 0;
        }
        pcf->dwRefCnt++;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }

    DPF( 2, "ClassFactory::AddRef, dwRefCnt=%ld", pcf->dwRefCnt );
    LEAVE_DPLAY();
    return pcf->dwRefCnt;

} /* DPCF_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_Release"

/*
 * DPCF_Release
 */
STDMETHODIMP_(ULONG) DPCF_Release( LPCLASSFACTORY this )
{
    LPDPLAYCLASSFACTORY	pcf;

    ENTER_DPLAY();
    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
            LEAVE_DPLAY();
            return 0;
        }
        pcf->dwRefCnt--;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }
    DPF( 2, "ClassFactory::Release, dwRefCnt=%ld", pcf->dwRefCnt );

    if( pcf->dwRefCnt != 0 )
    {
        LEAVE_DPLAY();
        return pcf->dwRefCnt;
    }

    DPMEM_FREE( pcf );
    LEAVE_DPLAY();
    return 0;

} /* DPCF_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF::CreateInstance"

/*
 * DPCF_CreateInstance
 *
 * Creates an instance of a DirectPlay object
 */
STDMETHODIMP DPCF_CreateInstance(
                LPCLASSFACTORY this,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT			hr;
    LPDPLAYCLASSFACTORY		pcf;
	IDirectPlay * pidp;
	GUID GuidCF = GUID_NULL; 	// pass this to DirectPlayCreate
								// to indicate no load sp
	
	
    DPF( 2, "ClassFactory::CreateInstance" );

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	ENTER_DPLAY();
	
    TRY
    {
	    pcf = (LPDPLAYCLASSFACTORY) this;
	    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
	    {
	        DPF_ERR( "Invalid this ptr" );
			LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }


    /*
     * go get a DirectPlay object
     *
     */
    hr = DirectPlayCreate(&GuidCF,&pidp,NULL);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();	
		DPF_ERR("could not create DirectPlay object");
		return hr;
	}
		
    if ( !IsEqualIID(riid, &IID_IDirectPlay) )
    {
		IDirectPlay2 * pidp2;

		hr = DP_QueryInterface(pidp,riid,&pidp2);
		if (FAILED(hr))
		{
			// this will destroy our object
			pidp->lpVtbl->Release(pidp);		
			LEAVE_DPLAY();	
			DPF_ERR("could not get requested DirectPlay interface");
			return hr;
		}

		// release the idp we used to get the pidp2
		pidp->lpVtbl->Release(pidp);

		*ppvObj= (LPVOID)pidp2;
    }
	else 
	{
		*ppvObj = (LPVOID)pidp;
	}

    LEAVE_DPLAY();
    return DP_OK;

} /* DPCF_CreateInstance */


/*
 * DPCF_LobbyCreateInstance
 *
 * Creates an instance of a DirectPlay object
 */
STDMETHODIMP DPCF_LobbyCreateInstance(
                LPCLASSFACTORY this,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT			hr;
    LPDPLAYCLASSFACTORY		pcf;
	IDirectPlayLobby * pidpl;
	
	
    DPF( 2, "ClassFactory::CreateInstance" );

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	ENTER_DPLAY();
	
    TRY
    {
	    pcf = (LPDPLAYCLASSFACTORY) this;
	    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
	    {
	        DPF_ERR( "Invalid this ptr" );
			LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }


    /*
     * go get a DirectPlayLobby object
     *
     */
    hr = DirectPlayLobbyCreate(NULL,&pidpl,NULL, NULL, 0);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();	
		DPF_ERR("could not create DirectPlayLobby object");
		return hr;
	}
		
    if ( !IsEqualIID(riid, &IID_IDirectPlayLobby) )
    {
		IDirectPlayLobby2 * pidpl2;

		hr = pidpl->lpVtbl->QueryInterface(pidpl,riid,&pidpl2);
		if (FAILED(hr))
		{
			// this will destroy our object
			pidpl->lpVtbl->Release(pidpl);		
			LEAVE_DPLAY();	
			DPF_ERR("could not get requested DirectPlayLobby interface");
			return hr;
		}

		// release the idpl we used to get the pidpl2
		pidpl->lpVtbl->Release(pidpl);

		*ppvObj= (LPVOID)pidpl2;
    }
	else 
	{
		*ppvObj = (LPVOID)pidpl;
	}

    LEAVE_DPLAY();
    return DP_OK;

} /* DPCF_LobbyCreateInstance */


#undef DPF_MODNAME
#define DPF_MODNAME "DPCF::LockServer"

/*
 * DPCF_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP DPCF_LockServer(
                LPCLASSFACTORY this,
                BOOL fLock
				)
{
    HRESULT		hr;
    HANDLE		hdll;
    LPDPLAYCLASSFACTORY	pcf;

	ENTER_DPLAY();
	
    pcf = (LPDPLAYCLASSFACTORY) this;
    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Invalid this ptr" );
        return E_INVALIDARG;
    }

    /*
     * call CoLockObjectExternal
     */
    DPF( 2, "ClassFactory::LockServer" );
    hr = E_UNEXPECTED;
    hdll = LoadLibraryA( "OLE32.DLL" );
    if( hdll != NULL )
    {
        HRESULT (WINAPI * lpCoLockObjectExternal)(LPUNKNOWN, BOOL, BOOL );
        lpCoLockObjectExternal = (LPVOID) GetProcAddress( hdll, "CoLockObjectExternal" );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
            DPF_ERR( "Error! Could not get procaddr for CoLockObjectExternal" );
        }
    }
    else
    {
        DPF_ERR( "Error! Could not load OLE32.DLL" );
    }

	LEAVE_DPLAY();
	return hr;

} /* DPCF_LockServer */

#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

static IClassFactoryVtbl directPlayClassFactoryVtbl =
{
        DPCF_QueryInterface,
        DPCF_AddRef,
        DPCF_Release,
        DPCF_CreateInstance,
        DPCF_LockServer
};

static IClassFactoryVtbl directPlayLobbyClassFactoryVtbl =
{
        DPCF_QueryInterface,
        DPCF_AddRef,
        DPCF_Release,
        DPCF_LobbyCreateInstance,
        DPCF_LockServer
};

/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
HRESULT WINAPI DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPDPLAYCLASSFACTORY	pcf;
    HRESULT		hr;

	ENTER_DPLAY();
	
    TRY
    {
	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();			
	        return E_INVALIDARG;
	    }
	    *ppvObj = NULL;
	    if( !VALID_READ_GUID_PTR( rclsid ) )
	    {
	        DPF_ERR( "Invalid clsid ptr" );
	        LEAVE_DPLAY();						
	        return E_INVALIDARG;
	    }
	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();						
	        return E_INVALIDARG;
	    }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }

    /*
     * is this one of our class ids?
     */
    if( !IsEqualCLSID( rclsid, &CLSID_DirectPlay ) && 
		!IsEqualCLSID( rclsid, &CLSID_DirectPlayLobby ))
    {
		DPF_ERR("requested invalid class object");
        LEAVE_DPLAY();			
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, &IID_IUnknown ) &&
	    !IsEqualIID( riid, &IID_IClassFactory ) )
    {
        LEAVE_DPLAY();				
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = DPMEM_ALLOC( sizeof( DPLAYCLASSFACTORY ) );
    if( NULL == pcf)
    {
        LEAVE_DPLAY();
        return E_OUTOFMEMORY;
    }

    /* check the CLSID and set the appropriate vtbl
	 */
	if(IsEqualCLSID(rclsid, &CLSID_DirectPlayLobby))
		pcf->lpVtbl = &directPlayLobbyClassFactoryVtbl;
	else
		pcf->lpVtbl = &directPlayClassFactoryVtbl;

    pcf->dwRefCnt = 0;

    hr = DPCF_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DPMEM_FREE( pcf );
        *ppvObj = NULL;
        DPF( 0, "QueryInterface failed, rc=%08lx", hr );
    }
    else
    {
        DPF( 2, "DllGetClassObject succeeded, pcf=%08lx", pcf );
    }
	
    LEAVE_DPLAY();
    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
HRESULT WINAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

    DPF( 2, "DllCanUnloadNow called" );
   
	if (0 == gnObjects)
	{
		// no dplay objects, it's ok to go
		DPF(2,"OK to unload dll");
		hr = S_OK;
	}
	
    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpcpl.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpcpl.h
 *  Content:	DirectX CPL include file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-nov-96	andyco	created it
 *
 ***************************************************************************/

#ifndef __DPCPL_INCLUDED__
#define __DPCPL_INCLUDED__


#define MAX_NAME 256

typedef struct _DP_PERFDATA
{
    DWORD dwProcessID;
    UINT nSendBPS; // BPS = bytes per second
    UINT nReceiveBPS;
    UINT nSendPPS; // PPS = packets per second
    UINT nReceivePPS;
    UINT nSendErrors;
    BOOL bHost; // hosting?    
	UINT nPlayers;
    char pszSessionName[MAX_NAME];
    char pszFileName[MAX_NAME];
    char pszSPName[MAX_NAME];    
} DP_PERFDATA, * LPDP_PERFDATA;

#define FILE_MAP_SIZE sizeof(DP_PERFDATA)
#define FILE_MAP_NAME "__DPCPLMAP__"
#define EVENT_NAME  "__DPCPLEVENT__"
#define MUTEX_NAME "__DPCPLMUTEX__"
#define ACK_EVENT_NAME "__DPCPLACKEVENT__"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpprot.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpprot.h
 *  Content:	DirectPlay reliable protocol header for dplay.
 *
 *  Notes:      code backing this up in protocol.lib
 *
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 5/11/97 aarono   created
 * 2/18/98 aarono   added protos of Protocol* functions 
 * 2/19/98 aarono   eliminated ProtocolShutdown, ProtocolShutdownEx.
 *                  added FiniProtocol. Shuts down on DP_Close now.
 * 3/19/98 aarono   added ProtocolPreNotifyDeletePlayer
 ***************************************************************************/

#ifndef _DPPROT_H_
#define _DPPROT_H_

extern HRESULT WINAPI InitProtocol(LPDPLAYI_DPLAY this);
extern VOID    WINAPI FiniProtocol(LPVOID pProtocol);
extern HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData);
extern HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData);
extern HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData);
extern HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData);

// New APIs for DX6
extern HRESULT WINAPI ProtocolGetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pGetMessageQueueData);
extern HRESULT WINAPI ProtocolSendEx(LPDPSP_SENDEXDATA pSendData);
extern HRESULT WINAPI ProtocolCancel(LPDPSP_CANCELDATA pGetMessageQueueData);

// Notify protocol when a DELETEPLAYER message is pended, so it can stop any ongoing sends.
extern HRESULT WINAPI ProtocolPreNotifyDeletePlayer(LPDPLAYI_DPLAY this, DPID idPlayer);

extern DWORD bForceDGAsync;

HRESULT 
DPAPI DP_SP_ProtocolHandleMessage(
	IDirectPlaySP * pISP,
	LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,
	LPVOID pvSPHeader
	);

extern
VOID 
DPAPI DP_SP_ProtocolSendComplete(
	IDirectPlaySP * pISP,
	LPVOID          lpvContext,
	HRESULT         CompletionStatus
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dplaypr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaypr.h
 *  Content:	DirectPlay private header file
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	1/96	andyco	created it
 *	4/9/96	andyco	moved dplay private data structures here from dplayi.h 
 *	5/2/96	andyco	added dplayi_dplay_int interface pointer
 *	5/29/96	andyco	idplay2!
 *	6/8/96	andyco	moved player + group structs here from dplayi.h.
 *					replaced dplayi.h w/ dplaysp.h
 *	6/20/96	andyco	added WSTRLEN_BYTES
 *	6/22/96	kipo	added EnumConnectionData() method.
 *	6/25/96	kipo	added support for DPADDRESS.
 *	6/29/96 andyco	added localdata to player + group
 *	6/30/96	kipo	added support for CreateAddress() method.
 *  7/8/96  AjayJ   removed declaration for DP_SaveSession and DP_A_SaveSession
 *	7/24/96 andyco	changed nametable timeout to be 60 seconds
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *  8/1/96	andyco	added keep alive files, sysplayer id to player struct
 *	8/6/96	andyco	added version to players + groups
 * 	8/8/96	andyco	changed around default timeout values - we now base 
 *					(or try to) off of sp's timeout
 *  8/9/96  sohailm added hSPModule member to DPLAYI_DPLAY structure
 *	8/16/96 andyco	added pNameServer to DPLAYI_DPLAY
 *  10/1/96 sohailm added CopySessionDesc2() and DoSessionCallbacks() prototypes
 *  10/2/96 sohailm added VALID_READ_*_PTR() macros
 *                  renamed GUID validation macros to use the term GUID instead of UUID
 *                  modified VALID_READ_GUID_PTR() macro to not check for null ptr
 * 10/9/96	andyco	added gbWaitingForReply so we know when we get a (player id,enumplayers)
 *					reply from the nameserver whether anyone is waiting.
 * 10/11/96 sohailm added InternalSetSessionDesc() and SendSessionDescChanged() prototypes
 * 10/12/96	andyco	added pSysGroup to DPLAYI_DPLAY
 * 10/28/96	andyco	added update list constants, pvUpdateList, dwUpdateListSize to 
 *					group / players
 *	1/1/97	andyco	added support for system players w/ groups
 *	2/1/97	andyco	changed dplayi_dplay_nametablepending to fdplayi_dplay_pending,
 *					since we now go into pending mode for guaranteed sends (since
 *					we drop the lock.
 *	2/25/97	andyco	added dll list of dplay objects
 *	3/6/97	myronth	added support for lobby object within dplay object
 *  3/12/97 sohailm added LOGINSTATE(enum type), NAMETABLE_PHCONTEXT(constant), pvData field
 *                  to nametable, security related fields to DPLAYI_PLAYER and DPLAYI_DPLAY, 
 *                  VALID_READ_DPCREDENTIALS() and VALID_READ_DPSECURITYDESC() macros, internal
 *                  error definitions, and some function prototypes.
 *	3/15/97	andyco	hung session list off of dplayi_dplay instead of being global
 *	3/17/97	kipo	added support for CreateCompoundAddress()
 *	3/20/97	myronth	Added IS_LOBBYOWNED macro
 *	3/24/97	andyco	dec debug lock counter b4 dropping lock!
 *  3/24/97 sohailm Added dwVersion field to session node and updated prototype for 
 *                  SendCreateMessage to take a session password
 *	3/25/97	kipo	EnumConnections takes a const *GUID now;
 *					added VALID_DPSESSIONDESC2_FLAGS macro
 *  3/28/97 sohailm allow DPOPEN_CREATE in the VALID_DPSESSIONDESC2_FLAGS macro so we don't break
 *                  monster truck.
 *	4/3/97	myronth	Added a few function prototypes needed by the lobby
 *					Also added dependency in dplobpr.h on this file so the
 *					lobby now pulls in all dplay internals
 *  3/31/97 sohailm Added a more descriptive comment about the reason for making DPOPEN_CREATE a valid
 *                  session desc flag.
 *  4/09/97 sohailm Added security related members (ulMaxSignatureSize and ulMaxContextBufferSize)
 *                  to DPLAYI_DPLAY structure.
 *	4/20/97	andyco	groups in groups
 *  4/23/97 sohailm Added flags DPLAYI_DPLAY_SIGNINGSUPPORTED and DPLAYI_DPLAY_ENCRYPTIONSUPPORTED.
 *  5/05/97 kipo	Added interface for CallAppEnumSessionsCallback()
 *	5/8/97	andyco	removed update list, added handy macros
 *	5/8/97	myronth	Exposed RemoveGroupFromGroup & DistributeGroupMessage to lobby
 *	5/12/97	kipo	Fixed bug #5406
 *	5/13/97	myronth	Added DPLAYI_DPLAY_SPSECURITY to override dplay handling security
 *  5/17/97 sohailm Added DPLOGIN_KEYEXCHANGE state to LOGINSTATE.
 *                  Added hCSP,hPublicKey,hEncryptionKey,hDecryptionKey,pPublicKey, 
 *                   and dwPublicKeySize to LPDPLAYI_DPLAY.
 *                  Added extern definitions for gpSSPIFuncTbl,gpSSPIFuncTblA,ghSSPI,ghCAPI.
 *                  Added macros VALID_DPSECURITYDESC_FLAGS() and VALID_DPCREDENTIALS_FLAGS() 
 *                  Added prototypes for DP_GetAccountDesc, DP_A_GetAccountDesc, and InternalGetAccountDesc().
 *	5/17/97	myronth	SendChatMessage function prototypes, structure validation macros
 *	5/18/97	kipo	added validation macros for EnumPlayers/Groups, CreatePlayer/Groups
 *  5/19/97 sohailm Added a new login state DPLOGIN_SUCCESS.
 *  5/21/97 sohailm Added VALID_SIGNING_STATE() macro and prototype for InternalHandleMessage().
 *	5/23/97	andyco	added DPLAYI_DPLAY_HANDLEMULTICAST
 *	5/23/97	kipo	Added support for return status codes
 *	5/30/97	myronth	Added GetGroupParent
 *  5/30/97 sohailm Added VALID_DPACCOUNTDESC_FLAGS() macro. Renamed GetAccountDesc and related
 *                  prototypes to GetPlayerAccount().
 *	5/30/97	kipo	Added GetPlayerFlags() and GetGroupFlags()
 *  6/09/97 sohailm Renamed DPLOGIN_ACCESSDENIED to DPERR_LOGONDENIED
 *  6/22/97 sohailm Added CLIENTINFO structure and removed NAMETABLE_PHCONTEXT.
 *                  Moved phCredential and phContext from DPLAYI_PLAYER to DPLAYI_DPLAY.
 *                  Added pClientInfo to DPALAYI_PLAYER.
 *  6/23/97 sohailm Added hServerPublicKey to DPLAYI_DPLAY and hPublicKey to CLIENTINFO.
 *	8/5/97	andyco	async addforward
 *	8/19/97	myronth	Added pointer to lobby object that launched us
 *	8/19/97	myronth	Changed the object pointer to a lobby interface pointer
 *	8/29/97	sohailm	Added VALID_SPHEADER() macro
 *	8/22/97	myronth	Added Descriptions & flags to SPNODE structure
 *	10/21/97myronth	Added IDirectPlay4 structure definitions, added hidden
 *					and owner flags to macros, added owner method prototypes
 *	10/29/97myronth	Added group owner node structure, added node pointer to
 *					player struct, added owner ID to group struct
 *	11/5/97	myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97myronth	Added VALID_CONNECT_FLAGS macro (#12541)
 *	11/19/97myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	11/24/97myronth	Fixed SetSessionDesc message for client/server (#15226)
 *	12/3/97	myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	1/21/98	myronth	Moved <mmsystem.h> include into this file for NT build
 *	1/27/98	myronth	Added prototype for NukeNameTableItem (#15255)
 *	1/28/98	sohailm	Added DP_MIN_KEEPALIVE_TIMEOUT and updated VALID_DPSESSIONDESC2_FLAGS()
 *  2/3/98  aarono  updated VALID_DPSESSIONDESC2_FLAGS()
 *  2/13/98 aarono  async support, added nPendingSends to player struct
 *  2/18/98 aarono  prototype of ConvertSendExDataToSendData for protocol
 *	2/18/98	a-peterz removed DPSESSION_OPTIMIZEBANDWIDTH.
 *  3/13/98 aarono  rearchitected packetizeandsendreliable
 *	5/11/98	a-peterz Add DPLAYI_DPLAY_ENUMACTIVE (#22920)
 *  6/6/98  aarono Fix for handling large loopback messages with protocol
 *  6/8/98  aarono Mark volatile fields
 *  6/10/98 aarono add PendingList to PLAYER and SENDPARM so we can track
 *                  pending sends and complete them on close.
 *  6/18/98 aarono fix group SendEx ASYNC to use unique Header
 *  6/19/98 aarono add last ptr for message queues, makes insert
 *                 constant time instead of O(n) where n is number
 *                 of messages in queue.
 *
 ***************************************************************************/

#ifndef __DPLAYPR_INCLUDED__
#define __DPLAYPR_INCLUDED__

#include <windows.h>
#include <stddef.h> // for offsetof
#include <sspi.h>   // for security info

#ifdef _WIN32_WINNT
#include <wincrypt.h>
#else
#define _WIN32_WINNT 0x400
#include <wincrypt.h> // for Crypto API
#undef _WIN32_WINNT
#endif

#include "dpf.h"
#include "dputils.h"
#include "dplaysp.h"
#include "dpmess.h"
#include "dpos.h"
#include "dpmem.h"
#include "dpcpl.h"
#include "dplobbyi.h"
#include "dpsecos.h"
#include "mcontext.h"
#include "fpm.h"
#include "bilink.h"
#include <mmsystem.h>

typedef struct IDirectPlayVtbl DIRECTPLAYCALLBACKS;
typedef DIRECTPLAYCALLBACKS FAR * LPDIRECTPLAYCALLBACKS;

typedef struct IDirectPlay2Vtbl DIRECTPLAYCALLBACKS2;
typedef DIRECTPLAYCALLBACKS2 FAR * LPDIRECTPLAYCALLBACKS2;

typedef struct IDirectPlay2Vtbl DIRECTPLAYCALLBACKS2A;
typedef DIRECTPLAYCALLBACKS2A FAR * LPDIRECTPLAYCALLBACKS2A;

typedef struct IDirectPlay3Vtbl DIRECTPLAYCALLBACKS3;
typedef DIRECTPLAYCALLBACKS3 FAR * LPDIRECTPLAYCALLBACKS3;

typedef struct IDirectPlay3Vtbl DIRECTPLAYCALLBACKS3A;
typedef DIRECTPLAYCALLBACKS3A FAR * LPDIRECTPLAYCALLBACKS3A;

typedef struct IDirectPlay4Vtbl DIRECTPLAYCALLBACKS4;
typedef DIRECTPLAYCALLBACKS4 FAR * LPDIRECTPLAYCALLBACKS4;

typedef struct IDirectPlay4Vtbl DIRECTPLAYCALLBACKS4A;
typedef DIRECTPLAYCALLBACKS4A FAR * LPDIRECTPLAYCALLBACKS4A;


typedef struct IDirectPlaySPVtbl DIRECTPLAYCALLBACKSSP;
typedef DIRECTPLAYCALLBACKSSP FAR * LPDIRECTPLAYCALLBACKSSP;

// these guids are from dpwsock\dpsp.h
// we use them since golf shipped a bogus service provider
// when they ask for that service provider, we force it
// to the regular tcp/ip service provider

// the regular tcp/ip service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(GUID_TCP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// the bogus service provider (bogus 'cause it still links w/ ddhelp.exe
// which is no longer dplay's friend
// {3A826E00-31DF-11d0-9CF9-00A0C90A43CB}
DEFINE_GUID(GUID_LOCAL_TCP, 
0x3a826e00, 0x31df, 0x11d0, 0x9c, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);


/********************************************************************
*                                                                    
* data structures moved from dplayi.h.  private dplay data structure 
*                                                                    
********************************************************************/

/*                      */
/* ADDRESSHEADER 		*/
/*                      */
// header for dp address.  used by InternalEnumConnections and createaddress.
typedef struct 
{
	DPADDRESS	dpaSizeChunk; // the size header
	DWORD		dwTotalSize; // the size
	DPADDRESS	dpaSPChunk; // the sp guid header
	GUID		guidSP; // the sp guid
	DPADDRESS	dpaAddressChunk; // the app's address header
	// address data follows
} ADDRESSHEADER, *LPADDRESSHEADER;



/*                      */
/* PACKET LIST	 		*/
/*                      */

#define INVALID_TIMER               0xFFFFFFFF

// each of this is a mesage that is being reconstructed on
// receive or a message that is being sent reliably using a
// simple ping-pong protocol.

typedef struct _PACKETNODE * LPPACKETNODE, *VOL LPPACKETNODE_V;
typedef struct _PACKETNODE
{
	union{
		LPPACKETNODE_V pNextPacketnode; // next packetnode in list-must be first element.		
		LPPACKETNODE_V pNext;		
	};	
	DWORD Signature;
	GUID guidMessage;     // id for this message
	LPBYTE pBuffer;       // pointer to message with extra space for SPHeader and MSG_PACKET for xmit.
	LPBYTE pMessage;      // message (excluding sp header)
	DWORD dwMessageSize;  // total size of message (excluding sp header)
	LPVOID pvSPHeader;    // header that came w/ 1st received packet, when not set, use dwIDTo/dwIDFrom and Send.
VOL	DWORD dwTotalPackets; 
VOL	DWORD dwSoFarPackets; // packets received/sent so far
	// new fields for reliability (ping-pong)
	BILINK RetryList;     // list of sends needing a retry.
	BILINK TimeoutList;   // list of sends timing out for retry.
	BOOL  bReliable;      // if set, we are doing the reliablity.
	BOOL  bReceive;       // set on all receives.
	LPDPLAYI_DPLAY lpDPlay;// dplay I/F ptr for use in TimeOuts
	DWORD dwLatency;      // assumed or observed round trip latency (ms).
	
VOL	UINT_PTR uRetryTimer;    // multi-media timer handle for re-xmit.
	DWORD Unique;
	
	UINT  tmTransmitTime; // Time of transmission of 1st try of packet.
	UINT  dwRetryCount;   // Number of times we retransmitted.
	UINT  tmLastReceive;  // Tick count we last got a receive on.
	// Fields used for Send (as opposed to Reply)
	DWORD dwIDTo;		  // To ID 
	DWORD dwIDFrom;       // From ID
	DWORD dwSendFlags;    // SendFlags
	
} PACKETNODE;


// client authentication states
typedef enum {
    DPLOGIN_NEGOTIATE,
    DPLOGIN_PROGRESS,
    DPLOGIN_ACCESSGRANTED,
    DPLOGIN_LOGONDENIED,
    DPLOGIN_ERROR,
	DPLOGIN_KEYEXCHANGE,
    DPLOGIN_SUCCESS
} LOGINSTATE;

// data structure used to store client specific information on 
// the server
typedef struct _CLIENTINFO
{
    CtxtHandle hContext;
    HCRYPTKEY hEncryptionKey;	// used for sending encrypted messages to client
    HCRYPTKEY hDecryptionKey;	// used for decrypting messages from client
    HCRYPTKEY hPublicKey;		// used for verification of signed messages from client
} CLIENTINFO, *LPCLIENTINFO;

/*                           */
/* SESSION DESCRIPTION LIST	 */
/*                           */
typedef struct _SESSIONLIST * LPSESSIONLIST, *VOL LPSESSIONLIST_V;
typedef struct _SESSIONLIST 
{
	DPSESSIONDESC2	dpDesc;
	LPVOID			pvSPMessageData;    // message data received w/ enumsessions reply
	LPSESSIONLIST_V	pNextSession;       // pointer to next session node
	DWORD			dwLastReply; // tick count when we last heard from this session
    DWORD           dwVersion;          // version of the sender
} SESSIONLIST;



/*                       */
/* PENDING LIST 		 */
/*                       */
typedef struct _PENDINGNODE * LPPENDINGNODE, *VOL LPPENDINGNODE_V;
typedef struct _PENDINGNODE 
{
	LPVOID	pMessage;
	DWORD 	dwMessageSize;
	LPVOID  pHeader;
	DPID 	idFrom,idTo;
	LPPENDINGNODE_V pNextNode;
	DWORD 	dwSendFlags;
} PENDINGNODE;

/*                       */
/* MESSAGE LIST 		 */
/*                       */
typedef struct _MESSAGENODE * LPMESSAGENODE, *VOL LPMESSAGENODE_V;
typedef struct _MESSAGENODE 
{
	LPVOID	pMessage;
	DWORD 	dwMessageSize;
	DPID 	idFrom,idTo;
	LPMESSAGENODE_V pNextMessage;
} MESSAGENODE;


/*                       */
/* NAME TABLE STUFF		 */
/*                       */

// each player id is defined as follows:
//      bits 0-15 : name table index
//      bits 16-31: uniqueness index
// the uniqueness index is used to make sure that if a location in the
// name table is reused, the user doesn't get the wrong contents
// index_mask masks off the uniqueness index from the name table index
#define INDEX_MASK 0x0000FFFF
// the initial size of the name table. when its full, we grow it by 2x.
#define NAMETABLE_INITSIZE 16
// used by nameserver to "hold" a slot for a client
#define NAMETABLE_PENDING ((DWORD)-1)

// max players is 2^16 (16 bits of index available in nametable)
#define DPLAY_MAX_PLAYERS  65536
// max buffer size is the max DWORD size
#define DPLAY_MAX_BUFFER_SIZE ((DWORD)-1)


/*                	       	*/
/* PLAYER + GROUP STUFF		*/
/*                       	*/

typedef struct _DPLAYI_PLAYER * LPDPLAYI_PLAYER,*VOL LPDPLAYI_PLAYER_V; 
typedef struct _DPLAYI_GROUP * LPDPLAYI_GROUP,*VOL LPDPLAYI_GROUP_V;
typedef struct _DPLAYI_DPLAY * LPDPLAYI_DPLAY, *VOL LPDPLAYI_DPLAY_V;
typedef struct _DPLAYI_GROUPNODE * LPDPLAYI_GROUPNODE, *VOL LPDPLAYI_GROUPNODE_V;
typedef struct _DPLAYI_SUBGROUP * LPDPLAYI_SUBGROUP, *VOL LPDPLAYI_SUBGROUP_V;
typedef struct _DPLAYI_GROUPOWNER * LPDPLAYI_GROUPOWNER, *VOL LPDPLAYI_GROUPOWNER_V;

/*                      */
/* DPLAYI_GROUPNODES    */
/*                      */
// this is a node in the list of all system players in a group, 
// each system player has a list of all local players in the group hanging
// off it
typedef struct _DPLAYI_GROUPNODE
{
        LPDPLAYI_GROUPNODE_V    pNextGroupnode; // the next groupnode in the list
        LPDPLAYI_PLAYER_V       pPlayer;
		UINT					nPlayers; // if pPlayer is a system player, nPlayers is the #
										  // of players that sysplayer has in this group
} DPLAYI_GROUPNODE;


/*                      */
/* DPLAYI_SUBGROUP    */
/*                      */
// this is a node in the list of all groups contained by a group
typedef struct _DPLAYI_SUBGROUP
{
        LPDPLAYI_SUBGROUP_V    	pNextSubgroup; // the next SUBGROUP in the list
		LPDPLAYI_GROUP_V		pGroup;
		DWORD 					dwFlags; // DPGROUP_STAGINGAREA, DPGROUP_SHORTCUT
} DPLAYI_SUBGROUP;

/*                      */
/* DPLAYI_GROUPOWNER    */
/*                      */
// this is a node in the list of groups a player is the owner of
typedef struct _DPLAYI_GROUPOWNER
{
		LPDPLAYI_GROUPOWNER_V	pNext;	// the next GROUPOWNER node in the list
		LPDPLAYI_GROUP_V		pGroup; // pointer to the group this player is the owner of
} DPLAYI_GROUPOWNER, *VOL DPLAYI_GROUPOWNER_V;

/*              */
/* DPLAYI_GROUP */
/*              */
// IMPORTANT - all fields up to dwSPDataSize must be kept the same in
// _DPLAYI_PLAYER + _DPLAYI_GROUP structs!!
typedef struct _DPLAYI_GROUP
{
    DWORD                       dwSize;
	DWORD						dwFlags;
    DPID                        dwID; // DPID for this group
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOIDV						pvPlayerData;
VOL	DWORD						dwPlayerDataSize;
	LPVOIDV						pvPlayerLocalData;
VOL	DWORD						dwPlayerLocalDataSize;
	// fields for service provider
	// service provider can store any info w/ spdata. whenever a player is created, spdata will be sent
	// w/ the rest of the player info to all remote machines.  
	LPVOID						pvSPData;   
	DWORD						dwSPDataSize; // SP sets this! 
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	DWORD						dwIDSysPlayer; // player id of this groups sys player
	DWORD						dwVersion;  // command version for system that created us
    LPDPLAYI_DPLAY              lpDP; // the dplay which created us
    DWORD                       nGroups; // # of groups to which a group belongs
	DPID						dwIDParent;	
	// fields above MUST BE kept common to player and group
    LPDPLAYI_GROUPNODE_V        pGroupnodes; // a list of the (non-system) players in the group
	LPDPLAYI_GROUPNODE_V 	    pSysPlayerGroupnodes; // a list of the system players to 
													  // whom group messages should be sent
    LPDPLAYI_GROUP_V            pNextGroup; // the list of all groups
VOL	UINT 						nPlayers; // # of players in the group
	LPDPLAYI_SUBGROUP_V			pSubgroups; // list of contained groups
VOL	UINT						nSubgroups;
	DWORD						dwOwnerID; // player id of the owner of this group (non-system player)
} DPLAYI_GROUP;

/*                      */
/* DPLAYI_PLAYER        */
/*                      */
// this is a node in the list of all players
// IMPORTANT - all fields up to dwSPDataSize must be kept the same in
// _DPLAYI_PLAYER + _DPLAYI_GROUP structs!!
typedef struct _DPLAYI_PLAYER
{
    DWORD                       dwSize;
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOIDV						pvPlayerData;
VOL	DWORD						dwPlayerDataSize;
	LPVOIDV						pvPlayerLocalData;
VOL	DWORD						dwPlayerLocalDataSize;
	// fields for service provider
	// service provider can store any info w/ spdata. whenever a player is created, spdata will be sent
	// w/ the rest of the player info to all remote machines.  
	LPVOID						pvSPData;   
	DWORD						dwSPDataSize; // SP sets this!
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	DWORD						dwIDSysPlayer; // player id of this players sys player
	DWORD						dwVersion;  // command version for system that created us
    LPDPLAYI_DPLAY              lpDP; // the dplay which created us
    DWORD                       nGroups; // # of groups to which a player belongs
	DPID						dwIDParent;		
	// fields above MUST BE kept common to player and group
    LPDPLAYI_PLAYER_V           pNextPlayer; // the list of all players
    HANDLE						hEvent; // handle to player event
	// the fields below are used w/ keep alives + player latencies
	DWORD						dwLatencyLastPing; // observed latency on last ping -used when nothing else avail.
	DWORD						dwNPings; // how many latency data points do we have
	// async
	DWORD                       nPendingSends; // count async sends that haven't completed.
	// better keepalive	- a-josbor
VOL	DWORD						dwChatterCount;	// how many times have we heard/reliably talked to player?
VOL	DWORD						dwUnansweredPings;	// how many continguous unanswered pings have there been?
VOL DWORD						dwProtLastSendBytes;	// how many bytes had we sent last time keepalives checked?
VOL	DWORD						dwProtLastRcvdBytes;	// how many bytes had we received last time keepalives checked?

	DWORD						dwTimeToDie;		// when the player should be killed due to connlost
    // security related
    LPCLIENTINFO                pClientInfo;  // pointer to client specific info
	// group owner list -- list of groups this player is the owner of
	LPDPLAYI_GROUPOWNER_V		pOwnerGroupList;
	BILINK                      PendingList;	// list of pending async sends.
} DPLAYI_PLAYER;

typedef struct _NAMETABLE 
{
    DWORD_PTR dwItem; // the data stored here
    // dwUnique is used to verify that this 
    // is a valid entry - it must match the unique index in
    // the users dpid
    DWORD dwUnique; // 0-2^16, incremented every time a new id is given out for this slot
    LPVOID pvData;  // data stored here depends on the type specified by dwItem
} NAMETABLE;

typedef struct _NAMETABLE * LPNAMETABLE, *VOL LPNAMETABLE_V;

typedef void (*FREE_ROUTINE)(LPVOID context, LPVOID pMem);

typedef struct _BufferFree {
	FREE_ROUTINE fnFree;
	LPVOID       lpvContext;
} BUFFERFREE, *LPBUFFERFREE, *PBUFFERFREE;

typedef struct _GroupHeader {
	MSG_PLAYERMESSAGE Msg;		// MUST BE AT FRONT
	struct _GroupHeader *pNext;
} GROUPHEADER, *LPGROUPHEADER, *PGROUPHEADER;

#define MAX_SG	8		// Maximum Scatter Gather Entries for a send - internal only.

// Send Paramters structure, used to lower the stack load in send path.
typedef struct _SENDPARMS {

	LPVOID           pPoolLink; // reserve void pointer at front 
								// so cs not overwritten by pool manager

	CRITICAL_SECTION cs;

	BILINK  PendingList;		// pending list on Group or Player

	UINT    RefCount;

	LPVOID  lpData;				// user buffer pointer
	DWORD   dwDataSize;			// user buffer length

	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_PLAYER pPlayerTo;
	LPDPLAYI_GROUP  pGroupTo;

	MESSAGENODE     msn;		// for linking this struct on receiveQ

	// ++ don't reorder +++++++++++++++++++++++++++++++++++++++++++
	// The following part of the structure is exactly the same
	// content as a DPMSG_SENDCOMPLETE - don't re-order
		
	DWORD   dwType;
	DPID	idFrom;
	DPID	idTo;
	DWORD   dwFlags;
	DWORD   dwPriority;			// 0-65535, SendEx Only
	DWORD   dwTimeout;			// in milliseconds, SendEx Only
	LPVOID  lpUserContext;  	// SendEx, ASYNC only.
	PVOID   hContext;           // handle to context list
	HRESULT hr;
	DWORD   dwSendCompletionTime;
	// -- order dependancy ends here -------------------------------

	DWORD_PTR dwMsgID;            // to store ID if user not provided.
	DWORD_PTR *lpdwMsgID;			// SendEx, ASYNC only.

	DWORD   dwSendTime;         // Time we were called in SendEx

	// parallel arrays for scatter gather, kept separate so we don't
	// have to transcribet the buffers to call the SP_SendEx i/f
	UINT       cBuffers;		// Number of filled in buffers.
	DWORD      dwTotalSize;     // total size of send data.
	SGBUFFER   Buffers[MAX_SG];	// the buffers 
	BUFFERFREE BufFree[MAX_SG]; // their free routines

	// support context mappings, also hContext above...
	UINT       iContext;		// next avail context in list
	UINT       nContext;        // number of contexts in list
	
	UINT       nComplete;		// number of completions

	PGROUPHEADER pGroupHeaders;	// when sending to group we may need many headers.
	
} SENDPARMS, *PSENDPARMS, *LPSENDPARMS;


/*                      */
/* DPLAYI_FLAGS         */
/*                      */
// this dplay object is in pending mode. we're either waiting for the nametable,
// or we've dropped our lock for a guaranteed send. either way - any incoming messages get
// pushed onto the pending q
#define DPLAYI_DPLAY_PENDING 			0x00000001
// we've lost the session. bummer.
#define DPLAYI_DPLAY_SESSIONLOST		0x00000002
// dplay is closed for bidness. set when we get a close or shutdown
#define DPLAYI_DPLAY_CLOSED				0x00000004
// there is (at least one) DX3 client in the game
#define DPLAYI_DPLAY_DX3INGAME			0x00000008
// indicates we're currently flushing the pending q. means player messages don't 
// need to be copied again
#define DPLAYI_DPLAY_EXECUTINGPENDING 	0x00000010
// our sp is a dx3 sp 
#define DPLAYI_DPLAY_DX3SP			   	0x00000020
// we were created by CoCreateInstance, but no SP has been loaded yet 
// (initialize hasn't been called)
#define DPLAYI_DPLAY_UNINITIALIZED	   	0x00000040
// the service thread is doing async enums
#define DPLAYI_DPLAY_ENUM			   	0x00000080
// the service thread is doing keepalives
#define DPLAYI_DPLAY_KEEPALIVE		   	0x00000100
// the lobby owns this dplay object
#define DPLAYI_DPLAY_LOBBYOWNS			0x00000200
// dplay is providing security 
#define DPLAYI_DPLAY_SECURITY           0x00000400
// an async enum is in process
#define DPLAYI_DPLAY_ENUMACTIVE		   	0x00000800
// encryption support is available
#define DPLAYI_DPLAY_ENCRYPTION         0x00001000
// the SP is handling security
#define DPLAYI_DPLAY_SPSECURITY			0x00002000
// we're processing a multicast message
#define DPLAYI_DPLAY_HANDLEMULTICAST	0x00004000
// sp isn't reliable - startup system messages use new packetize
#define DPLAYI_DPLAY_SPUNRELIABLE       0x00008000
// running protocol exclusively for datagram and reliable
#define DPLAYI_DPLAY_PROTOCOL           0x00020000
// if set protocol need not maintain reliable receive order
#define DPLAYI_DPLAY_PROTOCOLNOORDER    0x00040000

#ifdef DPLAY_VOICE_SUPPORT
// DPOPEN_VOICE was passed to open
#define DPLAYI_DPLAY_VOICE				0x00080000
#endif // DPLAY_VOICE_SUPPORT

// We are in the transitory period between a nameserver dropping out
// and a new nameserver being elected.
#define DPLAYI_DPLAY_NONAMESERVER       0x00100000

#define DPLAYI_PROTOCOL DPLAYI_DPLAY_PROTOCOL

// flags that get reset on DP_CLOSE
// note that we don't reset enum  - this is because if we enumplayers in a remote session,
// we leave the enum thread alone on close
#define DPLAYI_DPLAY_SESSIONFLAGS (DPLAYI_DPLAY_PENDING | DPLAYI_DPLAY_SESSIONLOST | DPLAYI_DPLAY_CLOSED \
	|  DPLAYI_DPLAY_DX3INGAME | DPLAYI_DPLAY_EXECUTINGPENDING | DPLAYI_DPLAY_KEEPALIVE \
    |  DPLAYI_DPLAY_ENCRYPTION | DPLAYI_DPLAY_SECURITY | DPLAYI_DPLAY_SPSECURITY \
    |  DPLAYI_DPLAY_PROTOCOL | DPLAYI_DPLAY_SPUNRELIABLE | DPLAYI_DPLAY_PROTOCOLNOORDER \
    |  DPLAYI_DPLAY_NONAMESERVER )

/*            */
/* APP HACKS  */
/*            */

// Japanese FORMULA1 crashes when we start our periodic multimedia timer
// since they were written for DirectPlay 5.0 we turn off the timer so
// we can't support the protocol OR reliable delivery.
#define DPLAY_APPHACK_NOTIMER		0x00000001

/*                      */
/* DPLAYI_SUPERPACKEDPLAYER  */
/*                      */
// this is the structure we use to xmit player data over the net - new for dx5
// see superpac.c
typedef struct _DPLAYI_SUPERPACKEDPLAYER
{
    DWORD             		    dwFixedSize; // size of this struct
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
	DWORD						dwMask;  // bitfield indicating which optional fields are present
} DPLAYI_SUPERPACKEDPLAYER,*LPDPLAYI_SUPERPACKEDPLAYER;
	
/*                      */
/* DPLAYI_PACKEDPLAYER  */
/*                      */
// this is the structure we use to xmit player data over the net
typedef struct _DPLAYI_PACKEDPLAYER
{
    DWORD                       dwSize; // packedplayer size + short name + long name
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
    UINT                        iShortNameLength;
    UINT                        iLongNameLength; 
    DWORD                       dwSPDataSize;// sp data follows strings
	DWORD 						dwPlayerDataSize;
	DWORD						dwNumPlayers; // number of players in group. only used w/ groups.
	DWORD						dwIDSysPlayer; // id of this players sys player. player only
	DWORD						dwFixedSize; // size of packed player. we put this in struct
											//  so we can change it in future versions
	DWORD 						dwVersion; // version of this player or group
    // short name and then long name follow structure, then spdata, then playerdata
	// then, (for groups) list of player id's.
	//
	// ** added for DX5 **
	//
	DWORD						dwIDParent; // if it was creategroupingroup

} DPLAYI_PACKEDPLAYER, *LPDPLAYI_PACKEDPLAYER;

/*                      */
/* SP Node stuff		*/
/*                      */
// this is where the service provider info read from
// the registry is kept

typedef struct _SPNODE
{
	LPTSTR		lpszName;
	LPTSTR		lpszPath;
	GUID		guid;
	DWORD		dwID;
	DWORD		dwReserved1;
	DWORD		dwReserved2;
	DWORD		dwNodeFlags;
	LPSTR		lpszDescA;
	LPWSTR		lpszDescW;
	struct _SPNODE * VOL pNextSPNode;
} SPNODE,*LPSPNODE;

// flags for SP Nodes
#define		SPNODE_DESCRIPTION		(0x00000001)
#define		SPNODE_PRIVATE			(0x00000002)

// an iunknown, idirectplay or idirectplay2 interface
typedef struct _DPLAYI_DPLAY_INT * LPDPLAYI_DPLAY_INT, *VOL LPDPLAYI_DPLAY_INT_V;
typedef struct _DPLAYI_DPLAY_INT
{
	LPVOID 				lpVtbl;
	LPDPLAYI_DPLAY		lpDPlay;
VOL	LPDPLAYI_DPLAY_INT 	pNextInt;	  // next interface on the dplay object
	DWORD 				dwIntRefCnt; // reference count for this interface

} DPLAYI_DPLAY_INT;

// a list of the addforward requests sent by a host, waiting for ack
typedef struct _ADDFORWARDNODE  * LPADDFORWARDNODE, *VOL LPADDFORWARDNODE_V;
typedef struct _ADDFORWARDNODE
{
	LPADDFORWARDNODE_V 	pNextNode; // next element in list
	DPID				dwIDSysPlayer; // system player who generated the addforward
	DWORD				nAcksRecv;  // # acks so far
	DWORD				nAcksReq;  // # of acks required
	DWORD				dwGiveUpTickCount; // tick count after we give up on acks, 
											// and just send nametable
	LPVOID				pvSPHeader; // header from dwIDSysPlayer - used to reply to	
									// when we finally get the nametable
 	DPID				dpidFrom; // if it was sent secure, id for returning nametable
	DWORD				dwVersion; // version of requestor
} ADDFORWARDNODE;

// Note protocol structure is actually much larger (see protocol\arpdint.h) this is
// just the bit that the DPLAY core needs to access.
typedef struct _PROTOCOL_PART {
		//
		// Service Provider info - at top so DPLAY can access easily through protocol ptr.
		//
		IDirectPlaySP   * m_lpISP;      	       	 	//  used by SP to call back into DirectPlay 

		DWORD             m_dwSPMaxFrame;
		DWORD             m_dwSPMaxGuaranteed;
		DWORD             m_dwSPHeaderSize;

		CRITICAL_SECTION  m_SPLock;						// lock calls to SP on our own, avoids deadlocks.

} PROTOCOL_PART, *LPPROTOCOL_PART;

#ifdef DPLAY_VOICE_SUPPORT
// pointer to an open voice channel.  only one of these per dplay object.
typedef struct _DPVOICE 
{
	DPID	idVoiceTo;
	DPID	idVoiceFrom;
} DPVOICE, * LPDPVOICE;
#endif // DPLAY_VOICE_SUPPORT

// this is the "class" that implements idirectplay
typedef struct _DPLAYI_DPLAY
{
	DWORD 						dwSize;
	LPDPLAYI_DPLAY_INT_V		pInterfaces; // list of interface objects pointing to this dplay object
    DWORD                       dwRefCnt; // ref cnt for the dplay object
    DWORD                       dwFlags;  // dplayi_xxx (see dplayi.h)
    DWORD                       dwSPFlags; // Flags from last call to GetCaps on SP.
    LPDPSP_SPCALLBACKS          pcbSPCallbacks; // sp entry points
    LPDPLAYI_PLAYER_V           pPlayers; // list of all players 
    LPDPLAYI_GROUP_V            pGroups;  // list of all groups
    LPDPLAYI_PLAYER             pSysPlayer; // pointer to our system player
    LPNAMETABLE_V               pNameTable; // player id <--> player
VOL UINT						nGroups;  // total # of groups
VOL	UINT						nPlayers; // total # of players
VOL UINT                        uiNameTableSize; // current alloc'ed size of nametable
VOL UINT                        uiNameTableLastUsed; // mru name table index
    LPDPSESSIONDESC2_V          lpsdDesc; // session desc for the current session
	LPMESSAGENODE_V				pMessageList; // list of all messages for local users
	LPMESSAGENODE_V             pLastMessage; // last element in MessageList
VOL	UINT						nMessages; // # of messages in message list
	DWORD						dwSPHeaderSize; // size of sp blob
	
	LPPENDINGNODE_V				pMessagesPending; // List of commands waiting for nametable
	LPPENDINGNODE_V             pLastPendingMessage; // Last element in PendingList
	UINT						nMessagesPending; //count of commands waiting for nametable
	
	DWORD						dwSPMaxMessage; // max unreliable send size for SP
	DWORD						dwSPMaxMessageGuaranteed; // max reliable send size for SP

	// PacketizeAndSend vars.
	LPPACKETNODE_V				pPacketList;
VOL	UINT_PTR                    uPacketTickEvent;	// MM timer handle for 15 second ticker
VOL	UINT                        nPacketsTimingOut;	// number of receives we are timing out
	
	// Retry sup for FacketizeAndSendReliable
VOL	HANDLE                      hRetryThread;
VOL	HANDLE                      hRetry;			
	BILINK                      RetryList;
	
VOL	HANDLE						hDPlayThread;
    HINSTANCE                   hSPModule; // SP module instance
VOL	HANDLE						hDPlayThreadEvent;
	LPDPLAYI_PLAYER_V			pNameServer; // pointer to the player that is the 
											 // nameserver.  null if we are the nameserver
											// or if we  don't have a nameserver yet.
    LPDPLAYI_GROUP_V			pSysGroup;
	LPDPLAYI_PLAYER_V			pServerPlayer; // the apps server player

	// dwServerPlayerVersion is used to track the server's version between when we enumsessions
	// and enumplayers in a session.  It is extremely transient.  Set in GetNameTable, cleared on Send.
	UINT                        dwServerPlayerVersion; 
	
	// control panel support
	LPDP_PERFDATA 				pPerfData;
	HANDLE						hPerfThread;
	HANDLE						hPerfEvent;
    // security related (valid on server and client)
    LPDPSECURITYDESC            pSecurityDesc;      // security description
    ULONG                       ulMaxContextBufferSize; // max size of opaque buffers
    ULONG                       ulMaxSignatureSize; // max size of digital signature
    HCRYPTPROV                  hCSP;               // handle to crypto service provider
    HCRYPTKEY                   hPublicKey;         // handle to system player's public key
    LPBYTE                      pPublicKey;         // public key buffer
    DWORD                       dwPublicKeySize;    // size of public key buffer
	// security related (valid only on client)
    LPDPCREDENTIALS             pUserCredentials;   // user provided credentials
    LOGINSTATE                  LoginState;         // tells the state of authentication
    PCredHandle                 phCredential;       // pointer to player's credential handle (given by package)
    PCtxtHandle                 phContext;          // pointer to security context (client only)
    HCRYPTKEY                   hEncryptionKey;     // session key used for encryption (client only)
    HCRYPTKEY                   hDecryptionKey;     // session key used for decryption (client only)
    HCRYPTKEY                   hServerPublicKey;   // handle to system player's public key

	// pointer to the sp node for the current sp
	LPSPNODE 					pspNode;
	// data the sp can stash w/ each IDirectPlaySP	
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	IDirectPlaySP * 			pISP;
	LPDPLAYI_DPLAY_V			pNextObject; // pointer in our dll list of dplay objects
											// list is anchored at gpObjectList;
	DWORD						dwLastEnum;
	DWORD						dwLastPing;
	DWORD						dwEnumTimeout;
	LPBYTE						pbAsyncEnumBuffer;
	DWORD						dwEnumBufferSize;
	// Lobby stuff
	LPDPLOBBYI_DPLOBJECT		lpLobbyObject;	// pointer to our aggregated lobby object
	LPDIRECTPLAYLOBBY			lpLaunchingLobbyObject; // the lobby interface we were launched on

	// list of enumsessions responses
	// new sessions are added to this when handler.c receives enum responses
	LPSESSIONLIST_V				pSessionList; 
	DWORD						dwMinVersion; // the lowest version of a player in our session
	LPADDFORWARDNODE_V			pAddForwardList; // the list of addforward notifications waiting
	 											// for ack's
	LPPROTOCOL_PART             pProtocol;      // reliable protocol object

#ifdef DPLAY_VOICE_SUPPORT
	LPDPVOICE					pVoice;
#endif // DPLAY_VOICE_SUPPORT

	LPFPOOL                     lpPlayerMsgPool;  // pool of player message headers.
	LPFPOOL                     lpSendParmsPool;  // pool of send parameter blocks.
	LPFPOOL                     lpMsgNodePool;

	// Pool of contexts for async send.
	PMSGCONTEXTTABLE            pMsgContexts;   // for async interface, context mapping table.
	LPVOID                      GrpMsgContextPool[MSG_FAST_CONTEXT_POOL_SIZE+1];
	CRITICAL_SECTION            ContextTableCS;

	// Support for waiting for and accepting Reply's
	CRITICAL_SECTION            ReplyCS;		// controls access to all vars in this section
VOL	HANDLE                      hReply;			// Autoreset event to wait for replies.
VOL	DWORD                       dwReplyCommand; // command reply we are waiting for 0xFFFF == ANY
												// if this is non-zero someone is already waiting.
	LPVOIDV                     pvReplySPHeader;// if reply has SPHeader, we store it here											
	PCHAR                       pReplyBuffer;   // Reply buffer goes here until accepted.

	// a-josbor: helper for making sure we don't let more than MaxPlayers in the game
	//	only used by the NameServer
	DWORD						dwPlayerReservations;	// how many unclaimed Player ids have we given out
	DWORD						dwLastReservationTime;	// when did we give out the most recent reservation?

	// a-josbor: the version number of the sp was not previously being remembered.  Remember it.
	DWORD               		dwSPVersion;        //  version number 16 | 16 , major | minor version 

	DWORD						dwZombieCount;		// how many zombie players (conn lost)
	DWORD                       dwAppHacks;
} DPLAYI_DPLAY;

/************************************************************
*                                                            
* global variables											 
*                                                            
************************************************************/

// gpObjectList is the list of all dplay objects that exist in
// this dll.  used in dllmain and classfactory->canunloadnow
extern LPDPLAYI_DPLAY gpObjectList;
extern UINT gnObjects; // the # of dplay objects in the gpObjectList

// global event handles. these are set in handler.c when the 
// namesrvr responds to our request. 
// alloc'ed and init'ed in dllmain.c
extern HANDLE ghEnumPlayersReplyEvent,ghRequestPlayerEvent,ghReplyProcessed;

// globals to hold buffer for enum players and new player id replies
// declared in handler.c
extern LPBYTE gpRequestPlayerBuffer, gpEnumPlayersReplyBuffer;

extern LPVOID gpvEnumPlayersHeader;

// set to TRUE when someone is waiting for our reply
// set to FALSE when they give up waiting, or when the reply shows up
extern BOOL gbWaitingForReply;
extern BOOL gbWaitingForEnumReply;

// set if we have a dx3 SP loaded. see api.c
extern BOOL gbDX3SP;											

// the vtable!
extern DIRECTPLAYCALLBACKS dpCallbacks;
extern DIRECTPLAYCALLBACKS2 dpCallbacks2;
extern DIRECTPLAYCALLBACKS2A dpCallbacks2A;
extern DIRECTPLAYCALLBACKS3 dpCallbacks3;
extern DIRECTPLAYCALLBACKS3A dpCallbacks3A;
extern DIRECTPLAYCALLBACKS4 dpCallbacks4;
extern DIRECTPLAYCALLBACKS4A dpCallbacks4A;
extern DIRECTPLAYCALLBACKSSP dpCallbacksSP;

// we're running mech. hack.
extern BOOL gbMech;

// set in dllmain.c if we're running on win95 (since win95 doesn't do 
// unicode)
extern BOOL gbWin95;

// pointers to sspi function tables
extern PSecurityFunctionTableA	gpSSPIFuncTblA;
extern PSecurityFunctionTable	gpSSPIFuncTbl;
extern LPCAPIFUNCTIONTABLE      gpCAPIFuncTbl;

// global event handle, used in dpsecure.c for synchronous authentication
extern HANDLE           ghConnectionEvent;

// global module handle to SSPI DLL
extern HINSTANCE ghSSPI;

// global module handle to CAPI DLL
extern HINSTANCE ghCAPI;

/********************************************************************************
*                                                                                
* macros and other cool stuff													 
*                                                                                
********************************************************************************/

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT
// ansi strlength + 1 for the terminating null
#define STRLEN(ptr) ((NULL==ptr) ? 0 : strlen(ptr) + 1)
//
// WSTRxxx defined in dpos.c.  
// we have our own strlen and strcmp for unicode since they're not in libc.lib
// and we don't want to link to msvcrt.dll
//
// unicode strlength + 1 for terminating nulls
#define WSTRLEN OS_StrLen
#define WSTRLEN_BYTES(ptr) (OS_StrLen(ptr) * sizeof(WCHAR))
#define WSTRCMP(ptr1,ptr2) ( memcmp(ptr1,ptr2,WSTRLEN_BYTES(ptr1)) )

// get the ansi length of a unicode string
#define WSTR_ANSILENGTH(psz) ( (psz == NULL) ? 0 : WideToAnsi(NULL,psz,0) )

// registry stuff - used in api.c
#define DPLAY_REGISTRY_PATH (TEXT("Software\\Microsoft\\DirectPlay\\Service Providers"))
#define DPLAY_REGISTRY_NAMELEN 512
#define DPLAY_MAX_FILENAMELEN 512

// number of sp timeouts we wait for a reply from a namesrvr for the nametable
// for the default this is ~ 2+ minutes (125 seconds).
#define DP_NAMETABLE_SCALE 25
// number of sp timeouts we wait for a reply from the namesrvr for a player id
// for the default, this is ~ 15 seconds
#define DP_GETID_SCALE 3
// generic timeout default
#define DP_DEFAULT_TIMEOUT (5*1000)
// max timeout we will wait for connect
#define DP_MAX_CONNECT_TIME	(60*1000)

// minimum time out between keep alives
#define DP_MIN_KEEPALIVE_TIMEOUT 1000

// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

//
// !!! NOTE: when taking SERVICE_LOCK and DPLAY_LOCK, you must always take the SERVICE_LOCK FIRST !!!
//

// crit section
extern LPCRITICAL_SECTION gpcsDPlayCritSection;	// defined in dllmain.c
#define INIT_DPLAY_CSECT() InitializeCriticalSection(gpcsDPlayCritSection);
#define FINI_DPLAY_CSECT() DeleteCriticalSection(gpcsDPlayCritSection);
#ifdef DEBUG
extern int gnDPCSCount; // count of dplay lock
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;
#define LEAVE_DPLAY() gnDPCSCount--;ASSERT(gnDPCSCount>=0);LeaveCriticalSection(gpcsDPlayCritSection);
//#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;DPF(9,"++>ENTER_DPLAY() %d file: %s line: %d\n",gnDPCSCount,__FILE__,__LINE__);
//#define LEAVE_DPLAY() gnDPCSCount--;ASSERT(gnDPCSCount>=0);DPF(9,"<--LEAVE_DPLAY() %d file: %s line: %d\n",gnDPCSCount,__FILE__,__LINE__);LeaveCriticalSection(gpcsDPlayCritSection);
#else 
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection);
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection);
#endif

#define PACKETIZE_LOCK() EnterCriticalSection(&g_PacketizeTimeoutListLock);
#define PACKETIZE_UNLOCK() LeaveCriticalSection(&g_PacketizeTimeoutListLock);


// service crit section
extern LPCRITICAL_SECTION gpcsServiceCritSection;	// defined in dllmain.c
#define INIT_SERVICE_CSECT() InitializeCriticalSection(gpcsServiceCritSection);
#define FINI_SERVICE_CSECT() DeleteCriticalSection(gpcsServiceCritSection);

#ifdef DEBUG
#define ENTER_SERVICE() EnterCriticalSection(gpcsServiceCritSection);
#define LEAVE_SERVICE() LeaveCriticalSection(gpcsServiceCritSection);
#else
#define ENTER_SERVICE() EnterCriticalSection(gpcsServiceCritSection);
#define LEAVE_SERVICE() LeaveCriticalSection(gpcsServiceCritSection);
#endif

// macros to make sure we take the locks together in the correct order.
#define ENTER_ALL() ENTER_SERVICE();ENTER_DPLAY();
#define LEAVE_ALL() LEAVE_DPLAY();LEAVE_SERVICE();

#ifdef DEBUG
	#define DPF_ERRVAL(a, b)  DPF( 0, DPF_MODNAME ": " a, b );
#else
	#define DPF_ERRVAL(a, b)
#endif

#define DPLAY_FROM_INT(ptr) \
	( ptr ? ((LPDPLAYI_DPLAY_INT)ptr)->lpDPlay  : NULL)

// handy macros
#define CLIENT_SERVER(this) ( (this) && (this->lpsdDesc) \
	&& (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) )
	
// secure server is when the session desc is marked dpsession_secureserver
#define SECURE_SERVER(this)  ( (this->lpsdDesc \
	&& (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER)) )
	
// is this the nameserver?
#define IAM_NAMESERVER(this) ( this->pSysPlayer \
	&& (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
	
// validation macros

#define VALID_SIGNING_STATE(this) (                     \
        (DPLOGIN_ACCESSGRANTED == this->LoginState) ||  \
        (DPLOGIN_KEYEXCHANGE == this->LoginState) ||    \
        (DPLOGIN_SUCCESS == this->LoginState) )          

#define VALID_SPHEADER(ptr) (ptr && (DPSP_HEADER_LOCALMSG != ptr))

#define VALID_DPLAY_PLAYER( ptr ) \
        ( ptr && (ptr != (LPDPLAYI_PLAYER)NAMETABLE_PENDING) &&\
		!IsBadWritePtr( ptr, sizeof( DPLAYI_PLAYER )) && \
        ((ptr)->dwSize == sizeof(DPLAYI_PLAYER)))

#define VALID_DPLAY_GROUP( ptr ) \
        ( ptr && (ptr != (LPDPLAYI_GROUP)NAMETABLE_PENDING) &&\
		!IsBadWritePtr( ptr, sizeof( DPLAYI_GROUP )) && \
        ((ptr)->dwSize == sizeof(DPLAYI_GROUP)))

#define VALID_PLAYER_DATA( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( PLAYERDATA )) && \
        ((ptr)->dwSize == sizeof(PLAYERDATA)))

#define VALID_GROUP_DATA( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( GROUPDATA )) && \
        ((ptr)->dwSize == sizeof(GROUPDATA)))
		
#define VALID_DPLAY_INT( ptr ) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPLAYI_DPLAY_INT )) && \
        ((ptr->lpVtbl == &dpCallbacks) || (ptr->lpVtbl == &dpCallbacks2) \
        || (ptr->lpVtbl == &dpCallbacks2A) || (ptr->lpVtbl == &dpCallbacksSP) \
		|| (ptr->lpVtbl == &dpCallbacks3) || (ptr->lpVtbl == &dpCallbacks3A) \
		|| (ptr->lpVtbl == &dpCallbacks4) || (ptr->lpVtbl == &dpCallbacks4A) ) )

#define VALID_DPLAY_PTR( ptr ) \
	( (!ptr || IsBadWritePtr( ptr, sizeof( DPLAYI_DPLAY )) ) ? DPERR_INVALIDOBJECT : \
    (ptr->dwSize != sizeof(DPLAYI_DPLAY))  ? DPERR_INVALIDOBJECT : \
   	(ptr->dwFlags & DPLAYI_DPLAY_UNINITIALIZED) ? DPERR_UNINITIALIZED : DP_OK )

#define VALID_STRING_PTR(ptr,cnt) \
        (!IsBadWritePtr( ptr, cnt))

#define VALID_READ_STRING_PTR(ptr,cnt) \
        (!IsBadReadPtr( ptr, cnt))

#define VALID_WRITE_PTR(ptr,cnt) \
        (!IsBadWritePtr( ptr, cnt))

#define VALID_READ_PTR(ptr,cnt) \
        (!IsBadReadPtr( ptr, cnt))

#define VALID_ID_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(DPID)))

#define VALID_GUID_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(GUID)))

#define VALID_READ_GUID_PTR(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof(GUID)))

#define VALID_DWORD_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(DWORD)))

#define VALID_READ_DWORD_PTR(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof(DWORD)))

#define VALID_DPSESSIONDESC(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPSESSIONDESC )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC)))

#define VALID_READ_DPSESSIONDESC(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSESSIONDESC )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC)))

#define VALID_DPSESSIONDESC2(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPSESSIONDESC2 )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC2)))

#define VALID_READ_DPSESSIONDESC2(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSESSIONDESC2 )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC2)))

// DPOPEN_CREATE and DPOPEN_JOIN are valid session desc flags for Open on IDirectPlay, 
// but not for later interfaces. However, some apps (monster truc) that didn't upgrade well, 
// are passing these flags to later interfaces as well. We can't catch this error now as we'll 
// break these apps. The following macro treats these two flags as valid. Treating DPOPEN_CREATE
// as a valid flag is safe because it has not been reused. However, DPSESSION_NEWPLAYERSDISABLED
// has taken DPOPEN_JOIN's slot. Reusing this flag doesn't cause any problems because session 
// flags passed in during join are ignored in IDirectPlay2 and greater interfaces.
#define VALID_DPSESSIONDESC2_FLAGS(dwFlags) \
		(!((dwFlags) & \
				  ~(DPSESSION_NEWPLAYERSDISABLED | \
                    DPOPEN_CREATE | \
					DPSESSION_MIGRATEHOST | \
					DPSESSION_NOMESSAGEID | \
					DPSESSION_NOPLAYERMGMT | \
					DPSESSION_JOINDISABLED | \
					DPSESSION_KEEPALIVE | \
					DPSESSION_NODATAMESSAGES | \
					DPSESSION_SECURESERVER | \
					DPSESSION_PRIVATE | \
					DPSESSION_PASSWORDREQUIRED | \
					DPSESSION_CLIENTSERVER | \
					DPSESSION_MULTICASTSERVER | \
					DPSESSION_OPTIMIZELATENCY | \
					DPSESSION_DIRECTPLAYPROTOCOL | \
					DPSESSION_NOPRESERVEORDER ) \
		) )

#define VALIDEX_CODE_PTR( ptr ) \
		( ptr && !IsBadCodePtr( (LPVOID) ptr ) )

#define VALID_DPLAY_CAPS( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( DPCAPS )) && \
        (ptr->dwSize == sizeof(DPCAPS)))

#define VALID_DPNAME_PTR( ptr ) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPNAME )) && \
        (ptr->dwSize == sizeof(DPNAME)))

#define VALID_READ_DPNAME_PTR( ptr ) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPNAME )) && \
        (ptr->dwSize == sizeof(DPNAME)))

#define VALID_READ_DPSECURITYDESC(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSECURITYDESC )) && \
        (ptr->dwSize == sizeof(DPSECURITYDESC)))

#define VALID_DPSECURITYDESC_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_READ_DPCREDENTIALS(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPCREDENTIALS )) && \
        (ptr->dwSize == sizeof(DPCREDENTIALS)))

#define VALID_DPCREDENTIALS_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_DPACCOUNTDESC_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_READ_DPCHAT(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPCHAT )) && \
        (ptr->dwSize == sizeof(DPCHAT)))

#define VALID_SEND_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPSEND_GUARANTEED | \
                    DPSEND_HIGHPRIORITY | \
                    DPSEND_TRYONCE | \
                    DPSEND_OPENSTREAM | \
                    DPSEND_CLOSESTREAM | \
                    DPSEND_SIGNED | \
                    DPSEND_ENCRYPTED | \
                    DPSEND_NOSENDCOMPLETEMSG | \
                    DPSEND_NOCOPY | \
                    DPSEND_ASYNC) \
		) )

#define VALID_RECEIVE_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPRECEIVE_ALL | \
                    DPRECEIVE_TOPLAYER | \
                    DPRECEIVE_FROMPLAYER | \
                    DPRECEIVE_PEEK) \
		) )

#define VALID_CHAT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPSEND_GUARANTEED) \
		) )

#define VALID_CREATEPLAYER_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPPLAYER_SERVERPLAYER | \
                    DPPLAYER_SPECTATOR) \
		) )

#define VALID_CREATEGROUP_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPGROUP_STAGINGAREA | \
					DPGROUP_HIDDEN) \
		) )

#define VALID_ENUMPLAYERS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_GROUP | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMPLAYERS_SERVERPLAYER | \
                    DPENUMPLAYERS_SPECTATOR) \
		) )

#define VALID_ENUMGROUPPLAYERS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMPLAYERS_SERVERPLAYER | \
                    DPENUMPLAYERS_SPECTATOR) \
		) )

#define VALID_ENUMGROUPS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMGROUPS_HIDDEN | \
					DPENUMGROUPS_SHORTCUT | \
                    DPENUMGROUPS_STAGINGAREA) \
		) )

// Note: allow DPENUMSESSIONS_PREVIOUS here even though its bogus...for compat
#define VALID_ENUMSESSIONS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMSESSIONS_AVAILABLE | \
                    DPENUMSESSIONS_ALL  | \
                    DPENUMSESSIONS_PREVIOUS  | \
                    DPENUMSESSIONS_NOREFRESH  | \
                    DPENUMSESSIONS_ASYNC  | \
                    DPENUMSESSIONS_STOPASYNC  | \
                    DPENUMSESSIONS_PASSWORDREQUIRED  | \
                    DPENUMSESSIONS_RETURNSTATUS) \
		) )

#define VALID_CONNECT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPCONNECT_RETURNSTATUS) \
		) )

#define VALID_OPEN_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPOPEN_JOIN | \
                    DPOPEN_CREATE  | \
                    DPOPEN_RETURNSTATUS) \
		) )

#define DPCAPS1_SIZE (offsetof(DPCAPS,dwLatency))
#define VALID_DPLAY1_CAPS( ptr) \
		( ptr && !IsBadWritePtr( ptr, DPCAPS1_SIZE) && \
        (ptr->dwSize == DPCAPS1_SIZE))
	
#define IS_LOBBY_OWNED(ptr) \
		(ptr->dwFlags & DPLAYI_DPLAY_LOBBYOWNS)

#define CALLSP(fn,pdata) (fn(pdata))	
#define CALLSPVOID(fn) (fn())	

#define GetPlayerMessageHeader() (LPMSG_PLAYERMESSAGE)(this->lpPlayerMsgPool->Get(this->lpPlayerMsgPool))
#define PlayerMessageFreeFn this->lpPlayerMsgPool->Release
#define PlayerMessageFreeContext this->lpPlayerMsgPool

// For SENDPARM blocks
#define GetSendParms() (LPSENDPARMS)(this->lpSendParmsPool->Get(this->lpSendParmsPool))
#define FreeSendParms(_psp) (this->lpSendParmsPool->Release(this->lpSendParmsPool,(_psp)))

// For MessageNodes
//#define GetMessageNode() (LPMESSAGENODE)(this->lpMsgNodePool->Get(this->lpMsgNodePool))
//#define FreeMessageNode(_pmsn) (this->lpMsgNodePool->Release(this->lpMsgNodePool,(_pmsn))) 

#define TRY 		_try
#define EXCEPT(a)	_except( a )

typedef struct IDirectPlayVtbl DIRECTPLAYCALLBACKS;
#define DPAPI WINAPI

// constants for passing to inernalenumxxxx
enum 
{
	ENUM_2,
	ENUM_2A,
	ENUM_1
};

// constants for passing to internalreceive
enum 
{
	RECEIVE_2,
	RECEIVE_2A,
	RECEIVE_1
};

/********************************************************************
*                                                                    
* internal errors														 
*                                                                    
********************************************************************/
#define _FACDPI  0x786
#define MAKE_DPIHRESULT( code )    MAKE_HRESULT( 1, _FACDPI, code )

#define DPERR_VERIFYSIGNFAILED                MAKE_DPIHRESULT(  1000 )
#define DPERR_DECRYPTIONFAILED                MAKE_DPIHRESULT(  1010 )


/********************************************************************
*                                                                    
* prototypes														 
*                                                                    
********************************************************************/

// dpunk.c
extern HRESULT 	DPAPI DP_QueryInterface(LPDIRECTPLAY,REFIID riid, LPVOID * ppvObj); 
extern ULONG	DPAPI DP_AddRef(LPDIRECTPLAY);  
extern ULONG 	DPAPI DP_Release(LPDIRECTPLAY); 
extern HRESULT 	GetInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT * ppInt,LPVOID pCallbacks);
extern HRESULT 	FreeSessionList(LPDPLAYI_DPLAY this);

// iplay.c

extern HRESULT DPAPI DP_AddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer); 
extern HRESULT DPAPI DP_CancelMessage(LPDIRECTPLAY lpDP, DWORD dwMsgID, DWORD dwFlags);
extern HRESULT DPAPI DP_CancelPriority(LPDIRECTPLAY lpDP, DWORD dwMinPriority, DWORD dwMaxPriority,DWORD dwFlags);
extern HRESULT DPAPI DP_Close(LPDIRECTPLAY lpDP); 
extern HRESULT DPAPI DP_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_DeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer); 
extern HRESULT DPAPI DP_DestroyPlayer(LPDIRECTPLAY lpDP, DPID idPlayer); 
extern HRESULT DPAPI DP_DestroyGroup(LPDIRECTPLAY lpDP, DPID idGroup); 
extern HRESULT DPAPI DP_EnableNewPlayers(LPDIRECTPLAY lpDP, BOOL bEnable); 
extern HRESULT DPAPI DP_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps,DWORD dwFlags); 
extern HRESULT DPAPI DP_GetGroupParent(LPDIRECTPLAY lpDP, DPID idGroup, LPDPID pidParent);
extern HRESULT DPAPI DP_GetMessageCount(LPDIRECTPLAY lpDP, DPID idPlayer, LPDWORD pdwCount); 
extern HRESULT DPAPI DP_GetMessageQueue(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes); 
extern HRESULT DPAPI DP_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,DWORD dwFlags); 
extern HRESULT DPAPI DP_GetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_GetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_GetPlayerAddress(LPDIRECTPLAY lpDP,DPID idPlayer, LPVOID pvAddress,
	LPDWORD pdwAddressSize) ;
extern HRESULT DPAPI DP_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_Initialize(LPDIRECTPLAY lpDP, LPGUID lpGuid); 
extern HRESULT DPAPI DP_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,DWORD dwFlags ); 
extern HRESULT DPAPI DP_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
    LPVOID pvBuffer,LPDWORD pdwSize	); 
extern HRESULT DPAPI DP_Send(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
    LPVOID pvBuffer,DWORD dwBufSize	); 
extern HRESULT DPAPI DP_SendEx(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPVOID lpData, DWORD dwDataSize, DWORD dwPriority, DWORD dwTimeout, LPVOID lpContext,
	DWORD_PTR *lpdwMsgID);
extern HRESULT DPAPI DP_SetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpSDesc, DWORD dwFlags,
    LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials); 
extern HRESULT DPAPI DP_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg);
extern HRESULT InternalSetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags, 
                                      BOOL fPropagate);
extern HRESULT DPAPI DP_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags);
extern HRESULT DeallocPlayer(LPDPLAYI_PLAYER);
extern HRESULT InternalOpenSession(LPDPLAYI_DPLAY this,LPCDPSESSIONDESC2 lpSDesc,BOOL fEnumOnly,
	DWORD dwFlags,BOOL fStuffInstanceGUID,LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials);
extern HRESULT InternalGetSessionDesc(LPDIRECTPLAY lpDP,LPVOID pvBuffer,
	LPDWORD pdwSize, BOOL fAnsi);  
extern HRESULT GetPlayer(LPDPLAYI_DPLAY this,  LPDPLAYI_PLAYER * ppPlayer,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags, LPWSTR lpSessionPassword, DWORD dwLobbyID);
extern HRESULT GetGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP * ppGroup,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,DPID idParent,DWORD dwLobbyID);
extern HRESULT InternalSetData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags,BOOL fPlayer,BOOL fPropagate);
extern HRESULT InternalSetName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,BOOL fPlayer,
	DWORD dwFlags,BOOL fPropagate);
extern HRESULT CallSPCreatePlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL bLocal,
	LPVOID pvSPMessageData, BOOL bNotifyProtocol);
extern HRESULT CallSPCreateGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,BOOL bLocal,
	LPVOID pvSPMessageData);
extern HRESULT InternalGetName(LPDIRECTPLAY lpDP, DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fPlayer,BOOL fAnsi);
extern HRESULT  InternalGetData(LPDIRECTPLAY lpDP,DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags,BOOL fPlayer);
extern HRESULT InternalDestroyPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,
	BOOL fPropagate, BOOL fLookForNewNS) ;
extern HRESULT InternalDestroyGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,
	BOOL fPropagate);
extern HRESULT InternalDeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer,
	BOOL fPropagate); 
extern HRESULT InternalAddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer,
	BOOL fPropagate) ;
extern HRESULT InternalReceive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize,DWORD dwCaller	);
extern LPDPLAYI_GROUPNODE FindPlayerInGroupList(LPDPLAYI_GROUPNODE pGroupnode,DPID id);
extern HRESULT RemovePlayerFromGroup(LPDPLAYI_GROUP, LPDPLAYI_PLAYER);
extern HRESULT DPAPI DP_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) ;
extern HRESULT DPAPI DP_AddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup) ;	
extern HRESULT DPAPI DP_DeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer) ;
extern HRESULT InternalAddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup,DWORD dwFlags,
	BOOL fPropagate) ;
extern HRESULT InternalDeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,
	DPID idGroup,BOOL fPropagate);
extern HRESULT RemoveGroupFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_GROUP lpGroupRemove);
extern HRESULT DPAPI DP_GetPlayerFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_GetGroupFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_GetGroupOwner(LPDIRECTPLAY lpDP, DPID id,LPDPID idOwner);
extern HRESULT DPAPI DP_SetGroupOwner(LPDIRECTPLAY lpDP, DPID id,DPID idNewOwner);
extern HRESULT GetMaxMessageSize(LPDPLAYI_DPLAY this);
extern void FreePacketList(LPDPLAYI_DPLAY this);


// enum.c
extern HRESULT DPAPI DP_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pContext,
    DWORD dwFlags) ;
extern HRESULT DPAPI InternalEnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPVOID lpEnumCallback,DWORD dwFlags);
extern HRESULT CheckSessionDesc(LPDPSESSIONDESC2 lpsdUser,LPDPSESSIONDESC2 lpsdSession,
	DWORD dwFlags,BOOL fAnsi); 
extern HRESULT DPAPI InternalEnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
extern HRESULT DPAPI InternalEnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
extern HRESULT DPAPI InternalEnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
DWORD GetDefaultTimeout(LPDPLAYI_DPLAY this,BOOL fGuaranteed);
extern HRESULT CopySessionDesc2(LPDPSESSIONDESC2 pSessionDescDest, 
                         LPDPSESSIONDESC2 pSessionDescSrc, BOOL bAnsi);
extern HRESULT DoSessionCallbacks(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc,
	LPDWORD lpdwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags, LPBOOL lpbContinue, BOOL bAnsi);
extern HRESULT InternalEnumerate();
extern HRESULT CallSPEnumSessions(LPDPLAYI_DPLAY this,LPVOID pBuffer,DWORD dwMessageSize,
	DWORD dwTimeout, BOOL bReturnStatus);
extern HRESULT StartDPlayThread(LPDPLAYI_DPLAY this,BOOL bKeepAlive);
extern void KillThread(HANDLE hThread,HANDLE hEvent);
extern HRESULT StopEnumThread(LPDPLAYI_DPLAY this);
extern BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
				DWORD dwFlags, LPVOID lpContext);
extern HRESULT DPAPI DP_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_A_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) ;
extern HRESULT DPAPI InternalEnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) ;	

// namesrv.c
extern LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY,DWORD);
extern LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY,DWORD);
extern HRESULT AddItemToNameTable(LPDPLAYI_DPLAY,DWORD_PTR,DWORD *,BOOL,DWORD);
extern HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY ,DWORD );
extern HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this);
extern BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id);
extern LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD id);
extern DWORD_PTR NameFromID(LPDPLAYI_DPLAY, DWORD);
extern HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID);
extern HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, LPVOID pvSPHeader);
extern HRESULT GrowTable(LPDPLAYI_DPLAY this);
extern void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer);
extern void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer);

// pack.c
extern HRESULT UnpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,LPVOID pvSPHeader);
extern HRESULT PackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD *pdwBufferSize) ;
extern DWORD PackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) ;
extern HRESULT UnpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PACKEDPLAYER pPacked,
	LPVOID pvSPHeader,BOOL bPlayer);


// sysmess.c
extern HRESULT InternalSendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock);
extern HRESULT InternalSendDPMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bDropLock);
extern HRESULT SendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock);
extern HRESULT SendCreateMessage(LPDPLAYI_DPLAY this,void * pPlayerOrGroup,BOOL fPlayer, 
    LPWSTR lpszSessionPassword);
extern HRESULT SendPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize);
extern HRESULT SendPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp);
extern HRESULT SendSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,
	DWORD dwMessageSize,DWORD dwFlags, BOOL bIsPlyrMgmtMsg);
extern HRESULT SendGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage);
extern HRESULT SendGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp, BOOL fPlayerMessage);
extern HRESULT SendPlayerManagementMessage(LPDPLAYI_DPLAY this,DWORD dwCmd,DPID idPlayer,
	DPID idGroup);
extern HRESULT SendPlayerData(LPDPLAYI_DPLAY this,DPID idChanged,LPVOID pData,
	DWORD dwDataSize);
extern HRESULT SendDataChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags);
extern HRESULT SendNameChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags);
extern HRESULT SendIAmNameServer(LPDPLAYI_DPLAY this);
extern HRESULT SendMeNameServer(LPDPLAYI_DPLAY this);
extern HRESULT SendSessionDescChanged(LPDPLAYI_DPLAY this, DWORD dwFlags);
extern HRESULT SendChatMessage(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags, LPDPCHAT lpMsg, BOOL fPlayer);
extern HRESULT SendAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,
	LPADDFORWARDNODE pnode);
extern HRESULT ConvertSendExDataToSendData(LPDPLAYI_DPLAY this, LPDPSP_SENDEXDATA psed, LPDPSP_SENDDATA psd) ;
	
// dllmain.c
extern HRESULT FreeSPList();

// iplay1.c
extern HRESULT DPAPI DP_1_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPSTR lpszShortName,LPSTR lpszLongName,LPHANDLE phEvent);
extern HRESULT DPAPI DP_1_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPSTR lpszShortName,LPSTR lpszLongName); 
extern HRESULT DPAPI DP_1_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags); 
extern HRESULT DPAPI DP_1_EnumGroups(LPDIRECTPLAY lpDP,DWORD dwSessionID,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags); 
extern HRESULT DPAPI DP_1_EnumPlayers(LPDIRECTPLAY lpDP, DWORD dwSessionID, 
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags);
extern HRESULT DPAPI DP_1_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK lpEnumCallback,LPVOID pContext,
	DWORD dwFlags); 
extern HRESULT DPAPI DP_1_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps); 
extern HRESULT DPAPI DP_1_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps); 
extern HRESULT DPAPI DP_1_GetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPDWORD pdwShortNameLength,LPSTR lpszLongName,LPDWORD pdwLongNameLength);
extern HRESULT DPAPI DP_1_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpSDesc ); 
extern HRESULT DPAPI DP_1_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize);
extern HRESULT DPAPI DP_1_SaveSession(LPDIRECTPLAY lpDP, LPSTR lpszNotInSpec); 
extern HRESULT DPAPI DP_1_SetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,
	LPSTR lpszShortName,LPSTR lpszLongName);       	
	

// iplaya.c						 
extern HRESULT DPAPI DP_A_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_A_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumGroupPlayers(LPDIRECTPLAY lpDP, DPID id,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumGroups(LPDIRECTPLAY lpDP, LPGUID pGuid,
	 LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
    LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) ;
extern HRESULT DPAPI DP_A_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,
	DWORD dwFlags,LPVOID pvBuffer,LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 pDesc,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc,
    DWORD dwFlags, LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials) ;
extern HRESULT DPAPI DP_A_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg);
extern HRESULT GetWideStringFromAnsi(LPWSTR * ppszWStr,LPSTR lpszStr);
extern HRESULT GetWideDesc(LPDPSESSIONDESC2 pDesc,LPCDPSESSIONDESC2 pDescA);
extern HRESULT GetAnsiDesc(LPDPSESSIONDESC2 pDescA,LPDPSESSIONDESC2 pDesc);
extern void FreeDesc(LPDPSESSIONDESC2 pDesc,BOOL fAnsi);
extern HRESULT FreeCredentials(LPDPCREDENTIALS lpCredentials,BOOL fAnsi);
extern HRESULT GetWideCredentials(LPDPCREDENTIALS lpCredentialsW, 
    LPCDPCREDENTIALS lpCredentialsA);
extern HRESULT FreeSecurityDesc(LPDPSECURITYDESC lpSecDesc, BOOL fAnsi);
extern HRESULT GetWideSecurityDesc(LPDPSECURITYDESC lpSecDescW, 
    LPCDPSECURITYDESC lpSecDescA);
extern HRESULT DPAPI DP_A_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) ;
extern HRESULT InternalGetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi);
extern HRESULT DPAPI DP_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize);

// pending.c
extern HRESULT ExecutePendingCommands(LPDPLAYI_DPLAY this);
extern HRESULT PushPendingCommand(LPDPLAYI_DPLAY this,LPVOID pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader,DWORD dwSendFlags);


// handler.c
extern HRESULT DPAPI InternalHandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader, DWORD dwMessageFlags);
extern HRESULT DPAPI DP_SP_HandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern HRESULT DPAPI DP_SP_HandleNonProtocolMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern VOID DPAPI DP_SP_SendComplete(IDirectPlaySP * pISP, LPVOID lpDPContext, HRESULT CompletionStatus);
extern HRESULT DoReply(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	LPVOID pvMessageHeader, DWORD dwReplyToVersion);
extern HRESULT HandleSessionLost(LPDPLAYI_DPLAY this);
extern HRESULT HandlePlayerMessage(LPDPLAYI_PLAYER, LPBYTE, DWORD, BOOL, DWORD);
extern HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY, LPBYTE, LPVOID);
extern HRESULT SP_HandleDataChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer);
extern HRESULT SP_HandleSessionDescChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer);
extern HRESULT  DistributeSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize);
extern HRESULT GetMessageCommand(LPDPLAYI_DPLAY this, LPVOID pReceiveBuffer, DWORD dwMessageSize, 
    LPDWORD pdwCommand, LPDWORD pdwVersion);
extern HRESULT DistributeGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroupTo,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage,DWORD dwMessageFlags);
extern DWORD GetPlayerFlags(LPDPLAYI_PLAYER pPlayer);
extern HRESULT SP_HandlePlayerMgmt(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader) ;
extern HRESULT FreeAddForwardNode(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind);
extern HRESULT NS_HandleEnumPlayers(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DPID dpidFrom,DWORD dwVersion);
extern LPDPLAYI_PLAYER GetRandomLocalPlayer(LPDPLAYI_DPLAY this);
extern VOID QueueSendCompletion(LPDPLAYI_DPLAY this, PSENDPARMS psp);
extern VOID UpdateChatterCount(LPDPLAYI_DPLAY this, DPID dwIDFrom);
 
// sphelp.c
extern HRESULT DPAPI DP_SP_AddMRUEntry(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPCVOID lpvData, DWORD dwDataSize, DWORD dwMaxEntries);
extern HRESULT DPAPI DP_SP_CreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPAPI DP_SP_CreateCompoundAddress(IDirectPlaySP * pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPAPI DP_SP_EnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize, 
	LPVOID lpContext);
extern HRESULT DPAPI DP_SP_EnumMRUEntries(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPENUMMRUCALLBACK fnCallback,
					LPVOID lpvContext);
extern HRESULT DPAPI DP_SP_GetPlayerFlags(IDirectPlaySP * pISP,DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_SP_GetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID * ppvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SP_SetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID pvData,
	DWORD dwDataSize,DWORD dwFlags	);
extern HRESULT DPAPI DP_SP_GetSPData(IDirectPlaySP * pISP,LPVOID * ppvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SP_SetSPData(IDirectPlaySP * pISP,LPVOID pvData,
	DWORD dwDataSize,DWORD dwFlags	);

#ifdef BIGMESSAGEDEFENSE
extern HRESULT DPAPI DP_SP_HandleSPWarning(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
#endif

extern HRESULT InternalEnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext);
extern HRESULT InternalCreateAddress(LPDIRECTPLAYSP pISP,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT InternalCreateCompoundAddress(
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);

// do.c
extern HRESULT DoPlayerData(LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,DWORD dwSourceSize,
	DWORD dwFlags);
extern HRESULT DoPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName);

// paketize.c
extern HRESULT PacketizeAndSend(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader,BOOL bReply);
HRESULT PacketizeAndSendReliable(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader, BOOL bReply);
extern HRESULT HandlePacket(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern void FreePacketNode(LPPACKETNODE pNode);
BOOL NeedsReliablePacketize(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, 
	DWORD dwFlags);
HRESULT InitPacketize(LPDPLAYI_DPLAY this);
VOID FiniPacketize(LPDPLAYI_DPLAY this);
VOID FreePacketizeRetryList(LPDPLAYI_DPLAY this);
DWORD WINAPI PacketizeRetryThread(LPDPLAYI_DPLAY this);
extern CRITICAL_SECTION g_PacketizeTimeoutListLock;

// dpthread.c
extern DWORD WINAPI DPlayThreadProc(LPDPLAYI_DPLAY this);
extern HRESULT HandlePing(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	LPVOID pvMessageHeader);
extern HRESULT  KillPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pSysPlayer, BOOL fPropagate);
	

// api.c
extern void LowerCase(char * lpsz);
extern HRESULT ConnectFindSession(LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect);
extern LPSESSIONLIST FindSessionInSessionList(LPDPLAYI_DPLAY this,
	GUID const *pGuid);
extern HRESULT LoadSP(LPDPLAYI_DPLAY this,LPGUID lpGUID,LPDPADDRESS lpAddress,
	DWORD dwAddressSize);	
extern void FreeSPNode(LPSPNODE pspNode);
VOID FreeMemoryPools(LPDPLAYI_DPLAY this);
VOID FiniReply(LPDPLAYI_DPLAY this);
HRESULT InitReply(LPDPLAYI_DPLAY this);
VOID SetupForReply(LPDPLAYI_DPLAY this, DWORD dwReplyCommand);
VOID UnSetupForReply(LPDPLAYI_DPLAY this);
HRESULT WaitForReply(LPDPLAYI_DPLAY this, PCHAR *ppReply, LPVOID *ppvSPHeader, DWORD dwTimeout);
VOID FreeReplyBuffer(PCHAR pReplyBuffer);
HRESULT HandleReply(LPDPLAYI_DPLAY this, PCHAR pReplyBuffer, DWORD cbReplyBuffer, DWORD dwReplyCommand, LPVOID pvSPHeader);

// perf.c
extern DWORD WINAPI PerfThreadProc(LPDPLAYI_DPLAY this);
extern HRESULT InitMappingStuff(LPDPLAYI_DPLAY this);

//connect.c
extern HRESULT DPAPI DP_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumConnectionsPreDP4(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_InitializeConnection(LPDIRECTPLAY lpDP,LPVOID pvAddress,
	DWORD dwFlags);

// superpac.c
extern HRESULT SuperPackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) ;
extern HRESULT UnSuperpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,UINT nShortcuts,LPVOID pvSPHeader);

#ifdef DPLAY_VOICE_SUPPORT
// voice.c
extern HRESULT DPAPI DP_CloseVoice(LPDIRECTPLAY lpDP,DWORD dwFlags);
extern HRESULT DPAPI DP_OpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags);
extern HRESULT InternalCloseVoice(LPDPLAYI_DPLAY this,BOOL fPropagate);
extern HRESULT InternalOpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
	BOOL fPropagate);
#endif // DPLAY_VOICE_SUPPORT

//sgl.c
void InsertSendBufferAtFront(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext);
void InsertSendBufferAtEnd(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext);
void FreeMessageBuffers(LPSENDPARMS psp);

//msgmem.c
void * MsgAlloc( int size );
void   MsgFree (void *context, void *pmem);

//sendparm.c
extern BOOL SendInitAlloc(void *pvsp);
extern VOID SendInit(void *pvsp);
extern VOID SendFini(void *pvsp);
extern VOID FreeSend(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL fFreeParms);

extern HRESULT InitContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nInitSize);
extern UINT AddContext(LPDPLAYI_DPLAY this, PSENDPARMS psp, PVOID pvContext);
extern UINT pspAddRef(PSENDPARMS psp);
extern UINT pspAddRefNZ(PSENDPARMS psp);
extern UINT pspDecRef(LPDPLAYI_DPLAY this, PSENDPARMS psp);

//apphack.c
extern HRESULT GetAppHacks(LPDPLAYI_DPLAY this);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplay.h
 *  Content:    DirectPlay include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date   By  Reason
 *	============
 *	04-apr-95  ericeng  DirectPlay header file COM version
 *	07-jul-95  johnhall Making Program Management Dreams a Reality.
 *	19-jul-95  ericeng  Header file rationalization
 *	2/96		AndyCo	New dplay (dp2)
 *	4/8/96		AndyCo	added DPSESSION_PLAYERS_ENABLED
 *	4/18/96		AndyCo	dpcaps2
 *	5/3/96		andyco	idirectplay2
 *	5/6/96		andyco	unions for wchar and char
 *	5/23/96		andyco	added DPSESSION_MIGRATENAMESERVER, moved data to last
 *						element in addxxx messages to make packing easier
 *	5/31/96		andyco	added DPNAME,DPLAY_SETDATA_REMOTE,
 *						DPSET_GUARANTEED
 *
 *	6/9/95		andyco	DPLAY_SETDATA_REMOTE -> DPLAY_SETDATA_LOCAL for consistancy
 *						PLAYERNAME -> DPNAME, DPOPEN_xxx -> DPSESSION_CREATE
 *						/ DPSESSION_JOIN
 *	6/20/96		andyco	cleaned up flags, etc.
 *	6/22/96		andyco	added dwFlags to Open,GetCaps
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *  6/27/96     ajayj   defined flags DPSEND_OPENSTREAM and DPSEND_CLOSESTREAM
 *  6/29/96     ajayj   defined flag DPSESSION_PRIVATE and modified comment for
 *                      DPSESSION_PLAYERSDISABLED
 *	6/30/96		andyco	added DP(G)SET_REMOTE,_LOCAL
 *  7/5/96      ajayj   change DPSESSION_PRIVATE to DPSESSION_JOINDISABLED
 *                      added DPSESSION_NEWPLAYERSDISABLED and defined
 *                      old flag DPSESSION_PLAYERSDISABLED to be the same thing
 *  7/8/96      ajayj   Added loads of comments.
 *                      Alphabetized IDirectPlay2 vtable
 *                      Removed SaveSession and EnableNewPlayers from vtable
 *                      Removed structure DPSAVEDATA
 *                      Change terminology "Name Server" is now a session "Host"
 *                      DPCAPS_GROUP                -> DPCAPS_GROUPOPTIMIZED
 *                      DPCAPS_NAMESERVER           -> DPCAPS_ISHOST
 *                      DPSESSION_MIGRATENAMESERVER -> DPSESSION_MIGRATEHOST
 *                      DPSYS_NAMESERVER            -> DPSYS_HOST
 *                      LPDPENUMSESSIONCALLBACK2 - lpContext at end of param list
 *                      LPDPENUMPLAYERSCALLBACK2 - dwPlayerType after dpId
 *                      Changed numbering of DPSYS_HOST, DPSYS_DATACHANGED, and
 *                          DPSYS_NAMECHANGED system messages
 *                      DPMSG_NAMECHANGED, DPMSG_ADDPLAYER2 - changed name of
 *                          data member 'PlayerName' to 'dpnName'.
 *	7/09/96		kipo	changed DPSYS_ADDPLAYER to DPSYS_CREATEPLAYERORGROUP and
 *						DPSYS_DELETEPLAYER/GROUP to DPSYS_DESTROYPLAYERORGROUP;
 *						changed player data/name messages to
 *						DPSYS_SETPLAYERORGROUPDATA and DPMSG_SETPLAYERORGROUPNAME;
 *						made the old system messages obsolete.
 *  7/11/96     ajayj   Deleted some flags which weren't use at all in Dplay1 or DPlay3
 *  7/14/96     ajayj   Added constants DPID_SYSMSG, DPID_ALLPLAYERS
 *                      Added structures DPMSG_HOST, DPMSG_SESSIONLOST, DPMSG_CONNECT all
 *                          are typedefs of DPMSG_GENERIC
 *                      Made system message comments more consistent.
 *  7/20/96     kipo	The GetPlayerName interface declartion in IDirectPlay2 had an
 *						extra DWORD parameter at the end. #2523
 *  7/23/96     ajayj	Moved DPSYS_CONNECT to the obsolete DPlay1 constants section
 *  7/27/96     kipo    Added GUID to EnumGroupPlayers(); changed CreatePlayer()
 *                      to take an event handle instead of an event pointer.
 *  7/31/96     kipo    CreatePlayer() still had a LPHANDLE instead of a HANDLE parameter.
 *  8/1/96		andyco	added DPSESSION_KEEPALIVE, DPCAPS_OPTIMIZEKEEPALIVE flags
 *  8/1/96      sohailm Added IDirectPlay2 and IDirectPlay interface macros
 *  8/8/96      ajayj   typedef LPDIRECTPLAY to be struct IUnknown when the
 *                      symbol IDIRECTPLAY2_OR_GREATER is defined so app can
 *                      still QI on IDirectPlay to obtain IDirectPlay2.
 *  8/8/96      ajayj   added definitions for DPCAPS_GUARANTEEDOPTIMIZED and
 *                      DPCAPS_GUARANTEEDSUPPORTED
 *  8/10/96		andyco	added DPSESSION_DATACHANGEENABLED and player data to 
 *						destroy player message
 *  8/10/96     sohailm Bug# 2224: declared pointers in callbacks as const.
 *	8/13/96		myronth	Added DPERR_NOTLOBBIED
 *  8/16/96             andyco  backed out the constant changes.
 *  8/20/96     ajayj   fixed TABS. Remove DPENUMPLAYERS_ALL. MSINTERNAL
 *                      around DPSESSION_NOPLAYERMGMT.
 *	8/22/96		andyco	added DPENUMPLAYERS_ALL again.
 *  8/25/96		kipo	DPERR_NOINTERFACE was defined twice for some reason
 *  10/11/96    sohailm added struct DPMSG_SETSESSIONDESC and constant DPSYS_SETSESSIONDESC 
 *	11/11/96	andyco	added idirectplay3, DPID_SERVERPLAYER, DPPLAYER_SERVERPLAYER
 *	 2/10/97	kipo	commented out DPSEND_HIGHPRIORITY flag since its obsolete
 *	 2/11/97	kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 *	 2/14/97	aarono	added DPERR_PENDING
 *	2/29/97		andyco	added clsid_directplay
 *	2/30/97		andyco	enumconnections, initializeconnection
 *	3/12/97		myronth	DPCONNECTION_* flags
 *  3/12/97     sohailm added SecureOpen() to IDirectPlay3 and 3A interfaces, corresponding macros,
 *                      DPCREDENTIALS and DPSECURITYDESC structures, DPSESSION_SECURESERVER flag,
 *                      and Security related errors.
 *	3/17/97		kipo	added support for DPADDRESSTYPEDESC structure
 *	3/24/97		kipo	IDirectPlay3 now inherits from IDirectPlay2
 *  3/24/97     sohailm added flags DPSESSION_PRIVATE, DPENUMSESSIONS_PASSWORDREQUIRED and 
 *                      errors DPERR_INVALIDPASSWORD,DPERR_JOINDISABLED,DPERR_PLAYERSMAXEDOUT
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	4/5/97		andyco	DPSESSION_MULTICASTSERVER
 *  4/09/97     sohailm Added error DPERR_CANTLOADSECURITYPACKAGE.
 *  4/23/97     sohialm Added flags DPCAPS_SIGNINGSUPPORTED, DPCAPS_ENCRYPTIONSUPPORTED, 
 *                      DPSEND_SIGNED and DPSEND_ENCRYTPED.
 *                      Added error DPERR_ENCRYPTIONNOTSUPPORTED.
 *  4/24/97     sohailm Added DPSYS_SECUREMESSAGE and DPMSG_SECUREMESSAGE.
 *	4/30/97		andyco	added groupingroup support
 *  5/7/97		ajayj	added back DPSEND_HIGHPRIORITY
 *	5/8/97		andyco	exposed server_player, client_server and removed update list
 *	5/8/97		myronth	moved DPLCONNECTION from dplobby.h, added StartSession,
 *						Get/SetGroupConnectionSettings, StartSession message
 *	5/10/97		kipo	added GUID to EnumConnections callback
 *  5/12/97     sohailm renamed lpszSecurityPackageName field of DPSECURITYDESC to lpszSSPIProvider
 *                      added fields lpszCAPIProvider, dwCAPIProviderType, and dwEncryptionAlgorithm 
 *                       to DPSECURITYDESC.
 *                      added DPERR_CANTLOADCAPI and DPERR_NOTLOGGEDIN (not exposed).
 *	5/17/97		myronth	Added SendChatMessage, DPCHAT, and it's flags, Moved
 *						DPLCONNECTION flags below other definitions they reference
 *	5/18/97		kipo	added new DPENUM_PLAYERS and DPENUM_GROUP flags
 *  5/18/97     sohailm removed ms internal around DPERR_NOTLOGGEDIN.
 *  5/21/97     sohailm removed DPSECURE_SIGNED and DPSECURE_ENCRYPTED flags. We are going
 *                      to use DPSEND_SIGNED and DPSEND_ENCRYPTED instead.
 *	5/21/97		myronth	Changed DPMSG_CHAT structure to correct format (#8642)
 *  5/22/97		ajayj	Added typedefs for DPENUMGROUPS_ flags
 *	5/22/97		myronth	Added dwFlags member to DPMSG_CHAT (#8868)
 *  5/22/97		ajayj	Removed new DPLCONNECTION flags for lobby messaging
 *	5/23/97		kipo	Added support for return status codes
 *	5/25/97		kipo	Added DPERR_CONNECTING error
 *	5/27/97		kipo	Add player flags to CreateGroup/Player and DestroyGroup/Player
 *  5/30/97		ajayj	Added DPENUMGROUPS_ALL
 *	5/30/97		myronth	Added GetGroupParent
 *  5/30/97     sohailm Added domain name member to DPCREDENTIALS.
 *                      Added GetPlayerAccount() to IDirectPlay3, related macros, and DPACCOUNTDESC.
 *	5/30/97		kipo	Added GetPlayerFlags() and GetGroupFlags()
 *  5/30/97		ajayj	Added service provider GUIDs.
 *  6/09/97     sohailm Added DPERR_LOGONDENIED and removed DPERR_INVALIDCREDENTIALS.
 *  6/16/97     sohailm Removed DPCAPS_ENCRYPTIONOPTIZED and DPCAPS_SIGNINGOPTIMIZED.
 *	7/30/97		myronth	Added DPSEND_LOBBYSYSTEMMESSAGE for standard lobby messaging
 *  8/4/97		andyco	added DPSEND_ASYNC so we can make addforward async
 *	10/21/97	myronth	Added IDirectPlay4 interface definitions, also added
 *						hidden group flags and owner player flags
 *	10/21/97	andyco	added openvoice
 *	10/29/97	myronth	Fixed owner player flag, added SetGroupOwner message
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added DPCONNECT_ASYNC & STOPASYNC flags
 *	12/3/97		myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohaiml	added DPSESSON_OPTIMIZELATENCY and DPSESSION_OPTIMIZEBANDWIDTH.
 *  2/2/98      aarono  added DPERR_INVALIDPRIORITY
 *  2/5/98      aarono  changed SGBUFFER item order to lineup with WSABUF
 *  2/18/98     aarono  added new CAPS bits for info on new APIs behaviour
 *	2/18/98	   a-peterz	removed DPSESSION_OPTIMIZEBANDWIDTH.
 *	3/19/98	   a-peterz	DP[SYS/MSG]_SENDCOMPLETE were in the obsolete section.
 *	4/14/98	   a-peterz	#18340 DPSEND_NOCOPY made MSINTERNAL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAY_INCLUDED__
#define __DPLAY_INCLUDED__

#include <ole2.h>       // for DECLARE_INTERFACE and HRESULT

/* avoid warnings in MSVC at Level4 */
#pragma warning(disable:4201)


/*
 * Some types
 */

#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

typedef LPVOID (*LPRGLPVOID)[];
typedef LPRGLPVOID PRGPVOID, LPRGPVOID, PRGLPVOID, PAPVOID, LPAPVOID, PALPVOID, LPALPVOID;

#define VOL volatile
typedef VOID *VOL LPVOIDV;


#define _FACDP  0x877
#define MAKE_DPHRESULT( code )    MAKE_HRESULT( 1, _FACDP, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectPlay objects
 */
DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {D1EB6D20-8923-11d0-9D97-00A0C90A43CB}
DEFINE_GUID(CLSID_DirectPlay,0xd1eb6d20, 0x8923, 0x11d0, 0x9d, 0x97, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * GUIDS used by Service Providers shipped with DirectPlay
 * Use these to identify Service Provider returned by EnumConnections
 */

// GUID for IPX service provider
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(DPSPGUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// GUID for TCP/IP service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(DPSPGUID_TCPIP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// GUID for Serial service provider
// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_SERIAL,						
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// GUID for Modem service provider
// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_MODEM,
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * DirectPlay Structures
 *
 * Various structures used to invoke DirectPlay.
 *
 ****************************************************************************/

#ifndef IDIRECTPLAY2_OR_GREATER
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#else
typedef struct IUnknown           FAR *LPDIRECTPLAY;
#endif

typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2;
typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2A;
typedef struct IDirectPlay2       IDirectPlay2A;

typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3;
typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3A;
typedef struct IDirectPlay3       IDirectPlay3A;

typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4;
typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4A;
typedef struct IDirectPlay4       IDirectPlay4A;

/*
 * DPID
 * DirectPlay player and group ID
 */
typedef DWORD DPID, FAR *LPDPID;

/*
 * DPID that system messages come from
 */
#define DPID_SYSMSG         0

/*
 * DPID representing all players in the session
 */
#define DPID_ALLPLAYERS     0

/*
 * DPID representing the server player
 */
#define DPID_SERVERPLAYER	1

//@@BEGIN_MSINTERNAL
/*
 * DPID representing the lobby's system player (only used internally
 * and only used in lobby sessions)
 */
#define DPID_LOBBYSYSTEMPLAYER    2

/*
 * DPID representing the lobby's system group (only used internally
 * and only used in lobby sessions)
 */
#define DPID_LOBBYSYSTEMGROUP     3

/*
 * DPID representing the lobby's system player for all remote
 * players and groups (only used internally and only used in lobby sessions)
 */
#define DPID_LOBBYREMOTESYSTEMPLAYER     4
//@@END_MSINTERNAL

/*
 * DPID representing the maxiumum ID in the range of DPID's reserved for
 * use by DirectPlay.
 */
#define DPID_RESERVEDRANGE     100

/*
 * The player ID is unknown (used with e.g. DPSESSION_NOMESSAGEID)
 */
#define DPID_UNKNOWN		0xFFFFFFFF

/*
 * DPCAPS
 * Used to obtain the capabilities of a DirectPlay object
 */
typedef struct
{
    DWORD dwSize;               // Size of structure, in bytes
    DWORD dwFlags;              // DPCAPS_xxx flags
    DWORD dwMaxBufferSize;      // Maximum message size, in bytes,  for this service provider
    DWORD dwMaxQueueSize;       // Obsolete. 
    DWORD dwMaxPlayers;         // Maximum players/groups (local + remote)
    DWORD dwHundredBaud;        // Bandwidth in 100 bits per second units; 
                                // i.e. 24 is 2400, 96 is 9600, etc.
    DWORD dwLatency;            // Estimated latency; 0 = unknown
    DWORD dwMaxLocalPlayers;    // Maximum # of locally created players allowed
    DWORD dwHeaderLength;       // Maximum header length, in bytes, on messages
                                // added by the service provider
    DWORD dwTimeout;            // Service provider's suggested timeout value
                                // This is how long DirectPlay will wait for 
                                // responses to system messages
} DPCAPS, FAR *LPDPCAPS;

/*
 * This DirectPlay object is the session host.  If the host exits the
 * session, another application will become the host and receive a
 * DPSYS_HOST system message.
 */
#define DPCAPS_ISHOST               0x00000002

/*
 * The service provider bound to this DirectPlay object can optimize
 * group messaging.
 */
#define DPCAPS_GROUPOPTIMIZED       0x00000008

/*
 * The service provider bound to this DirectPlay object can optimize
 * keep alives (see DPSESSION_KEEPALIVE)
 */
#define DPCAPS_KEEPALIVEOPTIMIZED   0x00000010

/*
 * The service provider bound to this DirectPlay object can optimize
 * guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDOPTIMIZED  0x00000020

/*
 * This DirectPlay object supports guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDSUPPORTED  0x00000040

/*
 * This DirectPlay object supports digital signing of messages.
 */
#define DPCAPS_SIGNINGSUPPORTED     0x00000080

/*
 * This DirectPlay object supports encryption of messages.
 */
#define DPCAPS_ENCRYPTIONSUPPORTED  0x00000100

/*
 * This DirectPlay player was created on this machine
 */
#define DPPLAYERCAPS_LOCAL			0x00000800

/*
 * Current Open settings supports all forms of Cancel
 */
#define DPCAPS_ASYNCCANCELSUPPORTED    0x00001000

/*
 * Current Open settings supports CancelAll, but not Cancel
 */
#define DPCAPS_ASYNCCANCELALLSUPPORTED 0x00002000

/*
 *  Current Open settings supports Send Timeouts for sends
 */
#define DPCAPS_SENDTIMEOUTSUPPORTED   0x00004000

/*
 *  Current Open settings supports send priority
 */
#define DPCAPS_SENDPRIORITYSUPPORTED   0x00008000

/*
 *  Current Open settings supports DPSEND_ASYNC flag
 */
#define DPCAPS_ASYNCSUPPORTED 		   0x00010000

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 * Defined in DPlay 1 header file but appear to have no effect
 * in the code.
 *
 * #define DPCAPS_NAMESERVICE          0x00000001
 * #define DPCAPS_NAMESERVER           DPCAPS_ISHOST
 * #define DPCAPS_GUARANTEED           0x00000004
 */
//@@END_MSINTERNAL

/*
 * DPSESSIONDESC2
 * Used to describe the properties of a DirectPlay
 * session instance
 */
typedef struct
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // DPSESSION_xxx flags
    GUID    guidInstance;       // ID for the session instance
    GUID    guidApplication;    // GUID of the DirectPlay application.
                                // GUID_NULL for all applications.
    DWORD   dwMaxPlayers;       // Maximum # players allowed in session
    DWORD   dwCurrentPlayers;   // Current # players in session (read only)
    union
    {                           // Name of the session
        LPWSTR  lpszSessionName;    // Unicode
        LPSTR   lpszSessionNameA;   // ANSI
    };
    union
    {                           // Password of the session (optional)
        LPWSTR  lpszPassword;       // Unicode
        LPSTR   lpszPasswordA;      // ANSI
    };
    DWORD_PTR   dwReserved1;        // Reserved for future MS use.
    DWORD_PTR   dwReserved2;
    DWORD_PTR   dwUser1;            // For use by the application
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC2, FAR *LPDPSESSIONDESC2;

typedef DPSESSIONDESC2 * VOL LPDPSESSIONDESC2_V;

/*
 * LPCDPSESSIONDESC2
 * A constant pointer to DPSESSIONDESC2
 */
typedef const DPSESSIONDESC2 FAR *LPCDPSESSIONDESC2;
 
/*
 * Applications cannot create new players in this session.
 */
#define DPSESSION_NEWPLAYERSDISABLED    0x00000001 

/*
 * If the DirectPlay object that created the session, the host,
 * quits, then the host will attempt to migrate to another
 * DirectPlay object so that new players can continue to be created
 * and new applications can join the session.
 */
#define DPSESSION_MIGRATEHOST           0x00000004

/*
 * This flag tells DirectPlay not to set the idPlayerTo and idPlayerFrom 
 * fields in player messages.  This cuts two DWORD's off the message 
 * overhead.
 */
#define DPSESSION_NOMESSAGEID           0x00000008

//@@BEGIN_MSINTERNAL
/*
 * This flag tells DirectPlay not to generate player management messages 
 * (DPSYS_CREATEPLAYERORGROUP, DPSYS_DESTROYPLAYERORGROUP,
 * DPSYS_ADDPLAYERTOGROUP, DPSYS_DELETEPLAYERFROMGROUP,
 * DPSYS_SETPLAYERORGROUPDATA, DPSYS_SETPLAYERORGROUPNAME). 
 */
#define DPSESSION_NOPLAYERMGMT          0x00000010
//@@END_MSINTERNAL

/*
 * This flag tells DirectPlay to not allow any new applications to
 * join the session.  Applications already in the session can still
 * create new players.
 */
#define DPSESSION_JOINDISABLED          0x00000020

/*
 * This flag tells DirectPlay to detect when remote players 
 * exit abnormally (e.g. their computer or modem gets unplugged)
 */
#define DPSESSION_KEEPALIVE             0x00000040

/*
 * This flag tells DirectPlay not to send a message to all players
 * when a players remote data changes
 */
#define DPSESSION_NODATAMESSAGES        0x00000080

/*
 * This flag indicates that the session belongs to a secure server
 * and needs user authentication
 */
#define DPSESSION_SECURESERVER          0x00000100

/*
 * This flag indicates that the session is private and requirs a password
 * for EnumSessions as well as Open.
 */
#define DPSESSION_PRIVATE               0x00000200

/*
 * This flag indicates that the session requires a password for joining.
 */
#define DPSESSION_PASSWORDREQUIRED      0x00000400

/*
 * This flag tells DirectPlay to route all messages through the server
 */
#define DPSESSION_MULTICASTSERVER		0x00000800

/*
 * This flag tells DirectPlay to only download information about the
 * DPPLAYER_SERVERPLAYER.  
 */
#define DPSESSION_CLIENTSERVER			0x00001000

/*
 * This flag tells DirectPlay to use the protocol built into dplay
 * for reliability and statistics all the time.  When this bit is
 * set, only other sessions with this bit set can join or be joined.
 */
#define DPSESSION_DIRECTPLAYPROTOCOL	0x00002000

/*
 * This flag tells DirectPlay that preserving order of received
 * packets is not important, when using reliable delivery.  This
 * will allow messages to be indicated out of order if preceding
 * messages have not yet arrived.  Otherwise DPLAY will wait for
 * earlier messages before delivering later reliable messages.
 */
#define DPSESSION_NOPRESERVEORDER		0x00004000


/*
 * This flag tells DirectPlay to optimize communication for latency
 */
#define DPSESSION_OPTIMIZELATENCY		0x00008000

/*
 * DPNAME
 * Used to hold the name of a DirectPlay entity
 * like a player or a group
 */
typedef struct 
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // Not used. Must be zero.
    union
    {                           // The short or friendly name
        LPWSTR  lpszShortName;  // Unicode
        LPSTR   lpszShortNameA; // ANSI
    };
    union
    {                           // The long or formal name
        LPWSTR  lpszLongName;   // Unicode
        LPSTR   lpszLongNameA;  // ANSI
    };

} DPNAME, FAR *LPDPNAME;

/*
 * LPCDPNAME
 * A constant pointer to DPNAME
 */
typedef const DPNAME FAR *LPCDPNAME;

/*
 * DPCREDENTIALS
 * Used to hold the user name and password of a DirectPlay user
 */
typedef struct 
{
    DWORD dwSize;               // Size of structure
    DWORD dwFlags;              // Not used. Must be zero.
    union
    {                           // User name of the account
        LPWSTR  lpszUsername;   // Unicode
        LPSTR   lpszUsernameA;  // ANSI
    };    
    union
    {                           // Password of the account
        LPWSTR  lpszPassword;   // Unicode
        LPSTR   lpszPasswordA;  // ANSI
    };    
    union
    {                           // Domain name of the account
        LPWSTR  lpszDomain;     // Unicode
        LPSTR   lpszDomainA;    // ANSI
    };    
} DPCREDENTIALS, FAR *LPDPCREDENTIALS;

typedef const DPCREDENTIALS FAR *LPCDPCREDENTIALS;

/*
 * DPSECURITYDESC
 * Used to describe the security properties of a DirectPlay
 * session instance
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // SSPI provider name
        LPWSTR  lpszSSPIProvider;   // Unicode
        LPSTR   lpszSSPIProviderA;  // ANSI
    };
    union
    {                               // CAPI provider name
        LPWSTR lpszCAPIProvider;    // Unicode
        LPSTR  lpszCAPIProviderA;   // ANSI
    };
    DWORD dwCAPIProviderType;       // Crypto Service Provider type
    DWORD dwEncryptionAlgorithm;    // Encryption Algorithm type
} DPSECURITYDESC, FAR *LPDPSECURITYDESC;

typedef const DPSECURITYDESC FAR *LPCDPSECURITYDESC;

/*
 * DPACCOUNTDESC
 * Used to describe a user membership account
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // Account identifier
        LPWSTR  lpszAccountID;      // Unicode
        LPSTR   lpszAccountIDA;     // ANSI
    };
} DPACCOUNTDESC, FAR *LPDPACCOUNTDESC;

typedef const DPACCOUNTDESC FAR *LPCDPACCOUNTDESC;

/*
 * LPCGUID
 * A constant pointer to a guid
 */
typedef const GUID FAR *LPCGUID;

/*
 * DPLCONNECTION
 * Used to hold all in the informaion needed to connect
 * an application to a session or create a session
 */
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    DWORD               dwFlags;            // Flags specific to this structure
    LPDPSESSIONDESC2    lpSessionDesc;      // Pointer to session desc to use on connect
    LPDPNAME            lpPlayerName;       // Pointer to Player name structure
    GUID                guidSP;             // GUID of the DPlay SP to use
    LPVOID              lpAddress;          // Address for service provider
    DWORD               dwAddressSize;      // Size of address data
} DPLCONNECTION, FAR *LPDPLCONNECTION;

/*
 * LPCDPLCONNECTION
 * A constant pointer to DPLCONNECTION
 */
typedef const DPLCONNECTION FAR *LPCDPLCONNECTION;

/*
 * DPCHAT
 * Used to hold the a DirectPlay chat message
 */
typedef struct
{
    DWORD               dwSize;
    DWORD               dwFlags;
    union
    {                          // Message string
        LPWSTR  lpszMessage;   // Unicode
        LPSTR   lpszMessageA;  // ANSI
    };    
} DPCHAT, FAR * LPDPCHAT;

/*
 * SGBUFFER
 * Scatter Gather Buffer used for SendEx
 */
typedef struct 
{
	UINT         len;       // length of buffer data
	PUCHAR	     pData;		// pointer to buffer data
} SGBUFFER, *PSGBUFFER, FAR *LPSGBUFFER;


/****************************************************************************
 *
 * Prototypes for DirectPlay callback functions
 *
 ****************************************************************************/

/*
 * Callback for IDirectPlay2::EnumSessions
 */
typedef BOOL (FAR PASCAL * LPDPENUMSESSIONSCALLBACK2)(
    LPCDPSESSIONDESC2   lpThisSD,
    LPDWORD             lpdwTimeOut,
    DWORD               dwFlags,
    LPVOID              lpContext );

/*
 * This flag is set on the EnumSessions callback dwFlags parameter when
 * the time out has occurred. There will be no session data for this 
 * callback. If *lpdwTimeOut is set to a non-zero value and the 
 * EnumSessionsCallback function returns TRUE then EnumSessions will 
 * continue waiting until the next timeout occurs. Timeouts are in 
 * milliseconds.
 */
#define DPESC_TIMEDOUT          0x00000001


/*
 * Callback for IDirectPlay2::EnumPlayers
 *              IDirectPlay2::EnumGroups
 *              IDirectPlay2::EnumGroupPlayers
 */
typedef BOOL (FAR PASCAL *LPDPENUMPLAYERSCALLBACK2)(
    DPID            dpId,
    DWORD           dwPlayerType,
    LPCDPNAME       lpName,
    DWORD           dwFlags,
    LPVOID          lpContext );


/*
 * Unicode callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for Unicode strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACK)(
    LPGUID      lpguidSP,
    LPWSTR      lpSPName,
    DWORD       dwMajorVersion,
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * ANSI callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for ANSI strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACKA)(
    LPGUID      lpguidSP,
    LPSTR       lpSPName,
    DWORD       dwMajorVersion,     
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * Callback for IDirectPlay3(A)::EnumConnections
 */
typedef BOOL (FAR PASCAL * LPDPENUMCONNECTIONSCALLBACK)(
    LPCGUID     lpguidSP,
	LPVOID		lpConnection,
	DWORD		dwConnectionSize,
    LPCDPNAME   lpName,
	DWORD 		dwFlags,
	LPVOID 		lpContext);


/*
 * API's
 */

#ifdef UNICODE
#define DirectPlayEnumerate     DirectPlayEnumerateW
#else
#define DirectPlayEnumerate     DirectPlayEnumerateA
#endif // UNICODE

extern HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA, LPVOID );
extern HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK, LPVOID );
extern HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);

/****************************************************************************
 *
 * IDirectPlay2 (and IDirectPlay2A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay2
DECLARE_INTERFACE_( IDirectPlay2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay2 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay2_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay2_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay2_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay2_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)

#else /* C++ */

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay2_AddRef(p)                      (p)->AddRef()
#define IDirectPlay2_Release(p)                     (p)->Release()
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay2_Close(p)                       (p)->Close()
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay2_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay3 (and IDirectPlay3A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay3
DECLARE_INTERFACE_( IDirectPlay3, IDirectPlay2 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
	STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
	STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
	STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
	STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
	STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
	STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
	STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay3 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay3_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay3_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay3_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay3_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)

#else /* C++ */

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay3_AddRef(p)                      (p)->AddRef()
#define IDirectPlay3_Release(p)                     (p)->Release()
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay3_Close(p)                       (p)->Close()
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay3_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay4 (and IDirectPlay4A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay4
DECLARE_INTERFACE_( IDirectPlay4, IDirectPlay3 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
    STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
    STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
    STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
    STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
    STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    /*** IDirectPlay4 methods ***/
    STDMETHOD(GetGroupOwner)        (THIS_ DPID, LPDPID) PURE;
    STDMETHOD(SetGroupOwner)        (THIS_ DPID, DPID) PURE;
    STDMETHOD(SendEx)               (THIS_ DPID, DPID, DWORD, LPVOID, DWORD, DWORD, DWORD, LPVOID, DWORD_PTR *) PURE;
    STDMETHOD(GetMessageQueue)      (THIS_ DPID, DPID, DWORD, LPDWORD, LPDWORD) PURE;
    STDMETHOD(CancelMessage)        (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(CancelPriority)       (THIS_ DWORD, DWORD, DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayX interface macros (for IDirectPlay4 and beyond)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayX_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayX_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->lpVtbl->CancelMessage(p,a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->lpVtbl->CancelPriority(p,a,b,c)
#define IDirectPlayX_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->lpVtbl->GetMessageQueue(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlayX_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->lpVtbl->SendEx(p,a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->lpVtbl->GetGroupOwner(p,a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->lpVtbl->SetGroupOwner(p,a,b)

#else /* C++ */

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayX_AddRef(p)                      (p)->AddRef()
#define IDirectPlayX_Release(p)                     (p)->Release()
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->CancelMessage(a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->CancelPriority(a,b,c)
#define IDirectPlayX_Close(p)                       (p)->Close()
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->GetMessageQueue(a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlayX_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->SendEx(a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->GetGroupOwner(a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->SetGroupOwner(a,b)

#endif

/****************************************************************************
 *
 * EnumConnections API flags
 *
 ****************************************************************************/

/*
 * Enumerate Service Providers
 */
#define DPCONNECTION_DIRECTPLAY      0x00000001

/*
 * Enumerate Lobby Providers
 */
#define DPCONNECTION_DIRECTPLAYLOBBY 0x00000002


/****************************************************************************
 *
 * EnumPlayers API flags
 *
 ****************************************************************************/

/*
 * Enumerate all players in the current session
 */
#define DPENUMPLAYERS_ALL           0x00000000
#define DPENUMGROUPS_ALL            DPENUMPLAYERS_ALL

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPENUMPLAYERS_PREVIOUS   0x00000004
 */
//@@END_MSINTERNAL

/*
 * Enumerate only local (created by this application) players
 * or groups
 */
#define DPENUMPLAYERS_LOCAL         0x00000008
#define DPENUMGROUPS_LOCAL			DPENUMPLAYERS_LOCAL

/*
 * Enumerate only remote (non-local) players
 * or groups
 */
#define DPENUMPLAYERS_REMOTE        0x00000010
#define DPENUMGROUPS_REMOTE			DPENUMPLAYERS_REMOTE

/*
 * Enumerate groups along with the players
 */
#define DPENUMPLAYERS_GROUP         0x00000020

/*
 * Enumerate players or groups in another session 
 * (must supply lpguidInstance)
 */
#define DPENUMPLAYERS_SESSION       0x00000080
#define DPENUMGROUPS_SESSION		DPENUMPLAYERS_SESSION

/*
 * Enumerate server players
 */
#define DPENUMPLAYERS_SERVERPLAYER  0x00000100

/*
 * Enumerate spectator players
 */
#define DPENUMPLAYERS_SPECTATOR     0x00000200

/*
 * Enumerate shortcut groups
 */
#define DPENUMGROUPS_SHORTCUT       0x00000400

/*
 * Enumerate staging area groups
 */
#define DPENUMGROUPS_STAGINGAREA    0x00000800

/*
 * Enumerate hidden groups
 */
#define DPENUMGROUPS_HIDDEN         0x00001000

/*
 * Enumerate the group's owner
 */
#define DPENUMPLAYERS_OWNER			0x00002000


/****************************************************************************
 *
 * CreatePlayer API flags
 *
 ****************************************************************************/

/*
 * This flag indicates that this player should be designated
 * the server player. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SERVERPLAYER           DPENUMPLAYERS_SERVERPLAYER

/*
 * This flag indicates that this player should be designated
 * a spectator. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SPECTATOR              DPENUMPLAYERS_SPECTATOR

/*
 * This flag indicates that this player was created locally.
 * (returned from GetPlayerFlags)
 */
#define DPPLAYER_LOCAL                  DPENUMPLAYERS_LOCAL

/*
 * This flag indicates that this player is the group's owner
 * (Only returned in EnumGroupPlayers)
 */
#define DPPLAYER_OWNER                   DPENUMPLAYERS_OWNER

/****************************************************************************
 *
 * CreateGroup API flags
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * This flag indicates that the subgroup was added to the group
 * instead of created in it.
 */
#define DPGROUP_SHORTCUT                DPENUMGROUPS_SHORTCUT
//@@END_MSINTERNAL

/*
 * This flag indicates that the StartSession can be called on the group.
 * The app should specify this at CreateGroup, or CreateGroupInGroup.
 */
#define DPGROUP_STAGINGAREA             DPENUMGROUPS_STAGINGAREA

/*
 * This flag indicates that this group was created locally.
 * (returned from GetGroupFlags)
 */
#define DPGROUP_LOCAL                   DPENUMGROUPS_LOCAL

/*
 * This flag indicates that this group was created hidden.
 */
#define DPGROUP_HIDDEN                   DPENUMGROUPS_HIDDEN


/****************************************************************************
 *
 * EnumSessions API flags
 *
 ****************************************************************************/

/*
 * Enumerate sessions which can be joined
 */
#define DPENUMSESSIONS_AVAILABLE    0x00000001 

/*
 * Enumerate all sessions even if they can't be joined.
 */
#define DPENUMSESSIONS_ALL          0x00000002

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPENUMSESSIONS_PREVIOUS     0x00000004
 */
//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL
/*
 * Private for dplay use only.  Used by DPConnect.
 * Don't free the responses from previous enums
 */
 #define DPENUMSESSIONS_NOREFRESH	0x00000008
//@@END_MSINTERNAL

/*
 * Start an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_ASYNC		0x00000010

/*
 * Stop an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_STOPASYNC	0x00000020
 
/*
 * Enumerate sessions even if they require a password
 */
 #define DPENUMSESSIONS_PASSWORDREQUIRED	0x00000040

/*
 * Return status about progress of enumeration instead of
 * showing any status dialogs.
 */
 #define DPENUMSESSIONS_RETURNSTATUS 0x00000080

/****************************************************************************
 *
 * GetCaps and GetPlayerCaps API flags
 *
 ****************************************************************************/

/*
 * The latency returned should be for guaranteed message sending.
 * Default is non-guaranteed messaging.
 */
#define DPGETCAPS_GUARANTEED        0x00000001 

 
/****************************************************************************
 *
 * GetGroupData, GetPlayerData API flags
 * Remote and local Group/Player data is maintained separately. 
 * Default is DPGET_REMOTE.
 *
 ****************************************************************************/

/*
 * Get the remote data (set by any DirectPlay object in
 * the session using DPSET_REMOTE)
 */
#define DPGET_REMOTE                0x00000000
	
/*
 * Get the local data (set by this DirectPlay object 
 * using DPSET_LOCAL)
 */
#define DPGET_LOCAL                 0x00000001


/****************************************************************************
 *
 * Open API flags
 *
 ****************************************************************************/

/*
 * Join the session that is described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_JOIN                 0x00000001

/*
 * Create a new session as described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_CREATE               0x00000002

/*
 * Return status about progress of open instead of showing
 * any status dialogs.
 */
 #define DPOPEN_RETURNSTATUS		DPENUMSESSIONS_RETURNSTATUS

//  @@BEGIN_MSINTERNAL 
// this is here so you don't pound the flag! -andy
// #define DPENUMSESSIONS_RETURNSTATUS 0x00000080 
//  @@END_MSINTERNAL


/****************************************************************************
 *
 * DPLCONNECTION flags
 *
 ****************************************************************************/

/*
 * This application should create a new session as
 * described by the DPSESIONDESC structure
 */
#define DPLCONNECTION_CREATESESSION					DPOPEN_CREATE

/*
 * This application should join the session described by 
 * the DPSESIONDESC structure with the lpAddress data
 */
#define DPLCONNECTION_JOINSESSION					DPOPEN_JOIN

/****************************************************************************
 *
 * Receive API flags
 * Default is DPRECEIVE_ALL
 *
 ****************************************************************************/

/*
 * Get the first message in the queue
 */
#define DPRECEIVE_ALL               0x00000001

/*
 * Get the first message in the queue directed to a specific player 
 */
#define DPRECEIVE_TOPLAYER          0x00000002

/*
 * Get the first message in the queue from a specific player
 */
#define DPRECEIVE_FROMPLAYER        0x00000004

/*
 * Get the message but don't remove it from the queue
 */
#define DPRECEIVE_PEEK              0x00000008


/****************************************************************************
 *
 * Send API flags
 *
 ****************************************************************************/

/*
 * Send the message using a guaranteed send method.
 * Default is non-guaranteed.
 */
#define DPSEND_GUARANTEED           0x00000001

//@@BEGIN_MSINTERNAL
/*
 * Do not delete the DPSEND_HIGHPRIORITY, DPSEND_OPENSTREAM or
 * DPSEND_CLOSESTREAM flags so we don't cause compile errors
 * in apps written for DX3 that use them.
 */
//@@END_MSINTERNAL

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_HIGHPRIORITY         0x00000002

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_OPENSTREAM           0x00000008

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_CLOSESTREAM          0x00000010

/*
 * Send the message digitally signed to ensure authenticity.
 */
#define DPSEND_SIGNED               0x00000020

/*
 * Send the message with encryption to ensure privacy.
 */
#define DPSEND_ENCRYPTED            0x00000040

/*
 * The message is a lobby system message
 */
#define DPSEND_LOBBYSYSTEMMESSAGE	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * Indicates that the message was on the pending queue
 */
#define DPSEND_PENDING              0x00000100
//@@END_MSINTERNAL

/*
 * Send message asynchronously, must check caps
 * before using this flag.  It is always provided
 * if the protocol flag is set.
 */
#define DPSEND_ASYNC				0x00000200

/*
 * When an message is completed, don't tell me. 
 * by default the application is notified with a system message.
 */
#define DPSEND_NOSENDCOMPLETEMSG    0x00000400

//@@BEGIN_MSINTERNAL
/*
 * To make some system messages proceed asynchronously
 */
#define DPSEND_SYSMESS              (DPSEND_GUARANTEE|DPSEND_ASYNC)
//@@END_MSINTERNAL

/*
 * Maximum priority for sends available to applications
 */
#define DPSEND_MAX_PRI              0x0000FFFF
#define DPSEND_MAX_PRIORITY         DPSEND_MAX_PRI

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPSEND_GUARANTEE            DPSEND_GUARANTEED
 * #define DPSEND_HIGHPRIORITY         0x00000002
 * #define DPSEND_TRYONCE              0x00000004
 */
 
/* This flag is used only for testing DPlay.
 *
 * When doing an async send, indicates that ownership of the
 * message buffers is passed to directplay.  Otherwise
 * DirectPlay must copy the buffer for an async send.
 */
#define DPSEND_NOCOPY               0x00000800

//@@END_MSINTERNAL

/****************************************************************************
 *
 * SetGroupData, SetGroupName, SetPlayerData, SetPlayerName,
 * SetSessionDesc API flags.
 * Default is DPSET_REMOTE.
 *
 ****************************************************************************/

/* 
 * Propagate the data to all players in the session
 */
#define DPSET_REMOTE                0x00000000

/*
 * Do not propagate the data to other players
 */
#define DPSET_LOCAL                 0x00000001

/*
 * Used with DPSET_REMOTE, use guaranteed message send to
 * propagate the data
 */
#define DPSET_GUARANTEED            0x00000002

/****************************************************************************
 *
 * GetMessageQueue API flags.
 * Default is DPMESSAGEQUEUE_SEND
 *
 ****************************************************************************/

/* 
 * Get Send Queue - requires Service Provider Support
 */
#define DPMESSAGEQUEUE_SEND        	0x00000001

/*
 * Get Receive Queue
 */
#define DPMESSAGEQUEUE_RECEIVE      0x00000002


/****************************************************************************
 *
 * Connect API flags
 *
 ****************************************************************************/

//  @@BEGIN_MSINTERNAL 
// this is here so you don't pound the flag! -andy
// #define DPENUMSESSIONS_RETURNSTATUS 0x00000080 
//  @@END_MSINTERNAL
 
/*
 * Start an asynchronous connect which returns status codes
 */
#define DPCONNECT_RETURNSTATUS      (DPENUMSESSIONS_RETURNSTATUS)


/****************************************************************************
 *
 * DirectPlay system messages and message data structures
 *
 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
 * the dwType member against one of the following DPSYS_xxx constants. Once
 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
 * structures to access the data of the message.
 *
 ****************************************************************************/

/*
 * A new player or group has been created in the session
 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
 * is a player or a group.
 */
#define DPSYS_CREATEPLAYERORGROUP   0x0003  

/*
 * A player has been deleted from the session
 * Use DPMSG_DESTROYPLAYERORGROUP
 */
#define DPSYS_DESTROYPLAYERORGROUP  0x0005  

/*
 * A player has been added to a group
 * Use DPMSG_ADDPLAYERTOGROUP
 */
#define DPSYS_ADDPLAYERTOGROUP      0x0007  

/*
 * A player has been removed from a group
 * Use DPMSG_DELETEPLAYERFROMGROUP
 */
#define DPSYS_DELETEPLAYERFROMGROUP 0x0021  

/*
 * This DirectPlay object lost its connection with all the
 * other players in the session.
 * Use DPMSG_SESSIONLOST.
 */
#define DPSYS_SESSIONLOST           0x0031

/*
 * The current host has left the session.
 * This DirectPlay object is now the host.
 * Use DPMSG_HOST.
 */
#define DPSYS_HOST                  0x0101

/*
 * The remote data associated with a player or
 * group has changed. Check dwPlayerType to see
 * if it is a player or a group
 * Use DPMSG_SETPLAYERORGROUPDATA
 */
#define DPSYS_SETPLAYERORGROUPDATA  0x0102

/*
 * The name of a player or group has changed.
 * Check dwPlayerType to see if it is a player
 * or a group.
 * Use DPMSG_SETPLAYERORGROUPNAME
 */
#define DPSYS_SETPLAYERORGROUPNAME  0x0103

/*
 * The session description has changed.
 * Use DPMSG_SETSESSIONDESC
 */
#define DPSYS_SETSESSIONDESC        0x0104

/*
 * A group has been added to a group
 * Use DPMSG_ADDGROUPTOGROUP
 */
#define DPSYS_ADDGROUPTOGROUP      	0x0105  

/*
 * A group has been removed from a group
 * Use DPMSG_DELETEGROUPFROMGROUP
 */
#define DPSYS_DELETEGROUPFROMGROUP 	0x0106

/*
 * A secure player-player message has arrived.
 * Use DPMSG_SECUREMESSAGE
 */
#define DPSYS_SECUREMESSAGE         0x0107

/*
 * Start a new session.
 * Use DPMSG_STARTSESSION
 */
#define DPSYS_STARTSESSION          0x0108

/*
 * A chat message has arrived
 * Use DPMSG_CHAT
 */
#define DPSYS_CHAT                  0x0109

/*
 * The owner of a group has changed
 * Use DPMSG_SETGROUPOWNER
 */
#define DPSYS_SETGROUPOWNER         0x010A

/*
 * An async send has finished, failed or been cancelled
 * Use DPMSG_SENDCOMPLETE
 */
#define DPSYS_SENDCOMPLETE          0x010d


/*
 * Used in the dwPlayerType field to indicate if it applies to a group
 * or a player
 */
#define DPPLAYERTYPE_GROUP          0x00000000
#define DPPLAYERTYPE_PLAYER         0x00000001


/*
 * DPMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct
{
    DWORD       dwType;         // Message type
} DPMSG_GENERIC, FAR *LPDPMSG_GENERIC;

/*
 * DPMSG_CREATEPLAYERORGROUP
 * System message generated when a new player or group
 * created in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of the player or group
    DWORD       dwCurrentPlayers;   // current # players & groups in session
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
    DPNAME      dpnName;        // structure with name info
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPID	    dpIdParent;     // id of parent group
	DWORD		dwFlags;		// player or group flags
} DPMSG_CREATEPLAYERORGROUP, FAR *LPDPMSG_CREATEPLAYERORGROUP;

/*
 * DPMSG_DESTROYPLAYERORGROUP
 * System message generated when a player or group is being
 * destroyed in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // player ID being deleted
    LPVOID      lpLocalData;    // copy of players local data
    DWORD       dwLocalDataSize; // sizeof local data
    LPVOID      lpRemoteData;   // copy of players remote data
    DWORD       dwRemoteDataSize; // sizeof remote data
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPNAME      dpnName;        // structure with name info
    DPID	    dpIdParent;     // id of parent group	
	DWORD		dwFlags;		// player or group flags
} DPMSG_DESTROYPLAYERORGROUP, FAR *LPDPMSG_DESTROYPLAYERORGROUP;

/*
 * DPMSG_ADDPLAYERTOGROUP
 * System message generated when a player is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdGroup;      // group ID being added to
    DPID        dpIdPlayer;     // player ID being added
} DPMSG_ADDPLAYERTOGROUP, FAR *LPDPMSG_ADDPLAYERTOGROUP;

/*
 * DPMSG_DELETEPLAYERFROMGROUP
 * System message generated when a player is being
 * removed from a group
 */
typedef DPMSG_ADDPLAYERTOGROUP          DPMSG_DELETEPLAYERFROMGROUP;
typedef DPMSG_DELETEPLAYERFROMGROUP     FAR *LPDPMSG_DELETEPLAYERFROMGROUP;

/*
 * DPMSG_ADDGROUPTOGROUP
 * System message generated when a group is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdParentGroup; // group ID being added to
    DPID        dpIdGroup;     // group ID being added
} DPMSG_ADDGROUPTOGROUP, FAR *LPDPMSG_ADDGROUPTOGROUP;

/*
 * DPMSG_DELETEGROUPFROMGROUP
 * System message generated when a GROUP is being
 * removed from a group
 */
typedef DPMSG_ADDGROUPTOGROUP          DPMSG_DELETEGROUPFROMGROUP;
typedef DPMSG_DELETEGROUPFROMGROUP     FAR *LPDPMSG_DELETEGROUPFROMGROUP;

/*
 * DPMSG_SETPLAYERORGROUPDATA
 * System message generated when remote data for a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
} DPMSG_SETPLAYERORGROUPDATA, FAR *LPDPMSG_SETPLAYERORGROUPDATA;

/*
 * DPMSG_SETPLAYERORGROUPNAME
 * System message generated when the name of a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    DPNAME      dpnName;        // structure with new name info
} DPMSG_SETPLAYERORGROUPNAME, FAR *LPDPMSG_SETPLAYERORGROUPNAME;

/*
 * DPMSG_SETSESSIONDESC
 * System message generated when session desc has changed
 */
typedef struct
{
    DWORD           dwType;     // Message type
    DPSESSIONDESC2  dpDesc;     // Session desc
} DPMSG_SETSESSIONDESC, FAR *LPDPMSG_SETSESSIONDESC;

/*
 * DPMSG_HOST
 * System message generated when the host has migrated to this
 * DirectPlay object.
 *
 */
typedef DPMSG_GENERIC       DPMSG_HOST;
typedef DPMSG_HOST          FAR *LPDPMSG_HOST;

/*
 * DPMSG_SESSIONLOST
 * System message generated when the connection to the session is lost.
 *
 */
typedef DPMSG_GENERIC       DPMSG_SESSIONLOST;
typedef DPMSG_SESSIONLOST   FAR *LPDPMSG_SESSIONLOST;

/*
 * DPMSG_SECUREMESSAGE
 * System message generated when a player requests a secure send
 */
typedef struct 
{
    DWORD		dwType;         // Message Type
    DWORD		dwFlags;        // Signed/Encrypted
    DPID        dpIdFrom;       // ID of Sending Player
    LPVOID		lpData;         // Player message
    DWORD		dwDataSize;     // Size of player message
} DPMSG_SECUREMESSAGE, FAR *LPDPMSG_SECUREMESSAGE;

/*
 * DPMSG_STARTSESSION
 * System message containing all information required to 
 * start a new session
 */
typedef struct
{
    DWORD              dwType;     // Message type
    LPDPLCONNECTION    lpConn;     // DPLCONNECTION structure
} DPMSG_STARTSESSION, FAR *LPDPMSG_STARTSESSION;

/*
 * DPMSG_CHAT
 * System message containing a chat message
 */
typedef struct
{
    DWORD              	dwType;       	// Message type
    DWORD              	dwFlags;      	// Message flags
    DPID               	idFromPlayer; 	// ID of the Sending Player
    DPID               	idToPlayer;   	// ID of the To Player
    DPID               	idToGroup;    	// ID of the To Group
	LPDPCHAT 			lpChat;			// Pointer to a structure containing the chat message
} DPMSG_CHAT, FAR *LPDPMSG_CHAT;

/*
 * DPMSG_SETGROUPOWNER
 * System message generated when the owner of a group has changed
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        idGroup;        // ID of the group
    DPID        idNewOwner;     // ID of the player that is the new owner
    DPID        idOldOwner;     // ID of the player that used to be the owner
} DPMSG_SETGROUPOWNER, FAR *LPDPMSG_SETGROUPOWNER;

/*
 * DPMSG_SENDCOMPLETE
 * System message generated when finished with an Async Send message
 *
 * NOTE SENDPARMS has an overlay for DPMSG_SENDCOMPLETE, don't
 *                change this message w/o changing SENDPARMS.
 */
typedef struct
{
	DWORD 		dwType;
	DPID		idFrom;
	DPID		idTo;
	DWORD		dwFlags;
	DWORD		dwPriority;
	DWORD		dwTimeout;
	LPVOID		lpvContext;
	DWORD		dwMsgID;
	HRESULT     hr;
	DWORD       dwSendTime;
} DPMSG_SENDCOMPLETE, *LPDPMSG_SENDCOMPLETE;

/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           S_OK
#define DPERR_ALREADYINITIALIZED        MAKE_DPHRESULT(   5 )
#define DPERR_ACCESSDENIED              MAKE_DPHRESULT(  10 )
#define DPERR_ACTIVEPLAYERS             MAKE_DPHRESULT(  20 )
#define DPERR_BUFFERTOOSMALL            MAKE_DPHRESULT(  30 )
#define DPERR_CANTADDPLAYER             MAKE_DPHRESULT(  40 )
#define DPERR_CANTCREATEGROUP           MAKE_DPHRESULT(  50 )
#define DPERR_CANTCREATEPLAYER          MAKE_DPHRESULT(  60 )
#define DPERR_CANTCREATESESSION         MAKE_DPHRESULT(  70 )
#define DPERR_CAPSNOTAVAILABLEYET       MAKE_DPHRESULT(  80 )
#define DPERR_EXCEPTION                 MAKE_DPHRESULT(  90 )
#define DPERR_GENERIC                   E_FAIL
#define DPERR_INVALIDFLAGS              MAKE_DPHRESULT( 120 )
#define DPERR_INVALIDOBJECT             MAKE_DPHRESULT( 130 )
#define DPERR_INVALIDPARAM              E_INVALIDARG
#define DPERR_INVALIDPARAMS             DPERR_INVALIDPARAM
#define DPERR_INVALIDPLAYER             MAKE_DPHRESULT( 150 )
#define DPERR_INVALIDGROUP             	MAKE_DPHRESULT( 155 )
#define DPERR_NOCAPS                    MAKE_DPHRESULT( 160 )
#define DPERR_NOCONNECTION              MAKE_DPHRESULT( 170 )
#define DPERR_NOMEMORY                  E_OUTOFMEMORY
#define DPERR_OUTOFMEMORY               DPERR_NOMEMORY
#define DPERR_NOMESSAGES                MAKE_DPHRESULT( 190 )
#define DPERR_NONAMESERVERFOUND         MAKE_DPHRESULT( 200 )
#define DPERR_NOPLAYERS                 MAKE_DPHRESULT( 210 )
#define DPERR_NOSESSIONS                MAKE_DPHRESULT( 220 )
#define DPERR_PENDING					E_PENDING
#define DPERR_SENDTOOBIG				MAKE_DPHRESULT( 230 )
#define DPERR_TIMEOUT                   MAKE_DPHRESULT( 240 )
#define DPERR_UNAVAILABLE               MAKE_DPHRESULT( 250 )
#define DPERR_UNSUPPORTED               E_NOTIMPL
#define DPERR_BUSY                      MAKE_DPHRESULT( 270 )
#define DPERR_USERCANCEL                MAKE_DPHRESULT( 280 ) 
#define DPERR_NOINTERFACE               E_NOINTERFACE
#define DPERR_CANNOTCREATESERVER        MAKE_DPHRESULT( 290 )
#define DPERR_PLAYERLOST                MAKE_DPHRESULT( 300 )
#define DPERR_SESSIONLOST               MAKE_DPHRESULT( 310 )
#define DPERR_UNINITIALIZED             MAKE_DPHRESULT( 320 )
#define DPERR_NONEWPLAYERS              MAKE_DPHRESULT( 330 )
#define DPERR_INVALIDPASSWORD           MAKE_DPHRESULT( 340 )
#define DPERR_CONNECTING                MAKE_DPHRESULT( 350 )
#define DPERR_CONNECTIONLOST            MAKE_DPHRESULT( 360 )
#define DPERR_UNKNOWNMESSAGE            MAKE_DPHRESULT( 370 )
#define DPERR_CANCELFAILED              MAKE_DPHRESULT( 380 )
#define DPERR_INVALIDPRIORITY           MAKE_DPHRESULT( 390 )
#define DPERR_NOTHANDLED                MAKE_DPHRESULT( 400 )
#define DPERR_CANCELLED                 MAKE_DPHRESULT( 410 )
#define DPERR_ABORTED                   MAKE_DPHRESULT( 420 )


#define DPERR_BUFFERTOOLARGE            MAKE_DPHRESULT( 1000 )
#define DPERR_CANTCREATEPROCESS         MAKE_DPHRESULT( 1010 )
#define DPERR_APPNOTSTARTED             MAKE_DPHRESULT( 1020 )
#define DPERR_INVALIDINTERFACE          MAKE_DPHRESULT( 1030 )
#define DPERR_NOSERVICEPROVIDER         MAKE_DPHRESULT( 1040 )
#define DPERR_UNKNOWNAPPLICATION        MAKE_DPHRESULT( 1050 )
#define DPERR_NOTLOBBIED                MAKE_DPHRESULT( 1070 )
#define DPERR_SERVICEPROVIDERLOADED		MAKE_DPHRESULT( 1080 )
#define DPERR_ALREADYREGISTERED			MAKE_DPHRESULT( 1090 )
#define DPERR_NOTREGISTERED				MAKE_DPHRESULT( 1100 )

//
// Security related errors
//
#define DPERR_AUTHENTICATIONFAILED      MAKE_DPHRESULT(  2000 )
#define DPERR_CANTLOADSSPI              MAKE_DPHRESULT(  2010 )
#define DPERR_ENCRYPTIONFAILED          MAKE_DPHRESULT(  2020 )
#define DPERR_SIGNFAILED                MAKE_DPHRESULT(  2030 )
#define DPERR_CANTLOADSECURITYPACKAGE   MAKE_DPHRESULT(  2040 )
#define DPERR_ENCRYPTIONNOTSUPPORTED    MAKE_DPHRESULT(  2050 )
#define DPERR_CANTLOADCAPI              MAKE_DPHRESULT(  2060 )
#define DPERR_NOTLOGGEDIN               MAKE_DPHRESULT(  2070 )
#define DPERR_LOGONDENIED               MAKE_DPHRESULT(  2080 )


/****************************************************************************
 *
 * 	dplay 1.0 obsolete structures + interfaces
 *	Included for compatibility only. New apps should
 *	use IDirectPlay2
 *
 ****************************************************************************/

// define this to ignore obsolete interfaces and constants
#ifndef IDIRECTPLAY2_OR_GREATER

#define DPOPEN_OPENSESSION          DPOPEN_JOIN
#define DPOPEN_CREATESESSION        DPOPEN_CREATE

#define DPENUMSESSIONS_PREVIOUS     0x00000004

#define DPENUMPLAYERS_PREVIOUS      0x00000004

//@@BEGIN_MSINTERNAL
/*
 * Defined in DPlay 1 header file but appear to have no effect 
 * in the code
 */
//@@END_MSINTERNAL
#define DPSEND_GUARANTEE            DPSEND_GUARANTEED
#define DPSEND_TRYONCE              0x00000004

//@@BEGIN_MSINTERNAL
/*
 * Defined in DPlay 1 header file but appear to have no effect
 * in the code
 */
//@@END_MSINTERNAL
#define DPCAPS_NAMESERVICE          0x00000001
#define DPCAPS_NAMESERVER           DPCAPS_ISHOST
#define DPCAPS_GUARANTEED           0x00000004

#define DPLONGNAMELEN               52
#define DPSHORTNAMELEN              20
#define DPSESSIONNAMELEN            32
#define DPPASSWORDLEN               16
#define DPUSERRESERVED              16

#define DPSYS_ADDPLAYER             0x0003
#define DPSYS_DELETEPLAYER          0x0005

#define DPSYS_DELETEGROUP           0x0020
#define DPSYS_DELETEPLAYERFROMGRP   0x0021
#define DPSYS_CONNECT               0x484b

typedef struct
{
    DWORD       dwType;
    DWORD       dwPlayerType;
    DPID        dpId;
    char        szLongName[DPLONGNAMELEN];
    char        szShortName[DPSHORTNAMELEN];
    DWORD       dwCurrentPlayers;
}   DPMSG_ADDPLAYER;

typedef DPMSG_ADDPLAYER DPMSG_ADDGROUP;

typedef struct
{
    DWORD       dwType;
    DPID        dpIdGroup;
    DPID        dpIdPlayer;
} DPMSG_GROUPADD;

typedef DPMSG_GROUPADD DPMSG_GROUPDELETE;
typedef struct
{
    DWORD       dwType;
    DPID        dpId;
} DPMSG_DELETEPLAYER;

typedef BOOL (PASCAL *LPDPENUMPLAYERSCALLBACK)(
    DPID    dpId,
    LPSTR   lpFriendlyName,
    LPSTR   lpFormalName,
    DWORD   dwFlags,
    LPVOID  lpContext );

typedef struct
{
    DWORD   dwSize;
    GUID    guidSession;                  
    DWORD_PTR dwSession;                    
    DWORD   dwMaxPlayers;                 
    DWORD   dwCurrentPlayers;             
    DWORD   dwFlags;                      
    char    szSessionName[DPSESSIONNAMELEN];
    char    szUserField[DPUSERRESERVED];
    DWORD_PTR   dwReserved1;                  
    char    szPassword[DPPASSWORDLEN];    
    DWORD_PTR   dwReserved2;                  
    DWORD_PTR   dwUser1;
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC,*LPDPSESSIONDESC;

typedef BOOL (PASCAL * LPDPENUMSESSIONSCALLBACK)(
    LPDPSESSIONDESC lpDPSessionDesc,
    LPVOID      lpContext,
    LPDWORD     lpdwTimeOut,
    DWORD       dwFlags);

/*
 * IDirectPlay
 */
#undef INTERFACE
#define INTERFACE IDirectPlay
DECLARE_INTERFACE_( IDirectPlay, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPSTR,LPSTR) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPSTR) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR) PURE;
};

/****************************************************************************
 *
 * IDirectPlay interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay_Close(p)                        (p)->lpVtbl->Close(p)
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->lpVtbl->CreateGroup(p,a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->lpVtbl->CreatePlayer(p,a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->lpVtbl->EnableNewPlayers(p,a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->lpVtbl->GetPlayerCaps(p,a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->lpVtbl->GetPlayerName(p,a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay_Open(p,a)                       (p)->lpVtbl->Open(p,a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->lpVtbl->SaveSession(p,a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->lpVtbl->SetPlayerName(p,a,b,c)

#else /* C++ */

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->AddPlayerToGroup(a,b)
#define IDirectPlay_Close(p)                        (p)->Close()
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->CreateGroup(a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->CreatePlayer(a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->DestroyGroup(a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->DestroyPlayer(a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->EnableNewPlayers(a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->EnumGroupPlayers(a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->EnumGroups(a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->GetMessageCount(a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->GetPlayerCaps(a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->GetPlayerName(a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->Initialize(a)
#define IDirectPlay_Open(p,a)                       (p)->Open(a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->Receive(a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->SaveSession(a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->Send(a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->SetPlayerName(a,b,c)

#endif

DEFINE_GUID(IID_IDirectPlay, 0x5454e9a0, 0xdb65, 0x11ce, 0x92, 0x1c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72);

#endif // IDIRECTPLAY2_OR_GREATER

/****************************************************************************
 *
 * IDirectPlay macros (included regardless of IDIRECTPLAY2_OR_GREATER flag)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectPlay_Release(p)                      (p)->lpVtbl->Release(p)

#else

#define IDirectPlay_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectPlay_AddRef(p)                       (p)->AddRef()
#define IDirectPlay_Release(p)                      (p)->Release()

#endif // IDirectPlay interface macros 


/*@@BEGIN_MSINTERNAL */
/*
 *	All of the following entries are part of the voice support that was
 *	removed from dplay before DX6.  It is currently still part of the
 *	code base and is just #ifdef'd out.
 */
#ifdef DPLAY_VOICE_SUPPORT
	/*
	 * This DirectPlay object supports voice communication
	 */
	#define DPCAPS_VOICE			  	0x00000200

	/*
	 * This DirectPlay player supports voice communication
	 */
	#define DPPLAYERCAPS_VOICE			0x00000400

	// From interface declaration
	STDMETHOD(CloseVoice)	        (THIS_ DWORD) PURE;
	STDMETHOD(OpenVoice)	        (THIS_ DPID, DPID,DWORD) PURE;

	#define IDirectPlayX_CloseVoice(p,a)	           	(p)->lpVtbl->CloseVoice(p,a)
	#define IDirectPlayX_OpenVoice(p,a,b,c)           	(p)->lpVtbl->OpenVoice(p,a,b,c)

	#define IDirectPlayX_CloseVoice(p,a)	           	(p)->CloseVoice(a)
	#define IDirectPlayX_OpenVoice(p,a,b,c)           	(p)->OpenVoice(a,b,c)

	/*
	 * This flag must be passed to Open if the app intends to use voice
	 */
	#define DPOPEN_VOICE				 0x00000004

	/*
	 * A voice channel has been opened
	 * Use DPMSG_VOICE
	 */
	#define DPSYS_VOICEOPEN		        0x010B

	/*
	 * A voice channel has been closed
	 * Use DPMSG_VOICE
	 */
	#define DPSYS_VOICECLOSE	        0x010C

	/*
	 * DPMSG_VOICE
	 * a voice operation has completed
	 */
	typedef struct
	{
		DWORD              	dwType;        	// Message type
		DWORD              	dwFlags;       	// unused
		DPID               	idFromPlayer;  	// ID of the Sending Player
		DPID               	idToPlayer;    	// ID of the To Player
		DPID               	idToGroup;     	// ID of the To Group
	} DPMSG_VOICE, FAR *LPDPMSG_VOICE;
#endif // DPLAY_VOICE_SUPPORT
/*@@END_MSINTERNAL */


#ifdef __cplusplus
};
#endif

#pragma warning(default:4201)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dplaysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysp.h
 *  Content:    DirectPlay Service Provider header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/96    	andyco  created it
 *  1/26/96   	andyco  list data structures
 *	2/15/96		andyco	packed structures (for net xport)
 *	3/16/96		andyco	added shutdown callback
 *	3/25/96		andyco	added sp nodes for sp enum
 *	3/28/96		andyco	added free receive buffer callback
 *	4/9/96		andyco	moved dplayi_dplay, packed player, spnode, etc. to dplaypr.h
 *	4/10/96		andyco	added getmessagesize,isvalidmessage fn's
 *  4/11/96		andyco	added spdata instead of reserving a bunch of dwords
 *	4/12/96		andyco	added dplay_xxx methods to get rid of dpmess.h macros
 *	4/18/96		andyco	added remote players to createplayer, getplayer + group
 *						list fn's
 *	4/25/96		andyco	got rid of dwreservedx. added dwSPHeaderSize. spblob  
 *						follows message
 *	5/2/96		andyco	replaced idirectplay * with iunknown *
 *	5/9/96		andyco	idirectplay2
 *	6/8/96		andyco	moved dplayi_player/group to dplaypr.h. ported from 
 *						(now defunct) dplayi.h.
 *	6/19/96		andyco	changed names, etc. for consistency
 *	6/22/96		andyco	tossed dwCookies. removed pUnk from callbacks.  removed sessiondesc
 *	 					from callbacks.  alphapathetical order.
 *	6/22/96		andyco	made DPlay_xxx functions a COM interface (IDirectPlaySP)
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/23/96		andyco	updated comments. removed bLocal from Create fn's (look 
 *						at flags).
 *	6/23/96		kipo	cleanup for service provider lab.
 *	6/24/96		kipo	added version number
 *	6/24/96		andyco	added getaddress
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/10/96		andyco	added dwflags to createaddress.  changed guid * to
 *						refguid in createaddress call.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  7/30/96     kipo    added DPLAYI_PLAYER_CREATEDPLAYEREVENT
 *  8/23/96     kipo    incremented major version number
 *	10/10/96	andyco	added optimized groups
 *	2/7/97		andyco	added idpsp to each callback
 *	3/04/97		kipo	updated gdwDPlaySPRefCount definition
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *	5/8/97		myronth	added DPLAYI_GROUP_STAGINGAREA (internal)
 *	5/18/97		kipo	added DPLAYI_PLAYER_SPECTATOR
 *	5/23/97		kipo	Added support for return status codes
 *	10/21/97	myronth	Added DPLAYI_GROUP_HIDDEN
 *	10/29/97	myronth	Added DPLAYI_PLAYER_OWNER (internal)
 *	10/31/97	andyco	added voice call
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohailm	Added dwSessionFlags to DPSP_OPENDATA
 *  4/1/98      aarono  Added DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE
 *  6/2/98		aarono  Added DPLAYI_PLAYER_BEING_DESTROYED to avoid
 *                       deleting more than once.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAYSP_INCLUDED__
#define __DPLAYSP_INCLUDED__

#include "dplay.h"
#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectPlay Service Provider Structures
 *
 * Various structures used to invoke DirectPlay Service Providers.
 *
 *==========================================================================*/

/*
 * Callback for EnumMRU()
 */
typedef BOOL (PASCAL *LPENUMMRUCALLBACK)(
    LPCVOID         lpData,
    DWORD           dwDataSize,
    LPVOID          lpContext);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPSP_MAJORVERSION               0x00060000

/*
 * This is the major version number that DirectX 3 (DX3) shipped with
 */
#define DPSP_DX3VERSION               	0x00040000

/*
 * This is the major version number that DirectX 5 (DX5) shipped with
 */
#define DPSP_DX5VERSION               	0x00050000

/*
 * Masks to help check the version info
 */
#define DPSP_MAJORVERSIONMASK			0xFFFF0000

#define DPSP_MINORVERSIONMASK			0x0000FFFF

//@@BEGIN_MSINTERNAL
#ifdef BIGMESSAGEDEFENSE
/*
 * warning types that could be returned from the SP via HandleSPWarning
 * see below for corresponding structures
 */
#define DPSPWARN_MESSAGETOOBIG			0xB0FF0001
#define DPSPWARN_PLAYERDEAD				0xB0FF0002

#endif
//@@END_MSINTERNAL

/*
 * DPLAYI_PLAYER_FLAGS
 *
 * These flags may be used with players or groups, as appropriate.
 * The service provider can get these by calling IDirectPlaySP->GetFlags()
 * as defined below.  The flags are also available in the dwFlags field
 * for most of the callback data structures.
 * 
 * These flags are set by DirectPlay - they are read only for the 
 * service provider
 *
 */

/*
 * Player is the system player (player only).
 */
#define DPLAYI_PLAYER_SYSPLAYER         0x00000001

/* 
 * Player is the name server (player only). Only valid when 
 * DPLAYI_PLAYER_SYSPLAYER is also set.
 */
#define DPLAYI_PLAYER_NAMESRVR          0x00000002

/*
 * Player belongs to a group (player only).
 */
#define DPLAYI_PLAYER_PLAYERINGROUP     0x00000004

/*
 * Player allocated on this IDirectPlay (player or group).
 */
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

//@@BEGIN_MSINTERNAL
/*
 * Player event allocated by DirectPlay (player only).
 * Used for compatability with the IDirectPlay1 API.
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_CREATEDPLAYEREVENT 0x00000010
//@@END_MSINTERNAL

/*
 * This group is the system group.  If the service provider returns
 * DPCAPS_GROUPOPTIMIZED on a GetCaps call, then DirectPlay will create
 * a system group containing all players in the game.  Sends by the application
 * to DPID_ALLPLAYERS will be sent to this group.  (group only).
 *												   
 */
#define DPLAYI_GROUP_SYSGROUP			0x00000020

/*
 * DirectPlay "owns" this group.  Sends to this group will be emulated by DirectPlay
 * (sends go to each individual member).  This flag  is set on a group if the
 * Service Provider returns failure to the CreateGroup or AddPlayerToGroup
 * callback. (group only).
 *
 */
#define DPLAYI_GROUP_DPLAYOWNS			0x00000040

/*
 * This player is the app's server player
 */
#define DPLAYI_PLAYER_APPSERVER       	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * This group is a staging area
 */
#define DPLAYI_GROUP_STAGINGAREA       	0x00000100
//@@END_MSINTERNAL

/*
 * This player is a spectator
 */
#define DPLAYI_PLAYER_SPECTATOR       	0x00000200

/*
 * This group is hidden
 */
#define DPLAYI_GROUP_HIDDEN		       	0x00000400

//@@BEGIN_MSINTERNAL
/*
 * Player is the owner of a group.  (Only used
 * internally, and only used during EnumGroupPlayers).
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_OWNER             0x00000800

// a-josbor: Internal flag that gets set when the Keepalive has
//	determined that this player should be killed
#define DPLAYI_PLAYER_ON_DEATH_ROW		0x00001000

// aarono: use this flag to mark players waiting for nametable.
// any sends to these players just return DPERR_UNAVAILABLE
// this bit is cleared when we transmit the nametable.
#define DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE 0x00002000

// a-josbor: set when we get an error back on a reliable
// send.  We don't kill them right away because there might
// be messages pending from them
#define DPLAYI_PLAYER_CONNECTION_LOST		0x00004000
/*
 * Used to stop re-entering destory player
 */
#define DPLAYI_PLAYER_BEING_DESTROYED 0x00010000

#define DPLAYI_PLAYER_NONPROP_FLAGS ( DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE | \
									  DPLAYI_PLAYER_BEING_DESTROYED | \
									  DPLAYI_PLAYER_ON_DEATH_ROW |\
									  DPLAYI_PLAYER_CONNECTION_LOST )

//@@END_MSINTERNAL


/*
 *	IDirectPlaySP
 *
 *	Service providers are passed an IDirectPlaySP interface
 *	in the SPInit method. This interface is used to call DirectPlay.
 */

struct IDirectPlaySP;

typedef struct IDirectPlaySP FAR* LPDIRECTPLAYSP;

#undef INTERFACE
#define INTERFACE IDirectPlaySP
DECLARE_INTERFACE_( IDirectPlaySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlaySP methods ***/
    STDMETHOD(AddMRUEntry)          (THIS_ LPCWSTR, LPCWSTR, LPCVOID, DWORD, DWORD) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID,REFGUID,LPCVOID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK,LPCVOID,DWORD,LPVOID) PURE;
    STDMETHOD(EnumMRUEntries)       (THIS_ LPCWSTR, LPCWSTR, LPENUMMRUCALLBACK, LPVOID) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetSPPlayerData)      (THIS_ DPID,LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(HandleMessage)        (THIS_ LPVOID,DWORD,LPVOID) PURE;
    STDMETHOD(SetSPPlayerData)      (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 5 ***/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSPData)      		(THIS_ LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(SetSPData)      		(THIS_ LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 6 ***/
    STDMETHOD_(VOID,SendComplete)   (THIS_ LPVOID,DWORD) PURE;
//@@BEGIN_MSINTERNAL 
#ifdef BIGMESSAGEDEFENSE
    STDMETHOD(HandleSPWarning)      (THIS_ LPVOID,DWORD,LPVOID) PURE;
#endif
//@@END_MSINTERNAL
};

/*
 * GUID for IDirectPlaySP
 */
// {0C9F6360-CC61-11cf-ACEC-00AA006886E3}
DEFINE_GUID(IID_IDirectPlaySP, 0xc9f6360, 0xcc61, 0x11cf, 0xac, 0xec, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

/* CALLBACK DATA STRUCTURES
 *
 * These are passed by DirectPlay to the service provider when
 * the callback is invoked.
 */

/*
 * DPSP_ADDPLAYERTOGROUPDATA
 */
typedef struct _DPSP_ADDPLAYERTOGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_ADDPLAYERTOGROUPDATA;

typedef DPSP_ADDPLAYERTOGROUPDATA FAR* LPDPSP_ADDPLAYERTOGROUPDATA;

/*
 * DPSP_CLOSEDATA - used with CloseEx
 */
typedef struct _DPSP_CLOSEDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CLOSEDATA;

typedef DPSP_CLOSEDATA FAR* LPDPSP_CLOSEDATA;

/*
 * DPSP_CREATEGROUPDATA
 */
typedef struct _DPSP_CREATEGROUPDATA 
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CREATEGROUPDATA;

typedef DPSP_CREATEGROUPDATA FAR* LPDPSP_CREATEGROUPDATA;

/*
 * DPSP_CREATEPLAYERDATA
 */
typedef struct _DPSP_CREATEPLAYERDATA
{
    DPID        idPlayer;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CREATEPLAYERDATA;

typedef DPSP_CREATEPLAYERDATA FAR* LPDPSP_CREATEPLAYERDATA;

/*
 * DPSP_DELETEGROUPDATA
 */
typedef struct _DPSP_DELETEGROUPDATA
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEGROUPDATA;

typedef DPSP_DELETEGROUPDATA FAR* LPDPSP_DELETEGROUPDATA;

/*
 * DPSP_DELETEPLAYERDATA
 */
typedef struct _DPSP_DELETEPLAYERDATA
{
    DPID        idPlayer;           //  player being deleted 
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEPLAYERDATA;

typedef DPSP_DELETEPLAYERDATA FAR* LPDPSP_DELETEPLAYERDATA;

/*
 * DPSP_ENUMSESSIONSDATA
 */
typedef struct _DPSP_ENUMSESSIONSDATA
{
    LPVOID      lpMessage;          //  enum message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      //  TRUE to return status on progress of enum
} DPSP_ENUMSESSIONSDATA;                

typedef DPSP_ENUMSESSIONSDATA FAR* LPDPSP_ENUMSESSIONSDATA;

/*
 * DPSP_GETADDRESSDATA
 */
typedef struct _DPSP_GETADDRESSDATA
{ 
    DPID        idPlayer;           // player (or group) to get ADDRESS for 
    DWORD       dwFlags;            // DPLAYI_PLAYER_xxx flags for idPlayer
    LPDPADDRESS lpAddress;          // return buffer for address of idPlayer
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSDATA;

typedef DPSP_GETADDRESSDATA FAR* LPDPSP_GETADDRESSDATA;

/*
 * DPSP_GETADDRESSCHOICESDATA
 */
typedef struct _DPSP_GETADDRESSCHOICESDATA
{ 
    LPDPADDRESS lpAddress;          // return buffer for address choices
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSCHOICESDATA;

typedef DPSP_GETADDRESSCHOICESDATA FAR* LPDPSP_GETADDRESSCHOICESDATA;

/*
 * DPSP_GETCAPSDATA
 */
typedef struct _DPSP_GETCAPSDATA
{ 
    DPID        idPlayer;           //  player to get caps for 
    LPDPCAPS    lpCaps;
    DWORD       dwFlags;            //  DPGETCAPS_xxx 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETCAPSDATA;

typedef DPSP_GETCAPSDATA FAR* LPDPSP_GETCAPSDATA;

/*
 * DPSP_OPENDATA
 */
typedef struct _DPSP_OPENDATA
{ 
    BOOL        bCreate;            // TRUE if creating, FALSE if joining 
    LPVOID      lpSPMessageHeader;  // If we are joining a session, lpSPMessageData 
                                    // is the message data received with the 
                                    // EnumSessionsReply message. If we are creating 
                                    // a session, it will be set to NULL. 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      // TRUE to return status on progress of open
    /*** fields added for DX 6 ***/    
    DWORD		dwOpenFlags;		// flags passed by app to IDirectPlayX->Open(...)
    DWORD		dwSessionFlags;		// flags passed by app in the session desc
} DPSP_OPENDATA;

typedef DPSP_OPENDATA FAR* LPDPSP_OPENDATA;

/*
 * DPSP_REMOVEPLAYERFROMGROUPDATA
 */
typedef struct _DPSP_REMOVEPLAYERFROMGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REMOVEPLAYERFROMGROUPDATA;

typedef DPSP_REMOVEPLAYERFROMGROUPDATA FAR* LPDPSP_REMOVEPLAYERFROMGROUPDATA;

/*
 * DPSP_REPLYDATA
 */
typedef struct _DPSP_REPLYDATA
{			  
    LPVOID      lpSPMessageHeader;  //  header that was received by dplay 
                                    // (with the message we're replying to) 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    DPID        idNameServer;       //  player id of nameserver 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REPLYDATA;               

typedef DPSP_REPLYDATA FAR* LPDPSP_REPLYDATA;

/*
 * DPSP_SENDDATA
 */
typedef struct _DPSP_SENDDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDDATA;

typedef DPSP_SENDDATA FAR* LPDPSP_SENDDATA;

/*
 * DPSP_SENDTOGROUPDATA
 */
typedef struct _DPSP_SENDTOGROUPDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDTOGROUPDATA;

typedef DPSP_SENDTOGROUPDATA FAR* LPDPSP_SENDTOGROUPDATA;

/*
 * DPSP_SENDEXDATA
 */
typedef struct _DPSP_SENDEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    
} DPSP_SENDEXDATA;

typedef DPSP_SENDEXDATA FAR* LPDPSP_SENDEXDATA;


/*
 * DPSP_SENDTOGROUPEXDATA
 */
typedef struct _DPSP_SENDTOGROUPEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.

} DPSP_SENDTOGROUPEXDATA;

typedef DPSP_SENDTOGROUPEXDATA FAR* LPDPSP_SENDTOGROUPEXDATA;

/*
 * DPSP_GETMESSAGEQUEUE
 */
typedef struct _DPSP_GETMESSAGEQUEUEDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;
	DPID            idFrom;			
	DPID            idTo;
	LPDWORD         lpdwNumMsgs;
	LPDWORD         lpdwNumBytes;

} DPSP_GETMESSAGEQUEUEDATA;

typedef DPSP_GETMESSAGEQUEUEDATA FAR* LPDPSP_GETMESSAGEQUEUEDATA;

/*
 * DPSP_CANCELSEND
 */
 
#define DPCANCELSEND_PRIORITY		0x00000001
#define DPCANCELSEND_ALL            0x00000002

typedef struct _DPSP_CANCELDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;        // 0,DPCANCELSEND_PRIORITY,DPCANCELSEND_ALL,etc.
	LPRGLPVOID      lprglpvSPMsgID; // cancel just these messages      (dwFlags == 0)
	DWORD           cSPMsgID;       // number of message id's in array (dwFlags == 0)
	DWORD           dwMinPriority;  // cancel all sends at this priority (dwFlags==DPCANCELSEND_PRIORITY)
	DWORD           dwMaxPriority;  // cancel all sends between Min and Max.
	
} DPSP_CANCELDATA;

typedef DPSP_CANCELDATA FAR* LPDPSP_CANCELDATA;

/*
 * DPSP_SHUTDOWNDATA - used with ShutdownEx
 */
typedef struct _DPSP_SHUTDOWNDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SHUTDOWNDATA;

typedef DPSP_SHUTDOWNDATA FAR* LPDPSP_SHUTDOWNDATA;

//@@BEGIN_MSINTERNAL
#ifdef BIGMESSAGEDEFENSE
/*
 * DPSP_MSGTOOBIG - used with HandleSPNotification (DPSPWARN_MESSAGETOOBIG)
 */
typedef struct _DPSP_MSGTOOBIG
{
	DWORD	dwType;
	LPBYTE 	pReceiveBuffer;	// --> pointer to the message data
	DWORD 	dwBytesReceived;// --> the number of bytes of the message actually received
	DWORD 	dwMessageSize;	// --> the size of the message as understood by the SP
} DPSP_MSGTOOBIG;

typedef DPSP_MSGTOOBIG FAR* LPDPSP_MSGTOOBIG;

/*
 * DPSP_PLAYERDEAD - used with HandleSPNotification (DPSPWARN_PLAYERDEAD)
 */
typedef struct _DPSP_PLAYERDISCONNECT
{
	DWORD	dwType;
	DPID	dwID;		// ID of the Sys player that has been disconnected
} DPSP_PLAYERDEAD;

typedef DPSP_PLAYERDEAD FAR* LPDPSP_PLAYERDEAD;
#endif
//@@END_MSINTERNAL

/*
 * Prototypes for callbacks returned by SPInit.
 */
typedef HRESULT   (WINAPI *LPDPSP_CREATEPLAYER)(LPDPSP_CREATEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEPLAYER)(LPDPSP_DELETEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_SEND)(LPDPSP_SENDDATA);
typedef HRESULT   (WINAPI *LPDPSP_ENUMSESSIONS)(LPDPSP_ENUMSESSIONSDATA);
typedef HRESULT   (WINAPI *LPDPSP_REPLY)(LPDPSP_REPLYDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWN)(void);
typedef HRESULT   (WINAPI *LPDPSP_CREATEGROUP)(LPDPSP_CREATEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEGROUP)(LPDPSP_DELETEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_ADDPLAYERTOGROUP)(LPDPSP_ADDPLAYERTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_REMOVEPLAYERFROMGROUP)(LPDPSP_REMOVEPLAYERFROMGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETCAPS)(LPDPSP_GETCAPSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESS)(LPDPSP_GETADDRESSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESSCHOICES)(LPDPSP_GETADDRESSCHOICESDATA);
typedef HRESULT   (WINAPI *LPDPSP_OPEN)(LPDPSP_OPENDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSE)(void);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUP)(LPDPSP_SENDTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWNEX)(LPDPSP_SHUTDOWNDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSEEX)(LPDPSP_CLOSEDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDEX)(LPDPSP_SENDEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUPEX)(LPDPSP_SENDTOGROUPEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_CANCEL)(LPDPSP_CANCELDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETMESSAGEQUEUE)(LPDPSP_GETMESSAGEQUEUEDATA);

/*
 * DPSP_SPCALLBACKS
 *
 * Table of callback pointers passed to SPInit. The service provider should fill
 * in the functions it implements. If the service provider does not implement
 * a callback, it should not set the table value for the unimplemented callback.
 */
typedef struct _DPSP_SPCALLBACKS
{
    DWORD                       dwSize;             //  size of table 
    DWORD                       dwVersion;			// 	the DPSP_MAJORVERSION of this DPLAY object
													// 	for DX3, this was 0. 
    LPDPSP_ENUMSESSIONS         EnumSessions;       //  required 
    LPDPSP_REPLY                Reply;              //  required 
    LPDPSP_SEND                 Send;               //  required 
    LPDPSP_ADDPLAYERTOGROUP     AddPlayerToGroup;   //  optional 
    LPDPSP_CLOSE                Close;              //  optional - for DX3 compat only
    LPDPSP_CREATEGROUP          CreateGroup;        //  optional 
    LPDPSP_CREATEPLAYER         CreatePlayer;       //  optional 
    LPDPSP_DELETEGROUP          DeleteGroup;        //  optional 
    LPDPSP_DELETEPLAYER         DeletePlayer;       //  optional 
    LPDPSP_GETADDRESS           GetAddress;         //  optional 
    LPDPSP_GETCAPS              GetCaps;            //  required 
    LPDPSP_OPEN                 Open;               //  optional 
    LPDPSP_REMOVEPLAYERFROMGROUP RemovePlayerFromGroup; //  optional 
    LPDPSP_SENDTOGROUP          SendToGroup;        //  optional 
    LPDPSP_SHUTDOWN             Shutdown;           //  optional - for DX3 compat only
    /*** fields added for DX 5 ***/
    LPDPSP_CLOSEEX	            CloseEx;			//  optional 
    LPDPSP_SHUTDOWNEX			ShutdownEx;			//  optional 
    LPDPSP_GETADDRESSCHOICES	GetAddressChoices;	//  optional 
	/*** fields added for DX 6 ***/
    /*** for async ***/
    LPDPSP_SENDEX               SendEx;             //  optional - required for async
    LPDPSP_SENDTOGROUPEX        SendToGroupEx;      //  optional - optional for async
    LPDPSP_CANCEL               Cancel;             //  optional - optional for async, highly recommended
    LPDPSP_GETMESSAGEQUEUE      GetMessageQueue;    //  optional - optional for async, highly recommended
} DPSP_SPCALLBACKS;             

typedef DPSP_SPCALLBACKS FAR *LPDPSP_SPCALLBACKS;

/*
 * SPINITDATA
 *
 * Data structure passed to the service provider at SPInit.
 */
typedef struct _SPINITDATA 
{
    LPDPSP_SPCALLBACKS  lpCB;               //  service provider fills in entry points 
    IDirectPlaySP      	* lpISP;            //  used to call back into DirectPlay 
                                            // (e.g. when message is received) 
    LPWSTR              lpszName;           //  service provider name from registry 
    LPGUID              lpGuid;             //  service provider GUID from registry 
    DWORD               dwReserved1;        //  service provider-specific data from registry 
    DWORD               dwReserved2;        //  service provider-specific data from registry 
    DWORD               dwSPHeaderSize;     //  dwSPHeaderSize is the size of the 
                                            //  data the sp wants stored with each message.
                                            //  DirectPlay will allocate dwSPHeaderSize 
                                            //  bytes at the beginning of each message.
                                            //  The service provider can then do what 
                                            //  they want with these. 
    LPDPADDRESS         lpAddress;          //  address to use for connection
    DWORD               dwAddressSize;      //  size of address data
    DWORD               dwSPVersion;        //  version number 16 | 16 , major | minor version 
} SPINITDATA;

typedef SPINITDATA FAR* LPSPINITDATA;

/*
 * SPInit
 *
 * DirectPlay calls this function to initialize the service provider.
 * All service providers must export this entry point from their DLL.
 */
typedef HRESULT (WINAPI *LPDPSP_SPINIT)(LPSPINITDATA);

HRESULT WINAPI SPInit(LPSPINITDATA);

/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the service
 * provider, the server provider should statically link to DPLAYX.LIB and
 * increment this global during the SPINIT call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


/*@@BEGIN_MSINTERNAL */
/*
 *	All of the following entries are part of the voice support that was
 *	removed from dplay before DX6.  It is currently still part of the
 *	code base and is just #ifdef'd out.
 */
#ifdef DPLAY_VOICE_SUPPORT
	/*
	 *	Player was created on a system that has voice capability
	 *
	 * INTERNAL USE ONLY
	 * THIS ENTRY SHOULD BE SURROUNDED BY MSINTERNALS!!!!!
	 */
	#define DPLAYI_PLAYER_HASVOICE			0x00001000

	/*
	 * DPSP_CLOSEVOICEDATA - used with CloseVoice
	 */
	typedef struct _DPSP_CLOSEVOICEDATA
	{
		IDirectPlaySP * lpISP;
		DWORD			dwFlags;
	} DPSP_CLOSEVOICEDATA;
	typedef DPSP_CLOSEVOICEDATA FAR* LPDPSP_CLOSEVOICEDATA;

	/*
	 * DPSP_OPENVOICEDATA - used with OpenVoice
	 */
	typedef struct _DPSP_OPENVOICEDATA
	{
		IDirectPlaySP * lpISP;
		DWORD			dwFlags;
		DPID			idTo;
		DPID			idFrom;
		BOOL			bToPlayer; // TRUE if idTo is a Player
	} DPSP_OPENVOICEDATA;
	typedef DPSP_OPENVOICEDATA FAR* LPDPSP_OPENVOICEDATA;

	typedef HRESULT   (WINAPI *LPDPSP_CLOSEVOICE)(LPDPSP_CLOSEVOICEDATA);
	typedef HRESULT   (WINAPI *LPDPSP_OPENVOICE)(LPDPSP_OPENVOICEDATA);

	// From interface declaration
	LPDPSP_CLOSEVOICE           CloseVoice;         //  optional 
	LPDPSP_OPENVOICE            OpenVoice;          //  optional 

#endif // DPLAY_VOICE_SUPPORT
/*@@END_MSINTERNAL */

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpmess.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpmessage.h
 *  Content:	DirectPlay message structures
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	2/10/96	andyco	created it
 *	3/15/96	andyco	added macros for manipulating messages (e.g. GET_MESSAGE_SIZE)
 *	4/21/96	andyco	added dwresreved3
 *	4/25/96	andyco	got rid of dwreservedx. spblob follows message. blobsize
 *					is lpdplayi_dplay->dwSPHeaderSize
 *	5/29/96 andyco	added playerdata
 *	6/22/96 andyco	added enumrequest,enumreply structs
 *	6/22/96	andyco	added groupidrequest, so server can refuse new players
 *	6/24/96	kipo	changed guidGame to guidApplication.
 *	7/31/96	andyco	added ping,pingreply
 *	8/6/96	andyco	added version stuff.  dwCmd->dwCmdToken. added offset
 *					to all packed fields (so we can change struct size w/o
 *					breaking compat).
 *	8/22/96	andyco	added playerwrapper
 * 10/11/96 sohailm added struct _MSG_SESSIONDESC and constant DPSP_MSG_SESSIONDESCCHANGED
 * 01/17/97 sohailm added struct _MSG_REQUESTPLAYERID.
 * 03/12/97 sohailm added new security related messages, MSG_SIGNED and MSG_AUTHENTICATION 
 *                  structs, DPSP_HEADER_LOCALMSG(constant), and dwSecurityPackageNameOffset 
 *                  field to PLAYERIDREPLY.
 * 03/24/97 sohailm added DPSP_MSG_DX5VERSION, DPSP_MSG_ADDFORWARDREPLY, and struct MSG_ADDFORWARDREPLY
 * 03/25/97 sohailm DPSP_MSG_DX5VERSION and DPSP_MSG_VERSION set to 4
 * 4/11/97	andyco	ask4multicast
 * 04/14/97 sohailm renamed structure MSG_SIGNED to MSG_SECURE, as we use the same structure for
 *                  both signing and encryption.
 *	4/20/97	andyco	group in group
 *	5/8/97	andyco	removed update list message
 *	5/8/97	myronth	StartSession
 * 05/12/97 sohailm Added DPSP_MSG_KEYEXCHANGE and DPSP_MSG_KEYEXCHANGEREPLY.
 *                  Added securitydesc, dwSSPIProviderOffset, and dwCAPIProviderOffset members
 *                   to MSG_PLAYERIDREPLY structure.
 *                  Added MSG_ACCESSGRANTED and MSG_KEYEXCHANGE structures.
 * 05/12/97 sohailm Bumped DPSP_MSG_DX5VERSION and DPSP_MSG_VERSION to 6
 *	5/17/97	myronth	SendChatMessage
 * 06/09/97 sohailm Renamed DPSP_MSG_ACCESSDENIED to DPSP_MSG_LOGONDENIED.
 * 06/16/97 sohailm Added struct MSG_AUTHERROR.
 * 06/23/97 sohailm Added dwFlags to DPMSG_SECURE. Removed DPSP_MSG_ENCRYPTED.
 * 8/5/97	andyco	async addforward
 *	10/29/97myronth	Added MSG_GROUPOWNERCHANGED
 *	1/5/97	myronth	Added DX5A and DX6 message versions and added an hresult
 *					to MSG_PLAYERIDREPLY (#15891)
 *	1/20/98	myronth	#ifdef'd out voice support
 *
 ***************************************************************************/


#ifndef __DPMESS_INCLUDED__
#define __DPMESS_INCLUDED__

// DPMESSAGES are send across the wire like other messages, their identifying mark is 
// that they begin with a special signature ('p','l','a','y') followed by a 2 byte
// little endian message id and then a 2 byte version number.

// The dplay reliable protocol violates this rule to save header bytes.  After the
// 'play' is a single 0xff byte which identifies the protocol.  In order to avoid
// ambiguity, no regular protocol message number may end in 0xff, i.e. 255,511, etc... 

// NOTE: NO MESSAGE NUMBER IS ALLOWED TO HAVE 0xFF IN THE LOW BYTE <<<LOOK HERE!!!!>>>
// this # goes in the top 16 bits of every dplay command
#define DPSP_MSG_DX3VERSION				1 // dx3
#define DPSP_MSG_AUTONAMETABLE          4 // the version in which client expects nametable
										  // to be sent on addforward	
#define DPSP_MSG_GROUPINGROUP           5 // the version we added group in group
#define DPSP_MSG_SESSIONNAMETABLE		7 // the version we send the session desc w/ enumplayersreply
#define DPSP_MSG_DX5VERSION             7 // dx5

#define DPSP_MSG_ASYNCADDFORWARD        8 // addforward requires an ack 
#define DPSP_MSG_DX5AVERSION			8 // dx5a
#define DPSP_MSG_RELIABLEVERSION        9 // introduced the reliable protocol
#define DPSP_MSG_DX6VERSION				9 // dx6
#define DPSP_MSG_DX61VERSION           10 // dx6.1
#define DPSP_MSG_DX61AVERSION          11 // dx6.1a
#define DPSP_MSG_VERSION			   11 // current

// these are the headers that go in the dwCmd field of the message
#define DPSP_MSG_ENUMSESSIONSREPLY 		1
#define DPSP_MSG_ENUMSESSIONS 			2
#define DPSP_MSG_ENUMPLAYERSREPLY 		3
#define DPSP_MSG_ENUMPLAYER 			4
#define DPSP_MSG_REQUESTPLAYERID		5
// there's a requestgroupid, since the server can turn down new players
// (based on dwmaxplayers) but not groups
#define DPSP_MSG_REQUESTGROUPID			6
// used for group + player
#define DPSP_MSG_REQUESTPLAYERREPLY		7
#define DPSP_MSG_CREATEPLAYER			8
#define DPSP_MSG_CREATEGROUP			9
#define DPSP_MSG_PLAYERMESSAGE			10
#define DPSP_MSG_DELETEPLAYER			11
#define DPSP_MSG_DELETEGROUP			12
#define DPSP_MSG_ADDPLAYERTOGROUP		13
#define DPSP_MSG_DELETEPLAYERFROMGROUP	14
#define DPSP_MSG_PLAYERDATACHANGED		15
#define DPSP_MSG_PLAYERNAMECHANGED		16
#define DPSP_MSG_GROUPDATACHANGED		17
#define DPSP_MSG_GROUPNAMECHANGED		18
#define DPSP_MSG_ADDFORWARDREQUEST		19
#define DPSP_MSG_NAMESERVER				20
#define DPSP_MSG_PACKET					21
#define DPSP_MSG_PING					22
#define DPSP_MSG_PINGREPLY				23
#define DPSP_MSG_YOUAREDEAD				24
#define DPSP_MSG_PLAYERWRAPPER			25
#define DPSP_MSG_SESSIONDESCCHANGED     26
#define DPSP_MSG_UPDATELIST				27
#define DPSP_MSG_CHALLENGE              28 
#define DPSP_MSG_ACCESSGRANTED          29
#define DPSP_MSG_LOGONDENIED            30
#define DPSP_MSG_AUTHERROR              31
#define DPSP_MSG_NEGOTIATE              32
#define DPSP_MSG_CHALLENGERESPONSE      33
#define DPSP_MSG_SIGNED                 34
#define DPSP_MSG_UNUSED1                35
#define DPSP_MSG_ADDFORWARDREPLY        36 
#define DPSP_MSG_ASK4MULTICAST			37
#define DPSP_MSG_ASK4MULTICASTGUARANTEED 38
#define DPSP_MSG_ADDSHORTCUTTOGROUP 	39
#define DPSP_MSG_DELETEGROUPFROMGROUP	40
#define DPSP_MSG_SUPERENUMPLAYERSREPLY 	41
#define DPSP_MSG_STARTSESSION			42
#define DPSP_MSG_KEYEXCHANGE            43
#define DPSP_MSG_KEYEXCHANGEREPLY       44
#define DPSP_MSG_CHAT					45
#define DPSP_MSG_ADDFORWARD				46
#define DPSP_MSG_ADDFORWARDACK			47
#define DPSP_MSG_PACKET2_DATA           48
#define DPSP_MSG_PACKET2_ACK            49
#define DPSP_MSG_GROUPOWNERCHANGED		50
#ifdef DPLAY_VOICE_SUPPORT
#define DPSP_MSG_VOICEOPEN				51
#define DPSP_MSG_VOICECLOSE				52
#endif // DPLAY_VOICE_SUPPORT
#define DPSP_MSG_IAMNAMESERVER          53

#define DPSP_MSG_DIEPIGGY				0x666
#define DPSP_MSG_PROTOCOL               0xFF		// See note above (LOOK HERE).

// flag for requesting async send on SendPlayerManagement Messages
#define DPSP_MSG_ASYNC					0x80000000

// if you are adding a new message that can be sent unsigned,
// add it to PermitMessage() in dpsecure.c

// MSG_HDR indicates a dplay system message
#define MSG_HDR 0x79616c70

#define IS_VALID_DPLAY_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )

#define IS_PLAYER_MESSAGE(pMsg) (!IS_VALID_DPLAY_MESSAGE(pMsg))

// calculate size for message + header
#define GET_MESSAGE_SIZE(this,MSG) (this->dwSPHeaderSize + sizeof(MSG))

#define COMMAND_MASK 0X0000FFFF
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)
#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )

#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
	| (DPSP_MSG_VERSION<<16)) )

// This constant is used to indicate that a message is for a local player
#define DPSP_HEADER_LOCALMSG ((LPVOID)0xFFFFFFFF)

// dplay internal messages below. 
typedef struct _MSG_SYSMESSAGE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;	
} MSG_SYSMESSAGE,*LPMSG_SYSMESSAGE;

// for sending out the player blob
typedef struct _MSG_PLAYERDATA
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo;		// id of destination player
    DWORD dwPlayerID; 	// id of player whose data is being set
    DWORD dwDataSize;
	DWORD dwDataOffset; // offset (in bytes) of data (so we don't hardcode struct size) 
						// from beginning of message
	// data follows    	
} MSG_PLAYERDATA,*LPMSG_PLAYERDATA;

// sent when player name changes
typedef struct _MSG_PLAYERNAME
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo;		// id of destination player
    DWORD dwPlayerID; 	// id of player whose data is being set
	DWORD dwShortOffset; // offset (in bytes) of short name from beginning of message.  
						// 0 means null short name.
	DWORD dwLongOffset;	// offset (in bytes) of long name from beginning of message.
						// 0 means null long name.
	// strings follow 
} MSG_PLAYERNAME,*LPMSG_PLAYERNAME;

// create player / group, delete player/group
typedef struct _MSG_PLAYERMGMTMESSAGE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo; // player message is being sent to
    DWORD dwPlayerID; // player id effected
	DWORD dwGroupID; // group id effected
	DWORD dwCreateOffset; 	// offset of player / group creation stuff from beginning 
							// of message
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwPasswordOffset; // offset of session password
	// if it's an addplayer, the player data will follow this message
    // if it's an addforward, session password will follow the player data
} MSG_PLAYERMGMTMESSAGE,*LPMSG_PLAYERMGMTMESSAGE;

// sent by name srvr w/ session desc
typedef struct _MSG_ENUMSESSIONS
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	GUID  guidApplication;
	DWORD dwPasswordOffset;	// offset (in bytes) of password from beginning of message.
							// 0 means null password.
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwFlags;          // enum session flags passed in by the app
} MSG_ENUMSESSIONS,*LPMSG_ENUMSESSIONS;

// sent to nameserver
typedef struct _MSG_ENUMSESSIONSREPLY
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DPSESSIONDESC2 dpDesc; 
	DWORD dwNameOffset;	// offset (in bytes) of session name from beginning of message.
					   	// 0 means null session name.
} MSG_ENUMSESSIONSREPLY,*LPMSG_ENUMSESSIONSREPLY;


// sent by namesrvr w/ list of all players and groups in session
typedef struct _MSG_ENUMPLAYERREPLY
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD nPlayers; //  # players we actually got
	DWORD nGroups; // # of groups we got
	DWORD dwPackedOffset; // offset (in bytes) of packed player structs from beginning of message
	// added for DX5
	DWORD nShortcuts; // # of groups w/ shortcuts
	DWORD dwDescOffset; // offset (in bytes) of session desc from beginning of message
						// always > 0
	DWORD dwNameOffset;	// offset (in bytes) of session name from beginning of message.
					   	// 0 means null session name.
	DWORD dwPasswordOffset; // offset (in bytes) of session password from beginning of message.
					   	// 0 means null session name.
	// session name + password follow
    // player data will follow session name + password in reply buffer
	// group data follows players. see pack.c
} MSG_ENUMPLAYERSREPLY,*LPMSG_ENUMPLAYERSREPLY;

// sent to nameserver to request a player id
typedef struct _MSG_REQUESTPLAYERID
{
    DWORD dwHeader; 
    DWORD dwCmdToken;	
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwFlags;      // player flags (system/applicaton player)
} MSG_REQUESTPLAYERID,*LPMSG_REQUESTPLAYERID;

// sent by name srvr w/ new player id
typedef struct _MSG_PLAYERIDREPLY
{
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwID; //  the new id
	// the following fields are only available in
	// DX5 or later versions
	DPSECURITYDESC dpSecDesc;   // security description - populated only if server is secure.
    DWORD dwSSPIProviderOffset; // offset (in bytes) of sspi provider name from beginning of message.
					   			// 0 means null provider name.
    DWORD dwCAPIProviderOffset; // offset (in bytes) of capi provider name from beginning of message.
					   			// 0 means null provider name.
    HRESULT hr; // return code used in DX6 and after
	// provider name strings follow
}MSG_PLAYERIDREPLY,*LPMSG_PLAYERIDREPLY;

// a player to player message
typedef struct _MSG_PLAYERMESSAGE
{
	DPID idFrom,idTo;
} MSG_PLAYERMESSAGE,*LPMSG_PLAYERMESSAGE;

typedef struct _MSG_PACKET
{
	DWORD dwHeader;
	DWORD dwCmdToken;
	GUID  guidMessage; // id of the message this packet belongs to
	DWORD dwPacketID; // this packet is # x of N
	DWORD dwDataSize; // total size of the data in this packet
					  // data follows MSG_PACKET struct
	DWORD dwOffset; // offset into reconstructed buffer for this packet
	DWORD dwTotalPackets; // total # of packets (N)
	DWORD dwMessageSize; // size of buffer to alloc at other end
	DWORD dwPackedOffset; // offset into this message of the actual packet data
						  // so we don't hardcode for struct sizes
} MSG_PACKET,*LPMSG_PACKET;	

typedef struct _MSG_PACKET_ACK
{
	DWORD dwHeader;
	DWORD dwCmdToken;
	GUID  guidMessage; // id of the message this packet belongs to
	DWORD dwPacketID;  // ACK packet is # x of N
} MSG_PACKET_ACK,*LPMSG_PACKET_ACK;	

typedef struct _MSG_PACKET     MSG_PACKET2,     *LPMSG_PACKET2;
typedef struct _MSG_PACKET_ACK MSG_PACKET2_ACK, *LPMSG_PACKET2_ACK;

// sent by name srvr w/ new player id
typedef struct _MSG_PING
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDFrom; //  the player who sent the ping
	DWORD dwTickCount; // tick count on message sending ping	
} MSG_PING,*LPMSG_PING;

// for sending out the session desc
typedef struct _MSG_SESSIONDESC
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDTo;
    DWORD dwSessionNameOffset;  // offsets of strings in the message
    DWORD dwPasswordOffset;     // so we don't hardcode for struct sizes
    DPSESSIONDESC2 dpDesc;
    // session name and password strings follow
} MSG_SESSIONDESC,*LPMSG_SESSIONDESC;


#define DPSECURE_SIGNEDBYSSPI			0x00000001
#define DPSECURE_SIGNEDBYCAPI			0x00000002
#define DPSECURE_ENCRYPTEDBYCAPI		0x00000004

// for sending signed messages
typedef struct _MSG_SECURE {
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDFrom;             // sender's system player id
    DWORD dwDataOffset;         // offset of dplay message
    DWORD dwDataSize;           // size of message
    DWORD dwSignatureSize;      // size of signature
	DWORD dwFlags;              // describes the contents
    // data and signature follow
} MSG_SECURE, *LPMSG_SECURE;

// authentication messages (negotiate, challenge, response, etc)
typedef struct _MSG_AUTHENTICATION {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwIDFrom;             // sender's system player id
    DWORD dwDataSize;           // size of opaque buffer
    DWORD dwDataOffset;         // offset of buffer
    // opaque buffer follows
} MSG_AUTHENTICATION, *LPMSG_AUTHENTICATION;

// for sending an error response to addforward (DX5)
// this message is sent by the nameserver to a client when addforward fails
typedef struct _MSG_ADDFORWARDREPLY {
    DWORD dwHeader;
    DWORD dwCmdToken;
    HRESULT hResult;            // indicates why addforward failed
} MSG_ADDFORWARDREPLY, *LPMSG_ADDFORWARDREPLY;

// message sent to the server when we want him to multicast for us
typedef struct _MSG_ASK4MULTICAST {
    DWORD dwHeader;
    DWORD dwCmdToken;
	DPID  idGroupTo;
	DPID  idPlayerFrom;
	DWORD dwMessageOffset;
} MSG_ASK4MULTICAST, *LPMSG_ASK4MULTICAST;

typedef struct _MSG_STARTSESSION {
    DWORD dwHeader;
    DWORD dwCmdToken;
	DWORD dwConnOffset;
} MSG_STARTSESSION, *LPMSG_STARTSESSION;

typedef struct _MSG_ACCESSGRANTED {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwPublicKeySize;      // sender's public key blob size
    DWORD dwPublicKeyOffset;    // sender's public key
} MSG_ACCESSGRANTED, *LPMSG_ACCESSGRANTED;

typedef struct _MSG_KEYEXCHANGE {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwSessionKeySize;
    DWORD dwSessionKeyOffset;
    DWORD dwPublicKeySize;
    DWORD dwPublicKeyOffset;
} MSG_KEYEXCHANGE, *LPMSG_KEYEXCHANGE;

// chat message
typedef struct _MSG_CHAT
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDFrom;		// id of sending player
	DWORD dwIDTo;		// id of destination player
	DWORD dwFlags;		// DPCHAT flags
	DWORD dwMessageOffset; // offset (in bytes) of chat message from beginning of message.  
						// 0 means null message.
	// strings follow 
} MSG_CHAT,*LPMSG_CHAT;

// for sending an error response to an authentication message (DX5)
// this message is sent by the nameserver to a client when an authentication error occurs
typedef struct _MSG_AUTHERROR {
    DWORD dwHeader;
    DWORD dwCmdToken;
    HRESULT hResult;            // indicates why authentication failed
} MSG_AUTHERROR, *LPMSG_AUTHERROR;

// acks an addforward message
typedef struct _MSG_ADDFORWARDACK{
    DWORD dwHeader;
    DWORD dwCmdToken;
	DWORD dwID; // id that the addforward was sent for
} MSG_ADDFORWARDACK, *LPMSG_ADDFORWARDACK;

// group owner changed message
typedef struct _MSG_GROUPOWNERCHANGED
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDGroup;
	DWORD dwIDNewOwner;
	DWORD dwIDOldOwner;
} MSG_GROUPOWNERCHANGED,*LPMSG_GROUPOWNERCHANGED;

// Notification from the new name server to flip the
// necessary bits to make the nameserver bit true on 
// that player.
typedef struct _MSG_IAMNAMESERVER
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDTo; 		// req'd field for system messages.
	DWORD dwIDHost;     // id of the host
	DWORD dwFlags;		// new host flags 
	DWORD dwSPDataSize; // length of contiguous following SP data field.
	CHAR  SPData[];
} MSG_IAMNAMESERVER,*LPMSG_IAMNAMESERVER;

// NOTE: we really only need the "To" address on the first packet of a message.
//       since most messages though are 1 packet, this is easier. On large messages
//       the extra 2 bytes per packet doesn't hurt.

#pragma pack(push,1)

// Message protocol header is variable using bit extension.  The first field
// is the from id, the second is the to id.  They can each be up to 3 bytes.
// This prototype allows allocators to calculate the worst case.
typedef struct _MSG_PROTOCOL {
	UCHAR   ToFromIds[6];		
} MSG_PROTOCOL, *LPMSG_PROTOCOL;

#pragma pack(pop)
// see protocol.h for the rest of the protocol header


#ifdef DPLAY_VOICE_SUPPORT
// voice open  / close
typedef struct _MSG_VOICE
{
    DWORD dwHeader; 	
    DWORD dwCmdToken;	
	DWORD dwIDFrom; 
	DWORD dwIDTo; 
} MSG_VOICE,*LPMSG_VOICE;
#endif // DPLAY_VOICE_SUPPORT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpos.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpos.h
 *  Content:	Function prototypes for OS wrapper functions
 *  History:
 *	Date	By		Reason
 *	====	==		======
 *	6/19/96	myronth	created it
 *	6/19/96	kipo	changed the interface to GetString() to return an HRESULT
 *	6/20/96 andyco	changed the interface to GetAnsiString() to return an HRESULT
 *	12/2/97	myronth	Added OS_RegDeleteKey function
 *	1/20/98	myronth	Moved PRV_SendStandardSystemMessage to dplobbyi.h
***************************************************************************/
#ifndef __DPOS_INCLUDED__
#define __DPOS_INCLUDED__

BOOL OS_IsPlatformUnicode(void);
BOOL OS_IsValidHandle(HANDLE handle);
HRESULT OS_CreateGuid(LPGUID pGuid);
int OS_StrLen(LPCWSTR lpwStr);
int OS_StrCmp(LPCWSTR lpwStr1, LPCWSTR lpwStr2);
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
HRESULT GetWideStringFromAnsi(LPWSTR * ppszWide,LPSTR pszAnsi);
HRESULT GetAnsiString(LPSTR * ppszAnsi,LPWSTR pszWide);
HRESULT GetString(LPWSTR * ppszDest,LPWSTR pszSrc);
HINSTANCE OS_LoadLibrary(LPWSTR pszWFileName);
FARPROC OS_GetProcAddress(HMODULE  hModule,LPSTR lpProcName);
HANDLE OS_CreateEvent(LPSECURITY_ATTRIBUTES lpSA, BOOL bManualReset,
						BOOL InitialState, LPWSTR lpName);
HANDLE OS_CreateMutex(LPSECURITY_ATTRIBUTES lpSA, BOOL bInitialOwner,
						LPWSTR lpName);
HANDLE OS_OpenEvent(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
HANDLE OS_OpenMutex(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
HANDLE OS_CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpSA,
							DWORD dwProtect, DWORD dwMaxSizeHigh,
							DWORD dwMaxSizeLow, LPWSTR lpName);
HANDLE OS_OpenFileMapping(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
BOOL OS_CreateProcess(LPWSTR lpwszAppName, LPWSTR lpwszCmdLine,
		LPSECURITY_ATTRIBUTES lpSAProcess, LPSECURITY_ATTRIBUTES lpSAThread,
		BOOL bInheritFlags, DWORD dwCreationFlags, LPVOID lpEnv,
		LPWSTR lpwszCurDir, LPSTARTUPINFO lpSI, LPPROCESS_INFORMATION lpPI);
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid);
HRESULT StringFromGUID(LPGUID lpGuid, LPWSTR lpwszGuid, DWORD dwBufferSize);
HRESULT AnsiStringFromGUID(LPGUID lpg, LPSTR lpszGuid, DWORD dwBufferSize);
LONG OS_RegOpenKeyEx(HKEY hKey,LPWSTR pvKeyStr,DWORD dwReserved,REGSAM samDesired,PHKEY phkResult);	
LONG OS_RegQueryValueEx(HKEY hKey,LPWSTR lpszValueName,LPDWORD lpdwReserved,
	LPDWORD lpdwType,LPBYTE lpbData,LPDWORD lpcbData);	
LONG OS_RegEnumKeyEx( HKEY hKey,DWORD iSubkey,LPWSTR lpszName,LPDWORD lpcchName,LPDWORD lpdwReserved,
	LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite );
long OS_RegSetValueEx(HKEY hKey, LPWSTR lpszValueName, DWORD dwReserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
long OS_RegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData);
long OS_RegDeleteValue(HKEY hKey, LPWSTR lpszValueName);
long OS_RegCreateKeyEx(HKEY hKey, LPWSTR lpszSubKey, DWORD dwReserved, LPWSTR lpszClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
long OS_RegDeleteKey(HKEY hKey, LPWSTR lpszKeyName);
DWORD OS_GetCurrentDirectory(DWORD dwSize, LPWSTR lpBuffer);
int OS_CompareString(LCID Locale, DWORD dwCmpFlags, LPWSTR lpwsz1,
		int cchCount1, LPWSTR lpwsz2, int cchCount2);
LPWSTR OS_StrStr(LPWSTR lpwsz1, LPWSTR lpwsz2);


#endif // __DPOS_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpos.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpos.c
 *  Content:	DirectPlay OS functions, and misc utils.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  5/7/96	andyco	created it
 *	6/19/96	kipo	changed the interface to GetString() to return an HRESULT
 *	6/20/96	andyco	changed the interface to GetAnsiString() to return an HRESULT
 *  6/30/96 dereks  Added OS_RegSetValueEx(), OS_RegEnumValue(),
 *                  OS_RegDeleteValue(), OS_RegCreateKeyEx()
 *  7/3/96	andyco	GetAnsiString puts terminating NULL on string
 *	8/16/96	andyco	check for null strings on ansitowide and widetoansi
 *	12/11/96myronth	Fixed bug #4993
 *	3/31/97	myronth	Fixed DPF spew for getting shared buffer -- set it to 8
 *	8/22/97	myronth	Fixed OS_CreateGuid to use SUCCEEDED macro & return a
 *					valid hresult in the failure case (#10949)
 *	12/2/97	myronth	Added OS_RegDeleteKey function
 *	1/26/98	myronth	Added OS_CompareString function
 *  6/25/99 aarono  B#24853 Unregister application not working because GUID
 *                  matching not working for GUID that don't have msb set
 *                  in the first GUID component.  Added padding before check.
 *  7/9/99  aarono  Cleaning up GetLastError misuse, must call right away,
 *                  before calling anything else, including DPF.
 ****************************************************************************/
// note - these are not general purpose routines.  they are designed specifically
// for use with the file api.c, and they may not support all functionality of the
// function they are abstracting!

#include "dplaypr.h"
#include "rpc.h"

#undef DPF_MODNAME
#define DPF_MODNAME "OS_"

BOOL OS_IsPlatformUnicode()
{
	OSVERSIONINFOA	ver;
	BOOL			bReturn = FALSE;


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Just always call the ANSI function
	if(!GetVersionExA(&ver))
	{
		DPF_ERR("Unable to determinte platform -- setting flag to ANSI");
		bReturn = FALSE;
	}
	else
	{
		switch(ver.dwPlatformId)
		{
			case VER_PLATFORM_WIN32_WINDOWS:
				DPF(0, "Platform detected as non-NT -- setting flag to ANSI");
				bReturn = FALSE;
				break;

			case VER_PLATFORM_WIN32_NT:
				DPF(0, "Platform detected as NT -- setting flag to Unicode");
				bReturn = TRUE;
				break;

			default:
				DPF_ERR("Unable to determine platform -- setting flag to ANSI");
				bReturn = FALSE;
				break;
		}
	}

	// Keep the compiler happy
	return bReturn;

}  // OS_IsUnicodePlatform


BOOL OS_IsValidHandle(HANDLE handle)
{
	HANDLE	hTemp;
	DWORD	dwError;


	// Validate the handle by calling DuplicateHandle.  This function
	// shouldn't change the state of the handle at all (except some
	// internal ref count or something).  So if it succeeds, then we
	// know we have a valid handle, otherwise, we will call it invalid.
	if(!DuplicateHandle(GetCurrentProcess(), handle,
						GetCurrentProcess(), &hTemp,
						DUPLICATE_SAME_ACCESS, FALSE,
						DUPLICATE_SAME_ACCESS))
	{
		dwError = GetLastError();
		DPF(0, "Duplicate Handle failed -- dwError = %lu",dwError);
		return FALSE;
	}

	// Now close our duplicate handle
	CloseHandle(hTemp);
	return TRUE;


} // OS_IsValidHandle


HRESULT OS_CreateGuid(LPGUID pGuid)
{
	RPC_STATUS rval;

	rval = UuidCreate(pGuid);

	// myronth -- changed this to use the succeeded macro so that in the
	// case where we are on a machine that doesn't have a network card,
	// this function will return a warning, but the pGuid will still be
	// unique enough for our purposes (only unique to the local machine).
	// Therefore, we will return a success in this case...
	if (SUCCEEDED(rval))
	{
		return DP_OK;
	}
	else
	{
		ASSERT(FALSE);
		DPF(0,"create guid failed - error = %d\n",rval);
		return rval;
	}

} // OS_CreateGuid

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;

    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++;
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		else
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	char lpTemp[GUID_STRING_SIZE];
	char *lpStr = lpTemp;

	WideToAnsi(lpStr,lpWStr,GUID_STRING_SIZE);

	lpTemp[GUID_STRING_SIZE-1]='\0';	// force NULL termination
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;

	// Fix for B#24853 GUIDs that don't have full significance fail
	// to be extracted properly.  This is because there aren't any
	// leading zeros stored in the GUID in the registry.  So we need
	// to zero pad the start of the GUID string before doing the
	// rest of the conversion.
	{
		int guidStrLen;
		char *lpScanStr=lpStr;

		guidStrLen=strlen(lpTemp);
		
		lpTemp[guidStrLen]='-'; //sentinel over terminating NULL

		while(*lpScanStr != '-'){ // find guid component separator
			lpScanStr++;
		}

		lpTemp[guidStrLen]='\0'; //eliminate sentinel

		// if this GUID's first component is not fully significant, then pad it.
		if(lpScanStr-lpStr < 8){
			int nPadBytes;
			nPadBytes = (int)(8-(lpScanStr-lpStr));
			if(guidStrLen + nPadBytes < GUID_STRING_SIZE-1){
				// there is room to pad it, so shift it.
				memmove(lpStr+nPadBytes, lpStr, GUID_STRING_SIZE-nPadBytes-1);
				// now write the pad bytes
				lpScanStr = lpStr;
				while(nPadBytes--){
					*(lpScanStr++)='0';
				}
			}
		}
	}
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr)
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString


// convert passed in guid to a string and place it in the buffer passed in
HRESULT StringFromGUID(LPGUID lpg, LPWSTR lpwszGuid, DWORD dwBufferSize)
{
	CHAR	szGuid[GUID_STRING_SIZE];


	// First check the size of the buffer
	if(dwBufferSize < GUID_STRING_SIZE)
		return DPERR_GENERIC;

	if(gbWin95)
	{
		wsprintfA(szGuid, "{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
			lpg->Data1, lpg->Data2, lpg->Data3, lpg->Data4[0], lpg->Data4[1],
			lpg->Data4[2], lpg->Data4[3], lpg->Data4[4], lpg->Data4[5],
			lpg->Data4[6], lpg->Data4[7]);

		AnsiToWide(lpwszGuid, szGuid, lstrlenA(szGuid)+1);
	}
	else
	{
		wsprintf(lpwszGuid, TEXT("{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), lpg->Data1, lpg->Data2,
			lpg->Data3, lpg->Data4[0], lpg->Data4[1], lpg->Data4[2], lpg->Data4[3],
			lpg->Data4[4], lpg->Data4[5], lpg->Data4[6], lpg->Data4[7]);
	}

	return DP_OK;
}

// convert passed in guid to a string and place it in the buffer passed in
HRESULT AnsiStringFromGUID(LPGUID lpg, LPSTR lpszGuid, DWORD dwBufferSize)
{
	ASSERT(lpszGuid);
	
	// First check the size of the buffer
	if(dwBufferSize < GUID_STRING_SIZE)
		return DPERR_GENERIC;

	wsprintfA(lpszGuid, "{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
			lpg->Data1, lpg->Data2, lpg->Data3, lpg->Data4[0], lpg->Data4[1],
			lpg->Data4[2], lpg->Data4[3], lpg->Data4[4], lpg->Data4[5],
			lpg->Data4[6], lpg->Data4[7]);

	return DP_OK;
}

// compute a wide string length.
// use this instead of crt fn. so we don't have
// to link to msvcrt.lib (and there's no wstrlen in libc.lib)
// called by WSTRLEN macro
int OS_StrLen(LPCWSTR lpwStr)
{
	int i=1; // 1 for null terminator...

	if (!lpwStr) return 0;

	while (*lpwStr++) i++;

	return i;
} //OS_StrLen

// compare two wide strings
int OS_StrCmp(LPCWSTR lpwStr1, LPCWSTR lpwStr2)
{
    if(!lpwStr1 || !lpwStr2)
    {
        if(!lpwStr1 && !lpwStr2) return 0;
        else return -1;
    }

    while(*lpwStr1 && *lpwStr2)
    {
        if(*lpwStr1 != *lpwStr2) return *lpwStr1 - *lpwStr2;

        lpwStr1++;
        lpwStr2++;
    }

    return 0;
} //OS_StrCmp

/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT GetAnsiString(LPSTR * ppszAnsi,LPWSTR lpszWide)
{
	int iStrLen;
	
	ASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return DP_OK;
	}

	// call wide to ansi to find out how big +1 for terminating NULL
	iStrLen = WideToAnsi(NULL,lpszWide,0) + 1;
	ASSERT(iStrLen > 0);

	*ppszAnsi = DPMEM_ALLOC(iStrLen);
	if (!*ppszAnsi)	
	{
		DPF_ERR("could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}
	WideToAnsi(*ppszAnsi,lpszWide,iStrLen);

	return DP_OK;
} // GetAnsiString

/*
 ** GetString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszDest - pointer to string
 *				lpszSrc - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and copies lpszSrc to lpszDest
 *
 *  RETURNS: strlength
 *
 */
HRESULT GetString(LPWSTR * ppszDest,LPWSTR lpszSrc)
{
	int iStrLen;

	ASSERT(ppszDest);

	if (!lpszSrc)
	{
		*ppszDest = NULL;
		return DP_OK;
	}

    // alloc dest string
    iStrLen=WSTRLEN_BYTES(lpszSrc) ;
    *ppszDest = DPMEM_ALLOC(iStrLen);
    if (!*ppszDest)
    {
            DPF_ERR("could not get string -- out of memory!");
            return E_OUTOFMEMORY;
    }
    // copy strings
	memcpy(*ppszDest,lpszSrc,iStrLen);
	
	return DP_OK;
} // GetString

HINSTANCE OS_LoadLibrary(LPWSTR lpszWFileName)
{
	if (gbWin95)
	{
		char FileName[DPLAY_MAX_FILENAMELEN];
		
		WideToAnsi(FileName,lpszWFileName,DPLAY_MAX_FILENAMELEN);
		
		return LoadLibraryA(FileName);
	}
	// nt, use unicode call
	return LoadLibrary(lpszWFileName);
} // OS_LoadLibrary

// we're always looking for "SPInit" name, so we can just use ansi
FARPROC OS_GetProcAddress(HMODULE  hModule,LPSTR lpProcName)
{
	// hmmm, no getprocaddressa, seems to be always ansi...
	return GetProcAddress(hModule,lpProcName);

} // OS_GetProcAddress

LONG OS_RegOpenKeyEx(HKEY hKey,LPWSTR lpszWKeyStr,DWORD dwReserved,REGSAM samDesired,PHKEY phkResult)
{
	if (gbWin95)
	{
		char lpszKeyStr[DPLAY_REGISTRY_NAMELEN];

		WideToAnsi(lpszKeyStr,lpszWKeyStr,DPLAY_REGISTRY_NAMELEN);

		return RegOpenKeyExA(hKey,lpszKeyStr,dwReserved,samDesired,phkResult);
	}
	else return RegOpenKeyEx(hKey,lpszWKeyStr,dwReserved,samDesired,phkResult);

} // OS_RegOpenKeyEx

LONG OS_RegQueryValueEx(HKEY hKey,LPWSTR lpszWValueName,LPDWORD lpdwReserved,
	LPDWORD lpdwType,LPBYTE lpbData,LPDWORD lpcbData)
{

	ASSERT(lpcbData);

	if (gbWin95)
	{
		char lpszValueName[DPLAY_REGISTRY_NAMELEN];
		int iStrLen;
		LONG rval;
		DWORD dwSize = 0;
								
		ASSERT(lpcbData);
		ASSERT(lpdwType);

		WideToAnsi(lpszValueName,lpszWValueName,DPLAY_REGISTRY_NAMELEN);

		if(lpcbData)
			dwSize = *lpcbData;

		rval = RegQueryValueExA(hKey,lpszValueName,lpdwReserved,
			lpdwType,lpbData,&dwSize);

		// convert back to wchar
		// take into account the case where lpbData is NULL
		if ((ERROR_SUCCESS == rval) && (REG_SZ == *lpdwType) && (lpbData))
		{
			char * lpszTemp;

			DPF(9,"reg - converting string");
			
			//
			// dwSize is the size of the ansi string
			// iStrLen is the size of the unicode string
			// lpcbData is the size of the buffer
			// lpbData is an ansi version of the (unicode) string we want...
			//
			// make sure buffer will hold unicode string
			iStrLen = AnsiToWide(NULL,lpbData,0);
			if (*lpcbData < (DWORD) iStrLen)
			{
				DPF_ERR("buffer too small!");
				return ERROR_INSUFFICIENT_BUFFER;
			}
			lpszTemp = DPMEM_ALLOC(dwSize);
			if (!lpszTemp)
			{
				DPF_ERR("could not alloc buffer for string conversion");
				return ERROR_NOT_ENOUGH_MEMORY;
			}
			memcpy(lpszTemp,lpbData,dwSize);
			// lpszTemp now holds the ansi string
			iStrLen = AnsiToWide((WCHAR *)lpbData,lpszTemp,*lpcbData);
			// finally, the unicode string is in lpbData
			*lpcbData = iStrLen;
			DPMEM_FREE(lpszTemp);
		}
		else
		{
			// This function returns the number of bytes (not WCHARs)
			*lpcbData = dwSize * sizeof(WCHAR);
		}
		return rval;
	}
	else return RegQueryValueEx(hKey,lpszWValueName,lpdwReserved,
			lpdwType,lpbData,lpcbData);

}// OS_RegQueryValueEx


LONG OS_RegEnumKeyEx( HKEY hKey,DWORD iSubkey,LPWSTR lpszWName,LPDWORD lpcchName,
	LPDWORD lpdwReserved,LPWSTR lpszClass, LPDWORD lpcchClass,
	PFILETIME lpftLastWrite )
{

	ASSERT(!lpdwReserved);
	ASSERT(!lpszClass);
	ASSERT(!lpcchClass);
	ASSERT(!lpftLastWrite);

	if (gbWin95)
	{
		char lpszName[DPLAY_REGISTRY_NAMELEN];
		LONG rval;
		DWORD dwNameLen = DPLAY_REGISTRY_NAMELEN;
								
		rval = RegEnumKeyExA(hKey,iSubkey,lpszName,&dwNameLen,NULL,
			NULL, NULL, NULL );

		// convert back to wchar
		if (ERROR_SUCCESS == rval)
		{
			*lpcchName = AnsiToWide(lpszWName,lpszName,DPLAY_REGISTRY_NAMELEN);
		}

		return rval;
	}
	else return RegEnumKeyEx(hKey,iSubkey,lpszWName,lpcchName,NULL,
			NULL, NULL, NULL );
} // OS_RegEnumKeyEx

//
// Additions from dplos.c in the dplobby project
//
HANDLE OS_CreateEvent(LPSECURITY_ATTRIBUTES lpSA, BOOL bManualReset,
						BOOL bInitialState, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hEvent;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hEvent = CreateEventA(lpSA, bManualReset, bInitialState, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hEvent = CreateEvent(lpSA, bManualReset, bInitialState, lpName);
	}	

	return hEvent;
}


HANDLE OS_CreateMutex(LPSECURITY_ATTRIBUTES lpSA, BOOL bInitialOwner,
						LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMutex;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMutex = CreateMutexA(lpSA, bInitialOwner, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMutex = CreateMutex(lpSA, bInitialOwner, lpName);
	}	

	return hMutex;
}


HANDLE OS_OpenEvent(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hEvent;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hEvent = OpenEventA(dwAccess, bInherit, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hEvent = OpenEvent(dwAccess, bInherit, lpName);
	}	

	return hEvent;
}


HANDLE OS_OpenMutex(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMutex;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMutex = OpenMutexA(dwAccess, bInherit, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMutex = OpenMutex(dwAccess, bInherit, lpName);
	}	

	return hMutex;
}


HANDLE OS_CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpSA,
							DWORD dwProtect, DWORD dwMaxSizeHigh,
							DWORD dwMaxSizeLow, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMapping;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMapping = CreateFileMappingA(hFile, lpSA, dwProtect, dwMaxSizeHigh,
										dwMaxSizeLow, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMapping = CreateFileMapping(hFile, lpSA, dwProtect, dwMaxSizeHigh,
										dwMaxSizeLow, lpName);
	}	

	return hMapping;
}


HANDLE OS_OpenFileMapping(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMapping = NULL;
	LPSTR	lpszTemp = NULL;
	DWORD	dwError;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMapping = OpenFileMappingA(dwAccess, bInherit, lpszTemp);
		if(!hMapping)
		{
			dwError = GetLastError();
			DPF(8, "Error getting shared memory file handle");
			DPF(8, "dwError = 0x%08x", dwError);
		}

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMapping = OpenFileMapping(dwAccess, bInherit, lpName);
	}	

	return hMapping;
}


BOOL OS_CreateProcess(LPWSTR lpwszAppName, LPWSTR lpwszCmdLine,
		LPSECURITY_ATTRIBUTES lpSAProcess, LPSECURITY_ATTRIBUTES lpSAThread,
		BOOL bInheritFlags, DWORD dwCreationFlags, LPVOID lpEnv,
		LPWSTR lpwszCurDir, LPSTARTUPINFO lpSI, LPPROCESS_INFORMATION lpPI)
{
	HRESULT	hr;
	BOOL	bResult;
	STARTUPINFOA	sia;
	LPSTR	lpszAppName = NULL,
			lpszCmdLine = NULL,
			lpszCurDir = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszAppName, lpwszAppName);
		if(SUCCEEDED(hr))
		{
			hr = GetAnsiString(&lpszCmdLine, lpwszCmdLine);
			if(SUCCEEDED(hr))
			{
				hr = GetAnsiString(&lpszCurDir, lpwszCurDir);
				if(FAILED(hr))
				{
					DPMEM_FREE(lpszAppName);
					DPMEM_FREE(lpszCmdLine);
					DPF_ERR("Couldn't allocate memory for temp CurDir string!");
					return FALSE;
				}
			}
			else
			{
				DPMEM_FREE(lpszAppName);
				DPF_ERR("Couldn't allocate memory for temp CmdLine string!");
				return FALSE;
			}
		}
		else
		{
			DPF_ERR("Couldn't allocate memory for temp AppName string!");
			return FALSE;
		}

		// Set up the ANSI STARTUPINFO structure, assuming we are not setting
		// any of the strings in the structures.  (This should be true since
		// the only place we call this is in dplgame.c and it doesn't send anything
		// in this structure).
		memcpy(&sia, lpSI, sizeof(STARTUPINFO));

		bResult = CreateProcessA(lpszAppName, lpszCmdLine, lpSAProcess,
					lpSAThread, bInheritFlags, dwCreationFlags, lpEnv,
					lpszCurDir, &sia, lpPI);

		if(lpszAppName)
			DPMEM_FREE(lpszAppName);
		if(lpszCmdLine)
			DPMEM_FREE(lpszCmdLine);
		if(lpszCurDir)
			DPMEM_FREE(lpszCurDir);
	}
	else
	{
		bResult = CreateProcess(lpwszAppName, lpwszCmdLine, lpSAProcess,
					lpSAThread, bInheritFlags, dwCreationFlags, lpEnv,
					lpwszCurDir, lpSI, lpPI);
	}	

	return bResult;
}


long OS_RegSetValueEx(HKEY hKey, LPWSTR lpszValueName, DWORD dwReserved, DWORD dwType,
	const BYTE *lpData, DWORD cbData)
{
    LPSTR                   lpszValueNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszValueNameA, lpszValueName)))
        {
            return (long)hr;
        }

        lResult = RegSetValueExA(hKey, lpszValueNameA, dwReserved, dwType, lpData, cbData);

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegSetValueEx(hKey, lpszValueName, dwReserved, dwType, lpData, cbData);
    }

    return lResult;
}


long OS_RegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcbValueName,
	LPDWORD lpReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData)
{
    LPSTR                   lpszValueNameA = NULL;
    long                    lResult;

    if(gbWin95)
    {
        if(lpszValueName && lpcbValueName && *lpcbValueName)
        {
            if(!(lpszValueNameA = (LPSTR)DPMEM_ALLOC(*lpcbValueName)))
            {
                return ERROR_OUTOFMEMORY;
            }
        }

        lResult = RegEnumValueA(hKey, dwIndex, lpszValueNameA, lpcbValueName, lpReserved,
        	lpdwType, lpbData, lpcbData);

        if(lpszValueName && lpcbValueName && *lpcbValueName)
        {
            AnsiToWide(lpszValueName, lpszValueNameA, *lpcbValueName);
        }

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegEnumValue(hKey, dwIndex, lpszValueName, lpcbValueName, lpReserved,
        	lpdwType, lpbData, lpcbData);
    }

    return lResult;
}


long OS_RegDeleteValue(HKEY hKey, LPWSTR lpszValueName)
{
    LPSTR                   lpszValueNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszValueNameA, lpszValueName)))
        {
            return (long)hr;
        }

        lResult = RegDeleteValueA(hKey, lpszValueNameA);

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegDeleteValue(hKey, lpszValueName);
    }

    return lResult;
}


long OS_RegCreateKeyEx(HKEY hKey, LPWSTR lpszSubKey, DWORD dwReserved, LPWSTR lpszClass,
	DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult, LPDWORD lpdwDisposition)
{
    LPSTR                   lpszSubKeyA = NULL;
    LPSTR                   lpszClassA = NULL;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(lpszSubKey && FAILED(hr = GetAnsiString(&lpszSubKeyA, lpszSubKey)))
        {
            return (long)hr;
        }

        if(lpszClass && FAILED(hr = GetAnsiString(&lpszClassA, lpszClass)))
        {
            if(lpszSubKeyA)
            {
                DPMEM_FREE(lpszSubKeyA);
                return (long)hr;
            }
        }

        lResult = RegCreateKeyExA(hKey, lpszSubKeyA, dwReserved, lpszClassA, dwOptions,
        	samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

        if(lpszSubKeyA)
        {
            DPMEM_FREE(lpszSubKeyA);
        }

        if(lpszClassA)
        {
            DPMEM_FREE(lpszClassA);
        }
    }
    else
    {
        lResult = RegCreateKeyEx(hKey, lpszSubKey, dwReserved, lpszClass, dwOptions, samDesired,
        	lpSecurityAttributes, phkResult, lpdwDisposition);
    }

    return lResult;
}


long OS_RegDeleteKey(HKEY hKey, LPWSTR lpszKeyName)
{
    LPSTR                   lpszKeyNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszKeyNameA, lpszKeyName)))
        {
            return (long)hr;
        }

        lResult = RegDeleteKeyA(hKey, lpszKeyNameA);

        DPMEM_FREE(lpszKeyNameA);
    }
    else
    {
        lResult = RegDeleteKey(hKey, lpszKeyName);
    }

    return lResult;
}


DWORD OS_GetCurrentDirectory(DWORD dwSize, LPWSTR lpBuffer)
{
	LPSTR	lpszTemp = NULL;
	DWORD	dwResult;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		if(lpBuffer)
		{
			lpszTemp = DPMEM_ALLOC(dwSize);
			if(!lpszTemp)
			{
				DPF_ERR("Unable to allocate memory for temporary CurrentDir string");
				return 0;
			}
		}

		dwResult = GetCurrentDirectoryA(dwSize, lpszTemp);

		// Convert the string back to Unicode
		if(dwResult && lpBuffer)
		{
			// NOTE: This min call is really unnecessary, but
			// just in case someone passes in a dwSize value which
			// is really a count of bytes instead of a count of
			// characters, we will make sure we don't
			// run off the end of our buffer (but the resulting
			// string will probably not be exactly what the caller
			// expects).
			AnsiToWide(lpBuffer, lpszTemp, min(dwResult, dwSize));
		}

		if(lpszTemp)
			DPMEM_FREE(lpszTemp);
	}
	else
	{
		dwResult = GetCurrentDirectory(dwSize, lpBuffer);
	}	

	return dwResult;
}


int OS_CompareString(LCID Locale, DWORD dwCmpFlags, LPWSTR lpwsz1,
		int cchCount1, LPWSTR lpwsz2, int cchCount2)
{
	LPSTR	lpsz1 = NULL;
	LPSTR	lpsz2 = NULL;
	int		iReturn;
	HRESULT	hr;

	// If we're on Win95, alloc ANSI strings and call the ANSI API,
	// otherwise, just call the Unicode API.  If we fail allocating
	// memory, return zero which indicates the strings are not equal.
	if(gbWin95)
	{
		// Allocate ANSI strings
		hr = GetAnsiString(&lpsz1, lpwsz1);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to allocate memory for temporary string");
			return 0;
		}

		hr = GetAnsiString(&lpsz2, lpwsz2);
		if(FAILED(hr))
		{
			DPMEM_FREE(lpwsz1);
			DPF_ERR("Unable to allocate memory for temporary string");
			return 0;
		}

		// Now call the ANSI API
		iReturn = CompareStringA(Locale, dwCmpFlags, lpsz1, cchCount1,
					lpsz2, cchCount2);

		// Free the strings
		DPMEM_FREE(lpsz1);
		DPMEM_FREE(lpsz2);

	}
	else
	{
		iReturn = CompareString(Locale, dwCmpFlags, lpwsz1, cchCount1,
					lpwsz2, cchCount2);
	}

	return iReturn;

} // OS_CompareString

LPWSTR OS_StrStr(LPWSTR lpwsz1, LPWSTR lpwsz2)
{
	DWORD i;
	// returns a pointer to the first occurance of lpwsz2 in lpwsz1
	while(*lpwsz1){
	
		i=0;
		while( (*(lpwsz2+i) && *(lpwsz1+i)) && (*(lpwsz1+i) == *(lpwsz2+i))){
			i++;
		}
		if(*(lpwsz2+i)==L'\0'){
			return lpwsz1;
		}
		lpwsz1++;
	}
	return NULL;	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpsecos.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecos.h
 *  Content:	DirectPlay's interface to SSPI.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through 
 *                      Windows Security Support Provider Interface (SSPI).
 *  04/14/97    sohailm Added prototypes for OS_FreeContextBuffer(), OS_QueryContextAttributes(), 
 *                      and OS_QueryContextBufferSize().
 *  05/12/97    sohailm Added prototypes for CAPI function calls.
 *  05/29/97    sohailm Added prototype for QueryContextUserName. Updated QueryContextBufferSize
 *                      prototype to return HRESULT.
 *  06/23/97    sohailm Added prototypes for CAPI message signing function calls.
 *
 ***************************************************************************/
#ifndef __DPSECOS_H__
#define __DPSECOS_H__

#include <sspi.h>

extern BOOL 
OS_IsSSPIInitialized(
    void
    );

extern BOOL 
OS_GetSSPIFunctionTable(
    HMODULE hModule
    );

extern BOOL
OS_IsCAPIInitialized(
    void
    );

extern BOOL 
OS_GetCAPIFunctionTable(
    HMODULE hModule
    );

extern void
OS_ReleaseCAPIFunctionTable(
    void
    );

/***************************************************************************
 * Security Support Provider Interface
 ***************************************************************************/

extern SECURITY_STATUS 
OS_AcceptSecurityContext(
    PCredHandle         phCredential,
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCtxtHandle         phNewContext,
    PSecBufferDesc      pOutSecDesc,
    PULONG              pfContextAttributes,
    PTimeStamp          ptsTimeStamp
    );

extern SECURITY_STATUS 
OS_AcquireCredentialsHandle(
    SEC_WCHAR *pwszPrincipal, 
    SEC_WCHAR *pwszPackageName,
    ULONG   fCredentialUse,
    PLUID   pLogonId,
    PSEC_WINNT_AUTH_IDENTITY_W pAuthData,
    PVOID   pGetKeyFn,
    PVOID   pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp  ptsLifeTime
    );

extern SECURITY_STATUS 
OS_DeleteSecurityContext(
    CtxtHandle *phContext
    );

extern SECURITY_STATUS 
OS_FreeCredentialHandle(
    PCredHandle     phCredential
    );

extern SECURITY_STATUS 
OS_FreeContextBuffer(
    PVOID   pBuffer
    );

extern SECURITY_STATUS 
OS_InitializeSecurityContext(
    PCredHandle     phCredential,
    PCtxtHandle     phContext,
    SEC_WCHAR       *pwszTargetName,
    ULONG           fContextReq,
    ULONG           Reserved1,
    ULONG           TargetDataRep,
    PSecBufferDesc  pInput,
    ULONG           Reserved2,
    PCtxtHandle     phNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttributes,
    PTimeStamp      ptsExpiry
    );

extern SECURITY_STATUS 
OS_MakeSignature(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    );

extern SECURITY_STATUS 
OS_QueryContextAttributes(
    PCtxtHandle     phContext,
    ULONG           ulAttribute,
    LPVOID          pBuffer
    );

extern HRESULT
OS_QueryContextBufferSize(
    SEC_WCHAR       *pwszPackageName,
    ULONG           *pulBufferSize
    );

extern HRESULT 
OS_QueryContextUserName(
    PCtxtHandle     phContext,
    LPWSTR          *ppwszUserName
    );

extern SECURITY_STATUS 
OS_VerifySignature(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    );

extern SECURITY_STATUS 
OS_SealMessage(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    );

extern SECURITY_STATUS 
OS_UnSealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    );


/***************************************************************************
 * Crypto Application Programming Interface
 ***************************************************************************/

typedef BOOL (WINAPI *PFN_CRYPTACQUIRECONTEXT_A)(
    HCRYPTPROV  *phProv,
    LPSTR       pszContainer,
    LPSTR       pszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTACQUIRECONTEXT_W)(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTRELEASECONTEXT)(
    HCRYPTPROV hProv,
    DWORD dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTGENKEY)(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef BOOL (WINAPI *PFN_CRYPTDESTROYKEY)(
    HCRYPTKEY hKey);

typedef BOOL (WINAPI *PFN_CRYPTEXPORTKEY)(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef BOOL (WINAPI *PFN_CRYPTIMPORTKEY)(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef BOOL (WINAPI *PFN_CRYPTENCRYPT)(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

typedef BOOL (WINAPI *PFN_CRYPTDECRYPT)(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef BOOL (WINAPI *PFN_CRYPTCREATEHASH)(
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	);

typedef BOOL (WINAPI *PFN_CRYPTDESTROYHASH)(
	HCRYPTHASH hHash
	);

typedef BOOL (WINAPI *PFN_CRYPTHASHDATA)(
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	);

typedef BOOL (WINAPI *PFN_CRYPTSIGNHASH_A)(
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPCSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

typedef BOOL (WINAPI *PFN_CRYPTSIGNHASH_W)(
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPCWSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

typedef BOOL (WINAPI *PFN_CRYPTVERIFYSIGNATURE_A)(
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPCSTR sDescription,
	DWORD dwFlags
	);

typedef BOOL (WINAPI *PFN_CRYPTVERIFYSIGNATURE_W)(
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPCWSTR sDescription,
	DWORD dwFlags
	);

/*
 * CAPI Function table
 */
typedef struct _CAPIFUNCTIONTABLE{
    PFN_CRYPTACQUIRECONTEXT_A	CryptAcquireContextA;
    PFN_CRYPTACQUIRECONTEXT_W	CryptAcquireContextW;
    PFN_CRYPTRELEASECONTEXT		CryptReleaseContext;
    PFN_CRYPTGENKEY				CryptGenKey;
    PFN_CRYPTDESTROYKEY			CryptDestroyKey;
    PFN_CRYPTEXPORTKEY			CryptExportKey;
    PFN_CRYPTIMPORTKEY			CryptImportKey;
    PFN_CRYPTENCRYPT			CryptEncrypt;
    PFN_CRYPTDECRYPT			CryptDecrypt;
	PFN_CRYPTCREATEHASH			CryptCreateHash;
	PFN_CRYPTDESTROYHASH		CryptDestroyHash;
	PFN_CRYPTHASHDATA			CryptHashData;
	PFN_CRYPTSIGNHASH_A			CryptSignHashA;
	PFN_CRYPTSIGNHASH_W			CryptSignHashW;
	PFN_CRYPTVERIFYSIGNATURE_A	CryptVerifySignatureA;
	PFN_CRYPTVERIFYSIGNATURE_W	CryptVerifySignatureW;
} CAPIFUNCTIONTABLE, *LPCAPIFUNCTIONTABLE;

/*
 * Prototypes
 */
extern BOOL 
OS_CryptAcquireContext(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags,
    LPDWORD     lpdwLastError
    );

extern BOOL
OS_CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    );

extern BOOL
OS_CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

extern BOOL
OS_CryptDestroyKey(
    HCRYPTKEY hKey
    );

extern BOOL
OS_CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    );

extern BOOL
OS_CryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

extern BOOL
OS_CryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen
    );

extern BOOL
OS_CryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    );

extern BOOL 
OS_CryptCreateHash( 
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	);

extern BOOL 
OS_CryptDestroyHash( 
	HCRYPTHASH hHash
	);

extern BOOL 
OS_CryptHashData( 
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	);

extern BOOL 
OS_CryptSignHash( 
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPWSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

extern BOOL 
OS_CryptVerifySignature( 
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPWSTR sDescription,
	DWORD dwFlags
	);

#endif // __DPSECOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpsecure.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecure.c
 *  Content:	implements directplay security routines.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Added client-server security to directplay
 *  03/19/97    sohailm Wait for challenge to be processed before unblocking receive thread
 *  03/30/97    sohailm Send dwReserved1 field from session desc in enumsessions reply
 *  04/09/97    sohailm Return DPERR_CANTLOADSECURITYPACKAGE when package not found.
 *  04/23/97    sohailm Added support to query buffer sizes from the security package (.
 *                      Updated SignAndSendDPMessage() and VerifyMessage() to support
 *                      encryption in addition to signing. Now Addforward and SetSessionDesc 
 *                      messages are being encrypted for privacy.
 *  05/12/97    sohailm Added support to provide message privacy through Crypto API. 
 *                      Encryption code can be contionally compiled to use SSPI or CAPI.
 *  05/18/97    sohailm SecureSendDPMessage() was not getting the correct security context
 *                      if destination player was a user player.
 *  05/21/97    sohailm Now we toggle the flags DPSEND_SIGNED and DPSEND_ENCRYPTED off in
 *                      SecureSendDPMessage().
 *  05/22/97    sohailm Now we use a dplay key container with CAPI. Using the default key 
 *                      container was failing when the user wasn't logged on. 
 *  05/29/97    sohailm Now we don't include null char in size of credential strings.
 *                      ISC_REQ_SUPPLIED_CREDS flag is now obsolete - removed it
 *                      (thanks to NTLM).
 *  06/09/97    sohailm Added better error handling for SSPI and CAPI provider initialization.
 *  06/16/97    sohailm Now we return server authentication errors to the client.
 *                      Mapped SEC_E_UNKNOWN_CREDENTIALS sspi error to DPERR_LOGONDENIED on
 *                       the client because DPA returns this when passed blank credentials.
 *  06/22/97    sohailm Since QuerySecurityPackageInfo() is not supported on all platforms 
 *                      (NTLM,Win'95 Gold) added a work around to get this info from the context.
 *                      We were not keeping track of separate encryption/decryption keys for each client.                      
 *  06/23/97    sohailm Added support for signing messages using CAPI.
 *  06/24/97    sohailm Code cleanup to prevent leaks etc.
 *  06/26/97    sohailm Don't modify the original message by encrypting in place. Make a local copy.
 *  06/27/97    sohailm Only sign the data portion of a signed message (bug:10373)
 *	12/29/97	myronth	TRUE != DPSEND_GUARANTEED (#15887)
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *
 ***************************************************************************/
#include "dplaypr.h"
#include "dpos.h"
#include "dpsecure.h"

// Encryption/Decryption is done using symmetric keys or session keys, meaning
// the same key will be used for both encryption and decryption. Encryption support
// is provided using SSPI or CAPI depending on the SSPI_ENCRYPTION flag. CAPI is default.

// The process of exchanging session keys is as follows:
// 1. Server and Client each generate a public/private key pair. 
// 2. They exchange their pubic keys (through digitally signed messages).
// 3. Server and Client each generate a session key.
// 4. Each encrypts the session key with the receivers public key
// 5. They exchange the encrypted session keys.
// 6. Receiver will import the encrypted session key blobs into the CSP
//    thus completing the exchange.

// Implementation
//
// Client and Server generate public/private key pair in LoadServiceProvider() 
// Client generates session (encryption) key in SendKeysToServer()
// Server generates session (encryption) key in SendKeyExchangeReply()
// Server sends its public key to the client in the DPSP_MSG_ACCESSGRANTED message (signed)
// Client encrypts its session key using the server's public key and sends
//  it to the server along with the clients public key in DPSP_MSG_KEYEXCHANGE (signed).
// Server encrypts its session key using the client's public key and sends 
//  it to the client in DPSP_MSG_KEYEXCHANGEREPLY (signed).
// Exchange is done - now the server and client can send each other private messages.


//
// Globals
//
LPBYTE                  gpReceiveBuffer;
DWORD                   gdwReceiveBufferSize;

#undef DPF_MODNAME
#define DPF_MODNAME	"InitSecurity"
//+----------------------------------------------------------------------------
//
//  Function:   InitSecurity
//
//  Description: This function initializes CAPI and SSPI.
//
//  Arguments:  this - dplay object
//
//  Returns:    DP_OK, DPERR_CANTLOADCAPI, DPERR_CANTLOADSSPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitSecurity(
    LPDPLAYI_DPLAY this
    )
{
    HRESULT hr;

    // check if we already initialized CAPI
    if (!OS_IsCAPIInitialized()) 
    {
        hr = InitCAPI();
        if (FAILED(hr))
        {
            DPF_ERRVAL("CAPI initialization failed: hr=0x%08x",hr);
            return hr;
        }
    }

    // check if we already initialized SSPI
    if (!OS_IsSSPIInitialized()) 
    {
        hr = InitSSPI();
        if (FAILED(hr))
        {
            DPF_ERRVAL("SSPI initialization failed: hr=0x%08x",hr);
            return hr;
        }
    }

    // success
    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"InitCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   InitCAPI
//
//  Description: This function initializes CAPI and gets a pointer to the function 
//               table
//
//  Arguments:  none
//
//  Returns:    DP_OK, DPERR_CANTLOADCAPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitCAPI(
    void
    )
{
    HRESULT hr;

    //
    // Load CAPI DLL. We unload it only when dplay goes away.
    //
    ghCAPI = OS_LoadLibrary(CAPI_DLL);
    if (!ghCAPI)
    {
        DPF_ERRVAL("Can't load CAPI: Error=0x%08x",GetLastError());
        return DPERR_CANTLOADCAPI;
    }

    //
    // Get the Cryptographic Application Programming Interface
    //
    if (!OS_GetCAPIFunctionTable(ghCAPI))
    {
        DPF_ERR("Can't get the CAPI function table");
        hr = DPERR_CANTLOADCAPI;
        goto ERROR_EXIT;
    }

    // Success
    return DP_OK;

ERROR_EXIT:
    if (ghCAPI)
    {
        FreeLibrary(ghCAPI);
        ghCAPI = NULL;
    }
    return hr;

} // InitCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"InitSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   InitSSPI
//
//  Description: This function initializes SSPI and gets a pointer to the function 
//               table
//
//  Arguments:  none
//
//  Returns:    DP_OK, DPERR_CANTLOADSSPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitSSPI(
    void
    )
{
    HRESULT hr;

    //
    // Load SSPI DLL. We unload it only when dplay goes away.
    //
    if (gbWin95)
    {
        ghSSPI = OS_LoadLibrary (SSP_WIN95_DLL);
    }
    else
    {
        ghSSPI = OS_LoadLibrary (SSP_NT_DLL);
    }
    if (!ghSSPI)
    {
        DPF_ERRVAL("Cannot load SSPI: Error=0x%08x", GetLastError());
        return DPERR_CANTLOADSSPI;
    }

    //
    // Get the Security Service Provider Interface
    //
    if (!OS_GetSSPIFunctionTable(ghSSPI))
    {
        DPF_ERR("Can't get the SSPI function table");
        hr = DPERR_CANTLOADSSPI;
        goto ERROR_EXIT;
    }

    //
    // Initialize seed for random numbers used during encryption
    //
    srand(GetTickCount());

    // Success
    return DP_OK;

ERROR_EXIT:
    if (ghSSPI)
    {
        FreeLibrary(ghSSPI);
        ghSSPI = NULL;
    }
    return hr;

} // InitSSPI


#undef DPF_MODNAME
#define DPF_MODNAME	"LoadSecurityProviders"

//+----------------------------------------------------------------------------
//
//  Function:   LoadSecurityProviders
//
//  Description: This function loads the specified security providers (SSPI and CAPI) and
//               initializes the credentials handle and the necessary keys.
//
//  Arguments:  this - dplay object
//              dwFlags - server or client
//
//  Returns:    DP_OK, DPERR_UNSUPPORTED, DPERR_INVALIDPARAMS, DPERR_CANTLOADSECURITYPACKAGE, or
//              DPERR_OUTOFMEMORY, DPERR_GENERIC.
//
//-----------------------------------------------------------------------------
HRESULT 
LoadSecurityProviders(
    LPDPLAYI_DPLAY this,
    DWORD dwFlags
    )
{
    TimeStamp tsLifeTime;
    PSEC_WINNT_AUTH_IDENTITY_W pAuthData = NULL;
    SEC_WINNT_AUTH_IDENTITY_W AuthData;
    SECURITY_STATUS SecStatus;
    ULONG ulCredType;
    PCredHandle phCredential=NULL;
    HCRYPTPROV hCSP=0;
    HCRYPTKEY hEncryptionKey=0;
    HCRYPTKEY hPublicKey=0;
    LPBYTE pPublicKeyBuffer=NULL;
    DWORD dwPublicKeyBufferSize = 0;
    HRESULT hr;
	BOOL fResult;
    DWORD dwError;
    ULONG ulMaxContextBufferSize=0;

    // lpszSSPIProvider is always initialized
    // lpszCAPIProvider could be NULL in which case CAPI will load Microsoft's RSA Base Provider
    ASSERT(this->pSecurityDesc->lpszSSPIProvider);
    // we shouldn't have a credential handle yet
    ASSERT(!(this->phCredential));

    //
    // SSPI
    //

    ZeroMemory(&AuthData,sizeof(AuthData));
    if (this->pUserCredentials)
    {
        // build a SEC_WINNT_AUTH_IDENTITY structure to pass credentials to 
        // SSPI package - this prevents the package from popping the login dialog

        // ************************************************************************
        // However, this data is package dependent. Passing credentials in this 
        // format will only work for packages that support the SEC_WINNT_AUTH_IDENTITY 
        // format for credentials.
        // ************************************************************************

        // note - do not include null character in the size of the strings
        if (this->pUserCredentials->lpszUsername)
        {
            AuthData.User = this->pUserCredentials->lpszUsername;
            AuthData.UserLength = WSTRLEN(AuthData.User)-1;
        }
        if (this->pUserCredentials->lpszPassword)
        {
            AuthData.Password = this->pUserCredentials->lpszPassword;
            AuthData.PasswordLength = WSTRLEN(AuthData.Password)-1;
        }
        if (this->pUserCredentials->lpszDomain)
        {
            AuthData.Domain = this->pUserCredentials->lpszDomain;
            AuthData.DomainLength = WSTRLEN(AuthData.Domain)-1;
        }

        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        pAuthData = &AuthData;
    }

    // allocate memory for the credential handle
    phCredential = DPMEM_ALLOC(sizeof(CredHandle));
    if (!phCredential)
    {
        DPF_ERR("Failed to allocate memory for credentials handle");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Select the appropriate credentials type
    //
    if (SSPI_SERVER == dwFlags)
    {
        DPF(9, "Setting server credentials");

        ulCredType = SECPKG_CRED_INBOUND;
    }
    else
    {
        DPF(9, "Setting client credentials");

        ulCredType = SECPKG_CRED_OUTBOUND;
    }

	// Calling acquire credentials loads the SSPI provider
    SecStatus = OS_AcquireCredentialsHandle(
        NULL, 
        this->pSecurityDesc->lpszSSPIProvider,
        ulCredType,
        NULL,
        pAuthData,
        NULL,
        NULL,
        phCredential,
        &tsLifeTime);
    if (!SEC_SUCCESS(SecStatus))
    {
        switch (SecStatus) {

        case SEC_E_SECPKG_NOT_FOUND:
            DPF_ERRVAL("SSPI provider %ls was not found\n",this->pSecurityDesc->lpszSSPIProvider);
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            break;

        case SEC_E_UNSUPPORTED_FUNCTION:
            DPF_ERR("This operation is not supported");
            hr = DPERR_UNSUPPORTED;
            break;

        case SEC_E_INVALID_TOKEN:
            DPF_ERRVAL("Credentials were passed in invalid format - check the format for %ls",\
                this->pSecurityDesc->lpszSSPIProvider);
            hr = DPERR_INVALIDPARAMS;
            break;
            
        case SEC_E_UNKNOWN_CREDENTIALS:
            DPF_ERR("SSPI Provider returned unknown credentials error - mapping to logon denied");
            hr = DPERR_LOGONDENIED;
            break;

        default:
            DPF(0,"Acquire Credential handle failed [0x%x]\n", SecStatus);
            hr = SecStatus;
        }

        goto CLEANUP_EXIT;
    }

    // get the max buffer size used for opaque buffers during authentication
    hr = GetMaxContextBufferSize(this->pSecurityDesc, &ulMaxContextBufferSize);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to get context buffer size: hr=0x%08x",hr);
        goto CLEANUP_EXIT;
    }

    //
	// CAPI
    //

    // delete any existing key containers 
    fResult = OS_CryptAcquireContext(
        &hCSP,                                  // handle to CSP
        DPLAY_KEY_CONTAINER,                    // key container name
        this->pSecurityDesc->lpszCAPIProvider,  // specifies which CSP to use
        this->pSecurityDesc->dwCAPIProviderType,// provider type (PROV_RSA_FULL, PROV_FORTEZZA)
        CRYPT_DELETEKEYSET,                     // delete any existing key container
        &dwError
        );

    if (!fResult)
    {

        switch (dwError) {

        case NTE_BAD_KEYSET_PARAM:
            DPF_ERRVAL("The CAPI provider name [%ls] is invalid",this->pSecurityDesc->lpszCAPIProvider);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_BAD_PROV_TYPE:
            DPF_ERRVAL("The CAPI provider type [%d] is invalid", this->pSecurityDesc->dwCAPIProviderType);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROV_TYPE_NOT_DEF:
            DPF_ERRVAL("No registry entry exists for the CAPI provider type %d", \
                this->pSecurityDesc->dwCAPIProviderType);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case ERROR_INVALID_PARAMETER:
            DPF_ERR("Invalid provider passed to the Crypto provider");
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROV_DLL_NOT_FOUND:
            DPF_ERR("The CAPI provider DLL doesn't exist or is not in the current path");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROVIDER_DLL_FAIL:
            DPF_ERR("The CAPI provider DLL file could not be loaded, and may not exist \
                If it exists, then the file is not a valid DLL");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        case NTE_BAD_SIGNATURE:
            DPF_ERR("Warning!!! - CAPI provider DLL signature could not be verified. Either the DLL \
                or the signature has been tampered with");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        default:
            DPF(6,"Failed to delete key container: Error=0x%08x (ok)", dwError);
            // it's ok if we can't delete the container - don't fail yet
        }
    }


    // create a new key container 
    fResult = OS_CryptAcquireContext(
        &hCSP,       							// handle to CSP
        DPLAY_KEY_CONTAINER,                    // key container name
        this->pSecurityDesc->lpszCAPIProvider,  // specifies which CSP to use
        this->pSecurityDesc->dwCAPIProviderType,// provider type (PROV_RSA_FULL, PROV_FORTEZZA)
        CRYPT_NEWKEYSET,							// create a new key container
        &dwError
        );
    if (!fResult)
    {
        DPF_ERRVAL("Failed to create a key container: Error=0x%08x",dwError);
        hr = DPERR_CANTLOADSECURITYPACKAGE;
        goto CLEANUP_EXIT;
    }

	// create a public/private key pair
	hr = GetPublicKey(hCSP, &hPublicKey, &pPublicKeyBuffer, &dwPublicKeyBufferSize);
	if (FAILED(hr))
	{
        DPF_ERRVAL("Failed to create public/private key pair: hr=0x%08x", hr);
        goto CLEANUP_EXIT;
	}
	
    // success 

    // now remember everything in the dplay object
    this->phCredential = phCredential;
    this->ulMaxContextBufferSize = ulMaxContextBufferSize;
    this->hCSP = hCSP;
    this->hEncryptionKey = hEncryptionKey;
    this->hPublicKey = hPublicKey;
    this->pPublicKey = pPublicKeyBuffer;
    this->dwPublicKeySize = dwPublicKeyBufferSize;

    // mark that dplay is providing security
    this->dwFlags |= DPLAYI_DPLAY_SECURITY;
	this->dwFlags |= DPLAYI_DPLAY_ENCRYPTION;

    return DP_OK;

	// not a fall through

CLEANUP_EXIT:

	OS_CryptDestroyKey(hEncryptionKey);
	OS_CryptDestroyKey(hPublicKey);
    OS_CryptReleaseContext(hCSP,0);
    if (phCredential) 
	{
		OS_FreeCredentialHandle(phCredential);
		DPMEM_FREE(phCredential);
	}

    if (pPublicKeyBuffer) DPMEM_FREE(pPublicKeyBuffer);
    return hr;

} // LoadSecurityProviders


#undef DPF_MODNAME
#define DPF_MODNAME	"GenerateAuthenticationMessage"

//+----------------------------------------------------------------------------
//
//  Function:   GenerateAuthenticateMessage
//
//  Description:   This function calls InitializeSecurityContext to generate 
//              an authentication message and sends it to the server.  
//              It generates different authentication messages depending on 
//              whether there's security token from the server to be used 
//              as input message or not (i.e. whether pInMsg is NULL).
//
//  Arguments:  this - pointer to dplay object
//              pInMsg - pointer to the server's authentication message '
//                       containing the security token.
//              fContextReq - security context flags
//
//  Returns:    DP_OK, DPERR_OUTOFMEMORY, DPERR_AUTHENTICATIONFAILED, DPERR_LOGONDENIED
//
//-----------------------------------------------------------------------------
HRESULT
GenerateAuthenticationMessage (
    LPDPLAYI_DPLAY          this,
    LPMSG_AUTHENTICATION    pInMsg,
    ULONG                   fContextReq
    )
{
    PCtxtHandle phCurrContext;
    DWORD dwOutMsgType, dwHeaderSize;
    SECURITY_STATUS status;
    SecBufferDesc inSecDesc, outSecDesc;
    SecBuffer     inSecBuffer, outSecBuffer;
    PSecBufferDesc pInSecDesc;
    ULONG     fContextAttrib;
    TimeStamp tsExpireTime;
    DWORD dwMessageSize;
    LPBYTE pSendBuffer=NULL;
    LPMSG_AUTHENTICATION pOutMsg=NULL;
    HRESULT hr;

    ASSERT(this->pSysPlayer);
    ASSERT(this->phCredential);

    if (pInMsg == NULL)
    {
        DPF(6, "Generating a negotiate message");
        //
        // This is the first time this function has been called, so the
        // message generated will be a MSG_NEGOTIATE.
        //
        phCurrContext = NULL;
        dwOutMsgType = DPSP_MSG_NEGOTIATE;
        pInSecDesc = NULL;

        // do we already have a security context ?
        if (this->phContext)
        {
            // get rid of it - we are re-negotiating
            DPF(5, "Removing existing security context");

            OS_DeleteSecurityContext(this->phContext);
            DPMEM_FREE(this->phContext);
            this->phContext = NULL;
        }

        //
        // Allocate memory to hold client's security context handle
        //
        this->phContext = DPMEM_ALLOC(sizeof(CtxtHandle));
        if (!this->phContext)
        {
            DPF_ERR("Failed to allocate security context handle - out of memory");
            return DPERR_OUTOFMEMORY;
        }
		DPF(6,"System player phContext=0x%08x", this->phContext);
    }
    else
    {
		DPF(6,"Using phContext=0x%08x for authentication",this->phContext);
        phCurrContext = this->phContext;
        dwOutMsgType = DPSP_MSG_CHALLENGERESPONSE;

        //
        // Setup API's input security buffer to pass the client's negotiate
        // message to the SSPI.
        //
        inSecDesc.ulVersion = SECBUFFER_VERSION;
        inSecDesc.cBuffers = 1;
        inSecDesc.pBuffers = &inSecBuffer;

        inSecBuffer.cbBuffer = pInMsg->dwDataSize;
        inSecBuffer.BufferType = SECBUFFER_TOKEN;
        inSecBuffer.pvBuffer = (LPBYTE)pInMsg + pInMsg->dwDataOffset;

        pInSecDesc = &inSecDesc;
    }

    dwHeaderSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION);

    //
    // Allocate memory for send buffer. 
    //
    pSendBuffer = DPMEM_ALLOC( dwHeaderSize + this->ulMaxContextBufferSize);

    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate authenticate message - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Setup API's output security buffer for receiving challenge message
    // from the SSPI.
    // Pass the client message buffer to SSPI via pvBuffer.
    //

    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.cbBuffer = this->ulMaxContextBufferSize;
    outSecBuffer.BufferType = SECBUFFER_TOKEN;
    outSecBuffer.pvBuffer = pSendBuffer + dwHeaderSize;

    // determine the security context requirements
    fContextReq |= DPLAY_SECURITY_CONTEXT_REQ;

    //
    //  If user credential has been supplied, and if 'prompt user' flag has not 
    //  been set, SSPI will use the supplied credential
    //
    if (this->pUserCredentials)
    {
		DPF(6, "Using supplied credentials");
    }

    ASSERT(this->phContext);

    //
    // Generate a negotiate/challenge response message to be sent to the server.
    //    
    status = OS_InitializeSecurityContext(
        this->phCredential,                     // phCredential
        phCurrContext,                          // phContext
        NULL,                                   // pszTargetName
        fContextReq,                            // fContextReq
        0L,                                     // reserved1
        SECURITY_NATIVE_DREP,                   // TargetDataRep
        pInSecDesc,                             // pInput
        0L,                                     // reserved2
        this->phContext,                        // phNewContext
        &outSecDesc,                            // pOutput negotiate msg
        &fContextAttrib,                        // pfContextAttribute
        &tsExpireTime                           // ptsLifeTime
        );

    if (!SEC_SUCCESS(status))
    {
        //
        // Failure
        //
        if (SEC_E_NO_CREDENTIALS == status)           
        {
            //
            // If SSPI does not have user credentials, let the app collect them and try again
            // Note that we never allow the package to collect credentials. This is because of
            // two reasons:
            // 1. Apps don't like windows' dialogs popping up while they are page
            //    flipping.
            // 2. Not all security packages collect credentials (NTLM for one).
            //
            DPF(6, "No credentials specified. Ask user.");
            hr = DPERR_LOGONDENIED;
            goto CLEANUP_EXIT;
        }
        else
        {
            DPF(0,"Authentication message generation failed [0x%08x]\n", status);
            hr = status;
            goto CLEANUP_EXIT;
        }
    }
    else
    {
        //
        // Success
        //
        if ((SEC_I_CONTINUE_NEEDED != status) &&
            (SEC_E_OK != status)) 
        {
            DPF_ERRVAL("SSPI provider requested unsupported functionality [0x%08x]",status);
            ASSERT(FALSE);
            hr = status;
            goto CLEANUP_EXIT;
        }

        // fall through will send the message
    }

    //
    // Setup pointer to the security message portion of the buffer
    //
    pOutMsg = (LPMSG_AUTHENTICATION)(pSendBuffer + this->dwSPHeaderSize);

    //
    // Setup directplay system message header 
    //
	SET_MESSAGE_HDR(pOutMsg);
    SET_MESSAGE_COMMAND(pOutMsg, dwOutMsgType);
    pOutMsg->dwIDFrom = this->pSysPlayer->dwID;
    pOutMsg->dwDataSize = outSecBuffer.cbBuffer;
    pOutMsg->dwDataOffset = sizeof(MSG_AUTHENTICATION);

    //
    // Calculate actual message size to be sent
    //
    dwMessageSize = dwHeaderSize + outSecBuffer.cbBuffer;
    
    DPF(9,"Sending type = %d, length = %d\n", dwOutMsgType, dwMessageSize);

    //
    // Send message to the server
    //
    hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
    					dwMessageSize,DPSEND_GUARANTEED,FALSE);
	if (FAILED(hr))
    {
        DPF(0,"Send Msg (type:%d) Failed: ret = %8x\n", dwOutMsgType, hr);
        goto CLEANUP_EXIT;
    }

    // Success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:

	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
    return hr;

}   // GenerateAuthenticationMessage


#undef DPF_MODNAME
#define DPF_MODNAME "SendAuthenticationResponse"

HRESULT SetupLogonDeniedMsg(LPDPLAYI_DPLAY this, LPMSG_AUTHENTICATION pMsg, LPDWORD pdwMsgSize, DPID dpidClient)
{
    HRESULT hr;

    ASSERT(pMsg);
    ASSERT(pdwMsgSize);

    SET_MESSAGE_COMMAND(pMsg, DPSP_MSG_LOGONDENIED);
    *pdwMsgSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
    //
    // We don't need the client information anymore, get rid of it.
    //
    hr = RemoveClientFromNameTable(this, dpidClient);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove security context for player %d", dpidClient);
    }

    return hr;
}

HRESULT SetupAuthErrorMsg(LPDPLAYI_DPLAY this, LPMSG_AUTHENTICATION pMsg, HRESULT hResult, LPDWORD pdwMsgSize, DPID dpidClient)
{
    HRESULT hr;
    LPMSG_AUTHERROR pAuthError = (LPMSG_AUTHERROR)pMsg;

    ASSERT(pMsg);
    ASSERT(pdwMsgSize);

    //
    // setup an authentication error message
    //
    SET_MESSAGE_COMMAND(pAuthError, DPSP_MSG_AUTHERROR);
    pAuthError->hResult = hResult;
    *pdwMsgSize = GET_MESSAGE_SIZE(this,MSG_AUTHERROR);
    //
    // We don't need the client information anymore, get rid of it.
    //
    hr = RemoveClientFromNameTable(this, dpidClient);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove security context for player %d", dpidClient);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SendAuthenticationResponse
//
//  Description:   This function generates and sends an authentication response 
//              to the client.  It will generate and send either a challenge 
//              or the final authentication result to client depending on 
//              the type of client message (pointed to by pInMsg) passed 
//              to this function.
//
//  Arguments:  this - pointer to dplay object
//              pInMsg - Points to the authentication message received from
//                       the server
//              pvSPHeader - pointer to reply sp header
//
//  Returns:    DPERR_OUTOFMEMORY or result form DoReply
//
//-----------------------------------------------------------------------------
HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    LPVOID pvSPHeader
    )
{
    PCtxtHandle    phInContext=NULL, phOutContext=NULL;
    LPBYTE pSendBuffer=NULL;
    LPMSG_AUTHENTICATION pOutMsg;
    SecBufferDesc inSecDesc, outSecDesc;
    SecBuffer     inSecBuffer, outSecBuffer;
    ULONG         fContextReq;
    ULONG         fAttribute;
    TimeStamp     tsExpireTime;
    SECURITY_STATUS status;
    DWORD dwHeaderSize=0, dwMessageSize=0, dwCommand, dwBufferSize;
    HRESULT hr;
    LPCLIENTINFO pClientInfo=NULL;
    DWORD_PTR dwItem;

    ASSERT(this->pSysPlayer);
    ASSERT(this->phCredential);
    ASSERT(pInMsg);

    // retrieve client info stored in nametable
    dwItem = NameFromID(this, pInMsg->dwIDFrom);
    pClientInfo = (LPCLIENTINFO) DataFromID(this, pInMsg->dwIDFrom);

    //
    // Which message did we get 
    //
    dwCommand = GET_MESSAGE_COMMAND(pInMsg);
    
    if (DPSP_MSG_NEGOTIATE == dwCommand)
    {
		DPF(6, "Received a negotiate message from player %d", pInMsg->dwIDFrom);

        phInContext = NULL;

        if (NAMETABLE_PENDING == dwItem)
		{
            if (pClientInfo)
            {
                // client has sent us another negotiate message instead of responding to our 
                // challenge. This can happen if communication link breaks down after the server 
                // responds to a negotiate.
			    DPF(6,"Removing existing information about client");

			    hr = RemoveClientInfo(pClientInfo);
                DPMEM_FREE(pClientInfo);
            }
		}
        else
        {
            // it's a duplicate id, we shouldn't be in this state
            DPF_ERRVAL("Player %d already exists in the nametable", pInMsg->dwIDFrom);
            ASSERT(FALSE);
            // don't respond for now 
            return DPERR_INVALIDPLAYER;
            // todo - we might want to send an error message.
        }

        //
        // Allocate memory to hold client information
        //
        pClientInfo = DPMEM_ALLOC(sizeof(CLIENTINFO));
        if (!pClientInfo)
        {
            DPF_ERR("Failed to allocate memory for client information - out of memory");
            return DPERR_OUTOFMEMORY;
        }
        //
        // Remember the pointer in the nametable temporarily
        //
        hr = SetClientInfo(this, pClientInfo, pInMsg->dwIDFrom);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to add client info to nametable for player %d", pInMsg->dwIDFrom);
            RemoveClientInfo(pClientInfo);
            DPMEM_FREE(pClientInfo);
            return hr;
        }

        phOutContext = &(pClientInfo->hContext);
    }
    else
    {
		DPF(6, "Received a challenge response from player %d", pInMsg->dwIDFrom);

        ASSERT(NAMETABLE_PENDING == dwItem);
        ASSERT(pClientInfo);

        //
        // Get the player context from name table
        //
        phInContext = phOutContext = &(pClientInfo->hContext);
    }

    DPF(6, "Using phInContext=0x%08x and phOutContext=0x%08x", phInContext, phOutContext);
    // 
    // Calculate buffer size needed for response. We are always allocating enough room 
    // for an authentication message. We use the same buffer to send access granted,
    // denied, or error system messages.
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION) + this->ulMaxContextBufferSize;

    //
    // Allocate memory for the buffer.
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for response - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Setup pointer to the message portion of the buffer
    //
    pOutMsg = (LPMSG_AUTHENTICATION) (pSendBuffer + this->dwSPHeaderSize);

    //
    // Fill directplay system message header in the outgoing message buffer
    //
	SET_MESSAGE_HDR(pOutMsg);
    pOutMsg->dwDataOffset = sizeof(MSG_AUTHENTICATION);
    pOutMsg->dwIDFrom = this->pSysPlayer->dwID;

    //
    // Setup API's input security buffer to pass the client's negotiate
    // message to the SSPI.
    //
    inSecDesc.ulVersion = SECBUFFER_VERSION;
    inSecDesc.cBuffers = 1;
    inSecDesc.pBuffers = &inSecBuffer;

    inSecBuffer.cbBuffer = pInMsg->dwDataSize;
    inSecBuffer.BufferType = SECBUFFER_TOKEN;
    inSecBuffer.pvBuffer = (LPBYTE)pInMsg + pInMsg->dwDataOffset;

    //
    // Setup API's output security buffer for receiving challenge message
    // from the SSPI.
    //
    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.cbBuffer = this->ulMaxContextBufferSize;
    outSecBuffer.BufferType = SECBUFFER_TOKEN;
    outSecBuffer.pvBuffer = (LPBYTE)pOutMsg + sizeof(MSG_AUTHENTICATION);

    // enfore the following requirements on the context 
    fContextReq = DPLAY_SECURITY_CONTEXT_REQ;

    ASSERT(phOutContext);

    //
    // pass it to the security package
    //
    status = OS_AcceptSecurityContext(
        this->phCredential, 
        phInContext, 
        &inSecDesc,
        fContextReq, 
        SECURITY_NATIVE_DREP, 
        phOutContext,
        &outSecDesc, 
        &fAttribute, 
        &tsExpireTime
        );

    if (!SEC_SUCCESS(status))
    {
        //
        // Failure
        //
        if ((SEC_E_LOGON_DENIED == status) ||
            (SEC_E_TARGET_UNKNOWN == status))
        {
            hr = SetupLogonDeniedMsg(this, pOutMsg, &dwMessageSize, pInMsg->dwIDFrom);
        }
        else
        {
            // Some other error occured - send an auth error message

            DPF_ERRVAL("Process authenticate request failed [0x%8x]\n", status);

            hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
        }
    }
    else
    {
        //
        // Success
        //
        if (SEC_E_OK == status)
        {
            //
            // Set up the max signature size for this package here. Although, 
            // the signature size is independent of the context, the only way to get it
            // in SSPI is through QueryContextAttributes (tied to a context). This
            // is why we setup this member here when the first client logs in.
            //
            if (0 == this->ulMaxSignatureSize)
            {
                hr = SetupMaxSignatureSize(this,phOutContext);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get signature size - not sending access granted message");

                    hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
                }
            }

            if (this->ulMaxSignatureSize)
            {
                // send an access granted message to the client
                DPF(6, "Sending access granted message");
                // 
                // Send an access granted message
                //
                hr = SendAccessGrantedMessage(this, pInMsg->dwIDFrom, pvSPHeader);
                if (FAILED(hr))
                {
                    DPF_ERRVAL("Failed to send access granted message: hr=0x%08x",hr);
                }
                // exit as we have already sent the message
                goto CLEANUP_EXIT;
            }

        }
        else if (SEC_I_CONTINUE_NEEDED == status)
        {
            DPF(6, "Sending challenge message");
            //
            // setup a challenge message
            //
            SET_MESSAGE_COMMAND(pOutMsg, DPSP_MSG_CHALLENGE);
            pOutMsg->dwDataSize = outSecBuffer.cbBuffer;
            dwMessageSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION) + outSecBuffer.cbBuffer;
        }
        else
        {
            // todo - we do not support complete auth token at this time
            DPF_ERRVAL("SSPI provider requested unsupported functionality [0x%8x]", status);

            hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
        }
    }

    // fall through will send the message

    //
    // Send reply to the client. We are using DoReply instead of SendDPMessage 
    // because we don't have a system player yet.
    //
    hr = DoReply(this, pSendBuffer, dwMessageSize, pvSPHeader, 0);
    if (FAILED(hr))
    {
        DPF(0, 
            "Send Authentication response failed for client[%d]\n",
            pInMsg->dwIDFrom);
    }

    // fall through

CLEANUP_EXIT:
    // cleanup allocations
    if (pSendBuffer) DPMEM_FREE(pSendBuffer);

    return hr;

}   // SendAuthenticationResponse

VOID CopyScatterGatherToContiguous(PUCHAR pBuffer, LPSGBUFFER lpSGBuffers, UINT cBuffers, DWORD dwTotalSize)
{
	DWORD offset=0;
	UINT i;
	// copy the SG buffers into the single buffer. 
	for(i=0;i<cBuffers;i++){
		memcpy(pBuffer+offset,lpSGBuffers[i].pData,lpSGBuffers[i].len);
		offset+=lpSGBuffers[i].len;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageEx"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageEx
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. Signing
//              is done with SSPI and encryption with CAPI.
//
//  Arguments:  this - pointer to dplay object
//              psp  - pointer to send parameter structure
//              bDropLock - flag whether to drop DPLAY_LOCK when calling SP
//              
//  Returns:    DPERR_OUTOFMEMORY, result from SignBuffer, EncryptBufferCAPI,
//              or SendDPMessage().
//
// NOTE: see SecureSendDPMessageCAPIEx
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize, dwMsgSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;


    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(psp->dwFlags & DPSEND_GUARANTEED);

    //
    // Get the signing security context handle
    //
    if (IAM_NAMESERVER(this))
    {
		// if destination player is a system player, use the info stored in it
		if (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
		{
	        phContext = &(psp->pPlayerTo->pClientInfo->hContext);
	        phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
		}
		else
		{
			// if destination player is a user player
            // use the security context of the corresponding system player
			psp->pPlayerTo = PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
			if (!psp->pPlayerTo)
			{
				DPF_ERR("Invalid player id - can't get security context handle");
				return DPERR_INVALIDPLAYER;
			}
			phContext = &(psp->pPlayerTo->pClientInfo->hContext);
			phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client

        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + this->dwSPHeaderSize/*workaround*/ + psp->dwTotalSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        hr=E_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);

    //
    // Setup message information on the send buffer
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    // Copy message data
    CopyScatterGatherToContiguous((LPBYTE)pSecureMsg+sizeof(MSG_SECURE)+this->dwSPHeaderSize/*workaround*/, 
    								psp->Buffers, psp->cBuffers, psp->dwTotalSize);

    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    dwMsgSize=pSecureMsg->dwDataSize = psp->dwTotalSize+this->dwSPHeaderSize/*workaround*/;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (psp->dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;

        //
        // Encrypt the message. 
        //
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		(psp->pPlayerFrom) ? psp->pPlayerFrom->dwID : 0, 
		(psp->pPlayerTo) ? psp->pPlayerTo->dwID : 0,
		phContext);

    // 
    // Sign the entire message in the buffer (including the wrapper) . 
    // Signature follows the message.
    //
    hr = SignBuffer(phContext,                          // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize, 	                    // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

	ASSERT(dwSigSize <= this->ulMaxSignatureSize);
	#if 0
		if(dwSigSize > this->ulMaxSignatureSize){
			DEBUG_BREAK();
		}
	#endif	

    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    //
    // Send the message
    //
    hr=InternalSendDPMessage(this, psp->pPlayerFrom, psp->pPlayerTo, 
    						 pSendBuffer, GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize+dwSigSize,
    						 psp->dwFlags & ~(DPSEND_ENCRYPTED | DPSEND_SIGNED),
    						 bDropLock);
	
CLEANUP_EXIT:    

	if(pSendBuffer){
		DPMEM_FREE(pSendBuffer);
	}

	return hr;	// since all alloc is on psp, it will get freed with the psp.

} // SecureSendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessage"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessage
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. Signing
//              is done with SSPI and encryption with CAPI.
//
//  Arguments:  this - pointer to dplay object
//              pPlayerFrom - pointer to sending player
//              pPlayerTo - pointer to receiving player
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (guaranteed,encrypted,signed,etc.)
//              
//  Returns:    DPERR_OUTOFMEMORY, result from SignBuffer, EncryptBufferCAPI,
//              or SendDPMessage().
//
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessage(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(dwFlags & DPSEND_GUARANTEED);

    //
    // Get the signing security context handle
    //
    if (IAM_NAMESERVER(this))
    {
		// if destination player is a system player, use the info stored in it
		if (pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
		{
	        phContext = &(pPlayerTo->pClientInfo->hContext);
	        phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
		}
		else
		{
			// if destination player is a user player
            // use the security context of the corresponding system player
			pPlayerTo = PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
			if (!pPlayerTo)
			{
				DPF_ERR("Invalid player id - can't get security context handle");
				return DPERR_INVALIDPLAYER;
			}
			phContext = &(pPlayerTo->pClientInfo->hContext);
			phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client

        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        return E_OUTOFMEMORY;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);

    //
    // Setup message information on the send buffer
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    // Copy message data
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);
    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;

        //
        // Encrypt the message. 
        //
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                    // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		(pPlayerFrom) ? pPlayerFrom->dwID : 0, 
		(pPlayerTo) ? pPlayerTo->dwID : 0,
		phContext);

    // 
    // Sign the entire message in the buffer (including the wrapper) . 
    // Signature follows the message.
    //
    hr = SignBuffer(phContext,                          // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize, 	                    // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    
    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    // since dplay is providing security, toggle the flags off
    dwFlags &= ~(DPSEND_ENCRYPTED | DPSEND_SIGNED);

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, pPlayerFrom, pPlayerTo, pSendBuffer, 
        GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize, dwFlags, bDropLock);
    //
    // Fall through
    //
CLEANUP_EXIT:    
    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);

	return hr;

} // SecureSendDPMessage

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageCAPIEx"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageCAPIEx
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. 
//              Signing and encryption both are done using CAPI.
//
//  Arguments:  this - pointer to dplay object
//				psp  - pointer to send parameters
//              bDropLock - whether to drop DPLAY_LOCK() when calling SP
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_GENERIC, result from EncryptBufferCAPI,
//              or SendDPMessage().
//
//
// NOTE: we have to add in a dummy SP header to be encrypted with the message
//       because that's how the old version did it, and we must be compatible.
//       So as not to confuse all workarounds from what it would have been 
//       are marked with "workaround".
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageCAPIEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock) 
{

	LPBYTE pMsg;
	DWORD  dwMsgSize;
	DWORD  dwMsgSizeMax;

	DWORD dwSigSize;
	HRESULT hr = DPERR_GENERIC;
    HCRYPTKEY *phEncryptionKey=NULL;
	HCRYPTHASH hHash=0;
	DWORD MaxSign=100;
	LPMSG_SECURE pSecureMsg;


    ASSERT(this->pSysPlayer);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(psp->dwFlags & DPSEND_GUARANTEED);


	dwMsgSize = psp->dwTotalSize+this->dwSPHeaderSize/*workaround*/;
	dwMsgSizeMax = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + MaxSign;
	
	pMsg = DPMEM_ALLOC(dwMsgSizeMax);

	if(!pMsg){
		DPF_ERR("Failed to allocate contiguous encryption buffer - out of memory\n");
		return DPERR_OUTOFMEMORY;
	}

	pSecureMsg=(LPMSG_SECURE)(pMsg+this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pSecureMsg);
	SET_MESSAGE_COMMAND(pSecureMsg, DPSP_MSG_SIGNED);

	CopyScatterGatherToContiguous(pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE)+this->dwSPHeaderSize/*workaround*/,
								  psp->Buffers,psp->cBuffers,psp->dwTotalSize);

    pSecureMsg->dwIDFrom     = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize   = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags      = DPSECURE_SIGNEDBYCAPI;
	//pSecureMsg->dwSignatureSize =			(filled in below when we know it)

	if (psp->dwFlags & DPSEND_ENCRYPTED)
	{
		// Encrypt the BODY of the message only
	
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
		//
		// Get the encryption key
		//
		if (IAM_NAMESERVER(this))
		{
			// if destination player is a system player, use the info stored in it
			if (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
			}
			else
			{
				// if destination player is a user player
				// use the security context of the corresponding system player
				psp->pPlayerTo = PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
				if (!psp->pPlayerTo)
				{
					DPF_ERR("Invalid player id - can't get security context handle");
					hr = DPERR_INVALIDPLAYER;
					goto CLEANUP_EXIT;
				}
				phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
			}
		}
		else
		{
			// client
			phEncryptionKey = &(this->hEncryptionKey);
		}

		ASSERT(phEncryptionKey);

		//
		// Encrypt the buffer in place. Since we only allow stream ciphers, the size of 
		// the decrypted data will be equal to the original size.
		//
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE),		    // pointer to data
            &dwMsgSize                                      // size of data
			);
			
		if (FAILED(hr))
		{
			DPF_ERRVAL("Failed to encrypt the buffer: Error=0x%08x",hr);
			goto CLEANUP_EXIT;
		}
	}

	DPF(6,"Using CAPI for signing");

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE), dwMsgSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	// Determine size of signature
	dwSigSize = 0;
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigSize)) 
	{
		DWORD dwError=GetLastError();
		DPF_ERRVAL("Error %x during CryptSignHash!\n", dwError);
		if(dwError!=NTE_BAD_LEN) 
		{
			hr=DPERR_GENERIC;
			goto CLEANUP_EXIT;
		}
	}

	#ifdef DEBUG
	if(dwSigSize > MaxSign){
		DPF(0,"Buffer too Small, requested signature of size %d only allocated %d\n",dwSigSize, MaxSign);
		DEBUG_BREAK();
	}
	#endif

	pSecureMsg->dwSignatureSize = dwSigSize;

	// Sign hash object.
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, 
		pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize, &dwSigSize)) 
	{
		// Warning, error may be incorrect since OS_CryptSignHash may call out and
		// cause the LastError to be changed.
		DPF_ERRVAL("Error %x during CryptSignHash! (WARINING, error may be incorrect)\n", GetLastError());
		goto CLEANUP_EXIT;
	}

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, psp->pPlayerFrom, psp->pPlayerTo, 
							   pMsg, GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize+dwSigSize,
							   psp->dwFlags & ~(DPSEND_ENCRYPTED | DPSEND_SIGNED),
							   bDropLock);

    //
    // Fall through
    //
CLEANUP_EXIT:    

	if(pMsg){
		DPMEM_FREE(pMsg);
	}

	// clean up allocated objects
	OS_CryptDestroyHash(hHash);

	return hr;
	
} // SecureSendDPMessageCAPIEx

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageCAPI
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. 
//              Signing and encryption both are done using CAPI.
//
//  Arguments:  this - pointer to dplay object
//              pPlayerFrom - pointer to sending player
//              pPlayerTo - pointer to receiving player
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (guaranteed,encrypted,signed,etc.)
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_GENERIC, result from EncryptBufferCAPI,
//              or SendDPMessage().
//
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageCAPI(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL, pLocalCopy=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr = DPERR_GENERIC;
    HCRYPTKEY *phEncryptionKey=NULL;
	HCRYPTHASH hHash=0;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(dwFlags & DPSEND_GUARANTEED);

	if (dwFlags & DPSEND_ENCRYPTED)
	{
		//
		// Make a copy of the message, so we don't destroy the original message.
		// Sending messages to groups will not work otherwise.
		//
		// todo - update code to avoid the extra copy
		//
		pLocalCopy = DPMEM_ALLOC(dwMsgSize);
		if (!pLocalCopy)
		{
			DPF_ERR("Failed to make a local copy of message for encryption - out of memory");
			return DPERR_OUTOFMEMORY;
		}

		// copy the message into the buffer
		memcpy(pLocalCopy, pMsg, dwMsgSize);

		// now point to the local copy of the message
		pMsg = pLocalCopy;

		//
		// Get the encryption key
		//
		if (IAM_NAMESERVER(this))
		{
			// if destination player is a system player, use the info stored in it
			if (pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
			}
			else
			{
				// if destination player is a user player
				// use the security context of the corresponding system player
				pPlayerTo = PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
				if (!pPlayerTo)
				{
					DPF_ERR("Invalid player id - can't get security context handle");
					hr = DPERR_INVALIDPLAYER;
					goto CLEANUP_EXIT;
				}
				phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
			}
		}
		else
		{
			// client
			phEncryptionKey = &(this->hEncryptionKey);
		}

		ASSERT(phEncryptionKey);

		//
		// Encrypt the buffer in place. Since we only allow stream ciphers, the size of 
		// the decrypted data will be equal to the original size.
		//
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            pMsg,										    // pointer to data
            &dwMsgSize                                      // size of data
			);
		if (FAILED(hr))
		{
			DPF_ERRVAL("Failed to encrypt the buffer: Error=0x%08x",hr);
			goto CLEANUP_EXIT;
		}
	}

	DPF(6,"Using CAPI for signing");

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, pMsg, dwMsgSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Determine size of signature
	dwSigSize = 0;
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigSize)) 
	{
		DWORD dwError=GetLastError();
		DPF_ERRVAL("Error %x during CryptSignHash!\n", dwError);
		if(dwError!=NTE_BAD_LEN) 
		{
			goto CLEANUP_EXIT;
		}
	}

	// Allocate memory for the signature
	// We allocate the send buffer and just put the signature directly into it

	dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize;

	pSendBuffer = DPMEM_ALLOC(dwBufferSize);
	if (!pSendBuffer)
	{
		DPF_ERR("Failed to allocate send buffer - out of memory");
		goto CLEANUP_EXIT;
	}

    // Copy message data into the send buffer
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);

    //
    // Setup message information
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYCAPI;
	if (dwFlags & DPSEND_ENCRYPTED)
	{
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
	}
    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
    pSecureMsg->dwSignatureSize = dwSigSize;

	// todo - do we want to add a description to the signature ?

	// Sign hash object.
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, 
		pSendBuffer+GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize, &dwSigSize)) 
	{
		// WARNING The LastError may be incorrect since OS_CryptSignHash may call out
		// to DPF which can change the LastError value.
		DPF_ERRVAL("Error %x during CryptSignHash! (WARNING, error may be incorrect)\n", GetLastError());
		goto CLEANUP_EXIT;
	}
    
    // since dplay is providing security, toggle the flags off
    dwFlags &= ~(DPSEND_ENCRYPTED | DPSEND_SIGNED);

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, pPlayerFrom, pPlayerTo, pSendBuffer, dwBufferSize, dwFlags,bDropLock);

    //
    // Fall through
    //
CLEANUP_EXIT:    

	// clean up allocated objects
	OS_CryptDestroyHash(hHash);

    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pLocalCopy) DPMEM_FREE(pLocalCopy);

	return hr;

} // SecureSendDPMessageCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureDoReply"
//+----------------------------------------------------------------------------
//
//  Function:   SecureDoReply
//
//  Description:This function is used to send a signed or encrypted reply message. 
//              It is only used by the server to send secure messages to the client
//              during client logon.
//
//  Arguments:  this - pointer to dplay object
//              dpidFrom - sending player id
//              dpidTo - receiving player id
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (encrypted or signed)
//              pvSPHeader - sp header used for replying
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_INVALIDPLAYER, result from SignBuffer, 
//              EncryptBufferSSPI, or DoReply
//
//-----------------------------------------------------------------------------
HRESULT 
SecureDoReply(
    LPDPLAYI_DPLAY this,
	DPID dpidFrom,
	DPID dpidTo,
	LPBYTE pMsg,
	DWORD dwMsgSize,
	DWORD dwFlags,
	LPVOID pvSPHeader
	)
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);

    //
    // Get security context handle to use
    //
    if (IAM_NAMESERVER(this))
    {
		DWORD_PTR dwItem;

		dwItem = NameFromID(this,dpidTo);
		if (!dwItem)
		{
			DPF_ERR("Failed to send secure reply - invalid destination player");
			return DPERR_INVALIDPLAYER;
		}
		// we have a valid dest player id
		if (NAMETABLE_PENDING == dwItem)
		{
    	    // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = DataFromID(this, dpidTo);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

		    phContext = &(pClientInfo->hContext);
		    phEncryptionKey = &(pClientInfo->hEncryptionKey);
		}
		else 
		{
			// player has logged in
	        phContext = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hContext);
	        phEncryptionKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client side
        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        return E_OUTOFMEMORY;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);
    // Copy message data
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);

    //
    // Setup message information
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    pSecureMsg->dwIDFrom = dpidFrom;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                    // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		dpidFrom, dpidTo, phContext);

    // 
    // Sign the entire message (including the wrapper) in the buffer. 
    // Signature follows the message.
    //
    hr = SignBuffer(
		phContext,			                            // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize,                         // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    
    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    //
    // Send the message
    //
	hr = DoReply(this, pSendBuffer, GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize, 
		pvSPHeader, 0);
    //
    // Fall through
    //
CLEANUP_EXIT:    
    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);

	return hr;

} // SecureDoReply

#undef DPF_MODNAME
#define DPF_MODNAME	"SignBuffer"
//+----------------------------------------------------------------------------
//
//  Function:   SignBuffer
//
//  Description:This function signs a data buffer and puts the signature in it.
//
//  Arguments:  phContext - pointer to signing security context handle
//              pBuffer - data buffer
//              dwBufferSize - size of the buffer
//              pSig - signature buffer
//              pdwSigSize - pointer to signature size
//
//  Returns:    DP_OK if success, otherwise DPERR_SIGNFAILED.
//
//-----------------------------------------------------------------------------
HRESULT 
SignBuffer(
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    DWORD dwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc outSecDesc;
    SecBuffer outSecBuffer[2];
    SECURITY_STATUS status;

    ASSERT(pBuffer && pSig && pdwSigSize);

    DPF(6,"Signing buffer: data: %d",dwBufferSize);
    DPF(6,"Signing buffer: sig: %d",*pdwSigSize);

    // 
    // Setup message buffer to be signed
    //
    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 2;
    outSecDesc.pBuffers = &outSecBuffer[0];

    outSecBuffer[0].cbBuffer = dwBufferSize;
    outSecBuffer[0].BufferType = SECBUFFER_DATA;
    outSecBuffer[0].pvBuffer = pBuffer;

    outSecBuffer[1].cbBuffer = *pdwSigSize;
    outSecBuffer[1].BufferType = SECBUFFER_TOKEN;
    outSecBuffer[1].pvBuffer = pSig;

    //
    // Sign the message
    //
    status = OS_MakeSignature(
        phContext,         // phContext
        0,                  // fQOP (Quality of Protection)
        &outSecDesc,        // pMessage
        0                   // MessageSeqNo
        );

    if (!SEC_SUCCESS(status))
    {
        DPF(0,"Buffer couldn't be signed: 0x%08x", status);
        return DPERR_SIGNFAILED;
    }

    //
    // Return the actual signature size
    //
    *pdwSigSize = outSecBuffer[1].cbBuffer;

    // 
    // Success
    //
	return DP_OK;

} // SignBuffer


#undef DPF_MODNAME
#define DPF_MODNAME "VerifyBuffer"
//+----------------------------------------------------------------------------
//
//  Function:   VerifyBuffer
//
//  Description:This function verifies the digital signature of a data buffer, given
//              the signature
//
//  Arguments:  hContext - Handle to client's security context
//              pBuffer - Points to signed message 
//              dwBufferSize - Size of the message
//              pSig - Points to the signature
//              dwSigSize - Size of the signature
// 
//  Returns:    DP_OK if signature verifies OK. Otherwise, DPERR_VERIFYFAILED is returned.
//
//-----------------------------------------------------------------------------
HRESULT 
VerifyBuffer(
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    DWORD dwBufferSize, 
    LPBYTE pSig, 
    DWORD dwSigSize
    )
{
    SECURITY_STATUS status;
    SecBufferDesc inSecDesc;
    SecBuffer inSecBuffer[2];

    DPF(6,"Verifying buffer: data: %d",dwBufferSize);
    DPF(6,"Verifying buffer: sig: %d",dwSigSize);

    inSecDesc.ulVersion = SECBUFFER_VERSION;
    inSecDesc.cBuffers = 2;
    inSecDesc.pBuffers = &inSecBuffer[0];

    inSecBuffer[0].cbBuffer = dwBufferSize;
    inSecBuffer[0].BufferType = SECBUFFER_DATA;
    inSecBuffer[0].pvBuffer = pBuffer;
    inSecBuffer[1].cbBuffer = dwSigSize;
    inSecBuffer[1].BufferType = SECBUFFER_TOKEN;
    inSecBuffer[1].pvBuffer = pSig;

    status = OS_VerifySignature(phContext, &inSecDesc, 0, 0);

    if (!SEC_SUCCESS(status))
    {
        DPF(0,"******** Buffer verification failed: 0x%08x ********", status);
        return DPERR_VERIFYSIGNFAILED;
    }

    //
    // Success
    //
    return DP_OK;

}   // VerifyBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "VerifySignatureSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   VerifySignatureSSPI
//
//  Description:This function verifies the digital signature on a secure message using
//              the Security Support Provider Interface (SSPI).
//
//  Arguments:  this - pointer to dplay object
//              phContext - pointer to verification security context handle
//              pReceiveBuffer - signed message received from transport sp
//              dwMessageSize - size of the message
// 
//  Returns:    DP_OK, result from VerifyBuffer() or DecryptBuffer()
//
//-----------------------------------------------------------------------------
HRESULT 
VerifySignatureSSPI(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    )
{
    PCtxtHandle phContext=NULL;
    DWORD_PTR dwItem;
    HRESULT hr;
    LPMSG_SECURE pSecureMsg = (LPMSG_SECURE) pReceiveBuffer;

	DPF(6,"Using SSPI for Signature verification");
    //
    // Retrieve security context handle to verify the message
    //
    if (IAM_NAMESERVER(this))
    {
        dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
        if (0==dwItem)
        {
            DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
            return DPERR_INVALIDPLAYER;
        }
        if (NAMETABLE_PENDING == dwItem)
        {
            // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = (LPCLIENTINFO) DataFromID(this,pSecureMsg->dwIDFrom);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

            phContext = &(pClientInfo->hContext);
        }
        else
        {
            // player has logged in
            phContext = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hContext);
        }
    }
    else
    {
        // client
        phContext = this->phContext;
    }

	//
	// Verify signature
	//
    hr = VerifyBuffer( 
        phContext,                                       // sec context handle
		(LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,	 // pointer to embedded message
		pSecureMsg->dwDataSize,							 // size of embedded message
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset + pSecureMsg->dwDataSize,
														 // pointer to signature
        pSecureMsg->dwSignatureSize                      // size of signature
        );

    return hr;

}   // VerifySignatureSSPI

#undef DPF_MODNAME
#define DPF_MODNAME "VerifySignatureCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   VerifySignatureCAPI
//
//  Description:This function verifies the digital signature on a message using the
//              Crypto API.
//
//  Arguments:  this - pointer to dplay object
//              pSecureMsg - secure message that came off the wire
// 
//  Returns:    DP_OK, DPERR_GENERIC, DPERR_INVALIDPLAYER, DPERR_VERIFYSIGNFAILED,
//
//-----------------------------------------------------------------------------
HRESULT 
VerifySignatureCAPI(
    LPDPLAYI_DPLAY this,
    LPMSG_SECURE pSecureMsg
    )
{
    DWORD_PTR dwItem;
    HRESULT hr = DPERR_GENERIC;
	HCRYPTHASH hHash=0;
	HCRYPTKEY *phPublicKey;

	DPF(6,"Using CAPI for Signature verification");

    //
    // Retrieve sender's public key
    //
    if (IAM_NAMESERVER(this))
    {
        dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
        if (0==dwItem)
        {
            DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
            return DPERR_INVALIDPLAYER;
        }
        if (NAMETABLE_PENDING == dwItem)
        {
            // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = (LPCLIENTINFO) DataFromID(this,pSecureMsg->dwIDFrom);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

            phPublicKey = &(pClientInfo->hPublicKey);
        }
        else
        {
            // player has logged in
            phPublicKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hPublicKey);
        }
    }
    else
    {
        // client
        phPublicKey = &(this->hServerPublicKey);
    }

	ASSERT(phPublicKey);

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset, pSecureMsg->dwDataSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Validate digital signature.
	if(!OS_CryptVerifySignature(hHash, (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+pSecureMsg->dwDataSize, 
		pSecureMsg->dwSignatureSize, *phPublicKey, NULL, 0)) 
	{
		if(GetLastError() == NTE_BAD_SIGNATURE) 
		{
			DPF_ERR("********** Signature verification failed *********");
			hr = DPERR_VERIFYSIGNFAILED;
		} 
		else 
		{
			DPF_ERRVAL("Error %x during CryptVerifySignature!\n", GetLastError());
		}
		goto CLEANUP_EXIT;
	} 

	hr = DP_OK;
	//
	// Fall through
	//

CLEANUP_EXIT:

	OS_CryptDestroyHash(hHash);
    return hr;

}   // VerifySignatureCAPI

#undef DPF_MODNAME
#define DPF_MODNAME "VerifyMessage"
//+----------------------------------------------------------------------------
//
//  Function:   VerifyMessage
//
//  Description:This function verifies a secure message. If the message is signed,
//              it will verify the digital signature on it. If the message is encrypted,
//              it will verify the digital signature on the message to make sure it has
//              not been tampered with and then decrypt it.
//
//  Arguments:  this - pointer to dplay object
//              phContext - pointer to verification security context handle
//              pReceiveBuffer - signed message received from transport sp
//              dwMessageSize - size of the message
// 
//  Returns:    DP_OK, result from VerifyBuffer() or DecryptBuffer()
//
//-----------------------------------------------------------------------------
HRESULT 
VerifyMessage(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    )
{
    HRESULT hr;
    LPMSG_SECURE pSecureMsg = (LPMSG_SECURE) pReceiveBuffer;

    if (!this->pSysPlayer)
    {
        DPF_ERR("Can't verify message - no system player yet");
        return DPERR_GENERIC;
    }

	DPF(6,"Verifying signature for message 0x%08x from player %d", pSecureMsg->dwCmdToken, \
		pSecureMsg->dwIDFrom);
	//
	// Verify the digital signature on the message
	//

	if (pSecureMsg->dwFlags & DPSECURE_SIGNEDBYCAPI)
	{
		hr = VerifySignatureCAPI(this, pSecureMsg);
	}
	else if (pSecureMsg->dwFlags & DPSECURE_SIGNEDBYSSPI)
	{
		// sspi signature includes the secure message not just the contents
		// (this is how it was coded)
		hr = VerifySignatureSSPI(this, pReceiveBuffer, dwMessageSize);
	}
	else
	{
		// flags were not set
		return DPERR_INVALIDPARAMS;
	}

	if (FAILED(hr))
	{
		return hr;
	}

	//
	// Decrypt the message, if it was encrypted
	//

	if (pSecureMsg->dwFlags & DPSECURE_ENCRYPTEDBYCAPI)
	{
		hr = DecryptMessageCAPI(this, pSecureMsg);
	}

    return hr;

}   // VerifyMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"EncryptBufferSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   EncryptBufferSSPI
//
//  Description:This function encrypts the Buffer passed in the buffer in place.
//              It also setups up the checksum in the structure.              
//
//  Arguments:  this - dplay object
//              phContext - pointer to security context used for encryption
//              pBuffer - Buffer to be encrypted
//              pdwBufferSize - pointer to Buffer size. If encryption succeeds, this will be
//                              be updated to the encrypted Buffer size
//              pSig - buffer for the signature
//              pdwSigSize - pointer to sig size. If encryption succeeds, this will be
//                           updated to the size of generated signature.
// 
//  Returns:    DP_OK if success, otherwise DPERR_ENCRYPTIONFAILED.
//
//-----------------------------------------------------------------------------
HRESULT 
EncryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer,
    LPDWORD pdwBufferSize,
    LPBYTE pSig,
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc   SecDesc;
    SecBuffer       SecBuffer[2]; // 1 for the checksum & 1 for the actual msg
    SECURITY_STATUS status;

    ASSERT(pSig);
    ASSERT(pdwSigSize);
	ASSERT(pdwBufferSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    //
    // Setup security buffer to pass the outgoing message to SealMessage()
    //
    SecDesc.ulVersion = SECBUFFER_VERSION;
    SecDesc.cBuffers = 2;
    SecDesc.pBuffers = &SecBuffer[0];

    SecBuffer[0].cbBuffer = *pdwSigSize;
    SecBuffer[0].BufferType = SECBUFFER_TOKEN;
    SecBuffer[0].pvBuffer = pSig;

    SecBuffer[1].cbBuffer = *pdwBufferSize;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pBuffer;

    //
    // Encrypt the outgoing message
    //
    status = OS_SealMessage(phContext, 0L, &SecDesc, 0L);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Encryption failed: %8x", status);
        return DPERR_ENCRYPTIONFAILED;
    }

    //
    // Return the actual signature size
    //
    *pdwSigSize = SecBuffer[0].cbBuffer;
	*pdwBufferSize = SecBuffer[1].cbBuffer;

    //
    // Success
    //
    return DP_OK;

}   // EncryptBufferSSPI


#undef DPF_MODNAME
#define DPF_MODNAME	"DecryptBufferSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   DecryptBufferSSPI
//
//  Description:This function decrypts the Buffer passed in the buffer in place.
//
//  Arguments:  this - dplay object
//              phContext - pointer to security context used for encryption
//              pBuffer - Buffer to be decrypted
//              dwBufferSize - Buffer buffer size
//              pSig - signature buffer
//              dwSigSize - signature buffer size
// 
//  Returns:    DP_OK if success, otherwise DPERR_DECRYPTIONFAILED, DPERR_ENCRYPTIONNOTSUPPORTED.
//
//-----------------------------------------------------------------------------
HRESULT 
DecryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    LPDWORD pdwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc SecDesc;
    SecBuffer     SecBuffer[2]; // 1 for the checksum & 1 for the actual msg
    SECURITY_STATUS status;

	ASSERT(pdwBufferSize);
	ASSERT(pdwSigSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    //
    // Setup API's input security buffer to pass the client's encrypted 
    // message to UnsealMessage().
    //
    SecDesc.ulVersion = SECBUFFER_VERSION;
    SecDesc.cBuffers = 2;
    SecDesc.pBuffers = &SecBuffer[0];

    SecBuffer[0].cbBuffer = *pdwSigSize;
    SecBuffer[0].BufferType = SECBUFFER_TOKEN;
    SecBuffer[0].pvBuffer = pSig;

    SecBuffer[1].cbBuffer = *pdwBufferSize;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pBuffer;

    status = OS_UnSealMessage(phContext, &SecDesc, 0L, 0L);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Decryption failed: %8x\n", GetLastError());
        return DPERR_DECRYPTIONFAILED;
    }

	*pdwSigSize = SecBuffer[0].cbBuffer;
	*pdwBufferSize = SecBuffer[1].cbBuffer;

    //
    // Success
    //
    return DP_OK;

} // DecryptBufferSSPI

#undef DPF_MODNAME
#define DPF_MODNAME "EncryptBufferCAPI"

HRESULT EncryptBufferCAPI(LPDPLAYI_DPLAY this, HCRYPTKEY *phEncryptionKey, LPBYTE pBuffer, LPDWORD pdwBufferSize)
{
	BOOL fResult;
	DWORD dwEncryptedSize, dwError;

    ASSERT(phEncryptionKey);
	ASSERT(pdwBufferSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    DPF(6,"Encrypt buffer using CAPI: size=%d",*pdwBufferSize);

	dwEncryptedSize = *pdwBufferSize;

	// encrypt buffer using CAPI
    fResult = OS_CryptEncrypt(
        *phEncryptionKey,           // session key for encryption
        0,                          // no hash needed - we are singing using SSPI
        TRUE,                       // final block
        0,                          // reserved
        pBuffer,                    // buffer to be encrypted
        &dwEncryptedSize,           // size of encrypted data
        *pdwBufferSize				// size of buffer
        );

    if (!fResult)
    {
        dwError = GetLastError();
        if (ERROR_MORE_DATA == dwError)
        {
            DPF_ERR("Block encryption is not supported in this release");
        }
        else
        {
            DPF_ERR("Failed to encrypt buffer: Error=%d",);
        }
        return DPERR_ENCRYPTIONFAILED;
    }

	// initialize the number of bytes encrypted
	*pdwBufferSize = dwEncryptedSize;

	// success
	return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecryptMessageCAPI"

HRESULT DecryptMessageCAPI(LPDPLAYI_DPLAY this, LPMSG_SECURE pSecureMsg)
{
	BOOL fResult;
	DWORD_PTR dwItem;
	HCRYPTKEY *phDecryptionKey;

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

	DPF(6,"Decrypting message 0x%08x from player %d using CAPI", pSecureMsg->dwCmdToken, \
		pSecureMsg->dwIDFrom);

	//
	// Retrieve sender's decryption key
	//
	if (IAM_NAMESERVER(this))
	{
		dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
		if (0==dwItem)
		{
			DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
			return DPERR_INVALIDPLAYER;
		}
		if (NAMETABLE_PENDING == dwItem)
		{
			// player hasn't logged in yet
			LPCLIENTINFO pClientInfo;

			pClientInfo = (LPCLIENTINFO) DataFromID(this, pSecureMsg->dwIDFrom);
			if (!pClientInfo)
			{
				DPF_ERR("No client info available for this player");
				return DPERR_GENERIC;
			}

			phDecryptionKey = &(pClientInfo->hDecryptionKey);
		}
		else
		{
			// player has logged in
			phDecryptionKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hDecryptionKey);
		}
	}
	else
	{
		// client
		phDecryptionKey = &(this->hDecryptionKey);
	}

	ASSERT(phDecryptionKey);

	// decrypt buffer using CAPI
    fResult = OS_CryptDecrypt(
        *phDecryptionKey,								// session key for decryption
        0,												// no hash used
        TRUE,											// final block
        0,												// reserved
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,	// buffer to be decrypted
        &(pSecureMsg->dwDataSize)						// size of buffer
        );
	if (!fResult)
	{
		DPF_ERRVAL("Buffer decryption failed: Error=0x%08x",GetLastError());
		return DPERR_GENERIC;
	}

	// success
	return DP_OK;

} // DecryptMessageCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"Login"
//+----------------------------------------------------------------------------
//
//  Function:   Login
//
//  Description:This function does the user authentication synchronously.
//
//  Arguments:  this - pointer to dplay object
// 
//  Returns:    
//
//-----------------------------------------------------------------------------
HRESULT 
Login(
    LPDPLAYI_DPLAY this
    )
{
    HRESULT hr;
    DWORD dwRet, dwTimeout;

    ASSERT(this->pSysPlayer);

    // check if we are already logged in
    if (DPLOGIN_SUCCESS == this->LoginState) return DP_OK;

    dwTimeout = DP_LOGIN_SCALE*GetDefaultTimeout(this, TRUE);

    // always start in negotiate mode
    this->LoginState = DPLOGIN_NEGOTIATE;

    while (TRUE)
    {
        switch (this->LoginState) {

        case DPLOGIN_NEGOTIATE:
            // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	        // until we finish processing it.
            gbWaitingForReply = TRUE;
            //
            // Send a Negotiate message to the server.
            //
            hr = GenerateAuthenticationMessage(this, NULL, 0);
            if (FAILED(hr))
            {
                DPF_ERR("Generate Negotiate message failed");
                // we are not waiting for a reply anymore
                gbWaitingForReply = FALSE;
                goto CLEANUP_EXIT;
            }
            break;

        case DPLOGIN_ACCESSGRANTED:
			{
				LPMSG_ACCESSGRANTED pMsg = (LPMSG_ACCESSGRANTED) gpReceiveBuffer;
				HCRYPTKEY hServerPublicKey;

				ASSERT(this->phContext);
				// we are initializing the signature buffer size here because SSPI 
				// requires a context to query for this information.
				hr = SetupMaxSignatureSize(this,this->phContext);
				if (FAILED(hr))
				{
					DPF_ERR("Failed to get max signature size");
                    // unblock sp thread on our way out
					goto UNBLOCK_EXIT;
				}
				// We successfully logged into the server. Now we need to setup session
				// keys for encryption/decryption. 

				// import server's public key which is contained in the access granted message 
				hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwPublicKeyOffset, pMsg->dwPublicKeySize, &hServerPublicKey);
				if (FAILED(hr))
				{
					DPF_ERRVAL("Failed to import server's public key: hr = 0x%08x",hr);
					hr = DPERR_AUTHENTICATIONFAILED;
                    // unblock receive thread on our way out
					goto UNBLOCK_EXIT;
				}

	            // we are done with the receive buffer, now unblock the receive thread
		        SetEvent(ghReplyProcessed);

				// remember server's public key
				this->hServerPublicKey = hServerPublicKey;

                // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	            // until we finish processing it.
                gbWaitingForReply = TRUE;

				// send our session and public keys to server
				hr = SendKeysToServer(this, hServerPublicKey);
				if (FAILED(hr))
				{
					DPF_ERRVAL("Failed to send keys to server: hr = 0x%08x",hr);
					hr = DPERR_AUTHENTICATIONFAILED;
                    // we are not waiting for a reply anymore
                    gbWaitingForReply = FALSE;
					goto CLEANUP_EXIT;
				}
			}
			break;
      
        case DPLOGIN_LOGONDENIED:
            DPF_ERR("Log in failed: Access denied");
            hr = DPERR_LOGONDENIED;
            // reset login state
            this->LoginState = DPLOGIN_NEGOTIATE;
            // let the app handle now so it can collect credentials from user and try again
            goto CLEANUP_EXIT;
            break;

        case DPLOGIN_ERROR:
            // we are not looking at version here because this change is being made
            // for DirectPlay 5.0 post beta2. We don't want to bump the version this late.
            // todo - remove this check after DirectPlay 5.0 ships.
            if (gdwReceiveBufferSize > sizeof(MSG_SYSMESSAGE))
            {
                LPMSG_AUTHERROR pAuthErrorMsg = (LPMSG_AUTHERROR) gpReceiveBuffer;
                DPF_ERRVAL("An authentication error occured on the server: Error=0x%08x",pAuthErrorMsg->hResult);
                hr = pAuthErrorMsg->hResult;
            }
            else
            {
                DPF_ERR("Login failed: Authentication error");    
                hr = DPERR_AUTHENTICATIONFAILED;
            }
            goto CLEANUP_EXIT;
            break;

        case DPLOGIN_PROGRESS:
            // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	        // until we finish processing it.
            gbWaitingForReply = TRUE;
            //
            // Send response to challenge
            //
            hr = GenerateAuthenticationMessage(this, (LPMSG_AUTHENTICATION)gpReceiveBuffer, 0);
            if (FAILED(hr))
            {
                DPF_ERRVAL("Generate challenge response failed",hr);
                // not waiting for a reply anymore
                gbWaitingForReply = FALSE;
                // unblock receive thread on our way out
                goto UNBLOCK_EXIT;
            }
            // we are done with the receive buffer, now unblock the receive thread
            SetEvent(ghReplyProcessed);
            break;

		case DPLOGIN_KEYEXCHANGE:
            // we received server's session key
			hr = ProcessKeyExchangeReply(this,(LPMSG_KEYEXCHANGE)gpReceiveBuffer);
			if (FAILED(hr))
			{
                DPF_ERRVAL("Failed to process key exchage reply from server: hr = 0x%08x",hr);
                hr = DPERR_AUTHENTICATIONFAILED;
                // unblock receive thread on our way out
                goto UNBLOCK_EXIT;
			}
            // we are done with the receive buffer, now unblock the receive thread
            SetEvent(ghReplyProcessed);

            // keys were exchanged successfully. we are done.
            this->LoginState = DPLOGIN_SUCCESS;
			hr = DP_OK;

    		DPF(5, "Log in successful");
			goto CLEANUP_EXIT;
			break;

        default:
            // make sure we notice 
            ASSERT(FALSE);
            DPF_ERR("Invalid login status\n");
            hr = DPERR_AUTHENTICATIONFAILED;
            goto CLEANUP_EXIT;
            break;
        }
        //
        // Block if we sent a message until we get a response
        //
        if (gbWaitingForReply)
        {
	        // we're protected by the service crit section here, so we can leave dplay
	        // (for reply to be processed)
	        LEAVE_DPLAY();

            // wait for the answer
            dwRet = WaitForSingleObject(ghConnectionEvent,dwTimeout);

	        ENTER_DPLAY();
	        
	        // notice that we look at gbWaitingForReply here instead of dwRet.
	        // this is because we may have timed out just as the reply arrived.
	        // since the reply had the dplay lock, dwRet would be WAIT_TIMEOUT, but
	        // we would have actually received the reply.
	        if (gbWaitingForReply)	
	        {
                DPF_ERR("Waiting for authentication message...Time out");
		        // gbWaitingForReply would have been set to FALSE when the reply arrived
		        // if it's not FALSE, no reply arrived...
		        gbWaitingForReply = FALSE; // reset this for next time
		        hr = DPERR_TIMEOUT;
                goto CLEANUP_EXIT;
	        }

            // we got a response, clear the event
            ResetEvent(ghConnectionEvent);

            // don't unblock the receive thread if we need to process the contents of
            // the receive buffer. We'll unblock the thread after we are done.
            if ((DPLOGIN_PROGRESS != this->LoginState) &&
				(DPLOGIN_KEYEXCHANGE != this->LoginState) &&
                (DPLOGIN_ACCESSGRANTED != this->LoginState))
            {
                // unblock the receive thread
                SetEvent(ghReplyProcessed);
            }

        }   // if (gbWaitingForReply)

    } //  while (TRUE)

    // we never fall through here

// unblock receive thread on our way out
UNBLOCK_EXIT:
    SetEvent(ghReplyProcessed);

// cleanup and bail
CLEANUP_EXIT:
	gpReceiveBuffer = NULL;
    gdwReceiveBufferSize = 0;
    return hr;

} // Login


#undef DPF_MODNAME
#define DPF_MODNAME	"HandleAuthenticationReply"
//+----------------------------------------------------------------------------
//
//  Function:   HandleAuthenticationReply
//
//  Description:This function wakes up the requesting thread, and waits for them 
//              to finish w/ the response buffer
//
//  Arguments:  pReceiveBuffer - buffer received from the sp
//              dwSize - buffer size
// 
//  Returns:    DP_OK or E_FAIL
//
//-----------------------------------------------------------------------------
HRESULT 
HandleAuthenticationReply(
    LPBYTE pReceiveBuffer,
    DWORD dwSize
    ) 
{
	DWORD dwRet;

	// 1st, see if anyone is waiting
	if (!gbWaitingForReply)
	{
		DPF(1,"reply arrived - no one waiting, returning");
		LEAVE_DPLAY();
		return DP_OK;
	}
	// reply is here, reset flag. we do this inside dplay, so whoever is waiting
	// can timeout while we're here, but if they look at gbWaitingForReply they'll
	// see reply actually arrived.
	gbWaitingForReply = FALSE;

    DPF(1,"got authentication reply");
    gpReceiveBuffer = pReceiveBuffer;
    gdwReceiveBufferSize = dwSize;

	// we leave dplay, since the thread in dpsecure.c will need 
	// to enter dplay to process response
	LEAVE_DPLAY();
	
	// let login() party on the buffer
	SetEvent(ghConnectionEvent);

	//
	// wait for Reply to be processed
    dwRet = WaitForSingleObject(ghReplyProcessed,INFINITE);
	if (dwRet != WAIT_OBJECT_0)
	{
		// this should *NEVER* happen
		ASSERT(FALSE);
		return E_FAIL;
	}

	// success!
	ResetEvent(ghReplyProcessed);		

	// note we leave w/ the dplay lock dropped.
	// our caller will just exit (not dropping the lock again).
	return DP_OK;

} // HandleAuthenticationReply


#undef DPF_MODNAME
#define DPF_MODNAME	"SetClientInfo"
//+----------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Description:This function stores client informaton in the nametable
//              given a player id.
//
//  Arguments:  this - pointer to dplay object
//              pClientInfo - pointer to client info.
//              id - player id
// 
//  Returns:    DP_OK or DPERR_INVALIDPLAYER
//
//-----------------------------------------------------------------------------
HRESULT 
SetClientInfo(
    LPDPLAYI_DPLAY this, 
    LPCLIENTINFO pClientInfo,
    DPID id
    )
{
	DWORD dwUnmangledID;
    DWORD index,unique;

    // check if we got a valid id
    if (!IsValidID(this,id))
    {
        DPF_ERRVAL("Invalid player id %d - can't set security context", id);
        return DPERR_INVALIDPLAYER;
    }

    // decrypt the id
	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index > this->uiNameTableSize ) 
    {
        DPF_ERRVAL("Invalid player id %d - can't set security context", id);
        return DPERR_INVALIDPLAYER;
    }

    ASSERT(this->pNameTable[index].dwItem == NAMETABLE_PENDING);

	DPF(5,"Setting pClientInfo=0x%08x in nametable for player %d",pClientInfo,id);

	this->pNameTable[index].pvData = pClientInfo;

	return DP_OK;
} // SetClientInfo


#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveClientInfo"

HRESULT RemoveClientInfo(LPCLIENTINFO pClientInfo)
{
    HRESULT hr;

    hr = OS_DeleteSecurityContext(&(pClientInfo->hContext));
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's security context",hr);
    }

    hr = OS_CryptDestroyKey(pClientInfo->hEncryptionKey);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's encryption key",hr);
    }

    hr = OS_CryptDestroyKey(pClientInfo->hDecryptionKey);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's decryption key",hr);
    }

    hr = OS_CryptDestroyKey(pClientInfo->hPublicKey);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's public key",hr);
    }

    return DP_OK;
} // RemoveClientInfo

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveClientFromNameTable"
//+----------------------------------------------------------------------------
//
//  Function:   RemoveClientFromNameTable
//
//  Description:This function removes a player and the client info associated with 
//              it from the nametable.
//
//  Arguments:  this - pointer to dplay object
//              id - player id
// 
//  Returns:    DP_OK or DPERR_INVALIDPLAYER, or result from FreeNameTableEntry
//
//-----------------------------------------------------------------------------
HRESULT 
RemoveClientFromNameTable(
    LPDPLAYI_DPLAY this, 
    DPID dpID
    )
{
    HRESULT hr;
    LPCLIENTINFO pClientInfo=NULL;
    DWORD_PTR dwItem;

    dwItem = NameFromID(this, dpID);
    if (!dwItem)
    {
        DPF(1, "Player %d doesn't exist", dpID);
        return DPERR_INVALIDPLAYER;
    }

    ASSERT(NAMETABLE_PENDING == dwItem);

    // 
    // Cleanup client info
    //
    pClientInfo = (LPCLIENTINFO) DataFromID(this,dpID);
    if (pClientInfo)
    {
        RemoveClientInfo(pClientInfo);
        // FreeNameTableEntry below will free up the memory
    }

    //
    // Remove client from name table
    //
    hr = FreeNameTableEntry(this, dpID);
    if (FAILED(hr))
    {
        DPF(0,"Couldn't remove client %d from name table: error [0x%8x]", dpID, hr);
        return hr;
    }

    //
    // Success
    //
    return DP_OK;
} // RemoveClientFromNameTable


#undef DPF_MODNAME
#define DPF_MODNAME	"PermitMessage"
//+----------------------------------------------------------------------------
//
//  Function:   PermitMessage
//
//  Description:This function verifies if a message is safe to process
//              when the session is secure.
//
//  Arguments:  dwCommand - message type
//              dwVersion - dplay version of the sender
// 
//  Returns:    TRUE if unsigned message is ok to process, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL 
PermitMessage(
    DWORD dwCommand, 
    DWORD dwVersion
    )
{
    // don't allow any dx3 messages
    if (DPSP_MSG_DX3VERSION == dwVersion)
    {
        return FALSE;
    }

    // only allow the following messages through
    if ((dwCommand == DPSP_MSG_ENUMSESSIONS) ||
         (dwCommand == DPSP_MSG_REQUESTPLAYERID) ||
         (dwCommand == DPSP_MSG_REQUESTPLAYERREPLY) ||
         (dwCommand == DPSP_MSG_PLAYERWRAPPER) ||
         (dwCommand == DPSP_MSG_PLAYERMESSAGE) ||
         (dwCommand == DPSP_MSG_NEGOTIATE) ||
         (dwCommand == DPSP_MSG_CHALLENGE) ||
         (dwCommand == DPSP_MSG_AUTHERROR) ||        
         (dwCommand == DPSP_MSG_LOGONDENIED) ||        
         (dwCommand == DPSP_MSG_CHALLENGERESPONSE) ||
         (dwCommand == DPSP_MSG_SIGNED) ||
         (dwCommand == DPSP_MSG_PING) ||
         (dwCommand == DPSP_MSG_PINGREPLY))
    {
        return TRUE;
    }

    return FALSE;
} // PermitMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"GetMaxContextBufferSize"
//+----------------------------------------------------------------------------
//
//  Function:   GetMaxContextBufferSize
//
//  Description:This function returns the max buffer size used by the specified provider
//              for authentication tokens. First we try to get this information using
//              QuerySecurityPackageInfo() function. If it is not supported (NTLM on Win'95 Gold)
//              we query the information from a temporary context.
//
//  Arguments:  pSecDesc - pointer to security description
//              pulMaxContextBufferSize - pointer to max context buffer size 

// 
//  Returns:    DP_OK or sspi error
//
//-----------------------------------------------------------------------------
HRESULT GetMaxContextBufferSize(LPDPSECURITYDESC pSecDesc, ULONG *pulMaxContextBufferSize)
{
    SecPkgContext_Sizes spContextSizes;
    SECURITY_STATUS status;
    SecBufferDesc outSecDesc;
    SecBuffer     outSecBuffer;
    LPBYTE pBuffer=NULL;
    ULONG     fContextAttrib=0;
    TimeStamp tsExpireTime;
    CtxtHandle hContext;
    CredHandle hCredential;
    HRESULT hr;
    DWORD dwMaxBufferSize=100*1024; // we are assuming that the max size will be atmost 100K
    DWORD dwCurBufferSize=0;

    ASSERT(pulMaxContextBufferSize);

    // try to get it in the normal way
    hr = OS_QueryContextBufferSize(pSecDesc->lpszSSPIProvider, pulMaxContextBufferSize);
    if (SUCCEEDED(hr))
    {
        DPF(6,"Got a max context buffer size of %d using QuerySecurityPackageInfo",*pulMaxContextBufferSize);
        return hr;
    }

	ZeroMemory(&hContext, sizeof(CtxtHandle));
	ZeroMemory(&hCredential, sizeof(CredHandle));

    // ok, looks like we need to try harder

    // acquire an outbound credential handle so we can create a temporary context
    // on both the server as well as the client
    status = OS_AcquireCredentialsHandle(
        NULL, 
        pSecDesc->lpszSSPIProvider,
        SECPKG_CRED_OUTBOUND,
        NULL,
        NULL,
        NULL,
        NULL,
        &hCredential,
        &tsExpireTime);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Failed to get temporary credential handle: Error = 0x%08x",status);
		hr = status;
        goto CLEANUP_EXIT;
    }

    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.BufferType = SECBUFFER_TOKEN;

    DPF_ERR("Trying to create a temporary security context");

    do 
    {
        dwCurBufferSize += 1024;    // increase the buffer size in 1K increments

        DPF(6,"Trying with context buffer size %d", dwCurBufferSize);

        pBuffer = DPMEM_ALLOC(dwCurBufferSize);
        if (!pBuffer)
        {
            hr = DPERR_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }

        outSecBuffer.cbBuffer = dwCurBufferSize;
        outSecBuffer.pvBuffer = pBuffer;

        // create a temporary context so we can get the buffer sizes
        status = OS_InitializeSecurityContext(
            &hCredential,                           // phCredential
            NULL,                                   // phInContext
            NULL,                                   // pszTargetName
            DPLAY_SECURITY_CONTEXT_REQ,             // fContextReq
            0L,                                     // reserved1
            SECURITY_NATIVE_DREP,                   // TargetDataRep
            NULL,                                   // pInput
            0L,                                     // reserved2
            &hContext,                              // phNewContext
            &outSecDesc,                            // pOutput negotiate msg
            &fContextAttrib,                        // pfContextAttribute
            &tsExpireTime                           // ptsLifeTime
            );

        // get rid of the buffer
        DPMEM_FREE(pBuffer);

    } while ((SEC_E_INSUFFICIENT_MEMORY == status) && (dwCurBufferSize <= dwMaxBufferSize));

    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Failed to create temporary security context: Error = 0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
    }

    //
    // We have a security context, now query for the correct buffer size
    //
    ZeroMemory(&spContextSizes, sizeof(SecPkgContext_Sizes));

    status = OS_QueryContextAttributes(&hContext,SECPKG_ATTR_SIZES,&spContextSizes);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Could not get size attributes from package 0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
    }

    *pulMaxContextBufferSize = spContextSizes.cbMaxToken;

    DPF(6,"Max context buffer size = %d", spContextSizes.cbMaxToken);

    // success
    hr = DP_OK;

CLEANUP_EXIT:
	OS_FreeCredentialHandle(&hCredential);
	OS_DeleteSecurityContext(&hContext);
    return hr;

} // GetMaxContextBufferSize

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupMaxSignatureSize"
//+----------------------------------------------------------------------------
//
//  Function:   SetupMaxSignatureSize
//
//  Description:This function queries the security package for max signature size
//              and stores it in the dplay object.
//
//  Arguments:  this - dplay object
// 
//  Returns:    DP_OK or DPERR_GENERIC
//
//-----------------------------------------------------------------------------
HRESULT SetupMaxSignatureSize(LPDPLAYI_DPLAY this, PCtxtHandle phContext)
{
    SecPkgContext_Sizes spContextSizes;
    SECURITY_STATUS status;

    memset(&spContextSizes, 0, sizeof(SecPkgContext_Sizes));

    //
    // query for the buffer sizes
    //
    status = OS_QueryContextAttributes(phContext,SECPKG_ATTR_SIZES,&spContextSizes);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Could not get size attributes from package 0x%08x",status);
        return status;
    }

    this->ulMaxSignatureSize = spContextSizes.cbMaxSignature;

    // success
    return DP_OK;
} // SetupMaxSignatureSize


#undef DPF_MODNAME
#define DPF_MODNAME	"SendAccessGrantedMessage"
//+----------------------------------------------------------------------------
//
//  Function:   SendAccessGrantedMessage
//
//  Description:This function sends a signed access granted message to a client. 
//              We also piggy back the server's public key on this message.
//
//  Arguments:  this - dplay object
// 
//  Returns:    
//
//-----------------------------------------------------------------------------
HRESULT SendAccessGrantedMessage(LPDPLAYI_DPLAY this, DPID dpidTo, LPVOID pvSPHeader)
{
	LPMSG_ACCESSGRANTED pMsg=NULL;
	LPBYTE pSendBuffer=NULL;
	DWORD dwMessageSize;
	HRESULT hr;

    ASSERT(this->pSysPlayer);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ACCESSGRANTED) + this->dwPublicKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send access granted message - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pMsg = (LPMSG_ACCESSGRANTED) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pMsg);
    SET_MESSAGE_COMMAND(pMsg,DPSP_MSG_ACCESSGRANTED);
	
    pMsg->dwPublicKeyOffset = sizeof(MSG_ACCESSGRANTED);
    pMsg->dwPublicKeySize = this->dwPublicKeySize;
	
	// copy the public key data into the send buffer
	memcpy((LPBYTE)pMsg + sizeof(MSG_ACCESSGRANTED), this->pPublicKey, this->dwPublicKeySize);

	hr = SecureDoReply(this,this->pSysPlayer->dwID,dpidTo,pSendBuffer,dwMessageSize, 
		DPSEND_SIGNED|DPSEND_GUARANTEED,pvSPHeader);
	
	DPMEM_FREE(pSendBuffer);

	return hr;
} // SendAccessGrantedMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendKeysToServer"

HRESULT SendKeysToServer(LPDPLAYI_DPLAY this, HCRYPTKEY hServerPublicKey)
{
	LPMSG_KEYEXCHANGE pMsg=NULL;
	LPBYTE pSendBuffer=NULL, pEncryptionKey=NULL;
	DWORD dwMessageSize, dwEncryptionKeySize=0;
    BOOL fResult;
    DWORD dwError;
    HCRYPTKEY hEncryptionKey=0;
	HRESULT hr=DPERR_GENERIC;

    ASSERT(this->pSysPlayer);

	// create a new session key for encrypting messages to the server
	// and store its handle in the dplay object
	fResult = OS_CryptGenKey(
		this->hCSP,                                 // handle to CSP
		this->pSecurityDesc->dwEncryptionAlgorithm, // encryption algorithm
		CRYPT_EXPORTABLE/*| CRYPT_CREATE_SALT*/,    // use a random salt value
		&hEncryptionKey                             // pointer to key handle 
		);
	if (!fResult)
	{
        dwError = GetLastError();
        if (NTE_BAD_ALGID == dwError)
        {
		    DPF_ERR("Bad encryption algorithm id");
            hr = DPERR_INVALIDPARAMS;
        }
        else
        {
		    DPF_ERRVAL("Failed to create encryption key: Error=0x%08x", dwError);
        }
		goto CLEANUP_EXIT;
	}

	// export client's encryption key 
	// note - pEncryptionKey will be filled after the call - we need to free it
	hr = ExportEncryptionKey(&hEncryptionKey, hServerPublicKey, &pEncryptionKey, 
        &dwEncryptionKeySize);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to export encryption key");
		goto CLEANUP_EXIT;
	}

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_KEYEXCHANGE) + this->dwPublicKeySize + dwEncryptionKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send keys to server - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    pMsg = (LPMSG_KEYEXCHANGE) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pMsg);
    SET_MESSAGE_COMMAND(pMsg,DPSP_MSG_KEYEXCHANGE);
	
    pMsg->dwPublicKeyOffset = sizeof(MSG_KEYEXCHANGE);
    pMsg->dwPublicKeySize = this->dwPublicKeySize;
	pMsg->dwSessionKeyOffset = pMsg->dwPublicKeyOffset + pMsg->dwPublicKeySize;
	pMsg->dwSessionKeySize = dwEncryptionKeySize;
	
	// copy the key data into the send buffer
	memcpy((LPBYTE)pMsg + pMsg->dwPublicKeyOffset, this->pPublicKey, this->dwPublicKeySize);
	memcpy((LPBYTE)pMsg + pMsg->dwSessionKeyOffset, pEncryptionKey, dwEncryptionKeySize);

	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
			dwMessageSize,DPSEND_GUARANTEED,FALSE); 	
			
	if (FAILED(hr))
	{
		DPF_ERR("Message send failed");
		goto CLEANUP_EXIT;
	}

	// Success

    // remember our key
    this->hEncryptionKey = hEncryptionKey;

	// cleanup allocations
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	// free the buffer allocated by ExportEncryptionKey()
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return DP_OK;

	// not a fall through

CLEANUP_EXIT:	
	OS_CryptDestroyKey(hEncryptionKey);
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return hr;
} // SendKeysToServer


#undef DPF_MODNAME
#define DPF_MODNAME "SendKeyExchangeReply"

HRESULT SendKeyExchangeReply(LPDPLAYI_DPLAY this, LPMSG_KEYEXCHANGE pMsg, DPID dpidTo,
	LPVOID pvSPHeader)
{
	HCRYPTKEY hClientPublicKey=0, hEncryptionKey=0, hDecryptionKey=0;
	LPBYTE pEncryptionKey=NULL;
	LPBYTE pSendBuffer=NULL;
	LPMSG_KEYEXCHANGE pReply=NULL;
	DWORD dwEncryptionKeySize, dwMessageSize;
    LPCLIENTINFO pClientInfo;
    BOOL fResult;
    DWORD dwError;
	HRESULT hr=DPERR_GENERIC;

    pClientInfo = (LPCLIENTINFO)DataFromID(this,dpidTo);
    if (!pClientInfo)
    {
        DPF_ERRVAL("No client info available for %d",dpidTo);
        return hr;
    }

	// import client's public key
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwPublicKeyOffset,pMsg->dwPublicKeySize,&hClientPublicKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import client's public key\n");
		goto CLEANUP_EXIT;
	}

	// import client's encryption key (server will use this for decrypting client messages)
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwSessionKeyOffset,pMsg->dwSessionKeySize,&hDecryptionKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import client's encryption key\n");
		goto CLEANUP_EXIT;
	}


	// create a new session key for encrypting messages to this client
	fResult = OS_CryptGenKey(
		this->hCSP,                                 // handle to CSP
		this->pSecurityDesc->dwEncryptionAlgorithm, // encryption algorithm
		CRYPT_EXPORTABLE/*| CRYPT_CREATE_SALT*/,    // use a random salt value
		&hEncryptionKey                             // pointer to key handle 
		);
	if (!fResult)
	{
        dwError = GetLastError();
        if (NTE_BAD_ALGID == dwError)
        {
		    DPF_ERR("Bad encryption algorithm id");
            hr = DPERR_INVALIDPARAMS;
        }
        else
        {
		    DPF_ERRVAL("Failed to create session key: Error=0x%08x", dwError);
        }
        goto CLEANUP_EXIT;
	}

	// export server's encryption key
	hr = ExportEncryptionKey(&hEncryptionKey, hClientPublicKey, &pEncryptionKey, 
        &dwEncryptionKeySize);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to export encryption key");
		goto CLEANUP_EXIT;
	}

	// now send reply

	// message size + encryption key size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_KEYEXCHANGE) + dwEncryptionKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send session key to client - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    pReply = (LPMSG_KEYEXCHANGE) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pReply);
    SET_MESSAGE_COMMAND(pReply,DPSP_MSG_KEYEXCHANGEREPLY);
	
	// only encryption key is sent - public key was already sent with access granted message
	pReply->dwSessionKeyOffset = sizeof(MSG_KEYEXCHANGE);
	pReply->dwSessionKeySize = dwEncryptionKeySize;
	
	// copy the key data into the send buffer
	memcpy((LPBYTE)pReply + pReply->dwSessionKeyOffset, pEncryptionKey, dwEncryptionKeySize);

	hr = SecureDoReply(this,this->pSysPlayer->dwID,dpidTo,pSendBuffer,dwMessageSize,
		DPSEND_SIGNED,pvSPHeader); 	
	if (FAILED(hr))
	{
		goto CLEANUP_EXIT;
	}

	// success

	// remember the keys
    pClientInfo->hEncryptionKey = hEncryptionKey;
    pClientInfo->hDecryptionKey = hDecryptionKey;
	pClientInfo->hPublicKey     = hClientPublicKey;

	// cleanup allocations
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hEncryptionKey);
	OS_CryptDestroyKey(hDecryptionKey);
	OS_CryptDestroyKey(hClientPublicKey);
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return hr;
} // SendKeyExchangeReply


#undef DPF_MODNAME
#define DPF_MODNAME "ProcessKeyExchangeReply"

HRESULT ProcessKeyExchangeReply(LPDPLAYI_DPLAY this, LPMSG_KEYEXCHANGE pMsg)
{
	HRESULT hr;
    HCRYPTKEY hDecryptionKey=0;

	// import server's encryption key (client will use this for decrypting server messages)
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwSessionKeyOffset,pMsg->dwSessionKeySize,&hDecryptionKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import server's encryption key\n");
		goto CLEANUP_EXIT;
	}

	// we have successfully established session keys on either side. now we can start sending
	// encrypted messages.
    this->hDecryptionKey = hDecryptionKey;

	// success
	return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hDecryptionKey);

	return hr;
} // ProcessKeyExchangeReply

#undef DPF_MODNAME
#define DPF_MODNAME "GetPublicKey"

HRESULT GetPublicKey(HCRYPTPROV hCSP, HCRYPTKEY *phPublicKey, LPBYTE *ppBuffer, LPDWORD pdwBufferSize)
{
    BOOL fResult;
    LPBYTE pPublicKeyBuffer=NULL;
    HCRYPTKEY hPublicKey=0;
    DWORD dwPublicKeySize=0;
    HRESULT hr=DPERR_GENERIC;

    ASSERT(hCSP);
    ASSERT(phPublicKey);
    ASSERT(ppBuffer);
    ASSERT(pdwBufferSize);

    // create a new public/private key pair
    fResult = OS_CryptGenKey(
        hCSP,                                   // handle to CSP
        AT_KEYEXCHANGE,                         // used for key exchange
        CRYPT_CREATE_SALT,                      // use a random salt value
        &hPublicKey                             // key handle
        );

    if (!fResult)
    {
        DPF_ERRVAL("Failed to create public/private keys: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // query for the size of the buffer required
    fResult = OS_CryptExportKey(
        hPublicKey,                             // handle to the public key
        0,                                      // no destination user key
        PUBLICKEYBLOB,                          // public key type
        0,                                      // reserved field
        NULL,                                   // no buffer
        &dwPublicKeySize                        // size of the buffer
        );

    if (0 == dwPublicKeySize)
    {
        DPF_ERRVAL("Failed to get the size of the key buffer: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // allocate buffer to hold the public key
    pPublicKeyBuffer = DPMEM_ALLOC(dwPublicKeySize);
    if (!pPublicKeyBuffer)
    {
        DPF_ERR("Failed to setup public key - out of memory");
        hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    // export key into the buffer
    fResult = OS_CryptExportKey(
        hPublicKey,                             // handle to the public key
        0,                                      // no destination user key
        PUBLICKEYBLOB,                          // public key type
        0,                                      // reserved field
        pPublicKeyBuffer,                       // buffer to store the key
        &dwPublicKeySize                        // size of the data exported
        );

    if (!fResult || !dwPublicKeySize)
    {
        DPF_ERRVAL("Failed to export the public key: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // now return the correct info
    *phPublicKey = hPublicKey;
    *ppBuffer = pPublicKeyBuffer;
    *pdwBufferSize = dwPublicKeySize;

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hPublicKey);
    if (pPublicKeyBuffer) DPMEM_FREE(pPublicKeyBuffer);
    return hr;

} // GetPublicKey

#undef DPF_MODNAME
#define DPF_MODNAME "ExportEncryptionKey"

HRESULT ExportEncryptionKey(HCRYPTKEY *phEncryptionKey, HCRYPTKEY hDestUserPubKey, 
    LPBYTE *ppBuffer, LPDWORD pdwSize)
{
    BOOL fResult;
    LPBYTE pBuffer = NULL;
    DWORD dwSize=0;
    HRESULT hr=DPERR_GENERIC;

    ASSERT(phEncryptionKey);
    ASSERT(ppBuffer);
    ASSERT(pdwSize);

    // query for the size of the buffer required
    fResult = OS_CryptExportKey(
        *phEncryptionKey,                       // handle to key being exported
        hDestUserPubKey,                        // destination user key
        SIMPLEBLOB,                             // key exchange blob
        0,                                      // reserved field
        NULL,                                   // no buffer
        &dwSize                                 // size of the buffer
        );

    if (0 == dwSize)
    {
        DPF_ERRVAL("Failed to get the size of the key buffer: Error=0x%08x",GetLastError());
        return DPERR_GENERIC;
    }

    // allocate buffer
    pBuffer = DPMEM_ALLOC(dwSize);
    if (!pBuffer)
    {
        DPF_ERR("Failed to allocate memory for key");
        return DPERR_OUTOFMEMORY;
    }

    // export key into the buffer
    fResult = OS_CryptExportKey(
        *phEncryptionKey,                       // handle to the public key
        hDestUserPubKey,                        // destination user key
        SIMPLEBLOB,                             // key exchange blob
        0,                                      // reserved field
        pBuffer,                                // buffer to store key
        &dwSize                                 // size of the buffer
        );

    if (!fResult || !dwSize)
    {
        DPF_ERRVAL("Failed to export the public key: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // return the buffer and its size
    *ppBuffer = pBuffer;
    *pdwSize = dwSize;

	// don't free the encryption key buffer - caller will free it.

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
    if (pBuffer) DPMEM_FREE(pBuffer);
    return hr;

} // ExportEncryptionKey


#undef DPF_MODNAME
#define DPF_MODNAME "ImportKey"

HRESULT ImportKey(LPDPLAYI_DPLAY this, LPBYTE pBuffer, DWORD dwSize, HCRYPTKEY *phKey)
{
    BOOL fResult;
	HRESULT hr=DPERR_GENERIC;
	HCRYPTKEY hKey=0;

    ASSERT(pBuffer);
    ASSERT(phKey);

    fResult = OS_CryptImportKey(
        this->hCSP,         // handle to crypto service provider
        pBuffer,            // buffer containing exported key
        dwSize,             // size of buffer
        0,                  // sender's key
        0,                  // flags
        &hKey				// store handle the new key here
        );

    if (!fResult)
    {
        DPF_ERRVAL("Failed to import key: Error=0x%08x",GetLastError());
		goto CLEANUP_EXIT;
    }

	*phKey = hKey;

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hKey);

	return hr;

} // ImportKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpsecure.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecure.h
 *  Content:	DirectPlay security definitions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through
 *                      Windows Security Support Provider Interface (SSPI).
 *  04/14/97    sohailm Removed definitions for buffer sizes and DPLAYI_SEALED struct.
 *  05/12/97    sohailm Added prototypes for CAPI (encryption/decryption) related functions.
 *  05/22/97    sohailm Added dplay key container name.
 *  06/09/97    sohailm Made NTLM the default security package instead of DPA.
 *  06/23/97    sohailm Added function prototypes related to signing support through CAPI.
 *
 ***************************************************************************/
#ifndef __DPSECURE_H__
#define __DPSECURE_H__

#include <windows.h>
#include <issperr.h>
#include <sspi.h>                                  
#include "dpsecos.h" 

// 
// Definitions
//
#define DPLAY_DEFAULT_SECURITY_PACKAGE L"NTLM" // Default security package used by directplay
#define DPLAY_KEY_CONTAINER L"DPLAY"          // key container name for use with CAPI
#define DPLAY_SECURITY_CONTEXT_REQ (ISC_REQ_CONFIDENTIALITY | \
                                    ISC_REQ_USE_SESSION_KEY | \
                                    ISC_REQ_REPLAY_DETECT)

#define SSPI_CLIENT 0
#define SSPI_SERVER 1
#define DP_LOGIN_SCALE                  5     

#define SEALMESSAGE     Reserved3             // Entry which points to SealMessage
#define UNSEALMESSAGE   Reserved4             // Entry which points to UnsealMessage

//
//  Names of secruity DLL
//

#define SSP_NT_DLL          L"security.dll"
#define SSP_WIN95_DLL       L"secur32.dll"
#define SSP_SSPC_DLL        L"msapsspc.dll"
#define SSP_SSPS_DLL        L"msapssps.dll"
#define CAPI_DLL            L"advapi32.dll"

#define SEC_SUCCESS(Status) ((Status) >= 0)

// 
// Function Prototypes
//

// dpsecure.c
extern HRESULT 
InitSecurity(
    LPDPLAYI_DPLAY
    );

extern HRESULT 
InitCAPI(
    void
    );

extern HINSTANCE
LoadSSPI (
    void
    );

extern HRESULT 
InitSSPI(
    void
    );

extern HRESULT 
LoadSecurityProviders(
    LPDPLAYI_DPLAY this,
    DWORD dwFlags
    );

extern HRESULT
GenerateAuthenticationMessage (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    ULONG       fContextReq
    );

extern HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    LPVOID pvSPHeader
    );

extern HRESULT 
SecureSendDPMessage(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock
    );

extern HRESULT 
SecureSendDPMessageEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock
    );

extern HRESULT 
SecureSendDPMessageCAPI(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock
	);

extern HRESULT 
SecureSendDPMessageCAPIEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock
    );

extern HRESULT 
SecureDoReply(
    LPDPLAYI_DPLAY this,
	DPID dpidFrom,
	DPID dpidTo,
	LPBYTE pMsg,
	DWORD dwMsgSize,
	DWORD dwFlags,
	LPVOID pvSPHeader
	);

extern HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    LPVOID pvSPHeader
    );

extern HRESULT 
SignBuffer(
    PCtxtHandle phContext, 
    LPBYTE pMsg, 
    DWORD dwMsgSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
VerifyBuffer(
    PCtxtHandle phContext, 
    LPBYTE pMsg, 
    DWORD dwMsgSize, 
    LPBYTE pSig, 
    DWORD dwSigSize
    );

extern HRESULT 
VerifySignatureSSPI(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    );

extern HRESULT 
VerifySignatureCAPI(
    LPDPLAYI_DPLAY this,
    LPMSG_SECURE pSecureMsg
    );

extern HRESULT 
VerifyMessage(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    );

extern HRESULT 
EncryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    LPDWORD dwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
DecryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pData, 
    LPDWORD pdwDataSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
EncryptBufferCAPI(
	LPDPLAYI_DPLAY this, 
    HCRYPTKEY *phEncryptionKey,
	LPBYTE pBuffer, 
	LPDWORD pdwBufferSize
	);

extern HRESULT 
DecryptMessageCAPI(
	LPDPLAYI_DPLAY this, 
	LPMSG_SECURE pSecureMsg
	);

extern HRESULT 
Login(
    LPDPLAYI_DPLAY this
    );

extern HRESULT 
HandleAuthenticationReply(
    LPBYTE pReceiveBuffer,
    DWORD dwCmd
    );

extern HRESULT 
SetClientInfo(
    LPDPLAYI_DPLAY this, 
    LPCLIENTINFO pClientInfo,
    DPID id
    );

extern HRESULT 
RemoveClientInfo(
    LPCLIENTINFO pClientInfo
    );

extern HRESULT 
RemoveClientFromNameTable(
   LPDPLAYI_DPLAY this, 
   DWORD dwID
   );

extern BOOL 
PermitMessage(
    DWORD dwCommand, 
    DWORD dwVersion
    );

extern HRESULT 
GetMaxContextBufferSize(
    LPDPSECURITYDESC pSecDesc,
    ULONG *pulMaxContextBufferSize
    );

extern HRESULT 
SetupMaxSignatureSize(
    LPDPLAYI_DPLAY this,
    PCtxtHandle phContext
    );

extern HRESULT 
SendAccessGrantedMessage(
    LPDPLAYI_DPLAY this, 
    DPID dpidTo,
	LPVOID pvSPHeader
    );


extern HRESULT 
SendKeysToServer(
	LPDPLAYI_DPLAY this, 
	HCRYPTKEY hServerPublicKey
	);

extern HRESULT 
SendKeyExchangeReply(
	LPDPLAYI_DPLAY this, 
	LPMSG_KEYEXCHANGE pMsg, 
	DPID dpidTo,
	LPVOID pvSPHeader
	);

extern HRESULT 
ProcessKeyExchangeReply(
	LPDPLAYI_DPLAY this, 
	LPMSG_KEYEXCHANGE pMsg
	);

extern HRESULT 
GetPublicKey(
    HCRYPTPROV hCSP, 
    HCRYPTKEY *phPublicKey, 
    LPBYTE *ppBuffer, 
    LPDWORD pdwBufferSize
    );

extern HRESULT 
ExportEncryptionKey(
    HCRYPTKEY *phEncryptionKey,
	HCRYPTKEY hDestUserPubKey, 
	LPBYTE *ppBuffer, 
	LPDWORD pdwSize
	);

extern HRESULT
ImportKey(
	LPDPLAYI_DPLAY this, 
	LPBYTE pBuffer, 
	DWORD dwSize, 
	HCRYPTKEY *phKey
	);

#endif // __DPSECURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpthread.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       dpthread.c
*  Content:		dplay worker thread.  sends pings / enum sessions requests,
*				looks for dead players
*
*  History:
*   Date		By		Reason
*   ====		==		======
*	8/1/96		andyco	created it 
*	8/8/96		andyco	changed to call getdefaulttimeout
*	9/3/96		andyco	take an extra lock in killplayer	  
*	9/4/96		andyco	DON'T take extra locks - it's dangerous - 
*						don't need 'em
*	11/12/96	andyco	check if we're nameserver every time we go through
*						the player list.  and, when we delete someone,
*						restart at the beginning of the list.
* 	3/5/97		andyco	renamed from ping.c
*	5/23/97		kipo	Added support for return status codes
*	7/30/97		andyco	removed youaredead on getting ping from invalid player
*   8/4/97		andyco	dpthread watches add forward list on this ptr, watching
*						for add forward requests that haven't been fully ack'ed, 
*						and sending out the nametable to them.
*	1/28/98		sohailm	Added a minimum threshold to keep alive timeout.
*   2/13/98     aarono  Added flag to internal destroy player calls for async
*   4/6/98      aarono  changed killplayer to send player delete messages
*                       and do host migration if necessary.
*   5/08/98    a-peterz #22920 Reset Async EnumSession on failure and
*						always use ReturnStatus to prevent dialogs in thread
*   6/6/98      aarono  avoid protocol deadlock by sending pings async
*
***************************************************************************/

#include "dplaypr.h"
#include "..\protocol\arpstruc.h"
#include "..\protocol\arpdint.h"

// KEEPALIVE_SCALE * dwTimeout is how often we  ping
#define KEEPALIVE_SCALE 12

// reservation timeout scale
#define RESERVATION_TIMEOUT_SCALE	12

// how many consecutive unanswered pings before we nuke the player
#define UNANSWERED_PINGS_BEFORE_EXECUTION	8

// KILL_SCALE * dwTimeout is how long we wait before we nuke if we've got 
// < MINIMUM_PINGS.  Otherwise is the number of standard deviations
// off the mean that we wait before nuking
#define KILL_SCALE 25

#undef DPF_MODNAME
#define DPF_MODNAME	"... ping -- "

HRESULT SendPing(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerTo,BOOL bReply,
	DWORD dwTickCount)
{
	HRESULT hr = DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	LPMSG_PING pPing;
	DWORD dwFlags;

	ASSERT(this->pSysPlayer);
	
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PING); 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send ping - out of memory");
        return E_OUTOFMEMORY;
    }
	
	pPing = (LPMSG_PING)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pPing);

	if (bReply)
	{
		// we're sending them a ping reply
		SET_MESSAGE_COMMAND(pPing,DPSP_MSG_PINGREPLY);
		// pass them back the tick count from the ping message
		// so they can figure latency
		pPing->dwTickCount = dwTickCount;
	}
	else 
	{
		// we're generating a ping request
		// store the tick count so we can compute latency when 
		// we get reply
		// Note, in sending case, we don't have dwTickCount is 
		// not passed in.
		ASSERT(dwTickCount==0);
		SET_MESSAGE_COMMAND(pPing,DPSP_MSG_PING);
		pPing->dwTickCount = GetTickCount();
	}
	pPing->dwIDFrom = this->pSysPlayer->dwID;
   
    // send reply back to whoever sent ping
    if(this->pProtocol){
    	dwFlags = DPSEND_ASYNC|DPSEND_HIGHPRIORITY;
    } else {
    	dwFlags = 0;
    }

	hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwMessageSize,dwFlags,FALSE);
	
	if (FAILED(hr) && (hr!=DPERR_PENDING))
	{
		DPF(5, "In SendPing, SendDPMessage returned %d", hr);
	}

	DPMEM_FREE(pSendBuffer);
	
	return hr;
	
} // SendPing

// when we get a ping from someone we don't recognize, we tell that someone
// to go away and leave us alone
HRESULT  SendYouAreDead(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvMessageHeader)
{
	HRESULT hr = DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	LPMSG_SYSMESSAGE pmsg;

	ASSERT(IAM_NAMESERVER(this));
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE); 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send ping - out of memory");
        return E_OUTOFMEMORY;
    }
	
	pmsg = (LPMSG_SYSMESSAGE)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pmsg);
	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_YOUAREDEAD);
	
	hr = DoReply(this,pSendBuffer,dwMessageSize,pvMessageHeader, 0);
	
	DPMEM_FREE(pSendBuffer);
	
	return hr;
} // SendYouAreDead

// got a ping request or reply
HRESULT HandlePing(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvMessageHeader)
{
	LPMSG_PING pPing = (LPMSG_PING)pReceiveBuffer;
	LPDPLAYI_PLAYER pPlayerFrom;
	BOOL bReply;
	HRESULT hr=DP_OK;
	DWORD dwCmd = GET_MESSAGE_COMMAND(pPing);
	
	bReply = (DPSP_MSG_PINGREPLY == dwCmd) ? TRUE : FALSE;
	
	pPlayerFrom = PlayerFromID(this,pPing->dwIDFrom);
    if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
    {
		DPF_ERR(" ACK !!! RECEIVED PING FROM INVALID (DEAD) PLAYER");
		if (IAM_NAMESERVER(this))
		{
			hr = SendYouAreDead(this,pReceiveBuffer,pvMessageHeader);
		}
		return DPERR_INVALIDPLAYER ;
    }

	if (bReply)
	{		
		// they are responding to our ping request
		DWORD dwTicks = abs(GetTickCount() - pPing->dwTickCount);
		if(dwTicks==0){
			dwTicks=5;	// resolution worst case 10ms, assume half if we can't observe.
		}
		pPlayerFrom->dwLatencyLastPing = (dwTicks/2)+1;
		DPF(4,"got ping reply from player id %d dwTicks = %d \n",pPlayerFrom->dwID,dwTicks);
		pPlayerFrom->dwUnansweredPings = 0;	// we're not really counting, just setting a threshold

	}
	else 
	{
		// they sent us a ping request
		hr = SendPing(this,pPlayerFrom,TRUE,pPing->dwTickCount);
		if (FAILED(hr))
		{
			DPF(7, "SendPing returned %d", hr);
		}
	} // reply
	
	return hr;
} // HandlePing


#undef DPF_MODNAME
#define DPF_MODNAME	"DirectPlay Worker Thread"

//
// called by KeepAliveThreadProc
// when we detect pSysPlayer is gone, we nuke him, and all of his local 
// players from the global name table
HRESULT  KillPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pSysPlayer, BOOL fPropagate)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;
	DWORD dwIDSysPlayer; // cache this for after we destroy sysplayer

	ASSERT(pSysPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);

	DPF(9,"->KillPlayer(0x%x,0x%x,%d)\n", this, pSysPlayer, fPropagate);
	DPF(1,"KillPlayer :: Killing system player id = %d\n",pSysPlayer->dwID);

	dwIDSysPlayer = pSysPlayer->dwID;
	
	// 1st destroy the sysplayer
	// we don't want to try to tell a dead sysplayer that one of their local players
	// is gone...
	DPF(9, "in KillPlayer, calling InternalDestroyPlayer (pSysPlayer = 0x%x)\n", pSysPlayer);
	hr = InternalDestroyPlayer(this,pSysPlayer,fPropagate,TRUE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	// next, destroy any players created w/ that sysplayer
	pPlayer = this->pPlayers;

	// for the record, this code is horked, not to mention broken. BUGBUG
	while (pPlayer)
	{
		pPlayerNext = pPlayer->pNextPlayer;

		DPF(9, "in KillPlayer, checking player %d\n", pPlayer->dwID); 
		if (pPlayer->dwIDSysPlayer == dwIDSysPlayer)
		{
			DPF(1,"in KillPlayer, Killing player id = %d\n",pPlayer->dwID);		
			// kill player
			if(!fPropagate){
				DPF(9,"Calling QDeleteAndDestroyMessagesForPlayer\n");
				QDeleteAndDestroyMessagesForPlayer(this, pPlayer);
			}
			
			DPF(9, "in KillPlayer, calling InternalDestroyPlayer (pPlayer = 0x%x)\n", pPlayer);
			hr = InternalDestroyPlayer(this,pPlayer,fPropagate,FALSE);
			if (FAILED(hr))
			{
				DPF(0,"InternalDestroyPlayer returned err: 0x%x\n", hr);
				ASSERT(FALSE);
			}
			
			// we deleted a player, so the list may be changed go back to beginning
			pPlayerNext=this->pPlayers; 
		} 
		
		pPlayer = pPlayerNext;
	}
	
	return DP_OK;
} // KillPlayer


// when we get a session lost, the handlesessionlost routine (handler.c)
// sets a flag telling the keep alive thread to delete all remote players
HRESULT DeleteRemotePlayers(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;

	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pPlayerNext = pPlayer->pNextPlayer;
		 
		// if it's a remote player, make it go bye bye
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			hr = InternalDestroyPlayer(this,pPlayer,FALSE,TRUE);	
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		
		pPlayer = pPlayerNext;
	}

	// since we've killed all remote players, it's safe to turn 
	// of this flag (e.g. so new people could now join our game)
	this->dwFlags &= ~DPLAYI_DPLAY_SESSIONLOST;	
	return DP_OK;
	
} // DeleteRemotePlayers

// check the player list, looking for dead players, and sending pings
// if necessary
HRESULT DoPingThing(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;
	BOOL bNameServer,bCheck,bKill;
	BOOL bWeHaveCasualties = FALSE;

	if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
		return E_FAIL;
		
	if (!this->pSysPlayer)	
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
		
	pPlayer = this->pPlayers;

	while (pPlayer)
	{
		ASSERT(VALID_DPLAY_PLAYER(pPlayer));
		
		bNameServer = (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) ? TRUE : FALSE;
		pPlayerNext = pPlayer->pNextPlayer;
		
		if (bNameServer || this->dwFlags & DPLAYI_DPLAY_NONAMESERVER)
		{
			bCheck = (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) 
					&& (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
					&& !(pPlayer->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)) ? TRUE : FALSE;
		}
		else 
		{
			bCheck = (pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) ? TRUE : FALSE;
		}

		if (bCheck)
		{
			BOOL	bProtocolHasChatter = FALSE;
			bKill = FALSE;			

			DPF(9, "in DoPingThing: Checking player %d\n", pPlayer->dwID);
			// a-josbor:  check chatter on the Protocol, if it's on
			if (this->pProtocol)
			{
				ASSERT(this->dwFlags & DPLAYI_DPLAY_PROTOCOL);
			}

			if (this->dwFlags & DPLAYI_DPLAY_PROTOCOL)
			{
				PSESSION     pSession = NULL;

				if (pPlayer)
				{
					pSession= GetSession((PPROTOCOL) this->pProtocol,pPlayer->dwID);

					if (pSession)
					{
						if ((pSession->RemoteBytesReceived != pPlayer->dwProtLastSendBytes) || 
							(pSession->LocalBytesReceived != pPlayer->dwProtLastRcvdBytes))
						{
							DPF(9,"Player %d not pinged because Protocol says there was traffic (%d in/%d out) since last\n",pPlayer->dwID,
								pSession->LocalBytesReceived - pPlayer->dwProtLastRcvdBytes,
								pSession->RemoteBytesReceived - pPlayer->dwProtLastSendBytes);
							pPlayer->dwProtLastSendBytes = pSession->RemoteBytesReceived;
							pPlayer->dwProtLastRcvdBytes = pSession->LocalBytesReceived;
							bProtocolHasChatter = TRUE;	
							pPlayer->dwUnansweredPings=0;
						}
						else
						{
							DPF(9,"Protocol says Player %d had no traffic\n",pPlayer->dwID);
						}
						
						DecSessionRef(pSession);	// release our reference to the session
					}
					else
					{
						DPF(7, "Unable to get Protocol Session ptr for Player %d!\n", pPlayer->dwID);
					}
				}
			}

			if (!bProtocolHasChatter) // if Protocol thinks the player hasn't sent or recvd, we should ping...
			{
				// a-josbor: Bug 15252- be more conservative about pinging.  Only do
				// 	it if we haven't heard from them since the last time we pinged
				if (pPlayer->dwChatterCount == 0)
				{
					DPF(9,"Player %d had %d unanswered pings\n", pPlayer->dwID, pPlayer->dwUnansweredPings);
					// no chatter has occurred since last time we pinged.
					bKill = (pPlayer->dwUnansweredPings >= UNANSWERED_PINGS_BEFORE_EXECUTION);

					if (bKill)
					{
						DPF(9,"Setting DEATHROW on %d because of unanswered pings!\n", pPlayer->dwID);
					
						// a-josbor: we can't kill them yet because it could
						// mess up our chatter count for other players.
						// we therefore just mark them for death, and run through
						// the list when we exit this loop
						pPlayer->dwFlags |= DPLAYI_PLAYER_ON_DEATH_ROW;
						bWeHaveCasualties = TRUE;
					}
					else 
					{
						DPF(9, "Pinging player %d\n", pPlayer->dwID);
						hr = SendPing(this,pPlayer,FALSE,0);
						if (FAILED(hr)&&hr!=DPERR_PENDING)
						{
							DPF(4, "In DoPingThing, SendPing returned %d", hr);
						}
    					DPF(6,"Player %d pinged. (%d Unanswered)\n",pPlayer->dwID, pPlayer->dwUnansweredPings);
						pPlayer->dwUnansweredPings++;
					}
				}
				else	// chatter has occurred since last ping
				{
					DPF(9,"Player %d not pinged.  Chatter == %d\n",pPlayer->dwID, pPlayer->dwChatterCount);
					pPlayer->dwChatterCount = 0;
					pPlayer->dwUnansweredPings = 0;
				}
			}
		} // bCheck
		
		pPlayer = pPlayerNext;
	}

//	a-josbor: we didn't delete in the loop above, so do it here
	if (bWeHaveCasualties)  //	we now have to service any dead players.  
	{
//		go back through the whole list, looking for the victims
		pPlayer = this->pPlayers;
		while (pPlayer)
		{
			ASSERT(VALID_DPLAY_PLAYER(pPlayer));
			pPlayerNext = pPlayer->pNextPlayer;
			if (pPlayer->dwFlags & DPLAYI_PLAYER_ON_DEATH_ROW)
			{
				DPF(9, "in DoPingThing: calling KillPlayer on %d\n", pPlayer->dwID);
				hr = KillPlayer(this,pPlayer,TRUE);
				if (FAILED(hr))
				{
					// if we had a problem killing them, unset the bit
					// so we don't keep trying
					pPlayer->dwFlags &= ~DPLAYI_PLAYER_ON_DEATH_ROW;
					ASSERT(FALSE);
				}
				// we deleted pPlayer, and all of its local players.
				// so - pNextPlayer could have been deleted.  to be safe, we restart at 
				// the beginning of the list
				pPlayerNext = this->pPlayers;
			}
			pPlayer = pPlayerNext;
		}
	}
	
	return DP_OK;
		
} // DoPingThings
							   
// figure out when to schedule next event, based on current time, last event,
// and event spacing.  (returns timeout in milliseconds suitable for passing
// to waitforsingleobject).
// called by GetDPlayThreadTimeout
DWORD GetEventTimeout(DWORD dwLastEvent,DWORD dwEventSpacing)
{
	DWORD dwCurrentTime = GetTickCount();
	
	// is it already over due?
	if ( (dwCurrentTime - dwLastEvent) > dwEventSpacing ) return 0;
	// else	return the event spacing relative to the current time
	return dwEventSpacing - (dwCurrentTime - dwLastEvent);
	
} // GetEventTimeout	

// figure out which timeout to use
DWORD GetDPlayThreadTimeout(LPDPLAYI_DPLAY this,DWORD dwKeepAliveTimeout)
{
	DWORD dwTimeout,dwAddForwardTime;
	LPADDFORWARDNODE pAddForward;
	
	if (this->dwFlags & DPLAYI_DPLAY_KEEPALIVE) 
	{
		// is there an enum too?
		if (this->dwFlags & DPLAYI_DPLAY_ENUM) 
		{
			DWORD dwKillEvent,dwEnumEvent;
			
			dwKillEvent = GetEventTimeout(this->dwLastPing,dwKeepAliveTimeout);
			dwEnumEvent = GetEventTimeout(this->dwLastEnum,this->dwEnumTimeout);
			
			dwTimeout = (dwKillEvent < dwEnumEvent) ? dwKillEvent : dwEnumEvent;
		}												
		else 
		{
			// only keep alive is running, use that
			dwTimeout = GetEventTimeout(this->dwLastPing,dwKeepAliveTimeout);
		}
	}
	else if (this->dwFlags & DPLAYI_DPLAY_ENUM) 
	{
		// only enum is running, use that 
		dwTimeout = GetEventTimeout(this->dwLastEnum,this->dwEnumTimeout);
	}
	else if(this->dwZombieCount)
	{
		dwTimeout = dwKeepAliveTimeout;
	} 
	else
	{
		// hmmm, neither enum nor keepalive is happening.
		// we'll just go to sleep until something changes
		dwTimeout = INFINITE;
	}
	
	// now, see if there's an add forward that needs handling before dwTimeout
	pAddForward = this->pAddForwardList;
	while (pAddForward)
	{
		// see how long till we give up waiting for ack's on this node and just send
		// the nametable
		dwAddForwardTime = pAddForward->dwGiveUpTickCount - GetTickCount();
		// if that's smaller than our current timeout, then we have a winner
		if ( dwAddForwardTime < dwTimeout) dwTimeout = dwAddForwardTime;
		pAddForward = pAddForward->pNextNode;
	}

	return dwTimeout;
	
} // GetDPlayThreadTimeout

void CheckAddForwardList(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer;
	LPADDFORWARDNODE pAddForward,pAddForwardNext;
	HRESULT hr;
	
	// now, see if there's an add forward that needs handling before dwTimeout
	pAddForward = this->pAddForwardList;
	while (pAddForward)
	{
		// save next node now, in case FreeAddForwardNode blows it away
		pAddForwardNext = pAddForward->pNextNode;
		if (GetTickCount() > pAddForward->dwGiveUpTickCount)
		{
			// clear doesn't have nametable from requesting player.
			pPlayer=PlayerFromID(this, pAddForward->dwIDSysPlayer);
			if(pPlayer){
				pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
			}
			DPF(0,"giving up waiting for an add forward response - sending nametable to joining client!");
		    hr = NS_HandleEnumPlayers(this, pAddForward->pvSPHeader, pAddForward->dpidFrom,
				pAddForward->dwVersion);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			
			hr = FreeAddForwardNode(this,pAddForward);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		pAddForward = pAddForwardNext;
	} 
	
} // CheckAddForwardList

//
// worker thread for dplay
// sleep for a while.  wake up and see 1.  if we need to send an enumsession request, 2. if we 
// need to send a ping and 3. if anyone has died
//
DWORD WINAPI DPlayThreadProc(LPDPLAYI_DPLAY this)
{
    HRESULT hr;
	DWORD dwKeepAliveTimeout;
	DWORD dwTimeout; // smaller of enum / keep alive timeout
	DWORD dwCurrentTime;
				
#ifdef DEBUG
	// makes for nice startup spew...
	dwKeepAliveTimeout = (KEEPALIVE_SCALE * GetDefaultTimeout( this, FALSE))/ UNANSWERED_PINGS_BEFORE_EXECUTION;
	if (dwKeepAliveTimeout < DP_MIN_KEEPALIVE_TIMEOUT) 
		dwKeepAliveTimeout = DP_MIN_KEEPALIVE_TIMEOUT;
	dwTimeout = GetDPlayThreadTimeout(this,dwKeepAliveTimeout);
	DPF(1,"starting DirectPlay Worker Thread - initial timeout = %d\n",dwTimeout);
#endif // DEBUG

 	while (1)
 	{
		// grab the latest timeouts...
		dwKeepAliveTimeout = (KEEPALIVE_SCALE * GetDefaultTimeout( this, FALSE))/ UNANSWERED_PINGS_BEFORE_EXECUTION;
		if (dwKeepAliveTimeout < DP_MIN_KEEPALIVE_TIMEOUT) 
			dwKeepAliveTimeout = DP_MIN_KEEPALIVE_TIMEOUT;
		dwTimeout = GetDPlayThreadTimeout(this,dwKeepAliveTimeout);

		WaitForSingleObject(this->hDPlayThreadEvent,dwTimeout);

		ENTER_ALL();
		
		dwCurrentTime = GetTickCount();		
		DPF(9,"DPLAY Thread woke up at t=%d", dwCurrentTime);

		// are we closed? is 'this' bogus?
		hr = VALID_DPLAY_PTR(this);
		if ( FAILED(hr) || (this->dwFlags & DPLAYI_DPLAY_CLOSED))
		{
			LEAVE_ALL();
			goto ERROR_EXIT;
		}
		
		
		// session lost?				
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			// session was lost, we need to clean up
			hr = DeleteRemotePlayers(this);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			// keep going
		}
		
		// time to send ping?
		if ((this->dwFlags & DPLAYI_DPLAY_KEEPALIVE) 
			&& (dwCurrentTime - this->dwLastPing >= dwKeepAliveTimeout))
		{
			DoPingThing(this);
			this->dwLastPing = GetTickCount();
		}

		// if we have zombies, walk the player list looking for them
		if (this->dwZombieCount > 0)
		{
			LPDPLAYI_PLAYER pPlayer,pPlayerNext;
			BOOL 			bWeHaveCasualties = FALSE;
			BOOL			bFoundZombies = FALSE;
			
			DPF(9, "We have zombies!  Walking the player list...");
			
			dwCurrentTime = GetTickCount();
			
			pPlayer = this->pPlayers;
			while (pPlayer)
			{
				ASSERT(VALID_DPLAY_PLAYER(pPlayer));
				pPlayerNext = pPlayer->pNextPlayer;
				if ((pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
					&& (pPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST))
				{
					bFoundZombies = TRUE;
					if (pPlayer->dwTimeToDie < dwCurrentTime)
					{
						pPlayer->dwFlags |= DPLAYI_PLAYER_ON_DEATH_ROW;
						bWeHaveCasualties = TRUE;
					}
				}			
				pPlayer = pPlayerNext;
			}

			// sanity
			if (!bFoundZombies)
				this->dwZombieCount = 0;
				
		//	a-josbor: we didn't delete in the loop above, so do it here
			if (bWeHaveCasualties)  //	we now have to service any dead players.  
			{
		//		go back through the whole list, looking for the victims
				pPlayer = this->pPlayers;
				while (pPlayer)
				{
					ASSERT(VALID_DPLAY_PLAYER(pPlayer));
					pPlayerNext = pPlayer->pNextPlayer;
					if (pPlayer->dwFlags & DPLAYI_PLAYER_ON_DEATH_ROW)
					{
						DPF(3, "Killing Zombie player %d", pPlayer->dwID);
						hr = KillPlayer(this,pPlayer,TRUE);
						if (FAILED(hr))
						{
							// if we had a problem killing them, unset the bit
							// so we don't keep trying
							pPlayer->dwFlags &= ~DPLAYI_PLAYER_ON_DEATH_ROW;
							ASSERT(FALSE);
						}
						else
						{
							this->dwZombieCount--;
						}
						// we deleted pPlayer, and all of its local players.
						// so - pNextPlayer could have been deleted.  to be safe, we restart at 
						// the beginning of the list
						pPlayerNext = this->pPlayers;
					}
					pPlayer = pPlayerNext;
				}
			}

		}

		// time to send an enum?		
		dwCurrentTime = GetTickCount();
		if ((this->dwFlags & DPLAYI_DPLAY_ENUM) 
			&& (dwCurrentTime - this->dwLastEnum >= this->dwEnumTimeout))
		{
			// send enum request
			// Set bReturnStatus because we can't allow dialogs from this thread - no msg pump.
			hr = CallSPEnumSessions(this,this->pbAsyncEnumBuffer,this->dwEnumBufferSize,0, TRUE);
			if (FAILED(hr) && hr != DPERR_CONNECTING) 
			{
				DPF_ERRVAL("CallSPEnumSessions failed - hr = %08lx\n",hr);

				// No more async Enum's by this service thread until the app thread
				// restarts the process.  If the connection was lost, the SP can
				// dialogs from the app thread.

				// reset the flag
				this->dwFlags &= ~DPLAYI_DPLAY_ENUM;
				// make sure we don't send an enum request when we wake up
				this->dwEnumTimeout = INFINITE;
				// free up the buffer
				DPMEM_FREE(this->pbAsyncEnumBuffer);
				this->pbAsyncEnumBuffer = NULL;
			}
			
			this->dwLastEnum = GetTickCount();	
		}
		
		// time to give up waiting for acks on an add forward, and just send the client the 
		// nametable?
		CheckAddForwardList(this);		

		// a-josbor: time to clear out the reservation count?
		if (IAM_NAMESERVER(this))
		{
			if (dwCurrentTime > this->dwLastReservationTime + 
					(GetDefaultTimeout(this, FALSE) * RESERVATION_TIMEOUT_SCALE))
			{
				this->dwPlayerReservations = 0;
				this->dwLastReservationTime = dwCurrentTime;
			}	
		}
		
		LEAVE_ALL();
	}	

ERROR_EXIT:
	DPF(1,"DPlay thread exiting");
	return 0;

}  // DPlayThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpsecos.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecos.c
 *  Content:	Windows SSPI calls.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through
 *                      Windows Security Support Provider Interface (SSPI)
 *  04/14/97    sohailm Added definitions for OS_FreeContextBuffer(), OS_QueryContextAttributes(), 
 *                      and OS_QueryContextBufferSize().
 *  05/12/97    sohailm Updated code to use gpSSPIFuncTbl instead of gpFuncTbl.
 *                      Added functions to access Crypto API.  
 *  05/29/97    sohailm Now we don't include null char in the size of credentials strings passed to sp.
 *                      Added QueryContextUserName(). Updated QueryContextBufferSize to return HRESULT.
 *  06/22/97    sohailm We return SSPI errors instead of DPERR_GENERIC now.
 *  06/23/97    sohailm Added support for signing messages using CAPI.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *                      
 *
 ***************************************************************************/
#include <wtypes.h>
#include <newdpf.h>
#include <sspi.h>
#include "dplaypr.h"
#include "dpsecure.h"

/***************************************************************************
 * SSPI
 ***************************************************************************/

/*
 * Description: Checks to see if sspi function table has already been initialized
 */
BOOL OS_IsSSPIInitialized(void)
{
    if (gbWin95)
    {
        if (gpSSPIFuncTblA) return TRUE;
    }
    else 
    {
        if (gpSSPIFuncTbl) return TRUE;
    }

    return FALSE;
}

/*
 * Description: Initializes the security interface based on the operating system.
 */
BOOL OS_GetSSPIFunctionTable(HMODULE hModule)
{
    INIT_SECURITY_INTERFACE_A	addrProcISIA = NULL;
    INIT_SECURITY_INTERFACE 	addrProcISI = NULL;

    if (gbWin95)
    {
        addrProcISIA = (INIT_SECURITY_INTERFACE_A) GetProcAddress( hModule, 
            "InitSecurityInterfaceA");       

        if (addrProcISIA == NULL)
        {
            DPF(0,
               "GetProcAddress() of InitSecurityInterfaceA failed [%d]\n",
                GetLastError());
            return FALSE;
        }
        //
        // Get the SSPI function table
        //
        gpSSPIFuncTblA = (*addrProcISIA)();
        if (gpSSPIFuncTblA == NULL)
        {
            DPF(0,"InitSecurityInterfaceA() failed [0x%08x]\n", GetLastError());
            return FALSE;
        }
    }
    else
    {
        addrProcISI = (INIT_SECURITY_INTERFACE_W) GetProcAddress(hModule, 
            "InitSecurityInterfaceW");       

        if (addrProcISI == NULL)
        {
            DPF(0, 
                "GetProcAddress() of InitSecurityInterface failed [%d]\n",
                GetLastError());
            return FALSE;
        }
        //
        // Get the SSPI function table
        //
        gpSSPIFuncTbl = (*addrProcISI)();
        if (gpSSPIFuncTbl == NULL)
        {
            DPF(0,"InitSecurityInterface() failed [%d]\n", 
                GetLastError());
            return FALSE;
        }
    }
    
    // SUCCESS
    return TRUE;
}


SECURITY_STATUS OS_AcceptSecurityContext(
    PCredHandle         phCredential,
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCtxtHandle         phNewContext,
    PSecBufferDesc      pOutSecDesc,
    PULONG              pfContextAttributes,
    PTimeStamp          ptsTimeStamp
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->AcceptSecurityContext)) (
           phCredential, 
           phContext, 
           pInSecDesc,
           fContextReq, 
           TargetDataRep, 
           phNewContext,
           pOutSecDesc, 
           pfContextAttributes, 
           ptsTimeStamp
           );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->AcceptSecurityContext)) (
           phCredential, 
           phContext, 
           pInSecDesc,
           fContextReq, 
           TargetDataRep, 
           phNewContext,
           pOutSecDesc, 
           pfContextAttributes, 
           ptsTimeStamp
           );
    }
}

SECURITY_STATUS OS_AcquireCredentialsHandle(
    SEC_WCHAR *pwszPrincipal, 
    SEC_WCHAR *pwszPackageName,
    ULONG   fCredentialUse,
    PLUID   pLogonId,
    PSEC_WINNT_AUTH_IDENTITY_W pAuthDataW,
    PVOID   pGetKeyFn,
    PVOID   pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp  ptsLifeTime
    )
{
    ASSERT(pwszPackageName);

    if (gbWin95)
    {
        SEC_WINNT_AUTH_IDENTITY_A *pAuthDataA=NULL;
        SEC_WINNT_AUTH_IDENTITY_A AuthDataA;
        SECURITY_STATUS status;
        HRESULT hr;
        LPSTR pszPackageName = NULL;

        ASSERT(gpSSPIFuncTblA);
        ZeroMemory(&AuthDataA, sizeof(AuthDataA));

        // get an ansi package name
        hr = GetAnsiString(&pszPackageName,pwszPackageName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to get an ansi version of package name");
            status = E_FAIL;
            goto CLEANUP_EXIT;
        }

        if (pAuthDataW)
        {
            AuthDataA.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            // note - don't include null character in string size for credential strings
            if (pAuthDataW->User)
            {
                // get an ansi username
                hr = GetAnsiString(&AuthDataA.User,pAuthDataW->User);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of username");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.UserLength = STRLEN(AuthDataA.User)-1;
            }
            if (pAuthDataW->Password)
            {
                // get an ansi password
                hr = GetAnsiString(&AuthDataA.Password,pAuthDataW->Password);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of password");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.PasswordLength = STRLEN(AuthDataA.Password)-1;
            }
            if (pAuthDataW->Domain)
            {
                // get an ansi username
                hr = GetAnsiString(&AuthDataA.Domain,pAuthDataW->Domain);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of domain");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.DomainLength = STRLEN(AuthDataA.Domain)-1;
            }
            pAuthDataA = &AuthDataA;
        }

        status = (*(gpSSPIFuncTblA->AcquireCredentialsHandleA)) (
            NULL, 
            pszPackageName, 
            fCredentialUse,  
            NULL, 
            pAuthDataA, 
            NULL, 
            NULL, 
            phCredential, 
            ptsLifeTime
            );

            // fall through

        CLEANUP_EXIT:
            // cleanup all local allocations
            if (AuthDataA.User) DPMEM_FREE(AuthDataA.User);
            if (AuthDataA.Password) DPMEM_FREE(AuthDataA.Password);
            if (AuthDataA.Domain) DPMEM_FREE(AuthDataA.Domain);
            if (pszPackageName) DPMEM_FREE(pszPackageName);
            return status;
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->AcquireCredentialsHandle)) (
            NULL, 
            pwszPackageName, 
            fCredentialUse,  
            NULL, 
            pAuthDataW, 
            NULL, 
            NULL, 
            phCredential, 
            ptsLifeTime
            );
    }
}


SECURITY_STATUS OS_DeleteSecurityContext(
    PCtxtHandle phContext
    )
{
	CtxtHandle hNullContext;

    DPF(6,"Deleting security context handle 0x%08x",phContext);

    // Passing unitialized handles (0) is causing first chance exceptions in the 
    // following calls. Therefore we are making these calls only if the handle is non-null.
	ZeroMemory(&hNullContext, sizeof(CtxtHandle));
	if (0 == memcmp(&hNullContext, phContext, sizeof(CtxtHandle)))
	{
		return SEC_E_OK;
	}

    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->DeleteSecurityContext)) (phContext);
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->DeleteSecurityContext)) (phContext);
    }
}

SECURITY_STATUS OS_FreeCredentialHandle(
    PCredHandle     phCredential
    )
{
	CredHandle hNullCredential;

    DPF(6,"Freeing credential handle 0x%08x",phCredential);

    // Passing unitialized handles (0) is causing first chance exceptions in the 
    // following calls. Therefore we are making these calls only if the handle is non-null.
	ZeroMemory(&hNullCredential, sizeof(CredHandle));
	if (0 == memcmp(&hNullCredential, phCredential, sizeof(CredHandle)))
	{
		return SEC_E_OK;
	}

    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->FreeCredentialHandle)) (phCredential);        
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->FreeCredentialHandle)) (phCredential);        
    }
}

SECURITY_STATUS OS_FreeContextBuffer(
    PVOID   pBuffer
    )
{
    DPF(6,"Freeing context buffer 0x%08x",pBuffer);
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->FreeContextBuffer)) (pBuffer);        
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->FreeContextBuffer)) (pBuffer);        
    }
}

SECURITY_STATUS OS_InitializeSecurityContext(
    PCredHandle     phCredential,
    PCtxtHandle     phContext,
    SEC_WCHAR       *pwszTargetName,
    ULONG           fContextReq,
    ULONG           Reserved1,
    ULONG           TargetDataRep,
    PSecBufferDesc  pInput,
    ULONG           Reserved2,
    PCtxtHandle     phNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttributes,
    PTimeStamp      ptsExpiry
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->InitializeSecurityContextA)) (
            phCredential,
            phContext,   
            NULL,        
            fContextReq, 
            0L,          
            SECURITY_NATIVE_DREP, 
            pInput,
            0L,    
            phNewContext,
            pOutput,     
            pfContextAttributes,
            ptsExpiry           
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->InitializeSecurityContext)) (
            phCredential,       
            phContext,          
            NULL,               
            fContextReq,        
            0L,                 
            SECURITY_NATIVE_DREP,
            pInput,             
            0L,                 
            phNewContext,       
            pOutput,            
            pfContextAttributes,
            ptsExpiry           
            );
    }
}


SECURITY_STATUS OS_MakeSignature(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->MakeSignature)) (
            phContext,
            fQOP,        
            pOutSecDesc,
            MessageSeqNo           
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->MakeSignature)) (
            phContext,
            fQOP,        
            pOutSecDesc,
            MessageSeqNo           
            );
    }
}


SECURITY_STATUS OS_QueryContextAttributes(
    PCtxtHandle     phContext,
    ULONG           ulAttribute,
    LPVOID          pBuffer
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->QueryContextAttributesA)) (
            phContext,
            ulAttribute,
            pBuffer
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->QueryContextAttributes)) (
            phContext,
            ulAttribute,
            pBuffer
            );
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME	"OS_QueryContextBufferSize"

HRESULT OS_QueryContextBufferSize(
    SEC_WCHAR       *pwszPackageName,
    ULONG           *pulBufferSize
    )
{
    SECURITY_STATUS status;
    HRESULT hr;

    ASSERT(pwszPackageName);
    ASSERT(pulBufferSize);

    if (gbWin95)
    {
	    LPSTR pszPackageName=NULL;
        PSecPkgInfoA pspInfoA=NULL;
        HRESULT hr;

        ASSERT(gpSSPIFuncTblA);

        // get ansi version of security package name
        hr = GetAnsiString(&pszPackageName, pwszPackageName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to get ansi version of package name");
            goto CLEANUP_EXIT_A;
        }
        // query package for info
        status = (*(gpSSPIFuncTblA->QuerySecurityPackageInfoA)) (
            pszPackageName,
            &pspInfoA
            );

        if (!SEC_SUCCESS(status))
        {
            DPF_ERRVAL("QuerySecurityPackageInfo failed: Error=0x%08x",status);
            hr = status;
            goto CLEANUP_EXIT_A;
        }
        // update the size
        if (pspInfoA)
        {
            *pulBufferSize = pspInfoA->cbMaxToken;
        }

        // success
        hr = DP_OK;

        // fall through
    CLEANUP_EXIT_A:
        // cleanup local allocations
        if (pszPackageName) DPMEM_FREE(pszPackageName);
        if (pspInfoA) OS_FreeContextBuffer(pspInfoA);
        return hr;
    }
    else
    {
        PSecPkgInfoW pspInfoW=NULL;

        ASSERT(gpSSPIFuncTbl);

        status = (*(gpSSPIFuncTbl->QuerySecurityPackageInfo)) (
            pwszPackageName,
            &pspInfoW
            );
        if (!SEC_SUCCESS(status))
        {
            DPF_ERRVAL("QuerySecurityPackageInfo failed: Error=0x%08x",status);
            hr = status;
            goto CLEANUP_EXIT_W;
        }

        if (pspInfoW)
        {
            *pulBufferSize = pspInfoW->cbMaxToken;
        }

        // success
        hr = DP_OK;

        // fall through
    CLEANUP_EXIT_W:
        // cleanup
        if (pspInfoW) OS_FreeContextBuffer(pspInfoW);
        return hr;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME	"OS_QueryContextUserName"

HRESULT OS_QueryContextUserName(
    PCtxtHandle     phContext,
    LPWSTR          *ppwszUserName
    )
{
    SECURITY_STATUS status;
   	SecPkgContext_Names contextAttribs;
    HRESULT hr;

    ASSERT(phContext);
    ASSERT(ppwszUserName);

    // query the security package
    ZeroMemory(&contextAttribs,sizeof(contextAttribs));
	status = OS_QueryContextAttributes(phContext, SECPKG_ATTR_NAMES, &contextAttribs);
	if (!SEC_SUCCESS(status))
	{
        DPF_ERRVAL("QueryContextAttributes failed: Error=0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
	}

    if (gbWin95)
    {
        // convert username to unicode and copy it into caller's buffer
        hr = GetWideStringFromAnsi(ppwszUserName, (LPSTR)contextAttribs.sUserName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to convert username to wide format");
            goto CLEANUP_EXIT;
        }
    }
    else
    {
        // copy unicode username as is into caller's buffer
        hr = GetString(ppwszUserName, contextAttribs.sUserName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to copy username");
            goto CLEANUP_EXIT;
        }
    }

    // success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:
    OS_FreeContextBuffer(contextAttribs.sUserName);
    return hr;
}

SECURITY_STATUS OS_VerifySignature(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->VerifySignature)) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->VerifySignature)) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
}


SECURITY_STATUS OS_SealMessage(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pOutSecDesc,
    ULONG               MessageSeqNo
    )
{
    if (gbWin95)
    {
        SECURITY_STATUS (*pFuncSealMessage)() = gpSSPIFuncTblA->SEALMESSAGE;

        ASSERT(gpSSPIFuncTblA);
        return (*pFuncSealMessage) (
            phContext, 
            fQOP,
            pOutSecDesc, 
            MessageSeqNo
            );
    }
    else
    {
        SECURITY_STATUS (*pFuncSealMessage)() = gpSSPIFuncTbl->SEALMESSAGE;

        ASSERT(gpSSPIFuncTbl);
        return (*pFuncSealMessage) (
            phContext, 
            fQOP,
            pOutSecDesc, 
            MessageSeqNo
            );
   }
}


SECURITY_STATUS OS_UnSealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP
    )
{
    if (gbWin95)
    {
        SECURITY_STATUS (*pFuncUnSealMessage)() = gpSSPIFuncTblA->UNSEALMESSAGE;

        ASSERT(gpSSPIFuncTblA);
        return (*pFuncUnSealMessage) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
    else
    {
        SECURITY_STATUS (*pFuncUnSealMessage)() = gpSSPIFuncTbl->UNSEALMESSAGE;

        ASSERT(gpSSPIFuncTbl);
        return (*pFuncUnSealMessage) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
}


/***************************************************************************
 * CAPI
 ***************************************************************************/
extern BOOL
OS_IsCAPIInitialized(
    void
    )
{
    return (gpCAPIFuncTbl ? TRUE : FALSE);
}

BOOL
OS_GetCAPIFunctionTable(
    HMODULE hModule
    )
{
    ASSERT(hModule);
 
    // allocate memory for CAPI function table
    gpCAPIFuncTbl = DPMEM_ALLOC(sizeof(CAPIFUNCTIONTABLE));
    if (!gpCAPIFuncTbl)
    {
        DPF_ERR("Failed to create CAPI function table - out of memory");
        return FALSE;
    }

    // initialize function table
    if (gbWin95)
    {
        gpCAPIFuncTbl->CryptAcquireContextA = (PFN_CRYPTACQUIRECONTEXT_A)GetProcAddress(hModule,"CryptAcquireContextA");
        if (NULL == gpCAPIFuncTbl->CryptAcquireContextA)
        {
            DPF_ERR("Failed to get pointer to CryptAcquireContextA");
            goto ERROR_EXIT;
        }
    }
    else
    {
        gpCAPIFuncTbl->CryptAcquireContextW = (PFN_CRYPTACQUIRECONTEXT_W)GetProcAddress(hModule,"CryptAcquireContextW");
        if (NULL == gpCAPIFuncTbl->CryptAcquireContextW)
        {
            DPF_ERR("Failed to get pointer to CryptAcquireContextW");
            goto ERROR_EXIT;
        }
    }

    gpCAPIFuncTbl->CryptReleaseContext = (PFN_CRYPTRELEASECONTEXT) GetProcAddress(hModule,"CryptReleaseContext");
    if (NULL == gpCAPIFuncTbl->CryptReleaseContext)
    {
        DPF_ERR("Failed to get pointer to CryptReleaseContext");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptGenKey = (PFN_CRYPTGENKEY) GetProcAddress(hModule,"CryptGenKey");
    if (NULL == gpCAPIFuncTbl->CryptGenKey)
    {
        DPF_ERR("Failed to get pointer to CryptGenKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDestroyKey = (PFN_CRYPTDESTROYKEY) GetProcAddress(hModule,"CryptDestroyKey");
    if (NULL == gpCAPIFuncTbl->CryptDestroyKey)
    {
        DPF_ERR("Failed to get pointer to CryptDestroyKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptExportKey = (PFN_CRYPTEXPORTKEY) GetProcAddress(hModule,"CryptExportKey");
    if (NULL == gpCAPIFuncTbl->CryptExportKey)
    {
        DPF_ERR("Failed to get pointer to CryptExportKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptImportKey = (PFN_CRYPTIMPORTKEY) GetProcAddress(hModule,"CryptImportKey");
    if (NULL == gpCAPIFuncTbl->CryptImportKey)
    {
        DPF_ERR("Failed to get pointer to CryptImportKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptEncrypt = (PFN_CRYPTENCRYPT) GetProcAddress(hModule,"CryptEncrypt");
    if (NULL == gpCAPIFuncTbl->CryptEncrypt)
    {
        DPF_ERR("Failed to get pointer to CryptEncrypt");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDecrypt = (PFN_CRYPTDECRYPT) GetProcAddress(hModule,"CryptDecrypt");
    if (NULL == gpCAPIFuncTbl->CryptDecrypt)
    {
        DPF_ERR("Failed to get pointer to CryptDecrypt");
        goto ERROR_EXIT;
    }
    
    gpCAPIFuncTbl->CryptCreateHash = (PFN_CRYPTCREATEHASH) GetProcAddress(hModule,"CryptCreateHash");
    if (NULL == gpCAPIFuncTbl->CryptCreateHash)
    {
        DPF_ERR("Failed to get pointer to CryptCreateHash");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDestroyHash = (PFN_CRYPTDESTROYHASH) GetProcAddress(hModule,"CryptDestroyHash");
    if (NULL == gpCAPIFuncTbl->CryptDestroyHash)
    {
        DPF_ERR("Failed to get pointer to CryptDestroyHash");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptHashData = (PFN_CRYPTHASHDATA) GetProcAddress(hModule,"CryptHashData");
    if (NULL == gpCAPIFuncTbl->CryptHashData)
    {
        DPF_ERR("Failed to get pointer to CryptHashData");
        goto ERROR_EXIT;
    }

	if (gbWin95)
	{
		gpCAPIFuncTbl->CryptSignHashA = (PFN_CRYPTSIGNHASH_A) GetProcAddress(hModule,"CryptSignHashA");
		if (NULL == gpCAPIFuncTbl->CryptSignHashA)
		{
			DPF_ERR("Failed to get pointer to CryptSignHashA");
			goto ERROR_EXIT;
		}
	}
	else
	{
		gpCAPIFuncTbl->CryptSignHashW = (PFN_CRYPTSIGNHASH_W) GetProcAddress(hModule,"CryptSignHashW");
		if (NULL == gpCAPIFuncTbl->CryptSignHashW)
		{
			DPF_ERR("Failed to get pointer to CryptSignHashW");
			goto ERROR_EXIT;
		}
	}

	if (gbWin95)
	{
		gpCAPIFuncTbl->CryptVerifySignatureA = (PFN_CRYPTVERIFYSIGNATURE_A) GetProcAddress(hModule,"CryptVerifySignatureA");
		if (NULL == gpCAPIFuncTbl->CryptVerifySignatureA)
		{
			DPF_ERR("Failed to get pointer to CryptVerifySignatureA");
			goto ERROR_EXIT;
		}
	}
	else
	{
		gpCAPIFuncTbl->CryptVerifySignatureW = (PFN_CRYPTVERIFYSIGNATURE_W) GetProcAddress(hModule,"CryptVerifySignatureW");
		if (NULL == gpCAPIFuncTbl->CryptVerifySignatureW)
		{
			DPF_ERR("Failed to get pointer to CryptVerifySignatureW");
			goto ERROR_EXIT;
		}
	}

    // success
    return TRUE;

ERROR_EXIT:
    OS_ReleaseCAPIFunctionTable();
    return FALSE;
}

void
OS_ReleaseCAPIFunctionTable(
    void
    )
{
    if (gpCAPIFuncTbl)
    {
        DPMEM_FREE(gpCAPIFuncTbl);
        gpCAPIFuncTbl = NULL;
    }
}

BOOL 
OS_CryptAcquireContext(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvider,
    DWORD       dwProvType,
    DWORD       dwFlags,
    LPDWORD     lpdwLastError
    )
{
    BOOL fResult=0;

    ASSERT(gpCAPIFuncTbl);

	*lpdwLastError=0;

    if (gbWin95)
    {
        LPSTR pszContainer=NULL, pszProvider=NULL;
        HRESULT hr;

        if (pwszContainer)
        {
            hr = GetAnsiString(&pszContainer,pwszContainer);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi container name: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        if (pwszProvider)
        {
            hr = GetAnsiString(&pszProvider,pwszProvider);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi provider name: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        fResult = gpCAPIFuncTbl->CryptAcquireContextA(phProv,pszContainer,pszProvider,dwProvType,dwFlags);

		if(!fResult)*lpdwLastError = GetLastError();

        // fall through
    CLEANUP_EXIT:
        if (pszContainer) DPMEM_FREE(pszContainer);
        if (pszProvider) DPMEM_FREE(pszProvider);
    }
    else
    {
        fResult = gpCAPIFuncTbl->CryptAcquireContext(phProv,pwszContainer,pwszProvider,dwProvType,dwFlags);

		if(!fResult)*lpdwLastError = GetLastError();
    }

    return fResult;
}

BOOL
OS_CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    )
{
	// don't pass null handles as it might crash the following call
	if (0 == hProv)
	{
		return TRUE;
	}
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptReleaseContext(hProv,dwFlags);
}

BOOL
OS_CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptGenKey(hProv,Algid,dwFlags,phKey);
}

BOOL
OS_CryptDestroyKey(
    HCRYPTKEY hKey
    )
{
    // Passing unitialized handles (0) is causing a first chance exception in the 
    // following call. Therefore we are making the call only if the handle is non-null.
	if (0 == hKey)
	{
		return TRUE;
	}

    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDestroyKey(hKey);
}

BOOL
OS_CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptExportKey(hKey,hExpKey,dwBlobType,dwFlags,pbData,pdwDataLen);
}

BOOL
OS_CryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptImportKey(hProv,pbData,dwDataLen,hPubKey,dwFlags,phKey);
}

BOOL
OS_CryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptEncrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen,dwBufLen);
}

BOOL
OS_CryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDecrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen);
}


BOOL 
OS_CryptCreateHash( 
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	)
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptCreateHash(hProv,Algid,hKey,dwFlags,phHash);
}

BOOL 
OS_CryptDestroyHash( 
	HCRYPTHASH hHash
	)
{
    // Passing unitialized handles (0) is causing a first chance exception in the 
    // following call. Therefore we are making the call only if the handle is non-null.
	if (0 == hHash)
	{
		return TRUE;
	}

    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDestroyHash(hHash);
}

BOOL 
OS_CryptHashData( 
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	)
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptHashData(hHash,pbData,dwDataLen,dwFlags);
}

BOOL 
OS_CryptSignHash( 
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPWSTR pwszDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	)
{
	BOOL fResult;

    ASSERT(gpCAPIFuncTbl);

    if (gbWin95)
    {
        LPSTR pszDescription=NULL;
        HRESULT hr;

        if (pwszDescription)
        {
            hr = GetAnsiString(&pszDescription,pwszDescription);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

		fResult = gpCAPIFuncTbl->CryptSignHashA(hHash,dwKeySpec,pszDescription,dwFlags,pbSignature,pdwSigLen);

        // fall through
    CLEANUP_EXIT:
        if (pszDescription) DPMEM_FREE(pszDescription);
    }
    else
    {
	    fResult = gpCAPIFuncTbl->CryptSignHash(hHash,dwKeySpec,pwszDescription,dwFlags,pbSignature,pdwSigLen);
    }

    return fResult;
}

BOOL 
OS_CryptVerifySignature( 
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPWSTR pwszDescription,
	DWORD dwFlags
	)
{
	BOOL fResult;

    ASSERT(gpCAPIFuncTbl);

    if (gbWin95)
    {
        LPSTR pszDescription=NULL;
        HRESULT hr;

        if (pwszDescription)
        {
            hr = GetAnsiString(&pszDescription,pwszDescription);
            if (FAILED(hr))
            {
            	//Can't DPF here, since we don't want to step on LastError.
                //DPF(0,"Failed to get ansi description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        fResult = gpCAPIFuncTbl->CryptVerifySignatureA(hHash,pbSignature,dwSigLen,hPubKey,pszDescription,dwFlags);

        // fall through
    CLEANUP_EXIT:
        if (pszDescription) DPMEM_FREE(pszDescription);
    }
    else
    {
        fResult = gpCAPIFuncTbl->CryptVerifySignature(hHash,pbSignature,dwSigLen,hPubKey,pwszDescription,dwFlags);
    }

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\dpunk.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpunk.c
 *  Content:	IUnknown implementation for dplay
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	1/96	andyco	created it
 *	5/20	andyco	idirectplay2
 *	6/26/96	kipo	use the CALLSPVOID macro
 *	7/10/96	andyco	#2282 - addref addrefs int ref cnt, not obj ref cnt.  
 *					changed dp_close(this) to dp_close(this->pInterfaces...) DUH!
 *	7/16/96	kipo	include dplaysp.h so we declare our GUID once in dplay.dll
 *  8/9/96  sohailm free the sp when dplay goes away
 *	9/1/96	andyco	take service lock + drop dplay on sp_shutdown
 *  10/3/96 sohailm renamed GUID validation macros to use the term GUID instead of UUID
 *                  added a check for null lpGuid in QueryInterface parameter validation
 *	1/24/97	andyco	call freelibrary on the sp 
 *	3/12/97	myronth	added lobby object cleanup code
 *	3/15/97	andyco	destroy dplay b4 interface, so apps using the interface off a timer
 *					don't get hosed.
 *	5/13/97	myronth	Drop the locks before calling the lobby cleanup otherwise
 *					the dplay worker thread in the lower object can't take them
 *					and we hang.  (Bug #8414)
 *	8/19/97	myronth	Release copy of the lobby interface we were launched on
 *	10/21/97myronth	Added IDirectPlay4 and 4A interfaces to QI
 *  12/18/97 aarono Free memory pools
 *   2/18/98 aarono dispatch HandleMessage to protocol when active
 *   2/19/98 aarono don't call protocol for Shutdown, done in DP_Close now.
 *   3/16/98 aarono moved FreePacketList to Release from DP_Close
 ***************************************************************************/

#define INITGUID
#include "dplaypr.h"
#include "dplobby.h"	// Needed to get the DEFINE_GUID's to work
#include "dplaysp.h"	// Same here
#include "dpprot.h"
#include <initguid.h>
#include "..\protocol\mytimer.h"

#undef DPF_MODNAME
#define DPF_MODNAME "GetInterface"

// find an interface with the pCallbacks vtbl on this object.
// if one doesn't exist, create it
// ref count and return the interface
HRESULT GetInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT * ppInt,LPVOID pCallbacks)
{
	LPDPLAYI_DPLAY_INT pCurrentInts = this->pInterfaces;
	BOOL bFound = FALSE;

	ASSERT(ppInt);

	// see if there is already an interface
	while (pCurrentInts && !bFound)
	{
		if (pCurrentInts->lpVtbl == pCallbacks)
		{
			bFound = TRUE;
		}
		else pCurrentInts = pCurrentInts->pNextInt;
	}
	// if there is, return it
	if (bFound)
	{
		*ppInt = pCurrentInts;
		(*ppInt)->dwIntRefCnt++;
		// we don't increment this->dwRefCnt, since it's one / interface object
		return DP_OK;
	}
	// else, 
	// create one
	*ppInt = DPMEM_ALLOC(sizeof(DPLAYI_DPLAY_INT));
	if (!*ppInt) 
	{
		DPF_ERR("could not alloc interface - out of memory");
		return E_OUTOFMEMORY;
	}

	(*ppInt)->dwIntRefCnt = 1;
	(*ppInt)->lpDPlay = this;
	(*ppInt)->pNextInt = this->pInterfaces;
	(*ppInt)->lpVtbl = pCallbacks;
	this->pInterfaces = *ppInt;
	this->dwRefCnt++; // one this->dwRefCnt for each interface object...
	return DP_OK;
	
} // GetInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DP_QueryInterface"
HRESULT DPAPI DP_QueryInterface(LPDIRECTPLAY lpDP, REFIID riid, LPVOID * ppvObj) 
{
    
    LPDPLAYI_DPLAY this;
    HRESULT hr;

  	DPF(7,"Entering DP_QueryInterface");
	ENTER_DPLAY();
    
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			// we allow uninited dplays to QI
			if (hr != DPERR_UNINITIALIZED)
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
				return hr;
			}
		}

		if ( !riid || (!VALID_READ_GUID_PTR(riid)) )
		{
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
		}
		
		if (!ppvObj || (!VALID_GUID_PTR(ppvObj)) )
		{
			LEAVE_DPLAY();
			DPF_ERR("invalid object pointer");
			return DPERR_INVALIDPARAMS;
		}
		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

     *ppvObj=NULL;

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, &IID_IUnknown) || 
        IsEqualIID(riid, &IID_IDirectPlay) )
    {
		// get an idirectplay
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectPlay2) )
	{
		// get an idirectplay2
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks2 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay2A) )
	{
		// get an idirectplay2A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks2A );
	}
    else if( IsEqualIID(riid, &IID_IDirectPlay3) )
	{
		// get an idirectplay3
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks3 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay3A) )
	{
		// get an idirectplay3A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks3A );
	}
    else if( IsEqualIID(riid, &IID_IDirectPlay4) )
	{
		// get an idirectplay4
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks4 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay4A) )
	{
		// get an idirectplay4A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks4A );
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    LEAVE_DPLAY();
    return hr;

}//DP_QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DP_AddRef"
ULONG DPAPI DP_AddRef(LPDIRECTPLAY lpDP) 
{
	DWORD dwRefCnt;
    LPDPLAYI_DPLAY_INT pInt;

	DPF(7,"Entering DP_AddRef");

    ENTER_DPLAY();
    
    TRY
    {
		pInt = (LPDPLAYI_DPLAY_INT)	lpDP;
		if (!VALID_DPLAY_INT(pInt))
		{
            LEAVE_DPLAY();
            return 0;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }

    pInt->dwIntRefCnt++;
    dwRefCnt = pInt->dwIntRefCnt;

    LEAVE_DPLAY();
    return dwRefCnt;		

}//DP_AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Release"

// remove pInt from the list of interfaces, and the free it
HRESULT  DestroyDPlayInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT pInt) 
{
	LPDPLAYI_DPLAY_INT pIntPrev; // the interface preceeding pInt in the list
	BOOL bFound=FALSE;

	if (NULL == this->pInterfaces) return DP_OK;

	// remove pInt from the list of interfaces
	if (this->pInterfaces == pInt) 
	{
		// it's the 1st one, just remove it
		this->pInterfaces = pInt->pNextInt;
	}
	else 
	{
		pIntPrev = this->pInterfaces;
		while (pIntPrev && !bFound)
		{
			if (pIntPrev->pNextInt == pInt)
			{
				bFound = TRUE;
			}
			else pIntPrev = pIntPrev->pNextInt;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		// take pint out of the list
		pIntPrev->pNextInt = pInt->pNextInt;
		
	}

	DPMEM_FREE(pInt);

	return DP_OK;
} // DestroyDPlayInterface

// take this dplay object out of the list of dplay objects (gpObjectList)
HRESULT RemoveThisFromList(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_DPLAY search,prev;
	
	ASSERT(gpObjectList); // better have at least this in list
	
	DPF(3,"removing this = 0x%08lx from object list", this);
	
	// is it the head?
	if (this == gpObjectList)
	{
		// remove from the front
		gpObjectList = gpObjectList->pNextObject;
		return DP_OK;
	}
	
	// else 
	prev = gpObjectList;
	search = gpObjectList->pNextObject;
	
	while ( (search) && (search != this))
	{
		prev = search;
		search = search->pNextObject;
	}

	if (search != this)
	{
		DPF_ERR("could not find this ptr in object list - badbadbad");
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	// else
	ASSERT(prev);	
	prev->pNextObject = this->pNextObject;

	return DP_OK;
	
} // RemoveThisFromList

// free the list of session nodes attached to this pointer
HRESULT FreeSessionList(LPDPLAYI_DPLAY this)
{
	LPSESSIONLIST pNext,pCurrent;

	pCurrent = this->pSessionList;
	while (pCurrent)
	{
		//
		// pCurrent is the current node to destroy
		// pNext is the next node in the list  - get it before we destroy pCurrent...
		//
		pNext = pCurrent->pNextSession;
		// 
		// now, destroy pCurrent
		//
		// free up the sp blob stored w/ the desc
		if (pCurrent->pvSPMessageData) DPMEM_FREE(pCurrent->pvSPMessageData);
		
        FreeDesc(&(pCurrent->dpDesc), FALSE);
		// free the session node
		DPMEM_FREE(pCurrent);
		// move onto next node
		pCurrent = pNext;
	}

	this->pSessionList = NULL;

	return DP_OK;
}// FreeSessionList

// Called from Release
HRESULT DestroyDPlay(LPDPLAYI_DPLAY this)
{
	HRESULT hr=DP_OK;
    DWORD dwError;

	if (this->lpsdDesc) // session open?
	{
		DPF(9,"Closing session %x this->dwFlags %x \n",this->lpsdDesc,this->dwFlags);
	   	// leave dplay, so if sp has threads waiting to get in, they can...
		LEAVE_ALL();

		hr=DP_Close((LPDIRECTPLAY)this->pInterfaces);

		ENTER_ALL();
	} else {
		DPF(0,"Closing with no open sessions\n");
	}

	if(hr==DP_OK){

		// Shutdown extended Timers
		FiniTimerWorkaround();

		// free up the session list
		FreeSessionList(this);
		
	   	// mark dplay as closed
		this->dwFlags |= DPLAYI_DPLAY_CLOSED;

		ASSERT(1 == gnDPCSCount); // when we drop locks - this needs to go to 0!

		// free any packets we're holding
		// drops and reacquires locks, shouldn't hurt here since we drop again.
		FreePacketList(this); 

		FiniReply(this);

		LEAVE_ALL();
		
		// kill the worker thread
		if(this->hDPlayThread){
			KillThread(this->hDPlayThread,this->hDPlayThreadEvent);
			this->hDPlayThread = 0;
			this->hDPlayThreadEvent = 0;
		}	

		ENTER_SERVICE();

	    if (this->pcbSPCallbacks->ShutdownEx)  
	    {
			DPSP_SHUTDOWNDATA shutdata;		
		
			shutdata.lpISP = this->pISP;
	   		hr = CALLSP(this->pcbSPCallbacks->ShutdownEx,&shutdata);
	    }
		else if (this->pcbSPCallbacks->Shutdown) 
		{
	   		hr = CALLSPVOID( this->pcbSPCallbacks->Shutdown );
		}
		else 
		{
			// shutdown is optional
			hr = DP_OK;
		}
	    
		ENTER_DPLAY();
		
		if (FAILED(hr)) 
		{
			DPF_ERR("could not invoke shutdown");
		}

		if (this->dwFlags & DPLAYI_DPLAY_DX3SP)	
		{
			// if there's one loaded, this must be it -
			// since we're destroying the dx3 sp - reset our global flag
			gbDX3SP = FALSE;
		}
		
		// free the sp Data
		if (this->pvSPLocalData)	
		{
			DPMEM_FREE(this->pvSPLocalData);
			this->pvSPLocalData = NULL;
			this->dwSPLocalDataSize = 0;
		}

		// Free memory pools
		FreeMemoryPools(this);

		// free all interfaces
		while (this->pInterfaces)
		{
			hr = DestroyDPlayInterface(this,this->pInterfaces);	
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay interface! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
				// keep trying...
			}
		}

		ASSERT(NULL == this->pInterfaces);

		// callbacks should be set in directplaycreate
		ASSERT(this->pcbSPCallbacks);
		DPMEM_FREE(this->pcbSPCallbacks);

	    // unload sp module
	    if (this->hSPModule)
	    {
	        if (!FreeLibrary(this->hSPModule))
	        {
	            ASSERT(FALSE);
				dwError = GetLastError();
				DPF_ERR("could not free sp module");
				DPF(0, "dwError = %d", dwError);
	        }
	    }
		
		if (this->pbAsyncEnumBuffer) DPMEM_FREE(this->pbAsyncEnumBuffer);
		// remove this from the dll object list
		RemoveThisFromList(this);
		gnObjects--;
		
		// just to be safe
		this->dwSize = 0xdeadbeef;

		// Drop the locks so that the lower dplay object in dpldplay can
		// get back in.  If we don't drop these, the worker thread in
		// dplay will hang trying to get these when it goes to shutdown
		LEAVE_ALL();
		
		// If we were lobby launched, release the interface we used to
		// communicate with the lobby server
		if(this->lpLaunchingLobbyObject)
		{
			IDirectPlayLobby_Release(this->lpLaunchingLobbyObject);
			this->lpLaunchingLobbyObject = NULL;	// just to be safe
		}

		// destroy the lobby object
		PRV_FreeAllLobbyObjects(this->lpLobbyObject);
		this->lpLobbyObject = NULL;		// just to be safe

		// Take the locks back
		ENTER_ALL();	
		
		DPMEM_FREE(this);	
		return DP_OK;
	}	else {
		DPF(0,"Someone called close after last release?\n");
		ASSERT(0);
		return DP_OK; // don't rock the boat.
	}
} // DestroyDPlay

ULONG DPAPI DP_Release(LPDIRECTPLAY lpDP)
{
    LPDPLAYI_DPLAY this;
    LPDPLAYI_DPLAY_INT pInt;
    HRESULT hr=DP_OK;
	DWORD dwReleaseCnt=1;	// if we've been init'ed, we release at 1, otherwise we 
							// release at 0, unless it is a lobby-owned object in
							// which case we still release at 1
	ULONG rc;
								
	DPF(7,"Entering DP_Release");
	
	ENTER_ALL();    
	
    TRY
    {
		pInt = (LPDPLAYI_DPLAY_INT)	lpDP;
		if (!VALID_DPLAY_INT(pInt))
		{
			LEAVE_ALL();
            return 0;
		}
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			// we allow uninited dplays to release
			if (hr != DPERR_UNINITIALIZED)
			{
				LEAVE_ALL();
				DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
				return 0;
			}
			else 
			{
				// we were unitialized - no IDirectPlaySP to account for
				dwReleaseCnt = 0; 
			}
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return 0;
    }

	// dec the interface count
	rc=--pInt->dwIntRefCnt;
	if (0 == rc)
	{
		// since we've destroyed an interface, dec the object count
	    this->dwRefCnt--;
		
	    if (dwReleaseCnt == this->dwRefCnt) // destroy @ ref = 1, 1 for IDirectPlaySP
	    {
			// nuke the dplay object
			if (1 == dwReleaseCnt) DPF(1,"direct play object - ref cnt = 1 (1 for IDirectPlaySP)!");
			else DPF(1,"direct play object - ref cnt = 0 (SP not initialized)!");
			
			hr = DestroyDPlay(this);
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
			}
	    } // 0 == this->dwRefCnt
		else
		{
			// if we destroyed dplay, it nuked all interfaces for us
			// otherwise, we do it here
			DPF(1,"destroying interface - int ref cnt = 0");
			// take interface out of the table
			hr = DestroyDPlayInterface(this,pInt);
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay interface! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
				// keep trying...
			}
			
		}
		
		LEAVE_ALL();
		return 0;

	} //0 == pInt->dwIntRefCnt 
	   	
	LEAVE_ALL();
    return rc;
	
}//DP_Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\mcontext.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcontext.h
 *  Content:	structures for message context mapping for SendEx
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *	12/8/97		aarono      Created
 *  2/13/98     aarono      got rid of special case for 1 context
 *
 *  Abstract:
 *
 *  Maintains a table of context mappings for messages being sent
 *  asynchronously.  Also keeps track of group sends vs. directed
 *  sends so that cancel can cancel them together.
 * 
 ***************************************************************************/
#ifndef _MSG_CONTEXT_H_
#define _MSG_CONTEXT_H_
		
#define MSG_FAST_CONTEXT_POOL_SIZE  20

#define INIT_CONTEXT_TABLE_SIZE     16
#define CONTEXT_TABLE_GROW_SIZE     16

#define N_UNIQUE_BITS 16
#define UNIQUE_ADD (1<<(32-N_UNIQUE_BITS))
#define CONTEXT_INDEX_MASK (UNIQUE_ADD-1)
#define CONTEXT_UNIQUE_MASK (0xFFFFFFFF-CONTEXT_INDEX_MASK)

#define LIST_END 0xFFFFFFFF

typedef PVOID (*PAPVOID)[]; // pointer to array of void pointers

typedef struct _SENDPARMS SENDPARMS, *PSENDPARMS, *LPSENDPARMS;

typedef struct _MsgContextEntry {
	PSENDPARMS psp;
	DWORD      nUnique;
	DWORD	   nContexts;
	union {
		PAPVOID   papv;	 
		UINT      iNextAvail;
	};	
} MSGCONTEXTENTRY, *PMSGCONTEXTENTRY;

typedef struct _MsgContextTable {
	UINT nUnique;
 	UINT nTableSize;
 	UINT iNextAvail;
 	MSGCONTEXTENTRY MsgContextEntry[0];
} MSGCONTEXTTABLE, *PMSGCONTEXTTABLE;

VOID InitTablePool(LPDPLAYI_DPLAY this);
VOID FiniTablePool(LPDPLAYI_DPLAY this);


//Internal
HRESULT InitContextTable(LPDPLAYI_DPLAY this);
VOID FiniContextTable(LPDPLAYI_DPLAY this);
PAPVOID AllocContextList(LPDPLAYI_DPLAY this, UINT nArrayEntries);
VOID FreeContextList(LPDPLAYI_DPLAY this, PAPVOID pList, UINT nArrayEntries);

//External
HRESULT ReadContextList(LPDPLAYI_DPLAY this, PVOID Context, PAPVOID *lplpContextArray, PUINT lpnArrayEntries,BOOL bVerify);
HRESULT WriteContextList(LPDPLAYI_DPLAY this, PVOID Context, PAPVOID papvContextArray, 	UINT nArrayEntries);
VOID ReleaseContextList(LPDPLAYI_DPLAY this, PVOID Context);
PVOID AllocateContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nArrayEntries);
PSENDPARMS pspFromContext(LPDPLAYI_DPLAY this, 	PVOID Context, BOOL bAddRef);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\msgmem.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
*
*  File:       msgmem.c
*  Content:	   message memory management
*  History:
*   Date		By		Reason
*   ====		==		======
*  12/31/97   aarono    Original
*
*
* Abstract
* --------
* (AO 12-31-97)
* Contention is that using the heap manager is not actually significant
* vs doing our own memory management for message buffers.  I do not
* currently support this contention and believe that directplay should not
* call HeapAlloc or GlobalAlloc in the hot path.  In order to prove this
* though I will first use HeapAlloc and GlobalAlloc for a profile run
* through these routines.  If the per hit is significant for a server type
* configuration then we will write our own packet memory manager. If the
* perf hit of using system heap is negligible this fill will be left as is.
***************************************************************************/

#include "dplaypr.h"

void * MsgAlloc( int size )
{
	return DPMEM_ALLOC(size);
}

void MsgFree (void *context, void *pmem)
{
	DPMEM_FREE(pmem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "dplaypr.h"
#include "windows.h"
#include "fpm.h"

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = DPMEM_ALLOC(this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			DPMEM_FREE(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	ASSERT(0);

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			DPMEM_FREE(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		DPMEM_FREE(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		ASSERT(0);
	}
	DeleteCriticalSection(&this->cs);
	DPMEM_FREE(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)DPMEM_ALLOC(sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\iplay1.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iplay1.c
 *  Content:	entry points for idirectplay1. entry points common to
 *				idirectplay1 and idirectplay2 are in iplay.c
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	5/8/96	andyco	created it
 *	6/19/96	kipo	Bug #2047. Changed DP_1_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Derek bug. CopyName() was not checking the application buffer
 *					size correctly before copying the buffer.
 *	6/20/96	andyco	added WSTRLEN_BYTES so we get the right strlength in copy string
 *	6/22/96	andyco	pass unicode sessiondesc2 to internalenumsessions so 
 *					we can send the password w/ the request
 *	6/26/96	andyco	pass DP_Open only DPOPEN_OPEN or DPOPEN_JOIN.  Also, 
 *					made sure we get service lock b4 getting dplay lock on enums.
 *	6/26/96	kipo	changed guidGame to guidApplication.
 *  7/8/96  ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                  to 'dpnName' to match DPLAY.H
 *	7/10/96	kipo	converter DPSYS_DELETEPLAYERORGROUP message to a DPSYS_DELETEPLAYER
 *					or DPSYS_DELETEGROUP message for DP1.0 compatability.
 *  7/11/96 ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
 *	7/11/96	andyco	wrapped receive param check in try / except
 * 7/30/96 	kipo    player event is a handle now
 *	8/10/96	andyco 	check DPSESSION_JOINDISABLED in checksessiondesc
 *  8/12/96	andyco	call internalreceive so we can get addplayer 10 size correct.
 *  8/13/96	kipo	bug #3186: return currentPlayers in DP 1.0 session description.
 *  8/13/96 kipo	bug #3203: DP_1_GetPlayerName() should allow player and groups.
 *  10/2/96 sohailm bug #2847: replaced VALID_DPSESSIONDESC_PTR() macros with 
 *                  VALID_READ_DPSESSIONDESC_PTR() macros where appropriate.
 * 10/14/96 sohailm bug #3526: not validating session id before dereferencing as guid pointer
 *	11/19/97myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 ***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_CreatePlayer"

HRESULT DPAPI DP_1_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPSTR lpszShortName,LPSTR lpszLongName,LPHANDLE phEvent)
{
    LPDPLAYI_DPLAY this;
    LPDPLAYI_PLAYER lpPlayer;
	DPNAME Name;
	HANDLE hEvent = NULL;	// assume we won't use events for this player
	HRESULT	hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check event
		if (phEvent && !VALID_DWORD_PTR(phEvent))
		{
	        DPF_ERR( "bad event pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if (phEvent && *phEvent)
		{
			DPF(3,"warning, *phEvent is non-null - dplay will be stomping this data!");
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// caller wants to use events
	if (phEvent)
	{
		ENTER_DPLAY();

		// create a manual-reset event
		hEvent = CreateEventA(NULL,TRUE,FALSE,NULL);

		LEAVE_DPLAY();

		if (!hEvent)
		{
	        DPF_ERR( "could not create event" );
	        hr = DPERR_NOMEMORY;
			goto Failure;
		}
	}

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);
	
	// call the ansi entry w/ the new struct
	hr = DP_A_CreatePlayer(lpDP, pidPlayerID,&Name,hEvent,NULL,0,0);
	if FAILED(hr)
		goto Failure;

	if (hEvent)
	{
		ENTER_DPLAY();

		// get pointer to player structure
        lpPlayer = PlayerFromID(this,*pidPlayerID);

        if (!VALID_DPLAY_PLAYER(lpPlayer))
		{
	        DPF_ERR( "invalid player ID" );
			hr = DPERR_INVALIDPLAYER;
			LEAVE_DPLAY();
			goto Failure;
		}

		// remember to delete this event when player is deleted
		lpPlayer->dwFlags |= DPLAYI_PLAYER_CREATEDPLAYEREVENT;

		// return event we created
		*phEvent = hEvent;
		LEAVE_DPLAY();
	}

	return (DP_OK);

Failure:
	if (hEvent)
		CloseHandle(hEvent);
		
	return (hr);

} // DP_1_CreatePlayer
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_CreateGroup"

HRESULT DPAPI DP_1_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPSTR lpszShortName,LPSTR lpszLongName) 
{
	DPNAME Name;

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);

	// call the ansi entry w/ the new struct
	return 	DP_A_CreateGroup(lpDP, pidGroupID,&Name,NULL,0,0);

} // DP_1_CreateGroup
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumGroupPlayers"

HRESULT DPAPI DP_1_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,NULL,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_1);


	LEAVE_ALL();
	
	return hr;

} // DP_1_EnumGroupPlayers
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumGroups"

HRESULT DPAPI DP_1_EnumGroups(LPDIRECTPLAY lpDP,DWORD dwSessionID,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroups(lpDP,(LPGUID)dwSessionID,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_1);


	LEAVE_ALL();
	
	return hr;

} // DP_1_EnumGroups
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumPlayers"

HRESULT DPAPI DP_1_EnumPlayers(LPDIRECTPLAY lpDP, DWORD dwSessionID, 
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,(LPGUID)dwSessionID,(LPVOID) lpEnumCallback,pvContext,dwFlags,ENUM_1);


	LEAVE_ALL();

	return hr;

} // DP_1_EnumPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumSessions"

// convert a unicode dpsessiondesc2 to (ansi) dpsessiondesc
// note we can't memcpy, since fields are not lined up
void Get10Desc(LPDPSESSIONDESC pDesc1,LPDPSESSIONDESC2 pDesc)
{
	memset(pDesc1,0,sizeof(DPSESSIONDESC));
	// copy over fields
	pDesc1->dwSize = sizeof(DPSESSIONDESC);
	pDesc1->guidSession = pDesc->guidApplication;
	pDesc1->dwMaxPlayers = pDesc->dwMaxPlayers;
	pDesc1->dwCurrentPlayers = pDesc->dwCurrentPlayers;
	pDesc1->dwFlags = pDesc->dwFlags;
	pDesc1->dwReserved1 = pDesc->dwReserved1;
	pDesc1->dwReserved2 = pDesc->dwReserved2;
	pDesc1->dwUser1 = pDesc->dwUser1;
	pDesc1->dwUser2 = pDesc->dwUser2;
	pDesc1->dwUser3 = pDesc->dwUser3;
	pDesc1->dwUser4 = pDesc->dwUser4;
	
	if (pDesc->lpszSessionName)
	{
		WideToAnsi(pDesc1->szSessionName,pDesc->lpszSessionName,DPSESSIONNAMELEN);
	}
	if (pDesc->lpszPassword)
	{
		WideToAnsi(pDesc1->szPassword,pDesc->lpszPassword,DPPASSWORDLEN);		
	}

	// use the pointer to the guid as the dwSession
	pDesc1->dwSession = (DWORD_PTR) &(pDesc->guidInstance);

} // Get10Desc

// same code as CheckSessionDesc, but for old desc.
// we need different code path here, since fields in  LPDPSESSIONDESC
// and LPDPSESSIONDESC2 don't line up
HRESULT CheckSessionDesc1(LPDPSESSIONDESC lpsdUser,LPDPSESSIONDESC lpsdSession,
	DWORD dwFlags)
{
	int iStrLen;


	// if we don't care about guids, passwords, open slots and enable new players, we're done
	if (dwFlags & DPENUMSESSIONS_ALL) return DP_OK;

	// 1st, check the guids
	if (!IsEqualGUID(&(lpsdUser->guidSession),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(lpsdUser->guidSession),&(lpsdSession->guidSession))) 
		{
			return E_FAIL;
		}
	}

	// if we don't care about passwords, open slots and enable new players, we're done
	if (!(dwFlags & DPENUMSESSIONS_AVAILABLE)) return DP_OK;
	
	// next, check current users
	if (lpsdSession->dwMaxPlayers) 
	{
		if (lpsdSession->dwCurrentPlayers >= lpsdSession->dwMaxPlayers)  
		{
			return E_FAIL;
		}
	}
	
	// check the password
	iStrLen = STRLEN(lpsdSession->szPassword);
	if (iStrLen)
	{
		int iCmp;

		iCmp = strcmp(lpsdSession->szPassword,lpsdUser->szPassword);
		if (0 != iCmp) return E_FAIL;
	}

	// finally, check players enabled
	if (lpsdSession->dwFlags & DPSESSION_NEWPLAYERSDISABLED) return E_FAIL;
	if (lpsdSession->dwFlags & DPSESSION_JOINDISABLED) return E_FAIL;
	
	return DP_OK;
} // CheckSessionDesc1

void Desc2FromDesc1(LPDPSESSIONDESC2 lpsdDesc2,LPDPSESSIONDESC lpsdDesc1)
{
	memset(lpsdDesc2,0,sizeof(DPSESSIONDESC2));
	lpsdDesc2->dwSize = sizeof(DPSESSIONDESC2);
	lpsdDesc2->dwFlags = lpsdDesc1->dwFlags;
	lpsdDesc2->guidApplication = lpsdDesc1->guidSession;// in sessiondesc1, session = game
	lpsdDesc2->dwMaxPlayers = lpsdDesc1->dwMaxPlayers;
	lpsdDesc2->dwUser1 = lpsdDesc1->dwUser1;
	lpsdDesc2->dwUser2 = lpsdDesc1->dwUser2;
	lpsdDesc2->dwUser3 = lpsdDesc1->dwUser3;
	lpsdDesc2->dwUser4 = lpsdDesc1->dwUser4;

	lpsdDesc2->lpszSessionNameA = lpsdDesc1->szSessionName;
	lpsdDesc2->lpszPasswordA = lpsdDesc1->szPassword;

	return ;
} // Desc2FromDesc1

HRESULT DPAPI DP_1_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpsdDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags) 
{
	HRESULT hr;
	BOOL bContinue = TRUE;
	LPSESSIONLIST pSessionList;
	DPSESSIONDESC2 desc2,descW;
	DPSESSIONDESC desc1;
	GUID guidInstance;
	LPDPLAYI_DPLAY this;
	
	ENTER_ALL();

    TRY
    {		
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
			 
		if (!VALID_READ_DPSESSIONDESC(lpsdDesc))
		{
			LEAVE_ALL();
			DPF_ERR("Bad session desc");	
	        return DPERR_INVALIDPARAMS;
		}
		if (lpsdDesc->dwSession) guidInstance = *((LPGUID)lpsdDesc->dwSession);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	Desc2FromDesc1(&desc2,lpsdDesc);
	desc2.guidInstance = guidInstance;

	hr = GetWideDesc(&descW,&desc2);
	if (FAILED(hr))
	{
		LEAVE_ALL();
		return hr;
	}

	while (bContinue)
	{
		//  do the enum. 
		hr = InternalEnumSessions(lpDP,&descW,dwTimeout,(LPVOID)lpEnumCallback,dwFlags);
		if (FAILED(hr)) 
		{
			FreeDesc( &descW,FALSE);
			LEAVE_ALL();
			DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			return hr;
		}

		// callback w/ results	
		pSessionList = this->pSessionList;
	    while (pSessionList && bContinue)
	    {
			Get10Desc(&desc1,&(pSessionList->dpDesc));

			// make sure this session matches what the user asked for...
			hr = CheckSessionDesc1(lpsdDesc,&desc1,dwFlags);
			if (SUCCEEDED(hr)) 
			{
		        bContinue = lpEnumCallback( &desc1,pvContext,&dwTimeout,0);				
			}
			pSessionList = pSessionList->pNextSession;
	    } 
	    
		// done...
	    if (bContinue) bContinue = lpEnumCallback(NULL,pvContext,&dwTimeout,DPESC_TIMEDOUT);

	} // while bContinue

	FreeDesc( &descW,FALSE);
	
	LEAVE_ALL();

    return DP_OK;

} // DP_1_EnumSessions

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetCaps"

HRESULT Internal_1_GetCaps(LPDIRECTPLAY lpDP,LPDPCAPS lpDPCaps,DPID idPlayer,BOOL fPlayer) 
{
	DPCAPS dpcaps; // pass this to iplay2 when we get passed an old caps
	BOOL bOldCaps;
	HRESULT hr;
	DWORD dwFlags;

	TRY
	{
		if (VALID_DPLAY_CAPS(lpDPCaps))	
		{
			bOldCaps = FALSE;
		}
		else 
		{
			if (VALID_DPLAY1_CAPS(lpDPCaps))	
			{
				bOldCaps = TRUE;
				
				// take lock so we don't hose crt
				ENTER_DPLAY();
				memset(&dpcaps,0,sizeof(DPCAPS));
				memcpy(&dpcaps,lpDPCaps,lpDPCaps->dwSize);
				dpcaps.dwSize = sizeof(DPCAPS);
				LEAVE_DPLAY();
				
			}
			else 
			{
		        DPF_ERR( "BAD CAPS POINTER" );
		        return DPERR_INVALIDPARAMS;
			}
		}
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
	}

	dwFlags = lpDPCaps->dwFlags;
	dpcaps.dwFlags = 0;

	if (bOldCaps)
	{
		if (fPlayer) 
		{
			hr = DP_GetPlayerCaps(lpDP,idPlayer,&dpcaps,dwFlags);
		}
		else 
		{
			hr = DP_GetCaps(lpDP,&dpcaps,dwFlags);
		}
		if (FAILED(hr)) return hr;

		// take lock so we don't hose crt
		ENTER_DPLAY();
		memcpy(lpDPCaps,&dpcaps,lpDPCaps->dwSize);
		LEAVE_DPLAY();
		
		return hr;
	}
	else 
	{
		if (fPlayer) 
		{
			hr = DP_GetPlayerCaps(lpDP,idPlayer,lpDPCaps,dwFlags);
		}
		else 
		{
			hr = DP_GetCaps(lpDP,lpDPCaps,dwFlags);
		}
	}
	
	return hr;
} // Internal_1_GetCaps

HRESULT DPAPI DP_1_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps) 
{

	return Internal_1_GetCaps(lpDP,lpDPCaps,0,FALSE);

} // DP_1_GetCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetPlayerCaps"

HRESULT DPAPI DP_1_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps) 
{
	
	return Internal_1_GetCaps(lpDP,lpDPCaps,idPlayer,TRUE);

} // DP_1_GetPlayerCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetPlayerName"

// called by getplayer name. copies lpszSrc (as much as will fit) to lpszDest
// set pdwDestLength to the size of lpszDest 
// returns DPERR_BUFFERTOOSMALL or DP_OK
HRESULT CopyName(LPSTR lpszDest,LPWSTR lpszSrc,DWORD * pdwDestLength) 
{
    UINT iStrLen; // str length, in bytes of what we're copying

	// ask wide to ansi how long
	iStrLen = WSTR_ANSILENGTH(lpszSrc);

	if (iStrLen > *pdwDestLength)
	{
		*pdwDestLength = iStrLen;
		return DPERR_BUFFERTOOSMALL;
	}

	*pdwDestLength = iStrLen;
	if (lpszSrc) 
	{
		WideToAnsi(lpszDest,lpszSrc,iStrLen);
	}
	
    return DP_OK;

} // CopyName

HRESULT DPAPI DP_1_GetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPDWORD pdwShortNameLength,LPSTR lpszLongName,LPDWORD pdwLongNameLength) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		lpPlayer = PlayerFromID(this,idPlayer);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,idPlayer);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERR("SP - passed bad player / group id");
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }

        // check the strings - (this is redundant, since the SEH will catch the bd pdw below,
		// but nothing wrong w/ belt + suspenders)
		if ( (!VALID_DWORD_PTR(pdwShortNameLength)) || (!VALID_DWORD_PTR(pdwLongNameLength)) )
		{
            LEAVE_DPLAY();
			DPF_ERR("bad length pointer");
            return DPERR_INVALIDPARAMS;
		}

		// if the string is null, they just get the length
		if (!lpszShortName)*pdwShortNameLength = 0;
		if (!lpszLongName) *pdwLongNameLength = 0;

        if ((*pdwShortNameLength) && (!VALID_STRING_PTR(lpszShortName,*pdwShortNameLength)) ) 
        {
            LEAVE_DPLAY();
            return DPERR_INVALIDPARAMS;
        }
        if ((*pdwLongNameLength) && (!VALID_STRING_PTR(lpszLongName,*pdwLongNameLength)) ) 
        {
            LEAVE_DPLAY();
            return DPERR_INVALIDPARAMS;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }
    
    hr = CopyName(lpszShortName,lpPlayer->lpszShortName,pdwShortNameLength);

    hr |= CopyName(lpszLongName,lpPlayer->lpszLongName,pdwLongNameLength);

    LEAVE_DPLAY();
    return hr;

}//DP_1_GetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_Open"

HRESULT DPAPI DP_1_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpsdDesc ) 
{
	DPSESSIONDESC2 desc2;
	GUID guidInstance;
	DWORD dwFlags;

	ENTER_DPLAY();

    TRY
    {
		if (!VALID_READ_DPSESSIONDESC(lpsdDesc))
		{
        	LEAVE_DPLAY();
			DPF_ERR("Bad session desc");	
	        return DPERR_INVALIDPARAMS;
		}
		if (lpsdDesc->dwFlags & DPOPEN_JOIN)
		{
            if (!VALID_READ_GUID_PTR((LPGUID)lpsdDesc->dwSession))
            {
        	    LEAVE_DPLAY();
			    DPF_ERR("Bad session id");	
	            return DPERR_INVALIDPARAMS;
            }
			// get the guid
			guidInstance = *((LPGUID)lpsdDesc->dwSession);
			dwFlags = DPOPEN_JOIN;
		}
		else 
		{
			dwFlags = DPOPEN_CREATE;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }			        

	Desc2FromDesc1(&desc2,lpsdDesc);
	desc2.guidInstance = guidInstance;

	LEAVE_DPLAY();

	return DP_A_Open(lpDP, &desc2,dwFlags ) ;
		
} // DP_1_Open

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_Receive"

// pvBuffer points to an DPMSG_CREATEPLAYERORGROUP mess
// convert it to an DPMSG_ADDPLAYER mess
HRESULT BuildAddPlayer1(LPVOID pvBuffer,LPDWORD pdwSize)
{
	DPMSG_ADDPLAYER msg;
	LPDPMSG_CREATEPLAYERORGROUP pmsg2 = (LPDPMSG_CREATEPLAYERORGROUP) pvBuffer;

	memset(&msg,0,sizeof(DPMSG_ADDPLAYER));
	
	msg.dwType = DPSYS_ADDPLAYER;
	msg.dwPlayerType = pmsg2->dwPlayerType;
	msg.dpId = pmsg2->dpId;
	msg.dwCurrentPlayers = pmsg2->dwCurrentPlayers;
	
	if (pmsg2->dpnName.lpszShortName)
	{
		WideToAnsi(msg.szShortName,pmsg2->dpnName.lpszShortName,DPSHORTNAMELEN);				
	}

	if (pmsg2->dpnName.lpszLongName)
	{
		WideToAnsi(msg.szLongName,pmsg2->dpnName.lpszLongName,DPLONGNAMELEN);		
	}
	
	*pdwSize = sizeof(msg);
	memcpy(pvBuffer,&msg,*pdwSize);
	return DP_OK;

} // BuildAddPlayer1

// pvBuffer points to an DPMSG_DESTROYPLAYERORGROUP mess
// convert it to a DPMSG_DELETEPLAYER
HRESULT BuildDeletePlayerOrDeleteGroup1(LPVOID pvBuffer,LPDWORD pdwSize)
{
	DPMSG_DELETEPLAYER msg;
	LPDPMSG_DESTROYPLAYERORGROUP pmsg2 = (LPDPMSG_DESTROYPLAYERORGROUP) pvBuffer;

	if (pmsg2->dwPlayerType == DPPLAYERTYPE_PLAYER)
	{
		msg.dwType = DPSYS_DELETEPLAYER;
		msg.dpId = pmsg2->dpId;
	}
	else
	{
		msg.dwType = DPSYS_DELETEGROUP;
		msg.dpId = pmsg2->dpId;
	}

	*pdwSize = sizeof(msg);
	memcpy(pvBuffer,&msg,*pdwSize);
	return DP_OK;

} // BuildDeletePlayerOrDeleteGroup1


HRESULT DPAPI DP_1_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize)
{
	HRESULT hr;
	DWORD dwOrigSize=0; 

	ENTER_DPLAY();
	
    TRY
    {						 
		if (pdwSize) dwOrigSize = *pdwSize;    
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating pdwSize" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }			        

	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_1);

	if (FAILED(hr)) 
	{
		LEAVE_DPLAY();
		return hr;
	}

	// see if its a addplayer mess
	if (0 == *pidFrom )
	{
		switch (((DPMSG_GENERIC *)pvBuffer)->dwType)
		{
		case DPSYS_CREATEPLAYERORGROUP:
			if (sizeof(DPMSG_ADDPLAYER) > dwOrigSize ) 
			{
				ASSERT(FALSE); // should never happen!
			}
			else 
			{
				// convert the iplay 20 add player to a 10 add player
				BuildAddPlayer1(pvBuffer,pdwSize);
			}
			break;

		case DPSYS_DESTROYPLAYERORGROUP:
			if (sizeof(DPMSG_DELETEPLAYER) > dwOrigSize ) 
			{
				*pdwSize = 	sizeof(DPMSG_DELETEPLAYER);
				hr = DPERR_BUFFERTOOSMALL;
			}
			else 
			{
				// convert the iplay 2.0 delete player/group to a 1.0 delete player or delete group
				BuildDeletePlayerOrDeleteGroup1(pvBuffer,pdwSize);
			}
			break;
		}
		
	} // 0 == pidFrom
	
	LEAVE_DPLAY();
	
	return hr;

} // DP_1_Receive

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_SaveSession"

HRESULT DPAPI DP_1_SaveSession(LPDIRECTPLAY lpDP, LPSTR lpszNotInSpec) 
{
	return E_NOTIMPL;
} // DP_1_SaveSession

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_SetPlayerName"

/*
 ** AnsiSetString
 *
 *  CALLED BY: DP_SetPlayerName
 *
 *  PARAMETERS: ppszDest - string to set, lpszSrc - string to copy
 *
 *  DESCRIPTION: frees *ppszDest. alloc's a new ppszDest to hold lpszSrc
 *
 *  RETURNS: DP_OK or E_OUTOFMEMORY
 *
 */
HRESULT AnsiSetString(LPWSTR * ppszDest,LPSTR lpszSrc)
{
    if (!ppszDest) return E_UNEXPECTED;
    if (*ppszDest) DPMEM_FREE(*ppszDest);
	
	GetWideStringFromAnsi(ppszDest,lpszSrc);

	return DP_OK;

} // AnsiSetString

HRESULT DPAPI DP_1_SetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPSTR lpszLongName) 
{
	DPNAME Name;

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);

	// call the ansi entry w/ the new struct
	return 	DP_A_SetPlayerName(lpDP, idPlayer,&Name,0);

}//DP_1_SetPlayerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\iplay.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       iplay.c
*  Content:	IDirectPlay implementation
*  History:
*   Date		By		Reason
*   ====		==		======
* 	1/96		andyco	created it
*  	1/30/96		andyco	1st pass at list mgmt
*  	2/1/96		andyco	added namesrv support
*	2/15/96		andyco	added player messages
*	3/31/96		andyco	bugfest! !leaks	
*	4/10/96		andyco	made sp callbacks optional.  validated spdata after
*						create player
*	5/9/96		andyco	idirectplay2 
*	5/21/96		andyco	getcaps, getplayer/groupdata, getsessiondesc
*	5/31/96		andyco	playername, etc.
*	6/10/96		andyco	getxxxname,getsessiondesc copy data, don't give out ptrs.
*	6/19/96		kipo	Bug #1804. Return *pdwSize correctly in DP_Receive if
*						application buffer is too small.
*						Bug #1957. Calls to InternalSetName() had the player boolean
*						and flags parameters switched.
*						Bug #1959. In DP_DestroyGroup() the loop to remove all players
*						in the group was not doing lpGroupnode = lpGroupnode->pNextGroupnode,
*						causing it to reference through a deleted node and crash.
*						Bug #2017. InternalSetData() and SetPlayerData() had similar problems.
*						Memory leaks and crashes were occuring when MemReAlloc() returned
*						a NULL. Also, InternalSetData() was not checking to see if the data
*						length was zero before doing all this work, and was not returning
*						the HRESULT returned by SendDataChanged().
*						Derek Bug. DP_GetGroupName() and DP_GetPlayerName() had the boolean for
*						players and groups were swapped.
*						Derek Bug. InternalGetData() was not checking the application buffer size
*						correctly before copying the buffer.
*	6/20/96		andyco	added WSTRLEN_BYTES
*	6/21/96		kipo	Bug #2083. InternalGetSessionDesc() was using sizeof(DPNAME) instead
*						of sizeof(DPSESSIONDESC2); free existing names if you pass in a null
*						DPNAME structure.
*	6/23/96		kipo	updated for latest service provider interfaces.

*	6/25/96		kipo	added support for DPADDRESS.
*	6/30/96		andyco	added remote + local data, moved setdata to do.c. made 
*						getplayer,internalsetxxx share code.
*	7/1/96		andyco	changed check for !LOCAL instead of REMOTE, since
*						* & 0 will never be !0  (!)
*  7/8/96       ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
*                       to 'dpnName' to match DPLAY.H
*                       Change DPCAPS_NAMESERVER to DPCAPS_ISHOST
*                       Deleted function DP_SaveSession
*	7/10/96		andyco	added pending on nametable download
*	7/10/96		kipo	renamed system messages
*   7/11/96     ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
*	7/11/96		andyco	1. dp_destroyplayer was calling dp_deleteplayerfromgroup
*						passing dplayi_dplay instead of dplayi_int.  doh.  	#2330.
*						2. internalopensession was getting session name from
*						user strings, not from nameservers session desc.  caused
*						the name server to appear not to migrate.  #2216.
*						3.  Getplayeraddress changed to look for null callback
*						and return e_notimpl.  #2327. 
*   7/20/96     kipo	InternalGetSessionDesc() was calling STRLEN on a UNICODE
*						string and thus returning the wrong session name length. #2524
*	7/27/96		kipo	Bug #2691. Need to increment/decrement lpGroup->nPlayers when
*						you add/delete players from a group so the name table packing
*						includes the players in groups.	 Player event is a handle now.
*	8/1/96		andyco	changed dp_destroyplayer to internaldestroy.  added 
*						keepalivethreadproc.
*	8/6/96		andyco	added id mangling
*	8/8/96		andyco	added internalxxx for all player mgmt fn's to handle 
*						correctly propagating messages.
*	8/9/96		andyco	check max player on player creation
*	8/10/96		andyco	guaranteed flags.  no more terminatethread for 
*						keepalive thread
*  8/12/96		andyco	added internalreceive so we can get addplayer 10 size correct.
*  8/16/96		andyco 	store nameserver for new id requests
*  8/23/96		kipo	call OS_IsValidHandle() on even passed to CreatePlayer
*  8/28/96		andyco	don't freenametable if getnametable fails - we need 
*						it to get rid of sysplayer (bug 3537)
*  8/30/96		andyco	fix up pointers on destroyplayerorgroup(3655)
*  9/3/96		andyco	drop lock on close,destroyplayer sp callback
*  9/4/96		andyco	DON'T drop lock on destroyplayer!
*  10/2/96      sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
*                       where appropriate.
*  10/2/96      sohailm added code to validate user's DPNAME ptrs before accessing them
*  10/9/96		andyco	got rid of race condition in handlereply by adding
*						gbWaitingForReply. raid #3848.
*  10/10/96		andyco	set this->lpsdDesc to NULL if SP OpenSession call fails,
*						so we can call open again.  raid # 3784.
*  10/11/96     sohailm implemented DP_SetSessionDesc() and InternalSetSessionDesc()
*                       added code to fix up DPSYS_SETSESSIONDESC message pointers
*  10/12/96		andyco	added DPLAYI_GROUP_DPLAYOWNS.  SysGroup. 
*  11/11/96		andyco	support for DPLAYI_PLAYER_APPSERVER, free updatelists w/ 
*						player / groups.  always create sysgroup- no just if 
*						sp optimizes it.
* 11/20/96		andyco	added control panel (perf) thread startup / shutdown.
*						this thread updates the directx control panel w/ dplay
*						stats. see perf.c
*	12/5/96		andyco	if CreateSystemPlayer fails, bail before we try + create 
*						system group (and die)! Bug 4840.
*  01/09/96     sohailm do not return an error if dwMaxPlayers is set to zero (#5171)
*                       return the right error code if dwMaxPlayers is being set to
*                        less than dwCurrentPlayers (#5175)
*  01/16/97     sohailm client now checks if session is allowing players before 
*                       opening it (#4574)
*	1/15/96		andyco	handle groups correctly - added system player groupnode
*						support. 
*	1/24/97		andyco	detect dx3 nameservers. check pidTo + pidFrom in receive.
*						don't allow send of a NULL buffer. Raid 5294,5402, 5403, 5427.
* 	1/28/97		andyco	fixed setdata / setname to pass fPropagate so we can do permission
*						checking
*	2/1/97		andyco	dplay drops lock on send.  take service lock on dp_ entry points.
*	2/11/97		kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
*	2/15/97		andyco	remember the nameserver, even if it's local
*	2/18/97		kipo	fix bugs #4933 and #4934 by checking for invalid flags
*						in InternalCreatePlayer
*   2/26/97     sohailm don't let dwMaxPlayers to be set to more than sp can handle (5447)
*   2/26/97     sohailm initialize the reserved fields in the session desc 
*                       when session is created(4499).
*	3/5/97		andyco	changed keepalive thread to dplay thread
*	3/10/97		andyco	reset only session flags on close
*	3/12/97		myronth	added lobby support for Open & Close
*	3/13/97		myronth	flagged unsupported lobby methods as such
*   3/13/97     sohailm added functions SecureOpen(), CopyCredentials(), ValidateOpenParams(),
*                       modified InternalOpenSession to handle security, and DP_Open to 
*                       to use ValidateOpenParams().
*	3/17/97		myronth	Added lobby support for Create/DestroyGroup/Player
*	3/20/97		myronth	Added lobby support for AddPlayerToGroup and
*						DeletePlayerFromGroup, changed to use IS_LOBBYOWNED macro
*	3/21/97		myronth	Added lobby support for SetGroup/PlayerName, 
*						Get/SetGroup/PlayerData
*   3/18/97     sohailm Added support to cleanup context ptrs from the nametable during Close()
*                       Updated GetNameTable() to not send a nametable request if nameserver is 
*                       DX5 or greater (optimization - nameserver responds to addforward).
*                       Open and SetSessionDesc set the DPSESSION_PASSWORDREQUIRED flag if session
*                       requires a password.
*	3/25/97		kipo	treat zero-length password strings just like NULL password
*						strings for DX3 compatability; check for valid session flags
*						in Open and SetSessionDesc.
*   3/28/97     sohailm don't allow toggling DPSESSION_SECURESERVER in SetSessionDesc.
*   3/30/97     sohailm when open fails, drop the dplay lock before calling close so we don't 
*                       assert in close.
*   3/31/97     sohailm changed dpf to print out session desc flags in hex (open)
*	3/31/97		myronth	Added use of the propagate flag for all player management
*						messages which can come from the lobby.  If the flag is
*						cleared, it means the lobby called it for a remote player.
*   4/02/97     sohailm now we reset the login state when session is closed (7192)
*	4/10/97		myronth	Added support for GetCaps/GetPlayerCaps, fixed GetPlayerAddress
*	4/20/97		andyco	group in group
*   4/23/97     sohailm Added support for reporting signing and encryption caps.
*                       Added support for player message signing and encryption.
*	5/8/97		andyco	removed update list
*	5/8/97		myronth	Turned on system players for lobby-owned objects, made
*						subgroup methods work with the lobby
*	5/11/97		kipo	Fixed bugs #5408, 5406, 7435, 5249, 5250
*	5/13/97		myronth	Pass credentials to lobby's Open call, SecureOpen
*  05/17/97     sohailm Updated InternalOpenSession, Close, and SecureOpen to support CAPI encryption
*                       Removed check for dwMaxPlayers > allowed by SP (5448).
*                       Enabled encryption support.
*                       Now we check the flags in security desc and credentials (8387)
*                       Added DP_GetAccountDesc(), InternalGetAccountDesc().
*	5/17/97		myronth	SendChatMessage and it's pointer fixups
*	5/17/97		kipo	There was a bug in GetNameTable() where it was setting
*						the ghReplyProcessed event twice on the way out,
*						which would let handler.c in, trashing the buffer
*						that GetNameTable() was using.
*	5/17/97		myronth	Can't AddGroupToGroup on the same group
*	5/18/97		kipo	Don't allow group operations on the system group
*	5/18/97		kipo	Set DPLAYI_GROUP_STAGINGAREA flag in InternalCreatePlayer
*   5/18/97     sohailm Now we check if client is logged in before we allow send on 
*                       a secure player to player message.
*	5/20/97		myronth	Changed when lobby is called in AddPlayerToGroup,
*						DeletePlayerFromGroup, and DestroyGroup. (Bug #8586)
*						Removed the STAGINGAREA error case for CreateGroup (Bug #8743)
*   5/21/97     kipo	Bug #8744: DPSESSION_MULTICASTSERVER can't be changed
*						by SetSessionDesc().
*	5/21/97		myronth	Moved AddPlayerToGroup call in the lobby to eliminate
*						a race condition
*   5/22/97     kipo	Bug #8330: because the session list is not global in DX
*						we had a regression with X-Wing vs. Tie Fighter, fixed
*						by re-aquiring the session; added DPSP_MSG_AUTONAMETABLE
*						check in GetNameTable
*	5/22/97		myronth	Changed when lobby is called in DeletePlayerFromGroup
*						and DestroyGroup.  Now drop locks in several other
*						functions when we call the lobby.
*	5/23/97		andyco	unpack session desc w/ nametable. don't allow send
*						to non-local player unless i'm the multicastserver
*	5/23/97		kipo	Added support for return status codes
*	5/23/97		myronth	Fixed DeleteGroupFromGroup bug #8396, changed name of
*						RemoveGroupFromGroups to RemoveGroupFromAllGroups
*   5/24/97     sohailm We weren't setting the security description parameters correctly
*                       when user passed in a NULL CAPI provider name.
*	5/27/97		myronth	Re-fixed #8396 at a higher level
*	5/30/97		myronth	Added DP_GetGroupParent
*   5/30/97     sohailm update CopyCredentials() and DP_SecureOpen() to handle domain name.
*                       Added DP_GetPlayerAccount() and InternalGetPlayerAccount()
*	5/30/97		kipo	Added GetPlayerFlags() and GetGroupFlags()
*	6/2/97		andyco	raid 9199 + 9063.  multicast server + client server error checking.
*	6/4/97		myronth	Bug #9146 -- SendChatMessage with remote From player should fail
*	6/4/97		myronth	Bug #9507 -- Failed lobby Open was leaving the dplay object initialized
*	6/4/97		kip		Bug #9311 don't param check DPNAME structure (regression with DX3)
*	6/6/97		myronth	Moved call to lobby in InternalDeletePlayerFromGroup
*   6/09/97     sohailm More parameter validation in DP_SecureOpen()
*	6/11/97		myronth	Drop dplay lock before calling lobby GetCaps/GetPlayerCaps (#9756)
*   6/16/97     sohailm no security on sps that don't support reliable messages (#9872).
*   6/22/97     sohailm Secure messages are now routed using the multi-casting code.
*                       Added check to not allow raw player messages in a secure session.
*   6/23/97     sohailm Cleanup public keys when session is closed.
*   6/24/97     sohailm We were releasing the crypt context before releasing keys (#10272).
*   6/25/97     kipo	Only allow secure server when client server is also set
*   7/28/97		sohailm Enable multicast with security by default.
*						Removed check for client-server when secure session is requested.
*						Raw player messages are not allowed in a secure session.
*   8/4/97		andyco	reset this->dwMinVersion on close
*	8/19/97		myronth	Added <mmsystem.h> dependency to make the NT build happy
*	8/29/97		sohailm	return hresult in RemoveGroupFromGroupList (bug 10927) + 
*						don't drop lock in RemoveGroupFromGroupList (bug 10933).
*	9/29/97		myronth	SetPlayer/GroupData/Name calls to lobby now wait for
*						response from server before changing local info (#12554)
*						SendChatMessage sends to remote players for DPID_ALLPLAYERS (#12524)
*	10/21/97	myronth	Added hidden flag to CreateGroup, Added stubbed out
*						group owner methods
*	10/29/97	myronth	Added support for group owners (affects Create/DestroyGroup,
*						CreateGroupInGroup, DestroyPlayer)
*	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
*   11/17/19    aarono  Added SendEx/GetMessageQueue/CancelSend
*	11/19/97	myronth	Allow host to destroy remote players (#12901) and
*						fixed bug in InternalGetCaps (#12634)
*	11/24/97	myronth	Fixed CreateGroupInGroup w/ ParentID = 0 (#15245)
*						and EnumJoinSession w/ max players (#15229)
*	12/5/97		andyco	voice stuff
*	12/29/97	myronth	TRUE != DPSEND_GUARANTEED (#15887), Also fixed
*						CreateGroupInGroup for invalid parent (#15245), and
*						Removed invalid DeleteGroupFromGroup msg for real
*						child groups (#15264)
*	12/29/97	sohailm	Clients can't join secure session if hosted with DPOPEN_RETURNSTATUS (#15239)
*						Send SetSessionDesc system message reliably (#15461)
*	01/14/98	sohailm	Clear DPCAPS_GROUPOPTIMIZED flag when CLIENT_SERVER, DX3_INGAME,
*						or SECURE_SERVER (#15210)
*	1/20/98		myronth	#ifdef'd out voice support
*	1/26/98		sohailm	added session flags to SP_OPEN data structure
*	1/26/98		sohailm added an upper bound to join timeout.
*   2/2/98      aarono  moved FreePacketList and re-ordered locking to avoid 
*                       deadlock on close.
*   2/2/98      aarono  fixed error checking on priority in DP_SendEx
*   2/3/98      aarono  changed when we get remote version to DP_Open
*   2/3/98      aarono  changed open to get frame size again in case changed because protocol running.
*   2/13/98     aarono  async support
*   2/18/98     aarono  moved ProtocolInit into Open
*                       call protocol direct rather than through table.
*   2/19/98     aarono  call FiniProtocol in DP_Close
*   3/5/98	    aarono	B#18776 don't allow changing DPSESSION_DIRECTPROTOCOL in SetSessionDesc
*   3/5/98	    aarono	B#19916 don't allow GetMessageQueue on idFrom a group.
*   3/10/98     aarono  adding ref on dplay object insufficient, added ENTER_DPLAY()
*                       to DP_Cancel and DP_GetMessageQueue.
*   3/12/98     aarono  fixed DP_Close to shutdown threads better
*   3/13/98     aarono  fixed packetize shutdown for packetizeandsendreliable change
*   3/13/98     aarono  fixed protocol initialization path by getting caps everytime
*   3/13/98     aarono  changed DP_SendEx to validate send parms earlier.
*   3/19/98     aarono  don't let app change DPSESSION_OPTIMIZELATENCY flag.
*   3/30/98     aarono  fix locking in MessageQueue and Cancel methods.
*   3/31/98    a-peterz #21331: Check flags before using them.
*   4/15/98     aarono  B#22909 validate idTo on GetMessageQueue
*   4/23/98     aarono  fix memory leak in GetNameTable
*   6/2/98      aarono  don't wait for pending sends
*                       pass DPSEND_NOCOPY to protocol if present
*                       fix psp accounting on error in SendEx
*                       Make GetMessageQueue ask for System Queue
*   6/6/98      aarono  Don't drop DPLAY() lock across ProtocolDeletePlayer
*                       since code around it can't handle it.
*   6/8/98      aarono+peterz B#25311 BellHop can't shutdown, because of
*                       re-enter to close, made this OK.
*  6/10/98 aarono add PendingList to PLAYER and SENDPARM, complete pending
*                     sends on close before blowing away PLAYER
*  6/19/98      aarono add last ptr for message queues, makes insert
*                      constant time instead of O(n) where n is number
*                      of messages in queue.
*  6/22/98      aarono NULL sysplayer when blowing it away.
*  1/27/99      aarono don't call SP when create player not there.
*  7/9/99       aarono MANBUG#25328 not protecting release of protocol
*                      properly can cause exception when racing close.
*
***************************************************************************/

// issues:
// 	some stuff in try/except blocks is not really dangerous...
  
// todo - get latency w/ player caps
// todo - who has right to set session desc?

#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"

// todo - This #define can be removed once we fix the DPF stuff on NT.
// currently, this is not getting defined by the makefile like it is
// on Win95, so we need to define it here. -- myronth
#ifndef PROF_SECT
#define PROF_SECT	"DirectPlay"
#endif // PROF_SECT


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_AddGroupToGroup"
HRESULT InternalAddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup,DWORD dwFlags,
	BOOL fPropagate) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_GROUP lpGroupTo; 
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_SUBGROUP lpSubgroup;
	
	DPF(5,"adding group id %d to group id %d fPropagate = %d\n",idGroup,idGroupTo,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    
        lpGroupTo = GroupFromID(this,idGroupTo);
        if ((!VALID_DPLAY_GROUP(lpGroupTo)) || (DPID_ALLPLAYERS == idGroupTo)) 
        {
			DPF_ERRVAL("invalid parent group id = %d", idGroupTo);
            return DPERR_INVALIDGROUP;
        }

        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// make sure they aren't trying to add a group to itself
	if(lpGroupTo == lpGroup)
	{
		DPF_ERR("Cannot add a group to itself");
		return DPERR_INVALIDGROUP;
	}

	// make sure group isn't already in group
	lpSubgroup = lpGroupTo->pSubgroups;
    while (lpSubgroup) 
    {
        if (lpSubgroup->pGroup == lpGroup) 
        {
			DPF(0,"group already in group!");
			return DP_OK;
        }
		// check next node
        lpSubgroup = lpSubgroup->pNextSubgroup;
    }

    // need a new DPLAYI_SUBGROUP
    lpSubgroup = DPMEM_ALLOC(sizeof(DPLAYI_SUBGROUP));
    if (!lpSubgroup) 
    {
        DPF_ERR("out of memory getting groupnode");
        return E_OUTOFMEMORY;
    }

	if (fPropagate)
	{
		if (dwFlags & DPGROUP_SHORTCUT)
		{
			hr = SendPlayerManagementMessage(this, DPSP_MSG_ADDSHORTCUTTOGROUP, idGroup, 
				idGroupTo);
			
		}
				
		if (FAILED(hr))	
		{
			ASSERT(FALSE); // sendsysmessage should not fail!
			// if this failed, we could have hosed global name table
			// keep going...
			hr = DP_OK;
		}
	}

	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared. If it is cleared, the lobby is calling us for a
	// remote group and we don't want to call it back in that case.
	// Also, if the DPGROUP_SHORTCUT flag is not set, then this is
	// being called from CreateGroupInGroup, so don't call the lobby
	// in that case.  The lobby will be called from DP_CreateGroupInGroup
	if((IS_LOBBY_OWNED(this)) && (fPropagate) && (dwFlags & DPGROUP_SHORTCUT))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		// REVIEW!!!! -- Should we make sure the service lock is taken???
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_AddGroupToGroup(this->lpLobbyObject, idGroupTo, idGroup);

		// Take the lock back
		ENTER_DPLAY();

		// If the lobby failed, free our memory and exit without adding the group
		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to add group to group, hr = 0x%08x", hr);
			DPMEM_FREE(lpSubgroup);
			return hr;
		}
	}

	// set up the players groupnode
    lpSubgroup->pGroup = lpGroup;
	lpSubgroup->dwFlags = dwFlags;
	
	// stick it on the front
	lpSubgroup->pNextSubgroup = lpGroupTo->pSubgroups;
	lpGroupTo->pSubgroups = lpSubgroup;
	// update groupto
	lpGroupTo->nSubgroups++;

    // updates groups group info
    lpGroup->nGroups++;
    lpGroup->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;
	
    return DP_OK;
	
}  // InternalAddGroupToGroup  

HRESULT DPAPI DP_AddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup) 
{
	HRESULT hr;
	
	ENTER_ALL();	
	
	hr = InternalAddGroupToGroup(lpDP,idGroupTo,idGroup,DPGROUP_SHORTCUT,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_AddGroupToGroup

  
#undef DPF_MODNAME
#define DPF_MODNAME	"DP_AddPlayerToGroup"

// we asked the SP to add a player to this group
// the SP failed, so we make the group dplay owned
// this means we have to call the sp to remove all players and destroy the group (just call
// the SP, we don't actually destroy the group)
HRESULT MakeGroupDPlayOwned(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup)
{
	HRESULT hr=DP_OK;
    LPDPLAYI_GROUPNODE lpGroupnode;
	DPSP_REMOVEPLAYERFROMGROUPDATA removedata;
	DPSP_DELETEGROUPDATA deletedata;
	
    ASSERT(!(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS));

    if (this->pcbSPCallbacks->RemovePlayerFromGroup) 
    {
		// a-josbor: ask the sp to remove all players from the group
		// only do this if we have an SP that is DX6 or later!
		if ((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
		{
		    lpGroupnode = lpGroup->pGroupnodes;
		    while ( lpGroupnode )
		    {
		        ASSERT(lpGroupnode->pPlayer);
			     // notify sp
				removedata.idPlayer = lpGroupnode->pPlayer->dwID;
				removedata.idGroup = lpGroup->dwID;        
				removedata.lpISP = this->pISP;

			    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&removedata);
			    if (FAILED(hr)) 
			    {
					DPF(0,"MakeGroupDPlayOwned :: SP - remove player from group failed - hr = 0x%08lx\n",hr);
					// keep going
			    }
			    lpGroupnode = lpGroupnode->pNextGroupnode;
			}
		}
		
		// ask the sp remove all the system players from the group 
	    lpGroupnode = lpGroup->pSysPlayerGroupnodes;
	    while ( lpGroupnode )
	    {
	        ASSERT(lpGroupnode->pPlayer);
		     // notify sp
			removedata.idPlayer = lpGroupnode->pPlayer->dwID;
			removedata.idGroup = lpGroup->dwID;        
			removedata.lpISP = this->pISP;

		    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&removedata);
		    if (FAILED(hr)) 
		    {
				DPF(0,"MakeGroupDPlayOwned :: SP - remove player from group failed - hr = 0x%08lx\n",hr);
				// keep going
		    }
		    lpGroupnode = lpGroupnode->pNextGroupnode;
		}
		
		
	}
	else 
	{
		// no callback - no biggie
	}
	
	// now, tell sp to nuke group
    if (this->pcbSPCallbacks->DeleteGroup) 
    {
	    // call sp
		deletedata.idGroup = lpGroup->dwID;
		deletedata.dwFlags = lpGroup->dwFlags;
		deletedata.lpISP = this->pISP;

    	hr = CALLSP(this->pcbSPCallbacks->DeleteGroup,&deletedata);
		if (FAILED(hr)) 
		{
			DPF(0,"MakeGroupDPlayOwned :: SP - delete group failed - hr = 0x%08lx\n",hr);
			// keep going
		}
    }
	else 
	{
		// no callback - no biggie
	}
											   
	// dplay owns it!										   
    lpGroup->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
    
    return DP_OK;
			
} // MakeGroupDPlayOwned

LPDPLAYI_GROUPNODE FindPlayerInGroupList(LPDPLAYI_GROUPNODE pGroupnode,DPID id)
{
	BOOL bFound = FALSE;
	LPDPLAYI_GROUPNODE pFoundNode = NULL;
	
	while (pGroupnode && !bFound)
	{
		if (pGroupnode->pPlayer->dwID == id)
		{
			bFound = TRUE;
			pFoundNode = pGroupnode;
		}
		else 
		{
			pGroupnode = pGroupnode->pNextGroupnode;	
		}
	} // while
	
	return pFoundNode;
	
} // FindPlayerInGroupList


// assumption: we only add sys players to sys groups
HRESULT InternalAddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer,BOOL fPropagate) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_PLAYER lpPlayer;
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_GROUPNODE lpGroupnode,lpSysGroupnode=NULL, lpGroupNodeAlloc=NULL;
	DPSP_ADDPLAYERTOGROUPDATA data;
	BOOL fSysPlayer = FALSE;
	
	DPF(5,"adding player id %d to group id %d fPropagate = %d\n",idPlayer,idGroup,fPropagate);

    //
	// Validate parameters
    // 
    
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    
        lpGroup = GroupFromID(this,idGroup);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d",idGroup);
            return DPERR_INVALIDGROUP;
        }

        lpPlayer = PlayerFromID(this,idPlayer);
        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }
        
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	//
	// Ensure that sys players are only added
	// to sysgroups
	//

	if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		ASSERT(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP); // should only add sysplayers to sysgroup!
		fSysPlayer = TRUE;
	}
	

	//
	// Ensure that we don't add a player
	// to a group of which he is already a 
	// member
	//
	if (fSysPlayer)
	{
		lpGroupnode = lpGroup->pSysPlayerGroupnodes;	// sys players go in the sysplayer group nodes
	} else {
		lpGroupnode = lpGroup->pGroupnodes;				// regular players go in the regular player list
	}	
		
    while (lpGroupnode) 
    {
        if (lpGroupnode->pPlayer == lpPlayer) 
        {
			if (fSysPlayer)  
				DPF(3,"system player already in group!");
			else 
				DPF(0,"player already in group -- idGroup = %lx, idPlayer = %lx", idGroup, idPlayer);
				
			return DP_OK;			// we found the player already in this group.  Just return quietly.
        }
		// check next node
        lpGroupnode = lpGroupnode->pNextGroupnode;
    }


	//	alloc the player's node now
	lpGroupNodeAlloc=DPMEM_ALLOC(sizeof(DPLAYI_GROUPNODE));
	if(!lpGroupNodeAlloc){
		return DPERR_NOMEMORY;
	}
	

	// if the player being added isn't a sys player and there is no DX3 in the game,
	//	we need to make sure the sys player for this player is in the game
	if (!fSysPlayer && !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
	{
		LPDPLAYI_PLAYER pSysPlayer = PlayerFromID(this,lpPlayer->dwIDSysPlayer);
		ASSERT(VALID_DPLAY_PLAYER(pSysPlayer));
		if (!VALID_DPLAY_PLAYER(pSysPlayer))
		{
			DPF(0,"could not find system player");
			ASSERT(FALSE);
			// let it go...
			hr = E_FAIL;
			goto EXIT;
		}
			
		// is this players system player in the group?
		lpSysGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpPlayer->dwIDSysPlayer);

		// if not, we go ahead and add it.  
		if (!lpSysGroupnode)
		{

			 // alloc a groupnode for the system player
		    lpSysGroupnode = DPMEM_ALLOC(sizeof(DPLAYI_GROUPNODE));
		    if (!lpSysGroupnode) 
		    {
		        DPF_ERR("out of memory adding system group node");
		        hr=E_OUTOFMEMORY;
		        goto EXIT;
		    }

			//
			// NOTE: In DX6, we add both the sysplayers and the regular players to the
			//       group AND INFORM THE SP.  It is up to the SP to distinguish
			//       systemplayers and regular players in a group.  The SP may
			//       deliver receives EITHER to the sysplayers or the regular
			//       players but not both.  The SP can differentiate sysplayers
			//       from regular players based on the flags passed into 
			//       SP_CreatePlayer.

			// now, inform the SP that we're adding this player to the group
			// this matches what happened with pre-DX6 SPs ( only sys players
			//	added to non-sys groups were told to the SP)
		    if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
				&& (this->pcbSPCallbacks->AddPlayerToGroup))
		    {
				ASSERT(lpSysGroupnode);
				data.idPlayer = pSysPlayer->dwID;
				data.idGroup = lpGroup->dwID;
 				data.lpISP = this->pISP;
				        
			    hr = CALLSP(this->pcbSPCallbacks->AddPlayerToGroup,&data);
		    }
			else 
			{
				// SP not required to implement this
				hr = DP_OK;
			}
		    if (FAILED(hr)) 
		    {
				DPF(2,"SP - AddPlayerToGroup failed - hr = 0x%08lx - GROUP FUNCTIONALITY WILL BE EMULATED",hr);    

				// take ownership of this group
				hr = MakeGroupDPlayOwned(this,lpGroup);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					// keep going.  sp may have not been able to clean up group - we keep trying...
					hr = DP_OK;
				}
		    } // FAILED(hr)

//			add our new group node to the front of the list
		    lpSysGroupnode->pNextGroupnode = lpGroup->pSysPlayerGroupnodes;
		    lpSysGroupnode->pPlayer = pSysPlayer;
		    lpSysGroupnode->nPlayers = 1;
		    lpGroup->pSysPlayerGroupnodes = lpSysGroupnode;

			// update the counts for the sysplayer
		    pSysPlayer->nGroups++;
	    	pSysPlayer->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;
		}
		else
		{
			lpSysGroupnode->nPlayers++;
		}
	}


//	Now add the player that was originally passed to us

	//	grab the pre-alloced group node
    lpGroupnode = lpGroupNodeAlloc;
	lpGroupNodeAlloc = NULL;
	
	//	first send the notification to the others.  Note we don't
	//	propagate sys group info
	if (!(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP) && fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_ADDPLAYERTOGROUP, idPlayer, 
			idGroup);
		if (FAILED(hr))	
		{
			ASSERT(FALSE); // sendsysmessage should not fail!
			// if this failed, we could have hosed global name table
			// keep going...
			hr = DP_OK;
		}
	}

	//	now, inform the SP that we're adding this player to the group
	//	a-josbor: only if this is DX6 or later
    if (((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
		&& !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
		&& (this->pcbSPCallbacks->AddPlayerToGroup) )
    {
		data.idPlayer = idPlayer;
		data.idGroup = idGroup;
		data.lpISP = this->pISP;
		        
	    hr = CALLSP(this->pcbSPCallbacks->AddPlayerToGroup,&data);
    }
	else 
	{
		// SP not required to implement this
		hr = DP_OK;
	}
    if (FAILED(hr)) 
    {
		DPF(2,"SP - AddPlayerToGroup failed - hr = 0x%08lx - GROUP FUNCTIONALITY WILL BE EMULATED",hr);    

		// take ownership of this group
		hr = MakeGroupDPlayOwned(this,lpGroup);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going.  sp may have not been able to clean up group - we keep trying...
			hr = DP_OK;
		}
    } // FAILED(hr)


	//
	// Update all the group cruft
	//

	// set up the player's groupnode	
	lpGroupnode->pNextGroupnode = 
		(fSysPlayer) ? lpGroup->pSysPlayerGroupnodes : lpGroup->pGroupnodes; // put the new node on the right list
	lpGroupnode->pPlayer = lpPlayer;
	lpGroupnode->nPlayers = 0;

	// fix up the groups structure
	if (fSysPlayer)
	{
		lpGroup->pSysPlayerGroupnodes = lpGroupnode;
	}
	else
	{
		lpGroup->pGroupnodes = lpGroupnode;
		lpGroup->nPlayers++;
	}
	
	// fix up the player struct
	lpPlayer->nGroups++;
	lpPlayer->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;		


	//
	// Finally, give the lobby a crack at
	// it, if necessary.


	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared. If it is cleared, the lobby is calling us for a
	// remote player and we don't want to call it back in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		// REVIEW!!!! -- Should we make sure the service lock is taken???
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_AddPlayerToGroup(this->lpLobbyObject, idGroup, idPlayer);
		
		// Take the lock back
		ENTER_DPLAY();

		// If the lobby failed, remove the player from the group
		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to add player to group, hr = 0x%08x", hr);
			InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->pInterfaces,
					idGroup, idPlayer, FALSE);
		}
	}

EXIT:
	if(lpGroupNodeAlloc){
		DPMEM_FREE(lpGroupNodeAlloc);
	}
	
    return hr;
}  // InternalAddPlayerToGroup  


HRESULT DPAPI DP_AddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer) 
{
	HRESULT hr;
	
	ENTER_ALL();	
	
	// bug 5807 - don't allow user to addplayer to system group
	if (DPID_ALLPLAYERS == idGroup)
	{
		LEAVE_ALL();
		DPF_ERRVAL("invalid group id = %d", idGroup);
		return DPERR_INVALIDGROUP;
	}

	hr = InternalAddPlayerToGroup(lpDP,idGroup,idPlayer,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_AddPlayerToGroup

#undef DPF_MODNAME
#define DPF_MODNAME "FreePacketList"
// remove any packetized mesages that haven't been completed yet
void FreePacketList(LPDPLAYI_DPLAY this)
{
	LPPACKETNODE pNode,pNodeNext;
	UINT_PTR uTickEvent;

	//
	// Packet list nulled here to keep PacketizeTick from
	// accessing the list while we are freeing it.
	//
	
	pNode = this->pPacketList;
	this->pPacketList = NULL;
	uTickEvent=this->uPacketTickEvent;
	this->uPacketTickEvent=0;

	LEAVE_DPLAY();
	if(uTickEvent){
		// Shutdown the ticker that ages out 
		// PacketizeAndSend Receives. -- can't hold DPLAY lock when
		// calling timeKillEvent on an event that takes the lock since
		// on NT timeKillEvent doesn't return until the function is
		// done, which would cause a deadlock if we had the lock.
		timeKillEvent((DWORD)uTickEvent);
	}	
	ENTER_DPLAY();

	while (pNode)
	{
		pNodeNext = pNode->pNextPacketnode;

		if(pNode->bReliable && pNode->bReceive){
			this->nPacketsTimingOut -= 1;
			ASSERT(!(this->nPacketsTimingOut&0x80000000));
		}

		// free up the packet node
		FreePacketNode(pNode);
				
		pNode = pNodeNext;
	}
	
	ASSERT(this->nPacketsTimingOut == 0);

	Sleep(0); // allow expired timers to run.

	return ;
	
} // FreePacketList

// remove any pending messages
void FreePendingList(LPDPLAYI_DPLAY this)
{
	LPPENDINGNODE pmsg,pmsgNext;

	pmsg = this->pMessagesPending;
	while (pmsg)
	{
		pmsgNext = pmsg->pNextNode;
		if (pmsg->pMessage) DPMEM_FREE(pmsg->pMessage);
		if (VALID_SPHEADER(pmsg->pHeader)) DPMEM_FREE(pmsg->pHeader);
		DPMEM_FREE(pmsg);
		pmsg = pmsgNext;
	}

	this->pMessagesPending = NULL;
	this->pLastPendingMessage = NULL;
	
	ASSERT(0 == this->nMessagesPending);

	return ;
		
} // FreePendingList 

// nuke our keep alive thread or our control panel thread
// signal the thread (so it will wake up and exit), then wait for it to
// go away
void KillThread(HANDLE hThread,HANDLE hEvent)
{
	DWORD dwRet;
	
	if (hThread)
	{
		SetEvent(hEvent);
		
		// wait for it to die
		dwRet = WaitForSingleObject(hThread,INFINITE);
		if (WAIT_OBJECT_0 != dwRet) 
		{
			ASSERT(FALSE);
			// sholuld never happen
		}
		
		if (!CloseHandle(hThread))
		{
			DWORD dwErr = GetLastError();
			
			DPF(0,"could not close thread - err = %d\n",dwErr);
		}

		if (!CloseHandle(hEvent))
		{
			DWORD dwErr = GetLastError();
			
			DPF(0,"could not close event handle - err = %d\n",dwErr);
		}
		
	}
	else 
	{
		ASSERT(!hEvent);
	}

	return ;
	
} // KillThread

// called by DP_Close
void CloseSecurity(LPDPLAYI_DPLAY this)
{
    // free up the security desc
    if (this->pSecurityDesc)
    {
        FreeSecurityDesc(this->pSecurityDesc,FALSE);
        DPMEM_FREE(this->pSecurityDesc);
        this->pSecurityDesc = NULL;
    }

    if (this->phCredential)
    {
        OS_FreeCredentialHandle(this->phCredential);
        DPMEM_FREE(this->phCredential);
        this->phCredential = NULL;
    }

    // free up user credentials
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }

    if (this->phContext)
    {
        OS_DeleteSecurityContext(this->phContext);
        DPMEM_FREE(this->phContext);
        this->phContext = NULL;
    }

    // cleanup CAPI stuff
    if (this->hPublicKey) 
    {
        OS_CryptDestroyKey(this->hPublicKey);
        this->hPublicKey = 0;
    }
    if (this->hServerPublicKey) 
    {
        OS_CryptDestroyKey(this->hServerPublicKey);
        this->hServerPublicKey = 0;
    }
    if (this->hEncryptionKey) 
    {
        OS_CryptDestroyKey(this->hEncryptionKey);
        this->hEncryptionKey = 0;
    }
    
    if (this->hDecryptionKey) 
    {
        OS_CryptDestroyKey(this->hDecryptionKey);
        this->hDecryptionKey = 0;
    }

    if (this->pPublicKey)
    {
	    DPMEM_FREE(this->pPublicKey);
	    this->pPublicKey = NULL;
    }

	// All objects contained in a crypt context must be released before 
	// freeing the context. Otherwise, it will cause handle leaks.
    if (this->hCSP) 
    {
        OS_CryptReleaseContext(this->hCSP,0);
        this->hCSP = 0;
    }

    // reset login state
    this->LoginState = DPLOGIN_NEGOTIATE;
    // reset the buffer sizes
    this->ulMaxContextBufferSize = 0;
    this->ulMaxSignatureSize = 0;

} // CloseSecurity


// Release a message node and any buffer that is stored on it.
VOID FreeMessageNode(LPDPLAYI_DPLAY this, LPMESSAGENODE pmsn)
{
	PSENDPARMS psp;
	DWORD dwType=0;

	if(pmsn->pMessage)
	{	
		dwType=(*((LPDPMSG_GENERIC)pmsn->pMessage)).dwType;

		// check for DPSYS_SENDCOMPLETE
		if (pmsn->idFrom == DPID_SYSMSG && dwType == DPSYS_SENDCOMPLETE)
		{
			DPF(8,"Freeing a DPSYS_SENDCOMPLETE message. pmsn == 0x%x", pmsn);
			psp=CONTAINING_RECORD(pmsn,SENDPARMS,msn);
			FreeSendParms(psp);
			// a-josbor: note, we don't free the pmsn because it's freed by FreeSendParams,
			//	according to aarono
		}
		else
		{
			DPMEM_FREE(pmsn->pMessage);
			DPMEM_FREE(pmsn);
		}
	}
	
	this->nMessages--;
}



// Note on closing of Retry and Keepalive thread.  The Retry and KeepAlive threads both do ENTER_ALL's
// in their processing path.  So when we wait for them to complete in DP_Close, we don't know if the
// interface pointer is still valid after we return (since we must drop both locks in order to wait or
// else we would deadlock).  So we flag that that part of shutdown is done and we go back to the top
// of DP_Close and revalidate the 'this' pointer before going on.

HRESULT DPAPI DP_Close(LPDIRECTPLAY lpDP) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	LPDPLAYI_GROUP pGroup,pGroupNext;
	LPMESSAGENODE pmsg,pmsgNext;
	int nMessages=0;
    DWORD index;
    LPCLIENTINFO pClientInfo;
	HANDLE hPerfThread;
	HANDLE hPerfEvent;
	BOOL   fDidClose=FALSE;
	BOOL   bWaitForDplayThread=FALSE;

Top:

	ENTER_ALL();

	DPF(8, "Entering DP_Close");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if (!this->lpsdDesc) 
	{
		LEAVE_ALL();
		DPF_ERR("no session!");
		return DPERR_NOSESSIONS;
	}

	// stop the enum thread
	if (this->dwFlags & DPLAYI_DPLAY_ENUM)	
	{
		StopEnumThread(this);
		bWaitForDplayThread=TRUE;
	} else {
		bWaitForDplayThread=FALSE;
	}

	// mark dplay as closed
	this->dwFlags |= DPLAYI_DPLAY_CLOSED;

#ifdef DPLAY_VOICE_SUPPORT
	// shut down the voice, if it's open
	if (this->pVoice) DP_CloseVoice(lpDP,0);
#endif

	// if keep alives are on, turn 'em off
	if (this->dwFlags & DPLAYI_DPLAY_KEEPALIVE || bWaitForDplayThread)	
	{
		HANDLE hWait;
		this->dwFlags &= ~DPLAYI_DPLAY_KEEPALIVE;
		// tell thread to wake up and smell the new settings
		SetEvent(this->hDPlayThreadEvent);
		hWait=this->hDPlayThread;
		this->hDPlayThread=0;
		LEAVE_ALL();
		WaitForSingleObject(hWait,INFINITE);
		CloseHandle(hWait);
		goto Top;	// this may now be invalid, back to the top
	}

	if(this->hPerfThread){
		// drop the locks, in case our threads are blocked trying to get in
		hPerfThread=this->hPerfThread;
		hPerfEvent=this->hPerfEvent;
		this->hPerfThread=0;
		this->hPerfEvent=0;
		LEAVE_ALL();
		KillThread(hPerfThread,hPerfEvent);
		goto Top;
	}
	
	// first, destroy all local players except sysplayer
	// (sysplayer is last local player to be destroyed, since it
	// needs to send destroy messages)

	pPlayer=this->pPlayers;
	
	while (pPlayer)
	{
		pPlayerNext=pPlayer->pNextPlayer;
		// store next player now (so we don't blow it away...)
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{

			if(pPlayer != this->pSysPlayer){
				hr = InternalDestroyPlayer(this,pPlayer,TRUE,FALSE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				} else {
					pPlayerNext=this->pPlayers; // list may have been nuked, back to beginning.
				}	
			} else {
				DPF(0,"Just avoided nuking sysplayer w/o sysplayer flag set on it! this %x pPlayer %x\n",this,pPlayer);
				DEBUG_BREAK();
			}
		}
		pPlayer=pPlayerNext;
	}

	// destroy groups - note, this will also destroy the sysgroup...
	pGroup = this->pGroups;
	while (pGroup)
	{
		// store next Group now (so we don't blow it away...)
		pGroupNext = pGroup->pNextGroup;
		if (pGroup != this->pSysGroup) // destroy sysgroup later
		{
			hr = InternalDestroyGroup(this,pGroup,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			// since internaldestroygroup may have nuked > 1 group (sub-groups)
			// we reset to beginning of list
			pGroupNext =  this->pGroups;
		}
		pGroup = pGroupNext;
	}

    // security related cleanup
    if (SECURE_SERVER(this))
    {
        if (this->pSysPlayer && IAM_NAMESERVER(this))
        {
            // cleanup any lingering client info structures - this could happen
            // if nameserver gives out an id in response to a negotiate message 
            // and the client never comes back
            for (index=0; index < this->uiNameTableSize; index++)
            {
                if ((NAMETABLE_PENDING == this->pNameTable[index].dwItem))
                {
                    // is client info stored in here ?
                    pClientInfo = (LPCLIENTINFO) this->pNameTable[index].pvData;
                    if (pClientInfo)
                    {
                        RemoveClientInfo(pClientInfo);
                        // free up the memory
                        DPMEM_FREE(pClientInfo);
                    }
                }
            }
        }
    }

	// sysplayer should be only local player left
	// we could have a session w/ no sysplayer if it was 
	// opened enumonly
	if (this->pSysPlayer)
	{
		hr = InternalDestroyPlayer(this,this->pSysPlayer,TRUE,FALSE);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}// sysplayer
	this->pSysPlayer = NULL;

	// now, destroy sys group
	if (this->pSysGroup)
	{
			hr = InternalDestroyGroup(this,this->pSysGroup,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
	}
	this->pGroups = NULL;
	this->pSysGroup = NULL;


	// finally, destroy all non-local players
	pPlayer = this->pPlayers;
	while (pPlayer)
	{

		// store next player now (so we don't blow it away...)
		pPlayerNext = pPlayer->pNextPlayer;

		ASSERT(!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL));
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}

		pPlayer = pPlayerNext;
	}
 	this->pPlayers = NULL;

	//
	// if the retry thread is running, shut it down.
	//
	if(this->hRetryThread){
		HANDLE hWait;
		SetEvent(this->hRetry);
		hWait=this->hRetryThread;
		this->hRetryThread=0;
		LEAVE_ALL();
		WaitForSingleObject(hWait,INFINITE);
		CloseHandle(hWait);
		goto Top;	// this may now be invalid, back to the top
	}

	if(this->hRetry){
		FiniPacketize(this); // cleans up handle and critical section.
	}	

	// notify sp
	// drop locks, in case sp needs has any threads blocked on handlemessage

	if(!fDidClose){
		
		// If this object is lobby-owned, call the lobby here
		if(IS_LOBBY_OWNED(this))
		{
			LEAVE_ALL();
			
			hr = PRV_Close(this->lpLobbyObject);
			fDidClose=TRUE;
			
			goto Top;
		}
		else
		{
			if (this->pcbSPCallbacks->CloseEx) 
			{
				DPSP_CLOSEDATA cd;
				
				cd.lpISP = this->pISP;

				LEAVE_DPLAY();
	    		hr = CALLSP(this->pcbSPCallbacks->CloseEx,&cd);					
	    		ENTER_DPLAY();
	    		fDidClose=TRUE;

			}
			else if (this->pcbSPCallbacks->Close) 
			{
				// dx3 sp's had a VOID arg list for shutdown
				LEAVE_DPLAY();
	    		hr = CALLSPVOID( this->pcbSPCallbacks->Close );
	    		ENTER_DPLAY();
	    		fDidClose=TRUE;
	    		
			}
			else 
			{
				// no callback - no biggie
				hr = DP_OK;
			}
		}
		
		if (FAILED(hr)) 
	    {
			DPF(0,"Close session failed - hr = 0x%08lx\n",hr);
			// keep going...
	    }
	}
	

	// Shutdown the protocol if running.
	if(this->pProtocol){
		// need to NULL this->pProtocol before dropping lock.
		LPPROTOCOL_PART pProtocol=this->pProtocol;
		this->pProtocol=NULL;
		LEAVE_ALL();
		FiniProtocol(pProtocol);
		goto Top;
	}

	// get rid of any messages left in the apps q
	pmsgNext = this->pMessageList;
	DPF(0,"close - cleaning up %d messages\n",this->nMessages);
	while (pmsgNext)
	{
		pmsg = pmsgNext;
		pmsgNext = pmsg->pNextMessage;
		// free up this message node
		FreeMessageNode(this, pmsg);
	}
	ASSERT(0 == this->nMessages);
	this->pMessageList = NULL;
	this->pLastMessage = NULL;

    // the cleanup needs to happen after we are done sending secure messages 
    if (SECURE_SERVER(this))
    {
		CloseSecurity(this);
    }

	// free up the session desc
	if (this->lpsdDesc)
	{
        FreeDesc(this->lpsdDesc,FALSE);
        DPMEM_FREE(this->lpsdDesc);
    	this->lpsdDesc=NULL;
	} 

	// free up the name table
	if (this->pNameTable) DPMEM_FREE(this->pNameTable);
	this->pNameTable=NULL;
	this->uiNameTableSize = 0;
	this->uiNameTableLastUsed = 0;


	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		FreePendingList(this);		
		this->dwFlags &= ~DPLAYI_DPLAY_PENDING;
	}

	// reset all session level flags
	this->dwFlags &= ~ (DPLAYI_DPLAY_SESSIONFLAGS);

	// reset the min version for this object
	this->dwMinVersion = DPSP_MSG_VERSION;
	
	while (this->pAddForwardList) FreeAddForwardNode(this,this->pAddForwardList);
	this->pAddForwardList = NULL;

	LEAVE_ALL();

	DPF(8, "Leaving DP_Close");

    return DP_OK;
        
}//DP_Close

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreatePlayer/DP_CreateGroup"

// allocate player structure
HRESULT AllocatePlayer( LPDPLAYI_PLAYER * lplpPlayer)
{
    LPDPLAYI_PLAYER pPlayer;

    // alloc memory for the player
    pPlayer = DPMEM_ALLOC(sizeof(DPLAYI_PLAYER));
    
    if (!pPlayer) 
    {
		*lplpPlayer = NULL;
        DPF_ERR("player alloc failed!");
        return E_OUTOFMEMORY;
    }
    
    pPlayer->dwSize = sizeof(DPLAYI_PLAYER); // used to validate structure

    // return the new player
    *lplpPlayer = pPlayer;
    
    return DP_OK;
} // AllocatePlayer

// done w/ player data structure
HRESULT DeallocPlayer(LPDPLAYI_PLAYER lpPlayer) 
{
    if (!lpPlayer) return E_UNEXPECTED;
	if ((lpPlayer->hEvent) &&
		(lpPlayer->dwFlags & DPLAYI_PLAYER_CREATEDPLAYEREVENT))
	{
		CloseHandle(lpPlayer->hEvent);
	}
    if (lpPlayer->lpszShortName) DPMEM_FREE(lpPlayer->lpszShortName);
    if (lpPlayer->lpszLongName) DPMEM_FREE(lpPlayer->lpszLongName);
	if (lpPlayer->pvPlayerData) DPMEM_FREE(lpPlayer->pvPlayerData);
	if (lpPlayer->pvPlayerLocalData) DPMEM_FREE(lpPlayer->pvPlayerLocalData);

	// free it's sp data
	if (lpPlayer->pvSPData) DPMEM_FREE(lpPlayer->pvSPData);
	if (lpPlayer->pvSPLocalData) DPMEM_FREE(lpPlayer->pvSPLocalData);	

    // free security context and credential handle
    if (lpPlayer->pClientInfo) 
    {
        RemoveClientInfo(lpPlayer->pClientInfo);
        DPMEM_FREE(lpPlayer->pClientInfo);
        lpPlayer->pClientInfo = NULL;
    }

#ifdef DEBUG
    lpPlayer->lpszShortName= (WCHAR *) 0xBEEDBEBE;
    lpPlayer->lpszLongName= (WCHAR *) 0xBEEDBEBE; 
	lpPlayer->pvPlayerData= (LPVOID) 0xBEEDBEBE; 
	lpPlayer->pvPlayerLocalData= (LPVOID)0xBEEDBEBE;
	lpPlayer->pvSPData= (LPVOID)0xBEEDBEBE;
	lpPlayer->pvSPLocalData= (LPVOID)0xBEEDBEBE;
#endif 		

    lpPlayer->dwSize=0xdeadbeef; //just in case someone tries to reuse dead memory
    DPMEM_FREE(lpPlayer);

    return DP_OK;

} // DeallocPlayer

// call sp's create player callback
// called by GetPlayer and UnpackPlayerList
HRESULT CallSPCreatePlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL bLocal,
	LPVOID pvSPMessageHeader, BOOL bNotifyProtocol)
{
	HRESULT hr=DP_OK;
    DPSP_CREATEPLAYERDATA cpd;

    if (this->pcbSPCallbacks->CreatePlayer || (bNotifyProtocol && this->pProtocol)) 
    {
	    // call sp
		memset(&cpd,0,sizeof(cpd));
	    cpd.idPlayer = pPlayer->dwID;
		cpd.lpSPMessageHeader = pvSPMessageHeader;
		cpd.dwFlags = pPlayer->dwFlags;
		cpd.lpISP = this->pISP;

		if(bNotifyProtocol && this->pProtocol){
			hr = ProtocolCreatePlayer(&cpd); // calls SP too.
		} else {
		    hr = CALLSP(this->pcbSPCallbacks->CreatePlayer,&cpd);	    	
		}    
	    if (FAILED(hr)) 
	    {
			DPF(0,"SP - Create player failed - hr = 0x%08lx\n",hr);
			return hr;
	    }
    }
	else 
	{
		// its ok if the sp doesn't implement this...
	}

	return hr;

} // CallSPCreatePlayer


/*
 ** GetPlayer	
 *
 *  CALLED BY:	InternalCreatePlayer,unpack player list and handledeadnameserver.
 *
 *  PARAMETERS:
 *		this - dplay object
 *		ppPlayer - pointer to player to create. return value
 *		pName - strings
 *		phEvent - handle to receive event
 *		pvData	- player data blob
 *		dwDataSize - size of blob
 *      dwFlags - player flags
 *      lpszPassword - session password, if creating a system player. NULL otherwise.
 *		dwLobbyID -- ID of the player in a lobby sesssion, assigned by the lobby server
 *
 *  DESCRIPTION: Creates the player. Allocs the player structure,and sets the data and calls the 
 *		sp (and adds to nametable) if local.
 *
 *	
 *  RETURNS:
 *		 DP_OK or E_OUTOFMEMORY or sp scode
 *
 */
HRESULT GetPlayer(LPDPLAYI_DPLAY this,  LPDPLAYI_PLAYER * ppPlayer,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags, LPWSTR lpszSessionPassword, DWORD dwLobbyID)
{
    HRESULT hr = DP_OK;
    DWORD id=0;
	LPDPLAYI_PLAYER pLastPlayer;
	

    // a-josbor: First thing: decrement our reservation count if it's a
    //	remote player.  We want to do this even if there is an error
    //	creating the player
    if (IAM_NAMESERVER(this) && !(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
    	if (this->dwPlayerReservations > 0)	// just in case...
    		this->dwPlayerReservations--;
    }


    // allocate / initialize a dplayi_player structure
    hr = AllocatePlayer( ppPlayer );
    if (FAILED(hr)) 
    {
    	return hr;
    }

	// update player fields
    (*ppPlayer)->lpDP = this;
    (*ppPlayer)->dwFlags = dwFlags;
    (*ppPlayer)->hEvent = hEvent;	
	(*ppPlayer)->nPendingSends = 0;
	InitBilink(&((*ppPlayer)->PendingList));
	
	// set up the name
	hr = DoPlayerName(*ppPlayer,pName);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// set up the data
	hr = DoPlayerData(*ppPlayer,pvData,dwDataSize,DPSET_REMOTE);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

     // if it's the app server, remember it
    if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_APPSERVER)
    {
    	this->pServerPlayer = (*ppPlayer);
    }

     // if it's the name server, remember it
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_NAMESRVR)
	{
		DPF(4,"creating name server");
		this->pNameServer = (*ppPlayer);
	}

	// add local player to name table.  
	// if its not local, unpack will add it for us, 
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
	    // if it's the app server, use the reserved appplayer id
	    if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_APPSERVER)
	    {
		    (*ppPlayer)->dwID = DPID_SERVERPLAYER;
	    }
	    else 
	    {
		    // get a player id, add player to name table
		    hr = AddItemToNameTable(this,(DWORD_PTR) (*ppPlayer),&id,TRUE,dwLobbyID);
		    if (FAILED(hr)) 
		    {
				goto ERROR_EXIT;
		    }
		    
			(*ppPlayer)->dwID = id;
	    }

		// Make sure we have a system player (a lobby-owned object may not)
		if(this->pSysPlayer)
		{
			(*ppPlayer)->dwIDSysPlayer = this->pSysPlayer->dwID;
		}
		
		(*ppPlayer)->dwVersion = DPSP_MSG_VERSION;
		
		// give sp a pop at the player...
		hr = CallSPCreatePlayer(this,*ppPlayer,TRUE,NULL,TRUE);
		if (FAILED(hr))
		{
			FreeNameTableEntry(this,id);
			goto ERROR_EXIT;
		}

		// notify all local and remote players of new player
		// unpack will send create messages for non-local players...
		hr = SendCreateMessage( this, *ppPlayer,TRUE, lpszSessionPassword);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// hmmm, what to do with a failure here?
			// keep going...
			hr = DP_OK;
		}

		// add player to system group.
		// unpack will do this for non-local players
		if (this->pSysGroup)
		{
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			(*ppPlayer)->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
		}

	}  // local

	// new sysplayers go on the front of the list
	// this is so when we unpack players and add them to the system group, we always
	// need to unpack system players first...
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
	{
		// slap 'em on the front
		(*ppPlayer)->pNextPlayer = this->pPlayers;
		this->pPlayers = *ppPlayer;
	}
	else 
	{
		// put new non-sysplayer at the back of the list
		pLastPlayer = this->pPlayers;
		if (!pLastPlayer) 
		{
			this->pPlayers = (*ppPlayer);
		}
		else 
		{
			// find the last system player in the list - insert our new 
			// player behind it...
			while ((pLastPlayer->pNextPlayer) 
				&& (pLastPlayer->pNextPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) 
			{
				pLastPlayer = pLastPlayer->pNextPlayer;		
			}
			ASSERT(pLastPlayer);
			// also, if there's a dx3 in the session, the list may be out of order
			if(!(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
			{
				ASSERT(pLastPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
				if(pLastPlayer->pNextPlayer)
				{
					ASSERT(!(pLastPlayer->pNextPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER));
				}
			}
			(*ppPlayer)->pNextPlayer = pLastPlayer->pNextPlayer;
			pLastPlayer->pNextPlayer = (*ppPlayer);
		}
	}

	if (!(dwFlags & DPLAYI_PLAYER_SYSPLAYER))
	{
		this->lpsdDesc->dwCurrentPlayers++;
	}

	this->nPlayers++;

	// SUCCESS
    return hr;

ERROR_EXIT:
	
	DPF(0,"*****	GetPlayer failed - hr = 0x%08lx !!!\n",hr);
	DeallocPlayer(*ppPlayer);
	*ppPlayer = NULL;
	return hr;
    	
} // GetPlayer


HRESULT AllocGroup(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP * ppGroup)
{

    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP pGroup;

    // alloc memory for the group
    pGroup = DPMEM_ALLOC(sizeof(DPLAYI_GROUP));
    
    if (!pGroup) 
    {
        DPF_ERR("group alloc failed!");
        return E_OUTOFMEMORY;
    }
    
    pGroup->dwSize = sizeof(DPLAYI_GROUP); // used to validate structure

    // return the new group
    *ppGroup = pGroup;
    			
    return hr;

} // AllocGroup

HRESULT DeallocGroup(LPDPLAYI_GROUP lpGroup) 
{
    if (lpGroup->lpszShortName) DPMEM_FREE(lpGroup->lpszShortName);
    if (lpGroup->lpszLongName) DPMEM_FREE(lpGroup->lpszLongName);
	if (lpGroup->pvPlayerData) DPMEM_FREE(lpGroup->pvPlayerData);
	if (lpGroup->pvPlayerLocalData) DPMEM_FREE(lpGroup->pvPlayerLocalData);

    lpGroup->dwSize=0xdeadbeef; //just in case someone tries to reuse dead memory	
    DPMEM_FREE(lpGroup);

    return DP_OK;
    
} // DeallocGroup

// call sp's create group callback
// called by GetGroup and UnpackGroupList
HRESULT CallSPCreateGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,BOOL bLocal,
	LPVOID pvSPMessageHeader)
{
	HRESULT hr=DP_OK;
    DPSP_CREATEGROUPDATA cgd;

	if (this->dwFlags & DPLAYI_DPLAY_DX3INGAME)
	{
		// no optimized groups w/ dx3
		hr = E_NOTIMPL;
	}
    else if (this->pcbSPCallbacks->CreateGroup) 
    {
	    // call sp
		memset(&cgd,0,sizeof(cgd));
	    cgd.idGroup = pGroup->dwID;
		cgd.lpSPMessageHeader = pvSPMessageHeader;
		cgd.dwFlags = pGroup->dwFlags;
		cgd.lpISP = this->pISP;

	    hr = CALLSP(this->pcbSPCallbacks->CreateGroup,&cgd);	    	
	    if (FAILED(hr)) 
	    {
			DPF(0,"SP - Create group failed - hr = 0x%08lx\n",hr);
	    }

    }
	else 
	{
		// if they don't support it - dplay will emulate it
		hr = E_NOTIMPL;
	}

	if (FAILED(hr))
	{
		// the SP couldn't do it.  mark group as owned by dplay.
		pGroup->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
	}
	
	return DP_OK;

} // CallSPCreateGroup

// called by DP_CreateGroup and UnpackPlayerAndGroupList
// actually creates the group.
// todo - make this and getplayer use the same code!
HRESULT GetGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP * ppGroup,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,DPID idParent,DWORD dwLobbyID)
{
	HRESULT hr;
	DWORD id;
	LPDPLAYI_GROUP pLastGroup; // stick new groups on end
	
    // create a group
    hr = AllocGroup(this, (LPDPLAYI_GROUP *)ppGroup);
    if (FAILED(hr)) 
    {
        return hr;
    }

	// set up the name
	hr = DoPlayerName((LPDPLAYI_PLAYER)*ppGroup,pName);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// set up the data
	hr = DoPlayerData((LPDPLAYI_PLAYER)*ppGroup,pvData,dwDataSize,DPSET_REMOTE);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// store the flags
	(*ppGroup)->dwFlags = dwFlags;
    (*ppGroup)->lpDP = this;
   	(*ppGroup)->dwIDParent = idParent;
	
	if ((*ppGroup)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)  
	{
		if ((*ppGroup)->dwFlags & DPLAYI_GROUP_SYSGROUP)
		{
			// use the reserved id for the system group
			(*ppGroup)->dwID = DPID_ALLPLAYERS;
		}
		else 
		{
		    // get a Group id, add Group to name table
		    hr = AddItemToNameTable(this,(DWORD_PTR) (*ppGroup),&id,FALSE,dwLobbyID);
		    if (FAILED(hr)) 
		    {
				goto ERROR_EXIT;
		    }

			(*ppGroup)->dwID = id;
		}
		

		// Make sure we have a system player (a lobby-owned object may not)
		if(this->pSysPlayer)
		{
			(*ppGroup)->dwIDSysPlayer = this->pSysPlayer->dwID;
		}

		(*ppGroup)->dwVersion = DPSP_MSG_VERSION;
		
		// tell sp about group
		hr = CallSPCreateGroup(this,*ppGroup,TRUE,NULL);
		if (FAILED(hr))
		{
			// make group dplay owned
			(*ppGroup)->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
		}

		// don't send create message if it's the system group
		if (!(dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// notify all local and remote players of new group
			// unpack will send create messages for non-local groups...
			hr = SendCreateMessage( this, *ppGroup,FALSE,NULL);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// hmmm, what to do with a failure here?
				// keep going...
				hr = DP_OK;
			}
		}

	}  // local

	// andyco - DX5 - new groups go on back

	if (this->pGroups) // empty list?
	{
		pLastGroup = this->pGroups;	
		// find the last one
		while (pLastGroup->pNextGroup)
		{
			 pLastGroup = pLastGroup->pNextGroup;
		}
		// found the end, stick the new group on
		ASSERT(pLastGroup);
		pLastGroup->pNextGroup = *ppGroup;
	}
	else 
	{
		this->pGroups = *ppGroup;
	}
	
	this->nGroups++;    

	return hr;

ERROR_EXIT:

	DPF(0,"*** GetGroup failed - hr = 0x%08lx\n",hr);
	DeallocGroup(*ppGroup);
	return hr;

} // GetGroup	


void MakeLocalPlayerGroupOwner(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP lpGroup,
		LPDPLAYI_PLAYER lpOwner)
{
	LPDPLAYI_GROUPOWNER		lpOwnerNode = NULL;


	ASSERT(lpGroup);

	// If we don't have a player, just make the server player own the group
	if(!lpOwner)
		lpGroup->dwOwnerID = DPID_SERVERPLAYER;

	// Allocate memory for the owner node
	lpOwnerNode = DPMEM_ALLOC(sizeof(DPLAYI_GROUPOWNER));
	if(!lpOwnerNode)
	{
		DPF_ERR("Unable to allocate memory for groupowner node");
		// So just set the group's owner to DPID_SERVERPLAYER
		lpGroup->dwOwnerID = DPID_SERVERPLAYER;
		return;
	}

	// Setup the node
	lpOwnerNode->pGroup = lpGroup;

	// Add it to the list
	lpOwnerNode->pNext = lpOwner->pOwnerGroupList;
	lpOwner->pOwnerGroupList = lpOwnerNode;

	// Set the group's owner ID
	lpGroup->dwOwnerID = lpOwner->dwID;

} // MakeLocalPlayerGroupOwner


/*
 ** InternalCreatePlayer	
 *
 *  CALLED BY:	DP_CreatePlayer,DP_CreateGroup,
 *
 *  PARAMETERS:
 *		lpDP - dplay interface pointer
 *		pid -  player / group id - return value
 *		pName - strings
 *		phEvent - handle to receive event. NULL for groups
 *		pvData	- player data blob
 *		dwDataSize - size of blob
 *		dwCreateFlags - dwFlags passed to create fn.
 *
 *  DESCRIPTION: validates params for DP_CreatePlayer/Group.
 *				calls GetPlayer or GetGroup to create + set up
 *				the player or group.
 *
 *	
 *  RETURNS:
 *		 DP_OK or E_OUTOFMEMORY or GetPlayer/Group error code.
 *
 */

// assumes service + dplay lock taken!
HRESULT InternalCreatePlayer(LPDIRECTPLAY lpDP, LPDPID pid,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,BOOL fPlayer,DPID idParent)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	DWORD dwPlayerFlags;
	LPWSTR lpszShortName,lpszLongName;
	LPDPLAYI_PLAYER lpPlayer=NULL;
	LPDPLAYI_GROUP lpGroup=NULL;
	LPDPLAYI_PLAYER lpRandomPlayer=NULL;
	DPID idOwner;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc) 
		{
			DPF_ERR("must join session before creating players");
			return DPERR_INVALIDPARAMS;
		}
		if (!VALID_DWORD_PTR(pid))
		{
			DPF_ERR("invalid pid pointer");
			return DPERR_INVALIDPARAMS;
		}
        if (pName && !VALID_READ_DPNAME_PTR(pName))
        {
			DPF_ERR("invalid dpname pointer");
			ASSERT(FALSE);

			// returning an error here causes a regression with DX3, since
			// we did not do parameter checks on the name previously
//			return DPERR_INVALIDPARAMS;
        }

		// check strings
		if (pName)
		{
			lpszShortName = pName->lpszShortName;
			lpszLongName = pName->lpszLongName;
			if ( lpszShortName && 
				!VALID_READ_STRING_PTR(lpszShortName,WSTRLEN_BYTES(lpszShortName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
			if ( lpszLongName && 
				!VALID_READ_STRING_PTR(lpszLongName,WSTRLEN_BYTES(lpszLongName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
		}
		// check event handle
		if ((hEvent) && (!OS_IsValidHandle(hEvent)))
		{
	        DPF_ERR( "bad event handle" );
	        return DPERR_INVALIDPARAMS;
		}		
		// check blob
		if (dwDataSize && !VALID_READ_STRING_PTR(pvData,dwDataSize)) 
		{
	        DPF_ERR( "bad player blob" );
	        return DPERR_INVALIDPARAMS;
		}

		if (fPlayer)
		{
			// check player flags
			if (!VALID_CREATEPLAYER_FLAGS(dwFlags))
			{
				DPF_ERR( "invalid flags" );
				return DPERR_INVALIDFLAGS;
			}
		}
		else
		{
			// check group flags
			if (!VALID_CREATEGROUP_FLAGS(dwFlags))
			{
				DPF_ERR( "invalid flags" );
				return DPERR_INVALIDFLAGS;
			}
		}
		
		// only nameserver can create serverplayer
		if ( (dwFlags & DPPLAYER_SERVERPLAYER) && !(IAM_NAMESERVER(this)) )
		{
			DPF_ERR("only host can create server player");
			return DPERR_INVALIDFLAGS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// see if we're allowed to create a player
	if (fPlayer)
	{
		if ( this->lpsdDesc->dwMaxPlayers ) 
		{
			if (this->lpsdDesc->dwCurrentPlayers >= this->lpsdDesc->dwMaxPlayers )
			{
				DPF(1,"can't create new player - exceeded dwMaxPlayers");
				return DPERR_CANTCREATEPLAYER;
			}
		}
		if (this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED)
		{
			DPF_ERR("can't create new player - DPSESSION_NEWPLAYERSDISABLED");
			return DPERR_CANTCREATEPLAYER;
		}
		// in a client server session, the session host (server) can't create
		// any players other than the DPID_SERVERPLAYER
		if ((this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) && 
			(IAM_NAMESERVER(this)) && !(dwFlags & DPPLAYER_SERVERPLAYER) )
		{
			DPF_ERR(" session host can only create DPPLAYER_SERVERPLAYER");
			return DPERR_ACCESSDENIED;
		}
	}

	// If this object is lobby-owned, do the server stuff and take
	// care of the rest of the nametable stuff from the lobby code.
	if(IS_LOBBY_OWNED(this))
	{
		// We need to drop the lock so the lobby's receive thread can
		// get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		if(fPlayer)
		{
			hr = PRV_CreatePlayer(this->lpLobbyObject, pid, pName, hEvent,
								pvData, dwDataSize, dwFlags);
		}
		else
		{
			// If it's a group, someone on this machine needs to be the group
			// owner, so just randomly pick a local player.  If there aren't
			// any local players, make the server player be the owner.
			lpRandomPlayer = GetRandomLocalPlayer(this);
			idOwner = (lpRandomPlayer ? lpRandomPlayer->dwID : DPID_SERVERPLAYER);
			
			// If there is a parent ID, then this is a CreateGroupInGroup call
			if(idParent)
			{
				hr = PRV_CreateGroupInGroup(this->lpLobbyObject, idParent,
						pid, pName,	pvData, dwDataSize, dwFlags, idOwner);
			}
			else
			{
				hr = PRV_CreateGroup(this->lpLobbyObject, pid, pName,
						pvData, dwDataSize, dwFlags, idOwner);
			}

			// Store the owner in the group, and create a reference node in the player
			if(SUCCEEDED(hr))
			{
				// Get the player the lobby just created
				lpGroup = GroupFromID(this, *pid);
				if(lpGroup)
					MakeLocalPlayerGroupOwner(this, lpGroup, lpRandomPlayer);
			}
		}
		
		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed creating player or group on the lobby, hr = 0x%08x", hr);
		}

		// Since all of the work below is already done by the lobby,
		// we can exit here.
		return hr;
	}

	// go get a player
	dwPlayerFlags =  DPLAYI_PLAYER_PLAYERLOCAL;
	
#ifdef DPLAY_VOICE_SUPPORT
	if (this->dwFlags & DPLAYI_DPLAY_VOICE) dwPlayerFlags |= DPLAYI_PLAYER_HASVOICE;
#endif // DPLAY_VOICE_SUPPORT
	
	if (dwFlags & DPPLAYER_SERVERPLAYER)
	{
		if (this->pServerPlayer)
		{
			DPF_ERR("server player already exists");
			return DPERR_CANTCREATEPLAYER;
		}
		// else
		dwPlayerFlags |= DPLAYI_PLAYER_APPSERVER;
	}

	if (dwFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;

	if (dwFlags & DPGROUP_STAGINGAREA)
		dwPlayerFlags |= DPLAYI_GROUP_STAGINGAREA;

	if(dwFlags & DPGROUP_HIDDEN)
		dwPlayerFlags |= DPLAYI_GROUP_HIDDEN;

	if (fPlayer)
	{
	    hr = GetPlayer(this, &lpPlayer,pName,hEvent,pvData,dwDataSize,dwPlayerFlags,NULL,0);
	}
	else 
	{
	    hr = GetGroup(this, &lpGroup,pName,pvData,dwDataSize,dwPlayerFlags,idParent,0);
	}
    if (FAILED(hr)) 
    {
		DPF(0,"Create player / group failed - hr = 0x%08lx\n",hr);
		if (hr == DPERR_TIMEOUT)
			hr = DPERR_CANTCREATEPLAYER;
        return hr;
    }
	
	// store the return value
	if (fPlayer) *pid = lpPlayer->dwID;
	else *pid = lpGroup->dwID;

	if (hr == DPERR_TIMEOUT)
		hr = DPERR_CANTCREATEPLAYER;

	return hr;
} // InternalCreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreatePlayer"
HRESULT DPAPI DP_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;

	ENTER_ALL();
	
	hr = InternalCreatePlayer(lpDP, pidPlayerID,pName,hEvent,pvData,
		dwDataSize,dwFlags,TRUE,0) ;

	LEAVE_ALL();		
	
	return hr;

}// DP_CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreateGroup"
HRESULT DPAPI DP_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;

	ENTER_ALL();
	
	hr = InternalCreatePlayer(lpDP, pidGroupID,pName,NULL,pvData,
		dwDataSize,dwFlags,FALSE,0) ;

	LEAVE_ALL();
	
	return hr;
        
} // DP	_CreateGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreateGroupInGroup"

HRESULT DPAPI DP_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT			hr;
	LPDPLAYI_GROUP	pGroup = NULL;
	LPDPLAYI_DPLAY	this = NULL;


	ENTER_ALL();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// We must have a valid parent -- zero is not a valid parent.
	    pGroup = GroupFromID(this,idParentGroup);
	    if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == idParentGroup)) 
	    {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idParentGroup);
	        return DPERR_INVALIDGROUP;
	    }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// go get the group
	hr = InternalCreatePlayer(lpDP, pidGroupID,pName,NULL,pvData,
		dwDataSize,dwFlags,FALSE,idParentGroup) ;
	if (FAILED(hr))
	{
		DPF_ERRVAL("Could not create group - hr = 0x%08lx\n",hr);
		goto CLEANUP_EXIT;
	}

	// add group to group
	hr = InternalAddGroupToGroup(lpDP,idParentGroup,*pidGroupID,dwFlags,TRUE);	
	if (FAILED(hr))
	{
		DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
		DP_DestroyGroup(lpDP,*pidGroupID);
		*pidGroupID = 0;
	}

	// fall through

CLEANUP_EXIT:		
	
	LEAVE_ALL();
	
	return hr;
        
} // DP_CreateGroupInGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DeleteGroupFromGroup"

// delete lpGroupRemove from lpGroup
HRESULT RemoveGroupFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_GROUP lpGroupRemove)
{
    HRESULT hr=DP_OK;
	LPDPLAYI_SUBGROUP lpSubgroup,lpSubgroupPrev=NULL;
    BOOL bFoundIt=FALSE;

	lpSubgroup = lpGroup->pSubgroups;
	
    // find the groupnode corresponding to this player
    while ( (lpSubgroup) && (!bFoundIt))
    {
        if (lpSubgroup->pGroup == lpGroupRemove) 
        {
            bFoundIt = TRUE;
            // remove this groupnode from the group list
            if (!lpSubgroupPrev) 
            {
                // remove groupnode from beginning of list
            	lpGroup->pSubgroups = lpSubgroup->pNextSubgroup;
            }
            else
            {
                // remove groupnode from middle (or end) of list
            	lpSubgroupPrev->pNextSubgroup = lpSubgroup->pNextSubgroup;
            }
        } 
		else 
		{
			// check next node
	        lpSubgroupPrev = lpSubgroup;
	        lpSubgroup = lpSubgroup->pNextSubgroup;
		}        
    } // while

    if (bFoundIt) 
    {
		lpGroup->nSubgroups--;		// one less group in this group			

		// free up groupnode
    	DPMEM_FREE(lpSubgroup);

        lpGroupRemove->nGroups--;
        if (0 == lpGroupRemove->nGroups) 
        {
            // mark player as not in any group
            lpGroupRemove->dwFlags &= ~DPLAYI_PLAYER_PLAYERINGROUP;	
        }
    }
    else
    {
		// this can happen - e.g. group deleted, etc. off the wire
		DPF(4,"could not remove group from group - player id %d not found in group id %d\n",
				lpGroup->dwID,lpGroupRemove->dwID);
    	hr = E_FAIL; 
    }
    
    return hr;
} // RemoveGroupFromGroup

HRESULT InternalDeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,DPID idGroup,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_GROUP lpGroupFrom; 	
	
	DPF(5,"deleting group id %d from group id %d - propagate = %d",idGroup,idGroupFrom,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
        lpGroupFrom = GroupFromID(this,idGroupFrom);
        if ((!VALID_DPLAY_GROUP(lpGroupFrom)) || (DPID_ALLPLAYERS == idGroupFrom)) 
        {
			DPF(0, "invalid Group From id -- idGroupFrom = %lx", idGroupFrom);
            return DPERR_INVALIDGROUP;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First, if this is a parent/child relationship, then the fPropagate flag must be
	// set to FALSE because we never give out DeleteGroupInGroup messages for
	// real subgroups (non-shortcuts).  Bug #15264.
	if(lpGroup->dwIDParent == lpGroupFrom->dwID)
		fPropagate = FALSE;

    hr = RemoveGroupFromGroup(lpGroupFrom,lpGroup);
    if (FAILED(hr)) 
    {
		// this can happen if e.g. player not in group...
		return hr;
    }

	// If this is a lobby-owned object, we need to call the lobby.  UNLESS
	// the fPropagate flag is cleared.  If it is cleared,  it means the
	// lobby called us for a remote group and we dont want to call it back
	// in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DeleteGroupFromGroup(this->lpLobbyObject, idGroupFrom, idGroup);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed deleting group from group on the lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

    // don't bother telling people about the sysgroup or system players
    if (fPropagate)
    {
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEGROUPFROMGROUP, idGroup, 
			idGroupFrom);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
			hr = DP_OK;
		}
    }

    return hr;
	
} // InternalDeleteGroupFromGroup

HRESULT DPAPI DP_DeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,DPID idGroup) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP lpGroup; 
	

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
		// Make sure this is a shortcut and not a parent-child (bug #8396)
		if((lpGroup->dwIDParent == idGroupFrom))
		{
			LEAVE_ALL();
			DPF_ERR("Cannot delete a child group from it's parent, please use DestroyGroup");
			return DPERR_ACCESSDENIED;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	hr = InternalDeleteGroupFromGroup(lpDP, idGroupFrom,idGroup,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_DeleteGroupFromGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DeletePlayerFromGroup"

// delete lpPlayer from lpGroupnode. called by DP_DeletePlayerFromGroup
// returns DP_OK or E_FAIL if player isn't in group
HRESULT RemovePlayerFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_PLAYER lpPlayer)
{
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodePrev = NULL;
    BOOL bFoundIt=FALSE;
	LPDPLAYI_GROUPNODE * ppRootGroupnode;
	
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		lpGroupnode = lpGroup->pSysPlayerGroupnodes;
		ppRootGroupnode = &((LPDPLAYI_GROUPNODE)lpGroup->pSysPlayerGroupnodes);
	}
	else 
	{
		lpGroupnode = lpGroup->pGroupnodes;		
		ppRootGroupnode = &((LPDPLAYI_GROUPNODE)lpGroup->pGroupnodes);		
	}
	
    // find the groupnode corresponding to this player
    while ( (lpGroupnode) && (!bFoundIt))
    {
        if (lpGroupnode->pPlayer == lpPlayer) 
        {
            bFoundIt = TRUE;
            // remove this groupnode from the group list
            if (!lpGroupnodePrev) 
            {
                // remove groupnode from beginning of list
            	*ppRootGroupnode = lpGroupnode->pNextGroupnode;
            }
            else
            {
                // remove groupnode from middle (or end) of list
            	lpGroupnodePrev->pNextGroupnode = lpGroupnode->pNextGroupnode;
            }
        } // (lpGroupnode->pPlayer == lpPlayer) 
		else 
		{
			// check next node
	        lpGroupnodePrev=lpGroupnode;
	        lpGroupnode = lpGroupnode->pNextGroupnode;
		}        
    } // while

    if (bFoundIt) 
    {
		if (!(DPLAYI_PLAYER_SYSPLAYER & lpPlayer->dwFlags))
		{
			// only dec the player count on non-system players
			lpGroup->nPlayers--;		// one less player in this group			
		}


		// free up groupnode
    	DPMEM_FREE(lpGroupnode);

        lpPlayer->nGroups--;
        if (0==lpPlayer->nGroups) 
        {
            // mark player as not in any group
            lpPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERINGROUP;	
        }
    }
    else
    {
		DPF(4,"could not remove player from group - player id %d not found in group id %d\n",
				lpPlayer->dwID,lpGroup->dwID);
    	hr = DPERR_INVALIDPLAYER; 
    }
    
    return hr;
} // RemovePlayerFromGroup

HRESULT InternalDeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
    LPDPLAYI_GROUP lpGroup; 
	DPSP_REMOVEPLAYERFROMGROUPDATA data;
	LPDPLAYI_GROUPNODE pSysGroupnode;
	
	DPF(5,"deleting player id %d from group id %d - propagate = %d",idPlayer,idGroup,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);

        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }

        lpPlayer = PlayerFromID(this,idPlayer);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

//	a-josbor: tell the SP that we have removed this player from the group
	// only do this if we have an SP that is DX6 or later!
	if ((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
	{
		if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
			&& (this->pcbSPCallbacks->RemovePlayerFromGroup) )
		{
			data.idPlayer = lpPlayer->dwID;
			data.idGroup = lpGroup->dwID;        
			data.lpISP = this->pISP;

		    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&data);
		}
		else 
		{
			// no callback - no biggie
		}
		if (FAILED(hr)) 
		{
			DPF(0,"SP - remove player from group failed - hr = 0x%08lx\n",hr);
		}
	}
	
//	now do the actual removal
    hr = RemovePlayerFromGroup(lpGroup,lpPlayer);
    if (FAILED(hr)) 
    {
		// this can happen if e.g. player not in group...
		return hr;
    }

    // don't bother telling people about the sysgroup or system players
    if (!(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP) && !(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
		&& fPropagate)
    {
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYERFROMGROUP, idPlayer, 
			idGroup);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
			hr = DP_OK;
		}
    }

	// update the system player groupnode.
 	pSysGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpPlayer->dwIDSysPlayer);
	if (pSysGroupnode)
	{
		pSysGroupnode->nPlayers--;
		// when this goes to 0, remove the system player from the group
	    // notify sp if we need to (notify both pre and post DX6 SPs)
		if (pSysGroupnode->nPlayers == 0 && !(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
		    if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
				&& (this->pcbSPCallbacks->RemovePlayerFromGroup) )
		    {
				data.idPlayer = pSysGroupnode->pPlayer->dwID;
				data.idGroup = lpGroup->dwID;        
				data.lpISP = this->pISP;

			    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&data);
		    }
			else 
			{
				// no callback - no biggie
			}
		    if (FAILED(hr)) 
		    {
				DPF(0,"SP - remove player from group failed - hr = 0x%08lx\n",hr);
		    }

		    hr = RemovePlayerFromGroup(lpGroup,pSysGroupnode->pPlayer);
		    if (FAILED(hr)) 
		    {
				ASSERT(FALSE);
		    }

		}
	}

	// If this is a lobby-owned object, we need to call the lobby.  UNLESS
	// the fPropagate flag is cleared.  If it is cleared,  it means the
	// lobby called us for a remote player and we dont want to call it back
	// in that case.  OR if the group is the system group, we don't want to
	// call the lobby
	if((IS_LOBBY_OWNED(this)) && (fPropagate) && (idGroup != 0))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DeletePlayerFromGroup(this->lpLobbyObject, idGroup, idPlayer);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed deleting player from group on the lobby, hr = 0x%08x", hr);
			
			// If this failed, we need to add the player back into the group
			InternalAddPlayerToGroup(lpDP, idGroup, idPlayer, FALSE);
		}
	}

    return DP_OK;
	
} // InternalDeletePlayerFromGroup

HRESULT DPAPI DP_DeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer) 
{
	HRESULT hr;
	
	ENTER_ALL();

	if (DPID_ALLPLAYERS == idGroup)
	{
		DPF_ERRVAL("invalid group id = %d", idGroup);
		LEAVE_ALL();
		return DPERR_INVALIDGROUP;
	}

	hr = InternalDeletePlayerFromGroup(lpDP, idGroup,idPlayer,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_DeletePlayerFromGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DestroyPlayer"

/*
 ** RemovePlayerFromGroups
 *
 *  CALLED BY: DP_DestroyPlayer
 *
 *  PARAMETERS:
 *	lpPlayer - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: calls InternalDeletePlayerFromGroup on all groups until
 *		player is not in anymore groups
 *
 *  RETURNS: DP_OK
 *
 */

HRESULT RemovePlayerFromGroups(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,BOOL fPropagate) 
{
    LPDPLAYI_GROUP lpGroup;
    LPDPLAYI_GROUPNODE_V lpNodes;
    HRESULT hr;

    // we do this by walking the group list, and calling delete from group on all groups
    if (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)
    {
        lpGroup=this->pGroups;

    	while (lpGroup && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP) )
    	{
	 		if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				lpNodes = lpGroup->pSysPlayerGroupnodes;
			}
			else
			{
				lpNodes = lpGroup->pGroupnodes;
			}

	   		if (FindPlayerInGroupList(lpNodes,lpPlayer->dwID))
    		{
	        	// this fn. will attempt to remove player from group.
	            // (if players not in group, no big deal).
	            // when player is removed from all groups, DP_DeletePlayerFromGroup
	            // resets DPLAYI_FLAGS_PLAYERINGROUP
	        	hr = InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->pInterfaces,
						lpGroup->dwID,lpPlayer->dwID,fPropagate);
				// BUGBUG:  If the remove fails, we could get hosed in an infinite loop
				//		so we just move on to the next group
				if (FAILED(hr))
				{
					// this can fail because, e.g., the player is not in this
					// particular group...
					DPF(4,"DP_DeletePlayerFromGroup failed - hr = 0x%08lx\n",hr);
					// keep trying...

					lpGroup = lpGroup->pNextGroup;
				}
				else
				{
					lpGroup = this->pGroups;
				}
			}
			else
			{
	        	lpGroup=lpGroup->pNextGroup;
	        }
	    }	
    }
    return DP_OK;
        
} // RemovePlayerFromGroups

/*
 ** RemovePlayerFromPlayerList
 *
 *  CALLED BY: DP_DestroyPlayer
 *
 *  PARAMETERS:
 *	lpPlayer - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: takes player out of dplay objects list of players
 *
 *  RETURNS: DP_OK unless player is not in list
 *
 */

HRESULT RemovePlayerFromPlayerList(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer) 
{
    LPDPLAYI_PLAYER pRefPlayer,pPrevPlayer;
    BOOL bFoundIt=FALSE;
    
    pRefPlayer=this->pPlayers;
    pPrevPlayer=NULL;
    
    
    while ( (pRefPlayer) && (!bFoundIt))
    {
        if (pRefPlayer == lpPlayer) 
        {
            bFoundIt = TRUE;
            if (!pPrevPlayer)
            {
                // remove from front of list
            	this->pPlayers=pRefPlayer->pNextPlayer;
            }
            else
            {
            	// remove this player from the middle (or end) of list
  	        	pPrevPlayer->pNextPlayer = pRefPlayer->pNextPlayer;
            }
        }

        pPrevPlayer=pRefPlayer;
        pRefPlayer = pRefPlayer->pNextPlayer;
    }

    if (!bFoundIt) 
    {
    	ASSERT(FALSE);
    	DEBUG_BREAK();
    	return E_UNEXPECTED;	
    }
    return DP_OK;
}	// RemovePlayerFromPlayerList


void RemoveOwnerFromGroup(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP lpGroup,
		LPDPLAYI_PLAYER lpPlayer, BOOL fPropagate)
{
	LPDPLAYI_GROUPOWNER		lpNode, lpPrev = NULL;
	HRESULT					hr;

	ASSERT(lpGroup);
	ASSERT(lpPlayer);

	lpNode = lpPlayer->pOwnerGroupList;

	// Walk the list of groups in the player's list
	while(lpNode)
	{
		if(lpNode->pGroup == lpGroup)
		{
			// Remove the node from the list
			if(lpPrev)
				lpPrev->pNext = lpNode->pNext;
			else
				lpPlayer->pOwnerGroupList = lpNode->pNext;

			// Now free the node
			DPMEM_FREE(lpNode);
			lpNode = NULL;
		}
		else
		{
			// Move to the next node
			lpPrev = lpNode;
			lpNode = lpNode->pNext;
		}
	}

	// If the player is local, and the group is local, we want to set the
	// owner of the group to be the server player.  If the player is remote,
	// or if the gorup is remote, we don't
	// want to touch it, because they may not really be going away, they
	// may only be getting purged from the nametable due to our
	// nametable partitioning algorithm.
	// Also, make sure the propagate flag is set, otherwise we don't
	// need to tell the server or the other players at all (this happens
	// if the group is being destroyed)
	if(fPropagate && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		(lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Change the owner of the group to the server player
		hr = DPL_SetGroupOwner((LPDIRECTPLAY)this->pInterfaces, lpGroup->dwID,
				DPID_SERVERPLAYER);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to set group owner to DPID_SERVERPLAYER, hr = 0x%08x", hr);
		}

		// Take the lock back
		ENTER_DPLAY();
	}

} // RemoveOwnerFromGroup

// Completes all pending sends from a player right away.
VOID CompletePendingSends(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	BILINK *pBilink;
	PSENDPARMS psp, pspcopy;

	pBilink=pPlayer->PendingList.next;
	while(pBilink!=&pPlayer->PendingList){
		psp=CONTAINING_RECORD(pBilink, SENDPARMS, PendingList);
		pBilink=pBilink->next;
		
		Delete(&psp->PendingList);
		InitBilink(&psp->PendingList);
		pspcopy=GetSendParms(); // allocates send parm, sets refcount to 1.
		if(pspcopy){
			DPF(5,"Queueing completion of send psp %x not really yet completed, using copy %x\n",psp, pspcopy);
			memcpy(&pspcopy->PendingList, &psp->PendingList, sizeof(SENDPARMS)-offsetof(SENDPARMS,PendingList));
			InitBilink(&pspcopy->PendingList);
			pspcopy->hr=DPERR_INVALIDPLAYER;
			pspcopy->dwSendCompletionTime=timeGetTime();
			QueueSendCompletion(this, pspcopy);
		}
	}
}

/*
 ** InternalDestroyPlayer
 *
 *  CALLED BY:	DP_DestroyPlayer,KillPlayer (from ping.c)
 *
 *  PARAMETERS: 
 *				lpPlayer - player we want killed
 *				fPropagate - if we're called from KillPlayer (ping.c) and we want
 *					to remove the player from the global nametable, this is TRUE
 *				fLookForNewNS - if this is the Nameserver, whether or not to look for another
 *  DESCRIPTION:
 *				kills the player
 *
 *  RETURNS:
 *				pretty much DP_OK
 *
 */
HRESULT InternalDestroyPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,BOOL fPropagate,BOOL fLookForNewNS) 
{
    HRESULT hr = DP_OK;
    DPSP_DELETEPLAYERDATA dd;
	BOOL fNameServer = lpPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR;
	BOOL fLocal = lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL;
	DPID dwPlayerID;

	ASSERT(lpPlayer != NULL);
	
	#ifdef DEBUG
	if(lpPlayer->nPendingSends){
		DPF(0,"WARNING:Destroying player with %d pending sends...\n",lpPlayer->nPendingSends);
	}
	#endif
	
	DPF(5,"destroying player - id = %d\n",lpPlayer->dwID);
	DPF(5,"local = %d, nameserver = %d", fLocal, fNameServer);

	if (lpPlayer == this->pSysPlayer)
	{
		// it's only leagal to delete the Sys player if we're closing
		ASSERT(this->dwFlags & DPLAYI_DPLAY_CLOSED);
		if (!(this->dwFlags & DPLAYI_DPLAY_CLOSED))
			return DPERR_GENERIC;
	}
	
	dwPlayerID=lpPlayer->dwID;

	DPF(8,"In InternalDestroyPlayer, calling CompletePendingSends...\n");
	CompletePendingSends(this,lpPlayer);

	// If this is a lobby object, call the lobby code instead of calling
	// a dplay SP.  The CALLSP code which follows will not get executed
	// since the callback will not exist for a lobby-owned object.  However,
	// if the fPropagate flag is cleared, it means the lobby called us
	// for a remote player, so don't call it back.  Don't call the lobby
	// if it is a system player either.
	if((IS_LOBBY_OWNED(this)) && (fPropagate) &&
		(!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DestroyPlayer(this->lpLobbyObject, lpPlayer->dwID);
		
		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to destroy player, hr = 0x%08x", hr);
			return hr;
		}
		else
		{
			// Clear the propagate flag so that dplay doesn't call back into
			// the lobby inside RemovePlayerFromGroups (and InternalDelete-
			// PlayerFromGroup), because it will fail since the lobby has
			// already deleted the player.
			fPropagate = FALSE;
		}
	}

	if(lpPlayer->dwFlags & DPLAYI_PLAYER_BEING_DESTROYED){
		return DPERR_INVALIDPLAYER;
	} else {
		lpPlayer->dwFlags |= DPLAYI_PLAYER_BEING_DESTROYED;
	}	

	// remove player from any groups
	hr = RemovePlayerFromGroups(this,lpPlayer,fPropagate);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

	// call the sp
	if (this->pcbSPCallbacks->DeletePlayer || this->pProtocol)
	{
		// call sp
		dd.idPlayer = lpPlayer->dwID;
		dd.dwFlags = lpPlayer->dwFlags; 
		dd.lpISP = this->pISP;

		ASSERT(gnDPCSCount==1);

		if(this->pProtocol){
			hr = ProtocolDeletePlayer(&dd); 
		} 
		
		if(this->pcbSPCallbacks->DeletePlayer){
	    	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
			if (FAILED(hr)) 
			{
				DPF_ERR(" SP could not delete player!!"); 
			}
	    }	

	}
	else 
	{
		// sp doesn't need to implement this one...
	}
	
    // remove player from player list
    hr = RemovePlayerFromPlayerList(this,lpPlayer);
	this->nPlayers--;
	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

	if (fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER, lpPlayer->dwID, 
			0);		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		// could have lost player pointer in SendPlayerManagementMessage, re-establish
		lpPlayer=PlayerFromID(this,dwPlayerID);
		if(!lpPlayer){
			DPF(0,"Player x%x was blown away during propogation of Delete\n",dwPlayerID);
			goto EXIT;
		}
	}

	
	// app server?
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
	{
		DPF(4,"destroying app server");
		this->pServerPlayer = NULL;
	}

	// name server?
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
	{
		DPF(4,"destroying name server");
		this->pNameServer = NULL;
	}
	
	// Owner of any groups?  Then remove ourselves as the owner.
	while(lpPlayer->pOwnerGroupList)
	{
		RemoveOwnerFromGroup(this, lpPlayer->pOwnerGroupList->pGroup,
			lpPlayer, TRUE);

		lpPlayer=PlayerFromID(this,dwPlayerID);
		if(!lpPlayer){
			DPF(0,"Player x%x was blown away during RemoveOwnerFromGroup\n", dwPlayerID);
			goto EXIT;
		}
	}

    FreeNameTableEntry(this,lpPlayer->dwID);

    // update sessiondesc
    if (!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) this->lpsdDesc->dwCurrentPlayers--;

    // deallocate strings + player
    DeallocPlayer(lpPlayer);

	// if we're pushing this delete across the wire, and its the 
	// nameserver we deleted, see if we're the new name server	
	if ( (fNameServer || 
		 (this->dwMinVersion >= DPSP_MSG_DX61AVERSION && this->dwFlags & DPLAYI_DPLAY_NONAMESERVER)
		 ) && !fLocal &&  fLookForNewNS)
	{
		// We shouldn't ever get in here if we're a lobby-owned object
		ASSERT(!IS_LOBBY_OWNED(this));

		hr = HandleDeadNameServer(this);
		if (FAILED(hr))
		{
			DPF(0,"HandleDeadNameServer returned error: 0x%x\n", hr);
			ASSERT(FALSE);
		}
	}
	
    // todo - cruise any messages (this will apply to lobby objects as well)
EXIT:
    return DP_OK;
	
} // InternalDestroyPlayer

HRESULT DPAPI DP_DestroyPlayer(LPDIRECTPLAY lpDP, DPID idPlayer) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	BOOL fLocal;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
        lpPlayer = PlayerFromID(this,idPlayer);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
    
	fLocal = lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL;
	
	// Because of bug #12901, we want the host to be able to destroy all
	// players (even remote players) so they can implement their
	// own keep-alives.
	if ((!fLocal) && (!IAM_NAMESERVER(this)))
	{
		LEAVE_ALL();
		DPF_ERR("attempt to destroy non-local player.  not gonna happen.");
		return DPERR_ACCESSDENIED;
	}
		
	hr = InternalDestroyPlayer(this,lpPlayer,TRUE,TRUE);

	LEAVE_ALL();

    return hr;
       
}//DP_DestroyPlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DestroyGroup"

HRESULT RemoveGroupFromGroupList(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup) 
{
	LPDPLAYI_GROUP lpGroupPrev,lpGroupSearch;
	BOOL bFoundIt=FALSE;

	// remove the group from the list
	lpGroupSearch = this->pGroups;
	lpGroupPrev=NULL;
	
	while ((lpGroupSearch)&&(!bFoundIt))
	{
		if (lpGroupSearch->dwID == lpGroup->dwID) bFoundIt=TRUE;
		else 
		{
			lpGroupPrev=lpGroupSearch;
			lpGroupSearch=lpGroupSearch->pNextGroup;
		}
	} 

	if (!bFoundIt) 
	{
		ASSERT(FALSE);
		DPF_ERR("bad group!");
        return DPERR_INVALIDPARAMS;
	}

	ASSERT(lpGroupSearch->pGroupnodes == NULL);
	if (lpGroupPrev) lpGroupPrev->pNextGroup = lpGroupSearch->pNextGroup;
    else this->pGroups = lpGroupSearch->pNextGroup;

	// success
	return DP_OK;
	
} // RemoveGroupFromGroupList

/*
 ** RemoveGroupFromAllGroups
 *
 *  CALLED BY: DP_DestroyGroup
 *
 *  PARAMETERS:
 *	lpGroup - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: calls InternalDeleteGroupFromGroup on all groups until
 *		player is not in anymore groups
 *
 *  RETURNS: DP_OK
 *
 */

HRESULT RemoveGroupFromAllGroups(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup,BOOL fPropagate) 
{
    LPDPLAYI_GROUP lpGroupFrom;
    HRESULT hr;

    // we do this by walking the group list, and calling delete from group on all groups
    if (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)
    {
        lpGroupFrom=this->pGroups;
        
    	while (lpGroupFrom && (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    	{
			// Don't try to remove any groups from the system group
			// because there will never be any in it and we're just
			// wasting our time
			if(lpGroupFrom->dwID != DPID_ALLPLAYERS)
			{
				// this fn. will attempt to remove player from group.
				// (if players not in group, no big deal).
				// when player is removed from all groups, DP_DeleteGroupFromGroup
				// resets DPLAYI_FLAGS_PLAYERINGROUP
            	hr = InternalDeleteGroupFromGroup((LPDIRECTPLAY)this->pInterfaces,
						lpGroupFrom->dwID,lpGroup->dwID,fPropagate);
				if (FAILED(hr))
				{
					// this can fail because, e.g., the player is not in this
					// particular group...
					DPF(4,"DP_DeleteGroupFromGroup failed - hr = 0x%08lx\n",hr);
					// keep trying...
				}
			}
            lpGroupFrom=lpGroupFrom->pNextGroup;		
    	}	
    }
    return DP_OK;
        
} // RemoveGroupFromAllGroups

//
// called by DP_DestroyGroup and SP_HandlePlayerMgmt and DP_Close
// if called by DP_DestroyGroup, fPropagate is TRUE, and we should remove group
// from global nametable.  Otherwise, we just remove from our nametable
HRESULT InternalDestroyGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup,BOOL fPropagate)
{
	HRESULT hr;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodeNext; 
	DPSP_DELETEGROUPDATA dd;
	LPDPLAYI_SUBGROUP pSubgroup,pSubgroupNext;
	LPDPLAYI_PLAYER pOwner = NULL;
	 	
	// If this is a lobby object, call the lobby.  Unless the fPropagate flag
	// is cleared.  If it is cleared, it means the lobby called us for a
	// remote player and we don't want to call it back in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DestroyGroup(this->lpLobbyObject, lpGroup->dwID);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to destroy group, hr = 0x%08x", hr);
			return hr;
		}
		else
		{
			// Clear the propagate flag so that dplay doesn't call back into
			// the lobby inside RemoveGroupsFromGroups (and InternalDelete-
			// GroupFromGroup), because it will fail since the lobby has
			// already deleted the group.  Ditto for all the following
			// DeleteGroup.... and DeletePlayer calls.
			fPropagate = FALSE;
		}
	}

    // remove group from any groups
    hr = RemoveGroupFromAllGroups(this,lpGroup,fPropagate);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

    // remove all players from group
    // just remove the 1st player in the list until all players are gone
    lpGroupnode = lpGroup->pGroupnodes;
    while (lpGroupnode)
    {
		// save next group node b4 we delete current one...
		// If this is a lobby object, we don't need to propagate the
		// DeletePlayerFromGroup message because the server already
		// knows about it.  Besides, it will fail out since the lobby
		// code has already removed the GroupID from the map table.
		lpGroupnodeNext = lpGroupnode->pNextGroupnode;
        hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,lpGroupnode->pPlayer->dwID,
			(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}
 		lpGroupnode =  lpGroupnodeNext;
 	}

    // remove all system players from group
    // just remove the 1st player in the list until all players are gone
    lpGroupnode = lpGroup->pSysPlayerGroupnodes;
	// only system group can have system players in a group w/ no corresponding app player
	if (lpGroupnode) ASSERT(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP);
    while (lpGroupnode)
    {
		// save next group node b4 we delete current one...
		// we never propagate this since it's sysplayer stuff...
		lpGroupnodeNext = lpGroupnode->pNextGroupnode;
        hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,lpGroupnode->pPlayer->dwID,
			FALSE);
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}
 		lpGroupnode =  lpGroupnodeNext;
 	}
	
	// remove all groups from group
	// if subgroup is not a shortcut, destroy subgroup too
	pSubgroup = lpGroup->pSubgroups;
	while (pSubgroup)
	{
		pSubgroupNext = pSubgroup->pNextSubgroup;

		if (! (pSubgroup->dwFlags & DPGROUP_SHORTCUT) )
		{
			LPDPLAYI_GROUP pGroupKill = pSubgroup->pGroup; // pSubgroup	is gonna get
															// nuked b4 we're done with it
			
			// it's not a shortcut, it's contained.  remove it, then destroy it.
			hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,pSubgroup->pGroup->dwID,FALSE);
			
			hr = InternalDestroyGroup(this,pGroupKill,
				(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
			
			// we may have effected the list - start over to be safe
			pSubgroupNext = lpGroup->pSubgroups;
		}
		else 
		{
			// it's  a shortcut, delete it
			hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
				lpGroup->dwID,pSubgroup->pGroup->dwID,
				(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
		}
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}

		pSubgroup = pSubgroupNext;
	}
	
	if (fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEGROUP, 0, lpGroup->dwID);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
		}
	}

	if (!(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && (this->pcbSPCallbacks->DeleteGroup) )
	{
		// call sp
		dd.idGroup = lpGroup->dwID;
		dd.dwFlags = lpGroup->dwFlags;
		dd.lpISP = this->pISP;

    	hr = CALLSP(this->pcbSPCallbacks->DeleteGroup,&dd);
		if (FAILED(hr)) 
		{
			DPF_ERR("sp - could not delete group!!"); 
		}
	}
	else 
	{
		// sp doesn't need to implement this one...
	}

	// Are we a lobby session and is there an owner.  If so, remove the owner
	// node from the player's list.
	if(IS_LOBBY_OWNED(this) && (lpGroup->dwOwnerID != DPID_SERVERPLAYER))
	{
		pOwner = PlayerFromID(this, lpGroup->dwOwnerID);
		if(pOwner)
			RemoveOwnerFromGroup(this, lpGroup, pOwner, FALSE);
	}

    hr = FreeNameTableEntry(this,lpGroup->dwID);
	if (FAILED(hr))
	{
    	return hr;
	}
	
	hr = RemoveGroupFromGroupList(this,lpGroup);
	if (FAILED(hr))
	{
    	return hr;
	}

	DeallocGroup(lpGroup);

	this->nGroups--;
	
	return DP_OK;
	
} // InternalDestroyGroup

HRESULT DPAPI DP_DestroyGroup(LPDIRECTPLAY lpDP, DPID idGroup) 
{

    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP lpGroup;
	BOOL fLocal;

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
		
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }

	fLocal = (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;
	DPF(3,"destroying group - fLocal = %d\n",fLocal);
	
	hr = InternalDestroyGroup( this, lpGroup, TRUE);

	LEAVE_ALL();
    return hr;
        
}//DP_DestroyGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnableNewPlayers"

HRESULT DPAPI DP_EnableNewPlayers(LPDIRECTPLAY lpDP, BOOL bEnable) 
{

    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }
	
	if (!this->lpsdDesc) 
	{
		LEAVE_DPLAY();
		DPF_ERR("must open a session before enabling new players");
		return DPERR_NOSESSIONS;
	}

    // set dp_bNewPlayersEnabled
    if (bEnable) 
    {
		this->lpsdDesc->dwFlags &= ~DPSESSION_NEWPLAYERSDISABLED;
    }
    else
    {
		this->lpsdDesc->dwFlags |= DPSESSION_NEWPLAYERSDISABLED;
    } 
	
	
    LEAVE_DPLAY();
    return hr;

}//DP_EnableNewPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetCaps"

void SetDefaultCaps(LPDPCAPS lpDPCaps)
{

	// just to be safe (belt + suspenders!)
	memset(lpDPCaps,0,sizeof(DPCAPS));

	lpDPCaps->dwSize = sizeof(DPCAPS);
		
	// we show the 0 values here, just to be explicit
	lpDPCaps->dwMaxBufferSize 		= DPLAY_MAX_BUFFER_SIZE;
	lpDPCaps->dwMaxQueueSize		= 0;    
	lpDPCaps->dwMaxPlayers			= DPLAY_MAX_PLAYERS;			
	lpDPCaps->dwHundredBaud			= 0;     
	lpDPCaps->dwLatency				= 0;
	lpDPCaps->dwMaxLocalPlayers		= DPLAY_MAX_PLAYERS;	
	lpDPCaps->dwFlags				= 0;
	lpDPCaps->dwHeaderLength		= 0;
	lpDPCaps->dwTimeout				= 0;

	return;

} // SetDefaultCaps

// called by InternalGetCaps.  set dpplayercaps
HRESULT GetPlayerCaps(LPDPCAPS lpCaps,LPDPLAYI_PLAYER lpPlayer)
{
	ASSERT(lpPlayer);
	if (!lpPlayer) return E_FAIL; // ACK!
	
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
		lpCaps->dwFlags |= DPPLAYERCAPS_LOCAL;		
	} 

	
#ifdef DPLAY_VOICE_SUPPORT
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_HASVOICE)
	{
		lpCaps->dwFlags |= DPPLAYERCAPS_VOICE;	
	} 
#endif

	if(!lpCaps->dwLatency){
		// neither SP or Protocol had a guess at the latency, so use our best guess. 
		lpCaps->dwLatency=lpPlayer->dwLatencyLastPing;
	}

	return DP_OK;		
} // GetPlayerCaps

// called by getcaps,getplayercaps
// assumes dplay lock taken!
HRESULT InternalGetCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,BOOL fPlayer,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	DPSP_GETCAPSDATA gcd;
	LPDPLAYI_PLAYER lpPlayer;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!VALID_DPLAY_CAPS(lpDPCaps))
		{
			DPF_ERR("invalid caps struct");
	        return DPERR_INVALIDPARAMS;
		}
		if (dwFlags & ~DPGETCAPS_GUARANTEED)
		{
			DPF_ERR("invalid caps flags");
			return DPERR_INVALIDPARAMS;
		}
        if (fPlayer)
        {
	        lpPlayer = PlayerFromID(this,idPlayer);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERR("invalid player");
	            return DPERR_INVALIDPLAYER;
	        }	
        } 
		else 
		{
			lpPlayer = NULL;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	SetDefaultCaps(lpDPCaps);

	// If this is lobby-owned, call the lobby provider here and let it fill
	// in the caps structure
	if(IS_LOBBY_OWNED(this))
	{
		// Drop the dplay lock
		LEAVE_DPLAY();
		
		// Call the appropriate GetCaps or GetPlayerCaps in the lobby
		if(!lpPlayer)
		{
			hr = PRV_GetCaps(this->lpLobbyObject, dwFlags, lpDPCaps);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed calling GetCaps in the lobby, hr = 0x%08x", hr);
			}
		}
		else
		{
			hr = PRV_GetPlayerCaps(this->lpLobbyObject, dwFlags, idPlayer, lpDPCaps);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed calling GetPlayerCaps in the lobby, hr = 0x%08x", hr);
			}
		}

		// Take the lock back
		ENTER_DPLAY();

		// If we failed, bail
		if(FAILED(hr))
			return hr;
	}


    // get caps from sp
    if (this->pcbSPCallbacks->GetCaps) 
    {
		// call sp
		gcd.lpCaps = lpDPCaps;
		gcd.dwFlags = dwFlags;
		if (lpPlayer) gcd.idPlayer = lpPlayer->dwID;
		else gcd.idPlayer = 0;
		gcd.lpISP = this->pISP;

		if(this->pProtocol){
			hr = ProtocolGetCaps(&gcd); // calls sp and patches returns
		} else {
		    hr = CALLSP(this->pcbSPCallbacks->GetCaps,&gcd);	    	
	    }
  	    if (FAILED(hr)) 
	    {
			DPF(0,"sp get caps failed - hr = 0x%08lx\n",hr);
	    }
  	}
	else 
	{
		// no callback is ok
	}
	
	// if the buffer size is zero, set it to the max (#12634)
	if(lpDPCaps->dwMaxBufferSize == 0)
		lpDPCaps->dwMaxBufferSize = DPLAY_MAX_BUFFER_SIZE;

	// fix up max buffer size (since we add header) raid # 2324
	lpDPCaps->dwMaxBufferSize -= sizeof(MSG_PLAYERMESSAGE);

	// for dx3, we don't support guaranteed unless sp does
	if (lpDPCaps->dwFlags & DPCAPS_GUARANTEEDOPTIMIZED)	
	{
		lpDPCaps->dwFlags |= DPCAPS_GUARANTEEDSUPPORTED;
	} else {
		this->dwFlags |= DPLAYI_DPLAY_SPUNRELIABLE;
	}

	// are we the host? (nameserver)
	if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)) 
	{
		lpDPCaps->dwFlags |= DPCAPS_ISHOST;
	}
	else 
	{
		lpDPCaps->dwFlags &= ~DPCAPS_ISHOST;
	} 

    // setup security caps
    if (this->dwFlags & DPLAYI_DPLAY_SECURITY)
    {
        // digital signing is supported
        lpDPCaps->dwFlags |= DPCAPS_SIGNINGSUPPORTED;

        // do we have encryption support ?
        if (this->dwFlags & DPLAYI_DPLAY_ENCRYPTION)
        {
            lpDPCaps->dwFlags |= DPCAPS_ENCRYPTIONSUPPORTED;
        }
        else
        {
            lpDPCaps->dwFlags &= ~DPCAPS_ENCRYPTIONSUPPORTED;
        }

    }
    
    if (lpDPCaps->dwFlags & DPCAPS_GROUPOPTIMIZED)
    {
    	// sp wants to optimize groups
    	if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||
    		(this->lpsdDesc && (this->lpsdDesc->dwFlags & (DPSESSION_CLIENTSERVER | DPSESSION_SECURESERVER))))
		{
			// if these conditions are true dplay will take over the owndership of groups
			// and won't allow sp to optimize groups
			lpDPCaps->dwFlags &= ~(DPCAPS_GROUPOPTIMIZED);
		}
	}

	this->dwSPFlags = lpDPCaps->dwFlags;	// remember the SP caps to validate send params.
	
	// player caps - note, we just stuff 'em on top of dpcaps for compatibility
	if (fPlayer) hr = GetPlayerCaps(lpDPCaps,lpPlayer);

	return hr;

} // InternalGetCaps

HRESULT DPAPI DP_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps,DWORD dwFlags) 
{
	HRESULT hr;

    ENTER_DPLAY();
	
	hr = InternalGetCaps(lpDP,0, lpDPCaps,FALSE,dwFlags);
	 
    LEAVE_DPLAY();
    return hr;
        
}//DP_GetCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetMessageCount"

HRESULT DPAPI DP_GetMessageCount(LPDIRECTPLAY lpDP, DPID idPlayer, LPDWORD pdwCount) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPMESSAGENODE pmsg;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		if (idPlayer)
		{
			LPDPLAYI_PLAYER pPlayer;

			pPlayer = PlayerFromID(this,idPlayer);
			if (!VALID_DPLAY_PLAYER(pPlayer)) 
			{
				DPF_ERRVAL("invalid player id = %d", idPlayer);
				LEAVE_DPLAY();
				return DPERR_INVALIDPLAYER;
			}
		}

		if (!VALID_DWORD_PTR(pdwCount))
		{
	        DPF_ERR( "bad count pointer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}
		*pdwCount = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	if (!idPlayer)
	{
		*pdwCount = (DWORD)this->nMessages;		
	} 
	else 
	{
		pmsg = this->pMessageList; //  1st message
		while (pmsg)
		{		
			if (pmsg->idTo == idPlayer) (*pdwCount)++;
			pmsg = pmsg->pNextMessage;
		}
	}

    LEAVE_DPLAY();
    return hr;
        
}//DP_GetMessageCount

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerAddress"

HRESULT DPAPI DP_GetPlayerAddress(LPDIRECTPLAY lpDP,DPID idPlayer, LPVOID pvAddress,
	LPDWORD pdwAddressSize) 
{
	
    LPDPLAYI_DPLAY this;
    LPDPLAYI_PLAYER lpPlayer = NULL;
    HRESULT hr = DP_OK;
	DPSP_GETADDRESSDATA dad;
	DPSP_GETADDRESSCHOICESDATA dac;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		// check player address if there is one
		if (idPlayer != DPID_ALLPLAYERS)
		{
			lpPlayer = PlayerFromID(this,idPlayer);
			if (!VALID_DPLAY_PLAYER(lpPlayer)) 
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("invalid player id = %d", idPlayer);
				return DPERR_INVALIDPLAYER;
			}
		}

		if (!VALID_DWORD_PTR(pdwAddressSize))
		{
	        DPF_ERR( "bad size pointer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}

		if (!pvAddress) *pdwAddressSize = 0;

		if (*pdwAddressSize && 
			!VALID_STRING_PTR(pvAddress,*pdwAddressSize))
		{
	        DPF_ERR( "bad addresss buffer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}

		if(IS_LOBBY_OWNED(this))
		{
			LEAVE_DPLAY();
			DPF_ERR("GetPlayerAddress not supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	// if they ask for the player address for all players, then we give
	// them the address choices available for this service provider
	if (DPID_ALLPLAYERS == idPlayer)
	{
		if (this->pcbSPCallbacks->GetAddressChoices)
		{
			dac.lpAddress = pvAddress;
			dac.lpdwAddressSize = pdwAddressSize;
			dac.lpISP = this->pISP;

			hr = CALLSP(this->pcbSPCallbacks->GetAddressChoices,&dac);	    			
		}
		else 
		{
			hr = E_NOTIMPL;
		}
	}

	// otherwise just get address for the given player
	else
	{
		if (this->pcbSPCallbacks->GetAddress)
		{
			dad.idPlayer = lpPlayer->dwIDSysPlayer;
			dad.lpAddress = pvAddress;
			dad.lpdwAddressSize = pdwAddressSize;
			dad.dwFlags = lpPlayer->dwFlags;
			dad.lpISP = this->pISP;

			hr = CALLSP(this->pcbSPCallbacks->GetAddress,&dad);	    			
		}
		else 
		{
			hr = E_NOTIMPL;
		}
	}
 
	LEAVE_DPLAY();

	return hr;
		
} // DP_GetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerCaps"

HRESULT DPAPI DP_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,DWORD dwFlags) 
{
	HRESULT hr;

    ENTER_DPLAY();
	
	hr = InternalGetCaps(lpDP,idPlayer, lpDPCaps,TRUE,dwFlags);
	 
    LEAVE_DPLAY();
    return hr;
        
}//DP_GetPlayerCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerData/GetGroupData"

// called by internalcreateplayer,internalsetname,internalsetdata
HRESULT CheckGetDataFlags(DWORD dwFlags)
{
	// check flags
	if ( dwFlags & ~(DPGET_REMOTE | DPGET_LOCAL) )
		
	{
		DPF_ERR("bad flags");
		return DPERR_INVALIDPARAMS;	
	}

	return DP_OK;

} // CheckSetDataFlags

// take a pointer to a buffer, stick a player(or group) data in it, slap the strings
// on the end.  
HRESULT  InternalGetData(LPDIRECTPLAY lpDP,DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;
	LPVOID pvSource; // local or remote data
	DWORD dwSourceSize;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwDataSize))
		{
			DPF_ERR("invalid pdwDataSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!pvData) *pdwDataSize = 0;
		if (*pdwDataSize && !VALID_STRING_PTR(pvData,*pdwDataSize))
		{
			DPF_ERR("invalid buffer");
			return DPERR_INVALIDPARAMS;	
		}
		// check flags
		hr = CheckGetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			DPF_ERR("invalid get data flags");
			return hr;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// figure out which source they want
	if (dwFlags & DPGET_LOCAL)
	{
		pvSource = pPlayer->pvPlayerLocalData;
		dwSourceSize = pPlayer->dwPlayerLocalDataSize;
	}
	else 
	{
		// If this is a lobby-owned object, we need to go get the data
		// from the lobby server.  We will never store it locally (sorry
		// for the pun).
		if(!IS_LOBBY_OWNED(this))
		{
			pvSource = pPlayer->pvPlayerData;
			dwSourceSize = pPlayer->dwPlayerDataSize;
		}
		else
		{
			// Drop the lock so response from the lobby can get back in
			ASSERT(1 == gnDPCSCount);
			LEAVE_DPLAY();
			
			// Get the data from the lobby
			if(fPlayer)
			{
				hr = PRV_GetPlayerData(this->lpLobbyObject, id,
							pvData, pdwDataSize);
			}
			else
			{
				hr = PRV_GetGroupData(this->lpLobbyObject, id,
							pvData, pdwDataSize);
			}

			// Take the lock again
			ENTER_DPLAY();
			
			// Since we've already copied the data into the caller's buffer,
			// we can just exit from here.
			return hr;
		}
	}

	// see if we've got space for it
	if (*pdwDataSize < dwSourceSize)
	{
		// not enough space
		*pdwDataSize = dwSourceSize;
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		// copy it
		*pdwDataSize = dwSourceSize;
		hr = DP_OK;
		memcpy(pvData,pvSource,*pdwDataSize);		
	}
	
	return hr;
	
} // InternalGetData  

HRESULT DPAPI DP_GetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetData(lpDP,id,pvData,pdwDataSize,dwFlags,FALSE);

	LEAVE_DPLAY();
	
	return hr;
	

} // DP_GetGroupData   

HRESULT DPAPI DP_GetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetData(lpDP,id,pvData,pdwDataSize,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerData  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupName"

// take a pointer to a buffer, stick a session desc in it, slap the strings
// on the end.  
HRESULT InternalGetName(LPDIRECTPLAY lpDP, DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fPlayer,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	UINT nShortLen,nLongLen; // length in bytes of strings
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwSize))
		{
			DPF_ERR("invalid pdwDataSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!pvBuffer) *pdwSize = 0;
		if (*pdwSize && !VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
			DPF_ERR("invalid buffer");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	if (fAnsi)
	{
		nShortLen = WSTR_ANSILENGTH(pPlayer->lpszShortName);
		nLongLen = WSTR_ANSILENGTH(pPlayer->lpszLongName);
	}
	else 
	{
		nShortLen = WSTRLEN_BYTES(pPlayer->lpszShortName);
		nLongLen = WSTRLEN_BYTES(pPlayer->lpszLongName);
	}

	// see if buffer is big enough
	if (*pdwSize < sizeof(DPNAME) + nShortLen + nLongLen )
	{
		*pdwSize = sizeof(DPNAME) + nShortLen + nLongLen;
		return DPERR_BUFFERTOOSMALL;
	}

	// zero it
	memset(pvBuffer,0,*pdwSize);
	
	// set up the playername struct, followed by strings
	*pdwSize = sizeof(DPNAME) + nShortLen + nLongLen;
	((LPDPNAME)pvBuffer)->dwSize = sizeof(DPNAME);

	// get strings
	if (fAnsi)
	{
		LPSTR psz;

		// short name, then long name
		psz = (LPBYTE)pvBuffer+sizeof(DPNAME);

		if (pPlayer->lpszShortName)
		{
			// string goes after name struct in buffer
			WideToAnsi(psz,pPlayer->lpszShortName,nShortLen);
			((LPDPNAME)pvBuffer)->lpszShortNameA = psz;
			// now, long name
			psz += nShortLen;
		}
		
		if (pPlayer->lpszLongName)
		{
			// string goes after session desc in buffer
			WideToAnsi(psz,pPlayer->lpszLongName,nLongLen);
			((LPDPNAME)pvBuffer)->lpszLongNameA = psz;
		}

	}
	else 
	{
		LPWSTR pszW;

		pszW = (LPWSTR)((LPBYTE)pvBuffer+sizeof(DPNAME));

		// short name, then long name
		if (pPlayer->lpszShortName)
		{
			// string goes after player name struct in buffer
			memcpy(pszW,pPlayer->lpszShortName,nShortLen);
			((LPDPNAME)pvBuffer)->lpszShortName = pszW;
		}
		
		if (pPlayer->lpszLongName)
		{
			// now, long name
			pszW = (LPWSTR)((LPBYTE)pszW + nShortLen);
			// string goes after session desc in buffer
			memcpy(pszW,pPlayer->lpszLongName,nLongLen);
			((LPDPNAME)pvBuffer)->lpszLongName = pszW;
		}
	}
	
	return DP_OK;
} // InternalGetName

HRESULT DPAPI DP_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)	
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, FALSE, FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerName"

HRESULT DPAPI DP_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, TRUE, FALSE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_GetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetFlags"

HRESULT  InternalGetFlags(LPDIRECTPLAY lpDP,DPID id,LPDWORD pdwFlags,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwFlags))
		{
			DPF_ERR("invalid flags pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// get the flags
	*pdwFlags = GetPlayerFlags(pPlayer);
	
	return DP_OK;
	
} // InternalGetFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerFlags"

HRESULT DPAPI DP_GetPlayerFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetFlags(lpDP,id,pdwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupFlags"

HRESULT DPAPI DP_GetGroupFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetFlags(lpDP,id,pdwFlags,FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetGroupFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetSessionDesc"

// take a pointer to a buffer, stick a session desc in it, slap the strings
// on the end.
HRESULT InternalGetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	UINT nNameLen,nPasswordLen; // session name length, in bytes
	HRESULT hr;
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before getting desc!");
			return DPERR_NOSESSIONS;
		}
		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;
		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	if (fAnsi)
	{
		nPasswordLen = WSTR_ANSILENGTH(this->lpsdDesc->lpszPassword);
		nNameLen = WSTR_ANSILENGTH(this->lpsdDesc->lpszSessionName);
	}
	else 
	{
		nPasswordLen = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);	
		nNameLen = WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
	}	
	
	if (*pdwSize < sizeof(DPSESSIONDESC2) + nNameLen  + nPasswordLen)
	{
		*pdwSize = sizeof(DPSESSIONDESC2) + nNameLen + nPasswordLen;
		return DPERR_BUFFERTOOSMALL;
	}

	// zero it
	memset(pvBuffer,0,*pdwSize);

	*pdwSize = sizeof(DPSESSIONDESC2) + nNameLen + nPasswordLen;

	// pack it up
	memcpy(pvBuffer,this->lpsdDesc,sizeof(DPSESSIONDESC2));

	// get strings
	if (fAnsi)
	{
		LPSTR psz;

		psz = (LPBYTE)pvBuffer+sizeof(DPSESSIONDESC2);

		if (this->lpsdDesc->lpszSessionName)
		{
			// string goes after session desc in buffer
			WideToAnsi(psz,this->lpsdDesc->lpszSessionName,nNameLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszSessionNameA = psz;
		}
		
		if (this->lpsdDesc->lpszPassword)
		{
			// now, password
			psz += nNameLen;
			// password follows session same
			WideToAnsi(psz,this->lpsdDesc->lpszPassword,nPasswordLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszPasswordA = psz;
		}
	}
	else 
	{
		LPWSTR pszW;
		
		pszW = (LPWSTR)((LPBYTE)pvBuffer+sizeof(DPSESSIONDESC2));
		
		if (this->lpsdDesc->lpszSessionName)
		{
			// 1st, session name
			memcpy(pszW,this->lpsdDesc->lpszSessionName,nNameLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszSessionName = pszW;
		}			
		
		if (this->lpsdDesc->lpszPassword)
		{
			// then, password
			pszW = (LPWSTR)((LPBYTE)pszW + nNameLen);
			memcpy(pszW,this->lpsdDesc->lpszPassword,nPasswordLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszPassword = pszW;
		}
	}
	
	return DP_OK;
} // InternalGetSessionDesc

HRESULT DPAPI DP_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetSessionDesc(lpDP,pvBuffer,pdwSize,FALSE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Initialize"

HRESULT DPAPI DP_Initialize(LPDIRECTPLAY lpDP, LPGUID lpGuid) 
{
    return DPERR_ALREADYINITIALIZED;	
}//DP_Initialize

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Open"

// get the system player / system group
HRESULT CreateSystemPlayer(LPDPLAYI_DPLAY this,DWORD dwFlags, LPWSTR lpszPassword)
{
	HRESULT hr;
	

   	// Even though the DPID_LOBBYSYSTEMPLAYER looks conspicuous here, it will
	// not have any effect in dplay sessions.  It will only be used if
	// we are in a lobby session.  Same for DPID_LOBBYSYSTEMGROUP below.
	hr = GetPlayer(this,&this->pSysPlayer,NULL,NULL,NULL,0,dwFlags,
			lpszPassword,DPID_LOBBYSYSTEMPLAYER);
    if (FAILED(hr)) 
    {
        DPF(0,"Could not create sysplayer - hr = 0x%08lx\n",hr);
		return hr;
    }

	// Create a system group.  This will be the group of all players
	// when we get a send to dpid_allplayers, we send it to this group and let sp 
	// optimize it.
   	hr = GetGroup(this,&((LPDPLAYI_GROUP)this->pSysGroup),NULL,NULL,0,
			DPLAYI_GROUP_SYSGROUP | DPLAYI_PLAYER_PLAYERLOCAL,0,
			DPID_LOBBYSYSTEMGROUP);
    if (FAILED(hr)) 
    {
        DPF(0,"Could not create system group - hr = 0x%08lx\n",hr);
		return hr;
    }
    
	ASSERT(this->pSysPlayer);

   	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
   			this->pSysPlayer->dwID,FALSE);
    if (FAILED(hr)) 
    {
		ASSERT(FALSE);
        DPF(0,"Could not add system player to  system group - hr = 0x%08lx\n",hr);
    }

	return hr;	

} // CreateSystemPlayer

// get the session desc out of an enumplayers reply
HRESULT UnpackSessionDesc(LPDPLAYI_DPLAY this,LPMSG_ENUMPLAYERSREPLY pmsg)
{
	LPDPSESSIONDESC2 psdNew;
	HRESULT hr;
	LPWSTR lpsz;
	
	ASSERT(this->lpsdDesc); // should have had one, with open

	psdNew = (LPDPSESSIONDESC2)((LPBYTE)pmsg + pmsg->dwDescOffset);
	
	// free any old strings
	if (this->lpsdDesc->lpszSessionName) DPMEM_FREE(this->lpsdDesc->lpszSessionName);
	if (this->lpsdDesc->lpszPassword) DPMEM_FREE(this->lpsdDesc->lpszPassword);
	
	// copy over the new desc
	memcpy(this->lpsdDesc,psdNew,sizeof(DPSESSIONDESC2));
		
	if (pmsg->dwNameOffset) GetString(&lpsz, (WCHAR *)((LPBYTE)pmsg + pmsg->dwNameOffset) );
	else lpsz = NULL;
	this->lpsdDesc->lpszSessionName = lpsz;

	if (pmsg->dwPasswordOffset) GetString(&lpsz, (WCHAR *)((LPBYTE)pmsg + pmsg->dwPasswordOffset) );
	else lpsz = NULL;
	this->lpsdDesc->lpszPassword = lpsz;
	
	return DP_OK;

	return hr;
	
} // UnpackSessionDesc

// called when we first join a session
// downloads the list of players and groups in the session from the nameserver
// called by internalopensession
HRESULT GetNameTable(LPDPLAYI_DPLAY this, DWORD dwServerVersion, BOOL fEnumOnly)
{
    UINT nPlayers,nGroups,nShortcuts; 
    LPMSG_SYSMESSAGE pmereq;
	LPBYTE pBuffer;
	LPBYTE pReply=NULL;
	LPVOID pvSPHeader;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	DWORD dwTimeout;
	DWORD dwVersion;
    DWORD dwCommand;

	DWORD dwReplyCommand;

    // send an enumplayers message if enumerating players in a remote session or
    // if nameserver won't automagically respond w/ the nametable on the addforward
    if ((fEnumOnly) || (dwServerVersion < DPSP_MSG_AUTONAMETABLE))
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
	    pBuffer = DPMEM_ALLOC(dwMessageSize);
	    if (!pBuffer) 
	    {
		    DPF_ERR("could not send request - out of memory");
		    return E_OUTOFMEMORY;
	    }

	    // pmsg follows sp blob
	    pmereq = (LPMSG_SYSMESSAGE)(pBuffer + this->dwSPHeaderSize);

        // build a message to send to the sp
   	    SET_MESSAGE_HDR(pmereq);

        SET_MESSAGE_COMMAND(pmereq,DPSP_MSG_ENUMPLAYER);

        // !! Review - the following stuff is already set in SendCreateMessage (AddForward)!!

	    // this flag indicates that any messages received before we get the whole
	    // nametable should be q'ed up.  Flag is reset in pending.c.
	    if (this->pSysPlayer)
	    {
		    // ok.  we've got a sysplayer, so we must be joining game for real.
		    // put us in pending mode, so we don't miss any nametable changes
		    // while we're waiting for the nametable to arrive
		    this->dwFlags |= DPLAYI_DPLAY_PENDING;
	    }

		if(dwServerVersion >= DPSP_MSG_DX5VERSION && !CLIENT_SERVER(this)){
			dwReplyCommand = DPSP_MSG_SUPERENUMPLAYERSREPLY;
		} else {
			dwReplyCommand = DPSP_MSG_ENUMPLAYERSREPLY;
		}


		SetupForReply(this,dwReplyCommand);

    	DPF(2,"requesting nametable");	

		//this->dwServerPlayerVersion=dwServerVersion; //moved to DP_Open

	    hr = SendDPMessage(this,this->pSysPlayer,NULL,pBuffer,dwMessageSize,DPSEND_SYSMESS,FALSE);

	    DPMEM_FREE(pBuffer); // done w/ message
	    
	    if (FAILED(hr)) 
	    {
	    	UnSetupForReply(this);
		    DPF_ERRVAL("could not send enumplayers request, hr = 0x%08lx", hr);
		    return hr;
	    }
    } 
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= (DP_NAMETABLE_SCALE-5);// scale up the amount of time we wait 
										// (nametable can be big)
										
	if (dwTimeout > DP_MAX_CONNECT_TIME)
		dwTimeout = DP_MAX_CONNECT_TIME;

	// changing to 30 sec on client, 15 sec on host.
	if(dwTimeout < DP_MAX_CONNECT_TIME/2){
		dwTimeout = DP_MAX_CONNECT_TIME/2;  
	}	

    DPF(2,"waiting for nametable:: timeout = %d\n",dwTimeout);	

	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

	hr=WaitForReply(this, &pReply, &pvSPHeader, dwTimeout);

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	// got a buffer with a message in it

    // if nameserver is DX5 or greater, it will respond with the nametable if 
    // addforward succeeds, otherwise it will respond with an addforwardreply containing
    // the error.
    dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReply);
    if (DPSP_MSG_ADDFORWARDREPLY == dwCommand)
    {
        hr = ((LPMSG_ADDFORWARDREPLY)pReply)->hResult;
        DPF_ERRVAL("Addforward failed: hr = 0x%08x\n",hr);

		// let handler.c continue
        goto CLEANUP_EXIT;
    }
	//
	// if it's a dx3 nameserver, the nametable will not be in the correct order
	//
	dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);
	if (DPSP_MSG_DX3VERSION == dwVersion) 
	{
		DPF(1,"name server is DX3");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	nPlayers = ((LPMSG_ENUMPLAYERSREPLY)pReply)->nPlayers;
	nGroups =  ((LPMSG_ENUMPLAYERSREPLY)pReply)->nGroups;
	
	DPF(0,"received %d players and %d groups and from name server\n",nPlayers,nGroups);

	if (dwVersion >= DPSP_MSG_SESSIONNAMETABLE)
	{
		hr = UnpackSessionDesc(this,(LPMSG_ENUMPLAYERSREPLY)pReply);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	// unpack  player list (player buffer follows enumreply message in buffer)
	this->lpsdDesc->dwCurrentPlayers = 0; // unpack will generate correct player count
	
	if (GET_MESSAGE_COMMAND((LPMSG_ENUMPLAYERSREPLY)pReply) == DPSP_MSG_SUPERENUMPLAYERSREPLY)
	{
		nShortcuts = ((LPMSG_ENUMPLAYERSREPLY)pReply)->nShortcuts;
	
		UnSuperpackPlayerAndGroupList(this,pReply+((LPMSG_ENUMPLAYERSREPLY)pReply)->dwPackedOffset,
			nPlayers,nGroups,nShortcuts,pvSPHeader);
	}
	else 
	{
		ASSERT(GET_MESSAGE_COMMAND((LPMSG_ENUMPLAYERSREPLY)pReply)== DPSP_MSG_ENUMPLAYERSREPLY);
		UnpackPlayerAndGroupList(this,pReply+((LPMSG_ENUMPLAYERSREPLY)pReply)->dwPackedOffset,
			nPlayers,nGroups,pvSPHeader);
	}

	if (this->pSysPlayer)
	{
		// execute any pending commands we may have queud
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE); // ?
		}
	}

// if we sucessfully received the name table, we have already
// set ghReplyProcessed to let handler.c run again. We do NOT
// want to set the event again or handler.c will not block the
// next time around.

CLEANUP_EXIT:
	if(pReply){
		FreeReplyBuffer(pReply);	
	}	
	
    // done
    return hr;

} // GetNameTable 

// called by InternalOpenSession
HRESULT AllocNameTable(LPDPLAYI_DPLAY this)
{
	UINT nPlayers;

	// now, alloc space for the nametable
    nPlayers =  this->lpsdDesc->dwCurrentPlayers + NAMETABLE_INITSIZE;
    
    // alloc the nametable
    this->pNameTable = DPMEM_ALLOC(nPlayers*sizeof(NAMETABLE));
    if (!this->pNameTable) 
    {
    	return E_OUTOFMEMORY;
    }
    
    this->uiNameTableSize  = nPlayers;
    DPF(0,"created name table of size %d\n",nPlayers);

	return DP_OK;

} // AllocNameTable

// todo - do we only do this on iplay1?
// put a DPSYS_CONNECTED in the apps message q
HRESULT DoConnected(LPDPLAYI_DPLAY this)
{
	LPDPMSG_GENERIC pconnected;
	LPMESSAGENODE pmsn;

	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
	if (!pmsn)
	{
		DPF_ERR("could not alloc message node!");
		return E_OUTOFMEMORY;
	}
	pconnected = DPMEM_ALLOC(sizeof(DPMSG_GENERIC));
	if (!pconnected)
	{
		DPMEM_FREE(pmsn);
		DPF_ERR("could not alloc message node!");
		return E_OUTOFMEMORY;
	}
	pconnected->dwType = DPSYS_CONNECT;
	pmsn->pNextMessage = NULL;
	pmsn->pMessage = pconnected;
	pmsn->dwMessageSize = sizeof(DPMSG_GENERIC);

	ASSERT(!this->pMessageList);
	this->pMessageList = pmsn;
	this->pLastMessage = pmsn;
	this->nMessages = 1;

	return DP_OK;

} // DoConnected

// called by internalenumsessions or internalopensession
// start our worker thread
// bKeepAlive is TRUE if we need keepalive, false if we need async enums
// if it's false, the seup was done in internalenum
HRESULT StartDPlayThread(LPDPLAYI_DPLAY this,BOOL bKeepAlive)
{
	DWORD dwThreadID;
	DPCAPS caps;
	HRESULT hr;

	if (bKeepAlive)	
	{
		// 1st, see if sp can do it
		memset(&caps,0,sizeof(caps));
		caps.dwSize = sizeof(caps);
		hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
		if (FAILED(hr))	
		{
			ASSERT(FALSE);
		}
		else 
		{
			// if sp does it, don't start the thread
			if (caps.dwFlags & DPCAPS_KEEPALIVEOPTIMIZED) return DP_OK;
		}
		
		// SP doesn't do it - we have to
		this->dwFlags |= DPLAYI_DPLAY_KEEPALIVE;
		this->dwLastPing = GetTickCount();
	}
	
	if (this->hDPlayThread)
	{
		// already running...just signal it that something has changed
		SetEvent(this->hDPlayThreadEvent);
		return DP_OK;
	}

	// get us a event
	this->hDPlayThreadEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
	if (!this->hDPlayThreadEvent)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);				
		DPF(0,"could not create worker thread event - err = %d\n",dwErr);
		return E_FAIL;
	}
	
	this->hDPlayThread = CreateThread(NULL,0,DPlayThreadProc,this,0,&dwThreadID);
	if (!this->hDPlayThread)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);
		DPF(0,"could not create worker thread - err = %d\n",dwErr);

		CloseHandle(this->hDPlayThreadEvent);
		this->hDPlayThreadEvent = 0;
		return E_FAIL;
	}
	
	return DP_OK;
	
} // StartDPlayThread

void StartPerf(LPDPLAYI_DPLAY this)
{
	DWORD dwThreadID;
	UINT nWantCPL;
	HRESULT hr;
	
	// 1st, see if we the user wants one
	nWantCPL = GetProfileIntA( PROF_SECT, "dxcpl", 0);
	// they must enter non-zero if they want it
	if (0 == nWantCPL)
	{
		// they don't want it
		// let's see if the dpcpl is running, just to make sure
		hr = InitMappingStuff(this);
		// if this failed, dplay cpl is not running
		if (FAILED(hr)) return ;
		// if the cpl is running, we'll talk to it
	}
	
	// get us a event
	this->hPerfEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
	if (!this->hPerfEvent)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);				
		DPF(0,"could not create perf event - err = %d\n",dwErr);
		return ;
	}
	
	this->hPerfThread = CreateThread(NULL,0,PerfThreadProc,this,0,&dwThreadID);
	if (!this->hPerfThread)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);
		DPF(0,"could not create perf thread - err = %d\n",dwErr);
		CloseHandle(this->hPerfEvent);
		this->hPerfEvent = 0;
		return ;
	}
	
	return ;
	
} // StartPerf

/*
 ** CopyCredentials
 *
 *  CALLED BY: InternalOpenSession()
 *
 *  PARAMETERS: pCredentialsDest - user credentials ptr (destination)
 *				pCredentialsSrc - user credentials ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies user credentials while allocating memory for username and password strings.
 *                These strings need to be freed by the calling function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopyCredentials(LPDPCREDENTIALS pCredentialsDest, 
                         LPCDPCREDENTIALS pCredentialsSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pCredentialsDest && pCredentialsSrc);

    memcpy(pCredentialsDest, pCredentialsSrc, sizeof(DPCREDENTIALS));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pCredentialsDest->lpszUsernameA), pCredentialsSrc->lpszUsername);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pCredentialsDest->lpszPasswordA), pCredentialsSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pCredentialsDest->lpszDomainA), pCredentialsSrc->lpszDomain);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pCredentialsDest->lpszUsername), pCredentialsSrc->lpszUsername);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pCredentialsDest->lpszPassword), pCredentialsSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pCredentialsDest->lpszDomain), pCredentialsSrc->lpszDomain);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeCredentials(pCredentialsDest, bAnsi);
    return hr;
} // CopyCredentials

HRESULT SetupSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC lpSecDesc)
{
    HRESULT hr;
    LPDPSECURITYDESC pSecDescLocal;
    LPWSTR pwszSSPIProvider=NULL,pwszCAPIProvider=NULL;
    DWORD dwCAPIProviderType,dwEncryptionAlgorithm;

    // alloc space for the security description
    pSecDescLocal = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDescLocal) 
    {
        DPF_ERR("couldn't allocate space for security desc - out of memory!");
        return DPERR_OUTOFMEMORY;
    }           

    // if app doesn't provide a security desc, setup defaults
    if (NULL == lpSecDesc)
    {
        // use default SSPI provider
        DPF(0, "No security description was provided - using defaults (NTLM and Microsoft's RSA Base Provider)");
        hr = GetString(&pwszSSPIProvider, DPLAY_DEFAULT_SECURITY_PACKAGE);
	    if (FAILED(hr))
	    {
		    DPF_ERRVAL("Failed to setup default SSPI Provider: hr = 0x%08lx", hr);
		    goto CLEANUP_EXIT;
	    }
	    // use default CAPI provider 
        // NULL means Microsoft's RSA Base Provider
	    dwCAPIProviderType = PROV_RSA_FULL; // full support
	    dwEncryptionAlgorithm = CALG_RC4;	 // stream cipher
    }
    else
    {
        // app passed in a security desc

	    // setup the SSPI provider
	    if (lpSecDesc->lpszSSPIProvider)
	    {
            DPF(0,"Using SSPI Provider: \"%ls\"", lpSecDesc->lpszSSPIProvider);
		    // copy the package name provided by application
            hr = GetString(&pwszSSPIProvider, lpSecDesc->lpszSSPIProvider);
	    }
	    else
	    {
		    // if app doesn't provide one, use the default security package
		    DPF(0, "No SSPI provider specified - using the default: %ls",DPLAY_DEFAULT_SECURITY_PACKAGE);
		    hr = GetString(&pwszSSPIProvider, DPLAY_DEFAULT_SECURITY_PACKAGE);
	    }
	    if (FAILED(hr))
	    {
		    DPF_ERRVAL("Failed to setup default SSPI Provider: hr = 0x%08lx", hr);
		    goto CLEANUP_EXIT;
	    }

	    // setup the CAPI provider
	    if (lpSecDesc->lpszCAPIProvider)
	    {
            dwCAPIProviderType = lpSecDesc->dwCAPIProviderType;
            dwEncryptionAlgorithm = lpSecDesc->dwEncryptionAlgorithm;

		    DPF(0, "Using CAPI provider: \"%ls\"",lpSecDesc->lpszCAPIProvider);

		    // copy the package name provided by application
            hr = GetString(&pwszCAPIProvider, lpSecDesc->lpszCAPIProvider);
		    if (FAILED(hr))
		    {
			    DPF_ERRVAL("Failed to setup default CAPI Provider: hr = 0x%08lx", hr);
			    goto CLEANUP_EXIT;
		    }
	    }
	    else
	    {
		    // if app doesn't provide one, use the default security package
		    DPF(0, "No CAPI provider specified - using Microsoft's RSA Base Provider");

	        // use default CAPI provider 
            // NULL means Microsoft's RSA Base Provider
	        dwCAPIProviderType = PROV_RSA_FULL; // full support
	        dwEncryptionAlgorithm = CALG_RC4;	 // stream cipher
	    }
    }

    // success

    // setup a security description
    pSecDescLocal->lpszSSPIProvider = pwszSSPIProvider;
    pSecDescLocal->lpszCAPIProvider = pwszCAPIProvider;
    pSecDescLocal->dwCAPIProviderType = dwCAPIProviderType;
    pSecDescLocal->dwEncryptionAlgorithm = dwEncryptionAlgorithm;
    pSecDescLocal->dwSize = sizeof(DPSECURITYDESC);
    pSecDescLocal->dwFlags = 0;

    // remember it in the dplay object
    this->pSecurityDesc = pSecDescLocal;

    return DP_OK;

CLEANUP_EXIT:

    if (pwszSSPIProvider) DPMEM_FREE(pwszSSPIProvider);
    if (pwszCAPIProvider) DPMEM_FREE(pwszCAPIProvider);
    if (pSecDescLocal) DPMEM_FREE(pSecDescLocal);

    return hr;
}  // SetupSecurityDesc

// find (or create) the session pointed to by lpSDesc.
// fEnumOnly means don't actually join - don't create the sysplayer...
HRESULT InternalOpenSession(LPDPLAYI_DPLAY this,LPCDPSESSIONDESC2 lpSDesc,
	BOOL fEnumOnly,DWORD dwFlags,BOOL fStuffInstanceGUID, 
    LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials)
{
	HRESULT hr = DP_OK;
    BOOL bNameSrvr = FALSE;
    DWORD dwPlayerFlags; // flags for our system player
    LPDPSESSIONDESC2 lpLocalDesc=NULL;
	DPSP_OPENDATA opd;
	BOOL bCreate;
	LPSESSIONLIST pSession;
    DWORD dwServerVersion=0;
	BOOL bReturnStatus; // true to override dialogs and return status
	DPCAPS dpCaps;

    //
	//
	// alloc space for the game description. if we create a game, we
	// use the passsed sessiondesc. if we join a game, we use the session
	// desc that enum stored for us.
    lpLocalDesc = DPMEM_ALLOC(sizeof(DPSESSIONDESC2));
    if (!lpLocalDesc) 
    {
    	DPF_ERR("open session - out of memory!");
        return E_OUTOFMEMORY;
    }

	// flags for the sysplayer
    dwPlayerFlags = DPLAYI_PLAYER_SYSPLAYER | DPLAYI_PLAYER_PLAYERLOCAL;

	// app can request that the SP not display any status
	// dialogs while opening by setting this flag. The SP
	// will return status codes while open is in progress

	bReturnStatus = (dwFlags & DPOPEN_RETURNSTATUS) ? TRUE : FALSE; 

	// 
	// get the session desc
    if (dwFlags & DPOPEN_JOIN) 
    {
		bCreate = FALSE;
		
		// find the matching session...
		pSession = FindSessionInSessionList(this,&(lpSDesc->guidInstance));	
		if (!pSession) 
		{
			DPF_ERR("could not find matching session to open");
            hr = DPERR_NOSESSIONS;
            goto CLEANUP_EXIT;
		}

    	DPF(0,"Remote dplay version %x\n",pSession->dwVersion);
	    this->dwServerPlayerVersion = pSession->dwVersion;

        if (pSession->dpDesc.dwFlags & DPSESSION_SECURESERVER)
        {
            //joining a secure session

            //do not allow enumeration on a remote session without authentication
            if (fEnumOnly)
            {
                DPF(0, "Can't enumerate a secure session without logging in");
                hr = DPERR_ACCESSDENIED;
                goto CLEANUP_EXIT;
            }
        }
        else
        {
            // joining an unsecure session
            if (lpSecDesc)
            {
                DPF_ERR("Passed security description while joining an unsecure session");
                hr = DPERR_INVALIDPARAMS;
                goto CLEANUP_EXIT;
            }
            if (lpCredentials)
            {
                DPF_ERR("Passed credentials while joining an unsecure session");
                hr = DPERR_INVALIDPARAMS;
                goto CLEANUP_EXIT;
            }
        }

        // if session we are trying to join is password protected
        if (pSession->dpDesc.dwFlags & DPSESSION_PASSWORDREQUIRED)
        {
            // do not allow enumeration of players without joining
            if (fEnumOnly)
            {
			    DPF(0,"session requires a password - join session before enumerating players\n");
                hr = DPERR_ACCESSDENIED;
                goto CLEANUP_EXIT;
            }
        }

        // check if the session is available to join
	    if ((pSession->dpDesc.dwFlags & DPSESSION_NEWPLAYERSDISABLED) ||
            (pSession->dpDesc.dwFlags & DPSESSION_JOINDISABLED))
        {
			DPF(0,"session is not allowing players to join\n");
            hr = DPERR_NONEWPLAYERS;
            goto CLEANUP_EXIT;
        }
	    
		// make sure we haven't reached the maximum number of players in
		// the session, unless we are just enum'ing, then let it join anyway
		if ((!fEnumOnly) && (pSession->dpDesc.dwMaxPlayers && 
           (pSession->dpDesc.dwCurrentPlayers >= pSession->dpDesc.dwMaxPlayers)))
		{
			DPF_ERR("Session already contains the maximum number of players");
			hr = DPERR_NONEWPLAYERS;
			goto CLEANUP_EXIT;
		}

        // initialize security, if we are joining a secure session, unless the SP
		// (or LP) is handling the security, in which case we can skip this
        if((pSession->dpDesc.dwFlags & DPSESSION_SECURESERVER) &&
			(!(this->dwFlags & DPLAYI_DPLAY_SPSECURITY)))
        {
            // initialize security
            hr = InitSecurity(this);
            if (FAILED(hr))
            {
                DPF(0, "Failed to initialize SSPI: hr = 0x%08lx", hr);
                goto CLEANUP_EXIT;
            }
        }
        
	    memcpy(lpLocalDesc,&(pSession->dpDesc),sizeof(DPSESSIONDESC2));

		// copy over the strings from the session desc supplied by the namesrvr
		GetString(&(lpLocalDesc->lpszSessionName),pSession->dpDesc.lpszSessionName);
		GetString(&(lpLocalDesc->lpszPassword),pSession->dpDesc.lpszPassword);
    }
	else
    {    	
	    this->dwServerPlayerVersion = DPSP_MSG_VERSION;
        // if we are creating a secure server
        if (lpSDesc->dwFlags & DPSESSION_SECURESERVER)
        {
			if(lpSDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL){
				DPF(0, "Tried to run protocol on secure session, not allowed, returning INVALIDFLAGS\n");
				hr=DPERR_INVALIDFLAGS;
				goto CLEANUP_EXIT;
			}
			
            // initialize security
            hr = InitSecurity(this);
            if (FAILED(hr))
            {
                DPF(0, "Failed to initialize SSPI hr = 0x%08lx", hr);
                goto CLEANUP_EXIT;
            }

            // we shouldn't have security desc yet
            ASSERT(!this->pSecurityDesc);

            // setup security description
            hr = SetupSecurityDesc(this, lpSecDesc);
            if (FAILED(hr))
            {
                DPF_ERRVAL("Failed to setup security description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

		// create a session.
		// copy the passed desc, and create a name server
		bCreate = TRUE;

		ASSERT(DPOPEN_CREATE & dwFlags);
	    memcpy(lpLocalDesc,lpSDesc,sizeof(DPSESSIONDESC2));

		// a-josbor: see if the WIN.INI file tells us to force the protocol on
		if (!(lpLocalDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL))
		{
		    if (GetProfileIntA( "DirectPlay", "Protocol", 0 ) == 1)
		    {
	            DPF(0, "Warning!  DirectProtocol turned ON by WIN.INI setting\n");
		    	lpLocalDesc->dwFlags |= DPSESSION_DIRECTPLAYPROTOCOL;
		    	bForceDGAsync=TRUE;
		    }
		}
		
        // init session desc properly
        lpLocalDesc->dwCurrentPlayers = 0;

    	dwPlayerFlags |= DPLAYI_PLAYER_NAMESRVR;

		// get a guid for this session
		// if we're stuffing the guid (called by dpconnect) then leave
		// the guid alone
		if (!fStuffInstanceGUID) OS_CreateGuid(&(lpLocalDesc->guidInstance));

		// copy over the strings from the session desc supplied by the user	
		GetString(&(lpLocalDesc->lpszSessionName),lpSDesc->lpszSessionName);
		GetString(&(lpLocalDesc->lpszPassword),lpSDesc->lpszPassword);

		// set up the player id xor key
		// the tick count serves as a pretty good randomizer
		lpLocalDesc->dwReserved1 = GetTickCount();
        // initialize the reserved fields
        lpLocalDesc->dwReserved2 = 0;
        // if session has a password, setup the PASSWORDREQUIRED flag in the session desc 
		// treat zero-length string like a NULL password to be compatible with
		// the behavior of DX3
        if ((lpSDesc->lpszPassword) &&
			(WSTRLEN(lpSDesc->lpszPassword) > 1))
        {
            lpLocalDesc->dwFlags |= DPSESSION_PASSWORDREQUIRED;
        }
		// if session is secure, use multicast
		if (lpSDesc->dwFlags & DPSESSION_SECURESERVER)
		{
			DPF(0,"Session is secure - enabling multicast");
			lpLocalDesc->dwFlags |= DPSESSION_MULTICASTSERVER;
		}
		
    } // create
		
    if (lpCredentials)
    {
        // app passed in user credentials - remember them in the dplay object
        // so we can use them while acquiring the credentials handle (after getting 
        // the package name from the server)
        ASSERT(!this->pUserCredentials);

        // allocate memory for storing credentials
        this->pUserCredentials = DPMEM_ALLOC(sizeof(DPCREDENTIALS));
        if (!this->pUserCredentials)
        {
            DPF_ERR("Failed to allocate credentials structure - out of memory!");
            hr = DPERR_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
        // remember the user credentials in the directplay object
        hr = CopyCredentials(this->pUserCredentials,lpCredentials, FALSE);                
        if (FAILED(hr))
        {
            DPF_ERRVAL("Couldn't store credentials: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }
    }

	// we  should not have a session desc yet!
	ASSERT(!this->lpsdDesc);

	// If this is a lobby-owned object, call the lobby here
	if(IS_LOBBY_OWNED(this))
	{
		// Drop the lock so the lobby's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Open a session to the lobby
		hr = PRV_Open(this->lpLobbyObject, lpLocalDesc, dwFlags, lpCredentials);
		// Take the lock back
		ENTER_DPLAY();
		
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed to Open lobby session, hr = 0x%08x", hr);
			goto CLEANUP_EXIT;
		}
	}

	// store the new session desc
    this->lpsdDesc =lpLocalDesc;
	// fixup protocol flags
	if(lpLocalDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL){
		this->dwFlags |= DPLAYI_DPLAY_PROTOCOL;
		DPF(0,">>>RUNNING WITH DIRECTPROTOCOL<<<\n");
	}
	if(lpLocalDesc->dwFlags & DPSESSION_NOPRESERVEORDER){
		this->dwFlags |= DPLAYI_DPLAY_PROTOCOLNOORDER;
	}

    if (this->pcbSPCallbacks->Open) 
    {
		opd.bCreate = bCreate;
		if (bCreate)
		{
			opd.lpSPMessageHeader = NULL;
		}
		else 
		{
			opd.lpSPMessageHeader = pSession->pvSPMessageData;
		}
		
		opd.lpISP = this->pISP;
		opd.bReturnStatus = bReturnStatus;
		opd.dwOpenFlags = dwFlags;
		opd.dwSessionFlags = this->lpsdDesc->dwFlags;
		
	    hr = CALLSP(this->pcbSPCallbacks->Open,&opd);	    	
	    if (FAILED(hr)) 
	    {
			DPF(0,"Open session callback failed - hr = 0x%08lx\n",hr);
            goto CLEANUP_EXIT;
	    }
    }
	else 
	{
		// no callback - no biggie
	}

	// Get Caps so we can tell if we need the protocol.

    ZeroMemory(&dpCaps,sizeof(dpCaps));
    dpCaps.dwSize = sizeof(dpCaps);
	hr=InternalGetCaps((LPDIRECTPLAY)this->pInterfaces,0, &dpCaps,FALSE,0);
    if (SUCCEEDED(hr) && !(dpCaps.dwFlags & DPCAPS_GUARANTEEDOPTIMIZED)){
		this->dwFlags |= DPLAYI_DPLAY_SPUNRELIABLE;
	}

	if(this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE | DPLAYI_DPLAY_PROTOCOL)){
	
		hr=InitPacketize(this);
		if(FAILED(hr)){
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
	}
	
	if(this->dwFlags & DPLAYI_DPLAY_PROTOCOL){

		// Initialize Dplay's reliable protocol on the interface.
		hr=InitProtocol(this);
		if(FAILED(hr)){
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// Get message sizes (again) since different with protocol running.
		hr=GetMaxMessageSize(this);
	    if (FAILED(hr))
	    {
	    	DPF_ERRVAL("Failed to get message sizes with protocol running hr=%08x\n",hr);
	        ASSERT(FALSE);
	        goto CLEANUP_EXIT;
	    }

	} 

	// alloc the nametable
	hr = AllocNameTable(this);
    if (FAILED(hr)) 
    {
		DPF(0,"Open session callback failed - hr = 0x%08lx\n",hr);
		// since we've succeeded sp's open call, shut down the session
        goto CLOSESESSION_EXIT;
    }

	// get the system player
	if (!fEnumOnly)
	{
		// we're actually joining this session
		hr = CreateSystemPlayer(this,dwPlayerFlags,lpSDesc->lpszPassword);
		if (FAILED(hr))
		{
			DPF_ERR("could not get system player");
            goto CLOSESESSION_EXIT;
		}

		// If we're a lobby object, we can skip everything that follows because it
		// has either already been done, or doesn't apply to lobbies.
		if(IS_LOBBY_OWNED(this))
			return hr;

        // setup credentials for the system player
        if ((DPOPEN_CREATE & dwFlags) && (lpSDesc->dwFlags & DPSESSION_SECURESERVER))
        {
			hr = LoadSecurityProviders(this,SSPI_SERVER);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to setup credentials");
                goto CLOSESESSION_EXIT;
            }
        }

		// put a DPSYS_CONNECT in the apps queue
		// we do this only for mech, since mech needs it
		// (but it breaks doom ii, so we can't do it always)
		if (gbMech) hr = DoConnected(this);

		// stop the enum thread
		if (this->dwFlags & DPLAYI_DPLAY_ENUM)	
		{
			StopEnumThread(this);
		}

		// a-josbor: if we're the nameserver start the DPLAY thread.  That's where we
		// clean up the reservation list
		// also start it up if we're using keepalives
		if ((this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE)
			|| (IAM_NAMESERVER(this)))
		{
			StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
		}
		
		// start up the perf thread
		StartPerf(this);
		
#ifdef DPLAY_VOICE_SUPPORT
		if (dwFlags & DPOPEN_VOICE)
		{
			DPF(2,"opening w/ voice caps");
			this->dwFlags |= DPLAYI_DPLAY_VOICE;
		}
#endif // DPLAY_VOICE_SUPPORT
	}

	//
    // get the name table
    // need to get the list of players from the name server
   	if (!(dwPlayerFlags & DPLAYI_PLAYER_NAMESRVR))
   	{
        ASSERT(pSession);
        // pass the name server's version so we don't send an enumplayers message
        // if it is dx5 or later
        hr = GetNameTable(this, pSession->dwVersion, fEnumOnly);	
		if (FAILED(hr)) 
		{
			DPF_ERR("could not download name table!");
            goto CLOSESESSION_EXIT;
		}
   	}

    // cleanup credentials - we don't want them hanging in our dplay object
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }
    // success
	return DP_OK;

    // if we reach here, we have allocated a session and perhaps initialized this->lpsdDesc
CLEANUP_EXIT:
    FreeDesc(lpLocalDesc, FALSE);
    DPMEM_FREE(lpLocalDesc);
    
    this->lpsdDesc = NULL;
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }
    if(this->pProtocol){
    	FiniProtocol(this->pProtocol);
    	this->pProtocol=NULL;
    }
    if(this->hRetryThread){
    	this->dwFlags |= DPLAYI_DPLAY_CLOSED;
    	KillThread(this->hRetryThread, this->hRetry);
    	this->hRetryThread=0;
    	FiniPacketize(this);
    	this->dwFlags &= ~DPLAYI_DPLAY_CLOSED;
    }
    return hr;

    // if we reach here, sp's open call was successfull
CLOSESESSION_EXIT:
    LEAVE_ALL();
    DP_Close((IDirectPlay *)this->pInterfaces);
    ENTER_ALL();
    return hr;

} // InternalOpenSession

// assumes it is being called in a TRY block
HRESULT ValidateOpenParams(LPDPLAYI_DPLAY this, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags)
{
    HRESULT hr;
    DPCAPS dpCaps;

    if (!VALID_READ_DPSESSIONDESC2(lpsdDesc)) 
    {
  		DPF_ERR("invalid session desc");
        return DPERR_INVALIDPARAMS;
    }

	if (!VALID_OPEN_FLAGS(dwFlags))
	{
  		DPF_ERR("invalid flags");
        return DPERR_INVALIDPARAMS;
	}

	// REVIEW NOTE: DX3 did not check for invalid flags in the session desc.
	// Therefore, apps may have been passing in garbage here and we would
	// not have caught it. Now we are checking to make sure the flags are valid.
	// This could cause a regression, since we will fail now where we did not before.

	if (!VALID_DPSESSIONDESC2_FLAGS(lpsdDesc->dwFlags))
	{
  		DPF_ERRVAL("invalid flags (0x%08x) in session desc!",lpsdDesc->dwFlags);
		ASSERT(FALSE);				// assert so we pay attention!
        return DPERR_INVALIDFLAGS;
	}
	
    // don't allow nameserver migration with 
    // DPSESSION_SECURESERVER or DPSESSION_CLIENTSERVER	or DPSESSION_MULTICASTSERVER
    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
	    DPF_ERR("Can't set host migration on a secure server");
	    return DPERR_INVALIDFLAGS;
    }

    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER))
    {
	    DPF_ERR("Can't set host migration on client server");
	    return DPERR_INVALIDFLAGS;
    }

    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER))
    {
	    DPF_ERR("Can't set host migration on multicast server");
	    return DPERR_INVALIDFLAGS;
    }

	if ((lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) && 
		(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
	{
		DPF(0,"Warning! Player messages sent secure will contain headers");
	}

	if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
		WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}
	if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
		WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}

    if ((dwFlags & DPOPEN_CREATE) && (lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
        // dplay security is only available if sp supports reliable communication
        ZeroMemory(&dpCaps,sizeof(dpCaps));
        dpCaps.dwSize = sizeof(dpCaps);
	    hr = InternalGetCaps((LPDIRECTPLAY)this->pInterfaces,0, &dpCaps,FALSE,0);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get caps: hr=0x%08x",hr);
            return hr;
        }
        if (!(dpCaps.dwFlags & DPCAPS_GUARANTEEDSUPPORTED))
        {
            DPF_ERR("Can't host a secure session - sp doesn't support reliable messages");
            return DPERR_UNSUPPORTED;
        }
    }

#ifdef DPLAY_VOICE_SUPPORT
    if ((dwFlags & DPOPEN_VOICE) && (IS_LOBBY_OWNED(this)) )
    {
		DPF_ERR("DPOPEN_VOICE is not supported for lobby connections");
		return DPERR_UNSUPPORTED;
    }
#endif // DPLAY_VOICE_SUPPORT

    // all params are ok
    return DP_OK;
}

// In DX3 the list of sessions was stored in a global list.
// In DX5, the list is stored with the DirectPlay object.
//
// This means if a DX3 app did an EnumSessions() on one object
// and then Open(JOIN) on a different object, the session list would
// be preserved between objects and the join would work.
//
// On DX5 this would fail since the session list was not preserved.
//
// We found one DX3 game (X-Wing vs. Tie Fighter) that was depending on
// this - there may be more. The fix was to simply EnumSessions again
// until the requested session was found.

#define FILE_NAME_SIZE	256

BOOL XWingHack(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc)
{
	DPLCONNECTION	connect;
	char			lpszFileName[FILE_NAME_SIZE];
	char			lpszXWing[] = "z_xvt__.exe";
	char			*lpszCheck;
	HRESULT			hr;

	// get path name of app we are running
	if (!GetModuleFileNameA(NULL,lpszFileName,FILE_NAME_SIZE)) 
		return (FALSE);

	// make sure string is big enough
	if (STRLEN(lpszFileName) < STRLEN(lpszXWing))
		return (FALSE);

	// match app name against characters at end of path name
	lpszCheck = lpszFileName + STRLEN(lpszFileName) - STRLEN(lpszXWing);

	LowerCase(lpszCheck);

	// bail if name does not match
	if (0 != strcmp(lpszCheck, lpszXWing))
		return (FALSE);

	DPF(1,"Found X-Wing!!!");

	memset(&connect, 0, sizeof(DPLCONNECTION));
	connect.lpSessionDesc = lpsdDesc;

	// get this session instance into the session list if it takes all night
	DPF(1,"Re-aquiring session...");
	hr = ConnectFindSession(this, &connect);

	if FAILED(hr)
		return (FALSE);
	else
		return (TRUE);
}

HRESULT DPAPI DP_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }

	    if (this->lpsdDesc)
	    {
			LEAVE_ALL();
		    DPF_ERR("session already open!");
		    return DPERR_ALREADYINITIALIZED;
	    }

        // parameter validation
        hr = ValidateOpenParams(this, lpsdDesc, dwFlags);
        if (FAILED(hr))
        {
		    LEAVE_ALL();
	        return hr;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,NULL,NULL);

	// this is a hack to make X-Wing vs. Tie Fighter work
	// it will go out on the network, find the specified session
	// and add it to the session list.
	if ((DPERR_NOSESSIONS == hr) && (XWingHack(this, lpsdDesc)))
	{
		hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,NULL,NULL);
	}

	LEAVE_ALL();
    return hr;
        
}//DP_Open

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Receive"

// we've just copied our private pmsg over to users pvBuffer
// if it was a system message, we need to fix up our pointers
void FixUpPointers(LPVOID pvBuffer)  
{
	DWORD dwType;
	UINT nShortLen=0,nLongLen=0;
	LPBYTE pBufferIndex;

	dwType = ((LPDPMSG_GENERIC)pvBuffer)->dwType;

	switch (dwType)
	{
		case DPSYS_CREATEPLAYERORGROUP:
			{
				LPDPMSG_CREATEPLAYERORGROUP pmsg = (LPDPMSG_CREATEPLAYERORGROUP)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CREATEPLAYERORGROUP);

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
				// now, lpData - follows strings
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}

			}		
			break;

		case DPSYS_SETPLAYERORGROUPDATA:
			{
				
				LPDPMSG_SETPLAYERORGROUPDATA pmsg = (LPDPMSG_SETPLAYERORGROUPDATA)pvBuffer;
				 				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPDATA);

				// data follows msg
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}


			}
			break;
			
		case DPSYS_SETPLAYERORGROUPNAME:
			{
				LPDPMSG_SETPLAYERORGROUPNAME pmsg = (LPDPMSG_SETPLAYERORGROUPNAME)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPNAME);

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
			}
			break;

		case DPSYS_DESTROYPLAYERORGROUP:	
			{
				LPDPMSG_DESTROYPLAYERORGROUP pmsg = (LPDPMSG_DESTROYPLAYERORGROUP)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_DESTROYPLAYERORGROUP);

				// fix up local data pointer
				if (pmsg->lpLocalData)
				{
					pmsg->lpLocalData = pBufferIndex;
					pBufferIndex += pmsg->dwLocalDataSize;
				}
				// fix up remote data pointer
				if (pmsg->lpRemoteData)
				{
					pmsg->lpRemoteData = pBufferIndex;
					pBufferIndex += pmsg->dwRemoteDataSize;
				}

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
				
			}
			break;

		case DPSYS_SETSESSIONDESC:
			{
                UINT nSessionNameLen, nPasswordLen;
				LPDPMSG_SETSESSIONDESC pmsg = (LPDPMSG_SETSESSIONDESC)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETSESSIONDESC);

				nSessionNameLen = WSTRLEN_BYTES(pmsg->dpDesc.lpszSessionName);
				nPasswordLen = WSTRLEN_BYTES(pmsg->dpDesc.lpszPassword);

				// fix up string pointers - strings follow msg
				if (nSessionNameLen)
				{
					pmsg->dpDesc.lpszSessionName = (LPWSTR)pBufferIndex;
					pBufferIndex += nSessionNameLen;
				}
				if (nPasswordLen)
				{
					pmsg->dpDesc.lpszPassword = (LPWSTR)pBufferIndex;
				}
			}
			break;

        case DPSYS_SECUREMESSAGE:
            {
                LPDPMSG_SECUREMESSAGE pmsg = (LPDPMSG_SECUREMESSAGE)pvBuffer;

                // fix up data pointer
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SECUREMESSAGE);

				// data follows msg
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}
            }
            break;

		case DPSYS_STARTSESSION:
			{
				LPDPMSG_STARTSESSION	pmsg = (LPDPMSG_STARTSESSION)pvBuffer;

				// First fix up the DPLCONNECTION pointer itself
				pmsg->lpConn = (LPDPLCONNECTION)((LPBYTE)pmsg +
								sizeof(DPMSG_STARTSESSION));
				
				// Call the function in the lobby which does this
				PRV_FixupDPLCONNECTIONPointers(pmsg->lpConn);
			}
			break;
		
		case DPSYS_CHAT:
			{
				LPDPMSG_CHAT	pmsg = (LPDPMSG_CHAT)pvBuffer;

				pmsg->lpChat = (LPDPCHAT)((LPBYTE)pmsg + sizeof(DPMSG_CHAT));
				pmsg->lpChat->lpszMessage = (LPWSTR)((LPBYTE)pmsg + sizeof(DPMSG_CHAT) +
						sizeof(DPCHAT));
			}
			break;

		default:
			// no ptrs to fix up...
			break;
	} // switch

	return ;
	
} // FixUpPointers

// if its an addlayer message, return size of dplay 10 add player message
DWORD OldMessageSize(LPMESSAGENODE pmsg)
{
	DWORD dwType;

	dwType = ((LPDPMSG_GENERIC)(pmsg->pMessage))->dwType;

	if (DPSYS_ADDPLAYER == dwType)
	{
		// make sure we tell the app to alloc enough space for the larger of the
		// addplayer1 and the addplayer2
		if (pmsg->dwMessageSize < sizeof(DPMSG_ADDPLAYER)) return sizeof(DPMSG_ADDPLAYER);
		else return pmsg->dwMessageSize;
	}
	// else
	return pmsg->dwMessageSize;
} // OldMessageSize

// called by dp_1_receive,dp_a_receive, dp_receive
// dwCaller is RECEIVE_2,RECEIVE_2A, or RECEIVE_1 depending on who called 
// us
HRESULT InternalReceive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
                LPVOID pvBuffer,LPDWORD pdwSize,DWORD dwCaller	) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPMESSAGENODE pmsg,pmsgPrev=NULL;
	DWORD dwActualSize; // message size may be adjusted if
						// it's a 1.0 system message
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		if  ((!pidTo) || (!VALID_ID_PTR(pidTo)))
		{
	        DPF_ERR( "Bad pidTo" );
	        return DPERR_INVALIDPARAMS;
		}

		if ((!pidFrom) || (!VALID_ID_PTR(pidFrom)))
		{
	        DPF_ERR( "Bad pidFrom" );
	        return DPERR_INVALIDPARAMS;
		}

		if (!VALID_RECEIVE_FLAGS(dwFlags))
		{
	        DPF_ERR( "invalid flags" );
	        return DPERR_INVALIDFLAGS;
		}

		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;
		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	pmsgPrev = NULL;
	pmsg = this->pMessageList; //  1st message

	// check for a match to or from a specific player
	if (dwFlags & (DPRECEIVE_TOPLAYER | DPRECEIVE_FROMPLAYER))
	{
		// loop over all the messages in the queue
		while (pmsg)
		{
			// both "to" and "from" must match
			if ((dwFlags & DPRECEIVE_TOPLAYER) &&
				(dwFlags & DPRECEIVE_FROMPLAYER))
			{
				// make sure both id's match
				if ((pmsg->idTo == *pidTo) &&
					(pmsg->idFrom == *pidFrom))
				{
					break;
				}
			}

			// just "to" has to match
			else if (dwFlags & DPRECEIVE_TOPLAYER)
			{
				// make sure "to" id's match
				if (pmsg->idTo == *pidTo)
				{
					break;
				}
			}

			// just "from" has to match
			else if (dwFlags & DPRECEIVE_FROMPLAYER)
			{
				// make sure "from" id's match
				if (pmsg->idFrom == *pidFrom)
				{
					break;
				}
			}

			// no match found, so go to next message
			pmsgPrev = pmsg;
			pmsg = pmsg->pNextMessage;
		}
	}

	// there are no messages for us
	if (!pmsg) 
	{
		return DPERR_NOMESSAGES;
	}
   
	// if it's 1.0, we may need to resize 
	if ((dwCaller == RECEIVE_1) && (0 == pmsg->idFrom))
	{
		dwActualSize = OldMessageSize(pmsg);
	}
	else 
	{
		dwActualSize = pmsg->dwMessageSize;
	}
	// see if the apps buffer is big enough
	if (*pdwSize < dwActualSize)
	{
		*pdwSize = dwActualSize;		// tell app how much is needed
		return DPERR_BUFFERTOOSMALL;
	}

	// copy the buffer over
	memcpy((LPBYTE *)pvBuffer,pmsg->pMessage,pmsg->dwMessageSize);
	*pdwSize = pmsg->dwMessageSize;
	*pidTo = pmsg->idTo;
	*pidFrom = pmsg->idFrom;

	DPF(5,"player id %d received message from player id %d\n",*pidTo,*pidFrom);

	if (0 == *pidFrom)
	{
		FixUpPointers(pvBuffer);
	}
	// remove message (unless its a peek)
	if (!(dwFlags & DPRECEIVE_PEEK))
	{
		if (!pmsgPrev) 
		{
			// 1st message on list
			this->pMessageList = pmsg->pNextMessage;
		} else {
			// not 1st message on list
			pmsgPrev->pNextMessage = pmsg->pNextMessage;
		}	
		
		if(pmsg == this->pLastMessage){
			this->pLastMessage = pmsgPrev;
		}

		FreeMessageNode(this, pmsg);
	}

    return hr;
        
}// InternalReceive


HRESULT DPAPI DP_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
                LPVOID pvBuffer,LPDWORD pdwSize	) 
{
	HRESULT hr;
	
	ENTER_DPLAY();
	
	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_2);
		
	LEAVE_DPLAY();
	
	return hr;
			
}//DP_Receive

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommonSendParms"

__inline HRESULT ValidateCommonSendParms(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
                LPVOID pvBuffer,DWORD dwBufSize,LPDPLAYI_PLAYER *ppPlayerFrom,
                LPDPLAYI_PLAYER *ppPlayerTo, LPDPLAYI_GROUP *ppGroupTo, BOOL *pbToPlayer)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// check src player        
		*ppPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(*ppPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			return DPERR_INVALIDPLAYER;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			*ppPlayerTo = PlayerFromID(this,idTo);
			if (VALID_DPLAY_PLAYER(*ppPlayerTo)) 
			{		  
				*pbToPlayer = TRUE;
			}
			else 
			{
				*ppGroupTo = GroupFromID(this,idTo);
				if (VALID_DPLAY_GROUP(*ppGroupTo)) 
				{
					*pbToPlayer = FALSE;
				}
				else 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					return DPERR_INVALIDPARAMS;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if (!VALID_SEND_FLAGS(dwFlags))
		{
			DPF_ERR("bad dwFlags");
            return DPERR_INVALIDPARAMS;
		}

		if((dwFlags & DPSEND_ASYNC)){
			DPF_ERR("trying async send on old send api");
			return DPERR_UNSUPPORTED;
		}

        if ((dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            // secure messages can only be sent in a secure session
            if (!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
			    DPF_ERR("Can't send a secure message - session is not secure");
                return DPERR_INVALIDPARAMS;
            }

            // secure message can only be sent reliable
            if (!(dwFlags & DPSEND_GUARANTEED))
            {
			    DPF_ERR("Can't send a secure message - message is not reliable");
                return DPERR_INVALIDPARAMS;
            }
        }

		// check the buffer
		if (!VALID_READ_STRING_PTR(pvBuffer,dwBufSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (0 == dwBufSize)
		{
			DPF_ERR("invalid buffer size");
			return DPERR_INVALIDPARAMS;			
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        return DPERR_INVALIDPARAMS;
    }

	// if player from is not local, and i am not the nameserver in a multicast 
	// session, the send is no good
	ASSERT(this->lpsdDesc);	   
	if ( !((*ppPlayerFrom)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		!((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) && IAM_NAMESERVER(this)) )
	{
		DPF_ERR("attempt to send from non-local player");
		return DPERR_ACCESSDENIED;
	}
	
	if (dwFlags & DPSEND_GUARANTEED ) DPF(7,"sending DPSEND_GUARANTEED");

    // if encryption was requested, check if support is available
    if ((dwFlags & DPSEND_ENCRYPTED) && !(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
    {
        DPF_ERR("Encryption is not supported");
        return DPERR_ENCRYPTIONNOTSUPPORTED;
    }

    // If a client is trying to send a secure message, make sure they have logged in
    if ((dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)) && !IAM_NAMESERVER(this))
    {
        if (DPLOGIN_SUCCESS != this->LoginState)
        {
            DPF_ERR("Client hasn't logged in yet");
            return DPERR_NOTLOGGEDIN;
        }
    }
    
    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Send"
HRESULT DPAPI DP_Send(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
                LPVOID pvBuffer,DWORD dwBufSize	) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP pGroupTo; 
    LPDPLAYI_PLAYER pPlayerTo,pPlayerFrom;
	BOOL bToPlayer= FALSE;

	ENTER_ALL();

	hr=ValidateCommonSendParms(lpDP, idFrom, idTo, dwFlags, pvBuffer, dwBufSize,
							   &pPlayerFrom, &pPlayerTo, &pGroupTo, &bToPlayer);

	if(FAILED(hr)){
		LEAVE_ALL();
		return hr;
	}

    this = DPLAY_FROM_INT(lpDP);
	
	DPF(9,"sending message from %d to %d\n",idFrom,idTo);

	// If this object is lobby-owned, pass the message off to it here
	// since it will do all the server stuff
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_Send(this->lpLobbyObject, idFrom, idTo, dwFlags,
						pvBuffer, dwBufSize);
		// Since the lobby already sent the message, we can just return
		// from here.
		LEAVE_ALL();
		return hr;
	}

	// do the send
	if (bToPlayer)
	{
		hr = SendPlayerMessage( this, pPlayerFrom, pPlayerTo, dwFlags, pvBuffer, 
			dwBufSize);
	}
	else 
	{
		// send to group
		hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwFlags,pvBuffer,
				dwBufSize,TRUE);
	}

	if (FAILED(hr)) DPF(0," send failed - hr = 0x%08lx\n",hr);

	LEAVE_ALL();
    return hr;
        
}//DP_Send

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommonSendParms"

__inline HRESULT ValidateCommonSendParmsEx(LPDIRECTPLAY lpDP, LPSENDPARMS psp)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// check src player        
		psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
		if (!VALID_DPLAY_PLAYER(psp->pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr=DPERR_INVALIDPLAYER;
    		goto ERROR_EXIT;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			psp->pPlayerTo = PlayerFromID(this,psp->idTo);
			if (VALID_DPLAY_PLAYER(psp->pPlayerTo)) 
			{		  
				psp->pGroupTo = NULL;
			}
			else 
			{
				psp->pGroupTo = GroupFromID(this,psp->idTo);
				if (VALID_DPLAY_GROUP(psp->pGroupTo)) 
				{
					psp->pPlayerTo = NULL;
				}
				else 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					hr=DPERR_INVALIDPLAYER;
		    		goto ERROR_EXIT;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if (!VALID_SEND_FLAGS(psp->dwFlags))
		{
			DPF_ERR("bad dwFlags");
			hr=DPERR_INVALIDFLAGS;
    		goto ERROR_EXIT;
		}

		if((psp->dwFlags & DPSEND_ASYNC) && !(this->dwSPFlags & DPCAPS_ASYNCSUPPORTED)){
			DPF_ERR("trying async send when not supported");
			return DPERR_UNSUPPORTED;
		}

        if ((psp->dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            // secure messages can only be sent in a secure session
            if (!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
			    DPF_ERR("Can't send a secure message - session is not secure");
			    hr=DPERR_INVALIDFLAGS;
	    		goto ERROR_EXIT;
            }

            // secure message can only be sent reliable
            if (!(psp->dwFlags & DPSEND_GUARANTEED))
            {
			    DPF_ERR("Can't send a secure message - message is not reliable");
			    hr=DPERR_INVALIDFLAGS;
	    		goto ERROR_EXIT;
            }
        }

		// check the buffer
		if (!VALID_READ_STRING_PTR(psp->lpData,psp->dwDataSize))
		{
	        DPF_ERR( "bad buffer pointer" );
    		goto INVALID_PARMS_EXIT;
		}

		if(!VALID_DWORD_PTR(psp->lpdwMsgID)){
			DPF_ERR( "bad message id pointer\n");
    		goto INVALID_PARMS_EXIT;
		}

		if (0 == psp->dwDataSize)
		{
			DPF_ERR("invalid buffer size");
    		goto INVALID_PARMS_EXIT;
		}
		

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
		goto INVALID_PARMS_EXIT;
    }

	// if player from is not local, and i am not the nameserver in a multicast 
	// session, the send is no good
	ASSERT(this->lpsdDesc);	   
	if ( !((psp->pPlayerFrom)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		!((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) && IAM_NAMESERVER(this)) )
	{
		DPF_ERR("attempt to send from non-local player");
		return DPERR_ACCESSDENIED;
	}
	
	if (psp->dwFlags & DPSEND_GUARANTEED ) DPF(7,"sending DPSEND_GUARANTEED");

    // if encryption was requested, check if support is available
    if ((psp->dwFlags & DPSEND_ENCRYPTED) && !(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
    {
        DPF_ERR("Encryption is not supported");
        return DPERR_ENCRYPTIONNOTSUPPORTED;
    }

    // If a client is trying to send a secure message, make sure they have logged in
    if ((psp->dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)) && !IAM_NAMESERVER(this))
    {
        if (DPLOGIN_SUCCESS != this->LoginState)
        {
            DPF_ERR("Client hasn't logged in yet");
            return DPERR_NOTLOGGEDIN;
        }
    }

	if(psp->dwPriority && !(this->dwSPFlags & DPCAPS_SENDPRIORITYSUPPORTED)){
		return DPERR_UNSUPPORTED;
	}

    if(psp->dwPriority > DPSEND_MAX_PRI){
	    DPF_ERR( "Priority is too high for user send" );		
	    hr=DPERR_INVALIDPRIORITY;
    	goto ERROR_EXIT;
    }

	if(psp->dwTimeout && !(this->dwSPFlags & DPCAPS_SENDTIMEOUTSUPPORTED)){
		return DPERR_UNSUPPORTED;
	}

    // do tests for async send validity
    if(psp->dwFlags & DPSEND_ASYNC){
    	#ifdef DEBUG
		if(psp->dwTimeout > 60000*60){
   			DPF_ERR("SendTimeOut is greater than 1 hour?");
    	} else if(psp->dwTimeout > 60000*5){
    		DPF_ERR( "SendTimeOut is greater than 5 minutes?");
    	}
    	#endif
    } else {
    	// A synchronous send.  
    	if(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG){
    		DPF_ERR( "Can't use DPSEND_NOSENDCOMPLETEMSG on synchronous send\n");
    		return DPERR_INVALIDFLAGS;
    	}
    }
    
    return DP_OK;

INVALID_PARMS_EXIT:    
	return DPERR_INVALIDPARAMS;

ERROR_EXIT:
	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SendEx"

#ifdef DEBUG
UINT nCallsToSend=0;
#endif

HRESULT DPAPI DP_SendEx(
	LPDIRECTPLAY lpDP, 
	DPID idFrom, 
	DPID idTo, 
	DWORD dwFlags,
	LPVOID lpData, 
	DWORD dwDataSize, 
	DWORD dwPriority, 
	DWORD dwTimeout, 
	LPVOID lpUserContext,
	DWORD_PTR *lpdwMsgID)
{
    HRESULT hr = DP_OK;

    LPDPLAYI_DPLAY this;
	LPSENDPARMS psp;

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	// make sure we 0 out his returned msg id.  Just to be safe
	if (lpdwMsgID)
		*lpdwMsgID = 0;

	if(FAILED(hr)){
		return hr;
	}

	psp=GetSendParms(); // allocates send parm, sets refcount to 1.

	if(!psp){
		return DPERR_OUTOFMEMORY;
	}
	
	InitBilink(&psp->PendingList);

	psp->dwSendTime    = timeGetTime();

	psp->idFrom        = idFrom;
	psp->idTo          = idTo;
	psp->dwFlags       = dwFlags;
	psp->lpData        = lpData;		// user buffer, not valid after return from call
	psp->dwDataSize    = dwDataSize;    // unless DPSEND_NOCOPY is set.
	psp->dwPriority    = dwPriority;
	psp->dwTimeout     = dwTimeout;
	psp->lpUserContext = lpUserContext;
	psp->lpdwMsgID     = lpdwMsgID;
		
	if(!psp->lpdwMsgID){
		psp->lpdwMsgID = &psp->dwMsgID;
	}

	psp->hr            = DP_OK;
	
	psp->cBuffers         = 0;
	psp->dwTotalSize      = dwDataSize;

	psp->iContext = 0;
	psp->nContext = 0; 
	psp->nComplete= 0;
	psp->hContext = NULL;

	ENTER_ALL();

	hr=ValidateCommonSendParmsEx(lpDP, psp); // Fills in players and groups.
	
	if(FAILED(hr)){
		psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;		
		goto EXIT;
	}

	//
	// Double buffer the send memory if necessary.
	//
	
	if((psp->dwFlags & DPSEND_ASYNC) && !(psp->dwFlags & DPSEND_NOCOPY))
	{
		// ASYNC send and sender retains ownership of send buffers, so we must copy.
		psp->Buffers[0].pData      = MsgAlloc(psp->dwDataSize);
		if(!psp->Buffers[0].pData){
			hr=DPERR_OUTOFMEMORY;
			psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;
			goto EXIT;
		}
		psp->Buffers[0].len        = psp->dwDataSize;
		
		memcpy(psp->Buffers[0].pData,psp->lpData,psp->dwDataSize);
		
		psp->BufFree[0].fnFree     = MsgFree;
		psp->BufFree[0].lpvContext = NULL;

		if(this->pProtocol){
			psp->dwFlags |= DPSEND_NOCOPY;	// we copied the data, so the protocol doesn't need to.
		}
		
	} else {
		psp->Buffers[0].pData = lpData;
		psp->Buffers[0].len   = dwDataSize;
		psp->BufFree[0].fnFree = NULL;
		psp->BufFree[0].lpvContext = NULL;
	}
	psp->cBuffers=1;
	
	DPF(9,"sending message from %d to %d\n",idFrom,idTo);

	// If this object is lobby-owned, pass the message off to it here
	// since it will do all the server stuff
	if(IS_LOBBY_OWNED(this))
	{
		// BUGBUG: MYRONTH, MAKE PRV_SendEx
		#if 0
		hr = PRV_Send(this->lpLobbyObject, idFrom, idTo, dwFlags,
						pvBuffer, dwBufSize);
						
		// Since the lobby already sent the message, we can just return
		// from here.
		#endif
		hr=E_NOTIMPL;
		LEAVE_ALL();
		return hr;
	}

	if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG) && (psp->dwFlags & DPSEND_ASYNC)){
		InterlockedIncrement(&psp->pPlayerFrom->nPendingSends);
		InsertBefore(&psp->PendingList, &psp->pPlayerFrom->PendingList);
		DPF(9,"INC pPlayerFrom %x, nPendingSends %d\n",psp->pPlayerFrom, psp->pPlayerFrom->nPendingSends);
	}	

	// do the send
	if (psp->pPlayerTo)
	{
		#ifdef DEBUG
		nCallsToSend++;
		#endif
		hr = SendPlayerMessageEx( this, psp );
	}
	else 
	{
		ASSERT(psp->pGroupTo);
		// send to group
		#ifdef DEBUG
		nCallsToSend++;
		#endif
		hr = SendGroupMessageEx(this, psp, TRUE);
	}

EXIT:
	if(FAILED(hr) && hr!=DPERR_PENDING){
		if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG)){
			psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
			if(psp->pPlayerFrom){
				InterlockedDecrement(&psp->pPlayerFrom->nPendingSends);
				Delete(&psp->PendingList);
				InitBilink(&psp->PendingList);
			}
			psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;
		}
	}

	LEAVE_ALL();

	pspDecRef(this,psp); // remove this functions reference.

    return hr;

} // DP_SendEx

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CancelMessage"

HRESULT DPAPI DP_CancelMessage(LPDIRECTPLAY lpDP, DWORD dwMsgID, DWORD dwFlags)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_CANCELDATA CancelData;
	PSENDPARMS psp=NULL;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(dwFlags){
		// Reserved for future expansion of API.
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	if(!this->pcbSPCallbacks->Cancel && !(this->pProtocol)){
		hr=DPERR_UNSUPPORTED;
		goto ERROR_EXIT;
	}

	if(dwMsgID){

		psp=pspFromContext(this, (LPVOID)dwMsgID, TRUE); // adds a reference to psp

		if(!psp){
			hr=DPERR_UNKNOWNMESSAGE;
			goto ERROR_EXIT;
		}

		EnterCriticalSection(&psp->cs);
		if(psp->nComplete){
			LeaveCriticalSection(&psp->cs);
			hr=DPERR_CANCELFAILED;
			goto ERROR_EXIT2;
		}
		LeaveCriticalSection(&psp->cs);

		// We don't need to lock the Context list, since it cannot grow now since the send returned, so
		// the list is held in place by the refcount on the psp.
		ReadContextList(this, psp->hContext, &CancelData.lprglpvSPMsgID, &CancelData.cSPMsgID,FALSE);
	} else {
		CancelData.dwFlags=DPCANCELSEND_ALL;
		CancelData.lprglpvSPMsgID = 0;
		CancelData.cSPMsgID       = 0;
	}
	
	CancelData.lpISP	      = this->pISP;
	CancelData.dwFlags        = 0;
	CancelData.dwMinPriority  = 0;
	CancelData.dwMaxPriority  = 0;
	
	if(this->pProtocol){
		hr=ProtocolCancel(&CancelData); // calls SP if appropriate.
	} else {
		hr=CALLSP(this->pcbSPCallbacks->Cancel,&CancelData);
	}

ERROR_EXIT2:
	if(psp){
		pspDecRef(this, psp);
	}	

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
	
} // DP_CancelMessage

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CancelMessage"

HRESULT DPAPI DP_CancelPriority(LPDIRECTPLAY lpDP, DWORD dwMinPriority, DWORD dwMaxPriority,DWORD dwFlags)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_CANCELDATA CancelData;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(!this->pcbSPCallbacks->Cancel && !(this->pProtocol)){
		hr=DPERR_UNSUPPORTED;
		goto ERROR_EXIT;
	}

	if(dwFlags){
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	if(dwMinPriority > dwMaxPriority){
		hr=DPERR_INVALIDPARAMS;
		goto ERROR_EXIT;
	}

	if(dwMaxPriority > DPSEND_MAX_PRIORITY){
		hr=DPERR_INVALIDPARAMS;
		goto ERROR_EXIT;
	}

	CancelData.lpISP	      = this->pISP;
	CancelData.dwFlags        = DPCANCELSEND_PRIORITY;
	CancelData.lprglpvSPMsgID = NULL;
	CancelData.cSPMsgID       = 0;
	CancelData.dwMinPriority  = dwMinPriority;
	CancelData.dwMaxPriority  = dwMaxPriority;

	if(this->pProtocol){
		hr=ProtocolCancel(&CancelData); // calls SP if appropriate
	} else {
		hr=CALLSP(this->pcbSPCallbacks->Cancel,&CancelData);
	}

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
} // DP_CancelPriority

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetMessageQueue"

extern HRESULT DPAPI DP_GetMessageQueue(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_GETMESSAGEQUEUEDATA GetMessageQueueData;
	LPMESSAGENODE pmsn;
	LPDPLAYI_PLAYER lpPlayer;
	DWORD dwPlayerFlags;


	DWORD dwNumMsgs;
	DWORD dwNumBytes;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(!dwFlags){
		dwFlags=DPMESSAGEQUEUE_SEND;
	}

	if( (!(dwFlags & (DPMESSAGEQUEUE_SEND|DPMESSAGEQUEUE_RECEIVE) ) ) || 
		((dwFlags-1 & dwFlags)!=0)
	  )
	{
		// an invalid flag bit is set OR more than one flag bit is set.
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	// Parameter Validation - yada yada yada
	if(dwFlags==DPMESSAGEQUEUE_SEND){	
	
		if(!this->pcbSPCallbacks->GetMessageQueue && !(this->pProtocol)){
			hr=DPERR_UNSUPPORTED;
			goto ERROR_EXIT;
		}
		
		if(idFrom){
		
			// can only get send queue for local from players.
			
			lpPlayer=PlayerFromID(this,idFrom);

			// make sure this is not a group.
			if (!VALID_DPLAY_PLAYER(lpPlayer)) { //BUGBUG: only works because players/groups differ in size!
				lpPlayer=NULL;
			}
			if(lpPlayer){
				dwPlayerFlags=lpPlayer->dwFlags;
			}	

			if(!lpPlayer || !(dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
		
		if(idTo){
			// can only get receive queue for local to players
			lpPlayer=PlayerFromID(this,idTo);
			
			if(!lpPlayer) {
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}

			// Route messages through system player on host unless DX3 in game
			// Messages delivered by host use the embedded FromID in the message
			// to notify the receiver who the message was from.

			if (!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		   		(! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ))
			{
				ASSERT(lpPlayer->dwIDSysPlayer);
				idTo = lpPlayer->dwIDSysPlayer;
			}

		}
		
	} else {
		// must be asking for the receive queue
		if(idTo){
			// can only get receive queue for local to players
			lpPlayer=PlayerFromID(this,idTo);
			if(lpPlayer){
				dwPlayerFlags=lpPlayer->dwFlags;
			}	
			
			if(!lpPlayer || !(dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
		// can't receive messages from a group.
		if(idFrom){
		
			lpPlayer=PlayerFromID(this,idFrom);
			
			if (!VALID_DPLAY_PLAYER(lpPlayer)) { //BUGBUG: only works because players/groups differ in size!
				lpPlayer=NULL;
			}

			if(!lpPlayer){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
	}


	if(dwFlags == DPMESSAGEQUEUE_SEND){

		// Get the send queue from the SP.
	
		GetMessageQueueData.lpISP   = this->pISP;
		GetMessageQueueData.dwFlags = 0;
		GetMessageQueueData.idFrom  = idFrom;
		GetMessageQueueData.idTo    = idTo;
		if(lpdwNumMsgs){
			GetMessageQueueData.lpdwNumMsgs = &dwNumMsgs;
		} else {
			GetMessageQueueData.lpdwNumMsgs = NULL;
		}
		if(lpdwNumBytes){
			GetMessageQueueData.lpdwNumBytes = &dwNumBytes;
		} else {
			GetMessageQueueData.lpdwNumBytes = NULL;
		}
		if(this->pProtocol){
			hr=ProtocolGetMessageQueue(&GetMessageQueueData);
		} else {
			hr=CALLSP(this->pcbSPCallbacks->GetMessageQueue,&GetMessageQueueData);
		}	

		if(FAILED(hr)){
			goto ERROR_EXIT;
		}
		

	} else {

		ASSERT(dwFlags == DPMESSAGEQUEUE_RECEIVE);
		// Get DPLAY's receive Queue
	
	
		dwNumMsgs  = 0;
		dwNumBytes = 0;

		pmsn = this->pMessageList;

		// optimization: if we don't specify to or from, and don't want bytes, just
		//	grab the count
		if (!idTo && !idFrom && !lpdwNumBytes)
		{
			dwNumMsgs = this->nMessages;
		} 
		else			// the normal way
		{
			while (pmsn)
			{
				BOOL count = TRUE;

				if (idTo && idTo != pmsn->idTo)
				{
					count = FALSE;
				}	

				if (idFrom && idFrom != pmsn->idFrom)
				{
					count = FALSE;
				}	

				if (count)
				{
					dwNumMsgs++;
					dwNumBytes+=pmsn->dwMessageSize;
				}
				pmsn = pmsn->pNextMessage;
			}
		}
	}
	
	TRY {
		if(lpdwNumMsgs){
			*lpdwNumMsgs = dwNumMsgs;
		}
		if(lpdwNumBytes){
			*lpdwNumBytes = dwNumBytes;
		}	
	} EXCEPT( EXCEPTION_EXECUTE_HANDLER ) {
        DPF_ERR( "GetMessageQueue: Exception encountered setting returned values" );
        hr=DPERR_INVALIDPARAMS;
    }
 

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
} // DP_GetMessageQueue

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetGroupData"  

// called by internalcreateplayer,internalsetname,internalsetdata
HRESULT CheckSetDataFlags(DWORD dwFlags)
{
	// check flags
	if ( dwFlags & ~(DPSET_REMOTE | DPSET_LOCAL | DPSET_GUARANTEED)) 
		
	{
		DPF_ERR("bad flags");
		return DPERR_INVALIDPARAMS;	
	}
	if ( (dwFlags & DPSET_LOCAL) && (dwFlags & DPSET_GUARANTEED) )
	{
		DPF_ERR(" invalid dwFlags combination");
		return DPERR_INVALIDPARAMS;
	}
	
	return DP_OK;

} // CheckSetDataFlags

/*
 ** InternalSetData
 *
 *  CALLED BY:	DP_SetGroupData and DP_SetPlayerData, and by handler.c 
 *
 *  PARAMETERS:	
 * 			fPropagate is set to TRUE when called from the DP_SetGroupData or DP_SetPlayerData - this
 * 			means we need to propagate the data - we were called by the client.	If we're called 
 *			by handler.c, fPropagate is set to FALSE.  we just set the data on the	local machine.
 *
 *  DESCRIPTION:
 *		updates the player data.
 *		propagates to all remote machine if dwFlags = DPSET_REMOTE and fPropagate is TRUE
 *
 */
HRESULT InternalSetData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags,BOOL fPlayer,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check src player        
 		if (fPlayer)
		{
	        lpPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
		    lpGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// cast the group so we can just use pPlayer
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
		}

		// check flags
		hr = CheckSetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			return hr;
		}

		// check permissions for remote data
		if(fPropagate && !(dwFlags & DPSET_LOCAL))
		{
			// this was generated by the local client
			// make sure they have permission
			ASSERT(this->pSysPlayer);
			if (this->pSysPlayer->dwID != lpPlayer->dwIDSysPlayer)
			{
				DPF_ERR("attempt to set data on player / group not owned by this client");
				return DPERR_ACCESSDENIED;
			}
		}
		
		// check blob
		if (dwDataSize && !VALID_READ_STRING_PTR(pvData,dwDataSize)) 
		{
	        DPF_ERR( "bad player blob" );
	        return DPERR_INVALIDPARAMS;
		}
    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
   
	// If this is a lobby-owned object, and it's remote, then call the lobby
	if(!(dwFlags & DPSET_LOCAL) && IS_LOBBY_OWNED(this))
	{
		// We need to drop the lock in case the GUARANTEED flag is set.
		// In that case, the lobby provider's receive thread needs to
		// be able to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		if(fPlayer)
		{
			hr = PRV_SetPlayerData(this->lpLobbyObject, id, pvData,
						dwDataSize, dwFlags);
		}
		else
		{
			hr = PRV_SetGroupData(this->lpLobbyObject, id, pvData,
						dwDataSize, dwFlags);
		}

		// Take the lock again
		ENTER_DPLAY();

		// If we failed, exit here
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling SetPlayer/GroupData in the lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

	// set up the data
	hr = DoPlayerData(lpPlayer,pvData,dwDataSize,dwFlags);
    if (FAILED(hr)) 
    {
		DPF_ERRVAL("could not set data - hr = 0x%08lx\n",hr);
		return hr;
    }
	
	if (!(dwFlags & DPSET_LOCAL))
	{
		// tell the world
		if (fPropagate)
		{
			if (dwFlags & DPSET_GUARANTEED)
			{
				ASSERT(1 == gnDPCSCount);
				LEAVE_DPLAY();
				hr = SendDataChanged(this,lpPlayer,fPlayer,DPSEND_GUARANTEE);
				ENTER_DPLAY();
			}	
			else
			{
				hr = SendDataChanged(this,lpPlayer,fPlayer,0);
			}
		}
	}

	return hr;

} // InternalSetData

HRESULT DPAPI DP_SetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetData(lpDP,id,pData,dwDataSize,dwFlags,FALSE,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetGroupData   


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetPlayerData"

HRESULT DPAPI DP_SetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetData(lpDP,id,pData,dwDataSize,dwFlags,TRUE,TRUE);
															  
	LEAVE_DPLAY();
	
	return hr;
	
} // DP_SetPlayerData  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetGroupName/SetPlayerName"

/*
 ** InternalSetName
 *
 *  CALLED BY:	DP_SetGroupName and DP_SetPlayerName, and by handler.c 
 *
 *  PARAMETERS:	
 * 			fPropagate is set to TRUE when called from the DP_SetGroupName or DP_SetPlayerName - this
 * 			means we need to propagate the Name - we were called by the client.	If we're called 
 *			by handler.c, fPropagate is set to FALSE.  we just set the Name on the	local machine.
 *
 *  DESCRIPTION:
 *		updates the player Name.
 *		propagates to all remote machine if dwFlags = DPSET_REMOTE and fPropagate is TRUE
 *
 */
HRESULT InternalSetName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,BOOL fPlayer,
	DWORD dwFlags,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPWSTR lpszShortName,lpszLongName;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check src player        
 		if (fPlayer)
		{
	        lpPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        lpGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// cast the group so we can just use pPlayer
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
		}

		// check flags
		hr = CheckSetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			return hr;
		}

		// check permissions for remote data
		if(fPropagate && !(dwFlags & DPSET_LOCAL))
		{
			// this was generated by the local client
			// make sure they have permission
			ASSERT(this->pSysPlayer);
			if (this->pSysPlayer->dwID != lpPlayer->dwIDSysPlayer)
			{
				DPF_ERR("attempt to set name on player / group not owned by this client");
				return DPERR_ACCESSDENIED;
			}
		}

        if (pName && !VALID_READ_DPNAME_PTR(pName))
        {
			DPF_ERR("invalid dpname pointer");
			return DPERR_INVALIDPARAMS;
        }

		// check strings
		if (pName)
		{
			lpszShortName = pName->lpszShortName;
			lpszLongName = pName->lpszLongName;
			if ( lpszShortName && 
				!VALID_READ_STRING_PTR(lpszShortName,WSTRLEN_BYTES(lpszShortName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
			if ( lpszLongName && 
				!VALID_READ_STRING_PTR(lpszLongName,WSTRLEN_BYTES(lpszLongName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared.  If it is cleared, it means the lobby called into us
	// to set the name of a remote group.  We don't want to call the lobby
	// back in that case.
	if(!(dwFlags & DPSET_LOCAL) && (IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// We need to drop the lock in case the GUARANTEED flag is set.  In
		// that case, the lobby provider's receive thread needs to be able
		// to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		if(fPlayer)
		{
			hr = PRV_SetPlayerName(this->lpLobbyObject, id, pName, dwFlags);
		}
		else
		{
			hr = PRV_SetGroupName(this->lpLobbyObject, id, pName, dwFlags);
		}

		// Take the lock back
		ENTER_DPLAY();

		// If it failed, just bail here
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling SetPlayer/GroupName in lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

	// set up the name
	hr = DoPlayerName(lpPlayer,pName);
    if (FAILED(hr)) 
    {
		DPF_ERRVAL("could not set name - hr = 0x%08lx\n",hr);
		return hr;
    }

	if (!(dwFlags & DPSET_LOCAL))
	{
		if (fPropagate)
		{
			if (dwFlags & DPSET_GUARANTEED)
			{
				hr = SendNameChanged(this,lpPlayer,fPlayer,DPSEND_GUARANTEED);
			}											  
			else
			{
				hr = SendNameChanged(this,lpPlayer,fPlayer,0);
			} 	
		}
	}

	return hr;

} // InternalSetName

HRESULT DPAPI DP_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetName(lpDP,id,pName,FALSE,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetPlayerName"

HRESULT DPAPI DP_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetName(lpDP,id,pName,TRUE,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "InternalSetSessionDesc"
HRESULT InternalSetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc, DWORD dwFlags, BOOL fPropagate)
{
	LPDPLAYI_DPLAY this;
    HRESULT hr;
    DPCAPS dpCaps;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			return DPERR_NOSESSIONS;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			return DPERR_INVALIDPARAMS;
		}
		if (!VALID_DPSESSIONDESC2_FLAGS(lpsdDesc->dwFlags))
		{
			DPF_ERR("invalid session desc flags");
			return DPERR_INVALIDFLAGS;
		}

		// check strings
		if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
			WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
			WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
        // no flags are supported
        if (dwFlags != 0)
        {
	        DPF_ERR( "Invalid flags" );
	        return DPERR_INVALIDPARAMS;
        }

		// This method is not supported for lobby connections
		if(IS_LOBBY_OWNED(this))
		{
			DPF_ERR("SetSessionDesc not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // check to make sure there is a system player
	if (!this->pSysPlayer)
	{
		DPF(1,"SetSessionDesc - session not currently open - failing");
		return E_FAIL;
	}

    // only a host can change the session desc
    // fPropagate is used here to distinguish between a user call and an
    // internal call (e.g. from handler.c)
    if ( fPropagate && !(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
    {
		DPF_ERR("A non-host can't set session desc");
		return DPERR_ACCESSDENIED;
    }

    // can't set max allowed players to less than current players
    // unless it is zero which means unlimited max players
	if ((lpsdDesc->dwMaxPlayers > 0) &&
        (lpsdDesc->dwMaxPlayers < this->lpsdDesc->dwCurrentPlayers))
	{
		DPF_ERR("can't set max players < current players");
		return DPERR_INVALIDPARAMS;
	}

    // get the caps so we can check how many max players sp allows
    dpCaps.dwSize = sizeof(DPCAPS);
    hr = InternalGetCaps(lpDP, 0, &dpCaps, FALSE, 0);
    if (FAILED(hr))
    {
        DPF_ERR("couldn't get caps for the current session");
        return hr;
    }

	// we don't allow reseting the following flags 
    //   DPSESSION_NOMESSAGEID, 
    //   DPSESSION_KEEPALIVE, 
    //   DPSESSION_MIGRATEHOST
    //   DPSESSION_SECURESERVER
    //   DPSESSION_CLIENTSERVER
    // all other flags are OK
    
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ==
			(lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)) )
	{
		DPF_ERR("error - can not reset DPSESSION_NOMESSAGEID");
		return DPERR_INVALIDPARAMS;
	}
	
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE) ==
			(lpsdDesc->dwFlags & DPSESSION_KEEPALIVE)) )
	{
		DPF_ERR("error - can not reset DPSESSION_KEEPALIVE");
		return DPERR_INVALIDPARAMS;
	}
	
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) ==
			(lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST)) )
	{
		DPF_ERR("error - can not reset DPSESSION_MIGRATEHOST");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_SECURESERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_SECURESERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_CLIENTSERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_MULTICASTSERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) == 
			(lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL)) )
	{
		DPF_ERR("error - can not change DPSESSION_DIRECTPLAYPROTOCOL\n");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_OPTIMIZELATENCY) == 
			(lpsdDesc->dwFlags & DPSESSION_OPTIMIZELATENCY)) )
	{
		DPF_ERR("error - can not change DPSESSION_OPTIMIZELATENCY\n");
		return DPERR_INVALIDPARAMS;
	}

    // update the existing session desc
	this->lpsdDesc->dwFlags = lpsdDesc->dwFlags;
	this->lpsdDesc->dwMaxPlayers = lpsdDesc->dwMaxPlayers;
	this->lpsdDesc->dwUser1 = lpsdDesc->dwUser1;
	this->lpsdDesc->dwUser2 = lpsdDesc->dwUser2;
	this->lpsdDesc->dwUser3	= lpsdDesc->dwUser3;
	this->lpsdDesc->dwUser4	= lpsdDesc->dwUser4;

	// copy strings
	if (this->lpsdDesc->lpszSessionName) DPMEM_FREE(this->lpsdDesc->lpszSessionName);
	GetString(&(this->lpsdDesc->lpszSessionName),lpsdDesc->lpszSessionName);

	if (this->lpsdDesc->lpszPassword) DPMEM_FREE(this->lpsdDesc->lpszPassword);
	GetString(&(this->lpsdDesc->lpszPassword),lpsdDesc->lpszPassword);

    // if session has a password, setup the password required flag
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        this->lpsdDesc->dwFlags |= DPSESSION_PASSWORDREQUIRED;
    }
    else
    {
        this->lpsdDesc->dwFlags &= ~DPSESSION_PASSWORDREQUIRED;
    }

    // tell the world/local players
	if (fPropagate)
	{
		// send this message guaranteed
	    hr = SendSessionDescChanged(this, dwFlags | DPSEND_GUARANTEED);
	}

    return hr;
} // InternalSetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetSessionDesc"
HRESULT DPAPI DP_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags)
{
    HRESULT hr;

	ENTER_DPLAY();

    hr = InternalSetSessionDesc(lpDP, lpsdDesc, dwFlags, TRUE);

    LEAVE_DPLAY();

    return hr;
} // DP_SetSessionDesc  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SecureOpen"

HRESULT DPAPI DP_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags,                             
    LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }

	    if (this->lpsdDesc)
	    {
			LEAVE_ALL();
		    DPF_ERR("session already open!");
		    return DPERR_ALREADYINITIALIZED;
	    }

        // validate regular open params
        hr = ValidateOpenParams(this,lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
		    LEAVE_ALL();
		    return hr;
        }

        // validate the additional params
        // null lpSecDesc is ok, we'll use the default
        if (lpSecDesc)            
        {
            // app passed in a security desc 

            // can't pass security desc to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed a security description while creating an unsecure session");                
	            goto INVALID_PARAMS_EXIT;
            }
            // join case will be checked after we find the session in our list

            // need to be hosting
            if (dwFlags & DPOPEN_JOIN)
            {
                DPF_ERR("Can't pass a security description while joining");                
	            goto INVALID_PARAMS_EXIT;
            }

            if (!VALID_READ_DPSECURITYDESC(lpSecDesc)) 
            {
    			DPF_ERR("invalid security desc");
	            goto INVALID_PARAMS_EXIT;
            }
	        if (!VALID_DPSECURITYDESC_FLAGS(lpSecDesc->dwFlags))
	        {
  		        DPF_ERRVAL("invalid flags (0x%08x) in security desc!",lpSecDesc->dwFlags);
                hr=DPERR_INVALIDFLAGS;
                goto CLEANUP_EXIT;
	        }
		    if ( lpSecDesc->lpszSSPIProvider && !VALID_READ_STRING_PTR(lpSecDesc->lpszSSPIProvider,
			    WSTRLEN_BYTES(lpSecDesc->lpszSSPIProvider)) ) 
		    {
	            DPF_ERR( "bad SSPI provider name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpSecDesc->lpszCAPIProvider && !VALID_READ_STRING_PTR(lpSecDesc->lpszCAPIProvider,
			    WSTRLEN_BYTES(lpSecDesc->lpszCAPIProvider)) ) 
		    {
	            DPF_ERR( "bad CAPI provider name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
        }
        // null lpCredentials is ok, sspi will pop the dialg
        if (lpCredentials)            
        {
            // app passed in credentials

            // can't pass credentials to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed credentials while creating an unsecure session");                
	            goto INVALID_PARAMS_EXIT;
            }
            // join case will be checked after we find the session in our list
            
            if (!VALID_READ_DPCREDENTIALS(lpCredentials)) 
            {
    			DPF_ERR("invalid credentials structure");
	            goto INVALID_PARAMS_EXIT;
            }
	        if (!VALID_DPCREDENTIALS_FLAGS(lpCredentials->dwFlags))
	        {
  		        DPF_ERRVAL("invalid flags (0x%08x) in credentials!",lpCredentials->dwFlags);
                hr=DPERR_INVALIDFLAGS;
                goto CLEANUP_EXIT;
	        }
		    if ( lpCredentials->lpszUsername && !VALID_READ_STRING_PTR(lpCredentials->lpszUsername,
			    WSTRLEN_BYTES(lpCredentials->lpszUsername)) ) 
		    {
	            DPF_ERR( "bad user name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpCredentials->lpszPassword && !VALID_READ_STRING_PTR(lpCredentials->lpszPassword,
			    WSTRLEN_BYTES(lpCredentials->lpszPassword)) ) 
		    {
	            DPF_ERR( "bad password string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpCredentials->lpszDomain && !VALID_READ_STRING_PTR(lpCredentials->lpszDomain,
			    WSTRLEN_BYTES(lpCredentials->lpszDomain)) ) 
		    {
	            DPF_ERR( "bad domain name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr=DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }			        

	hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,lpSecDesc,lpCredentials);

CLEANUP_EXIT:
	LEAVE_ALL();
    return hr;

INVALID_PARAMS_EXIT:
	hr=DPERR_INVALIDPARAMS;
	goto CLEANUP_EXIT;
	
}//DP_SecureOpen

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerAccount"

// take a pointer to a buffer, stick an account desc in it, slap the strings
// on the end.
HRESULT InternalGetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	UINT nNameLen=0; // user name length, in bytes
	HRESULT hr;
	LPDPACCOUNTDESC pAccountDesc;
    PCtxtHandle phContext;
    DWORD dwBufferSize=0;
    LPDPLAYI_PLAYER pPlayer;
    LPWSTR pwszUserName=NULL;
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

        if (!VALID_DPACCOUNTDESC_FLAGS(dwFlags))
        {
  		    DPF_ERRVAL("invalid flags (0x%08x)",dwFlags);
            return DPERR_INVALIDFLAGS;
        }

        // need to have a session
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before getting account desc!");
			return DPERR_NOSESSIONS;
		}

        // must be a secure session
        if (!SECURE_SERVER(this))
        {
            DPF_ERR("session is not secure!");
            return DPERR_UNSUPPORTED;
        }

        // allowed only on a nameserver
        if (!IAM_NAMESERVER(this))
        {
            DPF_ERR("can't get account info on the client!");
            return DPERR_ACCESSDENIED;
        }

		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;

		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

        // get the player structure for the specified id
        pPlayer = PlayerFromID(this,dpid);
        if (!pPlayer)
        {
            DPF_ERRVAL("Failed to get security context handle - Invalid player id %d", dpid);
            return DPERR_INVALIDPLAYER;
        }

        if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
        {
            // assert so we notice!
            ASSERT(FALSE);
            DPF_ERR("Failed to get security context handle - a system player was passed");
            return DPERR_INVALIDPLAYER;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // only system players have a security context handle
    // so get the corresponding system player
    pPlayer = PlayerFromID(this,pPlayer->dwIDSysPlayer);
    if (!pPlayer)
    {
        DPF_ERRVAL("Failed to locate system player (%d)",pPlayer->dwIDSysPlayer);
        return DPERR_INVALIDPLAYER;
    }

    // check if they are asking for nameserver's account description
    if (pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
    {
        // yep, can't do it
        DPF_ERR("Can't get nameserver's account description");
        return DPERR_INVALIDPLAYER;
    }

    // if we reach here means player is logged in, so just grab the context handle
    // belonging to the system player
    phContext = &(pPlayer->pClientInfo->hContext);

    // get user name associated with this security context
    hr = OS_QueryContextUserName(phContext,&pwszUserName);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to get user name associated: hr=0x%08x",hr);
        return hr;
    }

    // remember the length of the username
    nNameLen = WSTRLEN(pwszUserName);

    // calculate the required buffer size
    dwBufferSize = sizeof(DPACCOUNTDESC);

    // add the size of username
    if (fAnsi)
    {
        dwBufferSize += nNameLen;
    }
    else
    {
        dwBufferSize += WSTRLEN_BYTES(pwszUserName);
    }

    // check if user passed in a big enough buffer
	if (*pdwSize < dwBufferSize)
	{
		*pdwSize = dwBufferSize;
        hr = DPERR_BUFFERTOOSMALL;
        goto CLEANUP_EXIT;
	}

	// zero buffer passed in
	ZeroMemory(pvBuffer,*pdwSize);
    // use the buffer as an accountdesc
	pAccountDesc = (LPDPACCOUNTDESC) pvBuffer;
    pAccountDesc->dwSize = sizeof(DPACCOUNTDESC);
    // flags are zero for now

    // set buffer size to return to app
	*pdwSize = dwBufferSize;

    // copy username string into the buffer after the desc.
    if (nNameLen)
    {
		LPBYTE pbUsername = (LPBYTE)pvBuffer+sizeof(DPACCOUNTDESC);

        // return string in the proper format to the app
        if (fAnsi)
        {
            // app called the ansi interface, so convert string to ansi before copying
            WideToAnsi(pbUsername,pwszUserName,nNameLen);
            pAccountDesc->lpszAccountIDA = (LPSTR)pbUsername;
        }
        else
        {
            // app called the unicode interface, so just copy the strings over
            wcscpy((LPWSTR)pbUsername, pwszUserName);
            pAccountDesc->lpszAccountID = (LPWSTR)pbUsername;
        }
    }

    // success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:
    if (pwszUserName) DPMEM_FREE(pwszUserName);
	return hr;
} // InternalGetPlayerAccount


HRESULT DPAPI DP_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetPlayerAccount(lpDP,dpid,dwFlags,pvBuffer,pdwSize,FALSE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerAccount


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SendChatMessage"
/*
 ** DP_SendChatMessage
 *
 *  PARAMETERS:	
 * 			
 *  DESCRIPTION:
 *		Send a chat message to the appropriate players
 *
 */
HRESULT DPAPI DP_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER pPlayerFrom = NULL, pPlayerTo = NULL;
	LPWSTR lpszMessage = NULL;
	BOOL bToPlayer = FALSE;

	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto EXIT_SENDCHATMESSAGE;
        }

		// check src player        
		pPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr = DPERR_INVALIDPLAYER;
			goto EXIT_SENDCHATMESSAGE;
		}

		// if the player from is remote, fail the call
		if(!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			DPF_ERR("Cannot send a chat message FROM a remote player");
			hr = DPERR_ACCESSDENIED;
			goto EXIT_SENDCHATMESSAGE;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			pPlayerTo = PlayerFromID(this,idTo);
			if(VALID_DPLAY_PLAYER(pPlayerTo))
			{
				bToPlayer = TRUE;
			}
			else
			{		  
				pPlayerTo = (LPDPLAYI_PLAYER)GroupFromID(this,idTo);
				if (!VALID_DPLAY_GROUP(((LPDPLAYI_GROUP)pPlayerTo))) 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					hr = DPERR_INVALIDPARAMS;
					goto EXIT_SENDCHATMESSAGE;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if(!VALID_CHAT_FLAGS(dwFlags))
		{
			DPF_ERR("Invalid flags");
			hr = DPERR_INVALIDFLAGS;
			goto EXIT_SENDCHATMESSAGE;
		}

		// check DPCHAT struct
		if(!VALID_READ_DPCHAT(lpMsg))
		{
			DPF_ERR("Invalid DPCHAT structure");
			hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGE;
		}

		// verify the flags inside the DPCHAT struct (none currently defined)
		if(lpMsg->dwFlags)
		{
			DPF_ERR("Invalid flags in the DPCHAT structure");
			hr = DPERR_INVALIDFLAGS;
			goto EXIT_SENDCHATMESSAGE;
		}
		
		// check message string
		lpszMessage = lpMsg->lpszMessage;
		if ( !lpszMessage ||
			!VALID_READ_STRING_PTR(lpszMessage,WSTRLEN_BYTES(lpszMessage)) ) 
		{
		    DPF_ERR( "bad string pointer" );
		    hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGE;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr =  DPERR_INVALIDPARAMS;
		goto EXIT_SENDCHATMESSAGE;
    }
	
	// do the send
	if(!IS_LOBBY_OWNED(this))
	{
		// just send to the player
		hr = SendChatMessage(this, pPlayerFrom, pPlayerTo, dwFlags, lpMsg, bToPlayer);
	}
	else
	{
		// We need to drop the lock in case the GUARANTEED flag is set.  In
		// that case, the lobby provider's receive thread needs to be able
		// to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_SendChatMessage(this->lpLobbyObject, idFrom, idTo, dwFlags, lpMsg);

		// Take the lock back
		ENTER_DPLAY();
	}

	if (FAILED(hr))
	{
		DPF_ERRVAL("SendChatMessage failed - hr = 0x%08lx\n",hr);
	}


EXIT_SENDCHATMESSAGE:

	LEAVE_ALL();

	return hr;

} // DP_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupParent"
/*
 ** DP_GetGroupParent
 *
 *  PARAMETERS:	
 * 			
 *  DESCRIPTION:
 *		Get the DPID of a group's parent group
 *
 */
HRESULT DPAPI DP_GetGroupParent(LPDIRECTPLAY lpDP, DPID idGroup, LPDPID pidParent)	
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;


	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

	    pGroup = GroupFromID(this,idGroup);
	    if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == idGroup)) 
	    {
			LEAVE_DPLAY();
			DPF_ERRVAL("invalid group id = %d", idGroup);
	        return DPERR_INVALIDGROUP;
	    }

		if (!VALID_DWORD_PTR(pidParent))
		{
			LEAVE_DPLAY();
			DPF_ERR("invalid pidParent");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	

	// Fill in the group's parent
	*pidParent = pGroup->dwIDParent;

	LEAVE_DPLAY();
	return DP_OK;

} // DP_GetGroupParent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\enum.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.c
 *  Content:	DirectPlay callbacks
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  1/96	andyco	created it
 *	3/1/96	andyco	added enum players + groups
 *	4/8/96	andyco	moved leave_dplay past callsp in enumsessions. now, only
 *					one thread at a time inside sp.
 *	5/16/96	andyco	dplay2 - internal xxx
 *	6/19/96	kipo	Bug #1960. DebugFillStringA() and DebugFillString()
 *					were not checking for NULL string parameters, which are
 *					allowed if you pass in NULL for the short or long names in
 *					a PlayerName structure.
 *					Bug #2047. Changed DP_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Bug #2013. CheckSessionDesc() was not checking for valid password
 *					pointers before doing string operations on the passwords.
 *	6/20/96	andyco	added WSTRLEN_BYTES
 *	6/22/96	andyco	added guid + password to enumsessions request
 *	6/23/96	kipo	updated for latest service provider interfaces.
 *	6/24/96	kipo	changed guidGame to guidApplication.
 *  7/8/96  ajayj   fixed up parameter ordering in callback function calls for
 *                  LPDPENUMPLAYERSCALLBACK2 and LPDPENUMSESSIONSCALLBACK2
 *  7/11/96 ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
 *  7/27/96 kipo	Bug #2682. InternalEnumPlayers() with the DPENUMPLAYERS_GROUP flag
 *					set was calling DP_EnumGroups() instead of InternalEnumGroups().
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *	8/6/96	andyco	version in commands.  extensible on the wire support.
 *	8/8/96	andyco	changed docallback to check enum flags (ENUM_LOCAL, etc.) and
 *					to check for sysplayers (moved from enumplayers).  changed
 *					internalenumxxx to check bResult from docallback.  bug 2874.
 *					modified getdefaulttimeout to be the method called by all dplay
 *					functions needing a timeout.  bug 2235,2329.
 *  8/21/96	andyco	check flags passed to enum. bug 3289
 *	8/22/96	andyco	oops.  reset dwflags when calling enumgroups from enumplayers.
 *  9/30/96 sohailm bug #3060: drop dplay lock(s) during enum callbacks
 *                  added CopySessionDesc2() and DoSessionCallbacks() functions
 *                  modified GetPlayerName() to get new strings for UNICODE instead of copying ptrs
 *  10/2/96 sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
 *                  where appropriate.
 * 10/12/96 sohailm renamed goto labels for consistency
 *                  added error checking to CopySessionDesc2()
 * 10/12/96	andyco 	don't enum sysgroup.
 * 	1/16/97 sohailm if flags are not specified to EnumSessions, now we return
 *                  only the available sessions (4491).
 *	1/15/97	andyco	added dperr_invalidgroup
 *	3/7/97	andyco	async enumsessions
 *	3/4/97	kipo	pulled nPlayers and nGroups into local variables instead of
 *					using the this pointer in InternalEnumGroups/Player/GroupPlayers
 *					so reentrancy when we drop the lock doesn't hose us.
 *	3/10/97	andyco	drop dplay + service locks b4 calling dp_close on enumplayers(session)
 *	3/12/97	myronth	lobby support for EnumSessions                  
 *	3/13/97	myronth	flagged unsupported lobby methods as such
 *  3/13/97 sohailm updated call to InternalOpenSession() to reflect changes in params.
 *	3/17/97	myronth	Removed check for lobby in EnumGroups/EnumPlayers
 *	3/20/97	myronth	Removed check for lobby in EnumGroupPlayers, use macro
 *  3/24/97 sohailm Updated DoSessionsCallback to skip filtering sessions on the client
 *                  if they are DX5 or greater
 *  3/27/97 sohailm Return an error, if players or groups in current session are enumerated
 *                  before opening the session (4973)
 *	4/2/97	myronth	EnumPlayers always returns DPERR_ACCESSDENIED for lobby connections
 *	4/7/97	myronth	EnumGroupPlayers now returns DPERR_ACESSDENIED for
 *					lobby connections with an idGroup of DPID_ALLPLAYERS, and
 *					also for EnumGroups and EnumGroupPlayers in remote sessions
 *	4/20/97	andyco	group in group 
 *	5/05/97	kipo	Added CallAppEnumSessionsCallback() to work around Outlaws bug.
 *	5/06/97	kipo	Fixed stack save/restore for non-optimized builds
 *	5/8/97	andyco	Fixed fix stack save/restore
 *	5/18/97	kipo	Updated for new flags for EnumPlayer/Groups; do better filtering
 *					for players and groups in DoCallback().
 *	5/23/97	kipo	Added support for return status codes
 *	10/21/97myronth	Added support for hidden groups
 *	10/29/97myronth	Added support for owner flag on EnumGroupPlayers
 *	11/5/97	myronth	Expose lobby ID's as DPID's in lobby sessions
 *  3/26/98 aarono  Fix InternalEnumGroupPlayers assumptions about when pPlayer
 *                  can become invalid.
 *  5/11/98 a-peterz Don't reenter async CallSPEnumSessions() (#22920)
 ***************************************************************************/

 // todo - docallback should pass copy of pvPlayerData
 // todo - do we use bContinue w/ EnumGroups / EnumPlayers?
#include "dplaypr.h"
#include <memalloc.h>

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Enum"

#ifdef DEBUG 
#define DEBUGFILLSTRINGA DebugFillStringA
#define DEBUGFILLSTRING DebugFillString
#else
#define DEBUGFILLSTRING(lpsz)
#define DEBUGFILLSTRINGA(lpsz)
#endif 

#ifdef DEBUG

void DebugFillStringA(LPSTR psz)
{
	UINT iStrLen;

	if (psz == NULL)		// null pointers are allowed
		return;

	iStrLen = STRLEN(psz);
	memset(psz,0xfe,iStrLen);
	
	return ;	
} // DebugFillStringA

void DebugFillString(LPWSTR psz)
{
	UINT iStrLen;

	if (psz == NULL)		// null pointers are allowed
		return;
	
	iStrLen = WSTRLEN_BYTES(psz);
	memset(psz,0xfe,iStrLen);
	
	return ;	
} // DebugFillString

#endif // DEBUG


// 
// fill in a playername struct for the player (or group).
// if ansi strings haven't been created yet for this player, create 'em!
// 
void GetPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName,BOOL fAnsi)
{
	memset(pName,0,sizeof(DPNAME));
	pName->dwSize = sizeof(DPNAME);

	if (fAnsi)
	{
	    GetAnsiString(&(pName->lpszShortNameA),pPlayer->lpszShortName);
		GetAnsiString(&(pName->lpszLongNameA),pPlayer->lpszLongName);
	}
	else 
	{
		GetString(&(pName->lpszShortName), pPlayer->lpszShortName);
		GetString(&(pName->lpszLongName), pPlayer->lpszLongName);
	}

	return ;
} // GetPlayerName

BOOL GetCallbackFlags(LPDPLAYI_PLAYER pPlayer, DWORD dwFlags,
					  LPDWORD lpdwCallbackFlags)
{
	DWORD	dwCallbackFlags;

	//
	// first determine if this player matches the filter criteria
	//

	// never enum system players
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		return (FALSE);
	}
	
	// they want local players
	if (dwFlags & DPENUMPLAYERS_LOCAL)
	{
		// not a local player
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			return (FALSE);
		}
	}
	
	// they want remote players
	if (dwFlags & DPENUMPLAYERS_REMOTE)
	{
		// not a remote player
		if (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			return (FALSE);
		}
	}
	
	// they want server players
	if (dwFlags & DPENUMPLAYERS_SERVERPLAYER)
	{
		// not a server player
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))
		{
			return (FALSE);
		}
	}

	// they want spectators
	if (dwFlags & DPENUMPLAYERS_SPECTATOR)
	{
		// not a spectator
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR))
		{
			return (FALSE);
		}
	}

	// they want the group owner
	if (dwFlags & DPENUMPLAYERS_OWNER)
	{
		// not the group owner
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_OWNER))
		{
			return (FALSE);
		}
	}

	// they want staging areas
	if (dwFlags & DPENUMGROUPS_STAGINGAREA)
	{
		// not a staging area
		if (!(pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA))
		{
			return (FALSE);
		}
	}

	// they want hidden groups
	if (dwFlags & DPENUMGROUPS_HIDDEN)
	{
		// not a hidden group
		if (!(pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN))
		{
			return (FALSE);
		}
	}

	//
	// now build the flags to be passed to the callback
	//

	// flags start out set to the flags passed to Enum_xxx
	dwCallbackFlags = dwFlags;

	// player is a server player
	if (pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
		dwCallbackFlags |= DPENUMPLAYERS_SERVERPLAYER;

	// player is a spectator
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR)
		dwCallbackFlags |= DPENUMPLAYERS_SPECTATOR;

	// player is the group owner
	if (pPlayer->dwFlags & DPLAYI_PLAYER_OWNER)
		dwCallbackFlags |= DPENUMPLAYERS_OWNER;

	// group is a staging area
	if (pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA)
		dwCallbackFlags |= DPENUMGROUPS_STAGINGAREA;

	// group is hidden
	if (pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN)
		dwCallbackFlags |= DPENUMGROUPS_HIDDEN;

	// return the flags to pass to the callback
	*lpdwCallbackFlags = dwCallbackFlags;
	return (TRUE);
}

/*
 ** DoCallback
 *
 *  CALLED BY:	InternalEnumPlayers,InternalEnumGroups,InternalEnumGroupPlayers
 *
 *  PARAMETERS:
 *			pPlayerOrGroup - a LPDPLAYI_GROUP or LPDPLAYI_PLAYER struct.
 *			dwFlags - flags passed to enum
 *			pvContext - app supplied context
 *			lpEnumCallback - callback fn, either LPDPENUMPLAYERSCALLBACK or
 *				LPDPENUMPLAYERSCALLBACK2.
 *			dwEnumFlags - set by caller. ENUM_2A, or ENUM_2, or ENUM_1.
 *				indicates what type of callback fn we have (which interface 
 *				we were called from).
 *			fPlayer - whether pPlayerOrGroup is a player (TRUE) or a group.
 *
 *  DESCRIPTION:
 *			figures out what type of callback we're calling. sets up the 
 *			data structs, and calls it.
 *
 *  RETURNS:
 *			BOOL - the result of the callback.
 *
 */
BOOL DoCallback(LPDPLAYI_PLAYER pPlayer,DWORD dwFlags,LPVOID pvContext,
	LPVOID lpEnumCallback,DWORD dwEnumFlags,BOOL fPlayer)
{
	HRESULT hr = DP_OK;
	BOOL bResult;
	DWORD dwCallbackFlags;

	// get flags to pass to callback. If this fails we don't
	// need to do the callback for this player
	if (!GetCallbackFlags(pPlayer, dwFlags, &dwCallbackFlags))
	{
		// don't need to call the calback
		return TRUE;
	}
	
	switch (dwEnumFlags)
	{
		case ENUM_1:
		{
			// a dplay 10 callback
			// just get the strings and call
			LPSTR lpszShortName=NULL,lpszLongName=NULL;
            DPID idPlayer;

            // make local copies of player info to pass to the app
            idPlayer = pPlayer->dwID;
			GetAnsiString(&(lpszShortName),pPlayer->lpszShortName);
			GetAnsiString(&(lpszLongName),pPlayer->lpszLongName);

            // drop the locks 
			LEAVE_ALL();

            // call the app
			bResult = ((LPDPENUMPLAYERSCALLBACK)lpEnumCallback)(idPlayer,lpszShortName,
					lpszLongName,dwCallbackFlags,pvContext);

            // reacquire locks
			ENTER_ALL();

			DEBUGFILLSTRINGA(lpszShortName);
			DEBUGFILLSTRINGA(lpszLongName);

			if (lpszShortName) DPMEM_FREE(lpszShortName);
			if (lpszLongName) DPMEM_FREE(lpszLongName);
			
			// we're done here...
			return bResult;
		}
		
		case ENUM_2:
		case ENUM_2A:
        {
        	DPNAME PlayerName;
	        BOOL fAnsi;
            DPID idPlayer;

			// need to get a player (or group) data 
			fAnsi = (ENUM_2A == dwEnumFlags) ? TRUE : FALSE;

            // make local copies of player info to pass to the app
            idPlayer = pPlayer->dwID;
			GetPlayerName(pPlayer,&PlayerName,fAnsi);

            // drop the locks
			LEAVE_ALL();

			// call the app
			bResult = ((LPDPENUMPLAYERSCALLBACK2)lpEnumCallback)(idPlayer,fPlayer,
				&PlayerName,dwCallbackFlags,pvContext);

            // reacquire locks
			ENTER_ALL();

			// free the strings
			if (PlayerName.lpszShortNameA) DPMEM_FREE(PlayerName.lpszShortNameA);
			if (PlayerName.lpszLongNameA) DPMEM_FREE(PlayerName.lpszLongNameA);

			break;
        }

		default:
			ASSERT(FALSE);
			break;
	}
	
	return bResult;

} //DoCallback

/*
 ** EnumJoinSession
 *
 *  CALLED BY: InternalEnumPlayers,InternalEnumGroups
 *
 *  PARAMETERS:
 *			this - this ptr
 *			pGuid - instance guid of session to join
 *
 *  DESCRIPTION:
 *			finds a session, calls open on it.
 * 			called before enuming w/ DPENUMPLAYERS_SESSION
 * 			while we're trying to enum the players in a different session
 * 					*** ASSUMES SERVICE LOCK + DPLAY LOCK TAKEN ***
 * 			 		*** ASSUMES DPLAY LOCK COUNT IS @ 1 ***
 *
 *  RETURNS:   OpenSession hr, or  DPERR_NOSESSIONS if no matching
 *			session is available
 *
 */
HRESULT EnumJoinSession(LPDPLAYI_DPLAY this,LPGUID pGuid)
{
	LPSESSIONLIST pSession;
	HRESULT hr=DP_OK;

	if (this->lpsdDesc) 
	{
		DPF_ERR("DPENUMPLAYERS_SESSION flag set when session already open!");
		return E_FAIL;
	}

	pSession = FindSessionInSessionList(this,pGuid);	
	if (!pSession) 
	{
		DPF_ERR("could not find matching session to open");
		return DPERR_NOSESSIONS;
	}

	hr = InternalOpenSession(this,&(pSession->dpDesc),TRUE,DPOPEN_JOIN,FALSE,NULL,NULL);

	if (FAILED(hr)) 
	{	
		DPF(0,"enum sessions - could not open session - hr = 0x%08lx\n",hr);
		return hr;
	}

	return DP_OK;
}  // EnumJoinSession

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroupsInGroup"

// struct used to store group id's + flags while we drop locks
typedef struct 
{
	DPID 	id;
	DWORD	dwFlags;
} DPIDANDFLAGS,*LPDPIDANDFLAGS;

HRESULT DPAPI InternalEnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_SUBGROUP pSubgroup;
	BOOL bResult=TRUE;
    LPDPIDANDFLAGS pIDArray;
	DWORD nSubgroups;
	LPDPLAYI_GROUP pGroupEnum; // group passed to docallback
    UINT i;
	DWORD dwCallbackFlags; // flags we pass to callback
	
	DPF(5,"got enum GroupsInGroups ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		// If this is a lobby object, we don't allow DPID_ALLPLAYERS
		if(IS_LOBBY_OWNED(this) && (idGroup == DPID_ALLPLAYERS))
		{
			DPF_ERR("Enumerating all players is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// If this is a lobby object, we don't allow enumeration
		// of group players in the remote session
		if(IS_LOBBY_OWNED(this) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating group players in a remote session is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// system group not allowed
		if (0 == idGroup)
		{
			DPF_ERR( "Invalid group ID" );
			return DPERR_INVALIDGROUP;
		}

		// verify group ID if we're not enuming a remote session
		if (!(DPENUMPLAYERS_SESSION & dwFlags))
		{
			pGroup = GroupFromID(this,idGroup);
			if (!VALID_DPLAY_GROUP(pGroup)) 
			{
				DPF_ERR( "Invalid group ID" );
				return DPERR_INVALIDGROUP;
			}
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags 
		if (!VALID_ENUMGROUPS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDFLAGS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// enuming a remote session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
		pGroup = GroupFromID(this,idGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			hr = DPERR_INVALIDGROUP;
			goto CLEANUP_EXIT;
		}
	} // sessions

    // any players to enumerate ?
    if (!pGroup->pSubgroups || (0 == pGroup->nSubgroups))
    {
        // no players to enumerate
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(pGroup->nSubgroups * sizeof(DPIDANDFLAGS));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pSubgroup = pGroup->pSubgroups;
	nSubgroups = pGroup->nSubgroups;
    for (i=0; i < nSubgroups; i++)
    {
        ASSERT(pSubgroup);
        pIDArray[i].id = pSubgroup->pGroup->dwID;
		pIDArray[i].dwFlags = pSubgroup->dwFlags; // e.g.  DPGROUP_SHORTCUT
        pSubgroup = pSubgroup->pNextSubgroup;
    }

    // walk through the group calling by player
    for (i=0; (i < nSubgroups ) && bResult; i++)
    {        
        pGroupEnum = GroupFromID(this, pIDArray[i].id);
        // player could have been deleted while we dropped the locks
        if (VALID_DPLAY_GROUP(pGroupEnum))
        {
			// they want shortcuts
			if (dwFlags & DPENUMGROUPS_SHORTCUT)
			{
				// this is not a shortcut, so skip calling them back
				if (!(pIDArray[i].dwFlags & DPGROUP_SHORTCUT))
					continue;
			}

			// start with flags passed in
			dwCallbackFlags = dwFlags;

			// set shortcuts flag
			if (pIDArray[i].dwFlags & DPGROUP_SHORTCUT)
				dwCallbackFlags |= DPENUMGROUPS_SHORTCUT;

			bResult = DoCallback((LPDPLAYI_PLAYER)pGroupEnum, dwCallbackFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,FALSE);
        }
    }

    // free the list of player ids
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through
CLEANUP_EXIT:

    if (DPENUMPLAYERS_SESSION & dwFlags)  
	{
		LEAVE_ALL();		
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

} // InternalEnumGroupsInGroup

HRESULT DPAPI DP_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();
	
	hr = InternalEnumGroupsInGroup(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupsInGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroupPlayers"

HRESULT DPAPI InternalEnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nPlayers;
    LPDPLAYI_PLAYER pPlayer;
    UINT i;
	DPID dwGroupOwnerID;
	
	DPF(5,"got enum groupplayerss ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		// If this is a lobby object, we don't allow DPID_ALLPLAYERS
		if(IS_LOBBY_OWNED(this) && (idGroup == DPID_ALLPLAYERS))
		{
			DPF_ERR("Enumerating all players is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// If this is a lobby object, we don't allow enumeration
		// of group players in the remote session
		if(IS_LOBBY_OWNED(this) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating group players in a remote session is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// system group not allowed
		if (0 == idGroup)
		{
			DPF_ERR( "Invalid group ID" );
			return DPERR_INVALIDGROUP;
		}

		// verify group ID if we're not enuming a remote session
		if (!(DPENUMPLAYERS_SESSION & dwFlags))
		{
			pGroup = GroupFromID(this,idGroup);
			if (!VALID_DPLAY_GROUP(pGroup)) 
			{
				DPF_ERR( "Invalid group ID" );
				return DPERR_INVALIDGROUP;
			}
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags 
		if (!VALID_ENUMGROUPPLAYERS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// enuming a remote session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
		pGroup = GroupFromID(this,idGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			hr = DPERR_INVALIDGROUP;
			goto CLEANUP_EXIT;
		}
	} // sessions

    // any players to enumerate ?
    if (!pGroup->pGroupnodes || (0 == pGroup->nPlayers))
    {
        // no players to enumerate
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(pGroup->nPlayers * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pGroupnode = pGroup->pGroupnodes;
	nPlayers = pGroup->nPlayers;
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pGroupnode);
        pIDArray[i] = pGroupnode->pPlayer->dwID;
        pGroupnode=pGroupnode->pNextGroupnode;
    }

	// we snapshot the owner here, because it could go away during the callbacks.
	dwGroupOwnerID = pGroup->dwOwnerID;

    // walk through the group calling by player
    for (i=0; (i < nPlayers ) && bResult; i++)
    {        
		// player could have been deleted while we dropped the locks
        pPlayer = PlayerFromID(this, pIDArray[i]);

		if(pPlayer){

			// We need to see if this player is the group's owner, if it is,
			// temporarily set the internal owner flag so the external one
			// gets set correctly in the callback
			if(pPlayer->dwID == dwGroupOwnerID)
				pPlayer->dwFlags |= DPLAYI_PLAYER_OWNER;
			
		    bResult = DoCallback(pPlayer, dwFlags, pvContext, lpEnumCallback, 
				                    dwEnumFlags,TRUE);

			// need to reacquire the pointer since we dropped the locks on callback.
			pPlayer = PlayerFromID(this, pIDArray[i]);
			if(pPlayer){
				// Clear the temporary owner flag (which will never be set
				// unless we did it above)
				pPlayer->dwFlags &= ~(DPLAYI_PLAYER_OWNER);
			}	
		}
    }

    // free the list of player ids
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through
CLEANUP_EXIT:

    if (DPENUMPLAYERS_SESSION & dwFlags)  
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

}//DP_EnumGroupPlayers

HRESULT DPAPI DP_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();	
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroups"
HRESULT DPAPI InternalEnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nGroups;
    UINT i;
	
	DPF(5,"got enum groups ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}
		// EnumGroups in a remote session is not allowed for lobby connections
		if((IS_LOBBY_OWNED(this)) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating groups in a remote lobby session is not supported");
			return DPERR_ACCESSDENIED;
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags
		if (!VALID_ENUMGROUPS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// do we need to open a session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
	} // sessions
    else
    {   // they are trying to enumerate groups in current sesion. 
        if (!this->lpsdDesc) return DPERR_NOSESSIONS;
    }
	
	// how many top-level groups}
	nGroups =0;
	pGroup = this->pGroups;
	while (pGroup)
	{
		if (0 == pGroup->dwIDParent) nGroups++;
		pGroup = pGroup->pNextGroup;
	}
	
    // are there any groups to enumerate ?
    if (0 == nGroups)
    {
        // no groups
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for the array of group ids
    pIDArray = DPMEM_ALLOC(nGroups * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current group ids
    pGroup = this->pGroups;
	i = 0;
	while (pGroup && (i < nGroups))
	{
        if (0 == pGroup->dwIDParent) 
        {
        	pIDArray[i] = pGroup->dwID;
			i++;
        }
        pGroup=pGroup->pNextGroup;
    }

    // call user for every valid group
    for (i=0; (i < nGroups) && bResult; i++)
    {        
        pGroup = GroupFromID(this, pIDArray[i]);
        // group could have been deleted while we dropped the locks
        if (pGroup && !(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
        {
		    bResult = DoCallback((LPDPLAYI_PLAYER)pGroup, dwFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,FALSE);
        }
    }

    // free the list
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through

CLEANUP_EXIT:

	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

}//InternalEnumGroups


HRESULT DPAPI DP_EnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();

	hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2);

	LEAVE_ALL();
	
	return hr;

}  // DP_EnumGroups

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumPlayers"
HRESULT DPAPI InternalEnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_PLAYER pPlayer;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nPlayers;
    UINT i;
		
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		// This call should always return DPERR_ACCESSDENIED for
		// lobby connections
		if(IS_LOBBY_OWNED(this))
		{
			DPF_ERR("EnumPlayers is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags
		if (!VALID_ENUMPLAYERS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
	} // sessions
    else
    {   // they are trying to enumerate players in current sesion. 
        if (!this->lpsdDesc) return DPERR_NOSESSIONS;
    }

    // any players to enumerate ?
    if (!this->pPlayers || (0==this->lpsdDesc->dwCurrentPlayers))
    {
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(this->nPlayers * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pPlayer = this->pPlayers;
	nPlayers = this->nPlayers;
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pPlayer);
        pIDArray[i] = pPlayer->dwID;
        pPlayer=pPlayer->pNextPlayer;
    }

    // iterate over the player id array, calling the app for every valid player
    for (i=0; (i < nPlayers) && bResult; i++)
    {        
        pPlayer = PlayerFromID(this, pIDArray[i]);
        // player could have been deleted while we dropped the locks
        if (pPlayer)
        {
		    bResult = DoCallback(pPlayer, dwFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,TRUE);
        }
    }

    // free the list
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

	if (dwFlags & DPENUMPLAYERS_GROUP) 
	{
		DWORD dwStrippedFlags; // flags to pass to internalenumgroups
	
		// reset flags - DPENUMPLAYERS_GROUP, DPENUMPLAYERS_SERVERPLAYER, DPENUMPLAYERS_SPECTATOR
		// is illegal to pass to InternalEnumGroups, and if DPENUMPLAYERS_SESSION is set,
		// we've already joined the session
		dwStrippedFlags = dwFlags & ~(DPENUMPLAYERS_GROUP |
									  DPENUMPLAYERS_SESSION |
									  DPENUMPLAYERS_SERVERPLAYER |
									  DPENUMPLAYERS_SPECTATOR);
		hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,
			dwStrippedFlags, dwEnumFlags);
	}

    // fall through
CLEANUP_EXIT:

	if (DPENUMPLAYERS_SESSION & dwFlags )  
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;
        
}//InternalEnumPlayers


HRESULT DPAPI DP_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2);

	LEAVE_ALL();

	return hr;

}//DP_EnumPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumSessions"
// make sure the user desc, and the desc found by enum, match 
// if fEnumAll is set, don't check passwords or player counts
HRESULT CheckSessionDesc(LPDPSESSIONDESC2 lpsdUser,LPDPSESSIONDESC2 lpsdSession,
	DWORD dwFlags,BOOL fAnsi)
{
	int iStrLen;

	// if we don't care about guids, passwords, open slots and enable new players, we're done
	if (dwFlags & DPENUMSESSIONS_ALL) return DP_OK;

	// 1st, check the guids
	if (!IsEqualGUID(&(lpsdUser->guidApplication),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(lpsdUser->guidApplication),&(lpsdSession->guidApplication))) 
		{
			return E_FAIL;
		}
	}

	// if we don't care about passwords, open slots and enable new players, we're done
	if (!(dwFlags & DPENUMSESSIONS_AVAILABLE)) return DP_OK;
	
	// next, check current users
	if (lpsdSession->dwMaxPlayers) 
	{
		if (lpsdSession->dwCurrentPlayers >= lpsdSession->dwMaxPlayers)  
		{
			return E_FAIL;
		}
	}
	
	// check the password if the session has one
	if (lpsdSession->lpszPassword)
	{
		iStrLen = fAnsi ? STRLEN(lpsdSession->lpszPasswordA) : 
						  WSTRLEN(lpsdSession->lpszPassword);
		if (iStrLen)
		{
			int iCmp;

			if (lpsdUser->lpszPassword)	// make sure there is a password
			{
				iCmp = fAnsi ? strcmp(lpsdSession->lpszPasswordA,lpsdUser->lpszPasswordA) :
							   WSTRCMP(lpsdSession->lpszPassword,lpsdUser->lpszPassword);
				if (0 != iCmp) return E_FAIL;
			}
			else
				return E_FAIL;			// no password in description, so bail
		}
	}

	// finally, check players enabled
	if (lpsdSession->dwFlags & DPSESSION_NEWPLAYERSDISABLED) return E_FAIL;
	
	if (lpsdSession->dwFlags & DPSESSION_JOINDISABLED) return E_FAIL;

	
	return DP_OK;
} // CheckSessionDesc

// called by InternalEnumSessions, KeepAliveThreadProc, GetNameTable 
// and GetNewPlayerID.  Calls GetCaps get the latency.
// tries for guaranteed, falls back to unreliable or default as necessary.
DWORD GetDefaultTimeout(LPDPLAYI_DPLAY this,BOOL fGuaranteed)
{
	DPCAPS caps;
	HRESULT hr;

	memset(&caps,0,sizeof(caps));
	caps.dwSize = sizeof(caps);

	if (fGuaranteed)
	{
		// call idirectplay::getcaps.  see what it has to say...
		hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,DPGETCAPS_GUARANTEED);
		if (SUCCEEDED(hr))
		{
			if (caps.dwTimeout) return caps.dwTimeout;
			// else 
			goto RETURN_DEFAULT; 
		}
		// else, fall through and try not guaranteed		
	}

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return DP_DEFAULT_TIMEOUT;
	}
	
	if (caps.dwTimeout){
		if(caps.dwTimeout >= 1000) {
			return caps.dwTimeout;
		} else {
			return 1000;
		}	
	}	

	// else 
RETURN_DEFAULT:

	// they returned success, but didn't set the caps
	DPF(0,"error - SP not returning valid timeout. Using DPlay default = %d\n",DP_DEFAULT_TIMEOUT);
	return DP_DEFAULT_TIMEOUT;

} // GetDefaultTimeout

// called by internalenumsessions, and by dplaythreadproc
HRESULT CallSPEnumSessions(LPDPLAYI_DPLAY this,LPVOID pBuffer,DWORD dwMessageSize,
	DWORD dwTimeout, BOOL bReturnStatus)
{
	DPSP_ENUMSESSIONSDATA ed;
	HRESULT hr;
	   
	if (!this->pcbSPCallbacks->EnumSessions) 
	{
		DPF_ERR("SP NOT IMPLEMENTING REQUIRED ENUMSESSIONS ENTRY");
		ASSERT(FALSE);
		return E_NOTIMPL;
	}
   
   	ASSERT(pBuffer);
	
   	ed.lpMessage = pBuffer;
	ed.dwMessageSize = dwMessageSize;
	ed.lpISP = this->pISP;
	ed.bReturnStatus = bReturnStatus;
	hr = CALLSP(this->pcbSPCallbacks->EnumSessions,&ed); 
	if (FAILED(hr)) 
	{
		if (hr != DPERR_CONNECTING)
			DPF(0,"enum failed - hr = %08lx\n",hr);
		return hr;
	}

	if (!dwTimeout) return DP_OK; // all done
	
	// we leave dplay so that the sp can get inside dp (in handler.c) w/
	// any responses    
	
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	
	LEAVE_DPLAY();
	Sleep(dwTimeout);
	ENTER_DPLAY();
	
	return DP_OK;
	
} // CallSPEnumSessions
	
HRESULT StopEnumThread(LPDPLAYI_DPLAY this)
{
	if (!(this->dwFlags & DPLAYI_DPLAY_ENUM))
	{
		DPF_ERR("COULD NOT STOP ASYNC ENUM - IT'S NOT RUNNING");
		return E_FAIL;
	}
	
	// stop the async thread.
	// mark dplay as being not enum'ing
	this->dwFlags &= ~DPLAYI_DPLAY_ENUM;
	// make sure it doesn't send an enum request when we wake it up
	this->dwEnumTimeout = INFINITE;
	
	// free up the buffer
	ASSERT(this->pbAsyncEnumBuffer);
	DPMEM_FREE(this->pbAsyncEnumBuffer);
	this->pbAsyncEnumBuffer = NULL;

	// set the worker threads event, so it picks up the new timeout
	SetEvent(this->hDPlayThreadEvent);

	// we're done
	return DP_OK;

}  // StopEnumThread	

/*
 ** InternalEnumSessions
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions and DP_1_EnumSessions
 *
 *  PARAMETERS: lpDP - idirectplay(2,2a) interface pointer
 *				lpsdDesc - session desc - validated only
 *				dwTimeout - how long to wait for responses
 *				lpEnumCallback - callback pointer - validate only
 *				dwFlags - flags passed to DP_X_EnumSessions - unused so far...
 *				dwEnumFlags - set by caller. ENUM_2A, or ENUM_2, or ENUM_1.
 *					indicates what type of session desc we have
 *
 *  DESCRIPTION:  calls service provider for enum sessions, and waits for responses
 *					*** ASSUMES SERVICE + DPLAY LOCKS TAKEN ***
 *					*** ASSUMES DPLAY LOCK COUNT IS AT 1 ***
 *
 *  RETURNS: E_OUTOFMEMORY, or SP hresult from sp_enumsessions
 *
 */
HRESULT DPAPI InternalEnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,
	DWORD dwTimeout,LPVOID lpEnumCallback,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    BOOL bContinue=TRUE;
	LPBYTE pBuffer; // buffer we're going to send
    LPMSG_ENUMSESSIONS pmsg; // cast from pBuffer
	DWORD dwMessageSize;
	UINT nPasswordLen; // password length, in bytes
	BOOL bReturnStatus; // true to override dialogs and return status

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc)) 
		{
		    DPF_ERR( "Invalid session description" );
		    return DPERR_INVALIDPARAMS;
		}
		// check strings
		if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
			WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
			WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		// check callback
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		if (!VALID_ENUMSESSIONS_FLAGS(dwFlags))
		{
		    DPF_ERR( "Invalid flags" );
		    return DPERR_INVALIDPARAMS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// note - andyco - we may want to lift this restriction...
	if (this->lpsdDesc)
	{
		DPF_ERR("can't enum sessions - session already open");
		return E_FAIL;
	}

	if ( !(dwFlags & (DPENUMSESSIONS_NOREFRESH | DPENUMSESSIONS_ASYNC)) ) 
	{
		FreeSessionList(this);		
	}

	// if this is a lobby-owned object, call the lobby code
	if(IS_LOBBY_OWNED(this))
	{
		ASSERT(1 == gnDPCSCount); // when we drop locks - this needs to go to 0!

		// REVIEW!!!! -- Is there a way we can keep from having to drop the lock
		// here??? What are the ramifications of doing so???  Can we potentially
		// cause a crash when the user comes back in???

		// We need to drop the lock for the lobby since it may call
		// EnumSessions on another DPlay object (like dpldplay does).
		LEAVE_DPLAY();
		hr = PRV_EnumSessions(this->lpLobbyObject, lpsdDesc, dwTimeout, dwFlags);
		ENTER_DPLAY();
		return hr;
	}

	// if app wants async, and our async thread is already running, we're done
	if  ( (dwFlags & DPENUMSESSIONS_ASYNC ) && (this->dwFlags & DPLAYI_DPLAY_ENUM) )
	{
		// we'll let whatever interface they called on just walk the list
		return DP_OK;
	}
	
	if (dwFlags & DPENUMSESSIONS_STOPASYNC)
	{
		hr = StopEnumThread(this);
		return hr;
	}
	
	// Are we already in a call to the SP's EnumSession?
	if  (this->dwFlags & DPLAYI_DPLAY_ENUMACTIVE)
	{
		// App must be doing async and SP may have a connection dialog up
		return DPERR_CONNECTING;
	}
	
	nPasswordLen = WSTRLEN_BYTES(lpsdDesc->lpszPassword);
													
	// message size + blob size + password size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ENUMSESSIONS);
	dwMessageSize += nPasswordLen;

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_ENUMSESSIONS)(pBuffer + this->dwSPHeaderSize);
	// set up msg
    SET_MESSAGE_HDR(pmsg);
    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ENUMSESSIONS);
	pmsg->guidApplication = lpsdDesc->guidApplication;
    pmsg->dwFlags = dwFlags;
	
	if (nPasswordLen)
	{
		pmsg->dwPasswordOffset = sizeof(MSG_ENUMSESSIONS);
		// copy over password
		memcpy((LPBYTE)pmsg+sizeof(MSG_ENUMSESSIONS),lpsdDesc->lpszPassword,nPasswordLen);
	} 
	else
	{
		pmsg->dwPasswordOffset = 0;
	}

	// if the app doesn't want to guess on a timeout, we'll "do
	// the right thing"
	if (0 == dwTimeout) dwTimeout = GetDefaultTimeout(this,TRUE);

	// app can request that the SP not display any status
	// dialogs while enumerating by setting this flag. The SP
	// will return status codes while enumeration is in progress

	bReturnStatus = (dwFlags & DPENUMSESSIONS_RETURNSTATUS) ? TRUE : FALSE; 

	// if it's an async all, startup the async thread
	if (dwFlags & DPENUMSESSIONS_ASYNC)
	{
		// it's async
		// call the sp, so it can do its dialog thing syncro, but don't block waiting
		// on replies
		this->dwFlags |= DPLAYI_DPLAY_ENUMACTIVE;
		hr = CallSPEnumSessions(this,pBuffer,dwMessageSize,0, bReturnStatus);
		this->dwFlags &= ~DPLAYI_DPLAY_ENUMACTIVE;
		if (FAILED(hr)) 
		{
			goto ERROR_EXIT;
		}

		// set up the worker thread
		this->dwEnumTimeout = dwTimeout;
		this->dwLastEnum = GetTickCount(); // just sent one above
		this->dwFlags |= DPLAYI_DPLAY_ENUM;
		this->pbAsyncEnumBuffer = pBuffer;
		this->dwEnumBufferSize = dwMessageSize;
		// StartDPlayThread will either start the thread, or signal it
		// that something new is afoot
		StartDPlayThread(this,FALSE);
	}
	else 
	{
		// it's not async
		// call the sp and block waiting for a response
		this->dwFlags |= DPLAYI_DPLAY_ENUMACTIVE;
		hr = CallSPEnumSessions(this,pBuffer,dwMessageSize,dwTimeout, bReturnStatus);
		this->dwFlags &= ~DPLAYI_DPLAY_ENUMACTIVE;
		if (FAILED(hr)) 
		{
			goto ERROR_EXIT;
		}
		// we're not starting an async - we're done w/ the buffer		
		DPMEM_FREE(pBuffer);		
	}
	
	// normal exit
	return hr;
	
ERROR_EXIT:
	if (hr != DPERR_CONNECTING)
		DPF_ERRVAL("SP Enum Sessions Failed - hr = 0x%08lx\n",hr);	
	if (pBuffer) DPMEM_FREE(pBuffer);
	return hr;
	
} // InternalEnumSessions

// calls internal enum sessions, then does callback
HRESULT DPAPI DP_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
    DWORD dwFlags) 
{
    LPDPLAYI_DPLAY this;
	HRESULT hr=DP_OK;
	BOOL bContinue = TRUE;

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
	        goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }

	while (bContinue)
	{
		//  do the enum
		hr = InternalEnumSessions(lpDP,lpsdDesc,dwTimeout,(LPVOID)lpEnumCallback,
			dwFlags);
		if (FAILED(hr)) 
		{
			if (hr != DPERR_CONNECTING)
				DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
		}

        hr = DoSessionCallbacks(this, lpsdDesc, &dwTimeout, lpEnumCallback, 
                                pvContext, dwFlags, &bContinue, FALSE);
        if (FAILED(hr))
        {
            goto CLEANUP_EXIT;
        }
	    
		// done...
	    if (bContinue) bContinue = CallAppEnumSessionsCallback(lpEnumCallback,NULL,&dwTimeout,
	    	DPESC_TIMEDOUT,pvContext);

	} // while bContinue

    // fall through
CLEANUP_EXIT:

	LEAVE_ALL();
	
    return hr;

}//DP_EnumSessions


/*
 ** CopySessionDesc2
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions and DP_1_EnumSessions
 *
 *  PARAMETERS: pSessionDescDest - session description ptr (destination)
 *				pSessionDescSrc - session description ptr (source)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies session description while allocating memory for name and password strings.
 *                These strings need to be freed by the calling function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySessionDesc2(LPDPSESSIONDESC2 pSessionDescDest, 
                         LPDPSESSIONDESC2 pSessionDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSessionDescDest && pSessionDescSrc);

    memcpy(pSessionDescDest, pSessionDescSrc, sizeof(DPSESSIONDESC2));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSessionDescDest->lpszSessionNameA), pSessionDescSrc->lpszSessionName);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSessionDescDest->lpszPasswordA), pSessionDescSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSessionDescDest->lpszSessionName), pSessionDescSrc->lpszSessionName);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSessionDescDest->lpszPassword), pSessionDescSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeDesc(pSessionDescDest, bAnsi);
    return hr;
}
 
void FreeSessionNode(LPSESSIONLIST pNode)
{
	// free up the sp blob stored w/ the desc
	if (pNode->pvSPMessageData) DPMEM_FREE(pNode->pvSPMessageData);
	// free the strings	store w/ the desc
	if (pNode->dpDesc.lpszSessionName) DPMEM_FREE(pNode->dpDesc.lpszSessionName);
	if (pNode->dpDesc.lpszPassword) DPMEM_FREE(pNode->dpDesc.lpszPassword);
	// free the session node
	DPMEM_FREE(pNode);
	
	return ;
	
} // FreeSessionNode


 // if we don't hear from a session after this many this->dwEnumTimeouts, we 
// "expire" it
#define DPSESSION_EXPIRE_SCALE 5
/*
 ** DoSessionCallbacks
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions
 *
 *  PARAMETERS: this pointer
 *				lpsdDesc - session desc (always UNICODE) - validated only
 *				lpdwTimeout - how long to wait for responses
 *				lpEnumCallback - callback pointer - validate only
 *              pvContext - app supplied context 
 *				dwFlags - flags passed to DP_X_EnumSessions - unused so far...
 *              lpbContinue - place holder for callback result
 *              bAnsi - ANSI or UNICODE
 *
 *  DESCRIPTION:  Does protected session callbacks while dropping the dplay locks
 *
 *  RETURNS: DP_OK, DPERR_OUTOFMEMORY
 *
 */
HRESULT DoSessionCallbacks(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc,
	LPDWORD lpdwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags, LPBOOL lpbContinue, BOOL bAnsi)
{
    LPSESSIONLIST lpSessionNode,lpSessionNodePrev;
    UINT i, nSessions=0;
    LPGUID pGuidArray;
    HRESULT hr;
    DPSESSIONDESC2 sdesc;

    // default behavior when flags are not specified
    if (!dwFlags) dwFlags = DPENUMSESSIONS_AVAILABLE;

    // count the number of matching sessions
    lpSessionNode = this->pSessionList;
	lpSessionNodePrev = NULL;
    while (lpSessionNode) 
    {
		// is this session expired?
		if ( (this->dwFlags & DPLAYI_DPLAY_ENUM) && (GetTickCount() - lpSessionNode->dwLastReply > 
			this->dwEnumTimeout*DPSESSION_EXPIRE_SCALE ) )
		{
			// expire session
			if (lpSessionNodePrev)
			{
				// remove this session node from the middle of the list
				lpSessionNodePrev->pNextSession = lpSessionNode->pNextSession;
				FreeSessionNode(lpSessionNode);
				lpSessionNode = lpSessionNodePrev->pNextSession;
			}
			else 
			{
				// take it off the front
				this->pSessionList = lpSessionNode->pNextSession;
				FreeSessionNode(lpSessionNode);
				lpSessionNode = this->pSessionList;
			}
		}
		else 
		{
            // Filtering is done on the server for DX5 or greater
            if (lpSessionNode->dwVersion >= DPSP_MSG_DX5VERSION)
            {
                nSessions++;
            }
            else  // for previous versions, filtering is done on the client
            {
	            // make sure this session matches what the user asked for...
			    hr = CheckSessionDesc(lpsdDesc,&(lpSessionNode->dpDesc),dwFlags,FALSE);
		        if (SUCCEEDED(hr)) 
		        {
	                // increment the count
	                nSessions++;
	            }
            }

	        lpSessionNode = lpSessionNode->pNextSession;
		}
    }

    // are there any sessions to enumerate ?
    if (0 == nSessions)
    {
        return DP_OK;
    }

    // allocate memory for the session guids array
    pGuidArray = DPMEM_ALLOC(nSessions * sizeof(GUID));
    if (!pGuidArray)
	    {
        DPF_ERR("Could not allocate array for session guids");
        return DPERR_OUTOFMEMORY;
    }

    // fill the session guid and session desc arrays
    i=0;
    lpSessionNode = this->pSessionList;
    while (lpSessionNode)
    {
        // Filtering is done on the server for DX5 or greater
        if (lpSessionNode->dwVersion >= DPSP_MSG_DX5VERSION)
        {
            pGuidArray[i] = lpSessionNode->dpDesc.guidInstance;
            i++;
        }
        else  // for previous versions, filtering is done on the client
        {
            // make sure this session matches what the user asked for...
		    hr = CheckSessionDesc(lpsdDesc,&(lpSessionNode->dpDesc),dwFlags,FALSE);
            if (SUCCEEDED(hr)) 
	        {
                pGuidArray[i] = lpSessionNode->dpDesc.guidInstance;
                i++;
            }
        }
        lpSessionNode = lpSessionNode->pNextSession;
    }

	// iterate over the guid list and callback w/ results	
    for (i=0; i < nSessions && *lpbContinue; i++)
    {        
        // check if the session is still valid 'cause session list could get 
        // deleted if EnumSessions is called while we dropped the locks
        lpSessionNode = FindSessionInSessionList(this,&pGuidArray[i]);	
        if (lpSessionNode)
        {
            // make a local copy of the session desc
            hr = CopySessionDesc2(&sdesc, &(lpSessionNode->dpDesc), bAnsi);
		    if (FAILED(hr))
		    {
			    DPF(0,"could not copy session desc hr = 0x%08lx\n",hr);
			    goto CLEANUP_EXIT;
		    }

            // drop the locks
			LEAVE_ALL();

            // call the app
		    *lpbContinue = CallAppEnumSessionsCallback(lpEnumCallback,&sdesc,lpdwTimeout,0,pvContext);	

            // reacquire locks
			ENTER_ALL();

            // free the strings allocated in CopySessionDesc2
            FreeDesc(&sdesc, bAnsi);
        }
    }

    // setting this explicitly here 'cause CheckSessionDesc could fail which is OK
    hr = DP_OK;

CLEANUP_EXIT:
    // cleanup allocations
    if (pGuidArray) 
    {
        DPMEM_FREE(pGuidArray);
    }

    return hr;
}


// Some apps (ok, "Outlaws" from LucasArts) were declaring their callbacks to
// be _cdecl instead of _stdcall and were relying on DPlay to generate stack frames to
// clean up after them. To keep them running we have to reset the stack pointer
// after returning from their callback, which will pop the parameters they were supposed to.
//
// Unfortunately, we can't use that nifty "#pragma optimize ("y", off)" here to turn on
// stack frames to fix this problem. This is because we don't have any local stack variables,
// so the compiler doesn't need to restore the stack pointer. I tried adding stack varibles
// but this ended up popping the wrong parameters and generally did not work 100%. So, an
// assembly language version seemed the safest way to go. This way it will always be correct,
// no matter what the compiler or how things change in the original functions.

// This fix won't affect applications that actually do clean up their parameters, since
// ESP == EBP when we return from calling them, so doing the "mov esp,ebp" won't change
// anything.

#if defined(_M_IX86)

BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeout,
				DWORD dwFlags, LPVOID lpContext)
{
	// why we declare lpStackPtr :
	// 1. we use it as a return value (hence its type of 'bool')
	// 2. we use it as a temporary place to stash esp, so we don't confuse the compiler 
	BOOL lpStackPtr = FALSE;

	_asm {
		// Save stack pointer
		mov		dword ptr [lpStackPtr],esp
		
		mov		eax,dword ptr [lpContext]
		push	eax
		mov		eax,dword ptr [dwFlags]
		push	eax
		mov		eax,dword ptr [lpdwTimeout]
		push	eax
		mov		eax,dword ptr [lpSessionDesc]
		push	eax
		call	dword ptr [lpEnumCallback]
		
		// Restore stack pointer
		mov		esp,dword ptr [lpStackPtr]
		// immediately below, the compiler will generate a 'mov eax,dword ptr [lpStackPtr]'
		// we make sure lpStackPtr has the real return value we want.  this gets rid of 
		// a compiler warning (need to return something explicitly), plus force the compiler
		// to actually alloc space for lpStackPtr.
		mov		dword ptr [lpStackPtr],eax
	}
	
	return lpStackPtr;
}

#else

BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeout,
				DWORD dwFlags, LPVOID lpContext)
{
	return (lpEnumCallback(lpSessionDesc, lpdwTimeout, dwFlags, lpContext));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\iplaya.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iplaya.c
 *  Content:	ansi entry points for idirectplay2A. entry points common to
 *				idirectplay2A and idirectplay2 are in iplay.c
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	5/8/96	andyco	created it
 *	5/21/96	andyco	added internal_a_createplayer, dp_a_creategroup
 *	6/19/96	kipo	Bug #2047. Changed DP_A_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Derek bug. DP_A_GetGroupName() and DP_A_GetPlayerName()
 *					had the player boolean was swapped so that it always
 *					returned an error.
 *	6/21/96	kipo	Deal with a null DPNAME in GetWideNameFromAnsiName().
 *	6/22/96	andyco	we were leaking a session desc in enumsessions
 *  7/8/96  ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                  to 'dpnName' to match DPLAY.H
 *                  Deleted function DP_A_SaveSession
 *	7/10/96	kipo	changed system message names
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *  10/1/96 sohailm updated DP_A_EnumSessions() to do protected callbacks
 *  10/2/96 sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
 *                  where appropriate.
 *  10/2/96 sohailm added code to validate user's DPNAME ptrs before accessing them
 * 10/11/96 sohailm Implemented DP_A_SetSessionDesc. Renamed labels for consistency.
 *	12/5/96	andyco	set the wide name to 0 in GetWideNameFromAnsiName before we
 *					validate params - this prevents freeing bogus pointer 
 *					if there's an error. Bug 4924.
 *  2/11/97	kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 *  3/12/97 sohailm added functions SecureOpenA, GetWideCredentials, FreeCredentials,
 *                  GetSecurityDesc, FreeSecurityDesc, ValidateOpenParamsA.
 *                  modified DP_Open to use ValidateOpenParamsA.
 *	4/20/97	andyco	group in group 
 *	5/05/97	kipo	Added CallAppEnumSessionsCallback() to work around Outlaws bug.
 *	5/8/97	myronth	Fixed memory leak, added StartSession ANSI conversion
 *  5/12/97 sohailm Update DP_A_SecureOpen(), FreeSecurityDesc() and GetWideSecurityDesc() 
 *                  to handle CAPIProvider name.
 *                  Fix for deadlock problem seen when SecureOpen fails (8386).
 *                  Added DP_A_GetAccountDesc().
 *	5/17/97	myronth	ANSI SendChatMessage
 *	5/17/97	myronth	Bug #8649 -- Forgot to drop lock on failed Open
 *	5/18/97	kipo	Adjust size of messages correctly.
 *  5/29/97 sohaim  Updated FreeCredentials(), GetWideCredentials(), DP_A_SecureOpen() to 
 *                  handle domain name.
 *	6/4/97	kip		Bug #9311 don't param check DPNAME structure (regression with DX3)
 *  6/09/97 sohailm More parameter validation in DP_A_SecureOpen()
 *	9/29/97	myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	11/19/97myronth	Fixed error paths in DP_A_Open (#9757)
 ***************************************************************************/


// note - we always LEAVE_DPLAY(); before calling idirectplay2 fn's. this is 
// because some idirectplay2 fn's (ones that create a player ( take service lock)) 
// require the dplay lock to be completely dropped.


// todo - build messages!!!

#include "dplaypr.h"
#include "dpsecure.h" // !! Review - move headers into dplaypr !!

#undef DPF_MODNAME
#define DPF_MODNAME "GetWideStringFromAnsi"
			   
// utility function to convert the ansi string lpszStr to a wide string.  also, allocs space
// for the wide string
HRESULT GetWideStringFromAnsi(LPWSTR * ppszWStr,LPSTR lpszStr)
{
	int iStrLen;

	ASSERT(ppszWStr);

	if (!lpszStr) 
	{
		*ppszWStr = NULL;
		return DP_OK;
	}

	// alloc space for the wstr
	iStrLen = STRLEN(lpszStr);
	*ppszWStr = DPMEM_ALLOC(iStrLen * sizeof(WCHAR));
	if (!*ppszWStr)
	{
		DPF_ERR("could not get unicode string - out of memory");
		return E_OUTOFMEMORY;
	}

	// get the wstr
   	AnsiToWide(*ppszWStr,lpszStr,iStrLen);

	return DP_OK;
} // GetWideStringFromAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_CreatePlayer"


// get a wide playername struct from an ansi one
// assumes dplay lock taken
HRESULT GetWideNameFromAnsiName(LPDPNAME pWide,LPDPNAME pAnsi)
{
	LPSTR lpszShortName,lpszLongName;
	HRESULT hr;

	TRY 
	{
		// we assume pWide is valid - it's off our stack
		// init it here.  so, if we fail, it won't have garbage
		// which we try to free up...
		memset(pWide,0,sizeof(DPNAME));
		
        if (pAnsi && !VALID_READ_DPNAME_PTR(pAnsi))
        {
			DPF_ERR("invalid dpname pointer");
			ASSERT(FALSE);

			// returning an error here causes a regression with DX3, since
			// we did not do parameter checks on the name previously
//			return DPERR_INVALIDPARAMS;
        }

        if (pAnsi)
			lpszShortName = pAnsi->lpszShortNameA;
		else
			lpszShortName = NULL;

		if (pAnsi)
			lpszLongName = pAnsi->lpszLongNameA;
		else
			lpszLongName = NULL;

		if ( lpszShortName && !VALID_READ_STRING_PTR(lpszShortName,STRLEN(lpszShortName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpszLongName && !VALID_READ_STRING_PTR(lpszLongName,STRLEN(lpszLongName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }			      

    // get wchar versions of the strings
	hr = GetWideStringFromAnsi(&(pWide->lpszShortName),lpszShortName);
	if (FAILED(hr)) 
	{
		return hr;
	}
	hr = GetWideStringFromAnsi(&(pWide->lpszLongName),lpszLongName);
	if (FAILED(hr)) 
	{
		return hr;
	}

	// success - mark name as valid
	pWide->dwSize = sizeof(DPNAME);
	
	return DP_OK;	

} // GetWideNameFromAnsiName

// checks string params - then allocs unicode strings and calls DP_CreatePlayer
HRESULT DPAPI DP_A_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_CreatePlayer(lpDP, pID,&WName,hEvent,pvData,dwDataSize,dwFlags);
	}
	
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_CreatePlayer         

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_CreateGroup"

// gets an ansi groupdata, and then calls DP_A_CreateGroup
HRESULT DPAPI DP_A_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_CreateGroup(lpDP, pID,&WName,pvData,dwDataSize,dwFlags);

	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_CreateGroup         

HRESULT DPAPI DP_A_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_CreateGroupInGroup(lpDP,idParentGroup, pidGroupID,&WName,pvData,dwDataSize,dwFlags);

	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} //DP_A_CreateGroup


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumGroupPlayers"

HRESULT DPAPI DP_A_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupsInGroup(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2A);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupsInGroup

HRESULT DPAPI DP_A_EnumGroupPlayers(LPDIRECTPLAY lpDP, DPID idGroup, LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2A);


	LEAVE_ALL();
	
	return hr;

} // DP_A_EnumGroupPlayers     
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumGroups"

HRESULT DPAPI DP_A_EnumGroups(LPDIRECTPLAY lpDP, LPGUID pGuid,
	 LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2A);


	LEAVE_ALL();

	return hr;

} // DP_A_EnumGroups           
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumPlayers"

HRESULT DPAPI DP_A_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,ENUM_2A);

	LEAVE_ALL();

	return hr;

} // DP_A_EnumPlayers          
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumSessions"
// convert a unicode session desc to ansi
HRESULT GetAnsiDesc(LPDPSESSIONDESC2 pDescA,LPDPSESSIONDESC2 pDesc)
{
	
	memcpy(pDescA,pDesc,sizeof(DPSESSIONDESC2));
	
	// convert session name
	if (pDesc->lpszSessionName)
	{
		// alloc a new session name
		GetAnsiString(&(pDescA->lpszSessionNameA),pDesc->lpszSessionName);
	}
	
	// convert password
	if (pDesc->lpszPassword)
	{
		// alloc a new session name
		GetAnsiString(&(pDescA->lpszPasswordA),pDesc->lpszPassword);
	}

	return DP_OK;

} // GetAnsiDesc

// frees the strings in a session desc
void FreeDesc(LPDPSESSIONDESC2 pDesc,BOOL fAnsi)
{
	if (fAnsi)
	{
		if (pDesc->lpszPasswordA) DPMEM_FREE(pDesc->lpszPasswordA); 
		if (pDesc->lpszSessionNameA) DPMEM_FREE(pDesc->lpszSessionNameA);
		pDesc->lpszPasswordA = NULL;
		pDesc->lpszSessionNameA = NULL;
	}
	else 
	{
		if (pDesc->lpszPassword) DPMEM_FREE(pDesc->lpszPassword); 
		if (pDesc->lpszSessionName) DPMEM_FREE(pDesc->lpszSessionName);
		pDesc->lpszPassword = NULL;
		pDesc->lpszSessionName =NULL;
	}

} // FreeDesc

// convert an ansi session desc to unicode
HRESULT GetWideDesc(LPDPSESSIONDESC2 pDesc,LPCDPSESSIONDESC2 pDescA)
{
	LPWSTR lpsz;
	HRESULT hr;

	memcpy(pDesc,pDescA,sizeof(DPSESSIONDESC2));
	// convert session name
	// alloc a new session name
	hr = GetWideStringFromAnsi(&lpsz,pDescA->lpszSessionNameA);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert SessionName string to Unicode, hr = 0x%08x", hr);
		return hr;
	}
	// store the new one
	pDesc->lpszSessionName = lpsz;

	// convert password
	hr = GetWideStringFromAnsi(&lpsz,pDescA->lpszPasswordA);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert Password string to Unicode, hr = 0x%08x", hr);
		return hr;
	}

	// store the new one
	pDesc->lpszPassword = lpsz;

	return DP_OK;

} // GetWideDesc

// calls internal enum sessions, then does callback
HRESULT DPAPI DP_A_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwTimeout,
	LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;
	BOOL bContinue = TRUE;
	DPSESSIONDESC2 descW;

 	ENTER_ALL();

	// validate strings and the this ptr
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		// check strings
		if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
			STRLEN(lpsdDesc->lpszSessionNameA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
			STRLEN(lpsdDesc->lpszPasswordA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }
	
	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
        goto CLEANUP_EXIT;
	}

	while (bContinue)
	{
		//  do the enum
		hr = InternalEnumSessions(lpDP,&descW,dwTimeout,(LPVOID)lpEnumCallback,dwFlags);
		if (FAILED(hr)) 
		{
			DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT1;
		}

        hr = DoSessionCallbacks(this, &descW, &dwTimeout, lpEnumCallback, 
                                pvContext, dwFlags, &bContinue, TRUE);
        if (FAILED(hr))
        {
            goto CLEANUP_EXIT1;
        }
	    
		// done...
	    if (bContinue) bContinue = CallAppEnumSessionsCallback(lpEnumCallback,NULL,&dwTimeout,DPESC_TIMEDOUT,pvContext);

	} // while bContinue

    // fall through

CLEANUP_EXIT1:
	FreeDesc( &descW,FALSE);

CLEANUP_EXIT:
	LEAVE_ALL();
    return hr;

} // DP_A_EnumSessions         

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetGroupName"

HRESULT DPAPI DP_A_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, FALSE, TRUE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_A_GetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetPlayerName"

HRESULT DPAPI DP_A_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, TRUE, TRUE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_A_GetPlayerName
 
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetSessionDesc"

HRESULT DPAPI DP_A_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetSessionDesc(lpDP,pvBuffer,pdwSize,TRUE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_GetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateOpenParamsA"
HRESULT ValidateOpenParamsA(LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags)
{
	if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
	{
		DPF_ERR("invalid session desc");
		return DPERR_INVALIDPARAMS;
	}
	// check strings
	if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
		STRLEN(lpsdDesc->lpszSessionNameA)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}
	if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
		STRLEN(lpsdDesc->lpszPasswordA)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}

    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_Open"

HRESULT DPAPI DP_A_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) 
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
							
	ENTER_DPLAY();

	// validate strings
	TRY
    {
        hr = ValidateOpenParamsA(lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();
		return hr;
	}
	
	LEAVE_DPLAY();
	
	hr = DP_Open(lpDP,&descW,dwFlags);

	ENTER_DPLAY();
	
	FreeDesc(&descW,FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_Open
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_Receive"

// convert a unicode system message to an ansi one
// called by DP_A_Receive
//
// for namechanged and addplayer (only two sysmessages w/ strings),
// we're going to extract the strings from the uniciode message,
// and rebuild the message w/ ansi versions
HRESULT BuildAnsiMessage(LPDIRECTPLAY lpDP,LPVOID pvBuffer,LPDWORD pdwSize)
{
	DWORD dwType;
	LPSTR pszShortName=NULL,pszLongName=NULL; // our new ansi strings
	UINT nShortLen=0,nLongLen=0;
	DWORD dwAnsiSize;  // size for ansi msg
	LPBYTE pBufferIndex; // scratch pointer used to repack


	dwType = ((LPDPMSG_GENERIC)pvBuffer)->dwType;
	
	switch (dwType)
	{
		case DPSYS_CREATEPLAYERORGROUP:
		{
			LPDPMSG_CREATEPLAYERORGROUP pmsg;
		
			pmsg = (LPDPMSG_CREATEPLAYERORGROUP)pvBuffer;
			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}

			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_CREATEPLAYERORGROUP) + pmsg->dwDataSize
				 + nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;

			// we'll repack the message, w/ msg, then playerdata, then strings
			// 1st, repack the playerdata 
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CREATEPLAYERORGROUP);

			if (pmsg->lpData)
			{
				memcpy(pBufferIndex,pmsg->lpData,pmsg->dwDataSize);
				pmsg->lpData = pBufferIndex;
				pBufferIndex += pmsg->dwDataSize;
			}
			// next, pack the strings
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}

			// all done
			break;
			
		} // ADDPLAYER

		case DPSYS_DESTROYPLAYERORGROUP:
		{
			LPDPMSG_DESTROYPLAYERORGROUP pmsg;
		
			pmsg = (LPDPMSG_DESTROYPLAYERORGROUP)pvBuffer;
			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}

			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_DESTROYPLAYERORGROUP)
						+ pmsg->dwLocalDataSize + pmsg->dwRemoteDataSize
						+ nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;

			// we'll repack the message, w/ msg, then playerdata, then strings
			// 1st, repack the playerdata 
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_DESTROYPLAYERORGROUP);

			if (pmsg->lpLocalData)
			{
				memcpy(pBufferIndex,pmsg->lpLocalData,pmsg->dwLocalDataSize);
				pmsg->lpLocalData = pBufferIndex;
				pBufferIndex += pmsg->dwLocalDataSize;
			}

			if (pmsg->lpRemoteData)
			{
				memcpy(pBufferIndex,pmsg->lpRemoteData,pmsg->dwRemoteDataSize);
				pmsg->lpRemoteData = pBufferIndex;
				pBufferIndex += pmsg->dwRemoteDataSize;
			}

			// next, pack the strings
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
				pBufferIndex += nLongLen;
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}

			// all done
			
			break;
		} // DESTROYPLAYER

		case DPSYS_SETPLAYERORGROUPNAME:
		{
			// we're going to extract the strings from the uniciode message,
			// and rebuild the message w/ ansi versions
			LPDPMSG_SETPLAYERORGROUPNAME pmsg;

			pmsg = (LPDPMSG_SETPLAYERORGROUPNAME)pvBuffer;

			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}
			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_SETPLAYERORGROUPNAME) + nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPNAME);
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}
			// all done
			break;

		} // DPSYS_SETPLAYERORGROUPNAME:

		case DPSYS_SETSESSIONDESC:
		{
			// we're going to extract the strings from the uniciode message,
			// and rebuild the message w/ ansi versions
            UINT nSessionNameLen=0, nPasswordLen=0;
            LPSTR pszSessionName=NULL, pszPassword=NULL;
			LPDPMSG_SETSESSIONDESC pmsg;

			pmsg = (LPDPMSG_SETSESSIONDESC)pvBuffer;

			if (pmsg->dpDesc.lpszSessionName)
			{
				GetAnsiString(&pszSessionName,pmsg->dpDesc.lpszSessionName);
				nSessionNameLen = STRLEN(pszSessionName);
			}
			if (pmsg->dpDesc.lpszPassword)
			{
				GetAnsiString(&pszPassword,pmsg->dpDesc.lpszPassword);
				nPasswordLen = STRLEN(pszPassword);
			}
			
			dwAnsiSize = sizeof(DPMSG_SETSESSIONDESC) + nSessionNameLen + nPasswordLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszSessionName)
					DPMEM_FREE(pszSessionName);
				if (pszPassword)
					DPMEM_FREE(pszPassword);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETSESSIONDESC);
			if (pszSessionName) 
			{
				memcpy(pBufferIndex,pszSessionName,nSessionNameLen);
				pmsg->dpDesc.lpszSessionNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszSessionName);
				pBufferIndex += nSessionNameLen;
			}
			else 
			{
				pmsg->dpDesc.lpszSessionNameA = (LPSTR)NULL;				
			}

			if (pszPassword) 
			{
				memcpy(pBufferIndex,pszPassword,nPasswordLen);
				pmsg->dpDesc.lpszPasswordA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszPassword);
			}
			else 
			{
				pmsg->dpDesc.lpszPasswordA = (LPSTR)NULL;				
			}
			// all done
			break;

		} // DPSYS_SETSESSIONDESC:

		case DPSYS_STARTSESSION:
		{
			LPDPMSG_STARTSESSION	pmsg = (LPDPMSG_STARTSESSION)pvBuffer;
			HRESULT					hr;
		
			hr = PRV_ConvertDPLCONNECTIONToAnsiInPlace(pmsg->lpConn, pdwSize,
					sizeof(DPMSG_STARTSESSION));
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to convert DPLCONNECTION structure to ANSI, hr = 0x%08x", hr);
				return hr;
			}
			break;
		}

		case DPSYS_CHAT:
		{
			LPDPMSG_CHAT	pmsg = (LPDPMSG_CHAT)pvBuffer;
			LPSTR			pszMessage = NULL;
			UINT			nStringSize = 0;
			
			if (pmsg->lpChat->lpszMessage)
			{
				GetAnsiString(&pszMessage,pmsg->lpChat->lpszMessage);
				nStringSize = STRLEN(pszMessage);
			}
			
			dwAnsiSize = sizeof(DPMSG_CHAT) + sizeof(DPCHAT) + nStringSize; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszMessage)
					DPMEM_FREE(pszMessage);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CHAT) + sizeof(DPCHAT);
			if (pszMessage) 
			{
				memcpy(pBufferIndex, pszMessage, nStringSize);
				pmsg->lpChat->lpszMessageA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszMessage);
			}
			// all done
			break;
		}

		default:
			// do nothing
			break;
	}

	return DP_OK;

} // BuildAnsiMessage

HRESULT DPAPI DP_A_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_2A);

	if (FAILED(hr)) 
	{
		goto CLEANUP_EXIT;
	}
	
	// if it's a system message, we may need to convert strings to ansi
	if (0 == *pidFrom )
	{
		// it's a system message
		hr = BuildAnsiMessage(lpDP,pvBuffer,pdwSize);
	}

CLEANUP_EXIT:
	LEAVE_DPLAY();
	
	return hr;

} // DP_A_Receive        

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetGroupName"
HRESULT DPAPI DP_A_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_SetGroupName(lpDP, id,&WName,dwFlags);
	}								 
		
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetPlayerName"
HRESULT DPAPI DP_A_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_SetPlayerName(lpDP,id,&WName,dwFlags);
	}
	
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetSessionDesc"
HRESULT DPAPI DP_A_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags)
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
							
	ENTER_DPLAY();
	
    TRY
    {
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		// check strings
		if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
			STRLEN(lpsdDesc->lpszSessionNameA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
			STRLEN(lpsdDesc->lpszPasswordA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
        goto CLEANUP_EXIT;
	}
		
	hr = InternalSetSessionDesc(lpDP,&descW,dwFlags,TRUE);
	
	FreeDesc(&descW,FALSE);

    // fall through

CLEANUP_EXIT:

	LEAVE_DPLAY();	
	return hr;

} // DP_A_SetSessionDesc  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SecureOpen"

// frees the strings in a credentials structure
HRESULT FreeCredentials(LPDPCREDENTIALS lpCredentials, BOOL fAnsi)
{
    if (fAnsi)
    {
        if (lpCredentials->lpszUsernameA)
        {
            DPMEM_FREE(lpCredentials->lpszUsernameA);
            lpCredentials->lpszUsernameA = NULL;
        }
        if (lpCredentials->lpszPasswordA)
        {
            DPMEM_FREE(lpCredentials->lpszPasswordA);
            lpCredentials->lpszPasswordA = NULL;
        }
        if (lpCredentials->lpszDomainA)
        {
            DPMEM_FREE(lpCredentials->lpszDomainA);
            lpCredentials->lpszDomainA = NULL;
        }
    }
    else
    {
        if (lpCredentials->lpszUsername)
        {
            DPMEM_FREE(lpCredentials->lpszUsername);
            lpCredentials->lpszUsername = NULL;
        }
        if (lpCredentials->lpszPassword)
        {
            DPMEM_FREE(lpCredentials->lpszPassword);
            lpCredentials->lpszPassword = NULL;
        }
        if (lpCredentials->lpszDomain)
        {
            DPMEM_FREE(lpCredentials->lpszDomain);
            lpCredentials->lpszDomain = NULL;
        }
    }

    return DP_OK;
} // FreeCredentials


// create a unicode credentials struct from an ansi one
HRESULT GetWideCredentials(LPDPCREDENTIALS lpCredentialsW, LPCDPCREDENTIALS lpCredentialsA)
{
    HRESULT hr;

    ASSERT(lpCredentialsW && lpCredentialsA);

    memcpy(lpCredentialsW, lpCredentialsA, sizeof(DPCREDENTIALS));

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszUsername), lpCredentialsA->lpszUsernameA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszPassword), lpCredentialsA->lpszPasswordA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszDomain), lpCredentialsA->lpszDomainA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // success
    return DP_OK;

CLEANUP_EXIT:
    FreeCredentials(lpCredentialsW,FALSE);
    return hr;
} // GetWideCredentials

// frees the strings in a security desc structure
HRESULT FreeSecurityDesc(LPDPSECURITYDESC lpSecDesc, BOOL fAnsi)
{
    if (fAnsi)
    {
        if (lpSecDesc->lpszSSPIProviderA)
        {
            DPMEM_FREE(lpSecDesc->lpszSSPIProviderA);
            lpSecDesc->lpszSSPIProviderA = NULL;
        }
        if (lpSecDesc->lpszCAPIProviderA)
        {
            DPMEM_FREE(lpSecDesc->lpszCAPIProviderA);
            lpSecDesc->lpszCAPIProviderA = NULL;
        }
    }
    else
    {
        if (lpSecDesc->lpszSSPIProvider)
        {
            DPMEM_FREE(lpSecDesc->lpszSSPIProvider);
            lpSecDesc->lpszSSPIProvider = NULL;
        }
        if (lpSecDesc->lpszCAPIProvider)
        {
            DPMEM_FREE(lpSecDesc->lpszCAPIProvider);
            lpSecDesc->lpszCAPIProvider = NULL;
        }
    }

    return DP_OK;
} // FreeSecurityDesc

// create a unicode security description struct from an ansi one
HRESULT GetWideSecurityDesc(LPDPSECURITYDESC lpSecDescW, LPCDPSECURITYDESC lpSecDescA)
{
    HRESULT hr;

    ASSERT(lpSecDescW && lpSecDescA);

	memcpy(lpSecDescW,lpSecDescA,sizeof(DPSECURITYDESC));

    hr = GetWideStringFromAnsi(&(lpSecDescW->lpszSSPIProvider), 
        lpSecDescA->lpszSSPIProviderA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    hr = GetWideStringFromAnsi(&(lpSecDescW->lpszCAPIProvider), 
        lpSecDescA->lpszCAPIProviderA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // success
    return DP_OK;

CLEANUP_EXIT:
    FreeSecurityDesc(lpSecDescW,FALSE);
    return hr;
} // GetWideSecurityDesc

HRESULT DPAPI DP_A_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags,
    LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials)
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
    DPCREDENTIALS credW;
    DPSECURITYDESC secDescW;
    LPDPCREDENTIALS pIntCreds=NULL;
    LPDPSECURITYDESC pIntSecDesc=NULL;
							
	ENTER_DPLAY();

	// validate strings
	TRY
    {
        // validate regular open params
        hr = ValidateOpenParamsA(lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
        // validate additional params

        // null lpSecDesc is ok, will use default
        if (lpSecDesc)            
        {
            // can't pass security desc to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed a security description while creating an unsecure session");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }
            // join case will be checked after we find the session in our list

            // need to be hosting
            if (dwFlags & DPOPEN_JOIN)
            {
                DPF_ERR("Can't pass a security description while joining");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }

            if (!VALID_READ_DPSECURITYDESC(lpSecDesc)) 
            {
                LEAVE_DPLAY();
    			DPF_ERR("invalid security desc");
                return DPERR_INVALIDPARAMS;
            }
	        if (!VALID_DPSECURITYDESC_FLAGS(lpSecDesc->dwFlags))
	        {
                LEAVE_DPLAY();
  		        DPF_ERRVAL("invalid flags (0x%08x) in security desc!",lpSecDesc->dwFlags);
                return DPERR_INVALIDFLAGS;
	        }
		    if ( lpSecDesc->lpszSSPIProviderA && !VALID_READ_STRING_PTR(lpSecDesc->lpszSSPIProviderA,
			    STRLEN(lpSecDesc->lpszSSPIProviderA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad SSPI provider string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpSecDesc->lpszCAPIProviderA && !VALID_READ_STRING_PTR(lpSecDesc->lpszCAPIProviderA,
			    STRLEN(lpSecDesc->lpszCAPIProviderA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad CAPI provider string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
        }
        // null lpCredentials is ok, sspi will pop the dialg
        if (lpCredentials)            
        {
            // can't pass credentials to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed credentials while creating an unsecure session");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }
            // join case will be checked after we find the session in our list

            if (!VALID_READ_DPCREDENTIALS(lpCredentials)) 
            {
                LEAVE_DPLAY();
    			DPF_ERR("invalid credentials structure");
                return DPERR_INVALIDPARAMS;
            }
	        if (!VALID_DPCREDENTIALS_FLAGS(lpCredentials->dwFlags))
	        {
                LEAVE_DPLAY();
  		        DPF_ERRVAL("invalid flags (0x%08x) in credentials!",lpCredentials->dwFlags);
                return DPERR_INVALIDFLAGS;
	        }
		    if ( lpCredentials->lpszUsernameA && !VALID_READ_STRING_PTR(lpCredentials->lpszUsernameA,
			    STRLEN(lpCredentials->lpszUsernameA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad user name string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpCredentials->lpszPasswordA && !VALID_READ_STRING_PTR(lpCredentials->lpszPasswordA,
			    STRLEN(lpCredentials->lpszPasswordA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad password string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpCredentials->lpszDomainA && !VALID_READ_STRING_PTR(lpCredentials->lpszDomainA,
			    STRLEN(lpCredentials->lpszDomainA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad domain name string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // initialize here so we can call cleanup routines
    memset(&descW, 0, sizeof(DPSESSIONDESC2));
    memset(&credW, 0, sizeof(DPCREDENTIALS));
    memset(&secDescW, 0, sizeof(DPSECURITYDESC));

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();
		return hr;
	}

    if (lpCredentials)
    {
	    hr = GetWideCredentials(&credW,lpCredentials);
	    if (FAILED(hr))
	    {
            goto CLEANUP_EXIT;
	    }
        pIntCreds = &credW;
    }

    if (lpSecDesc)
    {
	    hr = GetWideSecurityDesc(&secDescW,lpSecDesc);
	    if (FAILED(hr))
	    {
            goto CLEANUP_EXIT;
	    }
        pIntSecDesc = &secDescW;
    }

	LEAVE_DPLAY();
	
	hr = DP_SecureOpen(lpDP,&descW,dwFlags,pIntSecDesc,pIntCreds);

	ENTER_DPLAY();

CLEANUP_EXIT:    
	FreeDesc(&descW,FALSE);
    FreeCredentials(&credW,FALSE);
    FreeSecurityDesc(&secDescW, FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SecureOpen


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetPlayerAccount"

HRESULT DPAPI DP_A_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetPlayerAccount(lpDP,dpid,dwFlags,pvBuffer,pdwSize,TRUE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_GetPlayerAccount


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SendChatMessage"
HRESULT DPAPI DP_A_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg)
{
	HRESULT hr;
	DPCHAT dpc;
	LPWSTR lpwszMessage = NULL; // unicode message

	ENTER_DPLAY();

    TRY
    {
		// check DPCHAT struct
		if(!VALID_READ_DPCHAT(lpMsg))
		{
			DPF_ERR("Invalid DPCHAT structure");
			hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGEA;
		}
		
		// check message string
		lpwszMessage = lpMsg->lpszMessage;
		if ( !lpwszMessage ||
			!VALID_READ_STRING_PTR(lpwszMessage,WSTRLEN_BYTES(lpwszMessage)) ) 
		{
		    DPF_ERR( "bad string pointer" );
		    hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGEA;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr =  DPERR_INVALIDPARAMS;
		goto EXIT_SENDCHATMESSAGEA;
    }
	
	// Get a Unicode copy of the string
	hr = GetWideStringFromAnsi(&lpwszMessage, lpMsg->lpszMessageA);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert message string to Unicode, hr = 0x%08x", hr);
		goto EXIT_SENDCHATMESSAGEA;
	}

	// Copy the user's DPCHAT struct into our local one and change the
	// message string pointer
	memcpy(&dpc, lpMsg, sizeof(DPCHAT));
	dpc.lpszMessage = lpwszMessage;

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_SendChatMessage(lpDP, idFrom, idTo, dwFlags, &dpc);
		
	ENTER_DPLAY();
	
	if(lpwszMessage)
		DPMEM_FREE(lpwszMessage);

EXIT_SENDCHATMESSAGEA:

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SendChatMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\perf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perf.c
 *  Content:	uses a memory mapped file to send dp_perfdata to directx control
 *				panel.  see dpcpl.h and MANROOT\dxcpl\dplay.c
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/20/96	andyco	created it
 *
 ***************************************************************************/

#include "dplaypr.h"
#include "dpcpl.h"

#define DPF_MODNAME "performance thread"

// how often we send updates to cpl
#define PERF_INTERVAL 1000
// how long we wait before deciding cpl has gone away
#define PERF_TIMEOUT 5000

BOOL gbInitMapping; // is the mapping done?
LPDP_PERFDATA gpPerfData; // out global perfdata
HANDLE ghFile;  // handle to mapped file
HANDLE ghEvent; // event to notify cpl that there's new data
HANDLE ghMutex; // used to sync access to the mapped file
HANDLE ghAckEvent; // set by the control panel when it has processed our update

void FiniMappingStuff(LPDPLAYI_DPLAY this)
{
    if (ghFile) CloseHandle(ghFile),ghFile=NULL;
    if (ghEvent) CloseHandle(ghEvent),ghEvent=NULL;
    if (gpPerfData) UnmapViewOfFile(gpPerfData),gpPerfData = NULL;
    if (ghMutex) CloseHandle(ghMutex),ghMutex = NULL;
    if (ghAckEvent) CloseHandle(ghAckEvent),ghAckEvent=NULL;
    if (this->pPerfData) DPMEM_FREE(this->pPerfData),this->pPerfData = NULL;
	gbInitMapping = FALSE;
	
    return ;
	
} // FiniMappingStuff

HRESULT InitMappingStuff(LPDPLAYI_DPLAY this)
{
    // Create the file mapping
    ghFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,
		PAGE_READWRITE,	0, FILE_MAP_SIZE,FILE_MAP_NAME);

    if (NULL != ghFile && GetLastError() != ERROR_ALREADY_EXISTS)
    {
		// this is ok - we'll check again later
		DPF(9,"ack - file mapping didn't exist!");
		goto ERROR_EXIT;
    }

    gpPerfData = MapViewOfFile(ghFile, FILE_MAP_WRITE, 0, 0, 0);
    if (!gpPerfData)
    {
    	DPF_ERR("ack - could not map file");
    	goto ERROR_EXIT;
    }

    ghEvent = CreateEventA(NULL,FALSE,TRUE,EVENT_NAME);
    if (!ghEvent)
    {
    	DPF_ERR("could not create event!");
		goto ERROR_EXIT;
    }

    ghAckEvent = CreateEventA(NULL,FALSE,TRUE,ACK_EVENT_NAME);
    if (!ghAckEvent)
    {
    	DPF_ERR("could not create ack event!");
		goto ERROR_EXIT;
    }

    // used to sync access to the shared memory
    ghMutex = CreateMutexA( NULL, FALSE, MUTEX_NAME );
    if (!ghMutex)
    {
    	DPF_ERR("could not create Mutex!");
		goto ERROR_EXIT;
    }

    // alloc the perf data
    this->pPerfData = DPMEM_ALLOC(sizeof(DP_PERFDATA));
    if (!this->pPerfData)
    {
    	DPF_ERR("could not alloc perf data - out of memory!");
		goto ERROR_EXIT;
    }

    // set up the constant value stuff
    this->pPerfData->dwProcessID = GetCurrentProcessId();

    // get the exe name
   	if (!GetModuleFileNameA(NULL,this->pPerfData->pszFileName,MAX_NAME))
   	{
   		ASSERT(FALSE);
   	}

	gbInitMapping = TRUE;

    return S_OK;

ERROR_EXIT:
	FiniMappingStuff(this);
    return E_FAIL;

}  // InitMappingStuff

void ResetPerfData(LPDPLAYI_DPLAY this)
{
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS = 0;
		this->pPerfData->nReceiveBPS= 0;
		this->pPerfData->nSendPPS= 0;
		this->pPerfData->nReceivePPS= 0;
		this->pPerfData->nSendErrors= 0;
		this->pPerfData->bHost = FALSE;
	}
	
}  // ResetPerfData

void DoUpdateCPL(LPDPLAYI_DPLAY this)
{
	DWORD dwRet;

	ASSERT(this->pSysPlayer);

	// send a message to the dxcpl
	if (!gbInitMapping)
	{
		InitMappingStuff(this);
	}

	if (gbInitMapping)
	{
		ASSERT(gpPerfData);
		// take the lock
	    WaitForSingleObject( ghMutex, INFINITE );
		// copy local info to the shared perf data
		memcpy(gpPerfData,this->pPerfData,sizeof(DP_PERFDATA));
		// update the session name (in case it was changed)...
		WideToAnsi(gpPerfData->pszSessionName,this->lpsdDesc->lpszSessionName,MAX_NAME);
		// host?
		if (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) gpPerfData->bHost = TRUE;
		// nplayers
		gpPerfData->nPlayers = this->lpsdDesc->dwCurrentPlayers;
        // sp name
        ASSERT(this->pspNode);
	   	ASSERT(this->pspNode->lpszPath);
   		WideToAnsi(gpPerfData->pszSPName,this->pspNode->lpszName,MAX_NAME);

		// tell the cpl to process update
		SetEvent(ghEvent);
		
		LEAVE_DPLAY(); // so app isn't blocked while cpl processes data
		
		// wait for dxcpl to finish w/ it
		dwRet = WaitForSingleObject(ghAckEvent,PERF_TIMEOUT);

		ENTER_DPLAY();
		
		ReleaseMutex( ghMutex );

		if (WAIT_OBJECT_0 != dwRet)
		{
			// rut ro, cpl might have split
			// reset everything...
			DPF_ERR(" no response from control panel - resetting...");
			FiniMappingStuff(this);
		}
		// reset counters		
		ResetPerfData(this);
	}
	return ;

}//  DoUpdateCPL		

DWORD WINAPI PerfThreadProc(LPDPLAYI_DPLAY this)
{
	
	DWORD dwRet;
	HRESULT hr;
		
	DPF(1,"starting perf thread proc");
	
 	while (1)
 	{
		dwRet = WaitForSingleObject(this->hPerfEvent,PERF_INTERVAL);
		if (WAIT_OBJECT_0 == dwRet)
		{
			// if it's wait_object_0, someone set our event
			// dplay must be closing.  scram.
			goto CLEANUP_EXIT;
		}

		ENTER_DPLAY();

		hr = VALID_DPLAY_PTR(this);
		if ( FAILED(hr) || !(VALID_DPLAY_PLAYER(this->pSysPlayer))
			|| (this->dwFlags & DPLAYI_DPLAY_CLOSED))
		{
			LEAVE_DPLAY();
			goto CLEANUP_EXIT;
		}

		DoUpdateCPL(this);
		
		LEAVE_DPLAY();
	}	

CLEANUP_EXIT:
	FiniMappingStuff(this);
	DPF(1,"perf thread exiting");
	return 0;
	
} // PerfThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\mcontext.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcontext.c
 *  Content:	message context mapping for SendEx
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *	12/8/97		aarono      Created
 *  2/13/98     aarono      fixed bugs found by async testing
 *  2/18/98     aarono      wasn't dropping lock in error path - fixed
 *  6/20/98     aarono      pspFromContext, used count w/o init.
 *
 *  Abstract:
 *
 *  Maintains a table of context mappings for messages being sent
 *  asynchronously.  Also keeps track of group sends vs. directed
 *  sends so that cancel can cancel them together.
 * 
 ***************************************************************************/

/*

	Structures:

	Context mapping is done on the array of MSGCONTEXTENTRY's 
	this->pMsgContexts.  This is a MsgContextTable which can be
	grown if it gets empty.  Each context provided is an integer
	index from 0 to the list size.  To avoid context collisions
	the context is composed of 2 parts.  A high 16 bits that is 
	cycled with every allocation and the low 16 bits which is the
	index in the context table. 
	
*/


#include "dplaypr.h"
#include "mcontext.h"

// Allocate the pool heads for context mapping buffers.
// sizes range from 2 to MSG_FAST_CONTEXT_POOL_SIZE. Larger
// allocations are off the heap.
VOID InitTablePool(LPDPLAYI_DPLAY this)
{
	UINT i;

	// Initialize the group context list pool.
	for (i=0; i < MSG_FAST_CONTEXT_POOL_SIZE; i++){
		this->GrpMsgContextPool[i]=0;
	}

	InitializeCriticalSection(&this->ContextTableCS);
	
}

// Free the pools and the head of the context mapping buffers.
// Note, not protected so all buffer ownership must already
// have reverted.
VOID FiniTablePool(LPDPLAYI_DPLAY this)
{
	UINT i;
	PVOID pFree;
	
	for(i=0;i<MSG_FAST_CONTEXT_POOL_SIZE;i++){
		while(this->GrpMsgContextPool[i]){
			pFree=this->GrpMsgContextPool[i];
			this->GrpMsgContextPool[i]=*((PVOID *)this->GrpMsgContextPool[i]);
			GlobalFree(pFree);
		}
	}
	DeleteCriticalSection(&this->ContextTableCS);
}

// Initializes the ContextTable.  The context table is an array of MSGCONTEXTENTRY's
// each one is used to map a DPLAY send context to the SP's internal context.  Entries
// are either a single entry or a list.  In the case of a list, a pointer to the list
// is entered into the CONTEXTENTRY.  Lists are allocated from the TablePool.
HRESULT InitContextTable(LPDPLAYI_DPLAY this)
{
	INT i;

	// Allocate the context mapping table
	this->pMsgContexts=(PMSGCONTEXTTABLE)GlobalAlloc(GPTR, sizeof(MSGCONTEXTTABLE)+
									INIT_CONTEXT_TABLE_SIZE * sizeof(MSGCONTEXTENTRY));

	if(!this->pMsgContexts){
		return DPERR_OUTOFMEMORY;
	}

	// Initialize the context mapping table.
	// this->pMsgContexts->nUnique=0; //by ZERO_INIT
	this->pMsgContexts->nTableSize=INIT_CONTEXT_TABLE_SIZE;

	this->pMsgContexts->iNextAvail=0;
	for(i=0;i<INIT_CONTEXT_TABLE_SIZE-1;i++){
		this->pMsgContexts->MsgContextEntry[i].iNextAvail=i+1;
	}
	this->pMsgContexts->MsgContextEntry[INIT_CONTEXT_TABLE_SIZE-1].iNextAvail = LIST_END;

	return DP_OK;
}

// FiniContextTable - uninitialize the context table
VOID FiniContextTable(LPDPLAYI_DPLAY this)
{
	if(this->pMsgContexts){
		GlobalFree(this->pMsgContexts);
		this->pMsgContexts=NULL;
	}	
}

// verify the context is the one allocated, i.e. hasn't been recycled.
BOOL VerifyContext(LPDPLAYI_DPLAY this, PVOID Context)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	if(iEntry > Table.nTableSize-1){
		return FALSE;
	}

	if(Entry[iEntry].nUnique && 
	   (Entry[iEntry].nUnique == ((DWORD_PTR)Context & CONTEXT_UNIQUE_MASK))
	  )
	{
		return TRUE;
	} else {
		return FALSE;
	}

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// Retrieves a pointer the array of values stored in a context, and the 
// number of entries in the array
HRESULT ReadContextList(
	LPDPLAYI_DPLAY this, 
	PVOID Context, 
	PAPVOID *ppapvContextArray, 	//output
	PUINT lpnArrayEntries,   		//output
	BOOL  bVerify					// whether we need to verify the Context
	
)
{
	HRESULT hr=DP_OK;
	
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);

	if(bVerify && !VerifyContext(this,Context)){
		hr=DPERR_GENERIC;
		goto EXIT;
	}

	*lpnArrayEntries=Entry[iEntry].nContexts;
//	if(*lpnArrayEntries==1){
//		*ppapvContextArray=(PAPVOID)(&Entry[iEntry].pv);
//	} else {
		*ppapvContextArray=Entry[iEntry].papv;
//	}

EXIT:	
	LeaveCriticalSection(&this->ContextTableCS);

	return hr;

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// Sets a pointer the array of values stored in a context, and the 
// number of entries in the array
HRESULT WriteContextList(
	LPDPLAYI_DPLAY this, 
	PVOID Context, 
	PAPVOID papvContextArray, 	
	UINT    nArrayEntries		
)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);
	Entry[iEntry].nContexts=nArrayEntries;
	Entry[iEntry].papv = papvContextArray;
	LeaveCriticalSection(&this->ContextTableCS);
	
	return DP_OK;

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}


// Retrieves a pointer the array of values stored in a context, and the 
// number of entries in the array 
PSENDPARMS pspFromContext(
	LPDPLAYI_DPLAY this, 
	PVOID Context,
	BOOL  bAddRef
)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	PSENDPARMS psp;
	UINT count;
	
	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);
	if(VerifyContext(this,Context)){
		psp=Entry[iEntry].psp;
		if(bAddRef){
			count=pspAddRefNZ(psp); 
			if(count==0){
				psp=NULL; // object already being freed.
			}
		}
	} else {
		psp=NULL;
	}
	LeaveCriticalSection(&this->ContextTableCS);

	return psp;
	
	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// allocates a list of contexts from the Table Pool.
PAPVOID AllocContextList(LPDPLAYI_DPLAY this, UINT nArrayEntries)
{
	PAPVOID papv;

	ASSERT(nArrayEntries);

	EnterCriticalSection(&this->ContextTableCS);
	
	if((nArrayEntries <= MSG_FAST_CONTEXT_POOL_SIZE) &&
	   (papv=(PAPVOID)this->GrpMsgContextPool[nArrayEntries]))
	{
		this->GrpMsgContextPool[nArrayEntries]=*(PVOID *)this->GrpMsgContextPool[nArrayEntries];
		LeaveCriticalSection(&this->ContextTableCS);
	}
	else 
	{
		LeaveCriticalSection(&this->ContextTableCS);
		papv=GlobalAlloc(GMEM_FIXED, nArrayEntries*sizeof(PVOID));
	}
	return papv;
}

// releases the memory associated with a context list
VOID FreeContextList(LPDPLAYI_DPLAY this, PAPVOID papv, UINT nArrayEntries)
{
	#define pNext ((PVOID *)papv)

	if(nArrayEntries){
		if(nArrayEntries > MSG_FAST_CONTEXT_POOL_SIZE){
			ASSERT(0);
			GlobalFree(papv);
		} else {
			EnterCriticalSection(&this->ContextTableCS);
			*pNext = this->GrpMsgContextPool[nArrayEntries];
			this->GrpMsgContextPool[nArrayEntries]=(PVOID)papv;
			LeaveCriticalSection(&this->ContextTableCS);
		}
	}
	#undef pNext
}

// returns a context list entry to the free pool.
VOID ReleaseContextList(LPDPLAYI_DPLAY this, PVOID Context)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry Table.MsgContextEntry
	#define iEntry ((UINT_PTR)Context&CONTEXT_INDEX_MASK)

	PAPVOID papv;
	UINT 	nContexts;

	EnterCriticalSection(&this->ContextTableCS);

		// save this so we can do free outside lock.
		nContexts=Entry[iEntry].nContexts;
		papv=Entry[iEntry].papv;

		Entry[iEntry].iNextAvail=Table.iNextAvail;
		Table.iNextAvail=(DWORD)iEntry;

		Entry[iEntry].nUnique=0;  // flags not in use.
	
	LeaveCriticalSection(&this->ContextTableCS);

	if(nContexts){
		FreeContextList(this, papv,nContexts);
	}
	
	
	#undef iEntry
	#undef Entry
	#undef Table
	#undef pTable
}

// allocates a context table of the appropriate size and returns the handle
// to use to manipulate the table.
PVOID AllocateContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nArrayEntries)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry Table.MsgContextEntry
	#define NewTable (*pNewTable)

	UINT              i;
	UINT_PTR		  iEntry;
	PMSGCONTEXTTABLE  pNewTable;

	// First find a free context table entry.
	EnterCriticalSection(&this->ContextTableCS);

	if(Table.iNextAvail == LIST_END) {
		// Need to re-allocate the table.

		// Allocate the new table.

		// Allocate the context mapping table
		pNewTable=(PMSGCONTEXTTABLE)GlobalAlloc(GPTR, sizeof(MSGCONTEXTTABLE)+
				(Table.nTableSize+CONTEXT_TABLE_GROW_SIZE) * sizeof(MSGCONTEXTENTRY));

		if(!pNewTable){
			LeaveCriticalSection(&this->ContextTableCS);
			return NULL;
		}
		
		memcpy(pNewTable, pTable, Table.nTableSize*sizeof(MSGCONTEXTENTRY)+sizeof(MSGCONTEXTTABLE));

		GlobalFree(pTable);

		NewTable.iNextAvail=NewTable.nTableSize;
		NewTable.nTableSize=NewTable.nTableSize+CONTEXT_TABLE_GROW_SIZE;
		
		for(i=NewTable.iNextAvail; i < NewTable.nTableSize-1; i++){
			NewTable.MsgContextEntry[i].iNextAvail=i+1;
		}
		NewTable.MsgContextEntry[NewTable.nTableSize-1].iNextAvail = LIST_END;
		
		pTable=pNewTable;

	}

	iEntry=Table.iNextAvail;
	Table.iNextAvail=Entry[Table.iNextAvail].iNextAvail;

	LeaveCriticalSection(&this->ContextTableCS);
	
	// If this is an array, look for array buffers of the pooled size, else allocate

	Entry[iEntry].nContexts = nArrayEntries;
	Entry[iEntry].psp       = psp;


	Entry[iEntry].papv = AllocContextList(this, nArrayEntries);
	
	if(!Entry[iEntry].papv){
		ASSERT(0);
		// couldn't get a context list, free the entry and bail.
		EnterCriticalSection(&this->ContextTableCS);
		Entry[iEntry].iNextAvail=Table.iNextAvail;
		Table.iNextAvail=(DWORD)iEntry;
		LeaveCriticalSection(&this->ContextTableCS);
		return NULL;
	}

	EnterCriticalSection(&this->ContextTableCS);
	
	// increment uniqueness, never zero.
	do {
		pTable->nUnique += UNIQUE_ADD;
	} while(!pTable->nUnique);

	Entry[iEntry].nUnique=pTable->nUnique;

	LeaveCriticalSection(&this->ContextTableCS);

	ASSERT(((iEntry+Entry[iEntry].nUnique)&CONTEXT_INDEX_MASK) == iEntry);

	return ((PVOID)(iEntry+Entry[iEntry].nUnique));
	
	#undef pTable
	#undef Table
	#undef NewTable
	#undef Entry
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\sgl.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sgl.c
 *  Content:	functions for manipulating scatter gather lists.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 12/18/97   aarono    Original
 ***************************************************************************/

#include "dplaypr.h"

void InsertSendBufferAtFront(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext)
{
	ASSERT(psp->cBuffers < MAX_SG);
	
	memmove(&psp->Buffers[1],&psp->Buffers[0],psp->cBuffers*sizeof(SGBUFFER));
	memmove(&psp->BufFree[1],&psp->BufFree[0],psp->cBuffers*sizeof(BUFFERFREE));
	psp->Buffers[0].pData=pData;
	psp->Buffers[0].len=len;
	psp->BufFree[0].fnFree=fnFree;
	psp->BufFree[0].lpvContext=lpvContext;
	psp->dwTotalSize+=len;
	psp->cBuffers++;
}

void InsertSendBufferAtEnd(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext)
{
	UINT i = psp->cBuffers;

	ASSERT(psp->cBuffers < MAX_SG);
	
	
	psp->Buffers[i].pData=pData;
	psp->Buffers[i].len=len;
	psp->BufFree[i].fnFree=fnFree;
	psp->BufFree[i].lpvContext=lpvContext;
	psp->dwTotalSize+=len;
	psp->cBuffers++;
}

void FreeMessageBuffers(LPSENDPARMS psp)
{
	UINT i;
	for(i=0;i<psp->cBuffers;i++){
		if(psp->BufFree[i].fnFree){
			(*psp->BufFree[i].fnFree)(psp->BufFree[i].lpvContext,psp->Buffers[i].pData);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\pack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pack.c
 *  Content:	packs / unpacks players + group before / after network xport
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/13/96		andyco	created it
 *	4/15/96		andyco	unpack calls sp's create player fn
 *	4/22/96		andyco	unapck takes pmsg 
 *	5/31/96		andyco	group and players use same pack / unpack show
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *	6/25/96		andyco 	check data size before unpack
 *	7/10/96		andyco	don't unpack our sysplayer (pending already put 
 *						'em in the table)
 *	7/27/96		kipo	call PackPlayer() with bPlayer == FALSE to pack players
 *						in group along with the rest of the group data.
 *	8/1/96		andyco	added system player id to packed struct
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *	10/14/96	andyco	don't pack up system group.  add players to system
 *						group after unpacking.
 *	1/15/97		andyco	set new players' sysplayer id early enough to add
 *						to system group
 *	2/15/97		andyco	moved "remember name server" to iplay.c 
 *  3/12/97     sohailm updated UnpackPlayer() to move the security context ptr from the
 *                      nametable to the player structure when session is secure
 *  3/24/97     sohailm updated UnPackPlayer to pass NULL for session password to GetPlayer and
 *                      SendCreateMessage
 *	4/20/97		andyco	group in group 
 *	5/8/97		andyco	packing for CLIENT_SERVER
 *  6/22/97     sohailm Updated code to use pClientInfo.
 *   8/4/97		andyco	track this->dwMinVersion as we unpack
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *   4/1/98     aarono  don't propogate local only player flags
 ***************************************************************************/

// todo - handle unpack error on create group/player

 /**************************************************************************
 *
 * packed player format :                                            
 *                                                                   
 * 		+ for player                                                    
 * 	                                                                  
 * 			DPLAYI_PACKED  pPacked; // packed player struct             
 * 			LPWSTR lpszShortName; 	// size = pPacked->iShortNameLength 
 * 			LPWSTR lpszLongName;  	// size = pPacked->iLongNameLength  
 * 			LPVOID pvSPData;	  	// size = pPacked->dwSPDataSize     
 * 			LPVOID pvPlayerData;  	// size = pPacked->dwPlayerDataSize 
 * 	                                                                  
 * 		+ for group                                                     
 *
 * 			DPLAYI_PACKED  pPacked; // packed player struct             
 * 			LPWSTR lpszShortName; 	// size = pPacked->iShortNameLength 
 * 			LPWSTR lpszLongName;  	// size = pPacked->iLongNameLength  
 * 			LPVOID pvSPData;	  	// size = pPacked->dwSPDataSize     
 * 			LPVOID pvPlayerData;  	// size = pPacked->dwPlayerDataSize 
 * 			DWORD  dwIDs[dwNumPlayers] // size = pPacked->dwNumPlayers
 *
 *	packed player list format :
 *	
 *		msg (e.g. CreatePlayer,CreateGroup,EnumPlayersReply)
 *		PackedPlayer[nPlayers]
 *		PackedGroup[nGroups]
 *		msgdata[this->dwSPHeaderSize] (set by sp on send / receive)
 *	
 *
 **************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"Pack -- "

// andyco - todo - remove TODOTODOTODO hack
// put in to find stress bug where system player hasn't been added yet
void CheckStressHack(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_PLAYER pSearchPlayer = this->pPlayers;
	
	if (!pPlayer) return ;
	
	while (pSearchPlayer)
	{
		if ( !(pSearchPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && (pSearchPlayer->dwIDSysPlayer == pPlayer->dwID)
			&& !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
		{
			DPF(0,"player in nametable before system player!");
			ASSERT(FALSE);
#if 0 // - andyco removed for beta 1
			DPF(0,"found player in nametable before system player - going to int 3 - contact andyco");
			DebugBreak();
#endif 			
		}
		pSearchPlayer = pSearchPlayer->pNextPlayer;
	}

	return ;
		
} // CheckStressHack

/*
 ** UnpackPlayer
 *
 *  CALLED BY: UnpackPlayerAndGroupList
 *
 *  PARAMETERS: 
 *		this - direct play object
 *		pPacked - packed player or group
 *		pMsg - original message received (used so we can get sp's message data
 *			out for CreatePlayer call)
 *		bPlayer - is packed a player or a group?
 *
 *  DESCRIPTION: unpacks player. creates new player, sets it up.
 *
 *  RETURNS: SP's hr, or result	of GetPlayer or SendCreateMessage
 *
 */
HRESULT UnpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PACKEDPLAYER pPacked,
	LPVOID pvSPHeader,BOOL bPlayer)
{
    LPWSTR lpszShortName, lpszLongName;
	DWORD dwFlags;
	DPNAME PlayerName;
	LPVOID pvPlayerData;
	LPVOID pvSPData;
    LPDPLAYI_PLAYER pNewPlayer;
	LPDPLAYI_GROUP pNewGroup;
    LPBYTE pBufferIndex = (LPBYTE)pPacked;
	HRESULT hr;

	// unpack the strings  - they folow the packed player in the buffer
	if (pPacked->iShortNameLength) 
	{
		lpszShortName = (WCHAR *)(pBufferIndex + pPacked->dwFixedSize);
	}	
	else lpszShortName = NULL;

	if (pPacked->iLongNameLength) 
	{
		lpszLongName =(WCHAR *)( pBufferIndex + pPacked->dwFixedSize
			+ pPacked->iShortNameLength);
	}
	else lpszLongName = NULL;

	dwFlags = pPacked->dwFlags;
	
	// player is not local
	dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;

	PlayerName.lpszShortName = lpszShortName;
	PlayerName.lpszLongName = lpszLongName;
		
	pvPlayerData = pBufferIndex + pPacked->dwFixedSize + 
		pPacked->iShortNameLength + pPacked->iLongNameLength + 
		pPacked->dwSPDataSize;

	// go create the player
	if (bPlayer)
	{
		hr = GetPlayer(this,&pNewPlayer,&PlayerName,NULL,pvPlayerData,
			pPacked->dwPlayerDataSize,dwFlags,NULL,0);
		// andyco - debug code to catch stress bug 
		// todo - REMOVE HACKHACK TODOTODO
		if ( SUCCEEDED(hr) && (dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			CheckStressHack(this,pNewPlayer);
		}
	}
	else 
	{
		hr = GetGroup(this,&pNewGroup,&PlayerName,pvPlayerData,
			pPacked->dwPlayerDataSize,dwFlags,0,0);
		// cast to player - we only going to use common fields
		pNewPlayer = (LPDPLAYI_PLAYER)pNewGroup;		
	}
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		return hr;
		// rut ro!
	}

	pNewPlayer->dwIDSysPlayer = pPacked->dwIDSysPlayer;
	pNewPlayer->dwVersion = pPacked->dwVersion;	
	
	if (DPSP_MSG_DX3VERSION == pNewPlayer->dwVersion)
	{
		DPF(0,"detected DX3 client in game");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if (pNewPlayer->dwVersion && (pNewPlayer->dwVersion < this->dwMinVersion))
	{
		this->dwMinVersion = pNewPlayer->dwVersion;
		DPF(2,"found new min player version of %d\n",this->dwMinVersion);
	}
	
	if (pPacked->dwSPDataSize)
	{
		// copy the sp data - 1st, alloc space
		pNewPlayer->pvSPData = DPMEM_ALLOC(pPacked->dwSPDataSize);
		if (!pNewPlayer->pvSPData) 
		{
			// rut ro!
			DPF_ERR("out of memory, could not copy spdata to new player!");
			return E_OUTOFMEMORY;
		}
		pNewPlayer->dwSPDataSize = pPacked->dwSPDataSize;
	
		pvSPData = 	pBufferIndex + pPacked->dwFixedSize + pPacked->iShortNameLength 
			+ pPacked->iLongNameLength;
		// copy the spdata from the packed to the player
		memcpy(pNewPlayer->pvSPData,pvSPData,pPacked->dwSPDataSize);
	}

	// now, set the id and add to nametable
	pNewPlayer->dwID = pPacked->dwID;

    // if we are a secure server and we receive a remote system player, 
    // move the pClientInfo from the nametable into the player structure before the slot
    // is taken by the player
	//
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this) &&
        !(pNewPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
        (pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        pNewPlayer->pClientInfo = (LPCLIENTINFO) DataFromID(this,pNewPlayer->dwID);
		DPF(6,"pClientInfo=0x%08x for player %d",pNewPlayer->pClientInfo,pNewPlayer->dwID);
    }
    

	// don't add to the nametable if it's the app server - this id is fixed
	if (!(pNewPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))	
	{
		hr = AddItemToNameTable(this,(DWORD_PTR)pNewPlayer,&(pNewPlayer->dwID),TRUE,0);
	    if (FAILED(hr)) 
	    {
			ASSERT(FALSE);
			// if this fails, we're hosed!  there's no id on the player, but its in the list...
			// todo - what now???
	    }
	}

	// call sp 	
	if (bPlayer)
	{
		// tell sp about player
		hr = CallSPCreatePlayer(this,pNewPlayer,FALSE,pvSPHeader,TRUE);
		
	    // add to system group
	    if (this->pSysGroup)
	    {
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			pNewPlayer->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
	    }
	}
	else 
	{
		// tell sp about group
		hr = CallSPCreateGroup(this,(LPDPLAYI_GROUP)pNewPlayer,TRUE,pvSPHeader);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// todo -handle create player / group fails on unpack
	}
	
	// if it's a group, unpack group info
	if (!bPlayer)
	{
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList;
		DWORD dwPlayerID;

		if ( (pNewPlayer->dwVersion >= DPSP_MSG_GROUPINGROUP) && (pPacked->dwIDParent) )
		{
			pNewGroup->dwIDParent = pPacked->dwIDParent;
			// add it to parent
			hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces,pPacked->dwIDParent,
				pNewGroup->dwID,0,FALSE);
			if (FAILED(hr))
			{
				DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
				// keep trying...
			}
		}

		nPlayers = pPacked->dwNumPlayers;
		// list of id's is list thing in packed buffer
		pdwIDList = (LPDWORD) ((LPBYTE)pPacked + pPacked->dwFixedSize + 
			pPacked->iShortNameLength + pPacked->iLongNameLength + 
			pPacked->dwSPDataSize + pPacked->dwPlayerDataSize);

		// now, add the players to the group
		while (nPlayers>0)
		{
			nPlayers--;
			dwPlayerID = *pdwIDList++;
			hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,pPacked->dwID,
				dwPlayerID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
				// keep trying...
			}
		}	
		
		// all done!
	} // !bPlayer

	return hr;

}// UnpackPlayer

/*
 ** UnpackPlayerAndGroupList
 *
 *  CALLED BY: handler.c (on createplayer/group message) and iplay.c (CreateNameTable)
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *		pvSPHeader - sp's header, as received off the wire
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT UnpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
	LPBYTE pBufferIndex;
	LPDPLAYI_PACKEDPLAYER pPacked;

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		// don't unpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		if ( !(this->pSysPlayer && (pPacked->dwID == this->pSysPlayer->dwID)) )
		{
			hr = UnpackPlayer(this,pPacked,pvSPHeader,TRUE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// keep trying
			}
		}

		nPlayers --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		
		hr = UnpackPlayer(this,pPacked,pvSPHeader,FALSE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nGroups --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
   	} 
		
	return hr;

} // UnpackPlayerAndGroupList

DWORD PackedPlayerSize(LPDPLAYI_PLAYER pPlayer) 
{
	DWORD dwSize = 0;
	LPDPLAYI_DPLAY this = pPlayer->lpDP;
	
	dwSize = (WSTRLEN(pPlayer->lpszShortName) + WSTRLEN(pPlayer->lpszLongName)) 
		* sizeof(WCHAR)	+ sizeof(DPLAYI_PACKEDPLAYER) + 
		pPlayer->dwPlayerDataSize + pPlayer->dwSPDataSize;
		
	return dwSize;
} // PackedPlayerSize


DWORD PackedGroupSize(LPDPLAYI_GROUP  pGroup)
{
	DWORD dwSize = 0;
	
	// space for player stuff, plus space for group list 
	dwSize = PackedPlayerSize((LPDPLAYI_PLAYER)pGroup) + 
		pGroup->nPlayers*sizeof(DPID);
		
	return dwSize;	
} // PackedGroupSize

// returns how big the packed player structure is for the nPlayers
DWORD PackedBufferSize(LPDPLAYI_PLAYER pPlayer,int nPlayers,BOOL bPlayer) 
{
	DWORD dwSize=0;
	LPDPLAYI_GROUP pGroup = (LPDPLAYI_GROUP)pPlayer;
	
	while (nPlayers > 0)
	{
		if (bPlayer)
		{

			ASSERT(pPlayer);
			dwSize += PackedPlayerSize(pPlayer);
			pPlayer=pPlayer->pNextPlayer;
		}
		else 
		{
			ASSERT(pGroup);
			// don't count the system group - we don't send that one
			if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
			{
				dwSize += PackedGroupSize(pGroup);
			}
			
			pGroup = pGroup->pNextGroup;			
		}
		nPlayers--;		
	}	
	return dwSize;
}// PackedBufferSize

// constructs a packedplayer object from pPlayer. stores result in pBuffer
// returns size of packed player
DWORD PackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) 
{
	DPLAYI_PACKEDPLAYER Packed;
	int iShortStrLen=0,iLongStrLen=0;
	LPBYTE pBufferIndex = pBuffer;
		
	if (!pBuffer)
	{
		return PackedBufferSize(pPlayer,1,bPlayer);
	} // pBuffer

	// just to be safe
	memset(&Packed,0,sizeof(DPLAYI_PACKEDPLAYER));
	
	// figure out how big the packed struct is, setting short and long strlen
	iShortStrLen = WSTRLEN_BYTES(pPlayer->lpszShortName);
	iLongStrLen = WSTRLEN_BYTES(pPlayer->lpszLongName);
	
	if (bPlayer)
	{
		Packed.dwSize =  PackedPlayerSize(pPlayer);
		Packed.dwNumPlayers = 0;
	}
	else 
	{
		Packed.dwSize = PackedGroupSize((LPDPLAYI_GROUP)pPlayer);
		Packed.dwNumPlayers = ((LPDPLAYI_GROUP)pPlayer)->nPlayers;
	}
	
	Packed.iShortNameLength = iShortStrLen;
	Packed.iLongNameLength = iLongStrLen;
	
	// copy over relevant fields
	Packed.dwFlags = pPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS); 
	Packed.dwID = pPlayer->dwID;
	Packed.dwPlayerDataSize = pPlayer->dwPlayerDataSize;

	Packed.dwIDSysPlayer = pPlayer->dwIDSysPlayer;
	Packed.dwVersion = pPlayer->dwVersion;	
	Packed.dwFixedSize = sizeof(DPLAYI_PACKEDPLAYER);
	Packed.dwIDParent = pPlayer->dwIDParent;
	
	// start filling up variable size structs behind the fixed size one
	pBufferIndex+= sizeof(Packed);
	
	// store strings after packed
	if (pPlayer->lpszShortName)	
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		pBufferIndex += iShortStrLen;
	}
	if (pPlayer->lpszLongName)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		pBufferIndex += iLongStrLen;
	}

	// pack sp data
	if (pPlayer->pvSPData)
	{
		// store spdata after strings
		memcpy(pBufferIndex,pPlayer->pvSPData,pPlayer->dwSPDataSize);
		pBufferIndex += pPlayer->dwSPDataSize;
		Packed.dwSPDataSize = pPlayer->dwSPDataSize;
	}
	else 
	{
		Packed.dwSPDataSize = 0;
	}

	if (pPlayer->pvPlayerData)
	{
		// copy playerdata after spdata
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
	}

	// if it's a group, store the list of id's after the playerdata
	if (!bPlayer)
	{
		LPDPLAYI_GROUPNODE pGroupnode = ((LPDPLAYI_GROUP)pPlayer)->pGroupnodes;
		LPDPID pdwBufferIndex;
		
		// we shouldn't be asked to pack the sysgroup
		ASSERT(! (pPlayer->dwFlags & DPLAYI_GROUP_SYSGROUP));

		pBufferIndex += pPlayer->dwPlayerDataSize;
		pdwBufferIndex = (LPDPID)pBufferIndex;

		// add the players in the group onto the list
		while (pGroupnode)
		{
			ASSERT(pGroupnode->pPlayer);
			*pdwBufferIndex++ = pGroupnode->pPlayer->dwID;
			pGroupnode = pGroupnode->pNextGroupnode;
		}
	}

	// store the fixed size packed struct in buffer
	memcpy(pBuffer,&Packed,sizeof(Packed));

	// all done
	return Packed.dwSize;	
	
} // PackPlayer

					
HRESULT PackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) 
{

	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP 	pGroup;

	if (!pBuffer) 
	{
		if (CLIENT_SERVER(this))
		{
			ASSERT(this->pSysPlayer);
			*pdwBufferSize = PackedBufferSize(this->pSysPlayer,1,TRUE);
			if (this->pServerPlayer) 
			{
				*pdwBufferSize += PackedBufferSize(this->pServerPlayer,1,TRUE);
			}
		}
		else 
		{
			*pdwBufferSize = PackedBufferSize((LPDPLAYI_PLAYER)this->pGroups,
				this->nGroups,FALSE);
			*pdwBufferSize += PackedBufferSize(this->pPlayers,this->nPlayers,TRUE);
		}
		return DP_OK;
	}
	// else, assume buffer is big enough...
	
	// if we're client server, just send the minimum info...
	if (CLIENT_SERVER(this))
	{
		ASSERT(this->pSysPlayer);	
		pBuffer += PackPlayer(this->pSysPlayer,pBuffer,TRUE);
		if (this->pServerPlayer) 
		{
				pBuffer += PackPlayer(this->pServerPlayer,pBuffer,TRUE);
		}
		return DP_OK;
	}
			
	// if not, pack all players
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pBuffer += PackPlayer(pPlayer,pBuffer,TRUE);
		pPlayer = pPlayer->pNextPlayer;
	}
	// next, pack groups
	pGroup = this->pGroups;
	while (pGroup)
	{
		// don't send the system group 
		if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			pBuffer += PackPlayer((LPDPLAYI_PLAYER)pGroup,pBuffer,FALSE);
		}
		pGroup = pGroup->pNextGroup;
	}

	return DP_OK;
	
}// PackPlayerAndGroupList	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\namesrv.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       namesrv.c
 *  Content:	name management code
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  1/96		andyco	created it
 *	4/15/96		andyco	added handledeadnameserver
 *	6/19/96		kipo	Fixed a problem in GrowTable() with MemReAlloc() returning
 *						NULL, which caused a memory leak and possibly a crash if someone
 *						was not expecting this->pNameTable to ever be NULL.
 *	6/22/96		andyco	indicate whether we're asking for player or group id
 *						in sendnsnewidrequest.
 *	8/1/96		andyco	changed dp_destroyplayer to internaldestroy
 *	8/6/96		andyco	version in commands.  extensible on the wire support. 
 *						id mangling.
 *	8/8/96		andyco	 get playerid timeout from sp (by calling getdefaultimeout).
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 *	10/14/96	andyco	check nametable index BEFORE using it...bug 3946
 *	12/18/96	andyco	moved bogus assert on additemtonametable 
 *  01/17/97    sohailm now we send player flags in request player id message
 *	1/15/98		andyco	cleaned up handledeadnameserver - no longer nukes
 *						old sysplayer.
 *  3/14/97     sohailm integrated security code into SendNewIDRequest, 
 *                      added functions IsValidID and DataFromID. Updated function NameFromID
 *                      to use IsValidID.
 *	3/17/97		myronth	Fixed AddItemToNameTable to work from lobby objects
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Updated SendCreateMessage call to pass NULL for session password
 *  3/28/97     sohailm Request group id message is being signed now if session is secure
 *  4/14/97     sohailm Updated calls to SetupCredentials() to reflect change in params.
 *	5/8/97		myronth	Fixed comment to better reflect the state of affairs
 *  5/12/97     sohialm Updated SendNSNewIDRequest() to process the new PLAYERIDREPLY format
 *	5/17/97		kipo	There was a bug in SendNSNewIDRequest() where it was setting
 *						the ghReplyProcessed event twice on the way out,
 *						which would let handler.c in, trashing the buffer
 *						that SendNSNewIDRequest() was using.
  *	5/18/97		andyco	changed nameserver migration to always send delete / create messages
 *						for new host. nuke item in table if  we add something new
 *						to non-empty spot.
 *	6/16/97		andyco	reset ping timer when we become host
 *  6/22/97     sohailm added support to store security desc in the dplay object on the client
 *	8/19/97		myronth	Send lobby system message when we become the host
 *	8/19/97		myronth	Changed to different lobby system message function
 *	9/29/97		myronth	Fixed group ID on DeleteGroup msgs generated by the
 *						corrupt nametable fixup code (#12533)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/29/97	myronth	Nametable corruption fixes (#15234, #15254)
 *	12/29/97	sohailm	Don't migrate the host in client server or secure sessions (#15224)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	Changed PRV_SendStandardSystemMessage
 *	1/27/98		myronth	Moved debug spew for nametable corruption
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  2/18/98     aarono  changed to direct calls to protocol
 ***************************************************************************/


#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"NS_AllocNameTableEntry"


HRESULT GrowTable(LPDPLAYI_DPLAY this) 
{
	LPVOID	pvTempNameTable;

    pvTempNameTable = DPMEM_REALLOC(this->pNameTable,sizeof(NAMETABLE)*this->uiNameTableSize*2);
    if (!pvTempNameTable) 
    {
    	DPF_ERR("COULD NOT GROW NAME TABLE");	
        return E_OUTOFMEMORY;
    }

    this->pNameTable = pvTempNameTable;
    this->uiNameTableSize *= 2;
    DPF(1,"Grew name table to %d entries\n",this->uiNameTableSize);
    return DP_OK;

}

// this code only executes on the NameServer

DPID MangleID(DWORD index,DWORD dwUnique,DWORD dwKey)
{
	DPID id;

    // construct a mangled id, = dwUnique<<16 | index ^ key
    id = dwUnique<<16;
    id |= index;
   	id ^= dwKey;

	return id;
} // MangleID

HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID)
{
    DWORD index;
    BOOL bFoundSlot=FALSE;
    HRESULT hr = DP_OK;
	BOOL bInvalidID = TRUE; // set to FALSE only when we decide this is not
							// not a restricted id
	
    // find the first unoccupied bucket
    index = this->uiNameTableLastUsed;

    // search fron lastused to end. we do this to keep the
    // bucket usage uniformly distributed in the list (i.e. don't
    // always search from beginning for empty slot...)
    while (!bFoundSlot && (index < this->uiNameTableSize))
    {
        // is this slot empty?
        bFoundSlot = (0 == this->pNameTable[index].dwItem);
        if (!bFoundSlot) index++;
    }
    if (!bFoundSlot) 
    {
        index = 0;
        // search from beginning to last used
        while (!bFoundSlot && (index < this->uiNameTableLastUsed))
        {
            // is this slot empty?
            bFoundSlot = (0 == this->pNameTable[index].dwItem);
            if (!bFoundSlot) index++;
        }
            	
    }
    if (!bFoundSlot) 
    {
    	hr = GrowTable(this);
        if (FAILED(hr)) 
        {
                return hr;
        }
        // try again
    	return NS_AllocNameTableEntry(this,pID);
    }

    // make sure we don't reuse b4 client has time to set item
    this->pNameTable[index].dwItem = NAMETABLE_PENDING;
	this->pNameTable[index].dwUnique++;

    this->uiNameTableLastUsed = index;

    while (bInvalidID)
    {
		// mangle it!
		*pID = MangleID(index,this->pNameTable[index].dwUnique,(DWORD)this->lpsdDesc->dwReserved1);

		// EEEK!  make sure the mangled id is not one of our reserved id's 
		if ( (DPID_SERVERPLAYER == *pID ) || (DPID_ALLPLAYERS == *pID) || 
			(DPID_UNKNOWN == *pID) )
		{
			// bump the unique count, and try again
			DPF(2,"NS_AllocNameTableEntry  --  found invalid id - trying again");
			this->pNameTable[index].dwUnique++;
		}
		else 
		{
			// this id is ok
			bInvalidID = FALSE;
		}
    
    } // while
	
    return DP_OK;
        
} // NS_AllocNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"SendNSNewIDRequest"

/*
 ** CopySecurityDesc
 *
 *  CALLED BY: SendNSNewIDRequest()
 *
 *  PARAMETERS: pSecDescDest - security description ptr (destination)
 *				pSecDescSrc - security descrption ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies a security description while allocating memory for SSPIProvider 
 *                and CAPIProvider strings. These strings need to be freed by the calling 
 *                function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySecurityDesc(LPDPSECURITYDESC pSecDescDest, 
                         LPCDPSECURITYDESC pSecDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSecDescDest && pSecDescSrc);

    memcpy(pSecDescDest, pSecDescSrc, sizeof(DPSECURITYDESC));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSecDescDest->lpszSSPIProviderA), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSecDescDest->lpszCAPIProviderA), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSecDescDest->lpszSSPIProvider), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSecDescDest->lpszCAPIProvider), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeSecurityDesc(pSecDescDest, bAnsi);
    return hr;
} // CopySecurityDesc

// copies the security desc into the dplay object
HRESULT StoreSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC pInSecDesc)
{
    LPDPSECURITYDESC pSecDesc;
    HRESULT hr;

    pSecDesc = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDesc)
    {
        DPF_ERR("Failed to store security desc - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    hr = CopySecurityDesc(pSecDesc, pInSecDesc, FALSE);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to copy security desc - hr=0x%08x",hr);
        goto ERROR_EXIT;
    }

    DPF(1,"SSPI provider: %ls",pSecDesc->lpszSSPIProvider);
    if (pSecDesc->lpszCAPIProvider)
    {
        DPF(1,"CAPI provider: %ls",pSecDesc->lpszCAPIProvider);
    }
    else
    {
        DPF(1,"CAPI provider: Microsoft's RSA Base Provider");
    }

    // success
    this->pSecurityDesc = pSecDesc;
    return DP_OK;

    // NOT a fall through

ERROR_EXIT:

    if (pSecDesc) 
    {
        FreeSecurityDesc(pSecDesc,FALSE);
        DPMEM_FREE(pSecDesc);
    }
    return hr;
}

// send a request for a new id to the namesrvr
// reply will include the id
// hmm, we should send the player stuff w/ the id request,  so ns doesn't get out of sync
HRESULT SendNSNewIDRequest(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer) 
{
    LPMSG_REQUESTPLAYERID pmsg; // the request we will send
    LPMSG_PLAYERIDREPLY pReply=NULL;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	LPBYTE pBuffer;
	DWORD dwTimeout, dwVersion;
    BOOL fLogin=FALSE;
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_REQUESTPLAYERID);
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_REQUESTPLAYERID)(pBuffer + this->dwSPHeaderSize);

	// set up msg
    SET_MESSAGE_HDR(pmsg);
    if (fPlayer) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTPLAYERID);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTGROUPID);

    // need to send flags to name server so it can verify permissions
    // before creating an ID for this player
    pmsg->dwFlags = ((LPDPLAYI_PLAYER)dwItem)->dwFlags;
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= DP_GETID_SCALE;

	if(dwTimeout < 30000){
		dwTimeout=30000;
	}

	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));

	DPF(2,"sending new player id request :: flags = %d,timeout = %d\n",((LPDPLAYI_GROUP)dwItem)->dwFlags,dwTimeout);

	SetupForReply(this, DPSP_MSG_REQUESTPLAYERREPLY);
	
    // call send
	// note that this->pNameServer will be NULL when we're requesting our
	// sysplayers id.  it will be non-null for subsequent requests.
	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pBuffer,
						dwMessageSize,DPSEND_GUARANTEED,FALSE);

	DPMEM_FREE(pBuffer);
	if (FAILED(hr)) 
	{
		DPF_ERR("could not send newplayerid request");
		UnSetupForReply(this);
		return hr;
	}
	
	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

    // wait for the answer
    hr = WaitForReply(this,(PCHAR *)&pReply,NULL,dwTimeout);

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	ASSERT(pReply);

    // get the message version
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);

	// In DX6 and later versioned messages, there is a return code in the
	// reply.  We need to make sure it wasn't an error (#15891)
	if(dwVersion >= DPSP_MSG_DX6VERSION)
	{
		// If we fail, 
		if(FAILED(pReply->hr))
		{
			hr = pReply->hr;
			goto CLEANUP_EXIT;
		}
	}

    *pid = pReply->dwID;

    // If server is DX5 or later and is secure, the reply will contain a security 
	// description detailing the security packages needed for establishing a secure channel
	// with the server.
    if (( dwVersion >= DPSP_MSG_DX5VERSION ) && (pReply->dwSSPIProviderOffset))
    {
        // fix up pointers in security desc in the reply buffer        
		pReply->dpSecDesc.lpszSSPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwSSPIProviderOffset);
		if (pReply->dwCAPIProviderOffset)
		{
			pReply->dpSecDesc.lpszCAPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwCAPIProviderOffset);
		}

        hr = StoreSecurityDesc(this, &(pReply->dpSecDesc));
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to store security desc: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }

        // we need to login
        fLogin = TRUE;

        // set the system player id here, so authentication routines can use it
    	ASSERT(this->pSysPlayer);
        this->pSysPlayer->dwID = *pid;

		// Initialize SSPI and CAPI providers
		hr = LoadSecurityProviders(this, SSPI_CLIENT);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to setup security providers");

			// let handler.c continue
            goto CLEANUP_EXIT;
        }
    }

    if (fLogin)
    {
        hr = Login(this);
        if (FAILED(hr))
        {
            DPF_ERR("User authentication failed...Exiting");
        }
    }

    DPF(2,"received id # %d from name server\n",*pid);

CLEANUP_EXIT:	
    // done
    if(pReply){
		FreeReplyBuffer((PCHAR)pReply);
	}	
    return hr;

} // SendNSNewIDRequest 
	
#undef DPF_MODNAME
#define DPF_MODNAME	"AddItemToNameTable"

// NukeNameTable (below) is about to nuke a player from our (corrupted) nametable
// this routine puts a delete message for that player in our apps message q
// we build a DPSP_MSG_PLAYERMGMT w/ just enough info for BuildDeleteMessage to 
// do it's thing
void QDeleteMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	
	if (fPlayer)
	{
		DPF(5, "Queueing DESTROYPLAYER message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYER);
		msg.dwPlayerID = pPlayer->dwID;
	}
	else
	{
		DPF(5, "Queueing DESTROYGROUP message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUP);
		msg.dwGroupID = pPlayer->dwID;
	}
	
	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteMessage


void QDeletePlayerFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_PLAYER pPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pPlayer->dwID;
	
	DPF(5, "Queueing DELETEPLAYERFROMGROUP message idGroupFrom = %lx, idPlayer = %lx", pGroup->dwID, pPlayer->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeletePlayerFromGroupMessage


void QDeleteGroupFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_GROUP pSubgroup)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUPFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pSubgroup->dwID;
	
	DPF(5, "Queueing DELETEGROUPFROMGROUP message idGroupFrom = %lx, idGroup = %lx", pGroup->dwID, pSubgroup->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteGroupFromGroupMessage


void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom)
    {
		// Only walk the list if it's not the system group	
		if(!(pGroupFrom->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// Next walk the list of players in the group
			pGroupnode = pGroupFrom->pGroupnodes;
			while(pGroupnode)
			{
				if(pGroupnode->pPlayer->dwID == pPlayer->dwID)
				{
					// Queue the DeletePlayerFromGroup message
					QDeletePlayerFromGroupMessage(this, pGroupFrom, pGroupnode->pPlayer);
				}

				// Move to the next one
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Now queue the final destroy message for the player
	QDeleteMessage(this,pPlayer,TRUE);

} // QDeleteAndDestroyMessagesForPlayer


void QDestroyMessageForGroupAndFamily(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP pGroup)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom && (pGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    {
		// Walk the subgroups for this group and see if the group being
		// destroyed is among them.  If it is, send a message.		
		pSubgroup = pGroupFrom->pSubgroups;
		while(pSubgroup)
		{
			// If the ID's match, send the message, but also
			// make sure we don't send a DeleteGroupFromGroup message for
			// a real parent/child relationship
			if((pSubgroup->pGroup->dwID == pGroup->dwID) &&
				(pGroupFrom->dwID != pGroup->dwIDParent))
			{
				QDeleteGroupFromGroupMessage(this, pGroupFrom, pGroup);
			}

			// Move to the next one
			pSubgroup = pSubgroup->pNextSubgroup;
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Next walk the list of players in the group
    pGroupnode = pGroup->pGroupnodes;
    while (pGroupnode)
    {
		// Queue the DeletePlayerFromGroup message
		QDeletePlayerFromGroupMessage(this, pGroup, pGroupnode->pPlayer);

		// Move to the next one
		pGroupnode = pGroupnode->pNextGroupnode;
	}

	// Next walk the list of subgroups (this includes both childres & shortcuts)
	pSubgroup = pGroup->pSubgroups;
	while(pSubgroup)
	{
		// See if the group is just a shortcut or a real child
		if(!(pSubgroup->dwFlags & DPGROUP_SHORTCUT))
		{
			// It's a real child, so just setup the destroy messages
			// NOTE: This goes recursive right here
			QDestroyMessageForGroupAndFamily(this, pSubgroup->pGroup);
		}
		else
		{
			// It's a shortcut, so just queue the deletegroupfromgroup message
			QDeleteGroupFromGroupMessage(this, pGroup, pSubgroup->pGroup);
		}

		// Move to the next one
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	// Now queue the destroy message for the group itself
	QDeleteMessage(this,(LPDPLAYI_PLAYER)pGroup,FALSE);

} // QDestroyMessageForGroupAndFamily


void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	HRESULT hr;
	BOOL fPlayer;
	LPDPLAYI_GROUP pGroup;
	

    TRY
    {
		if (VALID_DPLAY_PLAYER(pPlayer)) fPlayer = TRUE;
		else 
		{
			pGroup = (LPDPLAYI_GROUP)pPlayer;
			if (!VALID_DPLAY_GROUP(pGroup))
			{
				DPF_ERR("found item in nametable - it's not a player or a group - AAAAGH - it's a creepy monster");
				return;
			}
		 	fPlayer = FALSE;
		}
		DPF(0," invalid item found - fPlayer = %d  id = %lx\n",fPlayer,pPlayer->dwID);		
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		ASSERT(FALSE); // ACK!
		return ;
    }

	// now, delete it!	
	if (fPlayer)
	{
		// put a  mesage in the apps message q that the player is being deleted
		QDeleteAndDestroyMessagesForPlayer(this,pPlayer);

		// destroy the player
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
	}
	else
	{
		// put messages in the apps message q that the group and all it's
		// children (and shortcuts) are being destroyed
		QDestroyMessageForGroupAndFamily(this, (LPDPLAYI_GROUP)pPlayer);
		
		// destroy the group
		hr = InternalDestroyGroup(this,(LPDPLAYI_GROUP)pPlayer,FALSE);
	}
	if (FAILED(hr))
	{
		DPF(0,"COULD NOT NUKE ITEM hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	return;
	
}  // NukeNameTableItem


HRESULT AddItemToNameTable(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer,DWORD dwLobbyID)
{
    HRESULT hr=DP_OK;
	DWORD dwUnmangledID;
    DWORD index,unique;
  	BOOL bLocal;
	LPDPLAYI_PLAYER pPlayer = (LPDPLAYI_PLAYER)dwItem;

	// we can cast either a group or a player to a player, since the flags are 
	// in the same place...
	bLocal = (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;

	// non-local players don't need a new index
	if(bLocal)
	{
	  	// If this object is lobby owned, we won't be a nameserver,
		// but we always want to alloc the ID locally anyway
		if(IS_LOBBY_OWNED(this))
		{
			hr = NS_AllocNameTableEntry(this, pid);
		}
		else
		{
			ASSERT(this->pSysPlayer);

			// ask ns for an index
			// if we're the namesrvr, just go get it
			if(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
			{
				hr = NS_AllocNameTableEntry(this,pid);    	
			}
			else 
			{
				hr = SendNSNewIDRequest(this,dwItem,pid,fPlayer);
			}
		}

		if (FAILED(hr)) 
		{
			DPF_ERR("could not get new id for item");
			return hr;	
		}
	}

	dwUnmangledID = *pid ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

	// do we need to grow the table?
	// if so, keep growing it until its big enough...
    while (index >= this->uiNameTableSize) 
    {
        hr = GrowTable(this);
        if (FAILED(hr)) 
        {
            return hr;
        }

    }

    if (index > this->uiNameTableSize ) 
    {
        ASSERT(FALSE); // ??? rut ro
        return E_UNEXPECTED;
    }

	// if there is already something here.
	// this means we missed a system message (e.g. deleteplayer or deletegroup)
	// and our nametable is corrupt.  we will hope for the best, and delete the
	// item here. andyco.
	if (this->pNameTable[index].dwItem &&  (NAMETABLE_PENDING != this->pNameTable[index].dwItem))
	{
		DPF(5,"		!!!   NAMETABLE CORRUPTION DETECTED.  DPLAY WILL CORRECT ITSELF	!!!");
		NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
	} 

	this->pNameTable[index].dwItem = dwItem;
	this->pNameTable[index].dwUnique = unique;

	// If this is a lobby session, we need to make the ID be the lobby ID
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_AddMapIDNode(this->lpLobbyObject, dwLobbyID, *pid);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to add an entry to the map table, hr = 0x%08x", hr);
			NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
			return hr;
		}

		// Fix the output dpid to be the lobby ID
		*pid = dwLobbyID;
	}

	return hr;
} // AddItemToNameTable

#undef DPF_MODNAME
#define DPF_MODNAME	"FreeNameTableEntry"

// mark this spot in the name table as unused
HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY this,DWORD dpid)
{
    HRESULT hr=DP_OK;
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DWORD id;

	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return E_UNEXPECTED;
	}

	// don't get upset if they try to free the system group or server player id	
	if (DPID_ALLPLAYERS == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_ALLPLAYERS - ignoring");
		return DP_OK;
	}
	
	if (DPID_SERVERPLAYER == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_SERVERPLAYER - ignoring");
		return DP_OK;
	}
	
	
	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF_ERRVAL("Unable to unmap id %lu, not freeing nametable entry", dpid);
			ASSERT(FALSE);
			return DPERR_INVALIDPARAM;
		}
	}
	else
		id = dpid;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
    index = dwUnmangledID & INDEX_MASK;
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	ASSERT(FALSE); 	// ACK!!!
    	// this should *NEVER* happen!
    	// should almost be an int 3 here ?
    	// andyco. 10/14/96
    	DPF_ERR("asked for element outside table!");
        return E_UNEXPECTED;
    }

    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF_ERR("asked for invalid element");
        return E_UNEXPECTED;	 
    }

    if (NAMETABLE_PENDING == this->pNameTable[index].dwItem)
    {
        // remove client info
        if (this->pNameTable[index].pvData)
        {
            DPMEM_FREE(this->pNameTable[index].pvData);
        }
    }

    this->pNameTable[index].dwItem = 0;
    this->pNameTable[index].pvData = NULL;

	// Now delete them from the map table if this is a lobby session
	if(IS_LOBBY_OWNED(this))
	{
		PRV_DeleteMapIDNode(this->lpLobbyObject, dpid);
	}

    return hr;
}// FreeNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"IsValidID"

// check the element at location index in the nametable.
// (if its unique code matches) 
BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id) 
{	
	if (DPID_ALLPLAYERS == id)
	{
		// it's ok.  they tried to resolve the system group to a player
		DPF(8,"asked for id == DPID_ALLPLAYERS - failing");
		return FALSE;
	}
	
	if (DPID_SERVERPLAYER == id)
	{
		// it's ok.  they tried to resolve the server player to a group.
		DPF(8,"asked for id == DPID_SERVERPLAYER - failing");
		return FALSE;
	}
	
	if (!(this->lpsdDesc))
	{
		DPF(1,"unable to resolve player id - session closed");
		return FALSE;
	}	
	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return FALSE;
	}

    return TRUE;

} // IsValidID

#undef DPF_MODNAME
#define DPF_MODNAME	"DataFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return NULL;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id))
        return NULL;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"DataFromID:asked for element outside table - id = %d!",id);
        return NULL;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"DataFromID:asked for element w/ invalid tag - id = %d!",id);
        return NULL;
    }

    return this->pNameTable[index].pvData;
} // DataFromID

#undef DPF_MODNAME
#define DPF_MODNAME	"NameFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
DWORD_PTR NameFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return 0;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id)) return 0;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"NameFromID:asked for element outside table - id = %d!",id);
        return 0;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"NameFromID:asked for element w/ invalid tag - id = %d!",id);
        return 0;
    }

    return this->pNameTable[index].dwItem;
} // NameFromID
    
// return a dplay group corresponding to id.
// return null if id not valid
LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY this,DWORD idGroupID) 
{
	if (DPID_ALLPLAYERS == idGroupID)
	{
		if (!this->pSysGroup)
		{
			DPF_ERR("System group not found");
			return NULL;	
		} 
		return this->pSysGroup;
	}
    return (LPDPLAYI_GROUP)NameFromID(this,idGroupID);	
} // GroupFromID
// return a dplay player corresponding to id.
// return null if id not valid
LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY this,DWORD idPlayerID)
{
	if (DPID_SERVERPLAYER == idPlayerID)
	{
		if (!this->pServerPlayer)
		{
			DPF_ERR(" server player not found");
			return NULL;	
		} 
		return this->pServerPlayer;
	}
    return (LPDPLAYI_PLAYER)NameFromID(this,idPlayerID);		
} // PlayerFromID

// Someone is telling us they are the new nameserver.
HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, LPVOID pvSPHeader)
{
	LPDPLAYI_PLAYER pPlayer;
	HRESULT hr;
	DPSP_DELETEPLAYERDATA dd;

	pPlayer=PlayerFromID(this, pmsg->dwIDHost);

	if(!pPlayer){
		return DPERR_INVALIDPLAYER;
	}

	if(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL){
		return DP_OK;
	}

	dd.idPlayer       = pPlayer->dwID;
	dd.dwFlags        = pPlayer->dwFlags;
	dd.lpISP          = this->pISP;

	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer, &dd);

	if(FAILED(hr)){
		DPF_ERR("SP Could Not Delete Player in preparation for flags change in NS_HandleIamNameServer\n");
	}

	pPlayer->dwFlags = ((pPlayer->dwFlags & DPLAYI_PLAYER_NONPROP_FLAGS) | pmsg->dwFlags);
	
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
	
	pPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;//paranoia
	this->pNameServer = pPlayer;

	// BUGBUG: blows away the header.  May not be compatible with all SPs.
	if(pPlayer->pvSPData){
		DPMEM_FREE(pPlayer->pvSPData);
	}

	pPlayer->pvSPData=DPMEM_ALLOC(pmsg->dwSPDataSize+1);
	if(!pPlayer->pvSPData){
		DPF_ERR("Ran out of memory trying to allocate spdata block\n");
		hr=DPERR_OUTOFMEMORY;
		return hr;
	}
	memcpy(pPlayer->pvSPData, pmsg->SPData, pmsg->dwSPDataSize);
	pPlayer->dwSPDataSize=pmsg->dwSPDataSize;
	
	hr = CallSPCreatePlayer(this,pPlayer,FALSE,pvSPHeader,FALSE);
	
	if(FAILED(hr)){
		DPF_ERR("SP Couldn't Recreate Player in NS_HandleIamNameServer\n");
		return hr;
	}
	
	this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
	
	return hr;

}


// the nameserver has migrated to this client
// we need to recreate our sysplayer as  the nameserver
// we don't actually destroy the sysplayer, we just call the sp's
// destroy for the old (non-nameserver) and then create for the
// new (nameserver)
HRESULT MakeMeNameServer(LPDPLAYI_DPLAY this)
{
    DPSP_DELETEPLAYERDATA dd;
	HRESULT hr;

	DPF(0,"the name server has migrated to this client!");
	ASSERT(this->pSysPlayer);

	if (!this->pSysPlayer)
		return E_FAIL;

	// call sp delete player
	if (this->pcbSPCallbacks->DeletePlayer)
    {
	    // call sp
		dd.idPlayer = this->pSysPlayer->dwID;
		dd.dwFlags = this->pSysPlayer->dwFlags;
		dd.lpISP = this->pISP;

 	 	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
 	 	
		if (FAILED(hr)) 
		{
			DPF_ERR(" SP could not delete sysplayer in preparation for migration"); 
			ASSERT(FALSE);
			// keep trying...
		}
	}
	
	// free up the sp data
	if (this->pSysPlayer->pvSPData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPData);
		this->pSysPlayer->pvSPData = NULL;
	}
	
	if (this->pSysPlayer->pvSPLocalData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPLocalData);	
		this->pSysPlayer->pvSPLocalData = NULL;
	}
	this->pSysPlayer->dwSPLocalDataSize = 0;
	this->pSysPlayer->dwSPDataSize = 0;

	// get the sp to make us a nameserver (poof - you're a nameserver!)	
	this->pSysPlayer->dwFlags |= DPLAYI_PLAYER_NAMESRVR;
	// now, call the sp to create our nameserver
	hr = CallSPCreatePlayer(this,this->pSysPlayer,TRUE,NULL,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"could not migrate nameserver - sp create player failed hr = 0x%08lx\n",hr);
		DPF(0,"game play should continue normally, but there is no more nameserver");
		// we should be ok to keep going here.  the nameserver is toast, but the game should go on...
		return hr;
	}

	// a-josbor: make sure the dplay thread is running to care for the reservation count
	StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	

	// remember that we are the system player
	this->pNameServer = this->pSysPlayer;

	if((this->dwMinVersion >= DPSP_MSG_DX61VERSION) && 
	   (this->dwMinVersion >= DPSP_MSG_DX61AVERSION || this->pProtocol)){
		// we used to tell everyone that the system player was deleted and then
		// recreated.  This is a very bad thing to do with the protocol running
		// so we instead send an IAMHOST message to give the other players a chance
		// to update their information on who is the name server.
		hr=SendIAmNameServer(this);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
	} else {
		// tell the world about our new player
		// 1st, delete the non-nameserver old player
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER|DPSP_MSG_ASYNC, 
			this->pSysPlayer->dwID,0);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		
		// now, create the new nameserver player
		hr = SendCreateMessage( this, this->pSysPlayer,TRUE,NULL);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

	}
	// tell our local players we're the nameserver
	hr = SendMeNameServer(this);
	if (FAILED(hr))
	{
		DPF(0,"could not send name server message - hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	// Send a system message to the lobby server, telling them the
	// host just migrated to this client
	PRV_SendStandardSystemMessage(this->lpLaunchingLobbyObject,
			DPLSYS_NEWSESSIONHOST, DPLOBBYPR_GAMEID);

	// reset our ping counter, so we don't start sending pings
	// until things have settled down...
	this->dwLastPing = GetTickCount();
	
	return DP_OK;
	
} // MakeMeNameServer

// called by handler.c when it gets a dp_deleteplayer on 
// the namesrvr
HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this)
{
	DWORD IDMin; // the minimum player id, and the index of that id
	BOOL bFound = FALSE;
	LPDPLAYI_PLAYER pPlayer,pNewServer = NULL;	
	HRESULT hr = DP_OK;

	// In a client-server or secure session, don't migrate the host
	if ( (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) 
		||  (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) 
		|| !(this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) )
	{
		DPF(0,"Name server is dead.  Game over!");
		return HandleSessionLost(this);
	}

	DPF(0,"Name server dead.  Finding new name server");

	IDMin = (DWORD) -1;

	// search the name table, looking for a new namesrvr
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if (DPLAYI_PLAYER_SYSPLAYER & pPlayer->dwFlags )
		{
			if (pPlayer->dwID < IDMin) 
			{
				bFound=TRUE;
				IDMin = pPlayer->dwID;
				pNewServer = pPlayer;
			} // id < idMin
		} // sysplayer
		pPlayer = pPlayer->pNextPlayer;
	} // while

	if (!bFound) 
	{
		DPF(0,"Could not find new name srvr - ack!");
		return E_FAIL;
	}

	DPF(0,"found new name srvr - id = %d\n",IDMin);

	if (this->pSysPlayer && (this->pSysPlayer->dwID == IDMin)) 
	{
		this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
		hr = MakeMeNameServer(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// we should be ok to keep going here
		}
	} // id == idmin
	else {
		// Mark no nameserver and do keepalives until we find one.
		this->dwFlags |= DPLAYI_DPLAY_NONAMESERVER;
		StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
	}

	return hr;

} // HandleDeadNameServer


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\pending.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pending.c
 *  Content:	manage commands received while we're waiting for the
 *				nametable, or while we've dropped our lock during a 
 *				guaranteed send.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	6/3/96		andyco	created it.
 *	7/10/96		andyco	updated w/ pendingnodes, etc.
 *	2/1/97		andyco	modified pending so we can use it when we drop the 
 *						lock for guaranteed sends
 *	2/18/97		andyco	push pending nodes onto back (end) of Q
 *  3/17/97     sohailm push pending shouldn't copy the sp header if it is
 *                      DPSP_HEADER_LOCALMSG
 *	6/18/97		andyco	checkpending called playerfromid, and then checked for
 *						!NULL.  But, if we're the namesrvr, it could return
 *						NAMETABLE_PENDING. So, we have to call VALID_PLAYER or
 *						VALID_GROUP instead.
 *  7/28/97		sohailm	Updated pending code to enable sends in pending mode.
 *	8/29/97		sohailm	Copy sp header correctly for local messages in pushpending (bug 43571)
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *  6/19/98 	aarono  add last ptr for message queues, makes insert
 *               	    constant time instead of O(n) where n is number
 *                 		of messages in queue.
 ***************************************************************************/

#include "dplaypr.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"PushPendingCommand"

// we got a command.
// we don't have the nametable yet, so add this command to the
// pending list...
HRESULT PushPendingCommand(LPDPLAYI_DPLAY this,LPVOID pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPPENDINGNODE pmsg=NULL;
	LPVOID pReceiveCopy=NULL; // we will copy pReceiveBuffer here (SP reuses buffer)
	LPVOID pHeaderCopy=NULL; // alloc'ed if needed
	HRESULT hr;
	
	ASSERT(this->dwFlags & DPLAYI_DPLAY_PENDING);

	if (!pReceiveBuffer) return DP_OK;

	// get the pending node
	pmsg = DPMEM_ALLOC(sizeof(PENDINGNODE));
	if (!pmsg)
	{
		DPF_ERR("could not alloc new pending node - out of memory");
		return E_OUTOFMEMORY;
	}

	// copy over the message
	pReceiveCopy = DPMEM_ALLOC(dwMessageSize);
	if (!pReceiveCopy)
	{
		DPF_ERR("could not alloc pending copy buffer - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}

	memcpy(pReceiveCopy,pReceiveBuffer,dwMessageSize);

	// copy over the header, if needed
	if (pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader))
	{
		pHeaderCopy = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pHeaderCopy)
		{			
			DPF_ERR("could not alloc pending copy header buffer - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pHeaderCopy,pvSPHeader,this->dwSPHeaderSize);
	}
	else 
	{
		pHeaderCopy = pvSPHeader;
	}

	// store a copy of the command
	pmsg->pMessage = pReceiveCopy;
	pmsg->dwMessageSize = dwMessageSize;
	pmsg->pHeader = pHeaderCopy;
	pmsg->dwSendFlags = dwSendFlags; // for security code.  e.g. DPSEND_ENCRYPTED
	
	// stick pmsg on the back of the list
	if(this->pMessagesPending){
		this->pLastPendingMessage->pNextNode=pmsg;
		this->pLastPendingMessage=pmsg;
	} else {
		this->pMessagesPending=pmsg;
		this->pLastPendingMessage=pmsg;
	}

	// bump the pending count
	this->nMessagesPending++;

	// success
	return DP_OK;	

ERROR_EXIT:
	if (pmsg) DPMEM_FREE(pmsg);
	if (pReceiveCopy) DPMEM_FREE(pReceiveCopy);
	if (VALID_SPHEADER(pHeaderCopy)) DPMEM_FREE(pHeaderCopy);

	// failure
	return hr;

} // PushPendingCommand

#undef DPF_MODNAME
#define DPF_MODNAME	"ExecutePendingCommands"

// see if our pending message is a create that we got w/ the name
// table (i.e. filter redundant creates, since they would hose our
// unpack code...
HRESULT CheckPendingMessage(LPDPLAYI_DPLAY this,LPPENDINGNODE pmsg)
{
	DWORD dwCommand;

    // extract command
	if ((pmsg->dwMessageSize < sizeof(DWORD)) || (IS_PLAYER_MESSAGE(pmsg->pMessage)))
	{
		dwCommand = DPSP_MSG_PLAYERMESSAGE;
	}
	else 
	{
	    dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pmsg->pMessage));
	}
	
	switch (dwCommand)
	{

		case DPSP_MSG_CREATEPLAYER:
		{
			DWORD dwPlayerID;
			LPDPLAYI_PLAYER pPlayer;

			dwPlayerID = ((LPMSG_PLAYERMGMTMESSAGE)(pmsg->pMessage))->dwPlayerID;
			// see if it already exists
			pPlayer = PlayerFromID(this,dwPlayerID);
	        if (VALID_DPLAY_PLAYER(pPlayer))
	        {
				DPF(1,"got redundant create message in pending list id = %d - discarding",dwPlayerID);
				return E_FAIL; // squash it
			}
			
			break;
		}		
		case DPSP_MSG_CREATEGROUP:
		{
			DWORD dwPlayerID;
			LPDPLAYI_GROUP pGroup;

			dwPlayerID = ((LPMSG_PLAYERMGMTMESSAGE)(pmsg->pMessage))->dwPlayerID;
			// see if it already exists
			pGroup = GroupFromID(this,dwPlayerID);
	        if (VALID_DPLAY_GROUP(pGroup))
	        {
				DPF(1,"got redundant create message in pending list id = %d - discarding",dwPlayerID);
				return E_FAIL; // squash it
			}

			break;
		}		

		default:
			// other messages will be benign (e.g. deletes won't delete twice, etc.)
			// let it through
			break;

	} // switch

	return DP_OK;

} // CheckPendingMessage

// run through the list of pending commands
// call handler.c w/ q'ed up commands
// caller expects this function to clear DPLAYI_DPLAY_PENDING flag
// while executing pending commands, all new messages go on the pending queue.
HRESULT ExecutePendingCommands(LPDPLAYI_DPLAY this)	
{
	LPPENDINGNODE pmsg,pmsgDelete;
	HRESULT hr;
	DWORD nMessagesPending;

	if(!(this->dwFlags & DPLAYI_DPLAY_PENDING)){
		return DP_OK;
	}

	ASSERT(this->dwFlags & DPLAYI_DPLAY_PENDING);
	ASSERT(this->pSysPlayer);
	
    if (this->dwFlags & DPLAYI_DPLAY_EXECUTINGPENDING)
    {
		// we get here when we try to flush the pending queue after completing a 
		// reliable send in execute pending mode.
        DPF(7,"We are already in execute pending mode - not flushing the pending queue");
        return DP_OK;
    }

	if (this->nMessagesPending) 
	{
		DPF(7,"STARTING -- EXECUTING PENDING LIST nCommands = %d\n",this->nMessagesPending);
		DPF(7,"	NOTE - ERROR MESSAGES GENERATED WHILE EXECUTING PENDING MAY BE BENIGN");
	}
	else 
	{
		ASSERT(NULL == this->pMessagesPending);
		this->dwFlags &= ~DPLAYI_DPLAY_PENDING;
		return DP_OK;
	}

	// mark that we're exec'ing the pending list, so player messages don't get copied again
	this->dwFlags |= DPLAYI_DPLAY_EXECUTINGPENDING;
	
	while (this->nMessagesPending)
	{
		// take the pending queue out of circulation
		pmsg = this->pMessagesPending;
		nMessagesPending = this->nMessagesPending;
		this->pMessagesPending = NULL;
		this->pLastPendingMessage = NULL;
		this->nMessagesPending = 0;

		while (pmsg)
		{
			nMessagesPending--;

			// checkpending looks for dup messages
			hr = CheckPendingMessage(this,pmsg);
			if (SUCCEEDED(hr))
			{
				// drop the lock since InternalHandleMessage will take it again
				LEAVE_DPLAY();

				hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,pmsg->pMessage,
					pmsg->dwMessageSize,pmsg->pHeader,pmsg->dwSendFlags);

				ENTER_DPLAY();

				if (FAILED(hr))
				{
					// todo - do we care about hresult here?
					// this can fail e.g. due to commands we q'ed being processed by
					// namesrvr b4 it send us the nametable...
					ASSERT(FALSE);
					// keep going...
				}
			}

			pmsgDelete = pmsg;
			pmsg = pmsg->pNextNode;  // store this now so we don't blow it away
			
			// clean up pmsgDelete
			if (pmsgDelete->pMessage) DPMEM_FREE(pmsgDelete->pMessage);
			if (VALID_SPHEADER(pmsgDelete->pHeader)) DPMEM_FREE(pmsgDelete->pHeader);
			DPMEM_FREE(pmsgDelete);
		}

		ASSERT(0 == nMessagesPending);

		// messages might have come into the pending queue when we dropped the lock
		// make sure they are all processed before exiting the loop
		DPF(7,"%d messages were pushed on the pending queue in execute pending mode",this->nMessagesPending);
	}

	ASSERT(0  == this->nMessagesPending);
	
	DPF(7,"FINISHED -- EXECUTING PENDING LIST - ERRORS NO LONGER BENIGN");
	
	// reset pending flags
	this->dwFlags &= ~(DPLAYI_DPLAY_EXECUTINGPENDING | DPLAYI_DPLAY_PENDING);
	
	return DP_OK;

} // ExecutePendingCommands

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\paketize.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       paketize.c
*  Content:		break sends or replies up into sp-size packets
*  History:
*   Date		By		Reason
*   ====		==		======
*	7/25/96		andyco	created it 'cause IPX is wont packetize for
*						us.
*	7/26/96		kipo	check for pvSPHeader == NULL before calling memcpy (#2654)
*   3/18/97     sohailm HandlePacket shouldn't copy the sp header if it is
*                       DPSP_HEADER_LOCALMSG
*   6/17/97     aarono  Added reliability
*   2/2/98      aarono  Added test for closing to SendTimeOut
*   2/3/98      aarono  Fixed Paketize test for RAW mode
*   2/18/98     aarono  changed error checks to FAILED(hr)
*   3/5/98      aarono  NeedsReliablePacketize won't say so for 
*                       ENUMSESSIONSREPLY as this can lead to machines with
*                       improper IPX net number hanging up the host.
*   3/9/98      aarono  added more messages to packetize to avoid deadlocks.
*   3/13/98     aarono  rearchitected packetize retry/timeout for NT mmTimer 
*                       contraints.
*   3/26/98     aarono  B#21476 free retry packet nodes during close
*   4/1/98      aarono  B#21476 also need to free from timeoutlist
*   4/24/98     aarono  DX5 compat, reduce size of packetize messages
*    6/6/98     aarono  Fix for handling large loopback messages with protocol
*   6/19/98     aarono  Don't do our own reliability when the SP does it already.
*   8/21/98     aarono  Don't send packetize messages to machines with no nametable.
*
***************************************************************************/

#include "dplaypr.h"
#include <mmsystem.h>
#include "..\protocol\mytimer.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandlePacket"

VOID StartPacketizeTicker(LPDPLAYI_DPLAY this);
VOID SendPacketizeACK(LPDPLAYI_DPLAY this, LPPACKETNODE pNode,LPMSG_PACKET pmsg);
VOID SendNextPacket(LPDPLAYI_DPLAY this, LPPACKETNODE pNode, BOOL bInDplay);
void BlowAwayPacketNode(LPDPLAYI_DPLAY this, LPPACKETNODE pNode);

#define PACKETIZE_RECEIVE_TIMEOUT   60000	/* Always give up after this ms time */
#define MIN_RECEIVE_TIMEOUT         10000   /* Never give up before this ms time */
#define TICKER_INTERVAL  			15000	/* Check for expired receives this often*/
#define TICKER_RESOLUTION 			1000	/* How accurate we want the ticker (not very) */
#define MAX_PACKETIZE_RETRY 		16		/* Generally how often to retry before giving up*/

#define SIGNATURE(a,b,c,d) (UINT)(a+(b<<8)+(c<<16)+(d<<24))

#define NODE_SIGN SIGNATURE('N','O','D','E')
#define NODE_UNSIGN SIGNATURE('n','o','d','e')

// The PacketizeTimeoutListLock controls access to the PacketizeTimeoutList AND the 
// RetryList in each DPLAY object.  Use PACKETIZE_LOCK() PACKETIZE_UNLOCK() macros.
CRITICAL_SECTION g_PacketizeTimeoutListLock;
BILINK           g_PacketizeTimeoutList={&g_PacketizeTimeoutList, &g_PacketizeTimeoutList};


BOOL NeedsReliablePacketize(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, DWORD dwFlags)
{

	if ((dwFlags & DPSEND_GUARANTEED) &&
	    (this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE|DPLAYI_DPLAY_PROTOCOL)) && 
	    (dwVersion >= DPSP_MSG_RELIABLEVERSION))
	{
		switch (dwCommand)
		{
			//case DPSP_MSG_ENUMSESSIONSREPLY: -- can't do enumsession reply on packetizer
			//                                    since remote may be invalid subnet, hanging
			//                                    machine as IPX does RIPs, actually crashing IPX too.
			case DPSP_MSG_ENUMSESSIONS:
			case DPSP_MSG_ENUMPLAYER:
			case DPSP_MSG_ENUMPLAYERSREPLY:
			case DPSP_MSG_REQUESTGROUPID:
			case DPSP_MSG_REQUESTPLAYERID:
			case DPSP_MSG_CREATEGROUP:
			case DPSP_MSG_DELETEGROUP:
			case DPSP_MSG_REQUESTPLAYERREPLY:
			case DPSP_MSG_ADDFORWARDREQUEST:
			case DPSP_MSG_NAMESERVER:
			case DPSP_MSG_SESSIONDESCCHANGED:
			case DPSP_MSG_CREATEPLAYER:	
			case DPSP_MSG_DELETEPLAYER: 
			case DPSP_MSG_ADDPLAYERTOGROUP:
			case DPSP_MSG_DELETEPLAYERFROMGROUP:
			case DPSP_MSG_ADDFORWARDREPLY:
			case DPSP_MSG_ADDSHORTCUTTOGROUP:
			case DPSP_MSG_DELETEGROUPFROMGROUP:
			case DPSP_MSG_SUPERENUMPLAYERSREPLY:
			case DPSP_MSG_CHAT:
			case DPSP_MSG_ADDFORWARD:			
			case DPSP_MSG_ADDFORWARDACK:
			case DPSP_MSG_ASK4MULTICAST:
			case DPSP_MSG_ASK4MULTICASTGUARANTEED:
			case DPSP_MSG_IAMNAMESERVER:
			return TRUE;
				
			default:
				return FALSE;
		}
	} else {
		return FALSE;
	}

}

// Not quite symetric with Init, must kill the thread before calling this.
// key of non-zero this->hRetry to see if this is necessary.
VOID FiniPacketize(LPDPLAYI_DPLAY this)
{
	FreePacketizeRetryList(this);
	CloseHandle(this->hRetry);
	this->hRetry=0;
}

// Free Packetize Retry List
VOID FreePacketizeRetryList(LPDPLAYI_DPLAY this)
{
	LPPACKETNODE pNode;
	BILINK *pBilink;

	PACKETIZE_LOCK();

	// pull off retry list
	while(!EMPTY_BILINK(&this->RetryList)){
		pBilink=this->RetryList.next;
		pNode=CONTAINING_RECORD(pBilink, PACKETNODE, RetryList);

		BlowAwayPacketNode(this, pNode);
	}	

	// pull off timeout list
	pBilink=g_PacketizeTimeoutList.next;
	while(pBilink != &g_PacketizeTimeoutList){
		pNode=CONTAINING_RECORD(pBilink, PACKETNODE, TimeoutList);
		pBilink=pBilink->next;

		if(this==pNode->lpDPlay){
			BlowAwayPacketNode(this, pNode);
		}
	}

	PACKETIZE_UNLOCK();
}

// Initialize for packetize and send reliable.
HRESULT InitPacketize(LPDPLAYI_DPLAY this)
{
	HRESULT hr;
	DWORD dwThreadID;

	this->hRetry=CreateEventA(NULL,FALSE,FALSE,NULL);
	if(!this->hRetry){
		DPF(0,"InitPacketize failing, couldn't allocate retry thread event\n");
		hr=DPERR_OUTOFMEMORY;
		goto EXIT;
	}

	this->hRetryThread=CreateThread(NULL,4096,PacketizeRetryThread,this,0,&dwThreadID);
	if(!this->hRetryThread){
		DPF(0,"InitPacketize failing, couldn't allocate retry thread\n");
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_EXIT;
	}

	InitBilink(&this->RetryList);

	hr=DP_OK;
	
EXIT:
	return hr;

ERROR_EXIT:
	if(this->hRetry){
		CloseHandle(this->hRetry);
		this->hRetry=0;
	}
	return hr;
}

// need a thread to do retries for reliable sends due to problems dealing
// with differences between NT and Win95 mmTimers.
DWORD WINAPI PacketizeRetryThread(LPDPLAYI_DPLAY this)
{
	BILINK *pBilink;
	LPPACKETNODE pNode;
	UINT tmCurrentTime;

	DPF(9,"==>PacketizeRetryThread starting\n");

	while(TRUE){
	
		// wait for a message to send or shutdown.
		WaitForSingleObject(this->hRetry, INFINITE); 

		if(this->dwFlags & DPLAYI_DPLAY_CLOSED){
			// we test here in case of an error during startup, in this
			// case the error path of startup is the only thread that
			// could have signaled us.
			break;
		}
		
		tmCurrentTime=timeGetTime();
		
		ENTER_ALL();
		PACKETIZE_LOCK();
		
		while(!EMPTY_BILINK(&this->RetryList)){

			pBilink=this->RetryList.next;
			pNode=CONTAINING_RECORD(pBilink, PACKETNODE, RetryList);
			Delete(&pNode->RetryList);
			InitBilink(&pNode->RetryList);
			
			if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
			{
				// DP_CLOSE signaled us to shut down.
				PACKETIZE_UNLOCK();
				LEAVE_ALL();
				goto ERROR_EXIT;
			}

			pNode->dwRetryCount++;
			if((pNode->dwRetryCount>=MAX_PACKETIZE_RETRY) && 
		 	   (tmCurrentTime-pNode->tmTransmitTime > MIN_RECEIVE_TIMEOUT)){
				DPF(5,"Packetize SendTimeOut: Exceeded Max Retries, giving up (quietly!)\n");
				BlowAwayPacketNode(this, pNode);
				continue;
			}

			if(this->pProtocol){
				EnterCriticalSection(&this->pProtocol->m_SPLock);// don't re-enter SP.
				SendNextPacket(this,pNode,TRUE);
				LeaveCriticalSection(&this->pProtocol->m_SPLock);
			} else {
				SendNextPacket(this,pNode,TRUE);
			}	
		}
		
		PACKETIZE_UNLOCK();
		LEAVE_ALL();
	}


	DPF(1,"<== PacketizeRetryThread Exiting\n");
ERROR_EXIT:
	return TRUE;
	
}

VOID CancelPacketizeRetryTimer(LPPACKETNODE  pNode)
{
	UINT_PTR uRetry=0;
	HRESULT rc;
	DWORD Unique;

	ASSERT(pNode->bReliable);

	PACKETIZE_LOCK();
	
		if(!EMPTY_BILINK(&pNode->TimeoutList)){
			uRetry=pNode->uRetryTimer;
			Unique=pNode->Unique;
			pNode->uRetryTimer=0;
			Delete(&pNode->TimeoutList);
			InitBilink(&pNode->TimeoutList);
		}	

		if(!EMPTY_BILINK(&pNode->RetryList)){
			Delete(&pNode->RetryList);
			InitBilink(&pNode->RetryList);
		}
		
	PACKETIZE_UNLOCK();
	
	if(uRetry){
		rc=CancelMyTimer(uRetry,Unique);
		DPF(9,"CancelTimer:KillEvent %x returned %x\n",uRetry,rc);
	}	
}

// free up the contents of a single packetnode
// called by handlepacket and DP_Close (via FreePacketList)
void FreePacketNode(LPPACKETNODE pNode)
{
#ifdef DEBUG
	DPF(8,"Freeing Packet Node: %x",pNode);
	if(pNode->bReliable){
		DPF(8," Reliable ");
	}else{
		DPF(8," Unreliable ");
	}
	if(pNode->bReceive){
		DPF(8,"Receive, age %d ms\n",timeGetTime()-pNode->tmLastReceive);
	} else {
		DPF(8,"Send\n");
	}

	if(pNode->Signature != NODE_SIGN){
		DPF(0,"INVALID PACKET NODE %x, Sign %x\n",pNode, pNode->Signature);
		DEBUG_BREAK();
	}
#endif
	
	if(pNode->bReliable && !(pNode->bReceive)){
		CancelPacketizeRetryTimer(pNode);
	}	
	pNode->Signature=NODE_UNSIGN;
	if (pNode->pBuffer) DPMEM_FREE(pNode->pBuffer);
	if (VALID_SPHEADER(pNode->pvSPHeader)) DPMEM_FREE(pNode->pvSPHeader);
	DPMEM_FREE(pNode);

} // FreePacketNode

// like FreePacketNode, but also does the list removal - only for Send nodes.
void BlowAwayPacketNode(LPDPLAYI_DPLAY this, LPPACKETNODE pNode)
{
	LPPACKETNODE pNodeWalker;

	DPF(8,"==>BlowAwayPacketNode\n");

	pNodeWalker=(LPPACKETNODE)&this->pPacketList; //tricky...

	while(pNodeWalker && pNodeWalker->pNext!=pNode){
		pNodeWalker=pNodeWalker->pNext;
		ASSERT(pNodeWalker->Signature==NODE_SIGN);
	}
	if(pNodeWalker){
		pNodeWalker->pNext=pNode->pNext;
	}else{
		DPF(0,"ERROR: tried to remove packetnode not on list pNode=%x\n",pNode);
		ASSERT(0);
		DEBUG_BREAK();
	}
		
	FreePacketNode(pNode);
	DPF(8,"<==BlowAwayPacketNode\n");
}

/*
 ** NewPacketnode
 *
 *  CALLED BY:	 HandlePacket, PacketizeAndSend.
 *
 *  PARAMETERS:
 *				ppNode - node to be alloc'ed
 *				pmsg - first packet received in message we're alloc'ing for
 *
 *  DESCRIPTION:
 *				alloc space for a new packetnode
 *				set up static data (e.g. guid, total num packets, etc.)
 *				we actually copy pmsg->pmessage over in HandlePacket
 *
 *  			Note: PacketNodes are used for both sending and receiving
 *                    Packetized Messages
 *
 *  RETURNS:  DP_OK or E_OUTOFMEMORY
 *
 */
HRESULT NewPacketnode(
	LPDPLAYI_DPLAY this,
	LPPACKETNODE * ppNode,
	LPGUID lpGUID,
	DWORD  dwMessageSize,
	DWORD  dwTotalPackets,
	LPVOID pvSPHeader
)	
{
	HRESULT hr;
	DWORD   dwExtraSize;

	LPPACKETNODE pNode;

	// alloc the node
	pNode = DPMEM_ALLOC(sizeof(PACKETNODE));
	
	if (!pNode)
	{
		DPF_ERR("could not get new packetnode -  out of memory");
		hr =  E_OUTOFMEMORY;
		return hr;
	}

	InitBilink(&pNode->TimeoutList);
	InitBilink(&pNode->RetryList);

	pNode->Signature = NODE_SIGN; // must be here so error path doesn't debug_break()
	
	DPF(8,"NewPacketNode: %x\n",pNode);

	dwExtraSize=this->dwSPHeaderSize+sizeof(MSG_PACKET);
	// alloc the buffer - extra space at front so we can build send buffers.
	pNode->pBuffer = DPMEM_ALLOC(dwMessageSize+dwExtraSize);
	if (!pNode->pBuffer)
	{
		DPF_ERR("could not get buffer for new packetnode -  out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	
	pNode->pMessage = pNode->pBuffer + dwExtraSize;

	// alloc and copy the header (if necessary)
	
	if (pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader)){
	
		pNode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pNode->pvSPHeader)
		{
			DPF_ERR("could not get header for new packetnode");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pNode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
		
	}	

	// stick the new node on the front of the list
	pNode->pNextPacketnode = this->pPacketList;
	this->pPacketList = pNode;

	pNode->guidMessage = *lpGUID;
	pNode->dwMessageSize = dwMessageSize; 
	pNode->dwTotalPackets = dwTotalPackets;

	*ppNode = pNode;
	
	return DP_OK;

ERROR_EXIT:

	FreePacketNode(pNode);
	return hr;

} // NewPacketnode

// called by handler.c
// we received a packet.
HRESULT HandlePacket(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPMSG_PACKET pmsg = (LPMSG_PACKET)pReceiveBuffer;
	LPPACKETNODE pNode,pNodePrev;
	BOOL bFoundIt = FALSE;
	HRESULT hr;
	BOOL bRetry;
	ULONG command;

	command=GET_MESSAGE_COMMAND(pmsg);

	// see if this packet is in the list
	pNode = this->pPacketList;
	pNodePrev = NULL;
	while (pNode && !bFoundIt)
	{
		if ( IsEqualIID(&(pNode->guidMessage),&(pmsg->guidMessage)))
	 	{
			bFoundIt = TRUE;
		}
		else 
		{
			// keep looking
			pNodePrev = pNode;
			pNode = pNode->pNextPacketnode;
		}
	}

	if (!bFoundIt)
	{
		switch(command){
			case DPSP_MSG_PACKET:
			case DPSP_MSG_PACKET2_DATA:
				// 
				// this is a new mesage
				DPF(8,"creating new packetnode");
				
				hr = NewPacketnode(this,&pNode,&pmsg->guidMessage,pmsg->dwMessageSize,pmsg->dwTotalPackets,pvSPHeader);

				if (FAILED(hr))
				{
					DPF_ERR(" could not get new packetnode");
					return hr;
				}

				if(command==DPSP_MSG_PACKET2_DATA){
					pNode->bReliable=TRUE;
					pNode->bReceive=TRUE;
				} else {
					ASSERT(command==DPSP_MSG_PACKET);
					pNode->bReliable=FALSE;
					pNode->bReceive=TRUE;
				}
				break;
				
			case DPSP_MSG_PACKET2_ACK:	
				DPF(6,"Got ACK for MSG that is no longer around\n");
				goto exit;
				break;
		}

	}
	else 
	{
		DPF(8," got packet for existing message");
	}

	if(command==DPSP_MSG_PACKET2_ACK){

		// GOT AN ACK
		
		CancelPacketizeRetryTimer(pNode);

		// Copy return info if necessary.
		if(!pNode->pvSPHeader && pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader)){
			// ACK from SEND has return information, copy so we can use Reply instead of Send.
			pNode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
			if (pNode->pvSPHeader){
				memcpy(pNode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
			}	
		}	

		if(pmsg->dwPacketID==pNode->dwSoFarPackets){
			// Got ack for last send, update stats, send next packet.
			pNode->dwSoFarPackets++;
			pNode->dwLatency = timeGetTime()-pNode->tmTransmitTime; 
			pNode->dwRetryCount = 0;
			if (pNode->dwLatency < 25){
				DPF(5, "Packetize: Got really low latency %dms, using 25ms to be safe\n",pNode->dwLatency);
				pNode->dwLatency = 25; 
			}	
			SendNextPacket(this, pNode, TRUE); // will also terminate the send if no more to send.
		} else {
			DPF(8,"Rejecting extra ACK\n");
		}
		
	} else {

		// DATA PACKET
		
		// copy this packet's data into the node
		if(pmsg->dwPacketID==pNode->dwSoFarPackets){

			memcpy(pNode->pMessage + pmsg->dwOffset,pReceiveBuffer + sizeof(MSG_PACKET),
					pmsg->dwDataSize);


			if(pmsg->dwOffset+pmsg->dwDataSize > pNode->dwMessageSize){
				DPF(0,"Packetize HandlePacket Message to big, pmsg->dwOffset %d, pmsg->dwDataSize %d, pNode->dwMessageSize %d\n",pmsg->dwOffset,pmsg->dwDataSize,pNode->dwMessageSize);
				DEBUG_BREAK();
			}
			
			pNode->dwSoFarPackets++;
			bRetry=FALSE;
			DPF(8,"received %d packets out of %d total",pNode->dwSoFarPackets,pNode->dwTotalPackets);
		} else {
			bRetry=TRUE;
			DPF(8,"received duplicate of %d packet out of %d total",pNode->dwSoFarPackets,pNode->dwTotalPackets);
		}
		
		if(command==DPSP_MSG_PACKET2_DATA){
			// ACK original or Retry.
			ASSERT(pNode->bReliable);
			DPF(8,"HandlePacket: Sending ACK\n");
			SendPacketizeACK(this,pNode,pmsg); // see header for side effects.
		}

		if(pNode->bReliable){
			pNode->tmLastReceive=timeGetTime();
		}	

		if (pNode->dwSoFarPackets == pNode->dwTotalPackets && !bRetry)
		{
			// GOT A COMPLETE MESSAGE
			// call handler
			DPF(8," HANDLE PACKET COMPLETED PACKETIZED MESSAGE !!! ");

			// take it out of the list - must be done before releasing lock.
			if(command==DPSP_MSG_PACKET){
			
				LPPACKETNODE pNodeWalker;

				pNodeWalker=(LPPACKETNODE)&this->pPacketList; //tricky...

				while(pNodeWalker && pNodeWalker->pNext!=pNode){
					pNodeWalker=pNodeWalker->pNext;
				}
				if(pNodeWalker){
					pNodeWalker->pNext=pNode->pNext;
				}else{
					DPF(0,"ERROR: tried to remove packetnode not on list pNode=%x\n",pNode);
					ASSERT(0);
				}
				
			}
			//
			// we leave dplay, since the handler counts on being able to drop the lock
			// (so if we have another thread blocked on a reply, it can process it, 
			// e.g. getnametable)
			LEAVE_DPLAY();
			
			hr = DP_SP_HandleNonProtocolMessage((IDirectPlaySP *)this->pInterfaces,pNode->pMessage,
					pNode->dwMessageSize,pNode->pvSPHeader);

			ENTER_DPLAY();
			
			// free up the packet node
			if(command==DPSP_MSG_PACKET){
				#ifdef DEBUG
				if(pNode->Signature != NODE_SIGN){
					DPF(0,"Invalid Node %x, Signature %x\n",pNode, pNode->Signature);
					DEBUG_BREAK();
				}
				#endif
				FreePacketNode(pNode);
			} else {
				ASSERT(command==DPSP_MSG_PACKET2_DATA);
				// We dropped the lock, so make sure still in the node
				// list before we free the buffer.
				pNodePrev = this->pPacketList;
				while(pNodePrev){ 
					if(pNodePrev==pNode){
						if (pNode->pBuffer){
							// don't need the memory any more, still need the node
							// to handle ACKing retries by the other machine
							DPMEM_FREE(pNode->pBuffer);
							pNode->pBuffer=NULL;
						}	
						break;
					}
					pNodePrev=pNodePrev->pNextPacketnode;
				}

				StartPacketizeTicker(this);
				// Type 2's are removed by the ticker, after 1 minute.
			}

			return hr;
		}
	}	
	// otherwise, wait for more packets...
exit:			
	return DP_OK;

}  // HandlePacket

#undef DPF_MODNAME
#define DPF_MODNAME	"PacketizeAndSend"

// how many packets will it take to send this message?
// dwMessageSize is the message size originally passed to senddpmessage 
// (or doreply)
UINT GetNPackets(LPDPLAYI_DPLAY this,DWORD dwMessageSize,DWORD dwFlags)
{
	DWORD dwPacketSpace; // space available in a packet
	UINT nPackets;

	// how much data will we need to send (neglecting headers)
	dwMessageSize -= this->dwSPHeaderSize;

	// how big a packet can sp handle?
	if(this->pProtocol){
		if(dwFlags&DPSEND_GUARANTEE){
			dwPacketSpace = this->pProtocol->m_dwSPMaxGuaranteed;
		}else{
			dwPacketSpace = this->pProtocol->m_dwSPMaxFrame;
		}
	} else {
		if (dwFlags & DPSEND_GUARANTEE){
			dwPacketSpace = this->dwSPMaxMessageGuaranteed;
		}else{
			dwPacketSpace = this->dwSPMaxMessage;		
		}
	}

	// now, we need to put a SP header and a dplay packet header on the front
	// dwPacketSpace will be the amount of data (as opposed to header) each packet
	// can carry
	dwPacketSpace -= (this->dwSPHeaderSize + sizeof(MSG_PACKET));
	DPF(8,"get packets : space / packet = %d\n",dwPacketSpace);

	nPackets = dwMessageSize / dwPacketSpace;
	if (0 != (dwMessageSize % dwPacketSpace)) nPackets++; // little bit left over

	DPF(8,"get packets : message size = %d, packets needed = %d\n",dwMessageSize,nPackets);

	return nPackets;
	
} // GetNPackets

// called by PacketizeAndSend and HandlePacket(for ACKing)
HRESULT ReplyPacket(LPDPLAYI_DPLAY this,LPBYTE pSendPacket,DWORD dwPacketSize,
	LPVOID pvMessageHeader, USHORT dwVersion)
{
	HRESULT hr;

	hr = DoReply(this,pSendPacket,dwPacketSize,pvMessageHeader,dwVersion);

	return hr;

} // ReplyPacket

// called by PacketizeAndSend	
HRESULT SendPacket(LPDPLAYI_DPLAY this,LPBYTE pSendPacket,DWORD dwPacketSize,
	LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags, BOOL bReply)
{
	HRESULT hr;

	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendPacket,dwPacketSize,dwFlags,bReply);

	return hr;

} // SendPacket


void CALLBACK SendTimeOut( UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2 )
{
	LPPACKETNODE pNode=(LPPACKETNODE)dwUser,pNodeWalker;
	UINT tmCurrentTime;
	BILINK *pBilink;
	UINT bFound=FALSE;

	tmCurrentTime=timeGetTime();

	DPF(4,"==>PacketizeSendTimeOut uID %x dwUser %x\n",uID,dwUser);

	// we know that if we find a node on the timeout list, that:
	// 	1. the node must be valid, because it must be pulled off to be freed.
	//  2. its this pointer is valid, because DP_Close frees the list before
	//     freeing the 'this' pointer AND DP_Close takes the TimeOutListLock
	//     to do the removal.

	PACKETIZE_LOCK();

	pBilink=g_PacketizeTimeoutList.next;

	while(pBilink != &g_PacketizeTimeoutList){
		pNodeWalker=CONTAINING_RECORD(pBilink, PACKETNODE, TimeoutList);
		pBilink=pBilink->next;

		if(pNode == pNodeWalker){
			if(pNode->uRetryTimer==uID || pNode->uRetryTimer==INVALID_TIMER){
				DPF(9,"Found Node %x in List, signalling retry thread\n",dwUser);
				pNode->uRetryTimer=0;
				Delete(&pNode->TimeoutList);		
				InitBilink(&pNode->TimeoutList);
				InsertAfter(&pNode->RetryList, &pNode->lpDPlay->RetryList);
				SetEvent(pNode->lpDPlay->hRetry);
				break;
			}
		}
	}

	PACKETIZE_UNLOCK();
	
}

VOID SendNextPacket(
	LPDPLAYI_DPLAY this, 
	LPPACKETNODE pNode,
	BOOL bInDplay
	)
{
	HRESULT hr;
	LPBYTE pSendPacket; // packet we're going to send out (header ptr)
	LPBYTE pSendData;   // data area of the packet
	DWORD dwPacketSpace; // space available in the data area
	DWORD dwPacketSize;
	DWORD dwBytesSoFar;
	LPMSG_PACKET pmsg;	// pointer to packet header (after SPHeader);

	BOOL bReply;

    LPDPLAYI_PLAYER pPlayerTo,pPlayerFrom;

	if(pNode->dwSoFarPackets==pNode->dwTotalPackets){
		DPF(8,"SendNextPacket: node done, not sending, blowing away node. %x\n",pNode);
		goto exit1;
	}

	if(pNode->pvSPHeader) {
		bReply=TRUE;
	} else {
		bReply=FALSE;
	}	

	if(!bReply){

		pPlayerFrom = PlayerFromID(this,pNode->dwIDFrom);
		pPlayerTo = PlayerFromID(this,pNode->dwIDTo);
	}

	// amount of room in packet for data
	
	if(this->pProtocol){
		dwPacketSize = this->pProtocol->m_dwSPMaxFrame;
	}else{
		dwPacketSize = this->dwSPMaxMessage;	
	}	

	dwPacketSpace = dwPacketSize - (this->dwSPHeaderSize + sizeof(MSG_PACKET2));

	// walk through the buffer, overwriting space in front of next outgoing packet.
	dwBytesSoFar=(pNode->dwSoFarPackets*dwPacketSpace);
	
	pSendData   = pNode->pMessage+dwBytesSoFar;
	pSendPacket = pSendData-sizeof(MSG_PACKET2)-this->dwSPHeaderSize;

	ASSERT(pSendPacket >= pNode->pBuffer);
	ASSERT(pSendPacket < pNode->pMessage+pNode->dwMessageSize);
	
	// set up the header
	pmsg = (LPMSG_PACKET)(pSendPacket + this->dwSPHeaderSize);

	//
	// Build the header
	//

	SET_MESSAGE_HDR(pmsg);

	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_PACKET2_DATA);
	pmsg->dwTotalPackets = pNode->dwTotalPackets;
	pmsg->dwMessageSize = pNode->dwMessageSize;  // already has SP header size removed in sending case.

	pmsg->dwDataSize=dwPacketSpace;
	
	// size correction for last packet
	if(dwBytesSoFar+dwPacketSpace > pNode->dwMessageSize){
		pmsg->dwDataSize=pNode->dwMessageSize-dwBytesSoFar;
	}

	dwPacketSize=this->dwSPHeaderSize+sizeof(MSG_PACKET2)+pmsg->dwDataSize;

	pmsg->dwPacketID = (DWORD) pNode->dwSoFarPackets;

	// how many bytes into message does this packet start
	pmsg->dwOffset = (ULONG) (pSendData-pNode->pMessage); 

	pmsg->guidMessage=pNode->guidMessage;

	// we set this to INVALID_TIMER so we can check if we need to set the timeout later.
	pNode->uRetryTimer=INVALID_TIMER;
	
	if(!pNode->dwRetryCount){
		pNode->tmTransmitTime=timeGetTime();
	}	
	
	if (bReply)
	{
		DPF(7,"SendNextPacket, Reply Packet# %x From %x To %x\n",pNode->dwSoFarPackets,pPlayerFrom, pPlayerTo);
		hr = ReplyPacket(this,pSendPacket,dwPacketSize,pNode->pvSPHeader,0);			   
	}
	else 
	{
		ASSERT(pNode->dwSoFarPackets==0);
		DPF(7,"SendNextPacket, SendPacket Packet# %xFrom %x To %x\n",pNode->dwSoFarPackets,pPlayerFrom, pPlayerTo);
		hr = SendPacket(this,pSendPacket,dwPacketSize,pPlayerFrom,pPlayerTo,pNode->dwSendFlags&~DPSEND_GUARANTEED,FALSE);
	}

	// Start the retry timer - unless we already got an ACK (which will clear uRetryTimer)
	if(!FAILED(hr)){
		if(pNode->uRetryTimer==INVALID_TIMER){

			PACKETIZE_LOCK();

#if 0			
			pNode->uRetryTimer=timeSetEvent(pNode->dwLatency+pNode->dwLatency/2,
											pNode->dwLatency/4,
											SendTimeOut,
											(ULONG)pNode,
											TIME_ONESHOT);
#endif											

			pNode->uRetryTimer=SetMyTimer(pNode->dwLatency+pNode->dwLatency/2,
										   pNode->dwLatency/4,
										   SendTimeOut,
										   (ULONG_PTR)pNode,
											&pNode->Unique);

			if(pNode->uRetryTimer){
				InsertBefore(&pNode->TimeoutList, &g_PacketizeTimeoutList);
			} else {
				ASSERT(0);
				DEBUG_BREAK();
				PACKETIZE_UNLOCK();
				goto exit1;
			}
											
			PACKETIZE_UNLOCK();
			
		}	
	} else {
		goto exit1;
	}
	return;

exit1:
	BlowAwayPacketNode(this,pNode);
	return;
}

/*
 ** PacketizeAndSendReliable - if you don't want reliable, don't call this!
 *
 *  CALLED BY: 
 *
 *  PARAMETERS:
 *			this - dplay object
 *			pPlayerFrom,pPlayerTo - players who are sending. 
 *			pMessage,dwMessageSize - Message we want to send
 *			dwFlags  - send flags
 *			pvMessageHeader - message header if we're going to call reply
 *			bReply - are we doing a reply (called from HandleXXX) or a send
 *
 *
 *  DESCRIPTION: like packetize and send, but only dispatches the first
 *               packet, subsequent packets are transmitted by SendNextPacket
 *               when the previous packet was ACKed.
 *
 *               Yes folks, this is async.
 * 
 *  RETURNS:  DP_OK
 *
 */
HRESULT PacketizeAndSendReliable(
	LPDPLAYI_DPLAY  this,
	LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,
	LPBYTE pMessage,
	DWORD  dwMessageSize,
	DWORD  dwFlags,
	LPVOID pvMessageHeader,
	BOOL   bReply
)
{
	UINT  nPackets;		// number of datagrams to send this message
	DWORD dwPacketSize; // size of each packet
	GUID  guid;         // a guid for this message
	
    LPPACKETNODE pNode;	// "send" node for packet

	HRESULT hr;

	if((pPlayerTo) && (pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)){
		// don't try to send to a player that doesn't have the nametable.
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",pPlayerTo,pPlayerTo->dwID);
		return DPERR_UNAVAILABLE;
	}

	if (((dwFlags & DPSEND_GUARANTEED) &&(!(this->dwFlags & DPLAYI_DPLAY_SPUNRELIABLE))) ||
		(this->dwAppHacks & DPLAY_APPHACK_NOTIMER)
	    ) 
	{
		// SP's reliable, so we don't have to.
		return PacketizeAndSend(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags,pvMessageHeader,bReply);
	}

	// turn off guaranteed bit since we do the reliability.
	nPackets = GetNPackets(this,dwMessageSize,dwFlags&~DPSEND_GUARANTEED);

	if(this->pProtocol){
		dwPacketSize=this->pProtocol->m_dwSPMaxFrame;
	}else{
		dwPacketSize = this->dwSPMaxMessage;	
	}	

	// Create a GUID for this message... (very expensive, but this is rare)
	hr=OS_CreateGuid(&guid);

	if(FAILED(hr)){
		goto error_exit;
	}
	
	// Get a node to describe this send.
	hr=NewPacketnode(this, &pNode, &guid, dwMessageSize-this->dwSPHeaderSize, nPackets, pvMessageHeader);

	if(FAILED(hr)){
		goto error_exit;
	}

	memcpy(pNode->pMessage, pMessage+this->dwSPHeaderSize, dwMessageSize-this->dwSPHeaderSize);

	pNode->dwSoFarPackets=0;

	pNode->bReliable   = TRUE;
	pNode->bReceive    = FALSE;

	// Worse case assumption for latency, since only comes into play
	// for retries on first packet, assume 14.4 modem (aprox) 1800 bytes/sec
	// This will get updated by the first ACK.
	if(dwMessageSize < 500){
		pNode->dwLatency = 20 + dwMessageSize/2;
	} else {
		pNode->dwLatency = 600;  
	}
	
	pNode->dwRetryCount= 0;
	pNode->tmLastReceive=timeGetTime();

	if(!bReply) {
		if(pPlayerTo){
			pNode->dwIDTo=pPlayerTo->dwID;
		} else {
			pNode->dwIDTo=0;
		}
		if(pPlayerFrom){
			pNode->dwIDFrom=pPlayerFrom->dwID;
		} else {
			pNode->dwIDFrom=0;
		}
		pNode->dwSendFlags=dwFlags;
	}	

	// don't need ref for i/f ptr since timers cancelled during shutdown.
	pNode->lpDPlay=this;

	ASSERT(gnDPCSCount);
	SendNextPacket(this, pNode, TRUE);

error_exit:
	return hr;

} // PacketizeAndSendReliable



/*
 ** PacketizeAndSend
 *
 *  CALLED BY: SendDPMessage, HandleXXXMessage
 *
 *  PARAMETERS:
 *			this - dplay object
 *			pPlayerFrom,pPlayerTo - players who are sending.  NULL if we're 
 *				called by HandleXXX
 *			pMessage,dwMessageSize - Message we want to send
 *			dwFlags  - send flags
 *			pvMessageHeader - message header if we're going to call reply
 *			bReply - are we doing a reply (called from HandleXXX) or a send
 *
 *
 *  DESCRIPTION: packs up the message into sp size chunks, and sends (or replies)
 *				it out.
 *
 *  RETURNS:  DP_OK
 *
 */
HRESULT PacketizeAndSend(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader,BOOL bReply)
{
	UINT nPackets;	
	LPBYTE pBufferIndex;
	DWORD dwPacketSize; // size of each packet
	DWORD dwPacketSpace; // space available in a packet for msgdata
	LPBYTE pSendPacket; // packet we're going to send out
	LPMSG_PACKET pmsg;	
	DWORD dwBytesLeft;
	DWORD iPacket=0;	// index of the current packet
	HRESULT hr = DP_OK;

	nPackets = GetNPackets(this,dwMessageSize,dwFlags);
	
	// how big a packet can sp handle?
	if(this->pProtocol){
		if(dwFlags&DPSEND_GUARANTEE){
			dwPacketSize = this->pProtocol->m_dwSPMaxGuaranteed;
		}else{
			dwPacketSize = this->pProtocol->m_dwSPMaxFrame;
		}
	} else {
		if (dwFlags & DPSEND_GUARANTEE){
			dwPacketSize = this->dwSPMaxMessageGuaranteed;
		}else{
			dwPacketSize = this->dwSPMaxMessage;		
		}
	}
	
	pSendPacket = DPMEM_ALLOC(dwPacketSize);
	if (!pSendPacket)
	{
		DPF_ERR("could not alloc packet!");
		return E_OUTOFMEMORY;
	}

	// do the one time set up of the header
	pmsg = (LPMSG_PACKET)(pSendPacket + this->dwSPHeaderSize);

	// stick a guid on this baby, so receiving end knows which message packet
	// goes with
	hr = OS_CreateGuid(&(pmsg->guidMessage));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}

	SET_MESSAGE_HDR(pmsg);

	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_PACKET);
	pmsg->dwTotalPackets = nPackets;
	pmsg->dwMessageSize = dwMessageSize - this->dwSPHeaderSize;

	// amount of room in packet for data
	// DX5 doesn't expect us to send him messages that are longer than he thinks they can be
	// even though there was an error in the size calculation in DX5.  So we subtract 8 from
	// the actual available space so we can talk to DX5 properly.
	dwPacketSpace = dwPacketSize - (this->dwSPHeaderSize + sizeof(MSG_PACKET))-8/*dx5 compat*/;

	// we start reading out of the buffer after the header
	pBufferIndex = pMessage + this->dwSPHeaderSize;
	dwBytesLeft = dwMessageSize - this->dwSPHeaderSize;

	while (iPacket < nPackets)
	{
		// set up the header info specific to this packet 
		if (dwBytesLeft >= dwPacketSpace) pmsg->dwDataSize = dwPacketSpace;
		else pmsg->dwDataSize = dwBytesLeft;

		pmsg->dwPacketID = (DWORD) iPacket;

		// how many bytes into message does this packet go
		// on the receiving side, we don't have the header, so cruise that here...
		pmsg->dwOffset = (ULONG)(pBufferIndex - pMessage - this->dwSPHeaderSize); 

		// copy the data into the packet
		memcpy(pSendPacket + this->dwSPHeaderSize + sizeof(MSG_PACKET),pBufferIndex,
				pmsg->dwDataSize);

		if (bReply)
		{
			hr = ReplyPacket(this,pSendPacket,pmsg->dwDataSize+this->dwSPHeaderSize+sizeof(MSG_PACKET),pvMessageHeader,0);			   
		}
		else 
		{
			hr = SendPacket(this,pSendPacket,pmsg->dwDataSize+this->dwSPHeaderSize+sizeof(MSG_PACKET),pPlayerFrom,pPlayerTo,dwFlags,bReply);
		}
		if (FAILED(hr))
		{
			DPF(0,"could not send packet! hr = 0x%08lx\n",hr);
			goto ERROR_EXIT;

		}
		pBufferIndex += pmsg->dwDataSize;
		dwBytesLeft -= pmsg->dwDataSize;
		iPacket++;
	}


ERROR_EXIT:

	DPMEM_FREE(pSendPacket);

	return hr;

} // PacketizeAndSend


// SendPacketizeACK is always called from HandleMessage, therefore it
// always uses ReplyPacket to send the ACK.
//
// side-effect changes the dwCmdToken of the message.-also requires header space before pMsg.
VOID SendPacketizeACK(LPDPLAYI_DPLAY this, LPPACKETNODE pNode,LPMSG_PACKET pMsg)
{
	SET_MESSAGE_HDR(pMsg);
	SET_MESSAGE_COMMAND(pMsg, DPSP_MSG_PACKET2_ACK);
	ReplyPacket(this, ((LPBYTE)pMsg)-this->dwSPHeaderSize, sizeof(MSG_PACKET2_ACK)+this->dwSPHeaderSize, pNode->pvSPHeader, DPSP_MSG_VERSION);	
}

// Note, tick runs in the MM timer thread, so it can safely take
// the DPLAY lock.

void CALLBACK PacketizeTick( UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2 )
{
	LPDPLAYI_DPLAY this = (LPDPLAYI_DPLAY)(dwUser);
	
	LPPACKETNODE pNode, pLastNode=NULL;
	LPPACKETNODE pFreeNodes=NULL;

	UINT tmCurrentTime;

	tmCurrentTime=timeGetTime();

	ENTER_DPLAY();

		DPF(8,"PACKETIZE TICK");
		
		if(this->uPacketTickEvent==uID){
		
			this->uPacketTickEvent=0;
			// Scan the list looking for completed receives that have been around for 1 minute
			// or more.  If they have been, move them to a list to be blown away.

			pLastNode=(LPPACKETNODE)&this->pPacketList; //tricky...
			pNode=this->pPacketList;

			while(pNode){
				if(pNode->bReliable && pNode->bReceive){
					if(tmCurrentTime-pNode->tmLastReceive > PACKETIZE_RECEIVE_TIMEOUT){
						// remove this node from the list.
						pLastNode->pNextPacketnode=pNode->pNextPacketnode;
						// put it on the list to be freed.
						pNode->pNextPacketnode=pFreeNodes;
						pFreeNodes=pNode;
						// skip to the next node.
						pNode=pLastNode->pNextPacketnode;
						this->nPacketsTimingOut -= 1;
						ASSERT(!(this->nPacketsTimingOut&0x80000000));
						continue;
					}
				}
				pLastNode=pNode;
				pNode=pNode->pNextPacketnode;
			}

			if(this->nPacketsTimingOut){	
				this->uPacketTickEvent = timeSetEvent(TICKER_INTERVAL,TICKER_RESOLUTION,PacketizeTick,(ULONG_PTR)this,TIME_ONESHOT);
			}
		}	

	LEAVE_DPLAY();

	// we free the nodes after to reduce serialization.
	while(pFreeNodes){
		pNode=pFreeNodes->pNextPacketnode;
		FreePacketNode(pFreeNodes);
		pFreeNodes=pNode;
	}
}

// When a player is being deleted this removes sends to that player from the message queue.
VOID DeletePlayerPackets(LPDPLAYI_DPLAY this, UINT idPlayer)
{
	LPPACKETNODE pNode;

	ENTER_DPLAY();

	DPF(8,"==>Deleting player packets for playerid:x%x",idPlayer);

		pNode=this->pPacketList;

		while(pNode){
			// only delete sending nodes, since receive nodes req'd to ACK remote retries.
			if(!pNode->bReceive && pNode->dwIDTo==idPlayer){
					pNode->dwRetryCount=MAX_PACKETIZE_RETRY; //let next timeout deal with it.
			}
			pNode=pNode->pNextPacketnode;
		}

	LEAVE_DPLAY();
	
}

// Can only be called with DPLAY LOCK held.
VOID StartPacketizeTicker(LPDPLAYI_DPLAY this)
{
	this->nPacketsTimingOut += 1;
	if(this->nPacketsTimingOut == 1){
		// First one, start up the ticker. - note ok with lock since this must be first call.
		this->uPacketTickEvent = timeSetEvent(TICKER_INTERVAL,TICKER_RESOLUTION,PacketizeTick,(ULONG_PTR)this,TIME_ONESHOT);
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\sources.inc ===
UMTYPE=windows

TARGETNAME=dplayx
TARGETTYPE=DYNLINK

INCLUDES=..\..\..\inc; \
	 ..\..\..\misc; \
	 ..\; \
	 ..\..\..\dplobby\dplobby; \
	 ..\..\common; \

TARGETPATH=obj

TARGETLIBS=\
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(SDK_LIB_PATH)\user32.lib    \
    $(SDK_LIB_PATH)\kernel32.lib  \
    $(SDK_LIB_PATH)\uuid.lib  \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\winmm.lib \
    $(SDK_LIB_PATH)\version.lib

DLLENTRY=DllMain

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32

LINKER_FLAGS=-SECTION:share,RWS

LINKLIBS= \
	 ..\..\..\dplobby\dplobby\$(PLAT_DIR)\$(_OBJ_DIR)\*\dplobby.lib \
	 ..\..\protocol\$(PLAT_DIR)\$(_OBJ_DIR)\*\protocol.lib

SOURCES= \
	..\apphack.c \
	..\connect.c \
	..\perf.c \
	..\dpthread.c \
	..\paketize.c \
	..\api.c \
	..\dpos.c \
	..\iplaya.c \
	..\iplay1.c \
	..\dpunk.c \
	..\iplay.c \
	..\enum.c \
	..\dllmain.c \
	..\namesrv.c \
	..\handler.c \
	..\pack.c \
	..\sysmess.c \
	..\pending.c \
	..\sphelp.c \
	..\do.c \
	..\dpmem.c \
	..\classfac.c \
	..\dplay.rc \
	..\dpsecure.c \
	..\dpsecos.c \
	..\superpac.c \
	..\sendparm.c \
	..\sgl.c \
	..\mcontext.c \
	..\fpm.c \
	..\msgmem.c \
	memalloc.c \
	newdpf.c \
	dputils.c

DLLDEF=..\dplay.def

NTTARGETFILE0=\
    .\newdpf.h \
    .\newdpf.c \
    .\memalloc.c \
    .\dputils.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\sendparm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sendparm.c
 *  Content:	management of send parameter structure
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  01/08/98  aarono    Original
 *  02/13/98  aarono    Fixed bugs found in async testing
 *  06/02/98  aarono    fix psp completion for invalid player
 *  6/10/98 aarono add PendingList to PLAYER and SENDPARM so we can track
 *                  pending sends and complete them on close.
 *  6/18/98   aarono    fix group SendEx ASYNC to use unique Header
 ***************************************************************************/

#include "dplaypr.h"
#include "mcontext.h"

// Release all memory/resources associated with a send and then the send parms themselves
VOID FreeSend(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bFreeParms)
{
	PGROUPHEADER pGroupHeader,pGroupHeaderNext;
	FreeMessageBuffers(psp);
	if(psp->hContext){
		ReleaseContextList(this, psp->hContext);	
	}
	pGroupHeader=psp->pGroupHeaders;
	while(pGroupHeader){
		ASSERT(psp->pGroupTo);
		pGroupHeaderNext=pGroupHeader->pNext;
		this->lpPlayerMsgPool->Release(this->lpPlayerMsgPool,pGroupHeader);
		pGroupHeader=pGroupHeaderNext;
	}
	if(bFreeParms){
		FreeSendParms(psp);
	}	
}

//
// Send Parm init/deinit.
//

BOOL SendInitAlloc(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	InitializeCriticalSection(&psp->cs);
	return TRUE;
}

VOID SendInit(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	psp->RefCount=1;
	psp->pGroupHeaders=NULL;
}

VOID SendFini(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	DeleteCriticalSection(&psp->cs);
}

//
// Management of Context List
//

// initialize context list and info on a psp.
HRESULT InitContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nInitSize)
{
	psp->hContext=AllocateContextList(this,psp,nInitSize);
	if(!psp->hContext){
		return DPERR_OUTOFMEMORY;
	}
	
	*psp->lpdwMsgID=(DWORD_PTR)psp->hContext;
	
	psp->iContext=0;
	psp->nContext=nInitSize;
	return DP_OK;
}

// Note, this only works for context lists with an initial size > 1
UINT AddContext(LPDPLAYI_DPLAY this, PSENDPARMS psp, PVOID pvContext)
{
    UINT    n;
	PAPVOID papvList;
	UINT    nListEntries;

	PAPVOID papvNewList;
	UINT    nNewListEntries;

	EnterCriticalSection(&psp->cs);

	if(psp->iContext == psp->nContext){

			nNewListEntries=psp->iContext+4;
			// Need to grow the list
			// Get a new list
			papvNewList=AllocContextList(this,nNewListEntries);
			if(!papvNewList){
				return 0;
			}

			// transcribe the old list into the new list.
			ReadContextList(this,psp->hContext,&papvList,&nListEntries,FALSE);
			if(nListEntries){
				memcpy(papvNewList,papvList,nListEntries*sizeof(PVOID));
				// free the old list
				FreeContextList(this, papvList, nListEntries);
			}	


			// setup the new list in the psp
			WriteContextList(this, psp->hContext, papvNewList, nNewListEntries);
			psp->nContext   = nNewListEntries;
	}

	// Normal operation, set an entry.
	ReadContextList(this,psp->hContext,&papvList,&nListEntries,FALSE);
	(*papvList)[psp->iContext]=pvContext;
	
	n=psp->iContext++;

	LeaveCriticalSection(&psp->cs);
	
	return n;
}

UINT pspAddRefNZ(PSENDPARMS psp) // this one won't add to a zero refcount.
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount=++psp->RefCount;
	if(newCount==1){
		newCount=--psp->RefCount;
	}
	LeaveCriticalSection(&psp->cs);
	return newCount;
}

UINT pspAddRef(PSENDPARMS psp)
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount=++psp->RefCount;
	ASSERT(psp->RefCount != 0);
	LeaveCriticalSection(&psp->cs);
	return newCount;
}

#ifdef DEBUG
UINT nMessagesQueued=0;
#endif

UINT pspDecRef(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount = --psp->RefCount;
	if(newCount&0x80000000){
		DEBUG_BREAK(); // BUGBUG:ASSERT ONLY
	}
	LeaveCriticalSection(&psp->cs);
	if(!newCount){
		// ref 0, no-one has another ref do completion message (if req'd), then free this baby
		if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG) && (psp->dwFlags&DPSEND_ASYNC)){
			psp->dwSendCompletionTime=timeGetTime()-psp->dwSendTime;
			FreeSend(this,psp,FALSE); // must do here to avoid race with receiveQ
	 		#ifdef DEBUG
			nMessagesQueued++;
			#endif
			psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
			if (VALID_DPLAY_PLAYER(psp->pPlayerFrom)) {
				Delete(&psp->PendingList);
				InterlockedDecrement(&psp->pPlayerFrom->nPendingSends);
				DPF(9,"DEC pPlayerFrom %x, nPendingSends %d\n",psp->pPlayerFrom, psp->pPlayerFrom->nPendingSends);
				QueueSendCompletion(this, psp);
			}else{
				// This happens when client doesn't close players gracefully.
				DPF(0,"Got completion for blown away player?\n");
				FreeSendParms(psp);
			}
		} else {
			FreeSend(this,psp,TRUE);
		}
	}
	return newCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\sphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sphelp.c
 *  Content:	helper functions for sp
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	 6/6/96		andyco	created it
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/24/96		andyco	added IDirectPlaySP to EnumConnectionData
 *	6/25/96		kipo	added support for DPADDRESS and changed GetFlags
 *						to GetPlayerFlags.
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/11/96		andyco	changed guid * to refguid in createaddress.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *	8/1/96		andyco	dplay keeps copy of sp's data, instead of pointer
 *	8/15/96		andyco	added local / remote to spdata
 *	1/2/97		myronth	added wrapper for CreateAddress and EnumAddress
 *	2/7/97		andyco	added get/set spdata
 *	2/18/97		kipo	fixed bugs #3285, #4638, and #4639 by checking for
 *						invalid flags correctly
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *  7/28/97		sohailm	address buffer chunks returned by EnumAddress were not
 *                      aligned.
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 ***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_SetSPPlayerData"

// store a chunk o' data w/ a player or group, or w/ the this ptr if lpPlayer is 
// NULL
HRESULT DoSPData(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,
	DWORD dwSourceSize,DWORD dwFlags)
{
	LPVOID pvDest; // we set these two based on which flags 
	DWORD dwDestSize; // to dplayi_player->(local)data

	// figure out which dest they want
	if (NULL == lpPlayer)
	{
		pvDest = this->pvSPLocalData;
		dwDestSize = this->dwSPLocalDataSize;
	}
	else if (dwFlags & DPSET_LOCAL)
	{
		pvDest = lpPlayer->pvSPLocalData;
		dwDestSize = lpPlayer->dwSPLocalDataSize;
	}
	else 
	{
		pvDest = lpPlayer->pvSPData;
		dwDestSize = lpPlayer->dwSPDataSize;
	}

	// are we copying anything
	if (dwSourceSize)
	{
		// see if we need to alloc dest
		if (0 == dwDestSize)
		{
			ASSERT(!pvDest);
			pvDest = DPMEM_ALLOC(dwSourceSize);
			if (!pvDest)
			{
				DPF_ERR("could not alloc player blob!");
				return E_OUTOFMEMORY;
			}
		} // !pvDest
		// do we need to realloc?
		else if (dwSourceSize != dwDestSize)
		{
			LPVOID	pvTempSPData;

			ASSERT(pvDest);
			pvTempSPData = DPMEM_REALLOC(pvDest,dwSourceSize);
			if (!pvTempSPData)
			{
				DPF_ERR("could not re-alloc player blob!");
				return E_OUTOFMEMORY;
			}
		   	pvDest = pvTempSPData;
		}
		// copy the data over
		memcpy(pvDest,pvSource,dwSourceSize);
		dwDestSize = dwSourceSize;

	} // dwDataSize
	else 
	{
		// set it to NULL
		if (dwDestSize)
		{
			ASSERT(pvDest);
			DPMEM_FREE(pvDest);
			pvDest = NULL;
			dwDestSize = 0;
		}
	} // !dwSourceSize

	// update the appropriate pointer
	if (NULL == lpPlayer)
	{
		this->pvSPLocalData = pvDest;
		this->dwSPLocalDataSize = dwDestSize;
	}
	else if (dwFlags & DPSET_LOCAL)
	{
		lpPlayer->pvSPLocalData = pvDest;
		lpPlayer->dwSPLocalDataSize = dwDestSize;
	}
	else 
	{
		//
		// set the remote data
		lpPlayer->pvSPData = pvDest;
		lpPlayer->dwSPDataSize = dwDestSize;
	}

	return DP_OK;

} // DoSPData

   
#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_SetSPPlayerData"

//	 
// sp's can set a blob of data with a player (or group)
HRESULT DPAPI DP_SP_SetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }
		if (!VALID_STRING_PTR(pvData,dwDataSize))
		{
			LEAVE_DPLAY();
			DPF_ERR("SP - passed bad buffer");
            return DPERR_INVALIDPARAM;
		}

		if (dwFlags & ~DPSET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid flags");
			return DPERR_INVALIDFLAGS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	hr = DoSPData(this,lpPlayer,pvData,dwDataSize,dwFlags);	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		DPF_ERRVAL("could not set player data- hr = 0x%08lx\n",hr);
	}

	LEAVE_DPLAY();
	return hr;

} // DPlay_SetSPPlayerData

#ifdef BIGMESSAGEDEFENSE
#undef DPF_MODNAME
#define DPF_MODNAME	"HandleSPBigMessageNotification"

void HandleSPBigMessageNotification(LPDPLAYI_DPLAY this, LPDPSP_MSGTOOBIG pBigMessageInfo)
{
	DWORD				dwCommand;
	DWORD				dwVersion;
	DWORD				dwIDFrom = 0;
    LPDPLAYI_PLAYER 	lpPlayer;
    HRESULT				hr;
	
	DPF(6, "SP told us it got a message that's too big!\n");

 	// get the message pointer.  Let's see if we can
	// figure our who sent it and kill them
    hr = GetMessageCommand(this, pBigMessageInfo->pReceiveBuffer, 
    		pBigMessageInfo->dwMessageSize, &dwCommand, &dwVersion);
    if (FAILED(hr))
    {
    	DPF(6,"In HandleSPBigMessageNotification, unable to determine who sent us the message (the scum!)\n");
		return;
    }

	switch(dwCommand)
	{
		case DPSP_MSG_SIGNED:
		{
			dwIDFrom = ((LPMSG_SECURE)pBigMessageInfo->pReceiveBuffer)->dwIDFrom;
		}
		break;

		case DPSP_MSG_PLAYERMESSAGE:
		{
			if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
			{
				dwIDFrom = ((LPMSG_PLAYERMESSAGE)pBigMessageInfo->pReceiveBuffer)->idFrom;
			}
		}
		break;

		case DPSP_MSG_NEGOTIATE:
		case DPSP_MSG_CHALLENGERESPONSE:
		{
			dwIDFrom = ((LPMSG_AUTHENTICATION) pBigMessageInfo->pReceiveBuffer)->dwIDFrom;
		}
		break;
		case DPSP_MSG_ASK4MULTICASTGUARANTEED:
		case DPSP_MSG_ASK4MULTICAST:
		{
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pBigMessageInfo->pReceiveBuffer)->idPlayerFrom;
		}
		break;
		default:
		   	DPF(6,"In HandleSPBigMessageNotification, unable to determine who sent us the message (the scum!)\n");
		break;
	}
	
//	if we got a player id, kill them
	if (dwIDFrom != 0)
	{
    	DPF(6,"In HandleSPBigMessageNotification, Identified evil sender as %d!\n", dwIDFrom);

        lpPlayer = PlayerFromID(this,dwIDFrom);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
 			DPF(2, "Tried to get invalid player!: %d\n", dwIDFrom);
           return;
        }

    	DPF(6,"Removing player %d from our nametable!\n", dwIDFrom);
		hr = InternalDestroyPlayer(this,lpPlayer,IAM_NAMESERVER(this),FALSE);
		if (FAILED(hr))
		{
			DPF(2, "Error returned from InternalDestroyPlayer: %d\n", hr);
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME	"HandleSPPlayersConnectionLost"

void HandleSPPlayersConnectionLost(LPDPLAYI_DPLAY this, LPDPSP_PLAYERDEAD pBigMessageInfo)
{
    LPDPLAYI_PLAYER 	lpPlayer;
    HRESULT				hr;
	
	DPF(6, "SP told us it got a player's connection was lost!\n");

	if (pBigMessageInfo->dwID != 0)
	{
        lpPlayer = PlayerFromID(this,pBigMessageInfo->dwID);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
 			DPF(2, "Tried to get invalid player!: %d\n", pBigMessageInfo->dwID);
           return;
        }

    	DPF(6,"Removing player %d from our nametable!\n", pBigMessageInfo->dwID);
		hr = InternalDestroyPlayer(this,lpPlayer,IAM_NAMESERVER(this),FALSE);
		if (FAILED(hr))
		{
			DPF(2, "Error returned from InternalDestroyPlayer: %d\n", hr);
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_HandleSPMessage"

HRESULT DPAPI DP_SP_HandleSPWarning(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	DWORD			dwOpcode;

	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	dwOpcode = *((LPDWORD) pReceiveBuffer);
 	// look at the opcode and see if we understand what the SP is trying to tell us
 	switch(dwOpcode)
 	{
 		case DPSPWARN_MESSAGETOOBIG:
 			HandleSPBigMessageNotification(this, (LPDPSP_MSGTOOBIG)pReceiveBuffer);
 		break;

 		case DPSPWARN_PLAYERDEAD:
 			HandleSPPlayersConnectionLost(this, (LPDPSP_PLAYERDEAD) pReceiveBuffer);
 		break;
 		
 		default:
 			DPF(2, "Got a SP notification that we don't understand! %d\n", dwOpcode);
 		break;
 	}


	LEAVE_DPLAY();
	return hr;
} // DP_SP_HandleSPWarning

#endif /* BIGMESSAGEDEFENSE */

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_GetSPPlayerData"
// 
// sp's can get the blob of data previously set w/ player or group
// we give out our pointer to the sp here (no data copying)
HRESULT DPAPI DP_SP_GetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID * ppvData,LPDWORD pdwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }

		if (dwFlags & ~DPGET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid flags");
			return DPERR_INVALIDFLAGS;
		}

		*pdwDataSize = 0;
	 	*ppvData = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	if (dwFlags & DPGET_LOCAL)
	{
		*pdwDataSize  = lpPlayer->dwSPLocalDataSize;
		*ppvData = lpPlayer->pvSPLocalData;
	}
	else 
	{
		*pdwDataSize  = lpPlayer->dwSPDataSize;
		*ppvData = lpPlayer->pvSPData;
	}
	
	LEAVE_DPLAY();
	return DP_OK;

} // DPlay_GetSPPlayerData

// the sp can get the player (or group) flags (DPLAYI_PLAYER_xxx) with this call...
HRESULT DPAPI DP_SP_GetPlayerFlags(IDirectPlaySP * pISP,DPID id,LPDWORD pdwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }
		*pdwFlags = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }
	
	*pdwFlags = lpPlayer->dwFlags;

	LEAVE_DPLAY();
	return DP_OK;
} // DPlay_GetFlags


#undef DPF_MODNAME
#define DPF_MODNAME	"InternalCreateAddress"

// create address structure
HRESULT InternalCreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPADDRESSHEADER	lpHeader;
	DWORD			dwRequiredSize;
	HRESULT			hr;
	
    TRY
    {
		if (!VALID_READ_PTR(lpguidSP, sizeof(GUID)))
		{
			DPF_ERR("invalid SP GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_READ_PTR(lpguidDataType, sizeof(GUID)))
		{
			DPF_ERR("invalid data GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_READ_PTR(lpData, dwDataSize))
		{
			DPF_ERR("passed invalid lpData pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_DWORD_PTR(lpdwAddressSize))
		{
			DPF_ERR("invalid lpdwAddressSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!lpAddress) *lpdwAddressSize = 0;
		if (*lpdwAddressSize && !VALID_WRITE_PTR(lpAddress,*lpdwAddressSize))
		{
			DPF_ERR("invalid lpAddress pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// make sure we have enough space
	dwRequiredSize = sizeof(ADDRESSHEADER) + dwDataSize;	
	if (*lpdwAddressSize < dwRequiredSize)
	{
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		lpHeader = (LPADDRESSHEADER) lpAddress;

		// create service provider chunk
		// 1st, size
		lpHeader->dpaSizeChunk.guidDataType = DPAID_TotalSize;
		lpHeader->dpaSizeChunk.dwDataSize = sizeof(DWORD);		
		lpHeader->dwTotalSize = dwRequiredSize;
		// next, SP guid
		lpHeader->dpaSPChunk.guidDataType = DPAID_ServiceProvider;
		lpHeader->dpaSPChunk.dwDataSize = sizeof(GUID);
		lpHeader->guidSP = *lpguidSP;

		// create data chunk
		lpHeader->dpaAddressChunk.guidDataType = *lpguidDataType;
		lpHeader->dpaAddressChunk.dwDataSize = dwDataSize;
		memcpy((LPBYTE) lpHeader + sizeof(ADDRESSHEADER), lpData, dwDataSize);		

		hr = DP_OK;
	}
	
	*lpdwAddressSize = dwRequiredSize;

	return (hr);
} // InternalCreateAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_CreateAddress"
HRESULT DPAPI DP_SP_CreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalCreateAddress(pISP, lpguidSP, lpguidDataType, lpData,
								dwDataSize, lpAddress, lpdwAddressSize);

} // CreateAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalCreateCompoundAddress"

// create address with multiple chunks
HRESULT InternalCreateCompoundAddress(
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPADDRESSHEADER	lpHeader;
	DWORD			dwRequiredSize, dwTotalDataSize, i;
	LPBYTE			lpb;
	HRESULT			hr;
	
    TRY
    {
		if (!VALID_READ_PTR(lpAddressElements, dwAddressElementCount * sizeof(DPCOMPOUNDADDRESSELEMENT)))
		{
			DPF_ERR("invalid address elements pointer");
			return DPERR_INVALIDPARAMS;	
		}

		dwTotalDataSize = 0;
		for (i = 0; i < dwAddressElementCount; i++)
		{
			if (!VALID_READ_PTR(lpAddressElements[i].lpData, lpAddressElements[i].dwDataSize))
			{
				DPF_ERR("passed invalid lpData pointer");
				return DPERR_INVALIDPARAMS;	
			}
			dwTotalDataSize += lpAddressElements[i].dwDataSize;
		}

		if (!VALID_DWORD_PTR(lpdwAddressSize))
		{
			DPF_ERR("invalid lpdwAddressSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!lpAddress) *lpdwAddressSize = 0;
		if (*lpdwAddressSize && !VALID_WRITE_PTR(lpAddress,*lpdwAddressSize))
		{
			DPF_ERR("invalid lpAddress pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// make sure we have enough space
	dwRequiredSize = sizeof(DPADDRESS) + sizeof(DWORD) +
					 sizeof(DPADDRESS) * dwAddressElementCount + dwTotalDataSize;	
	if (*lpdwAddressSize < dwRequiredSize)
	{
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		lpHeader = (LPADDRESSHEADER) lpAddress;

		// create total size chunk at beginning of address
		lpHeader->dpaSizeChunk.guidDataType = DPAID_TotalSize;
		lpHeader->dpaSizeChunk.dwDataSize = sizeof(DWORD);		
		lpHeader->dwTotalSize = dwRequiredSize;

		// pack all the other chunks
		lpb = (LPBYTE) lpAddress + sizeof(DPADDRESS) + sizeof(DWORD);
		for (i = 0; i < dwAddressElementCount; i++)
		{
			// chunk descriptor
			lpAddress = (LPDPADDRESS) lpb;
			lpAddress->guidDataType = lpAddressElements[i].guidDataType;
			lpAddress->dwDataSize = lpAddressElements[i].dwDataSize;
			lpb += sizeof(DPADDRESS);

			// chunk data
			memcpy(lpb, lpAddressElements[i].lpData, lpAddressElements[i].dwDataSize);
			lpb += lpAddressElements[i].dwDataSize;
		}

		hr = DP_OK;
	}
	
	*lpdwAddressSize = dwRequiredSize;

	return (hr);
} // InternalCreateCompoundAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_CreateCompoundAddress"
HRESULT DPAPI DP_SP_CreateCompoundAddress(IDirectPlaySP * pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalCreateCompoundAddress(lpAddressElements, dwAddressElementCount,
								   lpAddress, lpdwAddressSize);

} // CreateCompoundAddresses

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalEnumAddress"

// enumerate the chunks in a connection data buffer
HRESULT InternalEnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext)
{
	LPDPADDRESS		lpChunk, lpCopy=NULL;
	DWORD			dwAmountParsed;
	BOOL			bContinue;
	HRESULT         hr;
	
    TRY
    {
		if (!VALIDEX_CODE_PTR(lpEnumCallback))
		{
		    DPF_ERR("Invalid callback routine");
		    return (DPERR_INVALIDPARAMS);
		}

		if (!VALID_READ_PTR(lpAddress, dwAddressSize))
		{
			DPF_ERR("Bad data buffer");
            return (DPERR_INVALIDPARAMS);
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// Allocate a buffer big enough to accomodate any address chunk embedded 
	// in the passed in buffer. We are making local copies here to ensure proper 
	// memory alignment of the address chunks.
	lpCopy = DPMEM_ALLOC(dwAddressSize);
	if (!lpCopy)
	{
		DPF_ERR("Failed to copy address buffer (for alignment) - out of memory");
		return DPERR_OUTOFMEMORY;
	}
	
	lpChunk = (LPDPADDRESS) lpAddress;
	dwAmountParsed = 0;
	while (dwAmountParsed < dwAddressSize)
	{
		// don't walk off the end of the buffer reading chunk header
		if ((dwAmountParsed + sizeof(DPADDRESS)) > dwAddressSize)
		{
			hr = DPERR_INVALIDPARAMS;
			goto CLEANUP_EXIT;
		}

		// don't walk off the end of the buffer reading chunk data
		if ((dwAmountParsed + sizeof(DPADDRESS) + lpChunk->dwDataSize) > dwAddressSize)
		{
			hr = DPERR_INVALIDPARAMS;
			goto CLEANUP_EXIT;
		}

		// copy address chunk to local buffer
		memcpy(lpCopy, lpChunk, sizeof(DPADDRESS) + lpChunk->dwDataSize);

		// call the callback
		bContinue = (lpEnumCallback)(&lpCopy->guidDataType, lpCopy->dwDataSize,
								   (LPBYTE)lpCopy + sizeof(DPADDRESS), lpContext);

		// callback asked to stop
		if (!bContinue)
		{
			hr = DP_OK;
			goto CLEANUP_EXIT;
		}

		dwAmountParsed += sizeof(DPADDRESS) + lpChunk->dwDataSize;
		lpChunk = (LPDPADDRESS) ((LPBYTE)lpAddress + dwAmountParsed);
	}

	// sucess
	hr = DP_OK;

	// fall through

CLEANUP_EXIT:
	// cleanup allocations
	if (lpCopy) DPMEM_FREE(lpCopy);
	return hr;

} // EnumAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_EnumAddress"
HRESULT DPAPI DP_SP_EnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalEnumAddress(pISP, lpEnumCallback, lpAddress,
								dwAddressSize, lpContext);

} // EnumAddress


// Registry definitions
#define MRU_KEY_PARENT      HKEY_CURRENT_USER
#define MRU_KEY_TOP         L"Software\\Microsoft\\DirectPlay\\Service Providers"

// Entry linked list node
typedef struct tagENTRYNODE
{
    struct tagENTRYNODE     *lpNext;
    LPVOID                  lpvData;
    DWORD                   dwSize;
} ENTRYNODE, *LPENTRYNODE;

// Entry linked list head
LPENTRYNODE                 g_lpEntryListHead = NULL;

// Local prototypes
HRESULT InternalEnumMRUEntries(LPCWSTR lpszSection, LPCWSTR lpszKey, LPENUMMRUCALLBACK fnCallback, LPVOID lpvContext, DWORD dwMaxEntries);
BOOL CALLBACK InternalEnumMRUCallback(LPCVOID, DWORD, LPVOID);
LPENTRYNODE AddEntryNode(LPVOID, DWORD);
LPENTRYNODE RemoveEntryNode(LPENTRYNODE);
void FreeEntryList(void);
int CompareMemory(LPCVOID, LPCVOID, DWORD);
long RegDelAllValues(HKEY);
long OpenMRUKey(LPCWSTR, LPCWSTR, HKEY *, DWORD);
int wstrlen(LPCWSTR);
int wstrcpy(LPWSTR, LPCWSTR);
int wstrcat(LPWSTR, LPCWSTR);


// ---------------------------------------------------------------------------
// EnumMRUEntries
// ---------------------------------------------------------------------------
// Description:             Enumerates entries stored in the service provider
//                          MRU list, passing each to a callback function.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPENUMMRUCALLBACK  Pointer to the application-defined callback
//                          function.
//  [in] LPVOID             Context passed to callback function.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT DPAPI DP_SP_EnumMRUEntries(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPENUMMRUCALLBACK fnCallback,
					LPVOID lpvContext)
{
	LPDPLAYI_DPLAY	this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// Call the internal enumeration routine
    return InternalEnumMRUEntries(lpszSection, lpszKey, fnCallback, lpvContext, MAXDWORD);
}


// ---------------------------------------------------------------------------
// AddMRUEntry
// ---------------------------------------------------------------------------
// Description:             Adds a new entry to the MRU list.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPVOID             New data.
//  [in] DWORD              New data size.
//  [in] DWORD              Maximum number of entries to save.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT DPAPI DP_SP_AddMRUEntry(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPCVOID lpvData, DWORD dwDataSize, DWORD dwMaxEntries)
{
    HRESULT                 hr;             // Return code
    HKEY                    hKey;           // Registry key
    LPENTRYNODE             lpNode;         // Generic linked list node
    long                    lResult;        // Return code from registry operations
    char                    szValue[13];    // New value name
    WCHAR                   szWValue[13];   // Unicode version of above name
    DWORD                   dwIndex;        // Current value index
	LPDPLAYI_DPLAY			this;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
		if (!VALID_READ_PTR(lpvData, dwDataSize))
		{
			DPF_ERR("passed invalid lpvData pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

    // Enumerate existing entries, adding each one to the linked list
    FreeEntryList();

    if(FAILED(hr = InternalEnumMRUEntries(lpszSection, lpszKey, InternalEnumMRUCallback, NULL, dwMaxEntries)))
    {
        FreeEntryList();
        return hr;
    }

    // Create the registry key
    if((lResult = OpenMRUKey(lpszSection, lpszKey, &hKey, GENERIC_WRITE)) != ERROR_SUCCESS)
    {
        FreeEntryList();
        return DPERR_GENERIC;
    }

    // Delete all existing values
    RegDelAllValues(hKey);

    // Search for a match to the passed-in data in the linked list
    lpNode = g_lpEntryListHead;

    while(lpNode)
    {
        if(lpNode->dwSize == dwDataSize && !CompareMemory(lpNode->lpvData, lpvData, dwDataSize))
        {
            // Item appears in the list.  Remove it.
            lpNode = RemoveEntryNode(lpNode);
        }
        else
        {
            lpNode = lpNode->lpNext;
        }
    }

    // Write the new data to the beginning of the list
    dwIndex = 0;

    if(dwMaxEntries)
    {
        wsprintfA(szValue, "%lu", dwIndex);
        AnsiToWide(szWValue, szValue, sizeof(szWValue));

        if((lResult = OS_RegSetValueEx(hKey, szWValue, 0, REG_BINARY, lpvData, dwDataSize)) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            FreeEntryList();
            return DPERR_GENERIC;
        }

        dwIndex++;
    }

    // Write all other entries to the list
    lpNode = g_lpEntryListHead;
    
    while(dwIndex < dwMaxEntries && lpNode)
    {
        wsprintfA(szValue, "%lu", dwIndex);
        AnsiToWide(szWValue, szValue, sizeof(szWValue));

        if((lResult = OS_RegSetValueEx(hKey, szWValue, 0, REG_BINARY, lpNode->lpvData, lpNode->dwSize)) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            FreeEntryList();
            return DPERR_GENERIC;
        }

        dwIndex++;
        lpNode = lpNode->lpNext;
    }

    // Clean up
    RegCloseKey(hKey);
    FreeEntryList();

    // Return success
    return DP_OK;
}


// ---------------------------------------------------------------------------
// InternalEnumMRUEntries
// ---------------------------------------------------------------------------
// Description:             Enumerates entries stored in the service provider
//                          MRU list, passing each to a callback function.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPENUMMRUCALLBACK  Pointer to the application-defined callback
//                          function.
//  [in] LPVOID             Context passed to callback function.
//  [in] DWORD              Maximum count of entries to enumerate.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT InternalEnumMRUEntries(LPCWSTR lpszSection, LPCWSTR lpszKey, LPENUMMRUCALLBACK fnCallback, LPVOID lpvContext, DWORD dwMaxEntries)
{
    HKEY                    hKey;           // Registry key
    long                    lResult;        // Return from registry calls
    DWORD                   dwMaxNameSize;  // Maximum size of registry value names
    DWORD                   dwMaxDataSize;  // Maximum size of registry value data
    LPWSTR                  lpszName;       // Value name
    LPBYTE                  lpbData;        // Value data
    DWORD                   dwNameSize;     // Size of this value name
    DWORD                   dwDataSize;     // Size of this value data
    BOOL                    fContinue;      // Continue enumeration
    DWORD                   dwType;         // Type of registry data.  Must be REG_BINARY
    DWORD                   dwIndex;        // Current value index

    TRY
    {
		if (!VALID_READ_STRING_PTR(lpszSection, WSTRLEN_BYTES(lpszSection))) 
		{
		    DPF_ERR( "bad section string pointer" );
		    return DPERR_INVALIDPARAMS;
		}
		if (!VALID_READ_STRING_PTR(lpszKey, WSTRLEN_BYTES(lpszKey))) 
		{
		    DPF_ERR( "bad key string pointer" );
		    return DPERR_INVALIDPARAMS;
		}

		if (!VALIDEX_CODE_PTR(fnCallback))
		{
		    DPF_ERR("Invalid callback routine");
		    return (DPERR_INVALIDPARAMS);
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }
    
    // Open the registry key
    if((lResult = OpenMRUKey(lpszSection, lpszKey, &hKey, GENERIC_READ)) != ERROR_SUCCESS)
    {
        // Key doesn't exist.  Nothing to enumerate.
        return DP_OK;
    }

    // Get maximum sizes for names and data
    if((lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxNameSize, &dwMaxDataSize, NULL, NULL)) != ERROR_SUCCESS)
    {
        // No values to enumerate
        RegCloseKey(hKey);
        return DP_OK;
    }

    // Name size does not include the NULL terminator
    dwMaxNameSize++;

    // Nor does it use WCHAR
    dwMaxNameSize *= sizeof(WCHAR);
    
    // Allocate memory
    if(!(lpszName = (LPWSTR)DPMEM_ALLOC(dwMaxNameSize)))
    {
        RegCloseKey(hKey);
        return DPERR_OUTOFMEMORY;
    }

    if(!(lpbData = (LPBYTE)DPMEM_ALLOC(dwMaxDataSize)))
    {
        DPMEM_FREE(lpszName);
        RegCloseKey(hKey);
        return DPERR_OUTOFMEMORY;
    }

    // Enumerate values
    dwIndex = 0;
    fContinue = TRUE;

    while(dwIndex < dwMaxEntries && fContinue)
    {
        // Get value name and data
        dwNameSize = dwMaxNameSize;
        dwDataSize = dwMaxDataSize;

        if((lResult = OS_RegEnumValue(hKey, dwIndex, lpszName, &dwNameSize, NULL, &dwType, lpbData, &dwDataSize)) != ERROR_SUCCESS)
        {
            // No more entries
            break;
        }

        // Validate type.  Must be REG_BINARY
        if(dwType == REG_BINARY)
        {
            // Call callback function
            fContinue = fnCallback(lpbData, dwDataSize, lpvContext);
        }

        // Next value, please
        dwIndex++;
    }

    // Free memory
    DPMEM_FREE(lpszName);
    DPMEM_FREE(lpbData);

    // Close the registry key
    RegCloseKey(hKey);

    // Return success
    return DP_OK;
}


// ---------------------------------------------------------------------------
// InternalEnumMRUCallback
// ---------------------------------------------------------------------------
// Description:             Callback function for InternalEnumMRUEntries.
//                          Called from AddMRUEntry to create a linked list
//                          of entries.
// Arguments:
//  LPVOID                  Data.
//  DWORD                   Data size.
//  LPVOID                  Context.
// Returns:
//  BOOL                    TRUE to continue enumeration.
BOOL CALLBACK InternalEnumMRUCallback(LPVOID lpvData, DWORD dwDataSize, LPVOID lpvContext)
{
    AddEntryNode(lpvData, dwDataSize);
    return TRUE;
}


// ---------------------------------------------------------------------------
// AddEntryNode
// ---------------------------------------------------------------------------
// Description:             Adds an MRU entry to the linked list
// Arguments:
//  [in] LPVOID             Data.
//  [in] DWORD              Data size.
// Returns:
//  LPENTRYNODE             Pointer to the node in the list, or NULL on 
//                          failure.
LPENTRYNODE AddEntryNode(LPVOID lpvData, DWORD dwDataSize)
{
    LPENTRYNODE             lpNode;         // Generic node pointer

    if(g_lpEntryListHead)
    {
        // Seek to the end of the list
        lpNode = g_lpEntryListHead;

        while(lpNode->lpNext)
            lpNode = lpNode->lpNext;

        // Allocate memory for the new node
        if(!(lpNode->lpNext = (LPENTRYNODE)DPMEM_ALLOC(sizeof(ENTRYNODE) + dwDataSize)))
        {
            return NULL;
        }

        lpNode = lpNode->lpNext;
    }
    else
    {
        // Allocate memory for the new node
        if(!(lpNode = g_lpEntryListHead = (LPENTRYNODE)DPMEM_ALLOC(sizeof(ENTRYNODE) + dwDataSize)))
        {
            return NULL;
        }
    }

    // Copy the data
    lpNode->lpNext = NULL;
    lpNode->lpvData = lpNode + 1;
    lpNode->dwSize = dwDataSize;
    
    CopyMemory(lpNode->lpvData, lpvData, dwDataSize);

    // Return success
    return lpNode;
}


// ---------------------------------------------------------------------------
// RemoveEntryNode
// ---------------------------------------------------------------------------
// Description:             Removes an MRU entry from the linked list.
// Arguments:
//  [in] LPENTRYNODE        Node to remove.
// Returns:
//  LPENTRYNODE             Pointer to the next node in the list, or NULL on
//                          failure.
LPENTRYNODE RemoveEntryNode(LPENTRYNODE lpRemove)
{
    LPENTRYNODE             lpNode;         // Generic node pointer

    // Make sure there's really a list
    if(!g_lpEntryListHead)
    {
        return NULL;
    }

    // Is the node to remove the list head?
    if(lpRemove == g_lpEntryListHead)
    {
        // Remove the current list head and replace it
        lpNode = g_lpEntryListHead->lpNext;
        DPMEM_FREE(g_lpEntryListHead);
        g_lpEntryListHead = lpNode;
    }
    else
    {
        // Find the node in the list and remove it
        lpNode = g_lpEntryListHead;

        while(lpNode->lpNext && lpNode->lpNext != lpRemove)
            lpNode = lpNode->lpNext;

        if(lpNode->lpNext != lpRemove)
        {
            // Couldn't find the node
            return NULL;
        }

        // Remove the node
        lpNode->lpNext = lpRemove->lpNext;
        DPMEM_FREE(lpRemove);
        lpNode = lpNode->lpNext;
    }

    // Return success
    return lpNode;
}


// ---------------------------------------------------------------------------
// FreeEntryList
// ---------------------------------------------------------------------------
// Description:             Frees the entire MRU entry list.
// Arguments:
//  void
// Returns:
//  void
void FreeEntryList(void)
{
    LPENTRYNODE             lpNode = g_lpEntryListHead;

    while(lpNode)
    {
        lpNode = RemoveEntryNode(lpNode);
    }
}


// ---------------------------------------------------------------------------
// CompareMemory
// ---------------------------------------------------------------------------
// Description:             Compares two memory buffers.
// Arguments:
//  [in] LPVOID             First buffer to compare.
//  [in] LPVOID             Second buffer to compare.
//  [in] DWORD              Buffer sizes.  Don't even bother calling this
//                          function if the sizes differ.
// Returns:
//  int                     0 if the buffers compare.
int CompareMemory(LPVOID lpv1, LPVOID lpv2, DWORD dwSize)
{
    if(!dwSize)
    {
        return 0;
    }

    while(dwSize--)
    {
        if(*(LPBYTE)lpv1 != *(LPBYTE)lpv2)
        {
            return *(LPBYTE)lpv1 - *(LPBYTE)lpv2;
        }
    }

    return 0;
}


// ---------------------------------------------------------------------------
// RegDelAllValues
// ---------------------------------------------------------------------------
// Description:             Removes all values from a registry key.
// Arguments:
//  [in] HKEY               Key to clean.
// Returns:
//  long                    Registry error code.
long RegDelAllValues(HKEY hKey)
{
    long                    lResult;            // Registry error code
    DWORD                   dwMaxNameSize;      // Maximum value name size
    LPWSTR                  lpszName;           // Value name
    DWORD                   dwNameSize;         // Value name size

    // Get maximum name size
    if((lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxNameSize, NULL, NULL,NULL)) != ERROR_SUCCESS)
    {
        return lResult;
    }

    // Allocate memory
    dwMaxNameSize++;
    dwMaxNameSize *= sizeof(WCHAR);

    if(!(lpszName = (LPWSTR)DPMEM_ALLOC(dwMaxNameSize)))
    {
        return ERROR_OUTOFMEMORY;
    }

    // Enumerate all values
    while(1)
    {
        // Get name
        dwNameSize = dwMaxNameSize;

        if((lResult = OS_RegEnumValue(hKey, 0, lpszName, &dwNameSize, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS)
        {
            break;
        }

        // Delete the value
        OS_RegDeleteValue(hKey, lpszName);
    }

    // Free memory
    DPMEM_FREE(lpszName);

    // Return success
    return ERROR_SUCCESS;
}


// ---------------------------------------------------------------------------
// OpenMRUKey
// ---------------------------------------------------------------------------
// Description:             Opens the MRU registry key.
// Arguments:
//  [in] LPCWSTR            Section name.
//  [in] LPCWSTR            Key name.
//  [out] HKEY *            Pointer to a registry key handle.
//  [in] DWORD              Open flags.
// Returns:
//  long                    Registry error code.
long OpenMRUKey(LPCWSTR lpszSection, LPCWSTR lpszKey, HKEY *lphKey, DWORD dwFlags)
{
    LPWSTR                  lpszFullKey;    // Full key name
    long                    lResult;        // Error code
    DWORD                   dwAction;       // Action returned from RegCreateKeyEx()
    
    // Get the full key name
    if(!(lpszFullKey = (LPWSTR)DPMEM_ALLOC((wstrlen(MRU_KEY_TOP) + 1 + wstrlen(lpszSection) + 1 + wstrlen(lpszKey) + 1) * sizeof(WCHAR))))
    {
        return ERROR_OUTOFMEMORY;
    }

    wstrcpy(lpszFullKey, MRU_KEY_TOP);
    wstrcat(lpszFullKey, L"\\");
    wstrcat(lpszFullKey, lpszSection);
    wstrcat(lpszFullKey, L"\\");
    wstrcat(lpszFullKey, lpszKey);

    // Open or create the key
    if(dwFlags == GENERIC_READ)
    {
        lResult = OS_RegOpenKeyEx(MRU_KEY_PARENT, lpszFullKey, 0, KEY_ALL_ACCESS, lphKey);
    }
    else
    {
        lResult = OS_RegCreateKeyEx(MRU_KEY_PARENT, lpszFullKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, lphKey, &dwAction);
    }

    // Free memory
    DPMEM_FREE(lpszFullKey);

    // Return
    return lResult;
}


// ---------------------------------------------------------------------------
// wstrlen, wstrcpy, wstrcat
// ---------------------------------------------------------------------------
// Description:             Unicode string helper functions.
int wstrlen(LPCWSTR lpszString)
{
    int                     nLen = 0;

    while(*lpszString++)
    {
        nLen++;
    }

    return nLen;
}


int wstrcpy(LPWSTR lpszDest, LPCWSTR lpszSrc)
{
    int                     nLen = 0;
    
    while(*lpszSrc)
    {
        *lpszDest++ = *lpszSrc++;
        nLen++;
    }

    *lpszDest = 0;

    return nLen;
}


int wstrcat(LPWSTR lpszDest, LPCWSTR lpszSrc)
{
    while(*lpszDest)
    {
        lpszDest++;
    }

    return wstrcpy(lpszDest, lpszSrc);
}


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_GetSPData"

// 
// sp's can get the blob of data previously set w/ this IDirectPlay pointer
// we give out our pointer to the sp here (no data copying)
HRESULT DPAPI DP_SP_GetSPData(IDirectPlaySP * pISP,LPVOID * ppvData,LPDWORD pdwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (dwFlags != DPGET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Local data only supported for this release");
			return E_NOTIMPL;
		}
		
		*pdwDataSize = 0;
	 	*ppvData = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	*pdwDataSize  = this->dwSPLocalDataSize;
	*ppvData = this->pvSPLocalData;

	LEAVE_DPLAY();
	return DP_OK;

} // DPlay_GetSPPlayerData

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_SetSPData"

//	 
// sp's can set a blob of data with each idirectplaysp 
HRESULT DPAPI DP_SP_SetSPData(IDirectPlaySP * pISP,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (!VALID_STRING_PTR(pvData,dwDataSize))
		{
			LEAVE_DPLAY();
			DPF_ERR("SP - passed bad buffer");
            return DPERR_INVALIDPARAM;
		}

		if (dwFlags != DPSET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Local data only supported for this release");
			return E_NOTIMPL;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	hr = DoSPData(this,NULL,pvData,dwDataSize,dwFlags);	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		DPF_ERRVAL("could not set idirectplaysp data- hr = 0x%08lx\n",hr);
	}

	LEAVE_DPLAY();
	return hr;

} // DPlay_SetSPPlayerData


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLAYSVR"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\superpac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SuperPack.c
 *  Content:	SuperPacks / unSuperPacks players + group before / after network xport
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  4/16/97		andyco	created it
 *  6/22/97     sohailm updated to use pClientInfo.
 *  8/4/97		andyco	track this->dwMinVersion as we unpack
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *   4/1/98     aarono  don't propogate local only player flags
 ***************************************************************************/

 /**************************************************************************
 *
 * SuperPacked player format :                                            
 *
 *	fixed fields
 *		dwFixedSize - size of fixed struct
 *		dwFlags - player or group flags (DPLAYI_
 *		DPID - the id of the player or group
 *		dwMask - bitfield indicating which optional fields are present
 *	
 *	optional fields
 *		dwVersion - version of player - present if dwFlags & DPLAYI_PLAYER_SYSPLAYER
 *		idSysPlayer - present if ! (dwFlags & DPLAYI_PLAYER_SYSPLAYER)
 *		dwSPDataSize 
 *		pvSPData 
 *		dwPlayerDataSize
 *		pvPlayerData
 *		pszShortName
 *		pszLongName
 *		dwNPlayers - # players in a group
 *		dwNGroupGroups - the number of contained groups in a group
 *
 *	after all the packed players and groups comes a list of linked groups 
 *
 **************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"SuperSuperPack! -- "

// offsets within mask of fields
#define SHORTSTR 	0 // 1 bit - string or not
#define LONGSTR 	1 // 1 bit - string or not
#define	SPDATA		2 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define	PLAYERDATA	4 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define NPLAYERS	6 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define	IDPARENT	8 // 1 bit - present or not
#define SHORTCUTS	9 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size

// constants used to define whether we've written a value into our buffer using a 
// byte, word, or dword
#define SIZE_BYTE	1
#define SIZE_WORD	2
#define SIZE_DWORD	3

// used to determine if the size fits in byte, word or dword
#define BYTE_MASK 0xFFFFFF00
#define WORD_MASK 0xFFFF0000

// extract dwBits bits from the dword dwMask, from loc'n dwOffset
DWORD GetMaskValue(DWORD dwMask,DWORD dwOffset,DWORD dwBits)
{
	DWORD rval;
	
	// shift it right to shift off right most bits
	rval = dwMask >> dwOffset;
	
	// shift it left to shift off left most bits
	rval = rval << (32 - dwBits);
	
	// shitf it back to right align rval
	rval = rval >> (32 - dwBits);	

	return rval;
		
} // GetMaskValue

DWORD GetSize(LPBYTE * ppBufferIndex,DWORD dwMaskValue)
{
	DWORD rval;

	// pick off the dword
	rval = *((LPDWORD)*ppBufferIndex);	

	switch (dwMaskValue)
	{
		// trim any extra bits, and advance ppBufferIndex as necessary
		case SIZE_BYTE:
			rval &= ~BYTE_MASK;			
			*ppBufferIndex += sizeof(BYTE);
			break;
		case SIZE_WORD:
			rval &= ~WORD_MASK;
			*ppBufferIndex += sizeof(WORD);			
			break;
		case SIZE_DWORD:			
			*ppBufferIndex += sizeof(DWORD);			
			break;
		default:
			ASSERT(FALSE);
			break;
	}	
	
	return rval;
	
} // GetSize

/*
 ** UnSuperpackPlayer
 *
 *  CALLED BY: UnSuperpackPlayerAndGroupList
 *
 *  PARAMETERS: 
 *		this - direct play object
 *		pPacked - packed player or group
 *		pMsg - original message received (used so we can get sp's message data
 *			out for CreatePlayer call)
 *		bPlayer - is packed a player or a group?
 *		ppBuffer - set to end of packed player in buffer
 *
 *  DESCRIPTION: UnSuperpacks player. creates new player, sets it up.
 *
 *  RETURNS: SP's hr, or result	of GetPlayer or SendCreateMessage
 *
 */
HRESULT UnSuperpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked,
	LPVOID pvSPHeader,BOOL bPlayer,LPBYTE * ppBuffer)
{
    LPWSTR lpszShortName, lpszLongName;
	DPNAME PlayerName;
	LPVOID pvPlayerData;
	LPVOID pvSPData;
    LPDPLAYI_PLAYER pNewPlayer;
	LPDPLAYI_GROUP pNewGroup;
    LPBYTE pBufferIndex;
	HRESULT hr;
	DWORD dwMaskValue;
	DWORD dwPlayerDataSize=0,dwSPDataSize=0;
	DWORD dwVersion,dwIDSysPlayer;
	BOOL fSizeOnly = FALSE;
	DPID idParent = 0;
	
	pBufferIndex = (LPBYTE)pSuperPacked + pSuperPacked->dwFixedSize;	
	
	if (pSuperPacked->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
	{
		// system player - get version
		dwVersion = GetSize(&pBufferIndex,SIZE_DWORD);
		dwIDSysPlayer = pSuperPacked->dwID;
	}
	else 
	{
		// non system player - get system player
		dwIDSysPlayer = GetSize(&pBufferIndex,SIZE_DWORD);
		dwVersion = 0; // todo - do we need version on non-sysplayer?
	}
	
	if (this->pSysPlayer && (this->pSysPlayer->dwID == dwIDSysPlayer))
	{
		// skip this player - it's our own system player
		fSizeOnly = TRUE; 
	}

	// short name
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SHORTSTR,1);
	if (dwMaskValue)
	{
		lpszShortName = (WCHAR *)(pBufferIndex);
		pBufferIndex += WSTRLEN_BYTES(lpszShortName);
	}
	else lpszShortName = NULL;

	// long name
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,LONGSTR,1);
	if (dwMaskValue)
	{
		lpszLongName = (WCHAR *)(pBufferIndex);
		pBufferIndex += WSTRLEN_BYTES(lpszLongName);
	}
	else lpszLongName = NULL;

	memset(&PlayerName,0,sizeof(DPNAME));
	PlayerName.dwSize = sizeof(DPNAME);
	PlayerName.lpszShortName = lpszShortName;
	PlayerName.lpszLongName = lpszLongName;

	// player data
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,PLAYERDATA,2);
	if (dwMaskValue)
	{
		dwPlayerDataSize = GetSize(&pBufferIndex,dwMaskValue);
		pvPlayerData = pBufferIndex;
		pBufferIndex += dwPlayerDataSize;
	}
	else pvPlayerData = NULL;

	// sp data
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SPDATA,2);
	if (dwMaskValue)
	{
		dwSPDataSize = GetSize(&pBufferIndex,dwMaskValue);
		pvSPData = pBufferIndex;
		pBufferIndex += dwSPDataSize;
	}
	else pvSPData = NULL;

	// player is not local
	pSuperPacked->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;

	// id Parent?
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,IDPARENT,1);
	if (dwMaskValue)
	{
		ASSERT(!bPlayer);
		idParent = *(((DWORD *)pBufferIndex)++);
	}

	// if it's a player, this is the end of the packed buffer
	*ppBuffer = pBufferIndex;	
	
	if (fSizeOnly)
	{
		ASSERT(bPlayer); // only should happen w/ our own sysplayer
		return DP_OK;
	}

	// go create the player
	if (bPlayer)
	{
		hr = GetPlayer(this,&pNewPlayer,&PlayerName,NULL,pvPlayerData,
			dwPlayerDataSize,pSuperPacked->dwFlags,NULL,0);
	}
	else 
	{
		hr = GetGroup(this,&pNewGroup,&PlayerName,pvPlayerData,
			dwPlayerDataSize,pSuperPacked->dwFlags,idParent,0);
		// cast to player - we only going to use common fields
		pNewPlayer = (LPDPLAYI_PLAYER)pNewGroup;		
	}
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		return hr;
		// rut ro!
	}

	pNewPlayer->dwIDSysPlayer = dwIDSysPlayer;
	pNewPlayer->dwVersion = dwVersion;	
	
	if (DPSP_MSG_DX3VERSION == pNewPlayer->dwVersion)
	{
		DPF(0,"detected DX3 client in game");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if (pNewPlayer->dwVersion && (pNewPlayer->dwVersion < this->dwMinVersion))
	{
		this->dwMinVersion = pNewPlayer->dwVersion;
		DPF(2,"found new min player version of %d\n",this->dwMinVersion);
	}

	if (dwSPDataSize)
	{
		// copy the sp data - 1st, alloc space
		pNewPlayer->pvSPData = DPMEM_ALLOC(dwSPDataSize);
		if (!pNewPlayer->pvSPData) 
		{
			// rut ro!
			DPF_ERR("out of memory, could not copy spdata to new player!");
			return E_OUTOFMEMORY;
		}
		pNewPlayer->dwSPDataSize = dwSPDataSize;
	
		// copy the spdata from the packed to the player
		memcpy(pNewPlayer->pvSPData,pvSPData,dwSPDataSize);
	}

	// now, set the id and add to nametable
	pNewPlayer->dwID = pSuperPacked->dwID;

    // if we are a secure server and we receive a remote system player, 
    // move the phContext from the nametable into the player structure before the slot
    // is taken by the player
	//
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this) &&
        !(pNewPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
        (pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        pNewPlayer->pClientInfo = (LPCLIENTINFO) DataFromID(this,pNewPlayer->dwID);
		DPF(6,"pClientInfo=0x%08x for player %d",pNewPlayer->pClientInfo,pNewPlayer->dwID);
    }
    

	// don't add to the nametable if it's the app server - this id is fixed
	if (!(pNewPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))	
	{
		hr = AddItemToNameTable(this,(DWORD_PTR)pNewPlayer,&(pNewPlayer->dwID),TRUE,0);
	    if (FAILED(hr)) 
	    {
			ASSERT(FALSE);
			// if this fails, we're hosed!  there's no id on the player, but its in the list...
			// todo - what now???
	    }
	}

	// call sp 	
	if (bPlayer)
	{
		// tell sp about player
		hr = CallSPCreatePlayer(this,pNewPlayer,FALSE,pvSPHeader,TRUE);
		
	    // add to system group
	    if (this->pSysGroup)
	    {
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			pNewPlayer->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
	    }
	}
	else 
	{
		// tell sp about group
		hr = CallSPCreateGroup(this,(LPDPLAYI_GROUP)pNewPlayer,TRUE,pvSPHeader);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// todo -handle create player / group fails on UnSuperpack
	}

	// if it's a group, UnSuperpack group info
	if (!bPlayer)
	{
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList = (LPDWORD)pBufferIndex;
		DWORD dwPlayerID;

		if (idParent)
		{
			// add it to parent
			hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces,idParent,
				pNewPlayer->dwID,0,FALSE);
			if (FAILED(hr))
			{
				DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
				// keep trying...
			}
		}
		
		dwMaskValue = GetMaskValue(pSuperPacked->dwMask,NPLAYERS,2);
		if (dwMaskValue)
		{
			nPlayers = GetSize(&pBufferIndex,dwMaskValue);
			pdwIDList = (LPDWORD)pBufferIndex;
		}
		else nPlayers = 0;

		// now, add the players to the group
		while (nPlayers>0)
		{
			nPlayers--;
			dwPlayerID = *pdwIDList++;
			hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,pSuperPacked->dwID,
				dwPlayerID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
				// keep trying...
			}
		}	
		
		*ppBuffer = (LPBYTE)pdwIDList;	
	// all done!
	} // !bPlayer

	return hr;

}// UnSuperpackPlayer

HRESULT UnSuperpackShortcuts(LPDPLAYI_DPLAY this,LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked,
	LPBYTE * ppBuffer)
{
    LPBYTE pBufferIndex;
	HRESULT hr;
	DWORD dwMaskValue;
	LPDWORD pdwBufferIndex;
	DWORD nShortcuts = 0;
	DWORD i;
	DPID idShortcut;
	
	pBufferIndex = (LPBYTE)pSuperPacked + pSuperPacked->dwFixedSize;	
	
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SHORTCUTS,2);
	if (dwMaskValue)
	{
		nShortcuts = GetSize(&pBufferIndex,dwMaskValue);
	}
	ASSERT(nShortcuts > 0);
	
	pdwBufferIndex = (LPDWORD)pBufferIndex;
	for (i=0;i<nShortcuts ;i++ )
	{
		idShortcut = *pdwBufferIndex++;
		hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces, 
			pSuperPacked->dwID, idShortcut,DPGROUP_SHORTCUT,FALSE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	// remember where we are
	*ppBuffer = (LPBYTE)pdwBufferIndex;
	
	return DP_OK;
	
} // UnSuperpackShortcuts

/*
 ** UnSuperpackPlayerAndGroupList
 *
 *  CALLED BY: handler.c (on createplayer/group message) and iplay.c (CreateNameTable)
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *		pvSPHeader - sp's header, as received off the wire
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT UnSuperpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,UINT nShortcuts,LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
	LPBYTE pBufferIndex;
	LPDPLAYI_SUPERPACKEDPLAYER pPacked;

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		// don't UnSuperpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		hr = UnSuperpackPlayer(this,pPacked,pvSPHeader,TRUE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

		nPlayers --;
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackPlayer(this,pPacked,pvSPHeader,FALSE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nGroups --;
   	} 
	
	while (nShortcuts > 0)
	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackShortcuts(this,pPacked,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nShortcuts--;
	}	
	return hr;

} // UnSuperpackPlayerAndGroupList

// how mayn bytes to represent dwSize
DWORD ByteSize(DWORD dwSize)
{
	if ( !(dwSize & BYTE_MASK) )
	{
		// fits in a byte
		return sizeof(BYTE);
	}
	 
	if ( !(dwSize & WORD_MASK) )
	{
		// fits in a WORD
		return sizeof(WORD);
	}

	return sizeof(DWORD);
	
} // ByteSize

DWORD SuperPackedPlayerSize(LPDPLAYI_PLAYER pPlayer) 
{
	DWORD dwSize = 0;
	
	// space 4 strings + struct + version/sysplayer id
	dwSize = (WSTRLEN(pPlayer->lpszShortName) + WSTRLEN(pPlayer->lpszLongName)) 
		* sizeof(WCHAR)	+ sizeof(DPLAYI_SUPERPACKEDPLAYER) + sizeof(DWORD);
		
	// player + sp data need data + 1 
	if (pPlayer->dwPlayerDataSize)
	{
		dwSize += pPlayer->dwPlayerDataSize	+ ByteSize(pPlayer->dwPlayerDataSize);
	}		 

	if (pPlayer->dwSPDataSize)
	{
		dwSize += pPlayer->dwSPDataSize + ByteSize(pPlayer->dwSPDataSize);
	}

	return dwSize;

} // SuperPackedPlayerSize

DWORD SuperPackedGroupSize(LPDPLAYI_GROUP  pGroup)
{
	DWORD dwSize = 0;
	LPDPLAYI_SUBGROUP pSubgroup;
	UINT nShortcuts;

	// space for player stuff, plus space for group list 
	dwSize = SuperPackedPlayerSize((LPDPLAYI_PLAYER)pGroup);
	
	if (pGroup->nPlayers)
	{
		dwSize += pGroup->nPlayers*sizeof(DPID) + ByteSize(pGroup->nPlayers);
	}
	
	if (pGroup->dwIDParent)
	{
		dwSize += sizeof(DPID);
	}
	
	// see if we'll have shortcuts w/ this group
	nShortcuts = 0;
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			nShortcuts++;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	if (nShortcuts)		
	{
		// if there were shortcuts, then this group will have a packed struct, the number of shortcuts
		// and a list of shortcuts at the end
		dwSize += sizeof(DPLAYI_SUPERPACKEDPLAYER)  + ByteSize(nShortcuts) + nShortcuts*sizeof(DPID);
	}
	
	return dwSize;	
} // SuperPackedGroupSize

// returns how big the SuperPacked player structure is for the nPlayers
DWORD SuperPackedBufferSize(LPDPLAYI_PLAYER pPlayer,int nPlayers,BOOL bPlayer) 
{
	DWORD dwSize=0;
	LPDPLAYI_GROUP pGroup = (LPDPLAYI_GROUP)pPlayer;
		
	while (nPlayers > 0)
	{
		if (bPlayer)
		{

			ASSERT(pPlayer);
			dwSize += SuperPackedPlayerSize(pPlayer);
			pPlayer=pPlayer->pNextPlayer;
		}
		else 
		{
			ASSERT(pGroup);
			// don't count the system group - we don't send that one
			if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
			{
				dwSize += SuperPackedGroupSize(pGroup);
			}
			
			pGroup = pGroup->pNextGroup;			
		}
		nPlayers--;		
	}	
	return dwSize;
} // SuperPackedBufferSize

// set some bits (dwVal) at some offset (dwOffset) in a mask (pdwMask)
// called by SuperPackPlayer  
void SetMask(LPDWORD pdwMask,DWORD dwOffset,DWORD dwVal)
{
	*pdwMask |= dwVal<<dwOffset;
} // SetMask


// writes the dwSize field into the buffer as a byte, word or dword.
// returns 1,2 or 3 for byte, word or dword
DWORD WriteSize(LPBYTE * ppBuffer,DWORD dwSize)
{
	if ( !(dwSize & BYTE_MASK) )
	{
		// fits in a byte
		*((BYTE *)*ppBuffer) = (BYTE)dwSize;
		*ppBuffer += sizeof(BYTE);
		return SIZE_BYTE;
	}

	if ( !(dwSize & WORD_MASK) )
	{
		// fits in a WORD
		*((WORD *)*ppBuffer) = (WORD)dwSize;
		*ppBuffer += sizeof(WORD);
		return SIZE_WORD;
	}

	// needs the whole mccoy
	*((DWORD *)*ppBuffer) = dwSize;
	*ppBuffer += sizeof(DWORD);

	return SIZE_DWORD;
	
} // WriteSize

// constructs a SuperPackedplayer object from pPlayer. stores result in pBuffer
// returns size of SuperPacked player
DWORD SuperPackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) 
{
	LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked;
	int iStrLen;
	LPBYTE pBufferIndex = pBuffer + sizeof(DPLAYI_SUPERPACKEDPLAYER);
	DWORD dwMaskValue;
		
	if (!pBuffer)
	{
		return SuperPackedBufferSize(pPlayer,1,bPlayer);
	} // pBuffer

	pSuperPacked = (LPDPLAYI_SUPERPACKEDPLAYER)	pBuffer;
	
	pSuperPacked->dwFixedSize = sizeof(DPLAYI_SUPERPACKEDPLAYER);
	pSuperPacked->dwID = pPlayer->dwID;
	pSuperPacked->dwFlags = pPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS);

	// if it's a sysplayer, set the version
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
	{
		*((DWORD *)pBufferIndex) = pPlayer->dwVersion;
	}
	else 
	{						   
		// otherwise, store the sysplayer id
		*((DWORD *)pBufferIndex) = pPlayer->dwIDSysPlayer;
	}
	pBufferIndex += sizeof(DWORD);
	
	// short name	
	if (pPlayer->lpszShortName)	
	{
		iStrLen	= WSTRLEN_BYTES(pPlayer->lpszShortName);
		memcpy(pBufferIndex,pPlayer->lpszShortName,iStrLen);
		pBufferIndex += iStrLen;
		// set the mask bit
		SetMask(&(pSuperPacked->dwMask),SHORTSTR,1);
	}
	// next, long name
	if (pPlayer->lpszLongName)
	{
		iStrLen	= WSTRLEN_BYTES(pPlayer->lpszLongName);
		memcpy(pBufferIndex,pPlayer->lpszLongName,iStrLen);
		pBufferIndex += iStrLen;
		SetMask(&(pSuperPacked->dwMask),LONGSTR,1);
	}

	// next, player data
	if (pPlayer->pvPlayerData)
	{
		// 1st, store the size		
		dwMaskValue = WriteSize(&pBufferIndex,pPlayer->dwPlayerDataSize);
		// set the mask bits
		SetMask(&(pSuperPacked->dwMask),PLAYERDATA,dwMaskValue);
		// next, the data
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		pBufferIndex += pPlayer->dwPlayerDataSize;
	}

	// finally, pack sp data
	if (pPlayer->pvSPData)
	{
		// 1st, store the size		
		dwMaskValue = WriteSize(&pBufferIndex,pPlayer->dwSPDataSize);
		// set the mask bits
		SetMask(&(pSuperPacked->dwMask),SPDATA,dwMaskValue);
		// next, the data
		memcpy(pBufferIndex,pPlayer->pvSPData,pPlayer->dwSPDataSize);
		pBufferIndex += pPlayer->dwSPDataSize;

	}

	if (!bPlayer)
	{
		// we shouldn't be asked to pack the sysgroup
		ASSERT(! (pPlayer->dwFlags & DPLAYI_GROUP_SYSGROUP));

		// parent id ?
		if (((LPDPLAYI_GROUP)pPlayer)->dwIDParent)
		{
			SetMask(&(pSuperPacked->dwMask),IDPARENT,1);
			*(((DWORD *)pBufferIndex)++) = ((LPDPLAYI_GROUP)pPlayer)->dwIDParent;
		}
		
		// next, any players in group
		if ( ((LPDPLAYI_GROUP)pPlayer)->nPlayers )
		{
			LPDPLAYI_GROUPNODE pGroupnode = ((LPDPLAYI_GROUP)pPlayer)->pGroupnodes;

			// 1st, store the size		
			dwMaskValue = WriteSize(&pBufferIndex,((LPDPLAYI_GROUP)pPlayer)->nPlayers);
			// set the mask bits
			SetMask(&(pSuperPacked->dwMask),NPLAYERS,dwMaskValue);
			// next, write the list of player id's
			while (pGroupnode)
			{
				ASSERT(pGroupnode->pPlayer);
				*(((DWORD *)pBufferIndex)++) = pGroupnode->pPlayer->dwID;
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		} // players
		
		
	} // !bPlayer
	return (DWORD)(pBufferIndex - pBuffer);

} // SuperPackPlayer

// throw the shortcuts onto the end of the biffer
DWORD SuperPackShortcuts(LPDPLAYI_GROUP pGroup,LPBYTE pBuffer)
{
	LPDPLAYI_SUBGROUP pSubgroup;
	LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked;
	LPBYTE pBufferIndex;
	LPDWORD pdwBufferIndex;
	DWORD dwMaskValue;
	UINT nShortcuts = 0;  

	// 1st - see if there are any	
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			nShortcuts++;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	if (!nShortcuts) return 0;
	
	pSuperPacked = (LPDPLAYI_SUPERPACKEDPLAYER)	pBuffer;
	pBufferIndex = pBuffer + sizeof(DPLAYI_SUPERPACKEDPLAYER);
	
	pSuperPacked->dwFixedSize = sizeof(DPLAYI_SUPERPACKEDPLAYER);
	pSuperPacked->dwID = pGroup->dwID;
	pSuperPacked->dwFlags = pGroup->dwFlags;

	// stick the number of subgroups in the struct
	dwMaskValue = WriteSize(&pBufferIndex,nShortcuts);
	ASSERT(dwMaskValue>=1);
	SetMask(&(pSuperPacked->dwMask),SHORTCUTS,dwMaskValue);

	// now, add subgroup id's	
	pSubgroup = pGroup->pSubgroups;
	pdwBufferIndex= (LPDWORD)pBufferIndex;
	
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			*pdwBufferIndex++ = pSubgroup->pGroup->dwID;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	
	pBufferIndex = (LPBYTE)pdwBufferIndex;
	return (DWORD)(pBufferIndex - pBuffer);

} // SuperPackShortcuts

					
HRESULT SuperPackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) 
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP 	pGroup;
	
	if (CLIENT_SERVER(this))
	{
		// we should never get called for client server - that should use regular pack.c
		ASSERT(FALSE); 
		return E_FAIL; // E_DON'T_DO_THAT!
	}

	if (!pBuffer) 
	{
		*pdwBufferSize = SuperPackedBufferSize((LPDPLAYI_PLAYER)this->pGroups,
				this->nGroups,FALSE);
		*pdwBufferSize += SuperPackedBufferSize(this->pPlayers,this->nPlayers,TRUE);
		return DP_OK;
	}
	// else, assume buffer is big enough...
	
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pBuffer += SuperPackPlayer(pPlayer,pBuffer,TRUE);
		pPlayer = pPlayer->pNextPlayer;
	}
	// next, SuperPack groups
	pGroup = this->pGroups;
	while (pGroup)
	{
		// don't send the system group 
		if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			pBuffer += SuperPackPlayer((LPDPLAYI_PLAYER)pGroup,pBuffer,FALSE);
		}
		pGroup = pGroup->pNextGroup;
	}
	
	// finally, superpac shortcuts
	pGroup = this->pGroups;
	while (pGroup)
	{
		pBuffer += SuperPackShortcuts(pGroup,pBuffer);
		pGroup = pGroup->pNextGroup;
	}

	return DP_OK;
	
}// SuperPackPlayerAndGroupList	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\sysmess.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sysmess.c
 *  Content:	sends system messages e.g. create/delete player
 *				also sends player to player messages
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/13/96		andyco	created it
 *	2/15/96		andyco	added player - player messages
 *	3/7/96		andyco	added reliable / unreliable player messages
 *	4/23/96		andyco	added delete player when send returns E_FAIL
 *	6/4/96		andyco	deletes player on dperr_playerlost, not e_fail
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *  6/21/96		kipo	Bug #2081. Need to subtract off header size from
 *						message size in SendDPMessage() before calling
 *						DPlay_HandleSPMessage() for local players.
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	7/10/96		andyco	changes for pending - checks on sendsystemmessage 
 *						modified for 2nd local sysplayer. 
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *						check for session lost on send to remote players
 *	8/8/96		andyco	added support for dpsession_nomessageid
 * 10/11/96     sohailm added SendSessionDescChanged()
 * 10/12/96		andyco	added optimized groups
 * 11/12/96		andyco	added system group / server player. unified sendtogroup
 *						and broadcast.
 * 11/21/96		andyco	update perf data if this->pPerfData exists...
 * 1/1/97		andyco	happy new year! all sends go to system players - this way
 *						sp's have fewer players to keep track of.
 *	1/28/97		andyco	SendName/DataChanged takes fPropagate flag so we can 
 *						correctly propagate these
 *	2/1/97		andyco	drop the dplay locks and go into pending modes on sends
 *						for guaranteed player / group messags (app messages only). Bug 5290.
 *  3/14/97     sohailm added functions NeedSigning(), InternalSendDPMessage(), 
 *                      BroadCastSystemMessage() and IsBroadCastSystemMessage().
 *                      modified SendDPMessage() to use InternalSendDPMessage() and 
 *                       SignAndSendDPMessage().
 *                      updated SendSystemMessage to route system messages through nameserver when 
 *                      session is secure.                      
 *  3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Added support for passing session password in addforward
 *  4/11/97		andyco	changed SendSystemMessage, and added ask4multicast
 *	4/20/97		andyco	group in group
 *  4/23/97     sohailm The new SendSystemMessage() was not forwarding system messages to local
 *                      players.
 *                      Added support for encrypting ADDFORWARD and SESSIONDESCCHANGED messages.
 *	5/8/97		andyco	changed SendSystemMessage() to deal w/ CLIENT_SERVER. 
 *						removed update list.
 *  5/08/97     sohailm Temporarily disabled encryption of addforward and setsessiondesc messages.
 *  5/12/97     sohailm Enabled encryption of addforward and setsessiondesc messages.
 *                      Updated NeedSecurity() to allow security in the key exchange state.
 *	5/17/97		myronth	Send the SendChatMessage system message
 *	5/17/97		kipo	There was a bug in SendGroupMessage () where it was
 *						always taking the dplay lock after sending a message if
 *						the pending flag was set. This is bad if the pending flag
 *						was already set when we came into SendGroupMessage(),
 *						(i.e. during DP_Close), causing use to not drop the lock.
 *  5/18/97     sohailm Player-Player messages were not secure, when sent from the server.
 *  5/21/97     sohailm NeedSecurity() now fails if dplay is not providing security support.
 *                      Replaced DP_SP_HandleMessage call in InternalSendDPMessage an 
 *                      InternalHandleMessage() call.
 *	6/2/97		andyco	check for no nameserver in client server case in sendsystemmessage
 *  6/23/97     sohailm Now we use SSPI for message signing until client logs in. After which
 *                      signing is done using CAPI.
 *	6/24/97		kipo	distribute group messages from the server to the client
 *						one message at a time (like DX3) in case the client
 *						does not know about the group.
 *	7/30/97		andyco	return hr on sendplayermessage from actual send
 *  8/01/97		sohailm	removed message broadcasting code written for security.
 *						implemented peer-peer security using dplay multicasting code.
 *  8/4/97		andyco	added SendAsyncAddForward
 *	11/19/97	myronth	Fixed uninitialized To player in SendGroupMessage (#10319)
 *	11/24/97	myronth	Fixed SetSessionDesc messages for client/server (#15226)
 *	1/9/97		myronth	Fixed SendChatMessage to groups (#15294, #16353)
 *	1/14/98		sohailm	don't allow sp to optimize groups in CLIENT_SERVER and SECURE_SERVER(#15210)
 *	1/28/98		sohailm keep groups local to the client in CLIENT_SERVER (#16340)
 *  2/3/98      aarono  Fixed Paketize test for RAW mode 
 *  2/18/98     aarono  changed to direct protocol calls
 *  4/1/98      aarono  flag players that don't have nametable, don't send to them
 *  6/2/98      aarono  skip group sends with 0 members
 *                      fix locking for player deletion
 *  6/10/98     aarono  removed dead security code
 *  6/18/98     aarono  fix group SendEx ASYNC to use unique Header
 ***************************************************************************/


#include "dplaypr.h"
#include "dpcpl.h"
#include "dpsecure.h"
#include "dpprot.h"

#undef DPF_MODNAME
#define DPF_MODNAME "NeedsSecurity"

// this function is called just before a message is handed off to the service provider
// here we decide if the outgoing message needs to be sent securely

BOOL NeedsSecurity(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, 
    LPDPLAYI_PLAYER pPlayerFrom, LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags)
{
    // message doesn't need security if any of the following conditions satisfy

    // dplay is not providing security
    if (!(this->dwFlags & DPLAYI_DPLAY_SECURITY))
    {
        return FALSE;
    }

    // no player yet
    if (!pPlayerFrom)
    {
        return FALSE;
    }

    // message is to a local player
    if (pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
        return FALSE;
    }

    // if we are a client and are not in a signing state
    if (!IAM_NAMESERVER(this) && !VALID_SIGNING_STATE(this))
    {
        return FALSE;
    }

	// if message is one of the following
    switch (dwCommand) {
    case DPSP_MSG_PLAYERMESSAGE:
	// multicast messages could be player messages
	case DPSP_MSG_ASK4MULTICASTGUARANTEED:
		// security only if requested
        if (!(dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            return FALSE;
        }
        break;

    case DPSP_MSG_PING:
    case DPSP_MSG_PINGREPLY:
        return FALSE;
        break;
    }

    // send message securely
    return TRUE;

} // NeedsSecurity

/*
 ** CheckPacketize
 *
 *  CALLED BY:	InternalSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - send flags
 *
 *  DESCRIPTION: checks if we should packetize the send for reliablilty.
 *
 *  RETURNS: sp return value
 *
 */

BOOL CheckPacketize(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,DWORD fSPHeader) 
{
	DWORD dwSPHeaderSize;
	DWORD dwSign;
	DWORD dwCommand;
	LPDPLAYI_PLAYER pSysPlayerTo;
	DWORD dwVersion;
	
	if((this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE|DPLAYI_DPLAY_PROTOCOL)) && (dwMessageSize >= this->dwSPHeaderSize+sizeof(MSG_SYSMESSAGE))) // quick test
	{
		if(fSPHeader){
			dwSPHeaderSize=this->dwSPHeaderSize;
		} else {
			dwSPHeaderSize=0;
		}
		
		dwSign    = ((LPMSG_SYSMESSAGE)(pMessage+dwSPHeaderSize))->dwHeader;
		dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pMessage+dwSPHeaderSize));

		// find dplay version at target so we know if it even supports this type of packetize.
		if(pPlayerTo)
		{
			dwVersion=pPlayerTo->dwVersion;
			if(!dwVersion)
			{ 
				pSysPlayerTo=PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
				if(pSysPlayerTo)
				{
					dwVersion=pPlayerTo->dwVersion=pSysPlayerTo->dwVersion;
				} 
				else 
				{
					ASSERT(0);
					dwVersion=DPSP_MSG_VERSION;
				}
			}
		} 
		else 
		{
			// No pPlayerTo, using SP cached nameserver, grab target version from this.
			dwVersion=this->dwServerPlayerVersion;
		}
		
		if((dwSign==MSG_HDR) && NeedsReliablePacketize(this, dwCommand, dwVersion, dwFlags))
		{
			return TRUE;
		}
	}
	return FALSE;
}			
#undef DPF_MODNAME
#define DPF_MODNAME "InternalSendDPMessage"

/*
 ** InternalSendDPMessage
 *
 *  CALLED BY:	SendDPMessage or SignAndSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				fReliable - requires reliable send?
 *
 *  DESCRIPTION: calls sp to send message
 *
 *  RETURNS: sp return value
 *
 */

HRESULT InternalSendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock) 
{
    DPSP_SENDDATA sd;
	HRESULT hr,hr2;
	DWORD dwMax;
 	LPDPLAYI_PLAYER pSysPlayer;
	
	// first, make sure the player isn't on the dead list
	if (pPlayerTo)
	{
		pSysPlayer=PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer)) 
		{
		    if (pSysPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST)
		    {
		    	DPF(7, "Not sending to %d because the CONNLOST flag is set", pPlayerTo->dwID);
		    	return DPERR_CONNECTIONLOST;
		    }
		}
	}
	
	DPF(7, "Sending message from player id %d to player id %d",
		(pPlayerFrom ? pPlayerFrom->dwID : 0),
		(pPlayerTo ? pPlayerTo->dwID : 0));

	if (dwFlags & DPSEND_GUARANTEED)
	{
		// do we need to packetize for reliability?
		if (!(pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))){ // don't do reliability on loopback.
			if(CheckPacketize(this,	pPlayerTo,pMessage,dwMessageSize,dwFlags,TRUE)){
				DPF(3,"InternalSendDPMessage :: message needs reliable delivery - packetizing with reliablility");
				hr = PacketizeAndSendReliable(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags,
					NULL,FALSE);
				return hr;
			}
		}	
		dwMax = this->dwSPMaxMessageGuaranteed;
	}
	else 
	{
		dwMax = this->dwSPMaxMessage;
	}


	// do we need to packetize
	if (dwMessageSize > dwMax)
	{
		DPF(3,"send :: message too big - packetizing");
		hr = PacketizeAndSend(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,
			dwFlags,NULL,FALSE);

		return hr;
	}

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS += dwMessageSize - this->dwSPHeaderSize;
		this->pPerfData->nSendPPS++;
	}
	
    // build the senddata
    sd.dwFlags = dwFlags;
	sd.bSystemMessage = TRUE;

	// to
	if (NULL == pPlayerTo)
	{
		sd.idPlayerTo = 0;		
	}
	else 
	{
		sd.idPlayerTo = pPlayerTo->dwID;					
		if (!(pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) 
		{
			if (! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
			{
				
				// tell sp to send it to this players system player
				// all sends get routed to system players
				// note that the actual player id is embedded in the message,
				// and will be used for delivery at the receiving end.
				//
				// we can't do this if dx3 players in game, since dx3 nameserver
				// migration doesn't update system player id's
				ASSERT(pPlayerTo->dwIDSysPlayer);
				sd.idPlayerTo = pPlayerTo->dwIDSysPlayer;
			}
		}
	}
	
	// from
	if (NULL == pPlayerFrom)
	{
		sd.idPlayerFrom = 0;		
	}
	else 
	{
		// if it's not from a system player, it's not a system message
		if (!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) sd.bSystemMessage = FALSE;	
		sd.idPlayerFrom = pPlayerFrom->dwID;					
	}

    sd.lpMessage = pMessage;
	sd.dwMessageSize = dwMessageSize;
	sd.lpISP = this->pISP;

	if (pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) 
	{
		DPF(7,"delivering message locally");

		// call our handler directly, bypassing sp
		hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,(LPBYTE)sd.lpMessage + 
			this->dwSPHeaderSize,dwMessageSize - this->dwSPHeaderSize,DPSP_HEADER_LOCALMSG,dwFlags);
	}
	else if((pPlayerTo) && (pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)){
		// don't try to send to a player that doesn't have the nametable.
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",pPlayerTo,pPlayerTo->dwID);
		hr=DPERR_UNAVAILABLE;
	}
    // call sp
    else if (this->pcbSPCallbacks->Send) 
    {

		// make sure we haven't lost the session...
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			DPF_ERR(" ACK - Session Lost - attempt to send to remote player failed!");
			return DPERR_SESSIONLOST;
		}

		if(bDropLock){
			LEAVE_DPLAY();
		}
		DPF(7,"delivering message to service provider");

		if(this->pProtocol){
			hr = ProtocolSend(&sd); // calls sp too.
		} else {
	    	hr = CALLSP(this->pcbSPCallbacks->Send,&sd);    	
	    }

		if(bDropLock){
			ENTER_DPLAY();
		}
	    
		if (DPERR_SESSIONLOST == hr)
		{
			DPF_ERR(" got session lost back from SP ");
			hr = HandleSessionLost(this);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		else if (hr == DPERR_CONNECTIONLOST)
		{
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF(5, " got connection lost for player %d from SP\n", sd.idPlayerTo);
			
			pPlayerToKill=PlayerFromID(this,sd.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
		    		// set the flag on the player's sys player
		    		pPlayerToKill->dwFlags |= DPLAYI_PLAYER_CONNECTION_LOST;
			    	pPlayerToKill->dwTimeToDie = GetTickCount() /*+ 15000*/;
		    		this->dwZombieCount++;
		    		
					// a-josbor: BUGBUG- we can't start the DPLAY thread here becase
					// it might deadlock with the DPLAY lock.  Any ideas?
		    		StartDPlayThread(this, FALSE);
				}
		    }
		}
		else if (hr == DPERR_INVALIDPLAYER){
		
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF_ERR(" got invalid player from SP, killing player\n");

			hr = DPERR_CONNECTIONLOST;
			
			pPlayerToKill=PlayerFromID(this,sd.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
		    	// a-josbor:  actually, kill his sys player
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
					hr2 = KillPlayer(this, pPlayerToKill,IAM_NAMESERVER(this));	// a-josbor: if we're the host tell everyone they're nuked
				}
				else
				{
					DPF_ERR("ERROR: Trying to kill invalid player!");
				}
		    }
			else
			{
				DPF_ERR("ERROR: Trying to kill invalid player!");
			}
			
			if(FAILED(hr2))
			{
				ASSERT(FALSE);
			}
		}
    }
	else 
	{
		ASSERT(FALSE);
	}

	if (FAILED(hr) && hr != DPERR_PENDING) 
	{
		DPF(0,"DP Send - failed hr = 0x%08lx\n",hr);
	}

	return hr; 		
} // InternalSendDPMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendDPMessage"

#undef DPF_MODNAME
#define DPF_MODNAME "ConcatenateSendBuffer"
/*
 ** ConcatenateSendBuffer
 *
 *  CALLED BY:	
 *
 *  PARAMETERS: this - idplay
 *              psed  - sendex parameters
 *              psd   - send paramter struct to be filled in.
 *
 *
 *  DESCRIPTION: converts a scatter gather array into a contiguous
 *               buffer for use in older DPLAY entry points.
 *
 *  NOTE:        allocates
 *
 *  RETURNS: pointer to new buffer, or NULL if out of memory
 *
 */

PUCHAR ConcatenateSendBuffer(LPDPLAYI_DPLAY this, LPSGBUFFER lpSGBuffers, UINT cBuffers, DWORD dwTotalSize)
{
	DWORD   dwMessageSize;
	PUCHAR  pBuffer;
	UINT    i;
	UINT    offset;

	dwMessageSize=this->dwSPHeaderSize+dwTotalSize;

	pBuffer=MsgAlloc(dwMessageSize);
	if(!pBuffer){
		goto exit;
	}

	// copy the SG buffers into the single buffer.  Leave dwSPHeaderSize bytes empty at front.
	offset=this->dwSPHeaderSize;
	for(i=0;i<cBuffers;i++){
		memcpy(pBuffer+offset,lpSGBuffers[i].pData,lpSGBuffers[i].len);
		offset+=lpSGBuffers[i].len;
	}

exit:
	return pBuffer;
}


#undef DPF_MODNAME
#define DPF_MODNAME "ConvertSendExDataToSendData"

/*
 ** ConvertSendExDataToSendData
 *
 *  CALLED BY:	SendDPMessageEx
 *
 *  PARAMETERS: this - idplay
 *              psed  - sendex parameters
 *              psd   - send paramter struct to be filled in.
 *
 *
 *  DESCRIPTION: converts sendexdata to senddata for use
 *               on old sp's or when looping back a send.
 *               Transcribes the Scatter gather buffers and
 *               leave space for the SP header at the front.
 *
 *  RETURNS: sp return value
 *
 */

HRESULT ConvertSendExDataToSendData(LPDPLAYI_DPLAY this, LPDPSP_SENDEXDATA psed, LPDPSP_SENDDATA psd) 
{
	PUCHAR  pBuffer;
	DWORD   dwMessageSize;

	pBuffer=ConcatenateSendBuffer(this,psed->lpSendBuffers,psed->cBuffers,psed->dwMessageSize);
	
	if(!pBuffer){
		return DPERR_NOMEMORY;
	}

	dwMessageSize=this->dwSPHeaderSize+psed->dwMessageSize;

	// same flags except no new bits.
	psd->dwFlags = psed->dwFlags & ~(DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG);

	psd->idPlayerTo     = psed->idPlayerTo;
	psd->idPlayerFrom   = psed->idPlayerFrom;
	psd->lpMessage      = pBuffer;
	psd->dwMessageSize  = dwMessageSize;
	psd->bSystemMessage = psed->bSystemMessage;
	psd->lpISP          = psed->lpISP;
	
	return DP_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "InternalSendDPMessageEx"

/*
 ** InternalSendDPMessageEx
 *
 *  CALLED BY:	SendDPMessage or SignAndSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *              psp  - send parameters
 *
 *
 *  DESCRIPTION: calls sp to send message
 *
 *  RETURNS: sp return value
 *
 */

HRESULT InternalSendDPMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bDropLock) 
{
	DPSP_SENDDATA   sd;
    DPSP_SENDEXDATA sed;
	HRESULT hr,hr2;
	DWORD dwMax;
	DWORD dwSPMsgID; // storage for message id returned by SP
	PUCHAR pBuffer=NULL;
	DWORD bOldSend=FALSE;
 	LPDPLAYI_PLAYER pSysPlayer;

	ASSERT(psp);
	
	// first, make sure the player isn't on the dead list
	if (psp->pPlayerTo)
	{
		pSysPlayer=PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer)) 
		{
		    if (pSysPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST)
		    {
		    	DPF(7, "Not sending to %d because the CONNLOST flag is set", psp->pPlayerTo->dwID);
		    	return DPERR_CONNECTIONLOST;
		    }
		}
	}
	
	DPF(7, "Sending message from player id %d to player id %d",
		(psp->pPlayerFrom ? psp->pPlayerFrom->dwID : 0),
		(psp->pPlayerTo ? psp->pPlayerTo->dwID : 0));

	if (psp->dwFlags & DPSEND_GUARANTEED)
	{
		// do we need to packetize for reliability?
		// don't do reliability on loopback
		if (!(psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))){ 

			if(CheckPacketize(this,	psp->pPlayerTo,psp->Buffers[0].pData,psp->dwTotalSize,psp->dwFlags,FALSE)){
				DPF(3,"InternalSendDPMessage :: message needs reliable delivery - packetizing with reliablility");
				
				pBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
				if(!pBuffer){
					return DPERR_NOMEMORY;
				}
				hr = PacketizeAndSendReliable(this,psp->pPlayerFrom,psp->pPlayerTo,pBuffer,psp->dwTotalSize+this->dwSPHeaderSize,psp->dwFlags,NULL,FALSE);
				goto EXIT;
			}
			
		}	
		dwMax = this->dwSPMaxMessageGuaranteed;
	}
	else 
	{
		dwMax = this->dwSPMaxMessage;
	}


	// do we need to packetize
	if (psp->dwTotalSize > dwMax)
	{
		DPF(3,"send :: message too big - packetizing");
		pBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
		if(!pBuffer){
			return DPERR_NOMEMORY;
		}
		hr = PacketizeAndSend(this,psp->pPlayerFrom,psp->pPlayerTo,pBuffer,psp->dwTotalSize+this->dwSPHeaderSize,psp->dwFlags,NULL,FALSE);
		goto EXIT;
	}

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS += psp->dwTotalSize - this->dwSPHeaderSize;
		this->pPerfData->nSendPPS++;
	}

	//
    // build the SendExData
    //
    
	sed.lpISP = this->pISP;
    sed.dwFlags = psp->dwFlags;
	sed.bSystemMessage = TRUE;

	// TO ID
	if (NULL == psp->pPlayerTo)	{

		sed.idPlayerTo = 0;		

	} else 	{
	
		sed.idPlayerTo = psp->pPlayerTo->dwID;					
		
		// Route messages through system player on host unless DX3 in game
		// Messages delivered by host use the embedded FromID in the message
		// to notify the receiver who the message was from.

		if (!(psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		   (! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ))
		{
				ASSERT(psp->pPlayerTo->dwIDSysPlayer);
				sed.idPlayerTo = psp->pPlayerTo->dwIDSysPlayer;
		}
	}
	
	// FROM ID
	if (NULL == psp->pPlayerFrom){
		sed.idPlayerFrom = 0;		
	}else {
		// if it's not from a system player, it's not a system message
		if (!(psp->pPlayerFrom->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) sed.bSystemMessage = FALSE;	
		sed.idPlayerFrom = psp->pPlayerFrom->dwID;					
	}

	// MESSAGE DATA
    sed.lpSendBuffers = &psp->Buffers[0];
    sed.cBuffers      = psp->cBuffers;
	sed.dwMessageSize = psp->dwTotalSize;

	// OTHER PARAMS
	sed.dwPriority    = psp->dwPriority;
	sed.dwTimeout     = psp->dwTimeout;
	sed.lpDPContext   = (LPVOID)psp->hContext;
	sed.lpdwSPMsgID   = &dwSPMsgID;
	    

	if (psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) {
	
		DPF(7,"delivering message locally");

		// Handle Message doesn't understand sed's, make contiguous.
		hr=ConvertSendExDataToSendData(this, &sed,&sd);
		
		if(!FAILED(hr)){
			pBuffer=sd.lpMessage;
			// call our handler directly, bypassing sp
			hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,(LPBYTE)sd.lpMessage + 
				this->dwSPHeaderSize,sd.dwMessageSize - this->dwSPHeaderSize,DPSP_HEADER_LOCALMSG,sd.dwFlags);
		} 

	}
	else if((psp->pPlayerTo) && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE) && (!(psp->dwFlags & DPSEND_ASYNC))){
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",psp->pPlayerTo,psp->pPlayerTo->dwID);
		// don't try to send to a player that doesn't have the nametable.
		hr=DPERR_UNAVAILABLE;
    } else if (this->pcbSPCallbacks->Send) 	{ // call sp
        
		// make sure we haven't lost the session...
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			DPF_ERR(" ACK - Session Lost - attempt to send to remote player failed!");
			hr = DPERR_SESSIONLOST;
			goto EXIT;
		}

		pspAddRef(psp);			// AddRef in anticipation of the send pending, must be added before
								// send, because it could complete in the send call causing the reference
								// count to go to zero.


		DPF(7,"delivering message to service provider");

		if(bDropLock){
			LEAVE_DPLAY();	//icky,icky,icky, BUGBUG: get rid of API level lock!
		}	

		if(this->pProtocol){
		
			hr = ProtocolSendEx(&sed); // protocol will call SP.
			
		} else if(this->pcbSPCallbacks->SendEx){
		
		    hr = CALLSP(this->pcbSPCallbacks->SendEx,&sed);    	
		    
		} else {

			// No extended send, convert to old method.
			if(!pBuffer){
				hr=ConvertSendExDataToSendData(this, &sed,&sd);
			} else {
				hr=DP_OK;
			}
			if(!FAILED(hr)){
				pBuffer=sd.lpMessage;
				bOldSend=TRUE;
				if(this->pProtocol){
					hr = ProtocolSend(&sd);  // protocol will call SP.
				} else {
				    hr = CALLSP(this->pcbSPCallbacks->Send,&sd);    	
				}    
			}    
		}
		
		if(bDropLock){
			ENTER_DPLAY();
		}
		
		if(hr == DPERR_PENDING){
			AddContext(this,psp,(LPVOID)dwSPMsgID);
		} else if(!(psp->dwFlags & DPSEND_ASYNC) || bOldSend || FAILED(hr)){
			// even in DP_OK case, completion still happens, so we 
			// only pull off the reference in an error case or the SYNC case.
			pspDecRef(this,psp);
		} 

		// error handling
		if (DPERR_SESSIONLOST == hr)
		{
			// Completely lost our connection to the game.
			
			DPF_ERR(" got session lost back from SP ");

			hr = HandleSessionLost(this);
			
			if (FAILED(hr))	{
				ASSERT(FALSE);
			}
		}
		else if (hr == DPERR_CONNECTIONLOST)
		{
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF(5, " got connection lost for player %d from SP\n", sed.idPlayerTo);
			
			pPlayerToKill=PlayerFromID(this,sed.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
		    		// set the flag on the player's sys player
		    		pPlayerToKill->dwFlags |= DPLAYI_PLAYER_CONNECTION_LOST;
			    	pPlayerToKill->dwTimeToDie = GetTickCount() /*+ 15000*/;
		    		this->dwZombieCount++;
					// a-josbor: BUGBUG- we can't start the DPLAY thread here becase
					// it might deadlock with the DPLAY lock.  Any ideas?
		    		StartDPlayThread(this, FALSE);
				}
		    }
		}
		else if (hr == DPERR_INVALIDPLAYER){
		
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF_ERR(" got invalid player from SP, killing player\n");

			hr = DPERR_CONNECTIONLOST;
			
			pPlayerToKill=PlayerFromID(this,sed.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
		    	// a-josbor:  actually, kill his sys player
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
					hr2 = KillPlayer(this, pPlayerToKill,IAM_NAMESERVER(this));	// a-josbor: if we're the host tell everyone they're nuked
				}
				else
				{
					DPF_ERR("ERROR: Trying to kill invalid player!");
				}
		    }
			else
			{
				DPF_ERR("ERROR: Trying to kill invalid player!");
			}
			
			if(FAILED(hr2))
			{
				ASSERT(FALSE);
			}
		}
    } else {
		// No Send Handler???
		ASSERT(FALSE);
	}

EXIT:
	// CleanUp
	if(pBuffer){
		MsgFree(NULL, pBuffer);
	}

	if (FAILED(hr) && hr != DPERR_PENDING) {
		DPF(0,"DP SendEx - failed hr = 0x%08lx\n",hr);
	}

	return hr; 		
} // InternalSendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendDPMessage"

/*
 ** SendDPMessage
 *
 *  CALLED BY:	anyone wanting to invoke the sp's send
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - message attributes (gauranteed, encrypted, signed, etc.)
 *
 *  DESCRIPTION: calls either SecureSendDPMessage or InternalSendDPMessage depending on 
 *              whether the message needs security or not.
 *
 *  RETURNS:    return value from sp or from SecureSendDPMessage
 *
 */

HRESULT SendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,BOOL bDropLock) 
{
	HRESULT hr;

	// If this is a lobby-owned object, we are never going to send a
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

    if (SECURE_SERVER(this))
    {
        DWORD dwCommand=0,dwVersion=0;

        // what message are we sending ?
        hr = GetMessageCommand(this, pMessage+this->dwSPHeaderSize, dwMessageSize, 
            &dwCommand, &dwVersion);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get the message type: hr=0x%08x",hr);
            return hr;
        }

        // do we need to send message securely ?
        if (NeedsSecurity(this, dwCommand, dwVersion, pPlayerFrom, pPlayerTo, dwFlags))
        {
            if ((DPSP_MSG_ADDFORWARDREQUEST == dwCommand) ||
                (DPSP_MSG_SESSIONDESCCHANGED == dwCommand))
            {
				// encrypted messages are signed as well
                dwFlags |= DPSEND_ENCRYPTED;
            }
            else
            {
                dwFlags |= DPSEND_SIGNED;
            }

            // secure messages are sent guaranteed regardless
            dwFlags |=  DPSEND_GUARANTEED;

			// SSPI is used for signing messages during client logon. After logon is completed
			// all messages are signed using CAPI.
			if (!IAM_NAMESERVER(this) && (DPLOGIN_SUCCESS != this->LoginState))
			{
				// send message securely (uses SSPI signing)
				hr = SecureSendDPMessage(this, pPlayerFrom, pPlayerTo, pMessage, 
					dwMessageSize, dwFlags, bDropLock);
			}
			else
			{
				// send message securely (uses CAPI signing)
				hr = SecureSendDPMessageCAPI(this, pPlayerFrom, pPlayerTo, pMessage, 
					dwMessageSize, dwFlags, bDropLock);

			}
			if (FAILED(hr))
			{
				DPF_ERRVAL("Failed to send message securely [0x%08x]", hr);
			}

            // all done
            return hr;
        }
    }

    // if we reach here, security was not requested so just
    // send the message in plain.
    hr = InternalSendDPMessage(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags, bDropLock);

	return hr; 		
} // SendDPMessage


/*
 ** SendDPMessageEx
 *
 *  CALLED BY:	anyone wanting to invoke the sp's send
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - message attributes (gauranteed, encrypted, signed, etc.)
 *
 *  DESCRIPTION: calls either SecureSendDPMessage or InternalSendDPMessage depending on 
 *              whether the message needs security or not.
 *
 *  RETURNS:    return value from sp or from SecureSendDPMessage
 *
 */

HRESULT SendDPMessageEx(LPDPLAYI_DPLAY this,LPSENDPARMS psp, BOOL bDropLock) 
{
	HRESULT hr;

	// If this is a lobby-owned object, we are never going to send a
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

    if (SECURE_SERVER(this))
    {
        DWORD dwCommand=0,dwVersion=0;

        // what message are we sending ?
        hr = GetMessageCommand(this, psp->Buffers[0].pData, psp->dwTotalSize,&dwCommand,&dwVersion);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get the message type: hr=0x%08x",hr);
            return hr;
        }

		ASSERT(!this->pProtocol);
	
		if (NeedsSecurity(this, dwCommand, dwVersion, psp->pPlayerFrom, psp->pPlayerTo, psp->dwFlags))
        {
            if ((DPSP_MSG_ADDFORWARDREQUEST == dwCommand) ||
                (DPSP_MSG_SESSIONDESCCHANGED == dwCommand))
            {
				// encrypted messages are signed as well
                psp->dwFlags |= DPSEND_ENCRYPTED;
            }
            else
            {
                psp->dwFlags |= DPSEND_SIGNED;
            }
            
            // secure messages are sent guaranteed regardless
            psp->dwFlags |=  DPSEND_GUARANTEED;

			// SSPI is used for signing messages during client logon. After logon is completed
			// all messages are signed using CAPI.
			if (!IAM_NAMESERVER(this) && (DPLOGIN_SUCCESS != this->LoginState))
			{
				// send message securely (uses SSPI signing)
				hr = SecureSendDPMessageEx(this, psp, bDropLock);
			}
			else
			{
				// send message securely (uses CAPI signing)
				hr = SecureSendDPMessageCAPIEx(this, psp, bDropLock);

			}
			if (FAILED(hr) && hr != DPERR_PENDING)
			{
				DPF_ERRVAL("Failed to send message securely [0x%08x]", hr);
			}

            // all done
            return hr;
        }
    }

    // if we reach here, security was not requested so just
    // send the message in plain.
    hr = InternalSendDPMessageEx(this,psp,bDropLock);

	return hr; 		
} // SendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendSystemMessage"

/*
 ** SendSystemMessage
 *
 *  CALLED BY: SendCreateMessage,SendPlayerManagementMessage
 *
 *  PARAMETERS: this - idplay
 *				pSendBuffer,dwBufferSize - buffer to send
 *				fPropagate - do we need to send this message to remote system players (TRUE),
 *					or do we just want to pass it on to our local (non-system) players (FALSE).
 *				fSetTo - do we need to set the id of the player we're sending to ?
 *					Some messages (e.g. playermgmtmessages) need the dest player
 *					to be set in the message.  See DPlay_HandleSPMessage in handler.c.
 *
 *  DESCRIPTION: sends messag to all remote system players (if fLocal is TRUE), and 
 *			to all local players
 *
 *  RETURNS:  DP_OK or failure from sp
 *
 */
HRESULT SendSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	DWORD dwFlags, BOOL bIsPlyrMgmtMsg)
{
	HRESULT hr=DP_OK;
   	LPMSG_PLAYERMGMTMESSAGE pmsg = NULL;

	// If this is a lobby-owned object, we are never going to send a system
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

	if(bIsPlyrMgmtMsg)
		pmsg = (LPMSG_PLAYERMGMTMESSAGE)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);

	if(this->dwFlags & DPLAYI_DPLAY_CLOSED){
		dwFlags &= ~DPSEND_ASYNC; // force sends on closing to be synchronous
	}

	if (CLIENT_SERVER(this))
	{
		// are we the nameserver?
		if (IAM_NAMESERVER(this))
		{
			ASSERT(this->pSysPlayer);
			// if so, only tell the world about events related to my system player or 
			// the appserver id
			if ((!bIsPlyrMgmtMsg)
				|| (pmsg->dwPlayerID == this->pSysPlayer->dwID) 
				|| (pmsg->dwPlayerID == DPID_SERVERPLAYER) )
			{
				// tell the world (this will also distribute it to our local players)
				if (this->pSysGroup) 
				{
					hr = SendGroupMessage(this,this->pSysPlayer,this->pSysGroup,dwFlags,
						pSendBuffer,dwMessageSize,FALSE);
				}
				// there won't be a sytemgroup if e.g. we're creating our system 
				// player - that's ok
			}
			// a-josbor: special case.  If we're deleting a player, we need to inform
			//	that player only
			else if (bIsPlyrMgmtMsg && GET_MESSAGE_COMMAND(pmsg) == DPSP_MSG_DELETEPLAYER)
			{
				LPDPLAYI_PLAYER pPlayer;

				pPlayer = PlayerFromID(this, pmsg->dwPlayerID);
				if (VALID_DPLAY_PLAYER(pPlayer))
				{
					hr = SendDPMessage(this, NULL, pPlayer, pSendBuffer,
						dwMessageSize, dwFlags,FALSE);
				}
			}
		} // IAM_NAMESERVER
		else 
		{
			// i am not the nameserver, tell the nameserver
			if (this->pNameServer)
			{
				if (bIsPlyrMgmtMsg)
				{
					// don't send any group related messages to the nameserver
					// a-josbor: handle these two special cases: commands where we have
					// a valid player in the player field, but it's really a group message.
					// note that we can't just check the groupId field of the player message
					// struct, because we'd be interpreting the structure incorrectly for
					// certain messages (i.e. PLAYERDATACHANGED)
					if ((VALID_DPLAY_PLAYER(PlayerFromID(this,pmsg->dwPlayerID)))	// in other words, not a group
						&& (GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_ADDPLAYERTOGROUP)
						&& (GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_DELETEPLAYERFROMGROUP))
					{
						pmsg->dwIDTo = this->pNameServer->dwID;
							
						// send message to nameserver
						hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
							dwMessageSize,dwFlags,FALSE);
					}
				}
				else
				{
					// send message to nameserver
					hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
						dwMessageSize,dwFlags,FALSE);
				}
			}
			else 
			{
			 	// this can happen if e.g. nameserver quits before we do
			}
		} // ! IAM_NAMESERVER

		// finally, distribute the message to all our local players
	    hr =  DistributeSystemMessage(this,pSendBuffer+this->dwSPHeaderSize,
            dwMessageSize-this->dwSPHeaderSize);

	} // CLIENT_SERVER
	else 
	{
		if (this->pSysGroup) 
		{
			hr = SendGroupMessage(this,this->pSysPlayer,this->pSysGroup,dwFlags,
				pSendBuffer,dwMessageSize,FALSE);
		}
		else 
		{
			// this will happen e.g. when you are creating your system player
			DPF(5,"no system group - system message not sent");
		}
	} // ! CLIENT_SERVER
		
	return DP_OK;
	
} // SendSystemMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendCreateMessage"

/*
 ** SendCreateMessage
 *
 *  CALLED BY: DP_CreatePlayer, DP_CreateGroup
 *
 *  PARAMETERS:
 *					this - 	dplay object
 *					pPlayer - player or group we're creating
 *					fPlayer - if !0, creating player, else creating group
 *                  lpszSessionPassword - session password, if creating system player, 
 *                                        otherwise NULL
 *
 *  DESCRIPTION:
 *					sets up a createxxx message
 *					packs the player or groupdata into the message, and sends it out
 *
 *  RETURNS:  result from sendsystemmessage, senddpmessage, or E_OUTOFMEMORY.
 *
 */
HRESULT SendCreateMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
    LPWSTR lpszSessionPassword)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize, dwPasswordLen=0, dwNoTickCountMessageSize;
	BOOL fPropagate;
	PUINT pTickCount;
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// If this is a lobby-owned object, we are never going to send a create
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

	// if the player we're creating is local, we need to propagate the announcement,
	// i.e. tell the world...
	fPropagate =  (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE:FALSE;
    
	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,fPlayer);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

    DPF(2,"sending new player announcment id = %d fPropagate = %d",msg.dwPlayerID,fPropagate);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    // add password size to message size
    if (lpszSessionPassword)
    {
        dwPasswordLen = WSTRLEN_BYTES(lpszSessionPassword);
        dwMessageSize += dwPasswordLen + sizeof(UINT)/* for TickCount */;
        dwNoTickCountMessageSize = dwMessageSize - sizeof(UINT);
    } else {
		// add extra space to use for TickCount if necessary.  Tickcount is sent in join
		// on the latest versions so we don't join a different session than we enumerated.
		dwNoTickCountMessageSize=dwMessageSize;
		dwMessageSize+=sizeof(UINT)+2; // 2 for NULL password
	}	

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CREATEPLAYER);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CREATEGROUP);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),fPlayer);

	// are we sending the create player announcement for our sysplayer?
	if (fPropagate && (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		this->pSysPlayer && !(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
	{
		LPMSG_SYSMESSAGE pmsg = (LPMSG_SYSMESSAGE)(pSendBuffer + this->dwSPHeaderSize);

        // if nameserver is dx5 or greater, it will require a password in the addforward
        // message. Fill in the password regardless of the nameserver's version, 'cause dx3
        // won't even look at it.
        if (lpszSessionPassword && dwPasswordLen > 2)
        {
            memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 
                lpszSessionPassword, dwPasswordLen);
            ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
            pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + dwPasswordLen);
        } else {
        	// Set NULL password so we can put tick count past it.
            memset(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 0, 2);
            ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
            pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + 2);
        }

		if(this->lpsdDesc){
			// put tickcount at end of message to allow verification of session
			*pTickCount=(DWORD)this->lpsdDesc->dwReserved1;
		}	

        // if nameserver is dx5 or greater, it will respond with the nametable
        // GetNameTable() in iplay.c will block for the nametable download

	    // this flag indicates that any messages received before we get the whole
	    // nametable should be q'ed up.  Flag is reset in pending.c.
	    if (this->pSysPlayer)
	    {
		    // ok.  we've got a sysplayer, so we must be joining game for real.
		    // put us in pending mode, so we don't miss any nametable changes
		    // while we're waiting for the nametable to arrive
		    this->dwFlags |= DPLAYI_DPLAY_PENDING;
	    }

		if(!CLIENT_SERVER(this)){
			SetupForReply(this, DPSP_MSG_SUPERENUMPLAYERSREPLY);
		} else {
			SetupForReply(this, DPSP_MSG_ENUMPLAYERSREPLY);
		}	

		//
		// tell the namesrvr to forward this message...
		// this is to get us into the global nametable - even though we
		// haven't downloaded it yet.  this allows the nametable pending
		// stuff to work, and ensures our name table is kept in sync.
		//
		SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ADDFORWARDREQUEST);
		hr = SendDPMessage(this,pPlayer,NULL,pSendBuffer,dwMessageSize,DPSEND_GUARANTEE,FALSE);
		if(FAILED(hr)){
			UnSetupForReply(this);
		}
	}
	else 
	{
		DWORD dwExtraFlags;
    	// Set NULL password so we can put tick count past it.
//        memset(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 0, 2);
//        ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
//        pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + 2);
//
//		if(this->lpsdDesc){
			// put tickcount at end of message to allow verification of session
//			*pTickCount=this->lpsdDesc->dwReserved1;
//		}	

		if(this->lpsdDesc && (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER|DPSESSION_SECURESERVER)){
			dwExtraFlags=0;
		} else {
			dwExtraFlags=DPSEND_SYSMESS;
		}
		
		// it's just a regular system message
		hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,DPSEND_GUARANTEE|dwExtraFlags,TRUE);

		if(dwExtraFlags){
			//BUGBUG: reduce chance of losing first reliable messages due to race
			// between async creation and sending of first message.
			Sleep(100);
		}
	}
	DPMEM_FREE(pSendBuffer);
    
    // done
    return hr;
} // SendCreateMessage 

#undef DPF_MODNAME
#define DPF_MODNAME "SendPlayerMessage"

//
// repackage the pSendBuffer to have a player wrapper
// called in case someone tries to send a message that has our token
// as the first dword.
HRESULT WrapPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pSendBuffer,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock)
{
	HRESULT hr;
	LPMSG_SYSMESSAGE psm;
	LPBYTE pWrapBuffer;
	DWORD dwWrapSize;
	
	// get rid of the header sendplayermessage put on it...
	dwMessageSize -= this->dwSPHeaderSize;
	pSendBuffer += this->dwSPHeaderSize;
	
	dwWrapSize = dwMessageSize +  GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
	
	// alloc a new message buffer, wrap it w/ our header and send it out
	pWrapBuffer = DPMEM_ALLOC(dwWrapSize);
	if (!pWrapBuffer)
	{
		DPF_ERR("could not send player-player message OUT OF MEMORY");
		return E_OUTOFMEMORY;
	}

	psm = (LPMSG_SYSMESSAGE)(pWrapBuffer + this->dwSPHeaderSize);
	
	SET_MESSAGE_HDR(psm);
	SET_MESSAGE_COMMAND(psm,DPSP_MSG_PLAYERWRAPPER);

	// set up the buffer,
	memcpy(pWrapBuffer + this->dwSPHeaderSize + sizeof(MSG_SYSMESSAGE),pSendBuffer,
		dwMessageSize);
		
	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pWrapBuffer,dwWrapSize,
		dwFlags, bDropLock);		
		
	DPMEM_FREE(pWrapBuffer);
	
	return hr;
} // WrapPlayerMessage


// alloc space for a player - player message.
// called by SendPlayerMessage and SendGroupMessage
HRESULT SetupPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp)
{
	LPMSG_PLAYERMESSAGE psm;
	BOOL bPutMessageIDs = TRUE;
	
	
	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		return DP_OK;
	}

	psm = GetPlayerMessageHeader();

    if (NULL == psm) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	// not naked - put to + from on 
	psm->idFrom = psp->pPlayerFrom->dwID;
	if(psp->pPlayerTo){
		psm->idTo = psp->pPlayerTo->dwID;
	} else {
		ASSERT(psp->pGroupTo);
		psm->idTo = psp->pGroupTo->dwID;
	}

	InsertSendBufferAtFront(psp,psm,sizeof(MSG_PLAYERMESSAGE),PlayerMessageFreeFn,PlayerMessageFreeContext);

	return DP_OK;
		
	
} // SetupPlayerMessage

HRESULT	ReplacePlayerHeader(LPDPLAYI_DPLAY this,LPSENDPARMS psp)
{
	LPMSG_PLAYERMESSAGE psm;
	PGROUPHEADER pGroupHeader;
	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		return DP_OK;
	}

	psm = GetPlayerMessageHeader();

    if (NULL == psm) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	// not naked - put to + from on 
	psm->idFrom = psp->pPlayerFrom->dwID;
	ASSERT(psp->pGroupTo);
	psm->idTo = psp->pGroupTo->dwID;

	// link the old header on list to be freed when send is done.
	pGroupHeader=(PGROUPHEADER)psp->Buffers[0].pData;
	pGroupHeader->pNext=psp->pGroupHeaders;
	psp->pGroupHeaders=pGroupHeader;

	psp->Buffers[0].pData=(PUCHAR)psm;
	ASSERT(psp->Buffers[0].len==sizeof(MSG_PLAYERMESSAGE));
	return DP_OK;
}

// alloc space for a player - player message.
// called by SendPlayerMessage and SendGroupMessage
HRESULT SetupPlayerMessage(LPDPLAYI_DPLAY this,LPBYTE * ppSendBuffer,DWORD * pdwMessageSize,
	LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo,LPVOID pvBuffer,DWORD dwBufSize)
{
	LPMSG_PLAYERMESSAGE psm;
	BOOL bPutMessageIDs = TRUE;
	
	ASSERT(pdwMessageSize);
	ASSERT(ppSendBuffer);

	*pdwMessageSize = dwBufSize + GET_MESSAGE_SIZE(this,MSG_PLAYERMESSAGE);

	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		*pdwMessageSize -= sizeof(MSG_PLAYERMESSAGE);
		bPutMessageIDs = FALSE;
	}
	
	*ppSendBuffer = DPMEM_ALLOC(*pdwMessageSize);
    if (NULL == *ppSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	if (bPutMessageIDs)
	{
		psm = (	LPMSG_PLAYERMESSAGE ) (*ppSendBuffer +  this->dwSPHeaderSize);
		// not naked - put to + from on 
		psm->idFrom = pPlayerFrom->dwID;
		psm->idTo = pPlayerTo->dwID;

		// copy player message into send buffer
		memcpy(*ppSendBuffer + this->dwSPHeaderSize + sizeof(MSG_PLAYERMESSAGE),(LPBYTE)pvBuffer,dwBufSize);
	}
	else
	{
		// naked!
		// copy just player message into send buffer
		memcpy(*ppSendBuffer + this->dwSPHeaderSize,(LPBYTE)pvBuffer,dwBufSize);
	}
	
	return DP_OK;
		
	
} // SetupPlayerMessage

// send a player to player message. called by idirectplay?::send
HRESULT SendPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize)
{
	HRESULT hr=DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer=NULL;
	HRESULT hrSend=DP_OK; // the hresult we actually return
	BOOL bDropLock = FALSE; // should we drop the lock across send?

	hr = SetupPlayerMessage( this,&pSendBuffer,&dwMessageSize,pPlayerFrom,pPlayerTo,
		pvBuffer,dwBufSize);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	DPF(9,"flags = %d sending player-player message, total size = %d,msg size = %d\n",dwFlags,dwMessageSize,dwBufSize);
	
	// if session is secure, route message through the nameserver
	if (SECURE_SERVER(this) && !IAM_NAMESERVER(this) && 
		!(pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
	{
		DPF(6,"Routing player message through nameserver");
		pPlayerTo = this->pNameServer;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if (dwFlags & DPSEND_GUARANTEE)
	{
		// note - we could already be in pending mode (executing pending commands on the server)
		DPF(6," guaranteed send - entering pending mode");
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop it
	}

	// make sure we don't send dplay's msg_hdr as the first dword in the message
	if ((dwMessageSize >= sizeof(DWORD)) && 
		(*(DWORD *)(pSendBuffer + this->dwSPHeaderSize) == MSG_HDR))
	{
	 	DPF(1,"app sending dplays command token - repackaging");
		hrSend = WrapPlayerMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,
			dwMessageSize,dwFlags,bDropLock);
	}
	else 
	{
		hrSend = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,dwMessageSize,
			dwFlags,bDropLock);		
	}	
	if (FAILED(hrSend) && (hrSend != DPERR_PENDING))	
	{
		DPF(0,"send message failed hr = 0x%08lx\n",hrSend);
	}

	// if we dropped the lock above make sure to take it again

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	DPMEM_FREE(pSendBuffer);
	return hrSend;

} // SendPlayerMessage	

MSG_SYSMESSAGE COMMAND_WRAPPER={MSG_HDR,DPSP_MSG_PLAYERWRAPPER};

// send a player to player message. called by idirectplay?::send
HRESULT SendPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp)
{
	HRESULT hr=DP_OK;
	HRESULT hrSend=DP_OK; // the hresult we actually return
	BOOL bDropLock = FALSE; // did we drop the lock ?

	hr = SetupPlayerMessageEx(this, psp);
	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	DPF(9,"flags = %d sending player-player message, total size = %d,msg size = %d\n",psp->dwFlags,psp->dwTotalSize,psp->dwDataSize);
	
	// if session is secure, route message through the nameserver
	if (SECURE_SERVER(this) && !IAM_NAMESERVER(this) && 
		!(psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
	{
		DPF(6,"Routing player message through nameserver");
		psp->pPlayerTo = this->pNameServer;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation --BUGBUG:PERF
	if (psp->dwFlags & DPSEND_GUARANTEE)
	{
		// note - we could already be in pending mode (executing pending commands on the server)
		DPF(6," guaranteed send - entering pending mode");
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop lock across send call.
	}

	// make sure we don't send dplay's msg_hdr as the first dword in the message
	if ((psp->Buffers[0].len >= sizeof(DWORD)) && 
		(*(DWORD *)(psp->Buffers[0].pData) == MSG_HDR))
	{
	 	DPF(1,"app sending dplays command token - tacking on wrapping");
	 	InsertSendBufferAtFront(psp,&COMMAND_WRAPPER,sizeof(COMMAND_WRAPPER),NULL,NULL);
	}

	// Directed send usually requires one send to the application, so allocate one
	// context in the context list to begin with.
	InitContextList(this,psp,1);
	
	hrSend = SendDPMessageEx(this,psp,bDropLock);		
	
	if (FAILED(hrSend) && hrSend != DPERR_PENDING)	
	{
		DPF(0,"send message failed hr = 0x%08lx\n",hrSend);
	}

	// if we dropped the lock above make sure to take it again

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	return hrSend;

} // SendPlayerMessageEx


#undef DPF_MODNAME
#define DPF_MODNAME "SendGroupMessage"

// call the SP's send to group function
// called by SendGroupMessage
HRESULT SendSPGroupMessage(LPDPLAYI_DPLAY this,DPID idPlayerFrom,DPID idGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize)
{
	DPSP_SENDTOGROUPDATA sd;
	HRESULT hr;

	sd.dwFlags = dwFlags;
	sd.idGroupTo = idGroupTo;
	sd.idPlayerFrom = idPlayerFrom;
	sd.lpMessage = pvBuffer;
	sd.dwMessageSize = dwBufSize;
	sd.lpISP = this->pISP;

    hr = CALLSP(this->pcbSPCallbacks->SendToGroup,&sd);
    
    if (FAILED(hr))
    {
    	DPF(0,"send to group failed! hr = 0x%08lx\n",hr);
    }
    
    return hr;
    
} // SendSPGroupMessage

#undef DPF_MODNAME

#define DPF_MODNAME "SendGroupMessageEx"
HRESULT SendSPGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{
	DWORD dwSPMsgID;
	DPSP_SENDTOGROUPEXDATA sed;
	HRESULT hr;

	hr=InitContextList(this,psp,1);

	if(FAILED(hr)){
		return hr;
	}

	sed.lpISP          = this->pISP;
	sed.dwFlags        = psp->dwFlags;
	sed.idGroupTo      = psp->idTo;
	sed.idPlayerFrom   = psp->idFrom;
	sed.lpSendBuffers  = &psp->Buffers[0];
	sed.cBuffers       = psp->cBuffers;
	sed.dwMessageSize  = psp->dwTotalSize;
	sed.dwPriority     = psp->dwPriority;
	sed.dwTimeout      = psp->dwTimeout;
	sed.lpDPContext    = psp->hContext;
	sed.lpdwSPMsgID    = &dwSPMsgID;

	pspAddRef(psp);

    hr = CALLSP(this->pcbSPCallbacks->SendToGroupEx,&sed);

	if(hr==DPERR_PENDING){
		AddContext(this,psp,(LPVOID)dwSPMsgID);
	} else {
		pspDecRef(this, psp);
	}
	return hr;
}
#undef DPF_MODNAME

#define DPF_MODNAME "AskServerToMulticast"
// ask the name server to send our group message for us
HRESULT AskServerToMulticast(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage)
{
	LPMSG_ASK4MULTICAST pmsg;
	DWORD dwTotalSize; // pvBuffer + pmsg
	LPBYTE pSendBuffer; // buffer we're going to send out
	HRESULT hr;
	BOOL bDropLock=FALSE; // drop the lock ?
		
	DPF(4,"routing group send via multicast server");

	if (!fPlayerMessage)	
	{
		// don't ship the header on our embedded system message
		ASSERT(dwBufSize > this->dwSPHeaderSize); // better have a header on it! 
		dwBufSize -= this->dwSPHeaderSize;
		pvBuffer = (LPBYTE)pvBuffer + this->dwSPHeaderSize; // point to the system message

		if (SECURE_SERVER(this))
		{
			// we are making the system message secure here because the hook cannot distinguish 
			// between a player and a system message when multicasted. A secure player message 
			// will have this flag set.
			dwFlags |= DPSEND_SIGNED;
		}
	}
	
	dwTotalSize = dwBufSize + GET_MESSAGE_SIZE(this,MSG_ASK4MULTICAST);
	
	pSendBuffer = DPMEM_ALLOC(dwTotalSize);
	if (!pSendBuffer)
	{
		DPF_ERR("could not send group message - out of memory");
		return DPERR_OUTOFMEMORY;
		
	}

	pmsg = (LPMSG_ASK4MULTICAST)(pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);

	if (dwFlags & DPSEND_GUARANTEED)
	{
	    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ASK4MULTICASTGUARANTEED);		
	}
	else 
	{
	    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ASK4MULTICAST);
	}

	// set up the fixed data
	pmsg->idGroupTo = pGroupTo->dwID;
	pmsg->idPlayerFrom = pPlayerFrom->dwID;
	pmsg->dwMessageOffset = sizeof(MSG_ASK4MULTICAST);
	
	// stick the message on the end
	memcpy((LPBYTE)pmsg+sizeof(MSG_ASK4MULTICAST),pvBuffer,dwBufSize);

	// if it's a guaranteed send of a player message, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if (fPlayerMessage && (dwFlags & DPSEND_GUARANTEED))
	{
		DPF(6,"guaranteed player message being multicasted - entering pending mode");
		ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop the lock across send.
	}
	
	// send it to the nameserver
   	hr = SendDPMessage(this,pPlayerFrom,this->pNameServer,(LPBYTE)pSendBuffer,dwTotalSize,dwFlags,bDropLock);			

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	DPMEM_FREE(pSendBuffer);
	
	return hr;	

} // AskServerToMulticast

#define MAX_FAST_TO_IDS 128

// send a player or system message to a group.  called by idirectplay::send, SendSystemMessage and SendUpdateMessage
HRESULT SendGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage)
{
	LPDPLAYI_PLAYER	pPlayer;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodeWalker;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	HRESULT hr=DP_OK;
	BOOL bAlloc = FALSE; // did we alloc the send buffer?
	BOOL bDX3SetPlayerTo = FALSE; // there's a dx3 player in the game
	BOOL bDropLock = FALSE; // did we drop the lock?

	DPID FromID;
	DPID ToID;

	UINT iToIDs;
	UINT cToIDs;
	DWORD (*pdwToIDs)[];
	DWORD rgdwToIDs[MAX_FAST_TO_IDS];
								  
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);

	// if there's a multicast server, and dplay owns this group (not optimized), and we're
	// not the server, we want the server to distribut this bad boy for us
	if ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) &&
		(pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		!(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		// send it to the multicast server
		hr = AskServerToMulticast(this,pPlayerFrom,pGroupTo,dwFlags,pvBuffer,
			dwBufSize,fPlayerMessage);
		return hr;
	}

	if (fPlayerMessage)
	{
		hr = SetupPlayerMessage( this,&pSendBuffer,&dwMessageSize,pPlayerFrom,(LPDPLAYI_PLAYER)pGroupTo,
			pvBuffer,dwBufSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}
		bAlloc = TRUE;
	}
	else 
	{
		pSendBuffer = pvBuffer;
		dwMessageSize = dwBufSize;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if ((dwFlags & DPSEND_GUARANTEE) && fPlayerMessage)
	{
		DPF(6," guaranteed send to group - entering pending mode");
		// note - we could already be in pending mode (executing pending commands on the server)
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount);	// we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;		// we dropped it
	}

	// optimize the send only if the sp owns the group and there's no dx3 clients (optimized
	// sends won't work w/ dx3 clients)
	if (!(pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		(this->pcbSPCallbacks->SendToGroup) && 
		!(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) &&
		!(this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) &&
		!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
	{
		FromID = pPlayerFrom->dwID;
		ToID   = pGroupTo->dwID;
		if(bDropLock){
			LEAVE_DPLAY();
		}
		// group is owned by sp,  let them do the send
		hr = SendSPGroupMessage(this,FromID,ToID,dwFlags,pSendBuffer,dwMessageSize);
		
		if(bDropLock){
			ENTER_DPLAY();
		}
		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	} // SendToGroup
	else
	{
		// otherwise, this dplay has to do the send.  In DX3, we sent one packet out to
		// each player. lpGroupnode is the list of players in the group

		// in client/server, the server may create groups containing a client that the
		// client does not know about. So, you can't send to the group on the client, you
		// have to send to each player on the client individually.

		if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||			// do it the DX3 way
			(IAM_NAMESERVER(this) && CLIENT_SERVER(this)))		// send to client individually
		{
			// have to send to each individual player
			if (fPlayerMessage) lpGroupnode = pGroupTo->pGroupnodes;
			// send it to the system players
			else lpGroupnode = pGroupTo->pSysPlayerGroupnodes;			
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (! (this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ) bDX3SetPlayerTo = TRUE;
		}
		else 
		{
			// if it's dx5 or better, send to sysplayer - let them distribute
			lpGroupnode = pGroupTo->pSysPlayerGroupnodes;			
		}

		
		iToIDs = 0;

//		a-josbor:  I'm not sure what this 'fix' is trying to say.  The pGroupTo->nPlayers is a count of all the 
//			regular (non-sys) players in the group.  This is different from the number of system players
//			that proxy all those players.  The count of the system players is really the only thing
//			interesting in post-DX3 games.  However, the code DOES do the right thing (count and send)
//			to only the system players.

			//cToIDs = pGroupTo->nPlayers+1; // sometimes we see a sysgroup with count not set so +1
			// workaround, sometimes count not right...
			lpGroupnodeWalker=lpGroupnode;

			cToIDs=0;
			while(lpGroupnodeWalker){
			   cToIDs++;     
			   lpGroupnodeWalker = lpGroupnodeWalker->pNextGroupnode; 
			}
			if(pGroupTo->nPlayers+1 < cToIDs){
				DPF(0,"WARNING: Group player count bad! (%d < %d) good thing we are working around...\n", pGroupTo->nPlayers+1, cToIDs);
			}
			// end workaround
		
		if(cToIDs > MAX_FAST_TO_IDS){
			// need to allocate a block of memory for the ToID list
			pdwToIDs = DPMEM_ALLOC(cToIDs*sizeof(DWORD));
		} else {
			// use the block of memory from the stack.
			pdwToIDs = (DWORD (*)[])&rgdwToIDs;
		}

		iToIDs=0;

		// copy the to ids in the group into an array.
		while (lpGroupnode)
		{
			pPlayer = lpGroupnode->pPlayer;
			(*pdwToIDs)[iToIDs++]=pPlayer->dwID;
			ASSERT(iToIDs <= cToIDs);
			lpGroupnode = lpGroupnode->pNextGroupnode; 
		}	

		cToIDs=iToIDs; // actual number filled in.

		for(iToIDs=0; iToIDs < cToIDs ; iToIDs++){
		
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (fPlayerMessage)
			{
				LPMSG_PLAYERMESSAGE pmsg = (LPMSG_PLAYERMESSAGE)(pSendBuffer +  this->dwSPHeaderSize);

				if(bDX3SetPlayerTo) {
					pmsg->idTo = (*pdwToIDs)[iToIDs];
				} 
			}
			else // it's a system message
			{
				LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer +  this->dwSPHeaderSize);

				// If it's a chat message, we don't want to mess with the To player ID
				if(GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_CHAT){
					if(bDX3SetPlayerTo) {
						pmsg->dwIDTo = (*pdwToIDs)[iToIDs];
					} 
					else 
					{
//						a-josbor: it's a system message, so just set the to field to 0
//							to avoid garbage on the wire.  The message will be distributed
//							to the system group on all receipient machines.
						pmsg->dwIDTo = 0;
					}	
				}
			}

			pPlayer=PlayerFromID(this, (*pdwToIDs)[iToIDs]);

			if(pPlayer){

			   	hr = SendDPMessage(this,pPlayerFrom,pPlayer,pSendBuffer,dwMessageSize,dwFlags,bDropLock);		
				if (FAILED(hr)) 
				{
					DPF(0,"SendGroup : send message failed hr = 0x%08lx\n",hr);	
					// keep trying...
				}
			}	
			
		} /* for */
		
		if(pdwToIDs != (DWORD (*)[])&rgdwToIDs){
			DPMEM_FREE(pdwToIDs);
		}

	}

	// clean up pending mode
	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	if (bAlloc) DPMEM_FREE(pSendBuffer);

	return DP_OK;
	
} // SendGroupMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendGroupMessageEx"

// send a player or system message to a group.  called by idirectplay::send, SendSystemMessage and SendUpdateMessage
HRESULT SendGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp, BOOL fPlayerMessage)
{
	LPDPLAYI_PLAYER pPlayer;
    LPDPLAYI_GROUPNODE lpGroupnode;
	LPBYTE pSendBuffer=NULL;
	HRESULT hr=DP_OK,hr2;
	BOOL bDX3SetPlayerTo = FALSE; // there's a dx3 player in the game
	BOOL bDropLock = FALSE; // Are we dropping the lock across sends?
	BOOL bReturnPending = FALSE;

	DPID FromID;
	DPID ToID;

	UINT  iToIDs;
	UINT  cToIDs;
	DWORD (*pdwToIDs)[];
	DWORD rgdwToIDs[MAX_FAST_TO_IDS];
								  
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);

	// if there's a multicast server, and dplay owns this group (not optimized), and we're
	// not the server, we want the server to distribut this bad boy for us
	if ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) &&
		(psp->pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		!(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		pSendBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
		if(!pSendBuffer){
			return DPERR_NOMEMORY;
		}
		// send it to the multicast server
		hr = AskServerToMulticast(this,
								  psp->pPlayerFrom,
								  psp->pGroupTo,
								  psp->dwFlags & ~DPSEND_NOCOPY,
								  pSendBuffer,
								  psp->dwTotalSize+this->dwSPHeaderSize,
								  fPlayerMessage);

		goto EXIT;
	}

	if (fPlayerMessage)
	{
		hr = SetupPlayerMessageEx(this,psp);
		if(FAILED(hr)){
			goto EXIT;
		}
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if ((psp->dwFlags & DPSEND_GUARANTEE) && fPlayerMessage)
	{
		DPF(6," guaranteed send to group - entering pending mode");
		// note - we could already be in pending mode (executing pending commands on the server)
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount);	// we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;		// drop lock across send calls.
	}

	// optimize the send only if the sp owns the group and there's no dx3 clients (optimized
	// sends won't work w/ dx3 clients)
	if (!(psp->pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		(this->pcbSPCallbacks->SendToGroup) && !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
	{
		FromID = psp->pPlayerFrom->dwID;
		ToID   = psp->pGroupTo->dwID;
		
		if(bDropLock){
			LEAVE_DPLAY();
		}
		
		// group is owned by sp,  let them do the send
		if(this->pcbSPCallbacks->SendToGroupEx){
			hr=SendSPGroupMessageEx(this,psp);
		} else {
			pSendBuffer=ConcatenateSendBuffer(this,&psp->Buffers[0],psp->cBuffers,psp->dwTotalSize);
			if(!pSendBuffer){
				goto EXIT;
			}
			hr = SendSPGroupMessage(this,
									FromID,
									ToID,
									psp->dwFlags,
									pSendBuffer,
									psp->dwTotalSize+this->dwSPHeaderSize);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}	

		if(bDropLock){
			ENTER_DPLAY();
		}
	} // SendToGroup
	else
	{
		// otherwise, this dplay has to do the send.  In DX3, we sent one packet out to
		// each player. lpGroupnode is the list of players in the group

		// in client/server, the server may create groups containing a client that the
		// client does not know about. So, you can't send to the group on the client, you
		// have to send to each player on the client individually.

		if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||			// do it the DX3 way
			(IAM_NAMESERVER(this) && CLIENT_SERVER(this)))		// send to client individually
		{
			// have to send to each individual player
			if (fPlayerMessage) lpGroupnode = psp->pGroupTo->pGroupnodes;
			// send it to the system players
			else lpGroupnode = psp->pGroupTo->pSysPlayerGroupnodes;			
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (! (this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ) bDX3SetPlayerTo = TRUE;
		}
		else 
		{
			// if it's dx5 or better, send to sysplayer - let them distribute
			lpGroupnode = psp->pGroupTo->pSysPlayerGroupnodes;			
		}


		// AO - Fixing a bug, can't run grouplist without a lock!  so we will copy the id's
		//      into a list.  The maximum size of the list is pGroupTo->nPlayers, so we alloc
		//      a buffer of this size.  If there are less than 128 entries, we get the memory
		//      from the stack, if not, we get the memory from the heap.

		iToIDs = 0;
		cToIDs = psp->pGroupTo->nPlayers+1;
		
		if(cToIDs > MAX_FAST_TO_IDS){
			// need to allocate a block of memory for the ToID list
			pdwToIDs = DPMEM_ALLOC(cToIDs*sizeof(DWORD));
		} else {
			// use the block of memory from the stack.
			pdwToIDs = (DWORD (*)[])&rgdwToIDs;
		}

		// copy the to ids in the group into an array.
		while (lpGroupnode)
		{
			pPlayer = lpGroupnode->pPlayer;
			(*pdwToIDs)[iToIDs++]=pPlayer->dwID;
			ASSERT(iToIDs <= cToIDs);
			lpGroupnode = lpGroupnode->pNextGroupnode; 
		}	

		cToIDs=iToIDs; // actual number filled in.

		if(!cToIDs){
			goto EXIT2;
		}

		// Now we know how big the list will be, we can allocate a context list.
		hr=InitContextList(this,psp,cToIDs);
		if(FAILED(hr)){
			goto EXIT2;
		}
		
		for(iToIDs=0; iToIDs < cToIDs ; iToIDs++){

			if(fPlayerMessage && (iToIDs > 0) && 
			  ((psp->dwFlags & (DPSEND_ASYNC|DPSEND_NOCOPY)) == (DPSEND_ASYNC|DPSEND_NOCOPY))){
				// Need to swap out header so its unique during the call if
				// we are sending async AND we don't want to copy the buffers
				hr=ReplacePlayerHeader(this,psp);
				if(hr!=DP_OK){
					bReturnPending=FALSE;
					DPF(0,"Ran out of memory building unique header for group send\n");
					break;
				}
			}
		
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (fPlayerMessage)
			{
				LPMSG_PLAYERMESSAGE pmsg = (LPMSG_PLAYERMESSAGE)(psp->Buffers[0].pData);

				if(bDX3SetPlayerTo) {
					pmsg->idTo = (*pdwToIDs)[iToIDs];
				} else {
					pmsg->idTo = 0;
				}	
			}
			else // it's a system message
			{
				LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)(psp->Buffers[0].pData);

				if(bDX3SetPlayerTo) {
					pmsg->dwIDTo = (*pdwToIDs)[iToIDs];
				} else {
					pmsg->dwIDTo = 0;
				}	
			}

			psp->pPlayerTo=PlayerFromID(this, (*pdwToIDs)[iToIDs]);

			if(psp->pPlayerTo){

		   		hr = SendDPMessageEx(this,psp,bDropLock);	// handles adding refs.

				if(hr==DPERR_PENDING){
					bReturnPending=TRUE;				
				} else if(FAILED(hr)) {
					if(hr==DPERR_NOMEMORY){
						bReturnPending=FALSE;
					}
					DPF(0,"SendGroup : send message failed hr = 0x%08lx\n",hr);	
					// keep trying...
				}
			}	
			
		} /* for */
EXIT2:		
		if(pdwToIDs != (DWORD (*)[])&rgdwToIDs){
			DPMEM_FREE(pdwToIDs);
		}

	}

EXIT:

	if(pSendBuffer){
		MsgFree(NULL,pSendBuffer);
	}

	// clean up pending mode
	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		// flush any commands that came in while our send was going on
		hr2 = ExecutePendingCommands(this);
		if (FAILED(hr2))
		{
			ASSERT(FALSE);
		}
	}

	if(bReturnPending){
		return DPERR_PENDING;
	} else {	
		return hr;
	}	

} // SendGroupMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendPlayerManagementMessage"

// called by InternalAddPlayerToGroup , InternalDeletePlayerFromGroup, InternalDestroyGroup, InternalDestroyPlayer
// addplayer/addgroup use sendaddmessage
HRESULT SendPlayerManagementMessage(LPDPLAYI_DPLAY this,DWORD dwCmd,DPID idPlayer,
	DPID idGroup)
{
	DWORD dwMessageSize;
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	HRESULT hr;
	LPBYTE pBuffer;
	DWORD dwExtraFlags=0;
//	BOOL bWait=FALSE;

	if(dwCmd & DPSP_MSG_ASYNC){
		dwCmd &= ~DPSP_MSG_ASYNC;
		dwExtraFlags=DPSEND_SYSMESS;
	}


	// alloc + set up message
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE);

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)((LPBYTE)pBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);
	SET_MESSAGE_COMMAND(pmsg,dwCmd);

	// fill in message specific info
	switch (dwCmd)
	{
		case DPSP_MSG_DELETEPLAYER:
			pmsg->dwPlayerID = idPlayer;
			
			if(this->pSysPlayer && idPlayer==this->pSysPlayer->dwID){
				//dwExtraFlags = 0; // by init
			} else {
//				bWait=TRUE;
				dwExtraFlags = DPSEND_SYSMESS;
			}
			break;
			

		case DPSP_MSG_DELETEGROUP:
			pmsg->dwGroupID = idGroup;
			break;

		case DPSP_MSG_ADDSHORTCUTTOGROUP:
		case DPSP_MSG_DELETEGROUPFROMGROUP:
		case DPSP_MSG_ADDPLAYERTOGROUP:
		case DPSP_MSG_DELETEPLAYERFROMGROUP:  
			pmsg->dwPlayerID = idPlayer;
			pmsg->dwGroupID = idGroup;
			break;
			
		default:
			ASSERT(FALSE);
			break;			
	}	

	hr = SendSystemMessage(this,pBuffer,dwMessageSize,DPSEND_GUARANTEE|dwExtraFlags,TRUE);

	DPMEM_FREE(pBuffer);

//	if(bWait){
//		Sleep(250);
//	}

	return hr;

} // SendPlayerManagementMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendDataChanged"

// the player blob has changed. tell the world.
HRESULT SendDataChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags)
{
	MSG_PLAYERDATA msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERDATA) + pPlayer->dwPlayerDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);

    if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_PLAYERDATACHANGED);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_GROUPDATACHANGED);
	
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwDataSize = pPlayer->dwPlayerDataSize;
	msg.dwDataOffset = sizeof(msg);
	
	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));
	// copy the new player data into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),pPlayer->pvPlayerData,
		pPlayer->dwPlayerDataSize);

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize, dwFlags|DPSEND_ASYNC,TRUE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendDataChanged

#undef DPF_MODNAME
#define DPF_MODNAME "SendNameChanged"

// the players name has changed. tell the world.
HRESULT SendNameChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags)
{
	MSG_PLAYERNAME msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;
	UINT nShortLength,nLongLength; // name length, in bytes

	nShortLength = WSTRLEN_BYTES(pPlayer->lpszShortName);
	nLongLength =  WSTRLEN_BYTES(pPlayer->lpszLongName);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERNAME) + nShortLength + nLongLength; 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);

    if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_PLAYERNAMECHANGED);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_GROUPNAMECHANGED);

	msg.dwPlayerID = pPlayer->dwID;

	// copy the short name into the buffer
	if (nShortLength)
	{
		// copy the short name into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),pPlayer->lpszShortName,
			nShortLength);
		msg.dwShortOffset = sizeof(msg);
	}
	else 
	{
		msg.dwShortOffset = 0;
	}
	// copy the long name into the send buffer	
	if (nLongLength)
	{
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + nShortLength,
			pPlayer->lpszLongName,nLongLength);
		msg.dwLongOffset = sizeof(msg) + nShortLength;
	}
	else 
	{
		msg.dwLongOffset = 0;
	}
	
	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,dwFlags|DPSEND_ASYNC,TRUE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendNameChanged

#undef DPF_MODNAME
#define DPF_MODNAME "SendIAmNameServer"

// this idirectplay has become the nameserver.  tell all remote players.
HRESULT SendIAmNameServer(LPDPLAYI_DPLAY this)
{
	LPBYTE pbuf;
	LPMSG_IAMNAMESERVER pmsg;
	HRESULT hr;

	pbuf=DPMEM_ALLOC(GET_MESSAGE_SIZE(this,MSG_IAMNAMESERVER)+this->pSysPlayer->dwSPDataSize);

	if(pbuf) {

		pmsg=(LPMSG_IAMNAMESERVER)(pbuf+this->dwSPHeaderSize);

		memset(pmsg,0,sizeof(MSG_IAMNAMESERVER));

	    // build a message to send 
		SET_MESSAGE_HDR(pmsg);
		SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_IAMNAMESERVER);

		ASSERT(this->pSysPlayer);
		ASSERT(this->pSysPlayer->dwID);

		pmsg->dwIDHost = this->pSysPlayer->dwID;
		pmsg->dwFlags = this->pSysPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS|DPLAYI_PLAYER_PLAYERLOCAL);
		pmsg->dwSPDataSize = this->pSysPlayer->dwSPDataSize;
		memcpy((PCHAR)(pmsg+1),this->pSysPlayer->pvSPData, this->pSysPlayer->dwSPDataSize);

		hr = SendSystemMessage(this,pbuf,this->dwSPHeaderSize+sizeof(MSG_IAMNAMESERVER)+this->pSysPlayer->dwSPDataSize,DPSEND_SYSMESS,FALSE);

		DPMEM_FREE(pbuf);

	} else {
		hr=DPERR_OUTOFMEMORY;
	}
	return hr;

} // SendIAmNameServer


#undef DPF_MODNAME
#define DPF_MODNAME "SendMeNameServer"

// this idirectplay has become the nameserver.  tell all local players.
HRESULT SendMeNameServer(LPDPLAYI_DPLAY this)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));

    // build a message to send to our local players
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_NAMESERVER);

	// send it out to our local players 
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	return hr;

} // SendMeNameServer

#undef DPF_MODNAME
#define DPF_MODNAME "SendSessionDescChanged"

// the sessiion desc has changed. tell the world.
HRESULT SendSessionDescChanged(LPDPLAYI_DPLAY this, DWORD dwFlags)
{
	MSG_SESSIONDESC msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;
    UINT nSessionNameLength, nPasswordLength;

    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
    SET_MESSAGE_COMMAND(&msg,DPSP_MSG_SESSIONDESCCHANGED);
    memcpy(&(msg.dpDesc), this->lpsdDesc, sizeof(DPSESSIONDESC2));

    // calculate the size of the send buffer
    nSessionNameLength  = WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
	nPasswordLength     = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);
	// message size + name + password
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SESSIONDESC) 
                    + sizeof(DPSESSIONDESC2) + nSessionNameLength 
                    + nPasswordLength;

    // allocate send buffer
    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not session desc changed message - out of memory");
        return E_OUTOFMEMORY;
    }
		
	// copy the session name into the buffer
	if (nSessionNameLength)
	{
		// copy the session name into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),this->lpsdDesc->lpszSessionName,
			nSessionNameLength);
		msg.dwSessionNameOffset = sizeof(msg);
	}
	else 
	{
		msg.dwSessionNameOffset = 0;
	}

	// copy the password into the send buffer	
	if (nPasswordLength)
	{
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + nSessionNameLength,
			this->lpsdDesc->lpszPassword,nPasswordLength);
		msg.dwPasswordOffset = sizeof(msg) + nSessionNameLength;
	}
	else 
	{
		msg.dwPasswordOffset = 0;
	}

	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,dwFlags|DPSEND_ASYNC,FALSE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendSessionDescChanged


#undef DPF_MODNAME
#define DPF_MODNAME "SendChatMessage"

// Send a chat message (it's in system message format)
HRESULT SendChatMessage(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags, LPDPCHAT lpMsg, BOOL fPlayer)
{
	MSG_CHAT msg;
	LPBYTE pSendBuffer;
	DWORD dwMsgSize;
	HRESULT hr;
	UINT nMsgLength; // message length, in bytes

	nMsgLength = WSTRLEN_BYTES(lpMsg->lpszMessage);

	// message size + blob size
	dwMsgSize = GET_MESSAGE_SIZE(this,MSG_CHAT) + nMsgLength; 

    pSendBuffer = DPMEM_ALLOC(dwMsgSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send chat message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the player (or group)
	SET_MESSAGE_HDR(&msg);

	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CHAT);

	msg.dwIDFrom = pPlayerFrom->dwID;
	msg.dwIDTo = pPlayerTo->dwID;
	msg.dwFlags = lpMsg->dwFlags;

	// copy the short name into the buffer
	if (nMsgLength)
	{
		// copy the message into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),
			lpMsg->lpszMessage,	nMsgLength);
		msg.dwMessageOffset = sizeof(msg);
	}
	else 
	{
		msg.dwMessageOffset = 0;
	}

	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// Send to the appropriate player(s)
	if(fPlayer)
	{
		if(dwFlags & DPSEND_GUARANTEE){
			this->dwFlags |= DPLAYI_DPLAY_PENDING;

		}
		hr = SendDPMessage( this, pPlayerFrom, pPlayerTo, pSendBuffer,
				dwMsgSize, dwFlags|DPSEND_ASYNC, (dwFlags&DPSEND_GUARANTEE)?TRUE:FALSE);

		ExecutePendingCommands(this);
	}
	else 
	{
		// send to group
		hr = SendGroupMessage(this, pPlayerFrom, (LPDPLAYI_GROUP)pPlayerTo,
				dwFlags|DPSEND_ASYNC, pSendBuffer, dwMsgSize, FALSE);
	}
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendChatMessage


// called by SendAsyncAddForward to see if we should send an add forward
// to pPlayer
BOOL IsInAddForwardList(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPADDFORWARDNODE pnode = this->pAddForwardList;
	BOOL bFound = FALSE;
	
	while (pnode && !bFound)
	{
		if (pnode->dwIDSysPlayer == pPlayer->dwID) bFound = TRUE;
		else pnode = pnode->pNextNode;
	}
	
	return bFound;
	
} // IsInAddForwardList

HRESULT SendAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,LPADDFORWARDNODE pnode)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize;
	LPDPLAYI_GROUPNODE lpGroupnode;
	LPDPLAYI_PLAYER pPlayerTo;
		
	ASSERT(IAM_NAMESERVER(this));
	
	// If this is a lobby-owned object, we are never going to send a create
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this)) return DP_OK;

	// no add forward in client server 
	if (CLIENT_SERVER(this)) return DP_OK; 
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,TRUE);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_ADDFORWARD);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),TRUE);

	// now, send it to all system players who are not in the addforwardq
	ASSERT(this->pSysGroup);
	lpGroupnode = this->pSysGroup->pSysPlayerGroupnodes;			
	while (lpGroupnode)
	{
		pPlayerTo = lpGroupnode->pPlayer;
		lpGroupnode = lpGroupnode->pNextGroupnode;
		if (!IsInAddForwardList(this,pPlayerTo) && (pPlayerTo != this->pSysPlayer))
		{
			pnode->nAcksReq++; // we're sending to pPlayerTo, we need an ack from him
			
		   	hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwMessageSize,
				DPSEND_GUARANTEED | DPSEND_ASYNC, FALSE);		
			if (FAILED(hr)) 
			{
				DPF(0,"SendAddForward : send message failed hr = 0x%08lx\n",hr);	
				pnode->nAcksReq--;
				// keep trying...
			}
		}
	}
   
    DPF(2,"sent add forward announcment id = %d - nAcksRequired = %d",msg.dwPlayerID,pnode->nAcksReq); 
	
	DPMEM_FREE(pSendBuffer);
	
    // done
    return DP_OK;

} // SendAsyncAddForward
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\update.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       update.c
*  Content:		support for SetUpdateList method
*  History:
*   Date		By		Reason
*   ====		==		======
*	10/31/96	andyco	created it 
*   6/6/98      aarono  Fix for handling large loopback messages with protocol
*
***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SetUpdateList"


// make sure player has enough room in update list to add a node of size dwUpdateNodeSize
// called by DP_SetUpdateList 
HRESULT MakeUpdateSpace(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerTo,DWORD dwUpdateNodeSize)
{
	LPVOID pvTemp;
	DWORD dwAvailSpace;
	DWORD dwAllocSize;

	// this is how much room is available in the players update list	
	dwAvailSpace = pPlayerTo->dwUpdateListSize - 
		( pPlayerTo->pbUpdateIndex - pPlayerTo->pbUpdateList);
		
	if (!pPlayerTo->pbUpdateList)
	{
		// alloc a new list
		ASSERT( 0 == pPlayerTo->dwUpdateListSize);

		//
		// alloc enough space for 1. the on the wire header, 2. the node we're adding and 
		// 3. a little extra
		//
		dwAllocSize = GET_MESSAGE_SIZE(this,MSG_UPDATELIST) + DPUPDATE_INITIALNODESIZE + dwUpdateNodeSize;

		DPF(7,"alloc'ing update list of size = %d\n",dwAllocSize);

		pPlayerTo->pbUpdateList = DPMEM_ALLOC(dwAllocSize);
		if (!pPlayerTo->pbUpdateList)
		{
			DPF_ERR("MakeUpdateSpace - out of memory - could not alloc node list");
			return E_OUTOFMEMORY;
		}
		
		// start writing into the buffer immediately after the on the wire header
		pPlayerTo->pbUpdateIndex = pPlayerTo->pbUpdateList + GET_MESSAGE_SIZE(this,MSG_UPDATELIST);
	}
	else if (dwAvailSpace >= dwUpdateNodeSize)
	{
		// we have a list and it's big enough. all done.
		return DP_OK;
	}
	else 
	{
		// the list isn't big enough - realloc it
		// alloc enough space for 1. the current buffer, 2. the node we're adding and 
		// 3. a little extra
		//
		dwAllocSize = pPlayerTo->dwUpdateListSize +  dwUpdateNodeSize + DPUPDATE_INITIALNODESIZE;
		DPF(7,"REalloc'ing update list of size = %d\n",dwAllocSize);		
		
		pvTemp = DPMEM_REALLOC(pPlayerTo->pbUpdateList,dwAllocSize);
		if (!pvTemp)
		{
			DPF_ERR("MakeUpdateSpace - out of memory - could not realloc node list");
			return E_OUTOFMEMORY;
		}
		pPlayerTo->pbUpdateList = pvTemp;
		// since realloc may have moved update list, need to reset updateindex
		pPlayerTo->pbUpdateIndex = pPlayerTo->pbUpdateList + pPlayerTo->dwUpdateListSize - dwAvailSpace;
	}
	
	// store the new size
	pPlayerTo->dwUpdateListSize = dwAllocSize;
	
	return DP_OK;		
	
} // MakeUpdateSpace

// put the system message (pvMessage, passed in by the app) into playerTo's update
// list. 
HRESULT UpdateSystemMessage(LPDPLAYI_DPLAY this,DWORD dwUpdateFlags,DPID idFrom,
	LPDPLAYI_PLAYER lpPlayerTo,LPVOID pvMessage,DWORD dwMessageSize)
{
	LPDPMSG_GENERIC pmsg = (LPDPMSG_GENERIC)pvMessage;
	DWORD dwUpdateNodeSize;
	HRESULT hr;
	
	if (dwUpdateFlags &  DPUPDATE_CREATEPLAYER) 
	{
		LPUPDNODE_CREATEPLAYER pup;
		LPDPLAYI_PLAYER lpPlayerCreated;
		
		lpPlayerCreated = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(lpPlayerCreated))
		{
			DPF_ERR("update add player - got bogus player");
			return DPERR_INVALIDPARAMS;
		}
		
		// ACK - todo - pack up other create structs
		dwUpdateNodeSize = sizeof(UPDNODE_CREATEPLAYER); // + ...
		
		// make sure playerto has room in its update list
		hr = MakeUpdateSpace(this,lpPlayerTo,dwUpdateNodeSize);
		if (FAILED(hr))
		{
			DPF_ERR("could not add node to update list - out of memory");
			return E_OUTOFMEMORY;
		}
		pup = (LPUPDNODE_CREATEPLAYER)(lpPlayerTo->pbUpdateIndex);

		pup->dwType = dwUpdateFlags;
		pup->dwID = lpPlayerCreated->dwID;
		pup->dwFlags = lpPlayerCreated->dwFlags;
		pup->dwUpdateSize = sizeof(UPDNODE_CREATEPLAYER);
		// increment our buffer pointer
		lpPlayerTo->pbUpdateIndex += pup->dwUpdateSize;
		lpPlayerTo->nUpdates++;
	}
	if (dwUpdateFlags & DPUPDATE_DESTROYPLAYER)
	{
		LPUPDNODE_DESTROYPLAYER pup;
		
		dwUpdateNodeSize = sizeof(UPDNODE_DESTROYPLAYER);
		// make sure playerto has room in its update list
		hr = MakeUpdateSpace(this,lpPlayerTo,dwUpdateNodeSize);
		if (FAILED(hr))
		{
			DPF_ERR("could not add node to update list - out of memory");
			return E_OUTOFMEMORY;
		}
		pup = (LPUPDNODE_DESTROYPLAYER)(lpPlayerTo->pbUpdateIndex);
		pup->dwType = dwUpdateFlags;
		pup->dwID = idFrom;
		pup->dwUpdateSize = sizeof(UPDNODE_DESTROYPLAYER);
		// increment our buffer pointer
		lpPlayerTo->pbUpdateIndex += pup->dwUpdateSize;
		lpPlayerTo->nUpdates++;
	}

	return DP_OK;	
	
} // UpdateSystemMessage

// add a playermessage to lpPlayerTo's update list
HRESULT UpdatePlayerMessage(LPDPLAYI_DPLAY this,DWORD dwUpdateFlags,DPID idFrom,
	LPDPLAYI_PLAYER lpPlayerTo,LPVOID pvMessage,DWORD dwMessageSize)
{
	LPUPNODE_MESSAGE pup;
	HRESULT hr;
	DWORD dwUpdateNodeSize;
	
	dwUpdateNodeSize = sizeof(UPNODE_MESSAGE) + dwMessageSize;
	
	// make sure playerto has room in its update list
	hr = MakeUpdateSpace(this,lpPlayerTo,dwUpdateNodeSize);
	if (FAILED(hr))
	{
		DPF_ERR("could not add node to update list - out of memory");
		return E_OUTOFMEMORY;
	}
	
	pup = (LPUPNODE_MESSAGE)(lpPlayerTo->pbUpdateIndex);
	pup->dwType = DPUPDATE_MESSAGE;
	pup->idFrom = idFrom;
	pup->dwUpdateSize = sizeof(UPNODE_MESSAGE) + dwMessageSize;
	pup->dwMessageOffset = sizeof(UPNODE_MESSAGE);
	memcpy((LPBYTE)pup + sizeof(UPNODE_MESSAGE),pvMessage,dwMessageSize);
	
	// increment our buffer pointer
	lpPlayerTo->pbUpdateIndex += pup->dwUpdateSize;
	lpPlayerTo->nUpdates++;
	
	return DP_OK;
} // UpdatePlayerMessage

//
// idFrom + idTo can be a group, a player or DPID_ALLPLAYERS
//
HRESULT DPAPI DP_SetUpdateList(LPDIRECTPLAY lpDP,DWORD dwUpdateFlags,DPID idFrom, 
	DPID idTo,LPVOID pvMessage,DWORD dwMessageSize,DWORD dwSendFlags)
{
	LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_PLAYER lpPlayerTo; // may be group or players
								// we'll cast to players since we only need 
								// update data
        
	ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (!this->pServerPlayer)
		{
			LEAVE_DPLAY();
			DPF_ERR("must create server player before sending updates");
			return DPERR_UNAVAILABLE;
		}
		
		// we don't care about idFrom
		// in fact, idFrom may not even be in our nametable (already deleted)
		
		// check idTo
    	// is it a player?
        lpPlayerTo = PlayerFromID(this,idTo);
        if (!VALID_DPLAY_PLAYER(lpPlayerTo)) 
        {
        	// not a player. is it a group?
        	lpPlayerTo = (LPDPLAYI_PLAYER)GroupFromID(this,idTo);
	        if (!VALID_DPLAY_GROUP(lpPlayerTo)) 
	        {
	        	// not player or group - error
	        	LEAVE_DPLAY();
				DPF_ERR("invalid To id");
	            return DPERR_INVALIDPLAYER;
	        }
        } // idTo


        // check pvMessage
        if (!VALID_READ_STRING_PTR(pvMessage,dwMessageSize))
        {
        	LEAVE_DPLAY();
        	DPF_ERR("invalid pvMessage");
        	return DPERR_INVALIDPARAMS;
        }										

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// see what they want updated
    if (dwUpdateFlags & DPUPDATE_MESSAGE)
    {
    	hr = UpdatePlayerMessage(this,dwUpdateFlags,idFrom,lpPlayerTo,pvMessage,dwMessageSize);
    	if (FAILED(hr))
    	{
    		ASSERT(FALSE);
    	}
    }
    if ((dwUpdateFlags & DPUPDATE_CREATEPLAYER) || // todo - other system messages
    	(dwUpdateFlags & DPUPDATE_DESTROYPLAYER))
    {
		if (DPID_ALLPLAYERS == idFrom)
		{
			LPDPLAYI_PLAYER lpPlayerSource = this->pPlayers;
			
			while (lpPlayerSource)
			{
				if (!(lpPlayerSource->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
				{
			    	// put the system message in idTo's update list
			    	hr = UpdateSystemMessage(this,dwUpdateFlags,lpPlayerSource->dwID,lpPlayerTo,pvMessage,dwMessageSize);
			    	if (FAILED(hr)) ASSERT(FALSE);
				}
				lpPlayerSource = lpPlayerSource->pNextPlayer;
			}
		}	// all players
		// TODOTODOTODO handle from a group
		else 
		{
			// from a player
	    	// put the system message in idTo's update list
	    	hr = UpdateSystemMessage(this,dwUpdateFlags,idFrom,lpPlayerTo,pvMessage,dwMessageSize);
	    	if (FAILED(hr)) ASSERT(FALSE);
		}
    }
    if (dwUpdateFlags & DPUPDATE_FLUSH)
    {
    	// is there something to send?
		if ( GET_MESSAGE_SIZE(this,MSG_UPDATELIST) < (DWORD)UPDATE_SIZE(lpPlayerTo))
		{
			DPF(4,"sending update - nMessages = %d, dwSize = %d\n",lpPlayerTo->nUpdates,(DWORD)UPDATE_SIZE(lpPlayerTo));
	    	hr = SendUpdateMessage(this,lpPlayerTo,dwSendFlags);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			lpPlayerTo->nUpdates = 0;
			// reset the pbBufferIndex			
			lpPlayerTo->pbUpdateIndex = lpPlayerTo->pbUpdateList + GET_MESSAGE_SIZE(this,MSG_UPDATELIST);
		}
    }
    else 
    {
    	DPF(5,"not sending update - update list size = %d\n",UPDATE_SIZE(lpPlayerTo));
    }

    LEAVE_DPLAY();
    
	return hr;	

} // DP_SetUpdateList


// called from HandleMessage (handler.c)
// parse the update list, calling back into handler as we go
HRESULT HandleUpdateList(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwTotalMessageSize)
{
	LPMSG_UPDATELIST pmsgUpdate;
	LPBYTE pbBufferIndex,pbBufferEnd;
	HRESULT hr;
	LPDPLAYI_DPLAY this;
	
	this = DPLAY_FROM_INT(pISP);

	pmsgUpdate = (LPMSG_UPDATELIST)pReceiveBuffer;
	// set pbBufferIndex to point at the 1st updatenode
	pbBufferIndex = pReceiveBuffer + pmsgUpdate->dwUpdateListOffset;
	pbBufferEnd = pReceiveBuffer + dwTotalMessageSize;
	
	// walk the list of updatenodes
	while (pbBufferIndex < pbBufferEnd)
	{
		DWORD dwType = ((LPUPNODE_GENERIC)pbBufferIndex)->dwType ;
	
		if (dwType &  DPUPDATE_MESSAGE)
		{
			LPUPNODE_MESSAGE pupMessage = (LPUPNODE_MESSAGE)pbBufferIndex;
			LPMSG_PLAYERMESSAGE pmsg;
			DWORD dwMessageSize;
			
		   	dwMessageSize = pupMessage->dwUpdateSize - pupMessage->dwMessageOffset + sizeof(MSG_PLAYERMESSAGE);
			pmsg = DPMEM_ALLOC(dwMessageSize);
			if (!pmsg)
			{
				DPF_ERR("could not handle message update - out of memory");
				return E_OUTOFMEMORY;
			}
			
			// build a player-player message
			pmsg->idTo = pmsgUpdate->dwIDTo;
			pmsg->idFrom = pupMessage->idFrom;
			// TODO - can we get around this memcpy?
			memcpy( (LPBYTE)pmsg + sizeof(MSG_PLAYERMESSAGE), (LPBYTE)pupMessage 
				+ pupMessage->dwMessageOffset,pupMessage->dwUpdateSize - pupMessage->dwMessageOffset);
			
			// call handler to deal w/ it
			hr = DP_SP_HandleNonProtocolMessage(pISP,(LPBYTE)pmsg,dwMessageSize,DPSP_HEADER_LOCALMSG);
			if (FAILED(hr))				
			{
				ASSERT(FALSE);
			}
			
			DPMEM_FREE(pmsg);
			
			// advance buffer pointer
			pbBufferIndex +=  pupMessage->dwUpdateSize;
			
		}
			
		if (dwType &  DPUPDATE_CREATEPLAYER) 
		{
			LPUPDNODE_CREATEPLAYER pupMessage = (LPUPDNODE_CREATEPLAYER)pbBufferIndex;
		    DPLAYI_PACKEDPLAYER packed;
			LPDPLAYI_PLAYER pPlayer;
			
			pPlayer = PlayerFromID(this,pupMessage->dwID);
			if (!VALID_DPLAY_PLAYER(pPlayer))
			{
				// only unpack it if it's not already here...		    
				memset(&packed,0,sizeof(packed));
				packed.dwSize = sizeof(DPLAYI_PACKEDPLAYER);
				packed.dwFlags = pupMessage->dwFlags;
				packed.dwID = pupMessage->dwID;
				packed.dwFixedSize = sizeof(DPLAYI_PACKEDPLAYER);
				hr = UnpackPlayer(this,&packed,NULL,TRUE);
				if (FAILED(hr))					
				{
					ASSERT(FALSE);
				}
			}
			// advance buffer pointer
			pbBufferIndex +=  pupMessage->dwUpdateSize;
		}
		if (dwType &  DPUPDATE_DESTROYPLAYER) 
		{
			LPUPDNODE_CREATEPLAYER pupMessage = (LPUPDNODE_CREATEPLAYER)pbBufferIndex;
			MSG_PLAYERMGMTMESSAGE msg;
			
			if (this->pSysPlayer)	
			{
				SET_MESSAGE_HDR(&msg);
				SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYER);
				msg.dwPlayerID = pupMessage->dwID;
				msg.dwIDTo = this->pSysPlayer->dwID;
				// call handler to deal w/ it
				hr = DP_SP_HandleNonProtocolMessage(pISP,(LPBYTE)&msg,sizeof(msg),DPSP_HEADER_LOCALMSG);
				if (FAILED(hr))				
				{
					ASSERT(FALSE);
				}
			}
			// otherwise, ignore
			
			// advance buffer pointer
			pbBufferIndex +=  pupMessage->dwUpdateSize;
		}
	} // while
	

	return DP_OK;
} // HandleUpdateList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\daytona\makefile.inc ===
!ifdef PASS0ONLY
.SUFFIXES: .c
!endif

{..\..\common}.h{}.h:
    del /f $@
    copy $< $@
    touch $@

{..\..\common}.c{}.c:
    del /f $@
    copy $< $@
    touch $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\voice.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.c
 *  Content:	direct play voice method support
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *  10/21/97	andyco	   	created it
  ***************************************************************************/
		
					
#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "SendVoiceMessage"
HRESULT SendVoiceMessage(LPDPLAYI_DPLAY this,BOOL fOpen,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo)
{
	HRESULT hr = DP_OK;
	LPMSG_VOICE pmsg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
    
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_VOICE);
    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }

	// message follows header    
	pmsg = (LPMSG_VOICE)(pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);
	if (fOpen) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_VOICEOPEN);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_VOICECLOSE);
	
	pmsg->dwIDTo 	= pPlayerTo->dwID;
	pmsg->dwIDFrom 	= pPlayerFrom->dwID;
		
	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,dwMessageSize, DPSEND_GUARANTEED | DPSEND_ASYNC, FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"SendVoiceMessage : senddpmessage failed hr = 0x%08lx\n",hr);	
		// keep trying...
	}
	
	DPMEM_FREE(pSendBuffer);
		
	return hr;	
		
}  // SendVoiceMessage

HRESULT InternalCloseVoice(LPDPLAYI_DPLAY this,BOOL fPropagate)
{
    HRESULT hr = DP_OK;
	DPSP_CLOSEVOICEDATA cvd;
	LPDPLAYI_PLAYER pVoiceTo,pVoiceFrom;
	
	// make sure voice is open
	if (!this->pVoice)
	{
		DPF_ERR("voice channel not open!");
		return E_FAIL;
	}

	if (fPropagate) 
	{
		// 
		// we generated this message.  we need to tell sp.  
		// call SP if SP supports it 
		//
		if (this->pcbSPCallbacks->CloseVoice)
		{
			cvd.lpISP = this->pISP;
			cvd.dwFlags = 0;
		    hr = CALLSP(this->pcbSPCallbacks->CloseVoice,&cvd);
		    if (FAILED(hr)) 
		    {
				DPF_ERRVAL("SP Close voice call failed!  hr = 0x%08lx\n",hr);
				// keep going
				hr = DP_OK;
		    }
		}
		
		pVoiceTo = PlayerFromID(this,this->pVoice->idVoiceTo);
		if (!VALID_DPLAY_PLAYER(pVoiceTo)) 
		{
			DPF_ERR("could not send voice msg - invalid player to!");
			goto ERROR_EXIT;
		}

		pVoiceFrom = PlayerFromID(this,this->pVoice->idVoiceFrom);
		if (!VALID_DPLAY_PLAYER(pVoiceFrom)) 
		{
			DPF_ERR("could not send voice msg - invalid player From!");
			goto ERROR_EXIT;
		}

		hr = SendVoiceMessage(this, FALSE, pVoiceFrom,pVoiceTo);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SendVoiceMessage failed!  hr = 0x%08lx\n",hr);
			// keep trying!
			hr = DP_OK;
	    }
		
	} // fPropagate
	
ERROR_EXIT:
	
	// free up voice
	DPMEM_FREE(this->pVoice);
	this->pVoice = NULL;
	
	return DP_OK;	
}	// InternalCloseVoice


#undef DPF_MODNAME
#define DPF_MODNAME "DP_CloseVoice"
HRESULT DPAPI DP_CloseVoice(LPDIRECTPLAY lpDP,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;

	ENTER_SERVICE();
    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }

		// check flags
		if (dwFlags)
		{
			DPF_ERR("bad dwFlags");
            hr = DPERR_INVALIDFLAGS;
			goto CLEANUP_EXIT;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        hr = DPERR_INVALIDPARAMS;
		goto CLEANUP_EXIT;
    }

	hr = InternalCloseVoice( this, TRUE);

	// fall through
CLEANUP_EXIT:
	LEAVE_SERVICE();
    LEAVE_DPLAY();

	return hr;
	
} // DP_CloseVoice


#undef DPF_MODNAME
#define DPF_MODNAME "DP_OpenVoice"

HRESULT InternalOpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP pGroupTo = NULL; 
    LPDPLAYI_PLAYER pPlayerTo = NULL,pPlayerFrom = NULL;
	BOOL bToPlayer= FALSE;
	DPSP_OPENVOICEDATA ovd;
	LPDPVOICE pVoice;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }

		// check src player        
		pPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr = DPERR_INVALIDPLAYER;
			goto CLEANUP_EXIT;
		}

		// see if it's a player or group
		pPlayerTo = PlayerFromID(this,idTo);
		if (VALID_DPLAY_PLAYER(pPlayerTo)) 
		{		  
			bToPlayer = TRUE;
		}
		else 
		{
			pGroupTo = GroupFromID(this,idTo);
			if (VALID_DPLAY_GROUP(pGroupTo)) 
			{
				bToPlayer = FALSE;
				// cast to player...
				pPlayerTo = (LPDPLAYI_PLAYER)pGroupTo;
				// voice not supported to groups for DX6
				DPF_ERR("voice not supported to groups yet - FAILING OPEN VOICE");
				hr = E_NOTIMPL;
				goto CLEANUP_EXIT;
			}
			else 
			{
				// bogus id! - player may have been deleted...
				DPF_ERR("bad player to");
				hr = DPERR_INVALIDPARAMS;
				goto CLEANUP_EXIT;
			}// not player or group
		} // group

		// check flags
		if (dwFlags)
		{
			DPF_ERR("bad dwFlags");
            hr = DPERR_INVALIDFLAGS;
			goto CLEANUP_EXIT;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        hr = DPERR_INVALIDPARAMS;
		goto CLEANUP_EXIT;
    }

	// make sure they called Open w/ DPOPEN_VOICE
	if (!(this->dwFlags & DPLAYI_DPLAY_VOICE))
	{
		DPF_ERR("must call IDirectPlayX->Open w/ DPOPEN_VOICE to use OpenVoice!");
		hr = DPERR_UNAVAILABLE;
		goto CLEANUP_EXIT;
	}
	
	// can only have one voice 
	if (this->pVoice)
	{
		DPF_ERR("voice channel already open!");
		hr = DPERR_ALREADYINITIALIZED;
		goto CLEANUP_EXIT;
	}

	// make sure SP supports it 
	if (! (this->pcbSPCallbacks->OpenVoice) )
	{
		DPF_ERR("voice not supported by SP");
		hr = DPERR_UNSUPPORTED;
		goto CLEANUP_EXIT;
	}

	// if we're originating - make sure to + from are ok w/ voice
	if (fPropagate)	
	{
		// no voice open to local players
		if (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)	
		{
			DPF_ERR("voice not supported to local players");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}
		
		// no voice open from non-local players
		if (!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			DPF_ERR("voice not supported from non-local players");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}

		// make sure player to can accept calls	
		if (!pPlayerTo->dwFlags & DPLAYI_PLAYER_HASVOICE)
		{
			DPF_ERR("remote system does not support voice");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}
	}
	
	// go get us a dpvoice
	pVoice = DPMEM_ALLOC(sizeof(DPVOICE));
	if (!pVoice)
	{
		DPF_ERR("could not alloc internal voice struct! out of memory");
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	pVoice->idVoiceTo = idTo;
	pVoice->idVoiceFrom = idFrom;

		
	if (fPropagate)	
	{
		// set up voice data
		ovd.idTo = idTo;
		ovd.idFrom = idFrom;
		ovd.bToPlayer = bToPlayer;
		ovd.lpISP = this->pISP;

		// tell SP to start it up
	    hr = CALLSP(this->pcbSPCallbacks->OpenVoice,&ovd);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SP Open voice call failed!  hr = 0x%08lx\n",hr);
			// clean up the DPVOICE
			DPMEM_FREE(pVoice);
			goto CLEANUP_EXIT;
	    }

		hr = SendVoiceMessage(this, TRUE, pPlayerFrom,pPlayerTo ); 
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SendVoiceMessage failed!  hr = 0x%08lx\n",hr);
			// keep trying!
			hr = DP_OK;
	    }
	}

	// open succeeded - store dpvoice	
	this->pVoice = pVoice;

	// fall through
CLEANUP_EXIT:

	return hr;
    
	
} // InternalOpenVoice

HRESULT DPAPI DP_OpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags) 
{
	HRESULT hr;
	
	ENTER_DPLAY();
	ENTER_SERVICE();
	
	hr =  InternalOpenVoice(lpDP, idFrom,idTo,dwFlags,TRUE);
	
	LEAVE_DPLAY();
	LEAVE_SERVICE();
	
	return hr;	
} // DP_OpenVoice
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\update.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       update.h
 *  Content:	header for app server update handling
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/31/96	andyco	created
 ***************************************************************************/

#ifndef __DPUPDATE_INCLUDED__
#define __DPUPDATE_INCLUDED__


/*                      */
/* Handy Macro	 		*/
/*                      */

#define UPDATE_SIZE(pPlayer) (pPlayer->pbUpdateIndex - pPlayer->pbUpdateList)

/*                      */
/* Constants	 		*/
/*                      */

// we alloc this much for the updatelist	 
#define DPUPDATE_INITIALNODESIZE			1024

/*                      */
/* Update messages		*/
/*                      */

typedef struct _UPNODE_GENERIC
{
	DWORD 	dwType; // e.g. DPUPDATE_xxx
} UPNODE_GENERIC, * LPUPNODE_GENERIC;

typedef struct _UPNODE_MESSAGE
{
	DWORD 	dwType; // e.g. DPUPDATE_xxx
	DPID	idFrom;
	DWORD	dwUpdateSize; // total size of this update node
	DWORD	dwMessageOffset; // offset of message from beginning of node
} UPNODE_MESSAGE,* LPUPNODE_MESSAGE;

typedef struct _UPDNODE_CREATEPLAYER
{
	DWORD dwType; // e.g. DPUPDATE_xxx
	DPID  dwID; // id of new player
	DWORD dwFlags; // player flags
	DWORD dwUpdateSize; // total size of this update node
	// short name, long name, data, address follow, if specified
	// by DPUDPATE_FLAGS	
	
}  UPDNODE_CREATEPLAYER, *LPUPDNODE_CREATEPLAYER;

typedef struct _UPDNODE_DESTROYPLAYER
{									
	DWORD dwType; // e.g. DPUPDATE_xxx
	DPID  dwID; // id of deleted player
	DWORD dwUpdateSize; // total size of this update node
}  UPDNODE_DESTROYPLAYER, *LPUPDNODE_DESTROYPLAYER;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplay\handler.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       handler.c
 *  Content:	handles messages received by sp. 
 *
 *		function prefixes indicate which players execute code
 *			NS_	- executes on name server only
 *			SP_ - executed by sysplayer only
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/1/96		andyco	created it
 *	2/14/96		andyco	added user message support
 *	3/1/96		andyco	added user system messages
 *	4/12/96		andyco	added DPlay_xxx for sp's to call 
 *	4/25/96		andyco	added spblob space at end of msg's
 *	5/20/96		andyco	idirectplay2
 *	5/29/96		andyco	combined builbuildaddplayer and buildaddgroup into build add
 *	6/6/96		andyco	added namechanged,datachanged
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *	6/22/96		andyco	check guid + pw at server on enumsessoins
 *	6/22/96		andyco	check max players b4 giving out new player id
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	7/1/96		andyco	turned on xxxPlayerxxGroup messages.  these weren't
 *						being generated, and left us w/ a messagenode w/ a
 *						NULL message
 *	7/3/96		andyco	setting names in buildxxxmessage was not properly 
 *						setting the pointers.  Fixes RAID # 2200.
 *  7/8/96      ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                      to 'dpnName' to match DPLAY.H
 *                      Change DPSESSION_MIGRATENAMESERVER to DPSESSION_MIGRATEHOST
 *                      Change DPSYS_NAMESERVER to DPSYS_HOST
 *	7/10/96		andyco	turned on add_forward support for pending...
 *	7/10/96		kipo	renamed system messages
 *  7/30/96     kipo    player event is a handle now.
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *						handle YOUAREDEAD and session lost.
 *	8/8/96		andyco	added support for dpsession_nomessageid
 *  8/12/96		andyco	builddelete was pulling player off stack (unit'ed). duh.
 *	9/1/96		andyco	throw away player-player mess's from invalid players
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 * 10/11/96     sohailm added BuildSessionDescMessage() and SP_HandleSessionDescChanged()
 *                      added logic to handle DPSP_MSG_SESSIONDESCCHANGED message.
 * 10/12/96		andyco	don't count sysgroup in enumplayersreply
 * 11/12/96		andyco	support for server players - updatelist
 * 11/21/96		andyco	update perf data if this->pPerfData exists...
 * 01/16/97     sohailm name server doesn't respond to new id requests if session is
 *                      not allowing players (#4574)
 * 1/15/96		andyco	fixed handling of incoming messages to groups
 * 1/24/97		andyco	raid 4728 - don't crash if handle message gets a null message.
 * 1/28/97		andyco	transfer groups to nameserver when sysplayer owning group dies
 * 1/30/97      sohailm don't use size of message to identify version (#5504).
 *	2/1/97		andyco	don't memcpy player messages if we are in pending mode - 
 *						use the copy made by pending.c
 * 2/11/97		kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 * 2/26/97      sohailm update cached session descs on subsequent enumsessions (5838)
 *	3/5/97		andyco	timestamp enumsessions reply
 *	3/10/97		andyco	toggle pending mode when we have multiple local players.
 *						drop player mgmt messages when session is closed.
 * 3/12/97		myronth	Work around for global session list (hack)
 * 3/12/97      sohailm Integrated security into directplay
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 * 3/24/97      sohailm Updated EnumSessions to do the filtering on the server.
 *                      Added functionality for DPSESSION_PRIVATE and DPENUMSESSIONS_PASSWORDREQUIRED
 *                      Open now checks for a password and availability of the session
 * 3/25/97		kipo	treat zero-length password strings just like NULL password
 *						strings for DX3 compatability.
 * 3/30/97      sohailm Don't put pingreplys on the pending list.
 *                      Message signatures are not verified in execute pending mode anymore.
 * 4/04/97      sohailm Let pings through in pending mode, but only after downloading the nametable
 * 4/11/97		andyco	added domulticast
 * 4/14/97      sohailm Added support to handle encrypted messages.
 *	4/20/97		andyco	group in group 
 * 4/24/97      sohailm Now we deliver secure player-player messages as DPSYS_SECUREMESSAGE 
 *                      system messages.
 *	5/8/97		andyco	fixed 5893 - incorrectly homing on forwardaddplayer.  changed
 *						NS_HandleEnumPlayers to pack on client_server. removed updatelist.
 *	5/8/97		myronth	Build StartSession system message
 * 05/12/97     sohailm Now we send the entire DPSECURITYDESC in PLAYERIDREPLY.
 *                      Added support to process DPSP_MSG_KEYEXCHANGE.
 *	5/17/97		myronth Build and handle SendChatMessage system messages
 *	5/17/97		kipo	Make sure the ghReplyProcessed is reset
 *	5/18/97		andyco	add validatedplay on debug builds
 *  5/18/97     sohailm BuildSecureSystem() was not reporting the correct message size (8647).
 *	5/19/97		andyco	put bandaid on SP_HandlePlayerMgmtMessage
 *  5/21/97     sohailm Added InternalHandleMessage().
 *                      Now we pass DPSEND_SIGNED and DPSEND_ENCRYPTED in the secure player message
 *                      flags instead of DPSECURE_SIGNED and DPSECURE_ENCRYPTED.
 *	5/21/97		myronth	Change to correct DPMSG_CHAT format	(#8642)
 *	5/23/97		andyco	session desc goes w/ nametable.  added dplayi_dplay_handlemulticast
 *						so we correctly  locally process multicast forwards
 *	5/27/97		kipo	Add player flags to CreateGroup/Player and DestroyGroup/Player
 *	5/29/97		andyco	removed EXECUTING_PENDING optimization - too much grief
 *	5/30/97		kipo	added DPPLAYER_LOCAL
 *  6/09/97     sohailm Renamed DPSP_MSG_ACCESSDENIED to DPSP_MSG_LOGONDENIED.
 *  6/10/97     kipo	Put ping and ping reply messages on pending queue.
 *  6/16/97     sohailm Updated calls to HandleAuthenticationReply() to take message size.
 *  6/23/97     sohailm Updated InternalHandleMessage() to check the flags on secure messages.
 *	7/30/97		myronth	Added use of dwReserved fields in StartSession message for
 *						standard lobby messaging to work correctly
 *  7/31/97		sohailm	Added peer-peer message security using multicast.
 *   8/4/97		andyco	added support for async add forward
 *	8/29/97		sohailm GPF in NS_DoAsyncAddForward when modem sp is loaded (bug #12459).
 *	10/21/97	myronth	Added support for hidden group flag
 *	10/29/97	myronth	Added BuildGroupOwnerChangedMessage and case statement for it
 *	11/5/97		myronth	Removed bogus (also unneeded) prototype
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/5/97		andyco	voice stuff
 *	12/29/97	myronth	Nametable corruption related fix -- don't queue msgs
 *						for remote stuff which doesn't affect the nametable
 *	12/30/97	sohailm	DPSYSMSG_SESSIONLOST does not cause player event to be set (#16141)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/27/98		myronth	Delete remote players/groups on sessionlost (#15255)
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  3/19/98     aarono  Added prenotification of pending DELETEPLAYER messages
 *                      so the protocol can bail on ongoing sends to that player
 *	3/23/98     aarono  Now ADDFORWARD is spoofed from ADDFORWARDREQ
 *  3/31/98     aarono  backout ADDFORWARD spoof
 *  4/1/98      aarono  flag players that don't have nametable, don't send to them
 *  6/6/98      aarono  Fix for handling large loopback messages with protocol
 *  6/19/98 	aarono  add last ptr for message queues, makes insert
 *              	    constant time instead of O(n) where n is number
 *                	    of messages in queue.
 *
 ****************************************************************************/

// todo - send fail message on max players

#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"

// #define this on to make DIE_PIGGY DEBUG_BREAK();
#undef DIE_PIG
  
// globals to hold buffer for enum players and new player id replies
LPBYTE gpRequestPlayerBuffer, gpEnumPlayersReplyBuffer;
LPVOID gpvEnumPlayersHeader;
BOOL gbWaitingForReply=FALSE;
BOOL gbWaitingForEnumReply=FALSE;

#undef DPF_MODNAME
#define DPF_MODNAME	"DoReply"

// called by PacketizeAndSend and ns_handlexxx	
HRESULT DoReply(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	LPVOID pvMessageHeader, DWORD dwReplyToVersion)
{
	DPSP_REPLYDATA rd;
	HRESULT hr;

	if(!dwReplyToVersion){

		if (!this->pSysPlayer)
		{
			DPF(1,"Reply - session not currently open - failing");
			return E_FAIL;
		}
		ASSERT(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
		ASSERT(!(this->dwFlags & DPLAYI_DPLAY_SESSIONLOST));
	} else {
		// doing reply for reliability (ACK) 
	}

	// do we need to packetize for reliability?
	if(this->dwFlags & DPLAYI_DPLAY_SPUNRELIABLE) // quick test
	{
		DWORD dwCommand;
		dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pSendBuffer+this->dwSPHeaderSize));

		if(NeedsReliablePacketize(this, dwCommand, dwReplyToVersion, DPSEND_GUARANTEED)){
			DPF(3,"reply :: message needs reliable delivery - packetizing with reliablility");
			hr = PacketizeAndSendReliable(this,NULL,NULL,pSendBuffer,dwMessageSize,0,
				pvMessageHeader,TRUE);
			return hr;
		}
	}

//	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)); BUGBUG:???
	
	// do we need to packetize for size?
	if (dwMessageSize > ((this->pProtocol)?(this->pProtocol->m_dwSPMaxGuaranteed):(this->dwSPMaxMessageGuaranteed)))
	{
		DPF(3,"reply :: message too big - packetizing");
		hr = PacketizeAndSend(this,NULL,NULL,pSendBuffer,dwMessageSize,0,
			pvMessageHeader,TRUE);
		return hr;
	}

    // call sp
    if (this->pcbSPCallbacks->Reply) 
    {
		rd.lpSPMessageHeader = pvMessageHeader;
		rd.lpMessage = pSendBuffer;
		rd.dwMessageSize = dwMessageSize;
		if(this->pSysPlayer){ 
	        rd.idNameServer = this->pSysPlayer->dwID;
	    } else {
			// we need to reply before we know the nameserver for ACKs on reliability.
	    	rd.idNameServer = 0;
	    }
    	rd.lpISP = this->pISP;

	 	hr = CALLSP(this->pcbSPCallbacks->Reply,&rd);    	
    }
	else 
	{
		hr = E_FAIL;
		ASSERT(FALSE); // no callback?
	}

	if (DPERR_SESSIONLOST == hr)
	{
		DPF_ERR(" got session lost back from SP ");
		hr = HandleSessionLost(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	return hr;

} // DoReply

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_HANDLER"
// a client wants us to send a multicast for them
HRESULT DoMulticast(LPDPLAYI_DPLAY this,LPMSG_ASK4MULTICAST pmcast,DWORD dwBufferSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPBYTE pmsg; // multicast message + header
	HRESULT hr;
	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_GROUP pGroupTo;
	DWORD dwCommand = 0;
	DWORD dwVersion;
	DWORD dwMessageSize;
	
	ASSERT(this->pSysPlayer);
	ASSERT(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(this->lpsdDesc);
	ASSERT(this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER);
	
	pms